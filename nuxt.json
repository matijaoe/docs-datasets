[
  {
    "title": "$fetch · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/dollarfetch",
    "html": "Utils\n$fetch\nSource\n\nNuxt uses ofetch to expose globally the $fetch helper for making HTTP requests.\n\nNuxt uses ofetch to expose globally the $fetch helper for making HTTP requests within your Vue app or API routes.\n\nDuring server-side rendering, calling $fetch to fetch your internal API routes will directly call the relevant function (emulating the request), saving an additional API call.\nUsing $fetch in components without wrapping it with useAsyncData causes fetching the data twice: initially on the server, then again on the client-side during hydration, because $fetch does not transfer state from the server to the client. Thus, the fetch will be executed on both sides because the client has to get the data again.\n\nWe recommend to use useFetch or useAsyncData + $fetch to prevent double data fetching when fetching the component data.\n\napp.vue\n<script setup lang=\"ts\">\n\n// During SSR data is fetched twice, once on the server and once on the client.\n\nconst dataTwice = await $fetch('/api/item')\n\n\n\n// During SSR data is fetched only on the server side and transferred to the client.\n\nconst { data } = await useAsyncData('item', () => $fetch('/api/item'))\n\n\n\n// You can also useFetch as shortcut of useAsyncData + $fetch\n\nconst { data } = await useFetch('/api/item')\n\n</script>\n\n Read more in Docs > Getting Started > Data Fetching.\n\nYou can use $fetch for any method that are executed only on client-side.\n\npages/contact.vue\n<script setup lang=\"ts\">\n\nfunction contactForm() {\n\n  $fetch('/api/contact', {\n\n    method: 'POST',\n\n    body: { hello: 'world '}\n\n  })\n\n}\n\n</script>\n\n\n\n<template>\n\n  <button @click=\"contactForm\">Contact</button>\n\n</template>\n\n$fetch is the preferred way to make HTTP calls in Nuxt instead of @nuxt/http and @nuxtjs/axios that are made for Nuxt 2.\n\nuseState\n\nThe useState composable creates a reactive and SSR-friendly shared state.\n\nabortNavigation\n\nabortNavigation is a helper function that prevents navigation from taking place and throws an error if one is set as a parameter."
  },
  {
    "title": "Migrate to Nuxt Bridge: Overview",
    "url": "https://nuxt.com/docs/bridge/overview",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nOverview\n\nReduce the differences with Nuxt 3 and reduce the burden of migration to Nuxt 3.\n\nIf you're starting a fresh Nuxt 3 project, please skip this section and go to Nuxt 3 Installation.\nNuxt Bridge provides identical features to Nuxt 3 (docs) but there are some limitations, notably that useAsyncData and useFetch composables are not available. Please read the rest of this page for details.\n\nBridge is a forward-compatibility layer that allows you to experience many of the new Nuxt 3 features by simply installing and enabling a Nuxt module.\n\nUsing Nuxt Bridge, you can make sure your project is (almost) ready for Nuxt 3 and you can gradually proceed with the transition to Nuxt 3.\n\nFirst Step\nUpgrade Nuxt 2\n\nMake sure your dev server (nuxt dev) isn't running, remove any package lock files (package-lock.json and yarn.lock), and install the latest Nuxt 2 version:\n\npackage.json\n- \"nuxt\": \"^2.16.3\"\n\n+ \"nuxt\": \"^2.17.0\"\n\n\nThen, reinstall your dependencies:\n\nyarn\nnpm\nyarn install\n\nOnce the installation is complete, make sure both development and production builds are working as expected before proceeding.\nInstall Nuxt Bridge\n\nInstall @nuxt/bridge-edge as a development dependency:\n\nYarn\nnpm\nyarn add --dev @nuxt/bridge@npm:@nuxt/bridge-edge\n\nUpdate nuxt.config\n\nPlease make sure to avoid any CommonJS syntax such as module.exports, require or require.resolve in your config file. It will soon be deprecated and unsupported.\n\nYou can use static import, dynamic import() and export default instead. Using TypeScript by renaming to nuxt.config.ts is also possible and recommended.\n\nnuxt.config.ts\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\n\n\nexport default defineNuxtConfig({\n\n  bridge: false\n\n})\n\nUpdate Commands\n\nThe nuxt command should now be changed to the nuxt2 command.\n\n{\n\n  \"scripts\": {\n\n-   \"dev\": \"nuxt\",\n\n+   \"dev\": \"nuxt2\",\n\n-   \"build\": \"nuxt build\",\n\n+   \"build\": \"nuxt2 build\",\n\n-   \"start\": \"nuxt start\",\n\n+   \"start\": \"nuxt2 start\"\n\n  }\n\n}\n\n\nTry running nuxt2 once here. You will see that the application works as before.\n\n(If 'bridge' is set to false, your application will operate without any changes as before.)\n\nUpgrade Steps\n\nWith Nuxt Bridge, the migration to Nuxt 3 can proceed in steps. The below Upgrade Steps does not need to be done all at once.\n\nTypeScript\nMigrate Legacy Composition API\nPlugins and Middleware\nMigrate New Composition API\nMeta Tags\nRuntime Config\nNitro\nVite\nMigrate from CommonJS to ESM\n\nNuxt 3 natively supports TypeScript and ECMAScript Modules. Please check Native ES Modules for more info and upgrading.\n\nReleases\n\nDiscover the latest releases of Nuxt & Nuxt official modules.\n\nTypeScript\n\nLearn how to use TypeScript with Nuxt Bridge."
  },
  {
    "title": "useServerSeoMeta · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-server-seo-meta",
    "html": "Composables\nuseServerSeoMeta\nSource\n\nThe useServerSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.\n\nJust like useSeoMeta, useServerSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.\n\n Read more in Docs > API > Composables > Use Seo Meta.\n\nIn most instances, the meta doesn't need to be reactive as robots will only scan the initial load. So we recommend using useServerSeoMeta as a performance-focused utility that will not do anything (or return a head object) on the client.\n\napp.vue\n<script setup lang=\"ts\">\n\nuseServerSeoMeta({\n\n  robots: 'index, follow'\n\n})\n\n</script>\n\n\nParameters are exactly the same as with useSeoMeta\n\n Read more in Docs > Getting Started > Seo Meta.\n\nuseSeoMeta\n\nThe useSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.\n\nuseState\n\nThe useState composable creates a reactive and SSR-friendly shared state."
  },
  {
    "title": "Lifecycle Hooks · Nuxt API",
    "url": "https://nuxt.com/docs/api/advanced/hooks",
    "html": "Advanced\nLifecycle Hooks\n\nNuxt provides a powerful hooking system to expand almost every aspect using hooks.\n\n Read more in Docs > Guide > Going Further > Hooks.\nApp Hooks (runtime)\n\nCheck the app source code for all available hooks.\n\nHook\tArguments\tEnvironment\tDescription\napp:created\tvueApp\tServer & Client\tCalled when initial vueApp instance is created.\napp:error\terr\tServer & Client\tCalled when a fatal error occurs.\napp:error:cleared\t{ redirect? }\tServer & Client\tCalled when a fatal error occurs.\napp:data:refresh\tkeys?\tServer & Client\t(internal)\nvue:setup\t-\tServer & Client\t(internal)\nvue:error\terr, target, info\tServer & Client\tCalled when a vue error propagates to the root component. Learn More.\napp:rendered\trenderContext\tServer\tCalled when SSR rendering is done.\napp:redirected\t-\tServer\tCalled before SSR redirection.\napp:beforeMount\tvueApp\tClient\tCalled before mounting the app, called only on client side.\napp:mounted\tvueApp\tClient\tCalled when Vue app is initialized and mounted in browser.\napp:suspense:resolve\tappComponent\tClient\tOn Suspense resolved event.\nlink:prefetch\tto\tClient\tCalled when a <NuxtLink> is observed to be prefetched.\npage:start\tpageComponent?\tClient\tCalled on Suspense pending event.\npage:finish\tpageComponent?\tClient\tCalled on Suspense resolved event.\npage:transition:finish\tpageComponent?\tClient\tAfter page transition onAfterLeave event.\nNuxt Hooks (build time)\n\nCheck the schema source code for all available hooks.\n\nHook\tArguments\tDescription\nkit:compatibility\tcompatibility, issues\tAllows extending compatibility checks.\nready\tnuxt\tCalled after Nuxt initialization, when the Nuxt instance is ready to work.\nclose\tnuxt\tCalled when Nuxt instance is gracefully closing.\nrestart\t{ hard?: boolean }\tTo be called to restart the current Nuxt instance.\nmodules:before\t-\tCalled during Nuxt initialization, before installing user modules.\nmodules:done\t-\tCalled during Nuxt initialization, after installing user modules.\napp:resolve\tapp\tCalled after resolving the app instance.\napp:templates\tapp\tCalled during NuxtApp generation, to allow customizing, modifying or adding new files to the build directory (either virtually or to written to .nuxt).\napp:templatesGenerated\tapp\tCalled after templates are compiled into the virtual file system (vfs).\nbuild:before\t-\tCalled before Nuxt bundle builder.\nbuild:done\t-\tCalled after Nuxt bundle builder is complete.\nbuild:manifest\tmanifest\tCalled during the manifest build by Vite and webpack. This allows customizing the manifest that Nitro will use to render <script> and <link> tags in the final HTML.\nbuilder:generateApp\toptions\tCalled before generating the app.\nbuilder:watch\tevent, path\tCalled at build time in development when the watcher spots a change to a file or directory in the project.\npages:extend\tpages\tCalled after pages routes are resolved.\nserver:devHandler\thandler\tCalled when the dev middleware is being registered on the Nitro dev server.\nimports:sources\tpresets\tCalled at setup allowing modules to extend sources.\nimports:extend\timports\tCalled at setup allowing modules to extend imports.\nimports:context\tcontext\tCalled when the unimport context is created.\nimports:dirs\tdirs\tAllows extending import directories.\ncomponents:dirs\tdirs\tCalled within app:resolve allowing to extend the directories that are scanned for auto-importable components.\ncomponents:extend\tcomponents\tAllows extending new components.\nnitro:config\tnitroConfig\tCalled before initializing Nitro, allowing customization of Nitro's configuration.\nnitro:init\tnitro\tCalled after Nitro is initialized, which allows registering Nitro hooks and interacting directly with Nitro.\nnitro:build:before\tnitro\tCalled before building the Nitro instance.\nnitro:build:public-assets\tnitro\tCalled after copying public assets. Allows modifying public assets before Nitro server is built.\nprerender:routes\tctx\tAllows extending the routes to be pre-rendered.\nbuild:error\terror\tCalled when an error occurs at build time.\nprepare:types\toptions\tCalled before Nuxi writes .nuxt/tsconfig.json and .nuxt/nuxt.d.ts, allowing addition of custom references and declarations in nuxt.d.ts, or directly modifying the options in tsconfig.json\nlisten\tlistenerServer, listener\tCalled when the dev server is loading.\nschema:extend\tschemas\tAllows extending default schemas.\nschema:resolved\tschema\tAllows extending resolved schema.\nschema:beforeWrite\tschema\tCalled before writing the given schema.\nschema:written\t-\tCalled after the schema is written.\nvite:extend\tviteBuildContext\tAllows to extend Vite default context.\nvite:extendConfig\tviteInlineConfig, env\tAllows to extend Vite default config.\nvite:configResolved\tviteInlineConfig, env\tAllows to read the resolved Vite config.\nvite:serverCreated\tviteServer, env\tCalled when the Vite server is created.\nvite:compiled\t-\tCalled after Vite server is compiled.\nwebpack:config\twebpackConfigs\tCalled before configuring the webpack compiler.\nwebpack:configResolved\twebpackConfigs\tAllows to read the resolved webpack config.\nwebpack:compile\toptions\tCalled right before compilation.\nwebpack:compiled\toptions\tCalled after resources are loaded.\nwebpack:change\tshortPath\tCalled on change on WebpackBar.\nwebpack:error\t-\tCalled on done if has errors on WebpackBar.\nwebpack:done\t-\tCalled on allDone on WebpackBar.\nwebpack:progress\tstatesArray\tCalled on progress on WebpackBar.\nNitro App Hooks (runtime, server-side)\n\nSee Nitro for all available hooks.\n\nHook\tArguments\tDescription\tTypes\nrender:response\tresponse, { event }\tCalled before sending the response.\tresponse, event\nrender:html\thtml, { event }\tCalled before constructing the HTML.\thtml, event\nrender:island\tislandResponse, { event, islandContext }\tCalled before constructing the island HTML.\tislandResponse, event, islandContext\nclose\t-\tCalled when Nitro is closed.\t-\nerror\terror, { event? }\tCalled when an error occurs.\terror, event\nrequest\tevent\tCalled when a request is received.\tevent\nbeforeResponse\tevent, { body }\tCalled before sending the response.\tevent, unknown\nafterResponse\tevent, { body }\tCalled after sending the response.\tevent, unknown\n\nExamples\n\nExamples of Nuxt Kit utilities in use.\n\nImport meta\n\nUnderstand where your code is running using `import.meta`."
  },
  {
    "title": "Migrate to Nuxt Bridge: Configuration",
    "url": "https://nuxt.com/docs/bridge/configuration",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nConfiguration\n\nLearn how to configure Nuxt Bridge to your own needs.\n\nFeature Flags\n\nYou can optionally disable some features from bridge or opt-in to less stable ones. In normal circumstances, it is always best to stick with defaults!\n\nYou can check bridge/src/module.ts for latest defaults.\n\nnuxt.config.ts\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\nexport default defineNuxtConfig({\n\n  bridge: {\n\n\n\n    // -- Opt-in features --\n\n\n\n    // Use Vite as the bundler instead of webpack 4\n\n    // vite: true,\n\n\n\n    // Enable Nuxt 3 compatible useHead\n\n    // meta: true,\n\n\n\n    // -- Default features --\n\n\n\n    // Use legacy server instead of Nitro\n\n    // nitro: false,\n\n\n\n    // Disable Nuxt 3 compatible `nuxtApp` interface\n\n    // app: false,\n\n\n\n    // Disable Composition API support\n\n    // capi: false,\n\n\n\n    // ... or just disable legacy Composition API support\n\n    // capi: {\n\n    //   legacy: false\n\n    // },\n\n\n\n    // Do not transpile modules\n\n    // transpile: false,\n\n\n\n    // Disable <script setup> support\n\n    // scriptSetup: false,\n\n\n\n    // Disable composables auto importing\n\n    // imports: false,\n\n\n\n    // Do not warn about module incompatibilities\n\n    // constraints: false\n\n  },\n\n\n\n  vite: {\n\n    // Config for Vite\n\n  }\n\n})\n\nMigration of each option\nrouter.base\nexport default defineNuxtConfig({\n\n- router: {\n\n-   base: '/my-app/'\n\n- }\n\n+ app: {\n\n+   baseURL: '/my-app/'\n\n+ }\n\n})\n\nbuild.publicPath\nexport default defineNuxtConfig({\n\n- build: {\n\n-   publicPath: 'https://my-cdn.net'\n\n- }\n\n+ app: {\n\n+   cdnURL: 'https://my-cdn.net'\n\n+ }\n\n})\n\n\nVite\n\nActivate Vite to your Nuxt 2 application with Nuxt Bridge.\n\nOverview\n\nNuxt 3 is a complete rewrite of Nuxt 2, and also based on a new set of underlying technologies."
  },
  {
    "title": "Migrate to Nuxt Bridge: Vite",
    "url": "https://nuxt.com/docs/bridge/vite",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nVite\n\nActivate Vite to your Nuxt 2 application with Nuxt Bridge.\n\nWhen using vite, nitro must have been configured.\nRemove Modules\nRemove nuxt-vite: Bridge enables same functionality\nUpdate Config\nnuxt.config.ts\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\n\n\nexport default defineNuxtConfig({\n\n  bridge: {\n\n    vite: true,\n\n    nitro: true\n\n  }\n\n})\n\nConfiguration\nnuxt.config.ts\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\n\n\nexport default defineNuxtConfig({\n\n  vite: {\n\n    // Config for Vite\n\n  }\n\n})\n\n\nNitro\n\nActivate Nitro to your Nuxt 2 application with Nuxt Bridge.\n\nConfiguration\n\nLearn how to configure Nuxt Bridge to your own needs."
  },
  {
    "title": "Migrate to Nuxt Bridge: Runtime Config",
    "url": "https://nuxt.com/docs/bridge/runtime-config",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nRuntime Config\n\nNuxt provides a runtime config API to expose configuration and secrets within your application.\n\nWhen using runtimeConfig option, nitro must have been configured.\nUpdate Runtime Config\n\nNuxt 3 approaches runtime config differently than Nuxt 2, using a new combined runtimeConfig option.\n\nFirst, you'll need to combine your publicRuntimeConfig and privateRuntimeConfig properties into a new one called runtimeConfig, with the public config within a key called public.\n\n// nuxt.config.js\n\n- privateRuntimeConfig: {\n\n-   apiKey: process.env.NUXT_API_KEY || 'super-secret-key'\n\n- },\n\n- publicRuntimeConfig: {\n\n-   websiteURL: 'https://public-data.com'\n\n- }\n\n+ runtimeConfig: {\n\n+   apiKey: process.env.NUXT_API_KEY || 'super-secret-key',\n\n+   public: {\n\n+     websiteURL: 'https://public-data.com'\n\n+   }\n\n+ }\n\n\nThis also means that when you need to access public runtime config, it's behind a property called public. If you use public runtime config, you'll need to update your code.\n\n// MyWidget.vue\n\n- <div>Website: {{ $config.websiteURL }}</div>\n\n+ <div>Website: {{ $config.public.websiteURL }}</div>\n\n\nMeta Tags\n\nLearn how to migrate from Nuxt 2 to Nuxt Bridge new meta tags.\n\nNitro\n\nActivate Nitro to your Nuxt 2 application with Nuxt Bridge."
  },
  {
    "title": "Migrate to Nuxt Bridge: Meta Tags",
    "url": "https://nuxt.com/docs/bridge/meta",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nMeta Tags\n\nLearn how to migrate from Nuxt 2 to Nuxt Bridge new meta tags.\n\nIf you need to access the component state with head, you should migrate to using useHead .\n\nIf you need to use the Options API, there is a head() method you can use when you use defineNuxtComponent.\n\nMigration\nSet bridge.meta\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\nexport default defineNuxtConfig({\n\n  bridge: {\n\n    meta: true,\n\n    nitro: false // If migration to Nitro is complete, set to true\n\n  }\n\n})\n\nUpdate head properties\n\nIn your nuxt.config, rename head to meta. (Note that objects no longer have a hid key for deduplication.)\n\nNuxt 2\nNuxt 3\nexport default {\n\n  head: {\n\n    titleTemplate: '%s - Nuxt',\n\n    meta: [\n\n      { charset: 'utf-8' },\n\n      { name: 'viewport', content: 'width=device-width, initial-scale=1' },\n\n      { hid: 'description', name: 'description', content: 'Meta description' }\n\n    ]\n\n  }\n\n}\n\nuseHead Composables\n\nNuxt Bridge provides a new Nuxt 3 meta API that can be accessed with a new useHead composable.\n\n<script setup lang=\"ts\">\n\nuseHead({\n\n  title: 'My Nuxt App',\n\n})\n\n</script>\n\nThis useHead composable uses @unhead/vue under the hood (rather than vue-meta) to manipulate your <head>.\nWe recommend not using the native Nuxt 2 head() properties in addition to useHead , as they may conflict.\n\nFor more information on how to use this composable, see the docs.\n\nOptions API\n<script>\n\n// if using options API `head` method you must use `defineNuxtComponent`\n\nexport default defineNuxtComponent({\n\n  head (nuxtApp) {\n\n    // `head` receives the nuxt app but cannot access the component instance\n\n    return {\n\n      meta: [{\n\n        name: 'description',\n\n        content: 'This is my page description.'\n\n      }]\n\n    }\n\n  }\n\n})\n\n</script>\n\nTitle Template\n\nIf you want to use a function (for full control), then this cannot be set in your nuxt.config, and it is recommended instead to set it within your /layouts directory.\n\nlayouts/default.vue\n<script setup lang=\"ts\">\n\nuseHead({\n\n  titleTemplate: (titleChunk) => {\n\n    return titleChunk ? `${titleChunk} - Site Title` : 'Site Title';\n\n  }\n\n})\n\n</script>\n\n\nNew Composition API\n\nNuxt Bridge implements composables compatible with Nuxt 3.\n\nRuntime Config\n\nNuxt provides a runtime config API to expose configuration and secrets within your application."
  },
  {
    "title": "Migrate to Nuxt Bridge: Nitro",
    "url": "https://nuxt.com/docs/bridge/nitro",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nNitro\n\nActivate Nitro to your Nuxt 2 application with Nuxt Bridge.\n\nRemove Modules\nRemove @nuxt/nitro: Bridge injects same functionality\nUpdate Config\nnuxt.config.ts\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\n\n\nexport default defineNuxtConfig({\n\n  bridge: {\n\n    nitro: true\n\n  }\n\n})\n\nUpdate Your Scripts\n\nYou will also need to update your scripts within your package.json to reflect the fact that Nuxt will now produce a Nitro server as build output.\n\nInstall Nuxi\n\nInstall nuxi as a development dependency:\n\nyarn\nnpm\nyarn add --dev nuxi\n\nNuxi\n\nNuxt 3 introduced the new Nuxt CLI command nuxi. Update your scripts as follows to leverage the better support from Nuxt Bridge:\n\n{\n\n  \"scripts\": {\n\n-   \"dev\": \"nuxt\",\n\n+   \"dev\": \"nuxi dev\",\n\n-   \"build\": \"nuxt build\",\n\n+   \"build\": \"nuxi build\",\n\n-   \"start\": \"nuxt start\",\n\n+   \"start\": \"nuxi preview\"\n\n  }\n\n}\n\nIf nitro: false, use the nuxt2 command.\nStatic Target\n\nIf you have set target: 'static' in your nuxt.config then you need to ensure that you update your build script to be nuxi generate.\n\npackage.json\n{\n\n  \"scripts\": {\n\n    \"build\": \"nuxi generate\"\n\n  }\n\n}\n\nServer Target\n\nFor all other situations, you can use the nuxi build command.\n\npackage.json\n{\n\n  \"scripts\": {\n\n    \"build\": \"nuxi build\",\n\n    \"start\": \"nuxi preview\"\n\n  }\n\n}\n\nExclude Built Nitro Folder From Git\n\nAdd the folder .output to the .gitignore file.\n\nEnsure Everything Goes Well\n\n✔️ Try with nuxi dev and nuxi build (or nuxi generate) to see if everything goes well.\n\nRuntime Config\n\nNuxt provides a runtime config API to expose configuration and secrets within your application.\n\nVite\n\nActivate Vite to your Nuxt 2 application with Nuxt Bridge."
  },
  {
    "title": "Migrate to Nuxt Bridge: New Composition API",
    "url": "https://nuxt.com/docs/bridge/nuxt3-compatible-api",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nNew Composition API\n\nNuxt Bridge implements composables compatible with Nuxt 3.\n\nBy migrating from @nuxtjs/composition-api to the Nuxt 3 compatible API, there will be less rewriting when migrating to Nuxt 3.\n\nssrRef and shallowSsrRef\n\nThese two functions have been replaced with a new composable that works very similarly under the hood: useState.\n\nThe key differences are that you must provide a key for this state (which Nuxt generated automatically for ssrRef and shallowSsrRef), and that it can only be called within a Nuxt 3 plugin (which is defined by defineNuxtPlugin) or a component instance. (In other words, you cannot use useState with a global/ambient context, because of the danger of shared state across requests.)\n\n- import { ssrRef } from '@nuxtjs/composition-api'\n\n\n\n- const ref1 = ssrRef('initialData')\n\n- const ref2 = ssrRef(() => 'factory function')\n\n+ const ref1 = useState('ref1-key', () => 'initialData')\n\n+ const ref2 = useState('ref2-key', () => 'factory function')\n\n  // accessing the state\n\n  console.log(ref1.value)\n\n\nBecause the state is keyed, you can access the same state from multiple locations, as long as you are using the same key.\n\nYou can read more about how to use this composable in the Nuxt 3 docs.\n\nssrPromise\n\nThis function has been removed, and you will need to find an alternative implementation if you were using it. If you have a use case for ssrPromise, please let us know via a discussion.\n\nonGlobalSetup\n\nThis function has been removed, but its use cases can be met by using useNuxtApp or useState within defineNuxtPlugin. You can also run any custom code within the setup() function of a layout.\n\n- import { onGlobalSetup } from '@nuxtjs/composition-api'\n\n\n\n- export default () => {\n\n-   onGlobalSetup(() => {\n\n+ export default defineNuxtPlugin((nuxtApp) => {\n\n+   nuxtApp.hook('vue:setup', () => {\n\n      // ...\n\n    })\n\n- }\n\n+ })\n\nuseStore\n\nIn order to access Vuex store instance, you can use useNuxtApp().$store.\n\n- import { useStore } from '@nuxtjs/composition-api`\n\n+ const { $store } = useNuxtApp()\n\nuseContext and withContext\n\nYou can access injected helpers using useNuxtApp.\n\n- import { useContext } from '@nuxtjs/composition-api`\n\n+ const { $axios } = useNuxtApp()\n\nuseNuxtApp() also provides a key called nuxt2Context which contains all the same properties you would normally access from Nuxt 2 context, but it's advised not to use this directly, as it won't exist in Nuxt 3. Instead, see if there is another way to access what you need. (If not, please raise a feature request or discussion.)\nwrapProperty\n\nThis helper function is not provided any more but you can replace it with the following code:\n\nconst wrapProperty = (property, makeComputed = true) => () => {\n\n  const vm = getCurrentInstance().proxy\n\n  return makeComputed ? computed(() => vm[property]) : vm[property]\n\n}\n\nuseAsync and useFetch\n\nThese two composables can be replaced with useLazyAsyncData and useLazyFetch, which are documented in the Nuxt 3 docs. Just like the previous @nuxtjs/composition-api composables, these composables do not block route navigation on the client-side (hence the 'lazy' part of the name).\n\nNote that the API is entirely different, despite similar sounding names. Importantly, you should not attempt to change the value of other variables outside the composable (as you may have been doing with the previous useFetch).\nThe useLazyFetch must have been configured for Nitro.\n\nMigrating to the new composables from useAsync:\n\n<script setup>\n\n- import { useAsync } from '@nuxtjs/composition-api'\n\n- const posts = useAsync(() => $fetch('/api/posts'))\n\n+ const { data: posts } = useLazyAsyncData('posts', () => $fetch('/api/posts'))\n\n+ // or, more simply!\n\n+ const { data: posts } = useLazyFetch('/api/posts')\n\n</script>\n\n\nMigrating to the new composables from useFetch:\n\n<script setup>\n\n- import { useFetch } from '@nuxtjs/composition-api'\n\n- const posts = ref([])\n\n- const { fetch } = useFetch(() => { posts.value = await $fetch('/api/posts') })\n\n+ const { data: posts, refresh } = useLazyAsyncData('posts', () => $fetch('/api/posts'))\n\n+ // or, more simply!\n\n+ const { data: posts, refresh } = useLazyFetch('/api/posts')\n\n  function updatePosts() {\n\n-   return fetch()\n\n+   return refresh()\n\n  }\n\n</script>\n\nuseMeta\n\nIn order to interact with vue-meta, you may use useNuxt2Meta, which will work in Nuxt Bridge (but not Nuxt 3) and will allow you to manipulate your meta tags in a vue-meta-compatible way.\n\n<script setup>\n\n- import { useMeta } from '@nuxtjs/composition-api'\n\n  useNuxt2Meta({\n\n    title: 'My Nuxt App',\n\n  })\n\n</script>\n\n\nYou can also pass in computed values or refs, and the meta values will be updated reactively:\n\n<script setup>\n\nconst title = ref('my title')\n\nuseNuxt2Meta({\n\n  title,\n\n})\n\ntitle.value = 'new title'\n\n</script>\n\nBe careful not to use both useNuxt2Meta() and the Options API head() within the same component, as behavior may be unpredictable.\n\nNuxt Bridge also provides a Nuxt 3-compatible meta implementation that can be accessed with the useHead composable.\n\n<script setup>\n\n- import { useMeta } from '@nuxtjs/composition-api'\n\n  useHead({\n\n    title: 'My Nuxt App',\n\n  })\n\n</script>\n\n\nYou will also need to enable it explicitly in your nuxt.config:\n\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\nexport default defineNuxtConfig({\n\n  bridge: {\n\n    meta: true\n\n  }\n\n})\n\n\nThis useHead composable uses @unhead/vue under the hood (rather than vue-meta) to manipulate your <head>. Accordingly, it is recommended not to use both the native Nuxt 2 head() properties as well as useHead , as they may conflict.\n\nFor more information on how to use this composable, see the Nuxt 3 docs.\n\nExplicit Imports\n\nNuxt exposes every auto-import with the #imports alias that can be used to make the import explicit if needed:\n\n<script setup lang=\"ts\">\n\nimport { ref, computed } from '#imports'\n\n\n\nconst count = ref(1)\n\nconst double = computed(() => count.value * 2)\n\n</script>\n\nDisabling Auto-imports\n\nIf you want to disable auto-importing composables and utilities, you can set imports.autoImport to false in the nuxt.config file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    autoImport: false\n\n  }\n\n})\n\n\nThis will disable auto-imports completely but it's still possible to use explicit imports from #imports.\n\nPlugins and Middleware\n\nLearn how to migrate from Nuxt 2 to Nuxt Bridge new plugins and middleware.\n\nMeta Tags\n\nLearn how to migrate from Nuxt 2 to Nuxt Bridge new meta tags."
  },
  {
    "title": "defineNuxtComponent · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/define-nuxt-component",
    "html": "Utils\ndefineNuxtComponent\nSource\n\ndefineNuxtComponent() is a helper function for defining type safe components with Options API.\n\ndefineNuxtComponent() is a helper function for defining type safe Vue components using options API similar to defineComponent(). defineNuxtComponent() wrapper also adds support for asyncData and head component options.\nUsing <script setup lang=\"ts\"> is the recommended way of declaring Vue components in Nuxt 3.\n Read more in Docs > Getting Started > Data Fetching.\nasyncData()\n\nIf you choose not to use setup() in your app, you can use the asyncData() method within your component definition:\n\npages/index.vue\n<script lang=\"ts\">\n\nexport default defineNuxtComponent({\n\n  async asyncData() {\n\n    return {\n\n      data: {\n\n        greetings: 'hello world!'\n\n      }\n\n    }\n\n  },\n\n})\n\n</script>\n\nhead()\n\nIf you choose not to use setup() in your app, you can use the head() method within your component definition:\n\npages/index.vue\n<script lang=\"ts\">\n\nexport default defineNuxtComponent({\n\n  head(nuxtApp) {\n\n    return {\n\n      title: 'My site'\n\n    }\n\n  },\n\n})\n\n</script>\n\n\ncreateError\n\nCreate an error object with additional metadata.\n\ndefineNuxtRouteMiddleware\n\nCreate named route middleware using defineNuxtRouteMiddleware helper function."
  },
  {
    "title": "Migrate to Nuxt Bridge: Legacy Composition API",
    "url": "https://nuxt.com/docs/bridge/bridge-composition-api",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nLegacy Composition API\n\nLearn how to migrate to Composition API with Nuxt Bridge.\n\nNuxt Bridge provides access to Composition API syntax. It is specifically designed to be aligned with Nuxt 3. Because of this, there are a few extra steps to take when enabling Nuxt Bridge, if you have been using the Composition API previously.\n\nRemove Modules\nRemove @vue/composition-api from your dependencies.\nRemove @nuxtjs/composition-api from your dependencies (and from your modules in nuxt.config).\nUsing @vue/composition-api\n\nIf you have been using just @vue/composition-api and not @nuxtjs/composition-api, then things are very straightforward.\n\nFirst, remove the plugin where you are manually registering the Composition API. Nuxt Bridge will handle this for you.\n- import Vue from 'vue'\n\n- import VueCompositionApi from '@vue/composition-api'\n\n-\n\n- Vue.use(VueCompositionApi)\n\nOtherwise, there is nothing you need to do. However, if you want, you can remove your explicit imports from @vue/composition-api and rely on Nuxt Bridge auto-importing them for you.\nMigrating from @nuxtjs/composition-api\n\nNuxt Bridge implements the Composition API slightly differently from @nuxtjs/composition-api and provides different composables (designed to be aligned with the composables that Nuxt 3 provides).\n\nBecause some composables have been removed and don't yet have a replacement, this will be a slightly more complicated process.\n\nRemove @nuxtjs/composition-api/module from your buildModules\n\nYou don't have to immediately update your imports yet - Nuxt Bridge will automatically provide a 'shim' for most imports you currently have, to give you time to migrate to the new, Nuxt 3-compatible composables, with the following exceptions:\n\nwithContext has been removed. See below.\nuseStatic has been removed. There is no current replacement. Feel free to raise a discussion if you have a use case for this.\nreqRef and reqSsrRef, which were deprecated, have now been removed entirely. Follow the instructions below regarding ssrRef to replace this.\nSet bridge.capi\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\n\n\nexport default defineNuxtConfig({\n\n  bridge: {\n\n    capi: true,\n\n    nitro: false // If migration to Nitro is complete, set to true\n\n  }\n\n})\n\n\nFor each other composable you are using from @nuxtjs/composition-api, follow the steps below.\n\nuseFetch\n\n$fetchState and $fetch have been removed.\n\nconst {\n\n- $fetch,\n\n- $fetchState,\n\n+ fetch,\n\n+ fetchState,\n\n} = useFetch(() => { posts.value = await $fetch('/api/posts') })\n\ndefineNuxtMiddleware\n\nThis was a type-helper stub function that is now removed.\n\nRemove the defineNuxtMiddleware wrapper:\n\n- import { defineNuxtMiddleware } from '@nuxtjs/composition-api`\n\n- export default defineNuxtMiddleware((ctx) => {})\n\n+ export default (ctx) => {}\n\n\nFor typescript support, you can use @nuxt/types:\n\nimport type { Middleware } from '@nuxt/types'\n\n\n\nexport default <Middleware> function (ctx) { }\n\ndefineNuxtPlugin\n\nThis was a type-helper stub function that is now removed.\n\nYou may also keep using Nuxt 2-style plugins, by removing the function (as with defineNuxtMiddleware).\n\nRemove the defineNuxtPlugin wrapper:\n\n- import { defineNuxtPlugin } from '@nuxtjs/composition-api'\n\n- export default defineNuxtPlugin((ctx, inject) => {})\n\n+ export default (ctx, inject) => {}\n\n\nFor typescript support, you can use @nuxt/types:\n\nimport type { Plugin } from '@nuxt/types'\n\n\n\nexport default <Plugin> function (ctx, inject) {}\n\n\nWhile this example is valid, Nuxt 3 introduces a new defineNuxtPlugin function that has a slightly different signature.\n\n Read more in Missing link.\nuseRouter and useRoute\n\nNuxt Bridge provides direct replacements for these composables via useRouter and useRoute.\n\nThe only key difference is that useRoute no longer returns a computed property.\n\n- import { useRouter, useRoute } from '@nuxtjs/composition-api'\n\n\n\n  const router = useRouter()\n\n  const route = useRoute()\n\n\n\n- console.log(route.value.path)\n\n+ console.log(route.path)\n\n\nTypeScript\n\nLearn how to use TypeScript with Nuxt Bridge.\n\nPlugins and Middleware\n\nLearn how to migrate from Nuxt 2 to Nuxt Bridge new plugins and middleware."
  },
  {
    "title": "Migrate to Nuxt Bridge: Plugins and Middleware",
    "url": "https://nuxt.com/docs/bridge/plugins-and-middleware",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nPlugins and Middleware\n\nLearn how to migrate from Nuxt 2 to Nuxt Bridge new plugins and middleware.\n\nNew Plugins Format\n\nYou can now migrate to the Nuxt 3 plugins API, which is slightly different in format from Nuxt 2.\n\nPlugins now take only one argument (nuxtApp). You can find out more in the docs.\n\nplugins/hello.ts\nexport default defineNuxtPlugin(nuxtApp => {\n\n  nuxtApp.provide('injected', () => 'my injected function')\n\n  // now available on `nuxtApp.$injected`\n\n})\n\nIf you want to use the new Nuxt composables (such as useNuxtApp or useRuntimeConfig) within your plugins, you will need to use the defineNuxtPlugin helper for those plugins.\nAlthough a compatibility interface is provided via nuxtApp.vueApp you should avoid registering plugins, directives, mixins or components this way without adding your own logic to ensure they are not installed more than once, or this may cause a memory leak.\nNew Middleware Format\n\nYou can now migrate to the Nuxt 3 middleware API, which is slightly different in format from Nuxt 2.\n\nMiddleware now take only two argument (to, from). You can find out more in the docs.\n\nexport default defineNuxtRouteMiddleware((to) => {\n\n  if (to.path !== '/') {\n\n    return navigateTo('/')\n\n  }\n\n})\n\nUse of defineNuxtRouteMiddleware is not supported outside of the middleware directory.\nYou can also use definePageMeta in Nuxt Bridge. But only for middleware and layout.\n\nLegacy Composition API\n\nLearn how to migrate to Composition API with Nuxt Bridge.\n\nNew Composition API\n\nNuxt Bridge implements composables compatible with Nuxt 3."
  },
  {
    "title": "Migrate to Nuxt Bridge: TypeScript",
    "url": "https://nuxt.com/docs/bridge/typescript",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nTypeScript\n\nLearn how to use TypeScript with Nuxt Bridge.\n\nRemove Modules\nRemove @nuxt/typescript-build: Bridge enables same functionality\nRemove @nuxt/typescript-runtime and nuxt-ts: Nuxt 2 has built-in runtime support\nSet bridge.typescript\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\n\n\nexport default defineNuxtConfig({\n\n  bridge: {\n\n    typescript: true,\n\n    nitro: false // If migration to Nitro is complete, set to true\n\n  }\n\n})\n\nUpdate tsconfig.json\n\nIf you are using TypeScript, you can edit your tsconfig.json to benefit from auto-generated Nuxt types:\n\ntsconfig.json\n{\n\n+ \"extends\": \"./.nuxt/tsconfig.json\",\n\n  \"compilerOptions\": {\n\n    ...\n\n  }\n\n}\n\nAs .nuxt/tsconfig.json is generated and not checked into version control, you'll need to generate that file before running your tests. Add nuxi prepare as a step before your tests, otherwise you'll see TS5083: Cannot read file '~/.nuxt/tsconfig.json'\nYou may also need to add @vue/runtime-dom as a devDependency if you are struggling to get template type inference working with Volar.\nKeep in mind that all options extended from ./.nuxt/tsconfig.json will be overwritten by the options defined in your tsconfig.json. Overwriting options such as \"compilerOptions.paths\" with your own configuration will lead TypeScript to not factor in the module resolutions from ./.nuxt/tsconfig.json. This can lead to module resolutions such as #imports not being recognized.In case you need to extend options provided by ./.nuxt/tsconfig.json further, you can use the alias property within your nuxt.config. nuxi will pick them up and extend ./.nuxt/tsconfig.json accordingly.\n\nOverview\n\nReduce the differences with Nuxt 3 and reduce the burden of migration to Nuxt 3.\n\nLegacy Composition API\n\nLearn how to migrate to Composition API with Nuxt Bridge."
  },
  {
    "title": "clearError · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/clear-error",
    "html": "Utils\nclearError\nSource\n\nThe clearError composable clears all handled errors.\n\nclearError\n\nWithin your pages, components, and plugins, you can use clearError to clear all errors and redirect the user.\n\nParameters:\n\noptions?: { redirect?: string }\n\nYou can provide an optional path to redirect to (for example, if you want to navigate to a 'safe' page).\n\n// Without redirect\n\nclearError()\n\n\n\n// With redirect\n\nclearError({ redirect: '/homepage' })\n\n\nErrors are set in state using useError(). The clearError composable will reset this state and calls the app:error:cleared hook with the provided options.\n\n Read more in Docs > Getting Started > Error Handling.\n\naddRouteMiddleware\n\naddRouteMiddleware() is a helper function to dynamically add middleware in your application.\n\nclearNuxtData\n\nDelete cached data, error status and pending promises of useAsyncData and useFetch."
  },
  {
    "title": "clearNuxtState · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/clear-nuxt-state",
    "html": "Utils\nclearNuxtState\nSource\n\nDelete the cached state of useState.\n\nThis method is useful if you want to invalidate the state of useState.\nType\nclearNuxtState (keys?: string | string[] | ((key: string) => boolean)): void\n\nParameters\nkeys: One or an array of keys that are used in useState to delete their cached state. If no keys are provided, all state will be invalidated.\n\nclearNuxtData\n\nDelete cached data, error status and pending promises of useAsyncData and useFetch.\n\ncreateError\n\nCreate an error object with additional metadata."
  },
  {
    "title": "defineNuxtRouteMiddleware · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/define-nuxt-route-middleware",
    "html": "Utils\ndefineNuxtRouteMiddleware\nSource\n\nCreate named route middleware using defineNuxtRouteMiddleware helper function.\n\nRoute middleware are stored in the middleware/ of your Nuxt application (unless set otherwise).\n\nType\ndefineNuxtRouteMiddleware(middleware: RouteMiddleware) => RouteMiddleware\n\n\n\ninterface RouteMiddleware {\n\n  (to: RouteLocationNormalized, from: RouteLocationNormalized): ReturnType<NavigationGuard>\n\n}\n\nParameters\nmiddleware\nType: RouteMiddleware\n\nA function that takes two Vue Router's route location objects as parameters: the next route to as the first, and the current route from as the second.\n\nLearn more about available properties of RouteLocationNormalized in the Vue Router docs.\n\nExamples\nShowing Error Page\n\nYou can use route middleware to throw errors and show helpful error messages:\n\nmiddleware/error.ts\nexport default defineNuxtRouteMiddleware((to) => {\n\n  if (to.params.id === '1') {\n\n    throw createError({ statusCode: 404, statusMessage: 'Page Not Found' })\n\n  }\n\n})\n\n\nThe above route middleware will redirect a user to the custom error page defined in the ~/error.vue file, and expose the error message and code passed from the middleware.\n\nRedirection\n\nUse useState in combination with navigateTo helper function inside the route middleware to redirect users to different routes based on their authentication status:\n\nmiddleware/auth.ts\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  const auth = useState('auth')\n\n  \n\n  if (!auth.value.isAuthenticated) {\n\n    return navigateTo('/login')\n\n  }\n\n\n\n  if (to.path !== '/dashboard') {\n\n    return navigateTo('/dashboard')\n\n  }\n\n})\n\n\nBoth navigateTo and abortNavigation are globally available helper functions that you can use inside defineNuxtRouteMiddleware.\n\ndefineNuxtComponent\n\ndefineNuxtComponent() is a helper function for defining type safe components with Options API.\n\ndefinePageMeta\n\nDefine metadata for your page components."
  },
  {
    "title": "createError · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/create-error",
    "html": "Utils\ncreateError\nSource\n\nCreate an error object with additional metadata.\n\nYou can use this function to create an error object with additional metadata. It is usable in both the Vue and Nitro portions of your app, and is meant to be thrown.\n\nParameters\nerr: { cause, data, message, name, stack, statusCode, statusMessage, fatal }\nIn Vue App\n\nIf you throw an error created with createError:\n\non server-side, it will trigger a full-screen error page which you can clear with clearError.\non client-side, it will throw a non-fatal error for you to handle. If you need to trigger a full-screen error page, then you can do this by setting fatal: true.\nExample\npages/movies/[slug].vue\n<script setup lang=\"ts\">\n\nconst route = useRoute()\n\nconst { data } = await useFetch(`/api/movies/${route.params.slug}`)\n\nif (!data.value) {\n\n  throw createError({ statusCode: 404, statusMessage: 'Page Not Found' })\n\n}\n\n</script>\n\nIn API Routes\n\nUse createError to trigger error handling in server API routes.\n\nExample\nexport default eventHandler(() => {\n\n  throw createError({\n\n    statusCode: 404,\n\n    statusMessage: 'Page Not Found'\n\n  })\n\n})\n\n Read more in Docs > Getting Started > Error Handling.\n\nclearNuxtState\n\nDelete the cached state of useState.\n\ndefineNuxtComponent\n\ndefineNuxtComponent() is a helper function for defining type safe components with Options API."
  },
  {
    "title": "clearNuxtData · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/clear-nuxt-data",
    "html": "Utils\nclearNuxtData\nSource\n\nDelete cached data, error status and pending promises of useAsyncData and useFetch.\n\nThis method is useful if you want to invalidate the data fetching for another page.\nType\nclearNuxtData (keys?: string | string[] | ((key: string) => boolean)): void\n\nParameters\nkeys: One or an array of keys that are used in useAsyncData to delete their cached data. If no keys are provided, all data will be invalidated.\n\nclearError\n\nThe clearError composable clears all handled errors.\n\nclearNuxtState\n\nDelete the cached state of useState."
  },
  {
    "title": "useSeoMeta · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-seo-meta",
    "html": "Composables\nuseSeoMeta\nSource\n\nThe useSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.\n\nThis helps you avoid common mistakes, such as using name instead of property, as well as typos - with over 100+ meta tags fully typed.\n\nThis is the recommended way to add meta tags to your site as it is XSS safe and has full TypeScript support.\n Read more in Docs > Getting Started > Seo Meta.\nUsage\napp.vue\n<script setup lang=\"ts\">\n\nuseSeoMeta({\n\n  title: 'My Amazing Site',\n\n  ogTitle: 'My Amazing Site',\n\n  description: 'This is my amazing site, let me tell you all about it.',\n\n  ogDescription: 'This is my amazing site, let me tell you all about it.',\n\n  ogImage: 'https://example.com/image.png',\n\n  twitterCard: 'summary_large_image',\n\n})\n\n</script>\n\n\nWhen inserting tags that are reactive, you should use the computed getter syntax (() => value):\n\napp.vue\n<script setup lang=\"ts\">\n\nconst title = ref('My title')\n\n\n\nuseSeoMeta({\n\n  title,\n\n  description: () => `description: ${title.value}`\n\n})\n\n</script>\n\nParameters\n\nThere are over 100 parameters. See the full list of parameters in the source code.\n\n Read more in Docs > Getting Started > Seo Meta.\n\nuseRuntimeConfig\n\nAccess runtime config variables with the useRuntimeConfig composable.\n\nuseServerSeoMeta\n\nThe useServerSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support."
  },
  {
    "title": "Migrate to Nuxt 3: Server",
    "url": "https://nuxt.com/docs/migration/server",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nServer\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 server.\n\nIn a built Nuxt 3 application, there is no runtime Nuxt dependency. That means your site will be highly performant, and ultra-slim. But it also means you can no longer hook into runtime Nuxt server hooks.\n\n Read more in Docs > Guide > Concepts > Server Engine.\nSteps\nRemove the render key in your nuxt.config.\nAny files in ~/server/api and ~/server/middleware will be automatically registered; you can remove them from your serverMiddleware array.\nUpdate any other items in your serverMiddleware array to point to files or npm packages directly, rather than using inline functions.\n Read more in Docs > Guide > Directory Structure > Server.\n Read more in Docs > Guide > Going Further > Hooks #server Hooks Runtime.\n\nBuild Tooling\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 build tooling.\n\nModules\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 modules."
  },
  {
    "title": "Migrate to Nuxt 3: Component Options",
    "url": "https://nuxt.com/docs/migration/component-options",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nComponent Options\n\nLearn how to migrate from Nuxt 2 components options to Nuxt 3 composables.\n\nasyncData and fetch\n\nNuxt 3 provides new options for fetching data from an API.\n\nIsomorphic Fetch\n\nIn Nuxt 2 you might use @nuxtjs/axios or @nuxt/http to fetch your data - or just the polyfilled global fetch.\n\nIn Nuxt 3 you can use a globally available fetch method that has the same API as the Fetch API or $fetch method which is using unjs/ofetch. It has a number of benefits, including:\n\nIt will handle 'smartly' making direct API calls if it's running on the server, or making a client-side call to your API if it's running on the client. (It can also handle calling third-party APIs.)\nPlus, it comes with convenience features including automatically parsing responses and stringifying data.\n\nYou can read more about direct API calls or fetching data.\n\nComposables\n\nNuxt 3 provides new composables for fetching data: useAsyncData and useFetch. They each have 'lazy' variants (useLazyAsyncData and useLazyFetch), which do not block client-side navigation.\n\nIn Nuxt 2, you'd fetch your data in your component using a syntax similar to:\n\nexport default {\n\n  async asyncData({ params, $http }) {\n\n    const post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)\n\n    return { post }\n\n  },\n\n  // or alternatively\n\n  fetch () {\n\n    this.post = await $http.$get(`https://api.nuxtjs.dev/posts/${params.id}`)\n\n  }\n\n}\n\n\nWithin your methods and templates, you could use the post variable similar how you'd use any other piece of data provided by your component.\n\nWith Nuxt 3, you can perform this data fetching using composables in your setup() method or <script setup> tag:\n\n<script setup lang=\"ts\">\n\n// Define params wherever, through `defineProps()`, `useRoute()`, etc.\n\nconst { data: post, refresh } = await useAsyncData('post', () => $fetch(`https://api.nuxtjs.dev/posts/${params.id}`) )\n\n// Or instead - useFetch is a convenience wrapper around useAsyncData when you're just performing a simple fetch\n\nconst { data: post, refresh } = await useFetch(`https://api.nuxtjs.dev/posts/${params.id}`)\n\n</script>\n\n\nYou can now use post inside of your Nuxt 3 template, or call refresh to update the data.\n\nDespite the names, useFetch is not a direct replacement of the fetch() hook. Rather, useAsyncData replaces both hooks and is more customizable; it can do more than simply fetching data from an endpoint. useFetch is a convenience wrapper around useAsyncData for simply fetching data from an endpoint.\nMigration\nReplace the asyncData hook with useAsyncData or useFetch in your page/component.\nReplace the fetch hook with useAsyncData or useFetch in your component.\nhead\n Read more in Docs > Migration > Meta.\nkey\n\nYou can now define a key within the definePageMeta compiler macro.\n\npages/index.vue\n- <script>\n\n- export default {\n\n-   key: 'index'\n\n-   // or a method\n\n-   // key: route => route.fullPath\n\n- }\n\n+ <script setup>\n\n+ definePageMeta({\n\n+   key: 'index'\n\n+   // or a method\n\n+   // key: route => route.fullPath\n\n+ })\n\n</script>\n\nlayout\n Read more in Docs > Migration > Pages And Layouts.\nloading\n\nThis feature is not yet supported in Nuxt 3.\n\nmiddleware\n Read more in Docs > Migration > Plugins And Middleware.\nscrollToTop\n\nThis feature is not yet supported in Nuxt 3. If you want to overwrite the default scroll behavior of vue-router, you can do so in ~/app/router.options.ts (see docs) for more info. Similar to key, specify it within the definePageMeta compiler macro.\n\npages/index.vue\n- <script>\n\n- export default {\n\n-   scrollToTop: false\n\n- }\n\n+ <script setup>\n\n+ definePageMeta({\n\n+   scrollToTop: false\n\n+ })\n\n</script>\n\ntransition\n Read more in Docs > Getting Started > Transitions.\nvalidate\n\nThe validate hook in Nuxt 3 only accepts a single argument, the route. Just as in Nuxt 2, you can return a boolean value. If you return false and another match can't be found, this will mean a 404. You can also directly return an object with statusCode/statusMessage to respond immediately with an error (other matches will not be checked).\n\npages/users/[id].vue\n- <script>\n\n- export default {\n\n-   async validate({ params }) {\n\n-     return /^\\d+$/.test(params.id)\n\n-   }\n\n- }\n\n+ <script setup>\n\n+ definePageMeta({\n\n+   validate: async (route) => {\n\n+     const nuxtApp = useNuxtApp()\n\n+     return /^\\d+$/.test(route.params.id)\n\n+   }\n\n+ })\n\n  </script>\n\nwatchQuery\n\nThis is not supported in Nuxt 3. Instead, you can directly use a watcher to trigger refetching data.\n\npages/users/[id].vue\n<script setup lang=\"ts\">\n\nconst route = useRoute()\n\nconst { data, refresh } = await useFetch('/api/user')\n\nwatch(() => route.query, () => refresh())\n\n</script>\n\n\nPages and Layouts\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 pages and layouts.\n\nRuntime Config\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 runtime config."
  },
  {
    "title": "Migrate to Nuxt 3: Runtime Config",
    "url": "https://nuxt.com/docs/migration/runtime-config",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nRuntime Config\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 runtime config.\n\nIf you wish to reference environment variables within your Nuxt 3 app, you will need to use runtime config.\n\nWhen referencing these variables within your components, you will have to use the useRuntimeConfig composable in your setup method (or Nuxt plugin).\n\nIn the server/ portion of your app, you can use useRuntimeConfig without any import.\n\n Read more in Docs > Guide > Going Further > Runtime Config.\nMigration\nAdd any environment variables that you use in your app to the runtimeConfig property of the nuxt.config file.\nMigrate process.env to useRuntimeConfig throughout the Vue part of your app.\nnuxt.config.ts\npages/index.vue\nserver/api/hello.ts\n.env\nexport default defineNuxtConfig({\n\n  runtimeConfig: {\n\n    // Private config that is only available on the server\n\n    apiSecret: '123',\n\n    // Config within public will be also exposed to the client\n\n    public: {\n\n      apiBase: '/api'\n\n    }\n\n  },\n\n})\n\n\nComponent Options\n\nLearn how to migrate from Nuxt 2 components options to Nuxt 3 composables.\n\nBuild Tooling\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 build tooling."
  },
  {
    "title": "Migrate to Nuxt 3: Overview",
    "url": "https://nuxt.com/docs/migration/overview",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nOverview\n\nNuxt 3 is a complete rewrite of Nuxt 2, and also based on a new set of underlying technologies.\n\nThere are significant changes when migrating a Nuxt 2 app to Nuxt 3, although you can expect migration to become more straightforward as we move toward a stable release.\n\nThis migration guide is under progress to align with the development of Nuxt 3.\n\nSome of these significant changes include:\n\nMoving from Vue 2 to Vue 3, including defaulting to the Composition API and script setup.\nMoving from webpack 4 and Babel to Vite or webpack 5 and esbuild.\nMoving from a runtime Nuxt dependency to a minimal, standalone server compiled with nitropack.\nIf you need to remain on Nuxt 2, but want to benefit from Nuxt 3 features in Nuxt 2, you can alternatively check out how to get started with Bridge.\nNext Steps\nLearn about differences in configuration\n\nConfiguration\n\nLearn how to configure Nuxt Bridge to your own needs.\n\nConfiguration\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 new configuration."
  },
  {
    "title": "Migrate to Nuxt 3: Build Tooling",
    "url": "https://nuxt.com/docs/migration/bundling",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nBuild Tooling\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 build tooling.\n\nWe use the following build tools by default:\n\nVite or webpack\nRollup\nPostCSS\nesbuild\n\nFor this reason, most of your previous build configuration in nuxt.config will now be ignored, including any custom babel configuration.\n\nIf you need to configure any of Nuxt's build tools, you can do so in your nuxt.config, using the new top-level vite, webpack and postcss keys.\n\nIn addition, Nuxt ships with TypeScript support.\n\n Read more in Docs > Guide > Concepts > Typescript.\nSteps\nRemove @nuxt/typescript-build and @nuxt/typescript-runtime from your dependencies and modules.\nRemove any unused babel dependencies from your project.\nRemove any explicit core-js dependencies.\nMigrate require to import.\n\nRuntime Config\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 runtime config.\n\nServer\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 server."
  },
  {
    "title": "useRouter · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-router",
    "html": "Composables\nuseRouter\nSource\n\nThe useRouter composable returns the router instance.\n\npages/index.vue\n<script setup>\n\nconst router = useRouter()\n\n</script>\n\n\nIf you only need the router instance within your template, use $router:\n\npages/index.vue\n<template>\n\n  <button @click=\"$router.back()\">Back</button>\n\n</template>\n\n\nIf you have a pages/ directory, useRouter is identical in behavior to the one provided by vue-router.\n\nRead vue-router documentation about the Router interface.\nBasic Manipulation\naddRoute(): Add a new route to the router instance. parentName can be provided to add new route as the child of an existing route.\nremoveRoute(): Remove an existing route by its name.\ngetRoutes(): Get a full list of all the route records.\nhasRoute(): Checks if a route with a given name exists.\nresolve(): Returns the normalized version of a route location. Also includes an href property that includes any existing base.\nExample\nconst router = useRouter()\n\n\n\nrouter.addRoute({ name: 'home', path: '/home', component: Home })\n\nrouter.removeRoute('home')\n\nrouter.getRoutes()\n\nrouter.hasRoute('home')\n\nrouter.resolve({ name: 'home' })\n\nrouter.addRoute() adds route details into an array of routes and it is useful while building Nuxt plugins while router.push() on the other hand, triggers a new navigation immediately and it is useful in pages, Vue components and composable.\nBased on History API\nback(): Go back in history if possible, same as router.go(-1).\nforward(): Go forward in history if possible, same as router.go(1).\ngo(): Move forward or backward through the history without the hierarchical restrictions enforced in router.back() and router.forward().\npush(): Programmatically navigate to a new URL by pushing an entry in the history stack. It is recommended to use navigateTo instead.\nreplace(): Programmatically navigate to a new URL by replacing the current entry in the routes history stack. It is recommended to use navigateTo instead.\nExample\nconst router = useRouter()\n\n\n\nrouter.back()\n\nrouter.forward()\n\nrouter.go(3)\n\nrouter.push({ path: \"/home\" })\n\nrouter.replace({ hash: \"#bio\" })\n\nRead more about the browser's History API.\nNavigation Guards\n\nuseRouter composable provides afterEach, beforeEach and beforeResolve helper methods that acts as navigation guards.\n\nHowever, Nuxt has a concept of route middleware that simplifies the implementation of navigation guards and provides a better developer experience.\n\n Read more in Docs > Guide > Directory Structure > Middleware.\nPromise and Error Handling\nisReady(): Returns a Promise that resolves when the router has completed the initial navigation.\nonError: Adds an error handler that is called every time a non caught error happens during navigation.\n Read more in Vue Router Docs.\nUniversal Router Instance\n\nIf you do not have a pages/ folder, then useRouter will return a universal router instance with similar helper methods, but be aware that not all features may be supported or behave in exactly the same way as with vue-router.\n\nuseRoute\n\nThe useRoute composable returns the current route.\n\nuseRuntimeConfig\n\nAccess runtime config variables with the useRuntimeConfig composable."
  },
  {
    "title": "<ClientOnly> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/client-only",
    "html": "Components\n<ClientOnly>\nSource\n\nRender components only in client-side with the <ClientOnly> component.\n\nThe <ClientOnly> component renders its slot only in client-side. To import a component only on the client, register the component in a client-side only plugin.\n\nProps\nplaceholderTag | fallbackTag: specify a tag to be rendered server-side.\nplaceholder | fallback: specify a content to be rendered server-side.\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <ClientOnly fallback-tag=\"span\" fallback=\"Loading comments...\">\n\n      <Comment />\n\n    </ClientOnly>\n\n  </div>\n\n</template>\n\nSlots\n#fallback: specify a content to be displayed server-side.\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <ClientOnly>\n\n      <!-- ... -->\n\n      <template #fallback>\n\n        <!-- this will be rendered on server side -->\n\n        <p>Loading comments...</p>\n\n      </template>\n\n    </ClientOnly>\n\n  </div>\n\n</template>\n\n\nNightly Release Channel\n\nThe nightly release channel allows using Nuxt built directly from the latest commits to the repository.\n\n<NuxtClientFallback>\n\nNuxt provides the <NuxtClientFallback> component to render its content on the client if any of its children trigger an error in SSR"
  },
  {
    "title": "WASM · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/experimental/wasm",
    "html": "Examples\nExperimental\nWASM\n\nThis example demonstrates the server-side support of WebAssembly in Nuxt 3.\n\nLoading Sandbox...\n\nUse Custom Fetch Composable\n\nThis example shows a convenient wrapper for the useFetch composable from nuxt. It allows you to customize the fetch request with default values and user authentication token."
  },
  {
    "title": "Migrate to Nuxt 3: Pages and Layouts",
    "url": "https://nuxt.com/docs/migration/pages-and-layouts",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nPages and Layouts\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 pages and layouts.\n\napp.vue\n\nNuxt 3 provides a central entry point to your app via ~/app.vue.\n\nIf you don't have an app.vue file in your source directory, Nuxt will use its own default version.\n\nThis file is a great place to put any custom code that needs to be run once when your app starts up, as well as any components that are present on every page of your app. For example, if you only have one layout, you can move this to app.vue instead.\n\n Read more in Docs > Guide > Directory Structure > App.\n Read and edit a live example in Docs > Examples > Hello World.\nMigration\n\nConsider creating an app.vue file and including any logic that needs to run once at the top-level of your app. You can check out an example here.\n\nLayouts\n\nIf you are using layouts in your app for multiple pages, there is only a slight change required.\n\nIn Nuxt 2, the <Nuxt> component is used within a layout to render the current page. In Nuxt 3, layouts use slots instead, so you will have to replace that component with a <slot />. This also allows advanced use cases with named and scoped slots. Read more about layouts.\n\nYou will also need to change how you define the layout used by a page using the definePageMeta compiler macro. Layouts will be kebab-cased. So layouts/customLayout.vue becomes custom-layout when referenced in your page.\n\nMigration\nReplace <Nuxt /> with <slot />\nlayouts/custom.vue\n  <template>\n\n    <div id=\"app-layout\">\n\n      <main>\n\n-       <Nuxt />\n\n+       <slot />\n\n      </main>\n\n    </div>\n\n  </template>\n\nUse definePageMeta to select the layout used by your page.\npages/index.vue\n  <script>\n\n+ definePageMeta({\n\n+   layout: 'custom'\n\n+ })\n\n- export default {\n\n-   layout: 'custom'\n\n- }\n\n  </script>\n\nMove ~/layouts/_error.vue to ~/error.vue. See the error handling docs. If you want to ensure that this page uses a layout, you can use <NuxtLayout> directly within error.vue:\nerror.vue\n<template>\n\n  <div>\n\n    <NuxtLayout name=\"default\">\n\n      <!-- -->\n\n    </NuxtLayout>\n\n  </div>\n\n</template>\n\nPages\n\nNuxt 3 ships with an optional vue-router integration triggered by the existence of a pages/ directory in your source directory. If you only have a single page, you may consider instead moving it to app.vue for a lighter build.\n\nDynamic Routes\n\nThe format for defining dynamic routes in Nuxt 3 is slightly different from Nuxt 2, so you may need to rename some of the files within pages/.\n\nWhere you previously used _id to define a dynamic route parameter you now use [id].\nWhere you previously used _.vue to define a catch-all route, you now use [...slug].vue.\nNested Routes\n\nIn Nuxt 2, you will have defined any nested routes (with parent and child components) using <Nuxt> and <NuxtChild>. In Nuxt 3, these have been replaced with a single <NuxtPage> component.\n\nPage Keys and Keep-alive Props\n\nIf you were passing a custom page key or keep-alive props to <Nuxt>, you will now use definePageMeta to set these options.\n\n Read more in Docs > Migration > Component Options.\nPage and Layout Transitions\n\nIf you have been defining transitions for your page or layout directly in your component options, you will now need to use definePageMeta to set the transition. Since Vue 3, -enter and -leave CSS classes have been renamed. The style prop from <Nuxt> no longer applies to transition when used on <slot>, so move the styles to your -active class.\n\n Read more in Docs > Getting Started > Transitions.\nMigration\nRename any pages with dynamic parameters to match the new format.\nUpdate <Nuxt> and <NuxtChild> to be <NuxtPage>.\nIf you're using the Composition API, you can also migrate this.$route and this.$router to use useRoute and useRouter composables.\nExample: Dynamic Routes\nNuxt 2\nNuxt 3\n- URL: /users\n- Page: /pages/users/index.vue\n\n- URL: /users/some-user-name\n- Page: /pages/users/_user.vue\n- Usage: params.user\n\n- URL: /users/some-user-name/edit\n- Page: /pages/users/_user/edit.vue\n- Usage: params.user\n\n- URL: /users/anything-else\n- Page: /pages/users/_.vue\n- Usage: params.pathMatch\n\nExample: Nested Routes and definePageMeta\nNuxt 2\nNuxt 3\n<template>\n\n  <div>\n\n    <NuxtChild keep-alive :keep-alive-props=\"{ exclude: ['modal'] }\" :nuxt-child-key=\"$route.slug\" />\n\n  </div>\n\n</template>\n\n\n\n<script>\n\nexport default {\n\n  transition: 'page' // or { name: 'page' }\n\n}\n\n</script>\n\n<NuxtLink> Component\n\nMost of the syntax and functionality are the same for the global NuxtLink component. If you have been using the shortcut <NLink> format, you should update this to use <NuxtLink>.\n\n<NuxtLink> is now a drop-in replacement for all links, even external ones. You can read more about it, and how to extend it to provide your own link component.\n\n Read more in Docs > API > Components > Nuxt Link.\nProgrammatic Navigation\n\nWhen migrating from Nuxt 2 to Nuxt 3, you will have to update how you programmatically navigate your users. In Nuxt 2, you had access to the underlying Vue Router with this.$router. In Nuxt 3, you can use the navigateTo() utility method which allows you to pass a route and parameters to Vue Router.\n\nEnsure to always await on navigateTo or chain its result by returning from functions.\nNuxt 2\nNuxt 3\n<script>\n\nexport default {\n\n  methods: {\n\n    navigate(){\n\n      this.$router.push({\n\n        path: '/search',\n\n        query: {\n\n          name: 'first name',\n\n          type: '1'\n\n        }\n\n      })\n\n    }\n\n  }\n\n}\n\n</script>\n\n\nPlugins and Middleware\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 plugins and middleware.\n\nComponent Options\n\nLearn how to migrate from Nuxt 2 components options to Nuxt 3 composables."
  },
  {
    "title": "Migrate to Nuxt 3: Auto Imports",
    "url": "https://nuxt.com/docs/migration/auto-imports",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nAuto Imports\n\nNuxt 3 adopts a minimal friction approach, meaning wherever possible components and composables are auto-imported.\n\nIn the rest of the migration documentation, you will notice that key Nuxt and Vue utilities do not have explicit imports. This is not a typo; Nuxt will automatically import them for you, and you should get full type hinting if you have followed the instructions to use Nuxt's TypeScript support.\n\nRead more about auto imports\n\nMigration\nIf you have been using @nuxt/components in Nuxt 2, you can remove components: true in your nuxt.config. If you had a more complex setup, then note that the component options have changed somewhat. See the components documentation for more information.\nYou can look at .nuxt/types/components.d.ts and .nuxt/types/imports.d.ts to see how Nuxt has resolved your components and composable auto-imports.\n\nConfiguration\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 new configuration.\n\nMeta Tags\n\nManage your meta tags, from Nuxt 2 to Nuxt 3."
  },
  {
    "title": "Migrate to Nuxt 3: Plugins and Middleware",
    "url": "https://nuxt.com/docs/migration/plugins-and-middleware",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nPlugins and Middleware\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 plugins and middleware.\n\nPlugins\n\nPlugins now have a different format, and take only one argument (nuxtApp).\n\nNuxt 2\nNuxt 3\nexport default (ctx, inject) => {\n\n  inject('injected', () => 'my injected function')\n\n})\n\n Read more in Docs > Guide > Directory Structure > Plugins.\nRead more about the format of nuxtApp.\nMigration\nMigrate your plugins to use the defineNuxtPlugin helper function.\nRemove any entries in your nuxt.config plugins array that are located in your plugins/ folder. All files in this directory at the top level (and any index files in any subdirectories) will be automatically registered. Instead of setting mode to client or server, you can indicate this in the file name. For example, ~/plugins/my-plugin.client.ts will only be loaded on client-side.\nRoute Middleware\n\nRoute middleware has a different format.\n\nNuxt 2\nNuxt 3\nexport default function ({ store, redirect }) {\n\n  // If the user is not authenticated\n\n  if (!store.state.authenticated) {\n\n    return redirect('/login')\n\n  }\n\n}\n\n\nMuch like Nuxt 2, route middleware placed in your ~/middleware folder is automatically registered. You can then specify it by name in a component. However, this is done with definePageMeta rather than as a component option.\n\nnavigateTo is one of a number of route helper functions.\n\n Read more in Docs > Guide > Directory Structure > Middleware.\nMigration\nMigrate your route middleware to use the defineNuxtRouteMiddleware helper function.\nAny global middleware (such as in your nuxt.config) can be placed in your ~/middleware folder with a .global extension, for example ~/middleware/auth.global.ts.\n\nMeta Tags\n\nManage your meta tags, from Nuxt 2 to Nuxt 3.\n\nPages and Layouts\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 pages and layouts."
  },
  {
    "title": "Migrate to Nuxt 3: Meta Tags",
    "url": "https://nuxt.com/docs/migration/meta",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nMeta Tags\n\nManage your meta tags, from Nuxt 2 to Nuxt 3.\n\nNuxt 3 provides several different ways to manage your meta tags:\n\nThrough your nuxt.config.\nThrough the useHead composable\nThrough global meta components\n\nYou can customize title, titleTemplate, base, script, noscript, style, meta, link, htmlAttrs and bodyAttrs.\n\nNuxt currently uses vueuse/head to manage your meta tags, but implementation details may change.\n Read more in Docs > Getting Started > Seo Meta.\nMigration\nIn your nuxt.config, rename head to meta. Consider moving this shared meta configuration into your app.vue instead. (Note that objects no longer have a hid key for deduplication.)\nIf you need to access the component state with head, you should migrate to using useHead . You might also consider using the built-in meta-components.\nIf you need to use the Options API, there is a head() method you can use when you use defineNuxtComponent.\nuseHead\nNuxt 2\nNuxt 3\n<script>\n\nexport default {\n\n  data: () => ({\n\n    title: 'My App',\n\n    description: 'My App Description'\n\n  })\n\n  head () {\n\n    return {\n\n      title: this.title,\n\n      meta: [{\n\n        hid: 'description',\n\n        name: 'description',\n\n        content: this.description\n\n      }]\n\n    }\n\n  }\n\n}\n\n</script>\n\nMeta-components\n\nNuxt 3 also provides meta components that you can use to accomplish the same task. While these components look similar to HTML tags, they are provided by Nuxt and have similar functionality.\n\nNuxt 2\nNuxt 3\n<script>\n\nexport default {\n\n  head () {\n\n    return {\n\n      title: 'My App',\n\n      meta: [{\n\n        hid: 'description',\n\n        name: 'description',\n\n        content: 'My App Description'\n\n      }]\n\n    }\n\n  }\n\n}\n\n</script>\n\nMake sure you use capital letters for these component names to distinguish them from native HTML elements (<Title> rather than <title>).\nYou can place these components anywhere in your template for your page.\nOptions API\nNuxt 3 (Options API)\n<script>\n\n// if using options API `head` method you must use `defineNuxtComponent`\n\nexport default defineNuxtComponent({\n\n  head (nuxtApp) {\n\n    // `head` receives the nuxt app but cannot access the component instance\n\n    return {\n\n      meta: [{\n\n        name: 'description',\n\n        content: 'This is my page description.'\n\n      }]\n\n    }\n\n  }\n\n})\n\n</script>\n\n\nAuto Imports\n\nNuxt 3 adopts a minimal friction approach, meaning wherever possible components and composables are auto-imported.\n\nPlugins and Middleware\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 plugins and middleware."
  },
  {
    "title": "Layers · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/config-extends",
    "html": "Examples\nAdvanced\nLayers\n\nThis example shows how to use the extends key in `nuxt.config.ts`.\n\nThis example shows how to use the extends key in nuxt.config.ts to use the base/ directory as a base Nuxt application, and use its components, composables or config and override them if necessary.\n\n Read more in Docs > Getting Started > Layers.\nLoading Sandbox...\n\nUniversal Router\n\nThis example demonstrates Nuxt universal routing utilities without depending on `pages/` and `vue-router`.\n\nError Handling\n\nThis example shows how to handle errors in different contexts: pages, plugins, components and middleware."
  },
  {
    "title": "Auto Imports · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/features/auto-imports",
    "html": "Examples\nFeatures\nAuto Imports\n\nThis example demonstrates the auto-imports feature in Nuxt.\n\nExample of the auto-imports feature in Nuxt with:\n\nVue components in the components/ directory are auto-imported and can be used directly in your templates.\nVue composables in the composables/ directory are auto-imported and can be used directly in your templates and JS/TS files.\nJS/TS variables and functions in the utils/ directory are auto-imported and can be used directly in your templates and JS/TS files.\n Read more in Docs > Guide > Directory Structure > Components.\n Read more in Docs > Guide > Directory Structure > Composables.\n Read more in Docs > Guide > Directory Structure > Utils.\nLoading Sandbox...\n\nHello World\n\nA minimal Nuxt 3 application only requires the `app.vue` and `nuxt.config.js` files.\n\nData Fetching\n\nThis example demonstrates data fetching with Nuxt 3 using built-in composables and API routes."
  },
  {
    "title": "Middleware · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/routing/middleware",
    "html": "Examples\nRouting\nMiddleware\n\nThis example shows how to add route middleware with the middleware/ directory or with a plugin, and how to use them globally or per page.\n\n Read more in Docs > Guide > Directory Structure > Middleware.\nLoading Sandbox...\n\nLayouts\n\nThis example shows how to define default and custom layouts.\n\nPages\n\nThis example shows how to use the pages/ directory to create application routes."
  },
  {
    "title": "nuxi dev · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/dev",
    "html": "Commands\nnuxi dev\nSource\n\nThe dev command starts a development server with hot module replacement at http://localhost:3000\n\nTerminal\nnpx nuxi dev [rootDir] [--dotenv] [--log-level] [--clipboard] [--open, -o] [--no-clear] [--port, -p] [--host, -h] [--https] [--ssl-cert] [--ssl-key]\n\n\nThe dev command starts a development server with hot module replacement at http://localhost:3000\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the application to serve.\n--dotenv\t.\tPoint to another .env file to load, relative to the root directory.\n--clipboard\tfalse\tCopy URL to clipboard.\n--open, -o\tfalse\tOpen URL in browser.\n--no-clear\tfalse\tDoes not clear the console after startup.\n--port, -p\t3000\tPort to listen.\n--host, -h\tlocalhost\tHostname of the server.\n--https\tfalse\tListen with https protocol with a self-signed certificate by default.\n--ssl-cert\tnull\tSpecify a certificate for https.\n--ssl-key\tnull\tSpecify the key for the https certificate.\n\nThe port and host can also be set via NUXT_PORT, PORT, NUXT_HOST or HOST environment variables.\n\nAdditionally to the above options, nuxi can pass options through to listhen, e.g. --no-qr to turn off the dev server QR code. You can find the list of listhen options in the unjs/listhen docs.\n\nThis command sets process.env.NODE_ENV to development.\n\nIf you are using a self-signed certificate in development, you will need to set NODE_TLS_REJECT_UNAUTHORIZED=0 in your environment.\n\nnuxi cleanup\n\nRemove common generated Nuxt files and caches.\n\nnuxi devtools\n\nThe devtools command allows you to enable or disable Nuxt DevTools on a per-project basis."
  },
  {
    "title": "Modules · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/modules",
    "html": "Nuxt Kit\nModules\nSource\n\nNuxt Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules.\n\nModules are the building blocks of Nuxt. Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules. For example, you can use the defineNuxtModule function to define a module and the installModule function to install a module programmatically.\n\ndefineNuxtModule\n\nDefine a Nuxt module, automatically merging defaults with user provided options, installing any hooks that are provided, and calling an optional setup function for full control.\n\nType\nfunction defineNuxtModule<OptionsT extends ModuleOptions> (definition: ModuleDefinition<OptionsT> | NuxtModule<OptionsT>): NuxtModule<OptionsT>\n\n\n\ntype ModuleOptions = Record<string, any>\n\n\n\ninterface ModuleDefinition<T extends ModuleOptions = ModuleOptions> {\n\n  meta?: ModuleMeta\n\n  defaults?: T | ((nuxt: Nuxt) => T)\n\n  schema?: T\n\n  hooks?: Partial<NuxtHooks>\n\n  setup?: (this: void, resolvedOptions: T, nuxt: Nuxt) => Awaitable<void | false | ModuleSetupReturn>\n\n}\n\n\n\ninterface NuxtModule<T extends ModuleOptions = ModuleOptions> {\n\n  (this: void, inlineOptions: T, nuxt: Nuxt): Awaitable<void | false | ModuleSetupReturn>\n\n  getOptions?: (inlineOptions?: T, nuxt?: Nuxt) => Promise<T>\n\n  getMeta?: () => Promise<ModuleMeta>\n\n}\n\n\n\ninterface ModuleSetupReturn {\n\n  timings?: {\n\n    setup?: number\n\n    [key: string]: number | undefined\n\n  }\n\n}\n\n\n\ninterface ModuleMeta {\n\n  name?: string\n\n  version?: string\n\n  configKey?: string\n\n  compatibility?: NuxtCompatibility\n\n  [key: string]: unknown\n\n}\n\nParameters\ndefinition\n\nType: ModuleDefinition<T> | NuxtModule<T>\n\nRequired: true\n\nA module definition object or a module function.\n\nmeta (optional)\nType: ModuleMeta\nMetadata of the module. It defines the module name, version, config key and compatibility.\ndefaults (optional)\nType: T | ((nuxt: Nuxt) => T)\nDefault options for the module. If a function is provided, it will be called with the Nuxt instance as the first argument.\nschema (optional)\nType: T\nSchema for the module options. If provided, options will be applied to the schema.\nhooks (optional)\nType: Partial<NuxtHooks>\nHooks to be installed for the module. If provided, the module will install the hooks.\nsetup (optional)\nType: (this: void, resolvedOptions: T, nuxt: Nuxt) => Awaitable<void | false | ModuleSetupReturn>\nSetup function for the module. If provided, the module will call the setup function.\nExamples\n// https://github.com/nuxt/starter/tree/module\n\nimport { defineNuxtModule } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'my-module',\n\n    configKey: 'myModule'\n\n  },\n\n  defaults: {\n\n    test: 123\n\n  },\n\n  setup (options, nuxt) {\n\n    nuxt.hook('modules:done', () => {\n\n      console.log('My module is ready with current test option: ', options.test)\n\n    })    \n\n  }\n\n})\n\ninstallModule\n\nInstall specified Nuxt module programmatically. This is helpful when your module depends on other modules. You can pass the module options as an object to inlineOptions and they will be passed to the module's setup function.\n\nType\nasync function installModule (moduleToInstall: string | NuxtModule, inlineOptions?: any, nuxt?: Nuxt)\n\nParameters\nmoduleToInstall\n\nType: string | NuxtModule\n\nRequired: true\n\nThe module to install. Can be either a string with the module name or a module object itself.\n\ninlineOptions\n\nType: any\n\nDefault: {}\n\nAn object with the module options to be passed to the module's setup function.\n\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\nExamples\nimport { defineNuxtModule, installModule } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({  \n\n  async setup (options, nuxt) {\n\n    // will install @nuxtjs/fontaine with Roboto font and Impact fallback\n\n    await installModule('@nuxtjs/fontaine', {\n\n      // module configuration\n\n      fonts: [\n\n        {\n\n          family: 'Roboto',\n\n          fallbacks: ['Impact'],\n\n          fallbackName: 'fallback-a',\n\n        }\n\n      ]\n\n    })\n\n  }\n\n})\n\n\nnuxi upgrade\n\nThe upgrade command upgrades Nuxt 3 to the latest version.\n\nProgrammatic Usage\n\nNuxt Kit provides a set of utilities to help you work with Nuxt programmatically. These functions allow you to load Nuxt, build Nuxt, and load Nuxt configuration."
  },
  {
    "title": "app.vue · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/app",
    "html": "Guide\nDirectory Structure\napp.vue\n\nThe app.vue file is the main component of your Nuxt application.\n\nMinimal Usage\n\nWith Nuxt 3, the pages/ directory is optional. If not present, Nuxt won't include vue-router dependency. This is useful when working on a landing page or an application that does not need routing.\n\napp.vue\n<template>\n\n  <h1>Hello World!</h1>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Hello World.\nUsage with Pages\n\nIf you have a pages/ directory, to display the current page, use the <NuxtPage> component:\n\napp.vue\n<template>\n\n  <div>\n\n    <NuxtLayout>\n\n      <NuxtPage/>\n\n    </NuxtLayout>\n\n  </div>\n\n</template>\n\nSince <NuxtPage> internally uses Vue's <Suspense> component, it cannot be set as a root element.\nRemember that app.vue acts as the main component of your Nuxt application. Anything you add to it (JS and CSS) will be global and included in every page.\nIf you want to have the possibility to customize the structure around the page between pages, check out the layouts/ directory.\n\napp.config.ts\n\nExpose reactive configuration within your application with the App Config file.\n\nnuxt.config.ts\n\nNuxt can be easily configured with a single nuxt.config file."
  },
  {
    "title": "Roadmap · Nuxt Community",
    "url": "https://nuxt.com/docs/community/roadmap",
    "html": "Community\nRoadmap\n\nNuxt is constantly evolving, with new features and modules being added all the time.\n\nSee our blog for the latest framework and ecosystem announcements.\nStatus Reports\nDocumentation Progress\nRendering Optimizations: Today and Tomorrow\nNuxt Image: Performance and Status\nRoadmap\n\nIn roadmap below are some features we are planning or working on at the moment.\n\nCheck Discussions and RFCs for more upcoming features and ideas.\nMilestone\tExpected date\tNotes\tDescription\nSEO & PWA\t2023\tnuxt/nuxt#18395\tMigrating from nuxt-community/pwa-module for built-in SEO utils and service worker support\nDevTools\t2023\t-\tIntegrated and modular devtools experience for Nuxt\nScripts\t2023\tnuxt/nuxt#22016\tEasy 3rd party script management.\nFonts\t2023\tnuxt/nuxt#22014\tAllow developers to easily configure fonts in their Nuxt apps.\nAssets\t2023\tnuxt/nuxt#22012\tAllow developers and modules to handle loading third-party assets.\nA11y\t2023\tnuxt/nuxt#23255\tAccessibility hinting and utilities\nTranslations\t-\tnuxt/translations#4 (request access)\tA collaborative project for a stable translation process for Nuxt 3 docs. Currently pending for ideas and documentation tooling support (content v2 with remote sources).\nCore Modules\n\nIn addition to the Nuxt framework, there are modules that are vital for the ecosystem. Their status will be updated below.\n\nModule\tStatus\tNuxt Support\tRepository\tDescription\nAuth\tPlanned\t3.x\tnuxt/auth to be announced\tNuxt 3 support is planned after session support\nImage\tActive\t2.x and 3.x\tnuxt/image\tNuxt 3 support is in progress: nuxt/image#548\nI18n\tActive\t2.x and 3.x\tnuxt-modules/i18n\tSee nuxt-modules/i18n#1287 for Nuxt 3 support\nRelease Cycle\n\nSince January 2023, we've adopted a consistent release cycle for Nuxt 3, following semver. We aim for major framework releases every year, with an expectation of patch releases every week or so and minor releases every month or so. They should never contain breaking changes except within options clearly marked as experimental.\n\nOngoing Support for Nuxt\n\nGoing forward from v3, we commit to support each major version of Nuxt for a minimum of a year after the last release, and to providing an upgrade path for current users at that point.\n\nCurrent Packages\n\nThe current active version of Nuxt is v3 which is available as nuxt on npm with the latest tag.\n\nNuxt 2 is in maintenance mode and is available on npm with the 2x tag. It will reach End of Life (EOL) on December 31st, 2023 at the same time as Vue 2 does.\n\nEach active version has its own nightly releases which are generated automatically. For more about enabling the Nuxt 3 nightly release channel, see the nightly release channel docs.\n\nRelease\t\tInitial release\tEnd Of Life\tDocs\n4.x (scheduled)\t\t2024 Q1\t\t\n3.x (stable)\t\n\t2022-11-16\tTBA\tnuxt.com\n2.x (maintenance)\t\n\t2018-09-21\t2023-12-31\tv2.nuxt.com\n1.x (unsupported)\t\n\t2018-01-08\t2019-09-21\t\nSupport Status\nStatus\tDescription\nUnsupported\tThis version is not maintained any more and will not receive security patches\nMaintenance\tThis version will only receive security patches\nStable\tThis version is being developed for and will receive security patches\nDevelopment\tThis version could be unstable\nScheduled\tThis version does not exist yet but is planned\n\nFramework\n\nSome specific points about contributions to the framework repository.\n\nReleases\n\nDiscover the latest releases of Nuxt & Nuxt official modules."
  },
  {
    "title": "Experimental Features · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/experimental-features",
    "html": "Guide\nGoing Further\nExperimental Features\n\nEnable Nuxt experimental features to unlock new possibilities.\n\nThe Nuxt experimental features can be enabled in the Nuxt configuration file.\n\nInternally, Nuxt uses @nuxt/schema to define these experimental features. You can refer to the API documentation or the source code for more information.\n\nNote that these features are experimental and could be removed or modified in the future.\nasyncContext\n\nEnable native async context to be accessible for nested composables in Nuxt and in Nitro. This opens the possibility to use composables inside async composables and reduce the chance to get the Nuxt instance is unavailable error.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    asyncContext: true\n\n  }\n\n})\n\nSee full explanation on the GitHub pull-request.\nasyncEntry\n\nEnables generation of an async entry point for the Vue bundle, aiding module federation support.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    asyncEntry: true\n\n  }\n\n})\n\nexternalVue\n\nExternalizes vue, @vue/* and vue-router when building.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    externalVue: true\n\n  }\n\n})\n\nThis feature will likely be removed in a near future.\ntreeshakeClientOnly\n\nTree shakes contents of client-only components from server bundle.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    treeshakeClientOnly: true\n\n  }\n\n})\n\nemitRouteChunkError\n\nEmits app:chunkError hook when there is an error loading vite/webpack chunks. Default behavior is to perform a hard reload of the new route when a chunk fails to load.\n\nYou can disable automatic handling by setting this to false, or handle chunk errors manually by setting it to manual.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    emitRouteChunkError: 'automatic' // or 'manual' or false\n\n  }\n\n})\n\nrestoreState\n\nAllows Nuxt app state to be restored from sessionStorage when reloading the page after a chunk error or manual reloadNuxtApp() call.\n\nTo avoid hydration errors, it will be applied only after the Vue app has been mounted, meaning there may be a flicker on initial load.\n\nConsider carefully before enabling this as it can cause unexpected behavior, and consider providing explicit keys to useState as auto-generated keys may not match across builds.\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    restoreState: true\n\n  }\n\n})\n\ninlineRouteRules\n\nDefine route rules at the page level using defineRouteRules.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    inlineRouteRules: true\n\n  }\n\n})\n\n\nMatching route rules will be created, based on the page's path.\n\nRead more in defineRouteRules utility.\n Read more in Docs > Guide > Concepts > Rendering #hybrid Rendering.\ninlineSSRStyles\n\nInlines styles when rendering HTML. This is currently available only when using Vite. You can also pass a function that receives the path of a Vue component and returns a boolean indicating whether to inline the styles for that component.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    inlineSSRStyles: true // or a function to determine inlining\n\n  }\n\n})\n\nnoScripts\n\nDisables rendering of Nuxt scripts and JS resource hints. Can also be configured granularly within routeRules.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    noScripts: true\n\n  }\n\n})\n\nrenderJsonPayloads\n\nAllows rendering of JSON payloads with support for revivifying complex types.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    renderJsonPayloads: true\n\n  }\n\n})\n\nnoVueServer\n\nDisables Vue server renderer endpoint within Nitro.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    noVueServer: true\n\n  }\n\n})\n\npayloadExtraction\n\nEnables extraction of payloads of pages generated with nuxt generate.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    payloadExtraction: true\n\n  }\n\n})\n\nclientFallback\n\nEnables the experimental <NuxtClientFallback> component for rendering content on the client if there's an error in SSR.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    clientFallback: true\n\n  }\n\n})\n\ncrossOriginPrefetch\n\nEnables cross-origin prefetch using the Speculation Rules API.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    crossOriginPrefetch: true\n\n  }\n\n})\n\nRead more about the Speculation Rules API.\nviewTransition\n\nEnables View Transition API integration with client-side router.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    viewTransition: true\n\n  }\n\n})\n\n Read and edit a live example in https://stackblitz.com/edit/nuxt-view-transitions?file=app.vue.\nRead more about the View Transition API.\nwriteEarlyHints\n\nEnables writing of early hints when using node server.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    writeEarlyHints: true\n\n  }\n\n})\n\ncomponentIslands\n\nEnables experimental component islands support with <NuxtIsland> and .island.vue files.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    componentIslands: true // false or 'local+remote'\n\n  }\n\n})\n\n Read more in Docs > Guide > Directory Structure > Components #server Components.\nYou can follow the server components roadmap on GitHub.\nconfigSchema\n\nEnables config schema support.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    configSchema: true\n\n  }\n\n})\n\npolyfillVueUseHead\n\nAdds a compatibility layer for modules, plugins, or user code relying on the old @vueuse/head API.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    polyfillVueUseHead: false\n\n  }\n\n})\n\nrespectNoSSRHeader\n\nAllow disabling Nuxt SSR responses by setting the x-nuxt-no-ssr header.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    respectNoSSRHeader: false\n\n  }\n\n})\n\nlocalLayerAliases\n\nResolve ~, ~~, @ and @@ aliases located within layers with respect to their layer source and root directories.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    localLayerAliases: true\n\n  }\n\n})\n\ntypedPages\n\nEnable the new experimental typed router using unplugin-vue-router.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    typedPages: true\n\n  }\n\n})\n\n\nOut of the box, this will enable typed usage of navigateTo, <NuxtLink>, router.push() and more.\n\nYou can even get typed params within a page by using const route = useRoute('route-name').\n\nwatcher\n\nSet an alternative watcher that will be used as the watching service for Nuxt.\n\nNuxt uses chokidar-granular by default, which will ignore top-level directories (like node_modules and .git) that are excluded from watching.\n\nYou can set this instead to parcel to use @parcel/watcher, which may improve performance in large projects or on Windows platforms.\n\nYou can also set this to chokidar to watch all files in your source directory.\n\nnuxt.config.ts\nexport defineNuxtConfig({ \n\n  experimental: { \n\n      watcher: 'chokidar-granular' // 'chokidar' or 'parcel' are also options\n\n  } \n\n})\n\n\ntsconfig.json\n\nNuxt generates a .nuxt/tsconfig.json file with sensible defaults and your aliases.\n\nHow Nuxt Works?\n\nNuxt is a minimal but highly customizable framework to build web applications."
  },
  {
    "title": "Nuxt Configuration",
    "url": "https://nuxt.com/docs/api/nuxt-config",
    "html": "Nuxt Configuration\n\nDiscover all the options you can use in your nuxt.config.ts file.\n\nThis file is auto-generated from Nuxt source code.\n_build\nType: boolean\nDefault: false\n_cli\nType: boolean\nDefault: false\n_generate\nType: boolean\nDefault: false\n_installedModules\nType: array\n_legacyGenerate\nType: boolean\nDefault: false\n_majorVersion\nType: number\nDefault: 3\n_modules\nType: array\n_nuxtConfigFile\n_nuxtConfigFiles\nType: array\n_prepare\nType: boolean\nDefault: false\n_requiredModules\n_start\nType: boolean\nDefault: false\nalias\nType: object\nDefault\n{\n\n  \"~\": \"/<rootDir>\",\n\n  \"@\": \"/<rootDir>\",\n\n  \"~~\": \"/<rootDir>\",\n\n  \"@@\": \"/<rootDir>\",\n\n  \"assets\": \"/<rootDir>/assets\",\n\n  \"public\": \"/<rootDir>/public\"\n\n}\n\nanalyzeDir\nType: string\nDefault: \"/<rootDir>/.nuxt/analyze\"\napp\nbaseURL\nType: string\nDefault: \"/\"\nbuildAssetsDir\nType: string\nDefault: \"/_nuxt/\"\ncdnURL\nType: string\nDefault: \"\"\nhead\nType: object\nDefault\n{\n\n  \"meta\": [\n\n    {\n\n      \"name\": \"viewport\",\n\n      \"content\": \"width=device-width, initial-scale=1\"\n\n    },\n\n    {\n\n      \"charset\": \"utf-8\"\n\n    }\n\n  ],\n\n  \"link\": [],\n\n  \"style\": [],\n\n  \"script\": [],\n\n  \"noscript\": []\n\n}\n\nkeepalive\nType: boolean\nDefault: false\nlayoutTransition\nType: boolean\nDefault: false\npageTransition\nType: boolean\nDefault: false\nrootId\nType: string\nDefault: \"__nuxt\"\nrootTag\nType: string\nDefault: \"div\"\nappConfig\nnuxt\nappDir\nType: string\nDefault: \"\"\nbuild\nanalyze\nType: object\nDefault\n{\n\n  \"template\": \"treemap\",\n\n  \"projectRoot\": \"/<rootDir>\",\n\n  \"filename\": \"/<rootDir>/.nuxt/analyze/{name}.html\"\n\n}\n\ntemplates\nType: array\ntranspile\nType: array\nbuildDir\nType: string\nDefault: \"/<rootDir>/.nuxt\"\nbuilder\nType: string\nDefault: \"@nuxt/vite-builder\"\ncomponents\nType: object\nDefault\n{\n\n  \"dirs\": [\n\n    {\n\n      \"path\": \"~/components/global\",\n\n      \"global\": true\n\n    },\n\n    \"~/components\"\n\n  ]\n\n}\n\ncss\nType: array\ndebug\nType: boolean\nDefault: false\ndev\nType: boolean\nDefault: false\ndevServer\nhost\nhttps\nType: boolean\nDefault: false\nloadingTemplate\nType: function\nport\nType: number\nDefault: 3000\nurl\nType: string\nDefault: \"http://localhost:3000\"\ndevServerHandlers\nType: array\ndevtools\ndir\nassets\nType: string\nDefault: \"assets\"\nlayouts\nType: string\nDefault: \"layouts\"\nmiddleware\nType: string\nDefault: \"middleware\"\nmodules\nType: string\nDefault: \"modules\"\npages\nType: string\nDefault: \"pages\"\nplugins\nType: string\nDefault: \"plugins\"\npublic\nType: string\nDefault: \"public\"\nstatic\nType: string\nDefault: \"public\"\nexperimental\nappManifest\nType: boolean\nDefault: true\nasyncContext\nType: boolean\nDefault: false\nasyncEntry\nType: boolean\nDefault: false\nclientFallback\nType: boolean\nDefault: false\ncomponentIslands\nType: boolean\nDefault: false\nconfigSchema\nType: boolean\nDefault: true\ncrossOriginPrefetch\nType: boolean\nDefault: false\ndefaults\nnuxtLink\ncomponentName\nType: string\nDefault: \"NuxtLink\"\nuseAsyncData\ndeep\nType: boolean\nDefault: true\nuseFetch\nemitRouteChunkError\nType: string\nDefault: \"automatic\"\nexternalVue\nType: boolean\nDefault: true\nheadNext\nType: boolean\nDefault: false\ninlineRouteRules\nType: boolean\nDefault: false\ninlineSSRStyles\nType: boolean\nDefault: true\nlocalLayerAliases\nType: boolean\nDefault: true\nnoScripts\nType: boolean\nDefault: false\nnoVueServer\nType: boolean\nDefault: false\npayloadExtraction\nType: boolean\nDefault: true\npolyfillVueUseHead\nType: boolean\nDefault: false\nreactivityTransform\nType: boolean\nDefault: false\nrenderJsonPayloads\nType: boolean\nDefault: true\nrespectNoSSRHeader\nType: boolean\nDefault: false\nrestoreState\nType: boolean\nDefault: false\ntemplateRouteInjection\nType: boolean\nDefault: true\ntreeshakeClientOnly\nType: boolean\nDefault: true\ntypedPages\nType: boolean\nDefault: false\ntypescriptBundlerResolution\nType: boolean\nDefault: false\nviewTransition\nType: boolean\nDefault: false\nwatcher\nType: string\nDefault: \"chokidar-granular\"\nwriteEarlyHints\nType: boolean\nDefault: false\nextends\nDefault: null\nextensions\nType: array\nDefault\n[\n\n  \".js\",\n\n  \".jsx\",\n\n  \".mjs\",\n\n  \".ts\",\n\n  \".tsx\",\n\n  \".vue\"\n\n]\n\ngenerate\nexclude\nType: array\nroutes\nType: array\nhooks\nDefault: null\nignore\nType: array\nDefault\n[\n\n  \"**/*.stories.{js,cts,mts,ts,jsx,tsx}\",\n\n  \"**/*.{spec,test}.{js,cts,mts,ts,jsx,tsx}\",\n\n  \"**/*.d.{cts,mts,ts}\",\n\n  \"**/.{pnpm-store,vercel,netlify,output,git,cache,data}\",\n\n  \".nuxt/analyze\",\n\n  \".nuxt\",\n\n  \"**/-*.*\"\n\n]\n\nignoreOptions\nignorePrefix\nType: string\nDefault: \"-\"\nimports\ndirs\nType: array\nglobal\nType: boolean\nDefault: false\nlogLevel\nType: string\nDefault: \"info\"\nmodules\nType: array\nmodulesDir\nType: array\nDefault\n[\n\n  \"/<rootDir>/node_modules\",\n\n  \"/Users/daniel/code/nuxt.js/packages/schema/node_modules\"\n\n]\n\nnitro\nrouteRules\nType: object\noptimization\nasyncTransforms\nasyncFunctions\nType: array\nDefault\n[\n\n  \"defineNuxtPlugin\",\n\n  \"defineNuxtRouteMiddleware\"\n\n]\n\nobjectDefinitions\ndefineNuxtComponent\nType: array\nDefault\n[\n\n  \"asyncData\",\n\n  \"setup\"\n\n]\n\ndefineNuxtPlugin\nType: array\nDefault\n[\n\n  \"setup\"\n\n]\n\ndefinePageMeta\nType: array\nDefault\n[\n\n  \"middleware\",\n\n  \"validate\"\n\n]\n\nkeyedComposables\nType: array\nDefault\n[\n\n  {\n\n    \"name\": \"defineNuxtComponent\",\n\n    \"argumentLength\": 2\n\n  },\n\n  {\n\n    \"name\": \"useState\",\n\n    \"argumentLength\": 2\n\n  },\n\n  {\n\n    \"name\": \"useFetch\",\n\n    \"argumentLength\": 3\n\n  },\n\n  {\n\n    \"name\": \"useAsyncData\",\n\n    \"argumentLength\": 3\n\n  },\n\n  {\n\n    \"name\": \"useLazyAsyncData\",\n\n    \"argumentLength\": 3\n\n  },\n\n  {\n\n    \"name\": \"useLazyFetch\",\n\n    \"argumentLength\": 3\n\n  }\n\n]\n\ntreeShake\ncomposables\nclient\nType: object\nDefault\n{\n\n  \"vue\": [\n\n    \"onServerPrefetch\",\n\n    \"onRenderTracked\",\n\n    \"onRenderTriggered\"\n\n  ],\n\n  \"#app\": [\n\n    \"definePayloadReducer\",\n\n    \"definePageMeta\"\n\n  ]\n\n}\n\nserver\nType: object\nDefault\n{\n\n  \"vue\": [\n\n    \"onBeforeMount\",\n\n    \"onMounted\",\n\n    \"onBeforeUpdate\",\n\n    \"onRenderTracked\",\n\n    \"onRenderTriggered\",\n\n    \"onActivated\",\n\n    \"onDeactivated\",\n\n    \"onBeforeUnmount\"\n\n  ],\n\n  \"#app\": [\n\n    \"definePayloadReviver\",\n\n    \"definePageMeta\"\n\n  ]\n\n}\n\npages\nType: boolean\nplugins\nType: array\npostcss\nplugins\nautoprefixer\ncssnano\nType: object\nrootDir\nType: string\nDefault: \"/<rootDir>\"\nrouteRules\nrouter\noptions\nhashMode\nType: boolean\nDefault: false\nscrollBehaviorType\nType: string\nDefault: \"auto\"\nruntimeConfig\nType: object\nDefault\n{\n\n  \"public\": {},\n\n  \"app\": {\n\n    \"baseURL\": \"/\",\n\n    \"buildAssetsDir\": \"/_nuxt/\",\n\n    \"cdnURL\": \"\"\n\n  }\n\n}\n\nserverDir\nType: string\nDefault: \"/<rootDir>/server\"\nserverHandlers\nType: array\nsourcemap\nType: object\nDefault\n{\n\n  \"server\": true,\n\n  \"client\": false\n\n}\n\nspaLoadingTemplate\nDefault: null\nsrcDir\nType: string\nDefault: \"/<rootDir>\"\nssr\nType: boolean\nDefault: true\ntelemetry\ntest\nType: boolean\nDefault: false\ntheme\nType: string\nDefault: null\ntypescript\nbuilder\nDefault: null\nincludeWorkspace\nType: boolean\nDefault: false\nshim\nType: boolean\nDefault: true\nstrict\nType: boolean\nDefault: true\ntsConfig\nType: object\nDefault\n{\n\n  \"compilerOptions\": {}\n\n}\n\ntypeCheck\nType: boolean\nDefault: false\nvite\nbuild\nassetsDir\nType: string\nDefault: \"_nuxt/\"\nemptyOutDir\nType: boolean\nDefault: false\nclearScreen\nType: boolean\nDefault: true\ndefine\nType: object\nDefault\n{\n\n  \"process.dev\": false,\n\n  \"import.meta.dev\": false,\n\n  \"process.test\": false,\n\n  \"import.meta.test\": false\n\n}\n\nesbuild\njsxFactory\nType: string\nDefault: \"h\"\njsxFragment\nType: string\nDefault: \"Fragment\"\ntsconfigRaw\nType: string\nDefault: \"{}\"\nmode\nType: string\nDefault: \"production\"\noptimizeDeps\nexclude\nType: array\nDefault\n[\n\n  \"vue-demi\"\n\n]\n\npublicDir\nType: string\nDefault: \"/<rootDir>/public\"\nresolve\nextensions\nType: array\nDefault\n[\n\n  \".mjs\",\n\n  \".js\",\n\n  \".ts\",\n\n  \".jsx\",\n\n  \".tsx\",\n\n  \".json\",\n\n  \".vue\"\n\n]\n\nroot\nType: string\nDefault: \"/<rootDir>\"\nserver\nfs\nallow\nType: array\nDefault\n[\n\n  \"/<rootDir>/.nuxt\",\n\n  \"/<rootDir>\",\n\n  \"/<rootDir>\",\n\n  \"/<rootDir>\",\n\n  \"/<rootDir>/node_modules\",\n\n  \"/Users/daniel/code/nuxt.js/packages/schema/node_modules\"\n\n]\n\nvue\nisProduction\nType: boolean\nDefault: true\nscript\ndefineModel\nType: boolean\nDefault: false\npropsDestructure\nType: boolean\nDefault: false\ntemplate\ncompilerOptions\nType: object\nvueJsx\nType: object\nvue\ncompilerOptions\ndefineModel\nType: boolean\nDefault: false\npropsDestructure\nType: boolean\nDefault: false\nruntimeCompiler\nType: boolean\nDefault: false\nwatch\nType: array\nwatchers\nchokidar\nignoreInitial\nType: boolean\nDefault: true\nrewatchOnRawEvents\nwebpack\naggregateTimeout\nType: number\nDefault: 1000\nwebpack\naggressiveCodeRemoval\nType: boolean\nDefault: false\nanalyze\nType: object\nDefault\n{\n\n  \"template\": \"treemap\",\n\n  \"projectRoot\": \"/<rootDir>\",\n\n  \"filename\": \"/<rootDir>/.nuxt/analyze/{name}.html\"\n\n}\n\ncssSourceMap\nType: boolean\nDefault: false\ndevMiddleware\nstats\nType: string\nDefault: \"none\"\nexperiments\nextractCSS\nType: boolean\nDefault: true\nfilenames\napp\nType: function\nchunk\nType: function\ncss\nType: function\nfont\nType: function\nimg\nType: function\nvideo\nType: function\nfriendlyErrors\nType: boolean\nDefault: true\nhotMiddleware\nloaders\ncss\nesModule\nType: boolean\nDefault: false\nimportLoaders\nType: number\nDefault: 0\nurl\nfilter\nType: function\ncssModules\nesModule\nType: boolean\nDefault: false\nimportLoaders\nType: number\nDefault: 0\nmodules\nlocalIdentName\nType: string\nDefault: \"[local]_[hash:base64:5]\"\nurl\nfilter\nType: function\nesbuild\nfile\nesModule\nType: boolean\nDefault: false\nfontUrl\nesModule\nType: boolean\nDefault: false\nlimit\nType: number\nDefault: 1000\nimgUrl\nesModule\nType: boolean\nDefault: false\nlimit\nType: number\nDefault: 1000\nless\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\npugPlain\nsass\nsassOptions\nindentedSyntax\nType: boolean\nDefault: true\nscss\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\nstylus\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\nvue\ncompilerOptions\nType: object\ndefineModel\nType: boolean\nDefault: false\npropsDestructure\nType: boolean\nDefault: false\ntransformAssetUrls\nembed\nType: string\nDefault: \"src\"\nobject\nType: string\nDefault: \"src\"\nsource\nType: string\nDefault: \"src\"\nvideo\nType: string\nDefault: \"src\"\nvueStyle\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\noptimization\nminimize\nType: boolean\nDefault: true\nminimizer\nruntimeChunk\nType: string\nDefault: \"single\"\nsplitChunks\nautomaticNameDelimiter\nType: string\nDefault: \"/\"\ncacheGroups\nchunks\nType: string\nDefault: \"all\"\noptimizeCSS\nType: boolean\nDefault: false\nplugins\nType: array\npostcss\npostcssOptions\nconfig\nplugins\nType: object\nDefault\n{\n\n  \"autoprefixer\": {},\n\n  \"cssnano\": {}\n\n}\n\nprofile\nType: boolean\nDefault: false\nserverURLPolyfill\nType: string\nDefault: \"url\"\nwarningIgnoreFilters\nType: array\nworkspaceDir\nType: string\nDefault: \"/<rootDir>\"\n\nImport meta\n\nUnderstand where your code is running using `import.meta`.\n\nGetting Help\n\nWe're a friendly community of developers and we'd love to help."
  },
  {
    "title": "Migrate to Nuxt 3: Overview",
    "url": "https://nuxt.com/docs/migration/overview",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nOverview\n\nNuxt 3 is a complete rewrite of Nuxt 2, and also based on a new set of underlying technologies.\n\nThere are significant changes when migrating a Nuxt 2 app to Nuxt 3, although you can expect migration to become more straightforward as we move toward a stable release.\n\nThis migration guide is under progress to align with the development of Nuxt 3.\n\nSome of these significant changes include:\n\nMoving from Vue 2 to Vue 3, including defaulting to the Composition API and script setup.\nMoving from webpack 4 and Babel to Vite or webpack 5 and esbuild.\nMoving from a runtime Nuxt dependency to a minimal, standalone server compiled with nitropack.\nIf you need to remain on Nuxt 2, but want to benefit from Nuxt 3 features in Nuxt 2, you can alternatively check out how to get started with Bridge.\nNext Steps\nLearn about differences in configuration\n\nConfiguration\n\nLearn how to configure Nuxt Bridge to your own needs.\n\nConfiguration\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 new configuration."
  },
  {
    "title": "Releases · Nuxt Community",
    "url": "https://nuxt.com/docs/community/changelog",
    "html": "Community\nReleases\n\nDiscover the latest releases of Nuxt & Nuxt official modules.\n\nnuxt/nuxt\n\nNuxt framework releases.\n\nnuxt/cli\n\nNuxt CLI (nuxi) releases.\n\nnuxt/content\n\nNuxt Content releases.\n\nnuxt/devtools\n\nNuxt DevTools releases.\n\nnuxt/image\n\nNuxt Image releases.\n\nnuxt/ui\n\nNuxt UI releases.\n\nDiscover the nuxt organization on GitHub\n\nRoadmap\n\nNuxt is constantly evolving, with new features and modules being added all the time.\n\nOverview\n\nReduce the differences with Nuxt 3 and reduce the burden of migration to Nuxt 3."
  },
  {
    "title": "Migrate to Nuxt Bridge: Overview",
    "url": "https://nuxt.com/docs/bridge/overview",
    "html": "Upgrade Guide\nMigrate to Nuxt Bridge\nOverview\n\nReduce the differences with Nuxt 3 and reduce the burden of migration to Nuxt 3.\n\nIf you're starting a fresh Nuxt 3 project, please skip this section and go to Nuxt 3 Installation.\nNuxt Bridge provides identical features to Nuxt 3 (docs) but there are some limitations, notably that useAsyncData and useFetch composables are not available. Please read the rest of this page for details.\n\nBridge is a forward-compatibility layer that allows you to experience many of the new Nuxt 3 features by simply installing and enabling a Nuxt module.\n\nUsing Nuxt Bridge, you can make sure your project is (almost) ready for Nuxt 3 and you can gradually proceed with the transition to Nuxt 3.\n\nFirst Step\nUpgrade Nuxt 2\n\nMake sure your dev server (nuxt dev) isn't running, remove any package lock files (package-lock.json and yarn.lock), and install the latest Nuxt 2 version:\n\npackage.json\n- \"nuxt\": \"^2.16.3\"\n\n+ \"nuxt\": \"^2.17.0\"\n\n\nThen, reinstall your dependencies:\n\nyarn\nnpm\nyarn install\n\nOnce the installation is complete, make sure both development and production builds are working as expected before proceeding.\nInstall Nuxt Bridge\n\nInstall @nuxt/bridge-edge as a development dependency:\n\nYarn\nnpm\nyarn add --dev @nuxt/bridge@npm:@nuxt/bridge-edge\n\nUpdate nuxt.config\n\nPlease make sure to avoid any CommonJS syntax such as module.exports, require or require.resolve in your config file. It will soon be deprecated and unsupported.\n\nYou can use static import, dynamic import() and export default instead. Using TypeScript by renaming to nuxt.config.ts is also possible and recommended.\n\nnuxt.config.ts\nimport { defineNuxtConfig } from '@nuxt/bridge'\n\n\n\nexport default defineNuxtConfig({\n\n  bridge: false\n\n})\n\nUpdate Commands\n\nThe nuxt command should now be changed to the nuxt2 command.\n\n{\n\n  \"scripts\": {\n\n-   \"dev\": \"nuxt\",\n\n+   \"dev\": \"nuxt2\",\n\n-   \"build\": \"nuxt build\",\n\n+   \"build\": \"nuxt2 build\",\n\n-   \"start\": \"nuxt start\",\n\n+   \"start\": \"nuxt2 start\"\n\n  }\n\n}\n\n\nTry running nuxt2 once here. You will see that the application works as before.\n\n(If 'bridge' is set to false, your application will operate without any changes as before.)\n\nUpgrade Steps\n\nWith Nuxt Bridge, the migration to Nuxt 3 can proceed in steps. The below Upgrade Steps does not need to be done all at once.\n\nTypeScript\nMigrate Legacy Composition API\nPlugins and Middleware\nMigrate New Composition API\nMeta Tags\nRuntime Config\nNitro\nVite\nMigrate from CommonJS to ESM\n\nNuxt 3 natively supports TypeScript and ECMAScript Modules. Please check Native ES Modules for more info and upgrading.\n\nReleases\n\nDiscover the latest releases of Nuxt & Nuxt official modules.\n\nTypeScript\n\nLearn how to use TypeScript with Nuxt Bridge."
  },
  {
    "title": "Framework · Nuxt Community",
    "url": "https://nuxt.com/docs/community/framework-contribution",
    "html": "Community\nFramework\n\nSome specific points about contributions to the framework repository.\n\nOnce you've read the general contribution guide, here are some specific points to make about contributions to the nuxt/nuxt repository.\n\nMonorepo Guide\npackages/kit: Toolkit for authoring Nuxt Modules, published as @nuxt/kit.\npackages/nuxt: The core of Nuxt, published as nuxt.\npackages/schema: Cross-version Nuxt typedefs and defaults, published as @nuxt/schema.\npackages/test-utils: Test utilities for Nuxt, published as @nuxt/test-utils.\npackages/vite: The Vite bundler for Nuxt, published as @nuxt/vite-builder.\npackages/webpack: The webpack bundler for Nuxt 3, published as @nuxt/webpack-builder.\nSetup\n\nTo contribute to Nuxt, you need to set up a local environment.\n\nFork the nuxt/nuxt repository to your own GitHub account and then clone it to your local device.\nEnsure using the latest Node.js (20.x)\nEnable Corepack to have pnpm and yarn\nTerminal\ncorepack enable\n\nRun pnpm install to Install the dependencies with pnpm:\nTerminal\npnpm install\n\nIf you are adding a dependency, please use pnpm add.\nThe pnpm-lock.yaml file is the source of truth for all Nuxt dependencies.\nActivate the passive development system\nTerminal\npnpm build:stub\n\nCheck out a branch where you can work and commit your changes:\nTerminal\ngit checkout -b my-new-branch\n\n\nThen, test your changes against the playground and test your changes before submitting a pull request.\n\nPlayground\n\nWhile working on a pull request, you will likely want to check if your changes are working correctly.\n\nYou can modify the example app in playground/, and run:\n\nTerminal\npnpm dev\n\nPlease make sure not to commit it to your branch, but it could be helpful to add some example code to your PR description. This can help reviewers and other Nuxt users understand the feature you've built in-depth.\nTesting\n\nEvery new feature should have a corresponding unit test (if possible). The test/ directory in this repository is currently a work in progress, but do your best to create a new test following the example of what's already there.\n\nBefore creating a PR or marking it as ready-to-review, ensure that all tests pass by running:\n\nTerminal\npnpm test\n\nLinting\n\nYou might have noticed already that we use ESLint to enforce a coding standard.\n\nBefore committing your changes, to verify that the code style is correct, run:\n\nTerminal\npnpm lint\n\nYou can use pnpm lint --fix to fix most of the style changes.\nIf there are still errors left, you must correct them manually.\nDocumentation\n\nIf you are adding a new feature or refactoring or changing the behavior of Nuxt in any other manner, you'll likely want to document the changes. Please include any changes to the docs in the same PR. You don't have to write documentation up on the first commit (but please do so as soon as your pull request is mature enough).\n\nMake sure to make changes according to the Documentation Style Guide.\nFinal Checklist\n\nWhen submitting your PR, there is a simple template that you have to fill out. Please tick all appropriate \"answers\" in the checklists.\n\nDocumentation Guide\n\nIf you spot an area where we can improve documentation or error messages, please do open a PR - even if it's just to fix a typo!\n\nMake sure to make changes according to the Documentation Style Guide.\nQuick Edits\n\nIf you spot a typo or want to rephrase a sentence, you can click on the Edit this page link located on the right aside in the Community section.\n\nMake the change directly in the GitHub interface and open a Pull Request.\n\nLonger Edits\n\nThe documentation content is inside the docs/ directory of the nuxt/nuxt repository and written in markdown.\n\nTo preview the docs locally, follow the steps on nuxt/nuxt.com repository.\nWe recommend that you install the MDC extension for VS Code.\nLinting Docs\n\nDocumentation is linted using MarkdownLint and case police to keep the documentation cohesive.\n\nTerminal\npnpm lint:docs\n\nYou can also run pnpm lint:docs:fix to highlight and resolve any lint issues.\nOpen a PR\n\nPlease make sure your PR title adheres to the conventional commits guidelines.\n\nExample of PR title\ndocs: update the section about the nuxt.config.ts file\n\n\nContribution\n\nNuxt is a community project - and so we love contributions of all kinds! ❤️\n\nRoadmap\n\nNuxt is constantly evolving, with new features and modules being added all the time."
  },
  {
    "title": "Contribution · Nuxt Community",
    "url": "https://nuxt.com/docs/community/contribution",
    "html": "Community\nContribution\n\nNuxt is a community project - and so we love contributions of all kinds! ❤️\n\nThere is a range of different ways you might be able to contribute to the Nuxt ecosystem.\n\nEcosystem\n\nThe Nuxt ecosystem includes many different projects and organizations:\n\nnuxt/ - core repositories for the Nuxt framework itself. nuxt/nuxt contains the Nuxt framework (both versions 2 and 3).\nnuxt-modules/ - community-contributed and maintained modules and libraries. There is a process to migrate a module to nuxt-modules. While these modules have individual maintainers, they are not dependent on a single person.\nunjs/ - many of these libraries are used throughout the Nuxt ecosystem. They are designed to be universal libraries that are framework- and environment-agnostic. We welcome contributions and usage by other frameworks and projects.\nHow To Contribute\nTriage Issues and Help Out in Discussions\n\nCheck out the issues and discussions for the project you want to help. For example, here are the issues board and discussions for Nuxt 3. Helping other users, sharing workarounds, creating reproductions, or even poking into a bug a little bit and sharing your findings makes a huge difference.\n\nCreating an Issue\n\nThank you for taking the time to create an issue! ❤️\n\nReporting bugs: Check out our guide for some things to do before opening an issue.\nFeature requests: Check that there is not an existing issue or discussion covering the scope of the feature you have in mind. If the feature is to another part of the Nuxt ecosystem (such as a module), please consider raising a feature request there first. If the feature you have in mind is general or the API is not entirely clear, consider opening a discussion in the Ideas section to discuss with the community first.\n\nWe'll do our best to follow our internal issue decision making flowchart when responding to issues.\n\nSend a Pull Request\n\nWe always welcome pull requests! ❤️\n\nBefore You Start\n\nBefore you fix a bug, we recommend that you check whether there's an issue that describes it, as it's possible it's a documentation issue or that there is some context that would be helpful to know.\n\nIf you're working on a feature, then we ask that you open a feature request issue first to discuss with the maintainers whether the feature is desired - and the design of those features. This helps save time for both the maintainers and the contributors and means that features can be shipped faster. The issue should be confirmed by a framework team member before building out a feature in a pull request.\n\nFor typo fixes, it's recommended to batch multiple typo fixes into one pull request to maintain a cleaner commit history.\n\nFor bigger changes to Nuxt itself, we recommend that you first create a Nuxt module and implement the feature there. This allows for quick proof-of-concept. You can then create an RFC in the form of a discussion. As users adopt it and you gather feedback, it can then be refined and either added to Nuxt core or continue as a standalone module.\n\nCommit Conventions\n\nWe use Conventional Commits for commit messages, which allows a changelog to be auto-generated based on the commits. Please read the guide through if you aren't familiar with it already.\n\nNote that fix: and feat: are for actual code changes (that might affect logic). For typo or document changes, use docs: or chore: instead:\n\nfix: typo -> docs: fix typo\n\nIf you are working in a project with a monorepo, like nuxt/nuxt, ensure that you specify the main scope of your commit in brackets. For example: feat(nuxi): add 'do-magic' command.\n\nMaking the Pull Request\n\nIf you don't know how to send a pull request, we recommend reading the guide.\n\nWhen sending a pull request, make sure your PR's title also follows the Commit Convention.\n\nIf your PR fixes or resolves existing issues, please make sure you mention them in the PR description.\n\nIt's ok to have multiple commits in a single PR; you don't need to rebase or force push for your changes as we will use Squash and Merge to squash the commits into one commit when merging.\n\nWe do not add any commit hooks to allow for quick commits. But before you make a pull request, you should ensure that any lint/test scripts are passing.\n\nIn general, please also make sure that there are no unrelated changes in a PR. For example, if your editor has made any changes to whitespace or formatting elsewhere in a file that you edited, please revert these so it is more obvious what your PR changes. And please avoid including multiple unrelated features or fixes in a single PR. If it is possible to separate them, it is better to have multiple PRs to review and merge separately. In general, a PR should do one thing only.\n\nOnce You've Made a Pull Request\n\nOnce you've made a pull request, we'll do our best to review it promptly.\n\nIf we assign it to a maintainer, then that means that person will take special care to review it and implement any changes that may be required.\n\nIf we request changes on a PR, please ignore the red text! It doesn't mean we think it's a bad PR - it's just a way of easily telling the status of a list of pull requests at a glance.\n\nIf we mark a PR as 'pending', that means we likely have another task to do in reviewing the PR - it's an internal note-to-self, and not necessarily a reflection on whether the PR is a good idea or not. We will do our best to explain via a comment the reason for the pending status.\n\nWe'll do our best to follow our PR decision making flowchart when responding and reviewing to pull requests.\n\nCreate a Module\n\nIf you've built something with Nuxt that's cool, why not extract it into a module, so it can be shared with others? We have many excellent modules already, but there's always room for more.\n\nIf you need help while building it, feel free to check in with us.\n\nMake an RFC\n\nWe highly recommend creating a module first to test out big new features and gain community adoption.\n\nIf you have done this already, or it's not appropriate to create a new module, then please start by creating a new discussion. Make sure it explains your thinking as clearly as possible. Include code examples or function signatures for new APIs. Reference existing issues or pain points with examples.\n\nIf we think this should be an RFC, we'll change the category to RFC and broadcast it more widely for feedback.\n\nAn RFC will then move through the following stages:\n\nrfc: active - currently open for comment\nrfc: approved - approved by the Nuxt team\nrfc: ready to implement - an issue has been created and assigned to implement\nrfc: shipped - implemented\nrfc: archived - not approved, but archived for future reference\nConventions Across Ecosystem\n\nThe following conventions are required within the nuxt/ organization and recommended for other maintainers in the ecosystem.\n\nModule Conventions\n\nModules should follow the Nuxt module template. See module guide for more information.\n\nUse Core unjs/ Libraries\n\nWe recommend the following libraries which are used throughout the ecosystem:\n\npathe - universal path utilities (replacement for node path)\nufo - URL parsing and joining utilities\nunbuild - rollup-powered build system\n... check out the rest of the unjs/ organization for many more!\nUse ESM Syntax and Default to type: module\n\nMost of the Nuxt ecosystem can consume ESM directly. In general we advocate that you avoid using CJS-specific code, such as __dirname and require statements. You can read more about ESM.\n\nWhat's Corepack\n\nCorepack makes sure you are using the correct version for package manager when you run corresponding commands. Projects might have packageManager field in their package.json.\n\nUnder projects with configuration as shown below, Corepack will install v7.5.0 of pnpm (if you don't have it already) and use it to run your commands.\n\npackage.json\n{\n\n  \"packageManager\": \"pnpm@7.5.0\"\n\n}\n\nUse ESLint\n\nWe use ESLint for both linting and formatting with @nuxt/eslint-config.\n\nIDE Setup\n\nWe recommend using VS Code along with the ESLint extension. If you would like, you can enable auto-fix and formatting when you save the code you are editing:\n\nsettings.json\n{\n\n  \"editor.codeActionsOnSave\": {\n\n    \"source.fixAll\": false,\n\n    \"source.fixAll.eslint\": true\n\n  }\n\n}\n\nNo Prettier\n\nSince ESLint is already configured to format the code, there is no need to duplicate the functionality with Prettier. To format the code, you can run yarn lint --fix, pnpm lint --fix, or bun run lint --fix or referring the ESLint section for IDE Setup.\n\nIf you have Prettier installed in your editor, we recommend you disable it when working on the project to avoid conflict.\n\nNote: we are discussing enabling Prettier in future.\n\nPackage Manager\n\nFor libraries, we recommend pnpm. For modules, we still recommend yarn but we may well switch this recommendation to pnpm in future once we support plug and play mode with Nuxt itself.\n\nIt is important to enable Corepack to ensure you are on the same version of the package manager as the project. Corepack is built-in to new node versions for seamless package manager integration.\n\nTo enable it, run\n\nTerminal\ncorepack enable\n\n\nYou only need to do this one time, after Node.js is installed on your computer.\n\nDocumentation Style Guide\n\nDocumentation is an essential part of Nuxt. We aim to be an intuitive framework - and a big part of that is making sure that both the developer experience and the docs are perfect across the ecosystem. 👌\n\nHere are some tips that may help improve your documentation:\n\nAvoid subjective words like simply, just, obviously... when possible.\nKeep in mind your readers can have different backgrounds and experiences. Therefore, these words don't convey meaning and can be harmful.\nSimply make sure the function returns a promise.\nMake sure the function returns a promise.\nPrefer active voice.\nAn error will be thrown by Nuxt.\nNuxt will throw an error.\nLearn how to contribute to the documentation.\n\nReporting Bugs\n\nOne of the most valuable roles in open source is taking the time to report bugs helpfully.\n\nFramework\n\nSome specific points about contributions to the framework repository."
  },
  {
    "title": "Migrate to Nuxt 3: Configuration",
    "url": "https://nuxt.com/docs/migration/configuration#vuex",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nConfiguration\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 new configuration.\n\nnuxt.config\n\nThe starting point for your Nuxt app remains your nuxt.config file.\n\nNuxt configuration will be loaded using unjs/jiti and unjs/c12.\nMigration\nYou should migrate to the new defineNuxtConfig function that provides a typed configuration schema.\nNuxt 2\nNuxt 3\nexport default {\n\n  // ...\n\n}\n\nIf you were using router.extendRoutes you can migrate to the new pages:extend hook:\nNuxt 2\nNuxt 3\nexport default {\n\n  router: {\n\n    extendRoutes (routes) {\n\n      //\n\n    }\n\n  }\n\n}\n\nESM Syntax\n\nNuxt 3 is an ESM native framework. Although unjs/jiti provides semi compatibility when loading nuxt.config file, avoid any usage of require and module.exports in this file.\n\nChange module.exports to export default\nChange const lib = require('lib') to import lib from 'lib'\nAsync Configuration\n\nIn order to make Nuxt loading behavior more predictable, async config syntax is deprecated. Consider using Nuxt hooks for async operations.\n\nDotenv\n\nNuxt has built-in support for loading .env files. Avoid directly importing it from nuxt.config.\n\nModules\n\nNuxt and Nuxt Modules are now build-time-only.\n\nMigration\nMove all your buildModules into modules.\nCheck for Nuxt 3 compatibility of modules.\nIf you have any local modules pointing to a directory you should update this to point to the entry file:\n  export default defineNuxtConfig({\n\n    modules: [\n\n-     '~/modules/my-module'\n\n+     '~/modules/my-module/index'\n\n    ]\n\n  })\n\nIf you are a module author, you can check out more information about module compatibility and our module author guide.\nDirectory Changes\n\nThe static/ (for storing static assets) has been renamed to public/. You can either rename your static directory to public, or keep the name by setting dir.public in your nuxt.config.\n\n Read more in Docs > Guide > Directory Structure > Public.\nTypeScript\n\nIt will be much easier to migrate your application if you use Nuxt's TypeScript integration. This does not mean you need to write your application in TypeScript, just that Nuxt will provide automatic type hints for your editor.\n\nYou can read more about Nuxt's TypeScript support in the docs.\n\nNuxt can type-check your app using vue-tsc with nuxi typecheck command.\nMigration\nCreate a tsconfig.json with the following content:\n{\n\n  \"extends\": \"./.nuxt/tsconfig.json\"\n\n}\n\nRun npx nuxi prepare to generate .nuxt/tsconfig.json.\nInstall Volar following the instructions in the docs.\nVue Changes\n\nThere are a number of changes to what is recommended Vue best practice, as well as a number of breaking changes between Vue 2 and 3.\n\nIt is recommended to read the Vue 3 migration guide and in particular the breaking changes list.\n\nIt is not currently possible to use the Vue 3 migration build with Nuxt 3.\n\nVuex\n\nNuxt no longer provides a Vuex integration. Instead, the official Vue recommendation is to use pinia, which has built-in Nuxt support via a Nuxt module. Find out more about pinia here.\n\nA simple way to provide global state management with pinia would be:\n\nInstall the @pinia/nuxt module:\n\nTerminal\nyarn add pinia @pinia/nuxt\n\n\nEnable the module in your nuxt configuration:\n\nnuxt.config.ts\nimport { defineNuxtConfig } from 'nuxt/config';\n\n\n\nexport default defineNuxtConfig({\n\n  modules: ['@pinia/nuxt']\n\n})\n\n\nCreate a store folder at the root of your application:\n\nstore/index.ts\nimport { defineStore } from 'pinia'\n\n\n\nexport const useMainStore = defineStore('main', {\n\n  state: () => ({\n\n    counter: 0,\n\n  }),\n\n  actions: {\n\n    increment() {\n\n      // `this` is the store instance\n\n      this.counter++\n\n    },\n\n  },\n\n})\n\n\nCreate a plugin file to globalize your store:\n\nplugins/pinia.ts\nimport { useMainStore } from '~/store'\n\n\n\nexport default defineNuxtPlugin(({ $pinia }) => {\n\n  return {\n\n    provide: {\n\n      store: useMainStore($pinia)\n\n    }\n\n  }\n\n})\n\n\nIf you want to keep using Vuex, you can manually migrate to Vuex 4 following these steps.\n\nOnce it's done you will need to add the following plugin to your Nuxt app:\n\nplugins/vuex.ts\nimport store from '~/store'\n\n\n\nexport default defineNuxtPlugin(nuxtApp => {\n\n  nuxtApp.vueApp.use(store);\n\n})\n\n\nFor larger apps, this migration can entail a lot of work. If updating Vuex still creates roadblocks, you may want to use the community module: nuxt3-vuex-module, which should work out of the box.\n\nOverview\n\nNuxt 3 is a complete rewrite of Nuxt 2, and also based on a new set of underlying technologies.\n\nAuto Imports\n\nNuxt 3 adopts a minimal friction approach, meaning wherever possible components and composables are auto-imported."
  },
  {
    "title": "Reporting Bugs · Nuxt Community",
    "url": "https://nuxt.com/docs/community/reporting-bugs",
    "html": "Community\nReporting Bugs\n\nOne of the most valuable roles in open source is taking the time to report bugs helpfully.\n\nTry as we might, we will never completely eliminate bugs.\n\nEven if you can't fix the underlying code, reporting a bug well can enable someone else with a bit more familiarity with the codebase to spot a pattern or make a quick fix.\n\nHere are a few key steps.\n\nIs It Really a Bug?\n\nConsider if you're looking to get help with something, or whether you think there's a bug with Nuxt itself. If it's the former, we'd love to help you - but the best way to do that is through asking for help rather than reporting a bug.\n\nSearch the Issues\n\nSearch through the open issues and discussions first. If you find anything that seems like the same bug, it's much better to comment on an existing thread than create a duplicate.\n\nCreate a Minimal Reproduction\n\nIt's important to be able to reproduce the bug reliably - in a minimal way and apart from the rest of your project. This narrows down what could be causing the issue and makes it possible for someone not only to find the cause, but also to test a potential solution.\n\nStart with the Nuxt 3 or Nuxt Bridge sandbox and add the minimum amount of code necessary to reproduce the bug you're experiencing.\n\nIf your issue concerns Vue 3 or Vite, please try to reproduce it first with the Vue 3 SSR starter.\n\nNuxt 3:\n\nNuxt 3 on StackBlitz\n\nNuxt 3 on CodeSandbox\n\nNuxt Bridge:\n\nNuxt Bridge on CodeSandbox\n\nVue 3:\n\nVue 3 SSR on StackBlitz\n\nVue 3 SSR on CodeSandbox\n\nVue 3 SSR Template on GitHub\n\nOnce you've reproduced the issue, remove as much code from your reproduction as you can (while still recreating the bug). The time spent making the reproduction as minimal as possible will make a huge difference to whoever sets out to fix the issue.\n\nFigure Out What the Cause Might Be\n\nWith a Nuxt project, there are lots of moving pieces - from Nuxt modules to other JavaScript libraries. Try to report the bug at the most relevant and specific place. That will likely be the Nuxt module causing an issue, or the upstream library that Nuxt is depending on.\n\nGetting Help\n\nWe're a friendly community of developers and we'd love to help.\n\nContribution\n\nNuxt is a community project - and so we love contributions of all kinds! ❤️"
  },
  {
    "title": "useAppConfig · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-app-config",
    "html": "Composables\nuseAppConfig\nSource\n\nAccess the reactive app config defined in the project.\n\nUsage\nconst appConfig = useAppConfig()\n\n\n\nconsole.log(appConfig)\n\n Read more in Docs > Guide > Directory Structure > App Config.\n\n<Teleport>\n\nThe <Teleport> component teleports a component to a different location in the DOM.\n\nuseAsyncData\n\nuseAsyncData provides access to data that resolves asynchronously in a SSR-friendly composable."
  },
  {
    "title": "Getting Help · Nuxt Community",
    "url": "https://nuxt.com/docs/community/getting-help",
    "html": "Community\nGetting Help\n\nWe're a friendly community of developers and we'd love to help.\n\nAt some point, you may find that there's an issue you need some help with.\n\nBut don't worry! We're a friendly community of developers and we'd love to help.\n\n\"I can't figure out how to (...).\"\n\nYou've read through these docs and you think it should be possible, but it's not clear how. The best thing is to open a GitHub Discussion.\n\nPlease don't feel embarrassed about asking a question that you think is easy - we've all been there! ❤️\n\nEveryone you'll encounter is helping out because they care, not because they are paid to do so. The kindest thing to do is make it easy for them to help you. Here are some ideas:\n\nExplain what your objective is, not just the problem you're facing. \"I need to ensure my form inputs are accessible, so I'm trying to get the ids to match between server and client.\"\nMake sure you've first read the docs and used your favorite search engine. Let people know by saying something like \"I've Googled for 'nuxt script setup' but I couldn't find code examples anywhere.\"\nExplain what you've tried. Tell people the kind of solutions you've experimented with, and why. Often this can make people's advice more relevant to your situation.\nShare your code. People probably won't be able to help if they just see an error message or a screenshot - but that all changes if you share your code in a copy/pasteable format - preferably in the form of a minimal reproduction like a CodeSandbox.\n\nAnd finally, just ask the question! There's no need to ask permission to ask a question or wait for someone to reply to your 'hello'. If you do, you might not get a response because people are waiting for the whole question before engaging.\n\n\"Could there be a bug?\"\n\nSomething isn't working the way that the docs say that it should. You're not sure if it's a bug. You've searched through the open issues and discussions but you can't find anything. (if there is a closed issue, please create a new one)\n\nWe recommend taking a look at how to report bugs. Nuxt 3 is still in active development, and every issue helps make it better.\n\nNuxt Configuration\n\nDiscover all the options you can use in your nuxt.config.ts file.\n\nReporting Bugs\n\nOne of the most valuable roles in open source is taking the time to report bugs helpfully."
  },
  {
    "title": "Builder · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/builder",
    "html": "Nuxt Kit\nBuilder\nSource\n\nNuxt Kit provides a set of utilities to help you work with the builder. These functions allow you to extend the webpack and vite configurations.\n\nNuxt have builders based on webpack and vite. You can extend the config passed to each one using extendWebpackConfig and extendViteConfig functions. You can also add additional plugins via addVitePlugin, addWebpackPlugin and addBuildPlugin.\n\nextendWebpackConfig\n\nExtends the webpack configuration. Callback function can be called multiple times, when applying to both client and server builds.\n\nType\nfunction extendWebpackConfig (callback: ((config: WebpackConfig) => void), options?: ExtendWebpackConfigOptions): void\n\n\n\nexport interface ExtendWebpackConfigOptions {\n\n  dev?: boolean\n\n  build?: boolean\n\n  server?: boolean\n\n  client?: boolean\n\n  prepend?: boolean\n\n}\n\nCheckout webpack website for more information about its configuration.\nParameters\ncallback\n\nType: (config: WebpackConfig) => void\n\nRequired: true\n\nA callback function that will be called with the webpack configuration object.\n\noptions\n\nType: ExtendWebpackConfigOptions\n\nDefault: {}\n\nOptions to pass to the callback function. This object can have the following properties:\n\ndev (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in development mode.\nbuild (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in production mode.\nserver (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the server bundle.\nclient (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the client bundle.\nprepend (optional)\nType: boolean\nIf set to true, the callback function will be prepended to the array with unshift() instead of push().\nExamples\nimport { defineNuxtModule, extendWebpackConfig } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    extendWebpackConfig((config) => {\n\n      config.module?.rules.push({\n\n        test: /\\.txt$/,\n\n        use: 'raw-loader'\n\n      })\n\n    })\n\n  }\n\n})\n\nextendViteConfig\n\nExtends the Vite configuration. Callback function can be called multiple times, when applying to both client and server builds.\n\nType\nfunction extendViteConfig (callback: ((config: ViteConfig) => void), options?: ExtendViteConfigOptions): void\n\n\n\nexport interface ExtendViteConfigOptions {\n\n  dev?: boolean\n\n  build?: boolean\n\n  server?: boolean\n\n  client?: boolean\n\n  prepend?: boolean\n\n}\n\nCheckout Vite website for more information about its configuration.\nParameters\ncallback\n\nType: (config: ViteConfig) => void\n\nRequired: true\n\nA callback function that will be called with the Vite configuration object.\n\noptions\n\nType: ExtendViteConfigOptions\n\nDefault: {}\n\nOptions to pass to the callback function. This object can have the following properties:\n\ndev (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in development mode.\nbuild (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in production mode.\nserver (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the server bundle.\nclient (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the client bundle.\nprepend (optional)\nType: boolean\nIf set to true, the callback function will be prepended to the array with unshift() instead of push().\nExamples\n// https://github.com/Hrdtr/nuxt-appwrite\n\nimport { defineNuxtModule, extendViteConfig } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    extendViteConfig((config) => {\n\n      config.optimizeDeps = config.optimizeDeps || {}\n\n      config.optimizeDeps.include = config.optimizeDeps.include || []\n\n      config.optimizeDeps.include.push('cross-fetch')\n\n    })\n\n  }\n\n})\n\naddWebpackPlugin\n\nAppend webpack plugin to the config.\n\nType\nfunction addWebpackPlugin (pluginOrGetter: PluginOrGetter, options?: ExtendWebpackConfigOptions): void\n\n\n\ntype PluginOrGetter = WebpackPluginInstance | WebpackPluginInstance[] | (() => WebpackPluginInstance | WebpackPluginInstance[])\n\n\n\ninterface ExtendWebpackConfigOptions {\n\n  dev?: boolean\n\n  build?: boolean\n\n  server?: boolean\n\n  client?: boolean\n\n  prepend?: boolean\n\n}\n\nSee webpack website for more information about webpack plugins. You can also use this collection to find a plugin that suits your needs.\nParameters\npluginOrGetter\n\nType: PluginOrGetter\n\nRequired: true\n\nA webpack plugin instance or an array of webpack plugin instances. If a function is provided, it must return a webpack plugin instance or an array of webpack plugin instances.\n\noptions\n\nType: ExtendWebpackConfigOptions\n\nDefault: {}\n\nOptions to pass to the callback function. This object can have the following properties:\n\ndev (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in development mode.\nbuild (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in production mode.\nserver (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the server bundle.\nclient (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the client bundle.\nprepend (optional)\nType: boolean\nIf set to true, the callback function will be prepended to the array with unshift() instead of push().\nExamples\n// https://github.com/nuxt-modules/eslint\n\nimport EslintWebpackPlugin from 'eslint-webpack-plugin'\n\nimport { defineNuxtModule, addWebpackPlugin } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'nuxt-eslint',\n\n    configKey: 'eslint',\n\n  },\n\n  defaults: nuxt => ({\n\n    include: [`${nuxt.options.srcDir}/**/*.{js,jsx,ts,tsx,vue}`],\n\n    lintOnStart: true,\n\n  }),\n\n  setup(options, nuxt) {\n\n    const webpackOptions = {\n\n      ...options,\n\n      context: nuxt.options.srcDir,\n\n      files: options.include,\n\n      lintDirtyModulesOnly: !options.lintOnStart\n\n    } \n\n    addWebpackPlugin(new EslintWebpackPlugin(webpackOptions), { server: false })\n\n  }\n\n})\n\naddVitePlugin\n\nAppend Vite plugin to the config.\n\nType\nfunction addVitePlugin (pluginOrGetter: PluginOrGetter, options?: ExtendViteConfigOptions): void\n\n\n\ntype PluginOrGetter = VitePlugin | VitePlugin[] | (() => VitePlugin | VitePlugin[])\n\n\n\ninterface ExtendViteConfigOptions {\n\n  dev?: boolean\n\n  build?: boolean\n\n  server?: boolean\n\n  client?: boolean\n\n  prepend?: boolean\n\n}\n\nSee Vite website for more information about Vite plugins. You can also use this repository to find a plugin that suits your needs.\nParameters\npluginOrGetter\n\nType: PluginOrGetter\n\nRequired: true\n\nA Vite plugin instance or an array of Vite plugin instances. If a function is provided, it must return a Vite plugin instance or an array of Vite plugin instances.\n\noptions\n\nType: ExtendViteConfigOptions\n\nDefault: {}\n\nOptions to pass to the callback function. This object can have the following properties:\n\ndev (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in development mode.\nbuild (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in production mode.\nserver (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the server bundle.\nclient (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the client bundle.\nprepend (optional)\nType: boolean\nIf set to true, the callback function will be prepended to the array with unshift() instead of push().\nExamples\n// https://github.com/yisibell/nuxt-svg-icons\n\nimport { defineNuxtModule, addVitePlugin } from '@nuxt/kit'\n\nimport { svg4VuePlugin } from 'vite-plugin-svg4vue'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'nuxt-svg-icons',\n\n    configKey: 'nuxtSvgIcons',\n\n  },\n\n  defaults: {\n\n    svg4vue: {\n\n      assetsDirName: 'assets/icons',\n\n    },\n\n  },\n\n  setup(options) {\n\n    addVitePlugin(svg4VuePlugin(options.svg4vue))\n\n  },\n\n})\n\naddBuildPlugin\n\nBuilder-agnostic version of addWebpackPlugin and addVitePlugin. It will add the plugin to both webpack and vite configurations if they are present.\n\nType\nfunction addBuildPlugin (pluginFactory: AddBuildPluginFactory, options?: ExtendConfigOptions): void\n\n\n\ninterface AddBuildPluginFactory {\n\n  vite?: () => VitePlugin | VitePlugin[]\n\n  webpack?: () => WebpackPluginInstance | WebpackPluginInstance[]\n\n}\n\n\n\ninterface ExtendConfigOptions {\n\n  dev?: boolean\n\n  build?: boolean\n\n  server?: boolean\n\n  client?: boolean\n\n  prepend?: boolean\n\n}\n\nParameters\npluginFactory\n\nType: AddBuildPluginFactory\n\nRequired: true\n\nA factory function that returns an object with vite and/or webpack properties. These properties must be functions that return a Vite plugin instance or an array of Vite plugin instances and/or a webpack plugin instance or an array of webpack plugin instances.\n\noptions\n\nType: ExtendConfigOptions\n\nDefault: {}\n\nOptions to pass to the callback function. This object can have the following properties:\n\ndev (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in development mode.\nbuild (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building in production mode.\nserver (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the server bundle.\nclient (optional)\nType: boolean\nDefault: true\nIf set to true, the callback function will be called when building the client bundle.\nprepend (optional)\nType: boolean\nIf set to true, the callback function will be prepended to the array with unshift() instead of push().\n\nLogging\n\nNuxt Kit provides a set of utilities to help you work with logging. These functions allow you to log messages with extra features.\n\nExamples\n\nExamples of Nuxt Kit utilities in use."
  },
  {
    "title": "Plugins · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/plugins",
    "html": "Nuxt Kit\nPlugins\nSource\n\nNuxt Kit provides a set of utilities to help you create and use plugins. You can add plugins or plugin templates to your module using these functions.\n\nPlugins are self-contained code that usually add app-level functionality to Vue. In Nuxt, plugins are automatically imported from the plugins directory. However, if you need to ship a plugin with your module, Nuxt Kit provides the addPlugin and addPluginTemplate methods. These utils allow you to customize the plugin configuration to better suit your needs.\n\naddPlugin\n\nRegisters a Nuxt plugin and to the plugins array.\n\nType\nfunction addPlugin (plugin: NuxtPlugin | string, options: AddPluginOptions): NuxtPlugin\n\n\n\ninterface NuxtPlugin {\n\n  src: string\n\n  mode?: 'all' | 'server' | 'client'\n\n  order?: number\n\n}\n\n\n\ninterface AddPluginOptions { append?: boolean }\n\nParameters\nplugin\n\nType: NuxtPlugin | string\n\nRequired: true\n\nA plugin object or a string with the path to the plugin. If a string is provided, it will be converted to a plugin object with src set to the string value. If a plugin object is provided, it must have the following properties:\n\nsrc (required)\nType: string\nPath to the plugin.\nmode (optional)\nType: 'all' | 'server' | 'client'\nDefault: 'all'\nIf set to 'all', the plugin will be included in both client and server bundles. If set to 'server', the plugin will only be included in the server bundle. If set to 'client', the plugin will only be included in the client bundle. You can also use .client and .server modifiers when specifying src option to use plugin only in client or server side.\norder (optional)\nType: number\nDefault: 0\nOrder of the plugin. This allows more granular control over plugin order and should only be used by advanced users. Lower numbers run first, and user plugins default to 0. It's recommended to set order to a number between -20 for pre-plugins (plugins that run before Nuxt plugins) and 20 for post-plugins (plugins that run after Nuxt plugins).\nDon't use order unless you know what you're doing. For most plugins, the default order of 0 is sufficient. To append a plugin to the end of the plugins array, use the append option instead.\noptions\n\nType: AddPluginOptions\n\nDefault: {}\n\nOptions to pass to the plugin. If append is set to true, the plugin will be appended to the plugins array instead of prepended.\n\nExamples\nmodule.ts\nruntime/plugin.js\nimport { createResolver, defineNuxtModule, addPlugin } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    addPlugin({\n\n      src: resolver.resolve('runtime/plugin.js'),\n\n      mode: 'client'\n\n    })\n\n  }\n\n})\n\naddPluginTemplate\n\nAdds a template and registers as a nuxt plugin. This is useful for plugins that need to generate code at build time.\n\nType\nfunction addPluginTemplate (pluginOptions: NuxtPluginTemplate, options: AddPluginOptions): NuxtPlugin\n\n\n\ninterface NuxtPluginTemplate<Options = Record<string, any>> {\n\n  src?: string,\n\n  filename?: string,\n\n  dst?: string,\n\n  mode?: 'all' | 'server' | 'client',\n\n  options?: Options,\n\n  getContents?: (data: Options) => string | Promise<string>,\n\n  write?: boolean,\n\n  order?: number\n\n}\n\n\n\ninterface AddPluginOptions { append?: boolean }\n\n\n\ninterface NuxtPlugin {\n\n  src: string\n\n  mode?: 'all' | 'server' | 'client'\n\n  order?: number\n\n}\n\nParameters\npluginOptions\n\nType: NuxtPluginTemplate\n\nRequired: true\n\nA plugin template object with the following properties:\n\nsrc (optional)\nType: string\nPath to the template. If src is not provided, getContents must be provided instead.\nfilename (optional)\nType: string\nFilename of the template. If filename is not provided, it will be generated from the src path. In this case, the src option is required.\ndst (optional)\nType: string\nPath to the destination file. If dst is not provided, it will be generated from the filename path and nuxt buildDir option.\nmode (optional)\nType: 'all' | 'server' | 'client'\nDefault: 'all'\nIf set to 'all', the plugin will be included in both client and server bundles. If set to 'server', the plugin will only be included in the server bundle. If set to 'client', the plugin will only be included in the client bundle. You can also use .client and .server modifiers when specifying src option to use plugin only in client or server side.\noptions (optional)\nType: Options\nOptions to pass to the template.\ngetContents (optional)\nType: (data: Options) => string | Promise<string>\nA function that will be called with the options object. It should return a string or a promise that resolves to a string. If src is provided, this function will be ignored.\nwrite (optional)\nType: boolean\nIf set to true, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.\norder (optional)\nType: number\nDefault: 0\nOrder of the plugin. This allows more granular control over plugin order and should only be used by advanced users. Lower numbers run first, and user plugins default to 0. It's recommended to set order to a number between -20 for pre-plugins (plugins that run before Nuxt plugins) and 20 for post-plugins (plugins that run after Nuxt plugins).\nDon't use order unless you know what you're doing. For most plugins, the default order of 0 is sufficient. To append a plugin to the end of the plugins array, use the append option instead.\noptions\n\nType: AddPluginOptions\n\nDefault: {}\n\nOptions to pass to the plugin. If append is set to true, the plugin will be appended to the plugins array instead of prepended.\n\nExamples\nmodule.ts\nruntime/plugin.ejs\n// https://github.com/vuejs/vuefire\n\nimport { createResolver, defineNuxtModule, addPluginTemplate } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    addPluginTemplate({\n\n      src: resolve(templatesDir, 'plugin.ejs'),\n\n      options: {\n\n        ...options,\n\n        ssr: nuxt.options.ssr,\n\n      },\n\n    })\n\n  }\n\n})\n\n\nLayout\n\nNuxt Kit provides a set of utilities to help you work with layouts.\n\nTemplates\n\nNuxt Kit provides a set of utilities to help you work with templates. These functions allow you to generate extra files during development and build time."
  },
  {
    "title": "Import meta · Nuxt API",
    "url": "https://nuxt.com/docs/api/advanced/import-meta",
    "html": "Advanced\nImport meta\n\nUnderstand where your code is running using `import.meta`.\n\nThe import.meta object\n\nWith ES modules you can obtain some metadata from the code that imports or compiles your ES-module. This is done through import.meta, which is an object that provides your code with this information. Throughout the Nuxt documentation you may see snippets that use this already to figure out whether the code is currently running on the client or server side.\n\n Read more in https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import.meta.\nRuntime (App) Properties\n\nThese values are statically injected and can be used for tree-shaking your runtime code.\n\nProperty\tType\tDescription\nimport.meta.client\tboolean\tTrue when evaluated on the client side.\nimport.meta.browser\tboolean\tTrue when evaluated on the client side.\nimport.meta.server\tboolean\tTrue when evaluated on the server side.\nimport.meta.nitro\tboolean\tTrue when evaluated on the server side.\nimport.meta.dev\tboolean\tTrue when running the Nuxt dev server.\nimport.meta.test\tboolean\tTrue when running in a test context.\nimport.meta.prerender\tboolean\tTrue when rendering HTML on the server in the prerender stage of your build.\nBuilder Properties\n\nThese values are available both in modules and in your nuxt.config.\n\nProperty\tType\tDescription\nimport.meta.env\tobject\tEquals process.env\nimport.meta.url\tstring\tResolvable path for the current file.\nExamples\nUsing import.meta.url to resolve files within modules\nmodules/my-module/index.ts\nimport { createResolver } from 'nuxt/kit'\n\n\n\n// Resolve relative from the current file\n\nconst resolver = createResolver(import.meta.url)\n\n\n\nexport default defineNuxtModule({\n\n  meta: { name: 'myModule' },\n\n  setup() {\n\n    addComponent({\n\n      name: 'MyModuleComponent',\n\n      // Resolves to '/modules/my-module/components/MyModuleComponent.vue'\n\n      filePath: resolver.resolve('./components/MyModuleComponent.vue')\n\n    })\n\n  }\n\n})\n\n\nLifecycle Hooks\n\nNuxt provides a powerful hooking system to expand almost every aspect using hooks.\n\nNuxt Configuration\n\nDiscover all the options you can use in your nuxt.config.ts file."
  },
  {
    "title": "Templates · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/templates",
    "html": "Nuxt Kit\nTemplates\nSource\n\nNuxt Kit provides a set of utilities to help you work with templates. These functions allow you to generate extra files during development and build time.\n\nTemplates allows to generate extra files during development and build time. These files will be available in virtual filesystem and can be used in plugins, layouts, components, etc. addTemplate and addTypeTemplate allow you to add templates to the Nuxt application. updateTemplates allows you to regenerate templates that match the filter.\n\naddTemplate\n\nRenders given template during build into the project buildDir.\n\nType\nfunction addTemplate (template: NuxtTemplate | string): ResolvedNuxtTemplate\n\n\n\ninterface NuxtTemplate {\n\n  src?: string\n\n  filename?: string\n\n  dst?: string\n\n  options?: Record<string, any>\n\n  getContents?: (data: Record<string, any>) => string | Promise<string>\n\n  write?: boolean\n\n}\n\n\n\ninterface ResolvedNuxtTemplate {\n\n  src: string\n\n  filename: string\n\n  dst: string\n\n  options: Record<string, any>\n\n  getContents: (data: Record<string, any>) => string | Promise<string>\n\n  write: boolean\n\n  filename: string\n\n  dst: string\n\n}\n\nParameters\ntemplate\n\nType: NuxtTemplate | string\n\nRequired: true\n\nA template object or a string with the path to the template. If a string is provided, it will be converted to a template object with src set to the string value. If a template object is provided, it must have the following properties:\n\nsrc (optional)\nType: string\nPath to the template. If src is not provided, getContents must be provided instead.\nfilename (optional)\nType: string\nFilename of the template. If filename is not provided, it will be generated from the src path. In this case, the src option is required.\ndst (optional)\nType: string\nPath to the destination file. If dst is not provided, it will be generated from the filename path and nuxt buildDir option.\noptions (optional)\nType: Options\nOptions to pass to the template.\ngetContents (optional)\nType: (data: Options) => string | Promise<string>\nA function that will be called with the options object. It should return a string or a promise that resolves to a string. If src is provided, this function will be ignored.\nwrite (optional)\nType: boolean\nIf set to true, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.\nExamples\nmodule.ts\nplugin.ts\n// https://github.com/nuxt/bridge\n\nimport { addTemplate, defineNuxtModule } from '@nuxt/kit'\n\nimport { defu } from 'defu'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options, nuxt) {\n\n    const globalMeta = defu(nuxt.options.app.head, {\n\n      charset: options.charset,\n\n      viewport: options.viewport\n\n    })\n\n\n\n    addTemplate({\n\n      filename: 'meta.config.mjs',\n\n      getContents: () => 'export default ' + JSON.stringify({ globalMeta, mixinKey: 'setup' })\n\n    })\n\n  }\n\n})\n\naddTypeTemplate\n\nRenders given template during build into the project buildDir, then registers it as types.\n\nType\nfunction addTypeTemplate (template: NuxtTypeTemplate | string): ResolvedNuxtTemplate\n\n\n\ninterface NuxtTemplate {\n\n  src?: string\n\n  filename?: string\n\n  dst?: string\n\n  options?: Record<string, any>\n\n  getContents?: (data: Record<string, any>) => string | Promise<string>\n\n}\n\n\n\ninterface ResolvedNuxtTemplate {\n\n  src: string\n\n  filename: string\n\n  dst: string\n\n  options: Record<string, any>\n\n  getContents: (data: Record<string, any>) => string | Promise<string>\n\n  write: boolean\n\n  filename: string\n\n  dst: string\n\n}\n\nParameters\ntemplate\n\nType: NuxtTypeTemplate | string\n\nRequired: true\n\nA template object or a string with the path to the template. If a string is provided, it will be converted to a template object with src set to the string value. If a template object is provided, it must have the following properties:\n\nsrc (optional)\nType: string\nPath to the template. If src is not provided, getContents must be provided instead.\nfilename (optional)\nType: string\nFilename of the template. If filename is not provided, it will be generated from the src path. In this case, the src option is required.\ndst (optional)\nType: string\nPath to the destination file. If dst is not provided, it will be generated from the filename path and nuxt buildDir option.\noptions (optional)\nType: Options\nOptions to pass to the template.\ngetContents (optional)\nType: (data: Options) => string | Promise<string>\nA function that will be called with the options object. It should return a string or a promise that resolves to a string. If src is provided, this function will be ignored.\nExamples\n// https://github.com/Hebilicious/nuxtpress\n\nimport { addTypeTemplate, defineNuxtModule } from \"@nuxt/kit\"\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    addTypeTemplate({\n\n      filename: \"types/markdown.d.ts\",\n\n      getContents: () => /* ts */`\n\n      declare module '*.md' {\n\n        import type { ComponentOptions } from 'vue'\n\n        const Component: ComponentOptions\n\n        export default Component\n\n      }`\n\n    })\n\n  }\n\n}\n\nupdateTemplates\n\nRegenerate templates that match the filter. If no filter is provided, all templates will be regenerated.\n\nType\nasync function updateTemplates (options: UpdateTemplatesOptions): void\n\n\n\ninterface UpdateTemplatesOptions {\n\n  filter?: (template: ResolvedNuxtTemplate) => boolean\n\n}\n\n\n\ninterface ResolvedNuxtTemplate {\n\n  src: string\n\n  filename: string\n\n  dst: string\n\n  options: Record<string, any>\n\n  getContents: (data: Record<string, any>) => string | Promise<string>\n\n  write: boolean\n\n  filename: string\n\n  dst: string\n\n}\n\nParameters\noptions\n\nType: UpdateTemplatesOptions\n\nDefault: {}\n\nOptions to pass to the template. This object can have the following property:\n\nfilter (optional)\nType: (template: ResolvedNuxtTemplate) => boolean\nA function that will be called with the template object. It should return a boolean indicating whether the template should be regenerated. If filter is not provided, all templates will be regenerated.\nExample\n// https://github.com/nuxt/nuxt\n\nimport { defineNuxtModule, updateTemplates } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options, nuxt) {\n\n    // watch and rebuild routes template list when one of the pages changes\n\n    nuxt.hook('builder:watch', async (event, relativePath) => {\n\n      if (event === 'change') { return }\n\n\n\n      const path = resolve(nuxt.options.srcDir, relativePath)\n\n      if (updateTemplatePaths.some(dir => path.startsWith(dir))) {\n\n        await updateTemplates({\n\n          filter: template => template.filename === 'routes.mjs'\n\n        })\n\n      }\n\n    })\n\n  }\n\n})\n\n\nPlugins\n\nNuxt Kit provides a set of utilities to help you create and use plugins. You can add plugins or plugin templates to your module using these functions.\n\nNitro\n\nNuxt Kit provides a set of utilities to help you work with Nitro. These functions allow you to add server handlers, plugins, and prerender routes."
  },
  {
    "title": "Resolving · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/resolving",
    "html": "Nuxt Kit\nResolving\nSource\n\nNuxt Kit provides a set of utilities to help you resolve paths. These functions allow you to resolve paths relative to the current module, with unknown name or extension.\n\nSometimes you need to resolve a paths: relative to the current module, with unknown name or extension. For example, you may want to add a plugin that is located in the same directory as the module. To handle this cases, nuxt provides a set of utilities to resolve paths. resolvePath and resolveAlias are used to resolve paths relative to the current module. findPath is used to find first existing file in given paths. createResolver is used to create resolver relative to base path.\n\nresolvePath\n\nResolves full path to a file or directory respecting Nuxt alias and extensions options. If path could not be resolved, normalized input path will be returned.\n\nType\nasync function resolvePath (path: string, options?: ResolvePathOptions): Promise<string>\n\nParameters\npath\n\nType: string\n\nRequired: true\n\nPath to resolve.\n\noptions\n\nType: ResolvePathOptions\n\nDefault: {}\n\nOptions to pass to the resolver. This object can have the following properties:\n\ncwd (optional)\nType: string\nDefault: process.cwd()\nCurrent working directory.\nalias (optional)\nType: Record<string, string>\nDefault: {}\nAlias map.\nextensions (optional)\nType: string[]\nDefault: ['.js', '.mjs', '.ts', '.jsx', '.tsx', '.json']\nExtensions to try.\nExamples\n// https://github.com/P4sca1/nuxt-headlessui\n\nimport { defineNuxtModule, resolvePath } from '@nuxt/kit'\n\nimport { join } from 'pathe'\n\n\n\nconst headlessComponents: ComponentGroup[] = [\n\n  {\n\n    relativePath: 'combobox/combobox.js',\n\n    chunkName: 'headlessui/combobox',\n\n    exports: [\n\n      'Combobox',\n\n      'ComboboxLabel',\n\n      'ComboboxButton',\n\n      'ComboboxInput',\n\n      'ComboboxOptions',\n\n      'ComboboxOption'\n\n    ]\n\n  },\n\n]\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'nuxt-headlessui',\n\n    configKey: 'headlessui',\n\n  },\n\n  defaults: {\n\n    prefix: 'Headless'\n\n  },\n\n  async setup (options) {\n\n    const entrypoint = await resolvePath('@headlessui/vue')\n\n    const root = join(entrypoint, '../components')\n\n\n\n    for (const group of headlessComponents) {\n\n      for (const e of group.exports) {\n\n        addComponent(\n\n          {\n\n            name: e,\n\n            export: e,\n\n            filePath: join(root, group.relativePath),\n\n            chunkName: group.chunkName,\n\n            mode: 'all'\n\n          }\n\n        )\n\n      }\n\n    }\n\n  }\n\n})\n\nresolveAlias\n\nResolves path aliases respecting Nuxt alias options.\n\nType\nfunction resolveAlias (path: string, alias?: Record<string, string>): string\n\nParameters\npath\n\nType: string\n\nRequired: true\n\nPath to resolve.\n\nalias\n\nType: Record<string, string>\n\nDefault: {}\n\nAlias map. If not provided, it will be read from nuxt.options.alias.\n\nfindPath\n\nTry to resolve first existing file in given paths.\n\nType\nasync function findPath (paths: string | string[], options?: ResolvePathOptions, pathType: 'file' | 'dir'): Promise<string | null>\n\n\n\ninterface ResolvePathOptions {\n\n  cwd?: string\n\n  alias?: Record<string, string>\n\n  extensions?: string[]\n\n}\n\nParameters\npaths\n\nType: string | string[]\n\nRequired: true\n\nA path or an array of paths to resolve.\n\noptions\n\nType: ResolvePathOptions\n\nDefault: {}\n\nOptions to pass to the resolver. This object can have the following properties:\n\ncwd (optional)\nType: string\nDefault: process.cwd()\nCurrent working directory.\nalias (optional)\nType: Record<string, string>\nDefault: {}\nAlias map.\nextensions (optional)\nType: string[]\nDefault: ['.js', '.mjs', '.ts', '.jsx', '.tsx', '.json']\nExtensions to try.\npathType\n\nType: 'file' | 'dir'\n\nDefault: 'file'\n\nType of path to resolve. If set to 'file', the function will try to resolve a file. If set to 'dir', the function will try to resolve a directory.\n\ncreateResolver\n\nCreates resolver relative to base path.\n\nType\nfunction createResolver (basePath: string | URL): Resolver\n\n\n\ninterface Resolver {\n\n  resolve (...path: string[]): string\n\n  resolvePath (path: string, options?: ResolvePathOptions): Promise<string>\n\n}\n\n\n\ninterface ResolvePathOptions {\n\n  cwd?: string\n\n  alias?: Record<string, string>\n\n  extensions?: string[]\n\n}\n\nParameters\nbasePath\n\nType: string\n\nRequired: true\n\nBase path to resolve from.\n\nExamples\n// https://github.com/vuejs/pinia/blob/v2/packages/nuxt\n\nimport {\n\n  defineNuxtModule,\n\n  isNuxt2,\n\n  createResolver,\n\n} from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options, nuxt) {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    nuxt.hook('modules:done', () => {\n\n      if (isNuxt2()) {\n\n        addPlugin(resolver.resolve('./runtime/plugin.vue2'))\n\n      } else {\n\n        addPlugin(resolver.resolve('./runtime/plugin.vue3'))\n\n      }\n\n    })\n\n  }\n\n})\n\n\nNitro\n\nNuxt Kit provides a set of utilities to help you work with Nitro. These functions allow you to add server handlers, plugins, and prerender routes.\n\nLogging\n\nNuxt Kit provides a set of utilities to help you work with logging. These functions allow you to log messages with extra features."
  },
  {
    "title": "Nitro · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/nitro",
    "html": "Nuxt Kit\nNitro\nSource\n\nNuxt Kit provides a set of utilities to help you work with Nitro. These functions allow you to add server handlers, plugins, and prerender routes.\n\nNitro is an open source TypeScript framework to build ultra-fast web servers. Nuxt 3 (and, optionally, Nuxt Bridge) uses Nitro as its server engine. You can use useNitro to access the Nitro instance, addServerHandler to add a server handler, addDevServerHandler to add a server handler to be used only in development mode, addServerPlugin to add a plugin to extend Nitro's runtime behavior, and addPrerenderRoutes to add routes to be prerendered by Nitro.\n\naddServerHandler\n\nAdds a nitro server handler. Use it if you want to create server middleware or custom route.\n\nType\nfunction addServerHandler (handler: NitroEventHandler): void\n\n\n\nexport interface NitroEventHandler {\n\n  handler: string;\n\n  route?: string;\n\n  middleware?: boolean;\n\n  lazy?: boolean;\n\n  method?: string;\n\n}\n\nParameters\nhandler\n\nType: NitroEventHandler\n\nRequired: true\n\nA handler object with the following properties:\n\nhandler (required)\nType: string\nPath to event handler.\nroute (optional)\nType: string\nPath prefix or route. If an empty string used, will be used as a middleware.\nmiddleware (optional)\nType: boolean\nSpecifies this is a middleware handler. Middleware are called on every route and should normally return nothing to pass to the next handlers.\nlazy (optional)\nType: boolean\nUse lazy loading to import handler.\nmethod (optional)\nType: string\nRouter method matcher. If handler name contains method name, it will be used as a default value.\nExamples\nmodule.ts\nruntime/robots.get.ts\n// https://github.com/nuxt-modules/robots\n\nimport { createResolver, defineNuxtModule, addServerHandler } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options) {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    addServerHandler({\n\n      route: '/robots.txt'\n\n      handler: resolver.resolve('./runtime/robots.get.ts')\n\n    })\n\n  }\n\n})\n\naddDevServerHandler\n\nAdds a nitro server handler to be used only in development mode. This handler will be excluded from production build.\n\nType\nfunction addDevServerHandler (handler: NitroEventHandler): void\n\n\n\nexport interface NitroEventHandler {\n\n  handler: string;\n\n  route?: string;\n\n  middleware?: boolean;\n\n  lazy?: boolean;\n\n  method?: string;\n\n}\n\nParameters\nhandler\n\nType: NitroEventHandler\n\nRequired: true\n\nA handler object with the following properties:\n\nhandler (required)\nType: string\nPath to event handler.\nroute (optional)\nType: string\nPath prefix or route. If an empty string used, will be used as a middleware.\nmiddleware (optional)\nType: boolean\nSpecifies this is a middleware handler. Middleware are called on every route and should normally return nothing to pass to the next handlers.\nlazy (optional)\nType: boolean\nUse lazy loading to import handler.\nmethod (optional)\nType: string\nRouter method matcher.\nExamples\nmodule.ts\nruntime/timer.get.ts\nimport { createResolver, defineNuxtModule, addDevServerHandler } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    addDevServerHandler({\n\n      handler: resolver.resolve('./runtime/uptime.get'),\n\n      route: '/_handler'\n\n    })\n\n  }\n\n})\n\n// https://github.com/nuxt-modules/tailwindcss\n\nimport { joinURL } from 'ufo'\n\nimport { defineNuxtModule, addDevServerHandler } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  async setup(options) {\n\n    const route = joinURL(nuxt.options.app?.baseURL, '/_tailwind')\n\n\n\n    // @ts-ignore\n\n    const createServer = await import('tailwind-config-viewer/server/index.js').then(r => r.default || r) as any\n\n    const viewerDevMiddleware = createServer({ tailwindConfigProvider: () => options, routerPrefix: route }).asMiddleware()\n\n\n\n    addDevServerHandler({ route, handler: viewerDevMiddleware })\n\n  }\n\n})\n\nuseNitro\n\nReturns the Nitro instance.\n\nYou can call useNitro() only after ready hook.\nChanges to the Nitro instance configuration are not applied.\nType\nfunction useNitro (): Nitro\n\n\n\nexport interface Nitro {\n\n  options: NitroOptions;\n\n  scannedHandlers: NitroEventHandler[];\n\n  vfs: Record<string, string>;\n\n  hooks: Hookable<NitroHooks>;\n\n  unimport?: Unimport;\n\n  logger: ConsolaInstance;\n\n  storage: Storage;\n\n  close: () => Promise<void>;\n\n  updateConfig: (config: NitroDynamicConfig) => void | Promise<void>;\n\n}\n\nExamples\n// https://github.com/nuxt/nuxt/blob/4e05650cde31ca73be4d14b1f0d23c7854008749/packages/nuxt/src/core/nuxt.ts#L404\n\nimport { defineNuxtModule, useNitro, addPlugin, createResolver } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options, nuxt) {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    nuxt.hook('ready', () => {\n\n      const nitro = useNitro()\n\n      if (nitro.options.static && nuxt.options.experimental.payloadExtraction === undefined) {\n\n        console.warn('Using experimental payload extraction for full-static output. You can opt-out by setting `experimental.payloadExtraction` to `false`.')\n\n        nuxt.options.experimental.payloadExtraction = true\n\n      }\n\n      nitro.options.replace['process.env.NUXT_PAYLOAD_EXTRACTION'] = String(!!nuxt.options.experimental.payloadExtraction)\n\n      nitro.options._config.replace!['process.env.NUXT_PAYLOAD_EXTRACTION'] = String(!!nuxt.options.experimental.payloadExtraction)\n\n\n\n      if (!nuxt.options.dev && nuxt.options.experimental.payloadExtraction) {\n\n        addPlugin(resolver.resolve(nuxt.options.appDir, 'plugins/payload.client'))\n\n      }\n\n    })\n\n  }\n\n})\n\naddServerPlugin\n\nAdd plugin to extend Nitro's runtime behavior.\n\nYou can read more about Nitro plugins in the Nitro documentation.\nType\nfunction addServerPlugin (plugin: string): void\n\nParameters\nplugin\n\nType: string\n\nRequired: true\n\nPath to the plugin. The plugin must export a function that accepts Nitro instance as an argument.\n\nExamples\nmodule.ts\nruntime/plugin.ts\nimport { createResolver, defineNuxtModule, addServerPlugin } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    const resolver = createResolver(import.meta.url)\n\n    addServerPlugin(resolver.resolve('./runtime/plugin.ts'))\n\n  }\n\n})\n\naddPrerenderRoutes\n\nAdd routes to be prerendered to Nitro.\n\nType\nfunction function addPrerenderRoutes (routes: string | string[]): void\n\nParameters\nroutes\n\nType: string | string[]\n\nRequired: true\n\nA route or an array of routes to prerender.\n\nExamples\nimport { defineNuxtModule, addPrerenderRoutes } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'nuxt-sitemap',\n\n    configKey: 'sitemap',\n\n  },\n\n  defaults: {\n\n    sitemapUrl: '/sitemap.xml',\n\n    prerender: true,\n\n  },\n\n  setup(options) {\n\n    if (options.prerender) {\n\n      addPrerenderRoutes(options.sitemapUrl)\n\n    }\n\n  }\n\n})\n\naddServerImportsDir\n\nAdd a directory to be scanned for auto-imports by Nitro.\n\nType\nfunction function addServerImportsDir (dirs: string | string[], opts: { prepend?: boolean }): void\n\nParameters\ndirs\n\nType: string | string[]\n\nRequired: true\n\nA directory or an array of directories to register to be scanned by Nitro\n\nExamples\nimport { defineNuxtModule, addServerImportsDir } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'my-module',\n\n    configKey: 'myModule',\n\n  },\n\n  setup(options) {\n\n    const resolver = createResolver(import.meta.url)\n\n    addServerImportsDir(resolver.resolve('./runtime/server/utils'))\n\n  }\n\n})\n\n\nTemplates\n\nNuxt Kit provides a set of utilities to help you work with templates. These functions allow you to generate extra files during development and build time.\n\nResolving\n\nNuxt Kit provides a set of utilities to help you resolve paths. These functions allow you to resolve paths relative to the current module, with unknown name or extension."
  },
  {
    "title": "Layout · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/layout",
    "html": "Nuxt Kit\nLayout\nSource\n\nNuxt Kit provides a set of utilities to help you work with layouts.\n\nLayouts is used to be a wrapper around your pages. It can be used to wrap your pages with common components, for example, a header and a footer. Layouts can be registered using addLayout utility.\n\naddLayout\n\nRegister template as layout and add it to the layouts.\n\nIn Nuxt 2 error layout can also be registered using this utility. In Nuxt 3 error layout replaced with error.vue page in project root.\nType\nfunction addLayout (layout: NuxtTemplate | string, name: string): void\n\n\n\ninterface NuxtTemplate {\n\n  src?: string\n\n  filename?: string\n\n  dst?: string\n\n  options?: Record<string, any>\n\n  getContents?: (data: Record<string, any>) => string | Promise<string>\n\n  write?: boolean\n\n}\n\nParameters\nlayout\n\nType: NuxtTemplate | string\n\nRequired: true\n\nA template object or a string with the path to the template. If a string is provided, it will be converted to a template object with src set to the string value. If a template object is provided, it must have the following properties:\n\nsrc (optional)\nType: string\nPath to the template. If src is not provided, getContents must be provided instead.\nfilename (optional)\nType: string\nFilename of the template. If filename is not provided, it will be generated from the src path. In this case, the src option is required.\ndst (optional)\nType: string\nPath to the destination file. If dst is not provided, it will be generated from the filename path and nuxt buildDir option.\noptions (optional)\nType: Options\nOptions to pass to the template.\ngetContents (optional)\nType: (data: Options) => string | Promise<string>\nA function that will be called with the options object. It should return a string or a promise that resolves to a string. If src is provided, this function will be ignored.\nwrite (optional)\nType: boolean\nIf set to true, the template will be written to the destination file. Otherwise, the template will be used only in virtual filesystem.\n\nPages\n\nNuxt Kit provides a set of utilities to help you create and use pages. You can use these utilities to manipulate the pages configuration or to define route rules.\n\nPlugins\n\nNuxt Kit provides a set of utilities to help you create and use plugins. You can add plugins or plugin templates to your module using these functions."
  },
  {
    "title": "Logging · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/logging",
    "html": "Nuxt Kit\nLogging\nSource\n\nNuxt Kit provides a set of utilities to help you work with logging. These functions allow you to log messages with extra features.\n\nNuxt provides a logger instance that you can use to log messages with extra features. useLogger allows you to get a logger instance.\n\nuseLogger\n\nReturns a logger instance. It uses consola under the hood.\n\nType\nfunction useLogger (tag?: string, options?: Partial<ConsolaOptions>): ConsolaInstance\n\nParameters\ntag\n\nType: string\n\n*Optional: true\n\nA tag to prefix all log messages with.\n\noptions\n\nType: Partial<ConsolaOptions>\n\n*Optional: true\n\nConsola configuration options\n\nExamples\nimport { defineNuxtModule, useLogger } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options, nuxt) {\n\n    const logger = useLogger('my-module')\n\n\n\n    logger.info('Hello from my module!')\n\n  }\n\n})\n\nimport { defineNuxtModule, useLogger } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options, nuxt) {\n\n    const logger = useLogger('my-module', { level: options.quiet ? 0 : 3 })\n\n\n\n    logger.info('Hello from my module!')\n\n  }\n\n})\n\n\nResolving\n\nNuxt Kit provides a set of utilities to help you resolve paths. These functions allow you to resolve paths relative to the current module, with unknown name or extension.\n\nBuilder\n\nNuxt Kit provides a set of utilities to help you work with the builder. These functions allow you to extend the webpack and vite configurations."
  },
  {
    "title": "Examples · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/examples",
    "html": "Nuxt Kit\nExamples\n\nExamples of Nuxt Kit utilities in use.\n\nAccessing Nuxt Vite Config\n\nIf you are building an integration that needs access to the runtime Vite or webpack config that Nuxt uses, it is possible to extract this using Kit utilities.\n\nSome examples of projects doing this already:\n\nhistoire\nnuxt-vitest\n@storybook-vue/nuxt\n\nHere is a brief example of how you might access the Vite config from a project; you could implement a similar approach to get the webpack configuration.\n\nimport { loadNuxt, buildNuxt } from '@nuxt/kit'\n\n\n\n// https://github.com/nuxt/nuxt/issues/14534\n\nasync function getViteConfig() {\n\n  const nuxt = await loadNuxt({ cwd: process.cwd(), dev: false, overrides: { ssr: false } })\n\n  return new Promise((resolve, reject) => {\n\n    nuxt.hook('vite:extendConfig', (config, { isClient }) => {\n\n      if (isClient) {\n\n        resolve(config)\n\n        throw new Error('_stop_')\n\n      }\n\n    })\n\n    buildNuxt(nuxt).catch((err) => {\n\n      if (!err.toString().includes('_stop_')) {\n\n        reject(err)\n\n      }\n\n    })\n\n  }).finally(() => nuxt.close())\n\n}\n\n\n\nconst viteConfig = await getViteConfig()\n\nconsole.log(viteConfig)\n\n\nBuilder\n\nNuxt Kit provides a set of utilities to help you work with the builder. These functions allow you to extend the webpack and vite configurations.\n\nLifecycle Hooks\n\nNuxt provides a powerful hooking system to expand almost every aspect using hooks."
  },
  {
    "title": "Lifecycle Hooks · Nuxt API",
    "url": "https://nuxt.com/docs/api/advanced/hooks",
    "html": "Advanced\nLifecycle Hooks\n\nNuxt provides a powerful hooking system to expand almost every aspect using hooks.\n\n Read more in Docs > Guide > Going Further > Hooks.\nApp Hooks (runtime)\n\nCheck the app source code for all available hooks.\n\nHook\tArguments\tEnvironment\tDescription\napp:created\tvueApp\tServer & Client\tCalled when initial vueApp instance is created.\napp:error\terr\tServer & Client\tCalled when a fatal error occurs.\napp:error:cleared\t{ redirect? }\tServer & Client\tCalled when a fatal error occurs.\napp:data:refresh\tkeys?\tServer & Client\t(internal)\nvue:setup\t-\tServer & Client\t(internal)\nvue:error\terr, target, info\tServer & Client\tCalled when a vue error propagates to the root component. Learn More.\napp:rendered\trenderContext\tServer\tCalled when SSR rendering is done.\napp:redirected\t-\tServer\tCalled before SSR redirection.\napp:beforeMount\tvueApp\tClient\tCalled before mounting the app, called only on client side.\napp:mounted\tvueApp\tClient\tCalled when Vue app is initialized and mounted in browser.\napp:suspense:resolve\tappComponent\tClient\tOn Suspense resolved event.\nlink:prefetch\tto\tClient\tCalled when a <NuxtLink> is observed to be prefetched.\npage:start\tpageComponent?\tClient\tCalled on Suspense pending event.\npage:finish\tpageComponent?\tClient\tCalled on Suspense resolved event.\npage:transition:finish\tpageComponent?\tClient\tAfter page transition onAfterLeave event.\nNuxt Hooks (build time)\n\nCheck the schema source code for all available hooks.\n\nHook\tArguments\tDescription\nkit:compatibility\tcompatibility, issues\tAllows extending compatibility checks.\nready\tnuxt\tCalled after Nuxt initialization, when the Nuxt instance is ready to work.\nclose\tnuxt\tCalled when Nuxt instance is gracefully closing.\nrestart\t{ hard?: boolean }\tTo be called to restart the current Nuxt instance.\nmodules:before\t-\tCalled during Nuxt initialization, before installing user modules.\nmodules:done\t-\tCalled during Nuxt initialization, after installing user modules.\napp:resolve\tapp\tCalled after resolving the app instance.\napp:templates\tapp\tCalled during NuxtApp generation, to allow customizing, modifying or adding new files to the build directory (either virtually or to written to .nuxt).\napp:templatesGenerated\tapp\tCalled after templates are compiled into the virtual file system (vfs).\nbuild:before\t-\tCalled before Nuxt bundle builder.\nbuild:done\t-\tCalled after Nuxt bundle builder is complete.\nbuild:manifest\tmanifest\tCalled during the manifest build by Vite and webpack. This allows customizing the manifest that Nitro will use to render <script> and <link> tags in the final HTML.\nbuilder:generateApp\toptions\tCalled before generating the app.\nbuilder:watch\tevent, path\tCalled at build time in development when the watcher spots a change to a file or directory in the project.\npages:extend\tpages\tCalled after pages routes are resolved.\nserver:devHandler\thandler\tCalled when the dev middleware is being registered on the Nitro dev server.\nimports:sources\tpresets\tCalled at setup allowing modules to extend sources.\nimports:extend\timports\tCalled at setup allowing modules to extend imports.\nimports:context\tcontext\tCalled when the unimport context is created.\nimports:dirs\tdirs\tAllows extending import directories.\ncomponents:dirs\tdirs\tCalled within app:resolve allowing to extend the directories that are scanned for auto-importable components.\ncomponents:extend\tcomponents\tAllows extending new components.\nnitro:config\tnitroConfig\tCalled before initializing Nitro, allowing customization of Nitro's configuration.\nnitro:init\tnitro\tCalled after Nitro is initialized, which allows registering Nitro hooks and interacting directly with Nitro.\nnitro:build:before\tnitro\tCalled before building the Nitro instance.\nnitro:build:public-assets\tnitro\tCalled after copying public assets. Allows modifying public assets before Nitro server is built.\nprerender:routes\tctx\tAllows extending the routes to be pre-rendered.\nbuild:error\terror\tCalled when an error occurs at build time.\nprepare:types\toptions\tCalled before Nuxi writes .nuxt/tsconfig.json and .nuxt/nuxt.d.ts, allowing addition of custom references and declarations in nuxt.d.ts, or directly modifying the options in tsconfig.json\nlisten\tlistenerServer, listener\tCalled when the dev server is loading.\nschema:extend\tschemas\tAllows extending default schemas.\nschema:resolved\tschema\tAllows extending resolved schema.\nschema:beforeWrite\tschema\tCalled before writing the given schema.\nschema:written\t-\tCalled after the schema is written.\nvite:extend\tviteBuildContext\tAllows to extend Vite default context.\nvite:extendConfig\tviteInlineConfig, env\tAllows to extend Vite default config.\nvite:configResolved\tviteInlineConfig, env\tAllows to read the resolved Vite config.\nvite:serverCreated\tviteServer, env\tCalled when the Vite server is created.\nvite:compiled\t-\tCalled after Vite server is compiled.\nwebpack:config\twebpackConfigs\tCalled before configuring the webpack compiler.\nwebpack:configResolved\twebpackConfigs\tAllows to read the resolved webpack config.\nwebpack:compile\toptions\tCalled right before compilation.\nwebpack:compiled\toptions\tCalled after resources are loaded.\nwebpack:change\tshortPath\tCalled on change on WebpackBar.\nwebpack:error\t-\tCalled on done if has errors on WebpackBar.\nwebpack:done\t-\tCalled on allDone on WebpackBar.\nwebpack:progress\tstatesArray\tCalled on progress on WebpackBar.\nNitro App Hooks (runtime, server-side)\n\nSee Nitro for all available hooks.\n\nHook\tArguments\tDescription\tTypes\nrender:response\tresponse, { event }\tCalled before sending the response.\tresponse, event\nrender:html\thtml, { event }\tCalled before constructing the HTML.\thtml, event\nrender:island\tislandResponse, { event, islandContext }\tCalled before constructing the island HTML.\tislandResponse, event, islandContext\nclose\t-\tCalled when Nitro is closed.\t-\nerror\terror, { event? }\tCalled when an error occurs.\terror, event\nrequest\tevent\tCalled when a request is received.\tevent\nbeforeResponse\tevent, { body }\tCalled before sending the response.\tevent, unknown\nafterResponse\tevent, { body }\tCalled after sending the response.\tevent, unknown\n\nExamples\n\nExamples of Nuxt Kit utilities in use.\n\nImport meta\n\nUnderstand where your code is running using `import.meta`."
  },
  {
    "title": "Context · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/context",
    "html": "Nuxt Kit\nContext\nSource\n\nNuxt Kit provides a set of utilities to help you work with context.\n\nNuxt modules allow you to enhance Nuxt's capabilities. They offer a structured way to keep your code organized and modular. If you're looking to break down your module into smaller components, Nuxt offers the useNuxt and tryUseNuxt functions. These functions enable you to conveniently access the Nuxt instance from the context without having to pass it as argument.\n\nWhen you're working with the setup function in Nuxt modules, Nuxt is already provided as the second argument. This means you can directly utilize it without needing to call useNuxt(). You can look at Nuxt Site Config as an example of usage.\nuseNuxt\n\nGet the Nuxt instance from the context. It will throw an error if Nuxt is not available.\n\nType\nfunction useNuxt(): Nuxt\n\n\n\ninterface Nuxt {\n\n  options: NuxtOptions\n\n  hooks: Hookable<NuxtHooks>\n\n  hook: Nuxt['hooks']['hook']\n\n  callHook: Nuxt['hooks']['callHook']\n\n  addHooks: Nuxt['hooks']['addHooks']\n\n  ready: () => Promise<void>\n\n  close: () => Promise<void>\n\n  server?: any\n\n  vfs: Record<string, string>\n\n  apps: Record<string, NuxtApp>\n\n}\n\nExamples\nsetupTranspilation.ts\nmodule.ts\n// https://github.com/Lexpeartha/nuxt-xstate/blob/main/src/parts/transpile.ts\n\nimport { useNuxt } from '@nuxt/kit'\n\n\n\nexport const setupTranspilation = () => {\n\n  const nuxt = useNuxt()\n\n\n\n  nuxt.options.build.transpile = nuxt.options.build.transpile || []\n\n\n\n  if (nuxt.options.builder === '@nuxt/webpack-builder') {\n\n    nuxt.options.build.transpile.push(\n\n      'xstate',\n\n    )\n\n  }\n\n}\n\ntryUseNuxt\n\nGet the Nuxt instance from the context. It will return null if Nuxt is not available.\n\nType\nfunction tryUseNuxt(): Nuxt | null\n\n\n\ninterface Nuxt {\n\n  options: NuxtOptions\n\n  hooks: Hookable<NuxtHooks>\n\n  hook: Nuxt['hooks']['hook']\n\n  callHook: Nuxt['hooks']['callHook']\n\n  addHooks: Nuxt['hooks']['addHooks']\n\n  ready: () => Promise<void>\n\n  close: () => Promise<void>\n\n  server?: any\n\n  vfs: Record<string, string>\n\n  apps: Record<string, NuxtApp>\n\n}\n\nExamples\nrequireSiteConfig.ts\nmodule.ts\n// https://github.com/harlan-zw/nuxt-site-config/blob/main/test/assertions.test.ts\n\nimport { tryUseNuxt } from '@nuxt/kit'\n\n\n\ninterface SiteConfig {\n\n  title: string\n\n}\n\n\n\nexport const requireSiteConfig = (): SiteConfig => {\n\n  const nuxt = tryUseNuxt()\n\n  if (!nuxt) {\n\n    return { title: null }\n\n  }\n\n  return nuxt.options.siteConfig\n\n}\n\n\nComponents\n\nNuxt Kit provides a set of utilities to help you work with components. You can register components globally or locally, and also add directories to be scanned for components.\n\nPages\n\nNuxt Kit provides a set of utilities to help you create and use pages. You can use these utilities to manipulate the pages configuration or to define route rules."
  },
  {
    "title": "Auto-imports · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/autoimports",
    "html": "Nuxt Kit\nAuto-imports\nSource\n\nNuxt Kit provides a set of utilities to help you work with auto-imports. These functions allow you to register your own utils, composables and Vue APIs.\n\nAuto-imports\n\nNuxt auto-imports helper functions, composables and Vue APIs to use across your application without explicitly importing them. Based on the directory structure, every Nuxt application can also use auto-imports for its own composables and plugins. With Nuxt Kit you can also add your own auto-imports. addImports and addImportsDir allow you to add imports to the Nuxt application. addImportsSources allows you to add listed imports from 3rd party packages to the Nuxt application.\n\nThese functions are designed for registering your own utils, composables and Vue APIs. For pages, components and plugins, please refer to the specific sections: Pages, Components, Plugins.\n\nNuxt auto-imports helper functions, composables and Vue APIs to use across your application without explicitly importing them. Based on the directory structure, every Nuxt application can also use auto-imports for its own composables and plugins. Composables or plugins can use these functions.\n\naddImports\n\nAdd imports to the Nuxt application. It makes your imports available in the Nuxt application without the need to import them manually.\n\nType\nfunction addImports (imports: Import | Import[]): void\n\n\n\ninterface Import {\n\n  from: string\n\n  priority?: number\n\n  disabled?: boolean\n\n  meta?: {\n\n    description?: string\n\n    docsUrl?: string\n\n    [key: string]: any\n\n  }\n\n  type?: boolean\n\n  typeFrom?: string\n\n  name: string\n\n  as?: string\n\n}\n\nParameters\nimports\n\nType: Import | Import[]\n\nRequired: true\n\nAn object or an array of objects with the following properties:\n\nfrom (required)\nType: string\nModule specifier to import from.\npriority (optional)\nType: number\nDefault: 1\nPriority of the import, if multiple imports have the same name, the one with the highest priority will be used.\ndisabled (optional)\nType: boolean\nIf this import is disabled.\nmeta (optional)\nType: object\nMetadata of the import.\nmeta.description (optional)\nType: string\nShort description of the import.\nmeta.docsUrl (optional)\nType: string\nURL to the documentation.\nmeta[key] (optional)\nType: any\nAdditional metadata.\ntype (optional)\nType: boolean\nIf this import is a pure type import.\ntypeFrom (optional)\nType: string\nUsing this as the from when generating type declarations.\nname (required)\nType: string\nImport name to be detected.\nas (optional)\nType: string\nImport as this name.\nExamples\n// https://github.com/pi0/storyblok-nuxt\n\nimport { defineNuxtModule, addImports, createResolver } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options, nuxt) {\n\n    const names = [\n\n      \"useStoryblok\",\n\n      \"useStoryblokApi\",\n\n      \"useStoryblokBridge\",\n\n      \"renderRichText\",\n\n      \"RichTextSchema\"\n\n    ];\n\n\n\n    names.forEach((name) =>\n\n      addImports({ name, as: name, from: \"@storyblok/vue\" })\n\n    );\n\n  }\n\n})\n\naddImportsDir\n\nAdd imports from a directory to the Nuxt application. It will automatically import all files from the directory and make them available in the Nuxt application without the need to import them manually.\n\nType\nfunction addImportsDir (dirs: string | string[], options?: { prepend?: boolean }): void\n\nParameters\ndirs\n\nType: string | string[]\n\nRequired: true\n\nA string or an array of strings with the path to the directory to import from.\n\noptions\n\nType: { prepend?: boolean }\n\nDefault: {}\n\nOptions to pass to the import. If prepend is set to true, the imports will be prepended to the list of imports.\n\nExamples\n// https://github.com/vueuse/motion/tree/main/src/nuxt\n\nimport { defineNuxtModule, addImportsDir, createResolver } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: '@vueuse/motion',\n\n    configKey: 'motion',\n\n  },\n\n  setup(options, nuxt) {\n\n    const resolver = createResolver(import.meta.url)\n\n    addImportsDir(resolver.resolve('./runtime/composables'))\n\n  },\n\n})\n\naddImportsSources\n\nAdd listed imports to the Nuxt application.\n\nType\nfunction addImportsSources (importSources: ImportSource | ImportSource[]): void\n\n\n\ninterface Import {\n\n  from: string\n\n  priority?: number\n\n  disabled?: boolean\n\n  meta?: {\n\n    description?: string\n\n    docsUrl?: string\n\n    [key: string]: any\n\n  }\n\n  type?: boolean\n\n  typeFrom?: string\n\n  name: string\n\n  as?: string\n\n}\n\n\n\ninterface ImportSource extends Import {\n\n  imports: (PresetImport | ImportSource)[]\n\n}\n\n\n\ntype PresetImport = Omit<Import, 'from'> | string | [name: string, as?: string, from?: string]\n\nParameters\nimportSources\n\nType: ImportSource | ImportSource[]\n\nRequired: true\n\nAn object or an array of objects with the following properties:\n\nimports (required)\nType: PresetImport | ImportSource[]\nRequired: true\nAn object or an array of objects, which can be import names, import objects or import sources.\nfrom (required)\nType: string\nModule specifier to import from.\npriority (optional)\nType: number\nDefault: 1\nPriority of the import, if multiple imports have the same name, the one with the highest priority will be used.\ndisabled (optional)\nType: boolean\nIf this import is disabled.\nmeta (optional)\nType: object\nMetadata of the import.\nmeta.description (optional)\nType: string\nShort description of the import.\nmeta.docsUrl (optional)\nType: string\nURL to the documentation.\nmeta[key] (optional)\nType: any\nAdditional metadata.\ntype (optional)\nType: boolean\nIf this import is a pure type import.\ntypeFrom (optional)\nType: string\nUsing this as the from when generating type declarations.\nname (required)\nType: string\nImport name to be detected.\nas (optional)\nType: string\nImport as this name.\nExamples\n// https://github.com/elk-zone/elk\n\nimport { defineNuxtModule, addImportsSources } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    // add imports from h3 to make them autoimported\n\n    addImportsSources({\n\n      from: 'h3',\n\n      imports: ['defineEventHandler', 'getQuery', 'getRouterParams', 'readBody', 'sendRedirect'] as Array<keyof typeof import('h3')>,\n\n    })\n\n  }\n\n})\n\n\nCompatibility\n\nNuxt Kit provides a set of utilities to help you check the compatibility of your modules with different Nuxt versions.\n\nComponents\n\nNuxt Kit provides a set of utilities to help you work with components. You can register components globally or locally, and also add directories to be scanned for components."
  },
  {
    "title": "Programmatic Usage · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/programmatic",
    "html": "Nuxt Kit\nProgrammatic Usage\nSource\n\nNuxt Kit provides a set of utilities to help you work with Nuxt programmatically. These functions allow you to load Nuxt, build Nuxt, and load Nuxt configuration.\n\nProgrammatic usage can be helpful when you want to use Nuxt programmatically, for example, when building a CLI tool or test utils.\n\nloadNuxt\n\nLoad Nuxt programmatically. It will load the Nuxt configuration, instantiate and return the promise with Nuxt instance.\n\nType\nasync function loadNuxt (loadOptions?: LoadNuxtOptions): Promise<Nuxt>\n\n\n\ninterface LoadNuxtOptions extends LoadNuxtConfigOptions {\n\n  dev?: boolean\n\n  ready?: boolean\n\n  rootDir?: string\n\n  config?: LoadNuxtConfigOptions['overrides']\n\n}\n\nParameters\nloadOptions\n\nType: LoadNuxtOptions\n\nDefault: {}\n\nLoading conditions for Nuxt. loadNuxt uses c12 under the hood, so it accepts the same options as c12.loadConfig with some additional options:\n\ndev (optional)\nType: boolean\nDefault: false\nIf set to true, Nuxt will be loaded in development mode.\nready (optional)\nType: boolean\nDefault: true\nIf set to true, Nuxt will be ready to use after the loadNuxt call. If set to false, you will need to call nuxt.ready() to make sure Nuxt is ready to use.\nrootDir (optional)\nType: string\nDefault: null\nDeprecated: Use cwd option instead.\nThe root directory of the Nuxt project.\nconfig (optional)\nType: LoadNuxtConfigOptions['overrides']\nDefault: {}\nDeprecated: Use overrides option instead.\nOverrides for the Nuxt configuration.\nbuildNuxt\n\nBuild Nuxt programmatically. It will invoke the builder (currently @nuxt/vite-builder or @nuxt/webpack-builder) to bundle the application.\n\nType\nasync function buildNuxt (nuxt: Nuxt): Promise<any>\n\nParameters\nnuxt\n\nType: Nuxt\n\nRequired: true\n\nNuxt instance to build. It can be retrieved from the context via useNuxt() call.\n\nloadNuxtConfig\n\nLoad Nuxt configuration. It will return the promise with the configuration object.\n\nType\nasync function loadNuxtConfig (options: LoadNuxtConfigOptions): Promise<NuxtOptions>\n\nParameters\noptions\n\nType: LoadNuxtConfigOptions\n\nRequired: true\n\nOptions to pass in c12 loadConfig call.\n\nwriteTypes\n\nGenerates tsconfig.json and writes it to the project buildDir.\n\nType\nfunction writeTypes (nuxt?: Nuxt): void\n\n\n\ninterface Nuxt {\n\n  options: NuxtOptions\n\n  hooks: Hookable<NuxtHooks>\n\n  hook: Nuxt['hooks']['hook']\n\n  callHook: Nuxt['hooks']['callHook']\n\n  addHooks: Nuxt['hooks']['addHooks']\n\n  ready: () => Promise<void>\n\n  close: () => Promise<void>\n\n  server?: any\n\n  vfs: Record<string, string>\n\n  apps: Record<string, NuxtApp>\n\n}\n\nParameters\nnuxt\n\nType: Nuxt\n\nRequired: true\n\nNuxt instance to build. It can be retrieved from the context via useNuxt() call.\n\nModules\n\nNuxt Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules.\n\nCompatibility\n\nNuxt Kit provides a set of utilities to help you check the compatibility of your modules with different Nuxt versions."
  },
  {
    "title": "Pages · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/pages",
    "html": "Nuxt Kit\nPages\nSource\n\nNuxt Kit provides a set of utilities to help you create and use pages. You can use these utilities to manipulate the pages configuration or to define route rules.\n\nextendPages\n\nIn Nuxt 3, routes are automatically generated based on the structure of the files in the pages directory. However, there may be scenarios where you'd want to customize these routes. For instance, you might need to add a route for a dynamic page not generated by Nuxt, remove an existing route, or modify the configuration of a route. For such customizations, Nuxt 3 offers the extendPages feature, which allows you to extend and alter the pages configuration.\n\nType\nfunction extendPages (callback: (pages: NuxtPage[]) => void): void\n\n\n\ntype NuxtPage = {\n\n  name?: string\n\n  path: string\n\n  file?: string\n\n  meta?: Record<string, any>\n\n  alias?: string[] | string\n\n  redirect?: RouteLocationRaw\n\n  children?: NuxtPage[]\n\n}\n\nParameters\ncallback\n\nType: (pages: NuxtPage[]) => void\n\nRequired: true\n\nA function that will be called with the pages configuration. You can alter this array by adding, deleting, or modifying its elements. Note: You should modify the provided pages array directly, as changes made to a copied array will not be reflected in the configuration.\n\nExamples\n// https://github.com/nuxt-modules/prismic/blob/master/src/module.ts\n\nimport { createResolver, defineNuxtModule, extendPages } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options) {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    extendPages((pages) => {\n\n      pages.unshift({\n\n        name: 'prismic-preview',\n\n        path: '/preview',\n\n        file: resolver.resolve('runtime/preview.vue')\n\n       })\n\n    })\n\n  }\n\n})\n\nextendRouteRules\n\nNuxt is powered by the Nitro server engine. With Nitro, you can incorporate high-level logic directly into your configuration, which is useful for actions like redirects, proxying, caching, and appending headers to routes. This configuration works by associating route patterns with specific route settings.\n\nYou can read more about Nitro route rules in the Nitro documentation.\nType\nfunction extendRouteRules (route: string, rule: NitroRouteConfig, options: ExtendRouteRulesOptions): void\n\n\n\ninterface NitroRouteConfig {\n\n  cache?: CacheOptions | false;\n\n  headers?: Record<string, string>;\n\n  redirect?: string | { to: string; statusCode?: HTTPStatusCode };\n\n  prerender?: boolean;\n\n  proxy?: string | ({ to: string } & ProxyOptions);\n\n  isr?: number | boolean;\n\n  cors?: boolean;\n\n  swr?: boolean | number;\n\n  static?: boolean | number;\n\n}\n\n\n\ninterface ExtendRouteRulesOptions {\n\n  override?: boolean\n\n}\n\n\n\ninterface CacheOptions {\n\n  swr?: boolean\n\n  name?: string\n\n  group?: string\n\n  integrity?: any\n\n  maxAge?: number\n\n  staleMaxAge?: number\n\n  base?: string\n\n  headersOnly?: boolean\n\n}\n\n\n\n// See https://www.jsdocs.io/package/h3#ProxyOptions\n\ninterface ProxyOptions {\n\n  headers?: RequestHeaders | HeadersInit;\n\n  fetchOptions?: RequestInit & { duplex?: Duplex } & {\n\n    ignoreResponseError?: boolean;\n\n  };\n\n  fetch?: typeof fetch;\n\n  sendStream?: boolean;\n\n  streamRequest?: boolean;\n\n  cookieDomainRewrite?: string | Record<string, string>;\n\n  cookiePathRewrite?: string | Record<string, string>;\n\n  onResponse?: (event: H3Event, response: Response) => void;\n\n}\n\nParameters\nroute\n\nType: string\n\nRequired: true\n\nA route pattern to match against.\n\nrule\n\nType: NitroRouteConfig\n\nRequired: true\n\nA route configuration to apply to the matched route.\n\noptions\n\nType: ExtendRouteRulesOptions\n\nDefault: {}\n\nOptions to pass to the route configuration. If override is set to true, it will override the existing route configuration.\n\nExamples\n// https://github.com/directus/website/blob/main/modules/redirects.ts\n\nimport { createResolver, defineNuxtModule, extendRouteRules, extendPages } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup(options) {\n\n    const resolver = createResolver(import.meta.url)\n\n\n\n    extendPages((pages) => {\n\n      pages.unshift({\n\n        name: 'preview-new',\n\n        path: '/preview-new',\n\n        file: resolver.resolve('runtime/preview.vue')\n\n       })\n\n    })\n\n\n\n    extendRouteRules('/preview', {\n\n      redirect: {\n\n        to: '/preview-new',\n\n        statusCode: 302\n\n      }\n\n    })\n\n\n\n    extendRouteRules('/preview-new', {\n\n      cache: {\n\n        maxAge: 60 * 60 * 24 * 7\n\n      }\n\n    })\n\n  }\n\n})\n\naddRouteMiddleware\n\nRegisters route middlewares to be available for all routes or for specific routes.\n\nRoute middlewares can be also defined in plugins via addRouteMiddleware composable.\n\nRead more about route middlewares in the Route middleware documentation.\nType\nfunction addRouteMiddleware (input: NuxtMiddleware | NuxtMiddleware[], options: AddRouteMiddlewareOptions): void\n\n\n\ntype NuxtMiddleware = {\n\n  name: string\n\n  path: string\n\n  global?: boolean\n\n}\n\n\n\ninterface AddRouteMiddlewareOptions {\n\n  override?: boolean\n\n}\n\nParameters\ninput\n\nType: NuxtMiddleware | NuxtMiddleware[]\n\nRequired: true\n\nA middleware object or an array of middleware objects with the following properties:\n\nname (required)\nType: string\nMiddleware name.\npath (required)\nType: string\nPath to the middleware.\nglobal (optional)\nType: boolean\nIf enabled, registers middleware to be available for all routes.\noptions\n\nType: AddRouteMiddlewareOptions\n\nDefault: {}\n\nOptions to pass to the middleware. If override is set to true, it will override the existing middleware with the same name.\n\nExamples\nruntime/auth.ts\n1\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  // isAuthenticated() is an example method verifying if a user is authenticated\n\n  if (to.path !== '/login' && isAuthenticated() === false) {\n\n    return navigateTo('/login')\n\n  }\n\n})\n\n\nContext\n\nNuxt Kit provides a set of utilities to help you work with context.\n\nLayout\n\nNuxt Kit provides a set of utilities to help you work with layouts."
  },
  {
    "title": "Components · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/components",
    "html": "Nuxt Kit\nComponents\nSource\n\nNuxt Kit provides a set of utilities to help you work with components. You can register components globally or locally, and also add directories to be scanned for components.\n\nComponents are the building blocks of your Nuxt application. They are reusable Vue instances that can be used to create a user interface. In Nuxt, components from the components directory are automatically imported by default. However, if you need to import components from an alternative directory or wish to selectively import them as needed, @nuxt/kit provides the addComponentsDir and addComponent methods. These utils allow you to customize the component configuration to better suit your needs.\n\naddComponentsDir\n\nRegister a directory to be scanned for components and imported only when used. Keep in mind, that this does not register components globally, until you specify global: true option.\n\nType\nasync function addComponentsDir (dir: ComponentsDir): void\n\n\n\ninterface ComponentsDir {\n\n  path: string\n\n  pattern?: string | string[]\n\n  ignore?: string[]\n\n  prefix?: string\n\n  pathPrefix?: boolean\n\n  enabled?: boolean\n\n  prefetch?: boolean\n\n  preload?: boolean\n\n  isAsync?: boolean\n\n  extendComponent?: (component: Component) => Promise<Component | void> | (Component | void)\n\n  global?: boolean\n\n  island?: boolean\n\n  watch?: boolean\n\n  extensions?: string[]\n\n  transpile?: 'auto' | boolean\n\n}\n\n\n\ninterface Component {\n\n  pascalName: string\n\n  kebabName: string\n\n  export: string\n\n  filePath: string\n\n  shortPath: string\n\n  chunkName: string\n\n  prefetch: boolean\n\n  preload: boolean\n\n  global?: boolean\n\n  island?: boolean\n\n  mode?: 'client' | 'server' | 'all'\n\n  priority?: number\n\n}\n\nParameters\ndir\n\nType: ComponentsDir\n\nRequired: true\n\nAn object with the following properties:\n\npath (required)\nType: string\nPath (absolute or relative) to the directory containing your components. You can use Nuxt aliases (~ or @) to refer to directories inside project or directly use an npm package path similar to require.\npattern (optional)\nType: string | string[]\nAccept Pattern that will be run against specified path.\nignore (optional)\nType: string[]\nIgnore patterns that will be run against specified path.\nprefix (optional)\nType: string\nPrefix all matched components with this string.\npathPrefix (optional)\nType: boolean\nPrefix component name by its path.\nenabled (optional)\nType: boolean\nIgnore scanning this directory if set to true.\nprefetch (optional)\nType: boolean\nThese properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on webpack documentation\npreload (optional)\nType: boolean\nThese properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on webpack documentation\nisAsync (optional)\nType: boolean\nThis flag indicates, component should be loaded async (with a separate chunk) regardless of using Lazy prefix or not.\nextendComponent (optional)\nType: (component: Component) => Promise<Component | void> | (Component | void)\nA function that will be called for each component found in the directory. It accepts a component object and should return a component object or a promise that resolves to a component object.\nglobal (optional)\nType: boolean\nDefault: false\nIf enabled, registers components to be globally available.\nisland (optional)\nType: boolean\nIf enabled, registers components as islands.\nwatch (optional)\nType: boolean\nWatch specified path for changes, including file additions and file deletions.\nextensions (optional)\nType: string[]\nExtensions supported by Nuxt builder.\ntranspile (optional)\nType: 'auto' | boolean\nTranspile specified path using build.transpile. If set to 'auto', it will set transpile: true if node_modules/ is in path.\naddComponent\n\nRegister a component to be automatically imported.\n\nType\nasync function addComponent (options: AddComponentOptions): void\n\n\n\ninterface AddComponentOptions {\n\n  name: string,\n\n  filePath: string,\n\n  pascalName?: string,\n\n  kebabName?: string,\n\n  export?: string,\n\n  shortPath?: string,\n\n  chunkName?: string,\n\n  prefetch?: boolean,\n\n  preload?: boolean,\n\n  global?: boolean,\n\n  island?: boolean,\n\n  mode?: 'client' | 'server' | 'all',\n\n  priority?: number,\n\n}\n\nParameters\noptions\n\nType: AddComponentOptions\n\nRequired: true\n\nAn object with the following properties:\n\nname (required)\nType: string\nComponent name.\nfilePath (required)\nType: string\nPath to the component.\npascalName (optional)\nType: pascalCase(options.name)\nPascal case component name. If not provided, it will be generated from the component name.\nkebabName (optional)\nType: kebabCase(options.name)\nKebab case component name. If not provided, it will be generated from the component name.\nexport (optional)\nType: string\nDefault: 'default'\nSpecify named or default export. If not provided, it will be set to 'default'.\nshortPath (optional)\nType: string\nShort path to the component. If not provided, it will be generated from the component path.\nchunkName (optional)\nType: string\nDefault: 'components/' + kebabCase(options.name)\nChunk name for the component. If not provided, it will be generated from the component name.\nprefetch (optional)\nType: boolean\nThese properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on webpack documentation\npreload (optional)\nType: boolean\nThese properties (prefetch/preload) are used in production to configure how components with Lazy prefix are handled by webpack via its magic comments. Learn more on webpack documentation\nglobal (optional)\nType: boolean\nDefault: false\nIf enabled, registers component to be globally available.\nisland (optional)\nType: boolean\nIf enabled, registers component as island. You can read more about islands in <NuxtIsland/> component description.\nmode (optional)\nType: 'client' | 'server' | 'all'\nDefault: 'all'\nThis options indicates if component should render on client, server or both. By default, it will render on both client and server.\npriority (optional)\nType: number\nDefault: 1\nPriority of the component, if multiple components have the same name, the one with the highest priority will be used.\n\nAuto-imports\n\nNuxt Kit provides a set of utilities to help you work with auto-imports. These functions allow you to register your own utils, composables and Vue APIs.\n\nContext\n\nNuxt Kit provides a set of utilities to help you work with context."
  },
  {
    "title": "Compatibility · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/compatibility",
    "html": "Nuxt Kit\nCompatibility\nSource\n\nNuxt Kit provides a set of utilities to help you check the compatibility of your modules with different Nuxt versions.\n\nNuxt Kit utilities can be used in Nuxt 3, Nuxt 2 with Bridge and even Nuxt 2 without Bridge. To make sure your module is compatible with all versions, you can use the checkNuxtCompatibility, assertNuxtCompatibility and hasNuxtCompatibility functions. They will check if the current Nuxt version meets the constraints you provide. Also you can use isNuxt2, isNuxt3 and getNuxtVersion functions for more granular checks.\n\ncheckNuxtCompatibility\n\nChecks if constraints are met for the current Nuxt version. If not, returns an array of messages. Nuxt 2 version also checks for bridge support.\n\nType\nasync function checkNuxtCompatibility(\n\n  constraints: NuxtCompatibility,\n\n  nuxt?: Nuxt\n\n): Promise<NuxtCompatibilityIssues>;\n\n\n\ninterface NuxtCompatibility {\n\n  nuxt?: string;\n\n  bridge?: boolean;\n\n}\n\n\n\ninterface NuxtCompatibilityIssue {\n\n  name: string;\n\n  message: string;\n\n}\n\n\n\ninterface NuxtCompatibilityIssues extends Array<NuxtCompatibilityIssue> {\n\n  toString(): string;\n\n}\n\nParameters\nconstraints\n\nType: NuxtCompatibility\n\nDefault: {}\n\nConstraints to check for. It accepts the following properties:\n\nnuxt (optional)\nType: string\nNuxt version in semver format. Versions may be defined in Node.js way, for example: >=2.15.0 <3.0.0.\nbridge (optional)\nType: boolean\nIf set to true, it will check if the current Nuxt version supports bridge.\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\nassertNuxtCompatibility\n\nAsserts that constraints are met for the current Nuxt version. If not, throws an error with the list of issues as string.\n\nType\nasync function assertNuxtCompatibility(\n\n  constraints: NuxtCompatibility,\n\n  nuxt?: Nuxt\n\n): Promise<true>;\n\n\n\ninterface NuxtCompatibility {\n\n  nuxt?: string;\n\n  bridge?: boolean;\n\n}\n\nParameters\nconstraints\n\nType: NuxtCompatibility\n\nDefault: {}\n\nConstraints to check for. It accepts the following properties:\n\nnuxt (optional)\nType: string\nNuxt version in semver format. Versions may be defined in Node.js way, for example: >=2.15.0 <3.0.0.\nbridge (optional)\nType: boolean\nIf set to true, it will check if the current Nuxt version supports bridge.\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\nhasNuxtCompatibility\n\nChecks if constraints are met for the current Nuxt version. Return true if all constraints are met, otherwise returns false. Nuxt 2 version also checks for bridge support.\n\nType\nasync function hasNuxtCompatibility(\n\n  constraints: NuxtCompatibility,\n\n  nuxt?: Nuxt\n\n): Promise<boolean>;\n\n\n\ninterface NuxtCompatibility {\n\n  nuxt?: string;\n\n  bridge?: boolean;\n\n}\n\nParameters\nconstraints\n\nType: NuxtCompatibility\n\nDefault: {}\n\nConstraints to check for. It accepts the following properties:\n\nnuxt (optional)\nType: string\nNuxt version in semver format. Versions may be defined in Node.js way, for example: >=2.15.0 <3.0.0.\nbridge (optional)\nType: boolean\nIf set to true, it will check if the current Nuxt version supports bridge.\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\nisNuxt2\n\nChecks if the current Nuxt version is 2.x.\n\nType\nfunction isNuxt2(nuxt?: Nuxt): boolean;\n\nParameters\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\nisNuxt3\n\nChecks if the current Nuxt version is 3.x.\n\nType\nfunction isNuxt3(nuxt?: Nuxt): boolean;\n\nParameters\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\ngetNuxtVersion\n\nReturns the current Nuxt version.\n\nType\nfunction getNuxtVersion(nuxt?: Nuxt): string;\n\nParameters\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\nProgrammatic Usage\n\nNuxt Kit provides a set of utilities to help you work with Nuxt programmatically. These functions allow you to load Nuxt, build Nuxt, and load Nuxt configuration.\n\nAuto-imports\n\nNuxt Kit provides a set of utilities to help you work with auto-imports. These functions allow you to register your own utils, composables and Vue APIs."
  },
  {
    "title": "Modules · Nuxt Kit",
    "url": "https://nuxt.com/docs/api/kit/modules",
    "html": "Nuxt Kit\nModules\nSource\n\nNuxt Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules.\n\nModules are the building blocks of Nuxt. Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules. For example, you can use the defineNuxtModule function to define a module and the installModule function to install a module programmatically.\n\ndefineNuxtModule\n\nDefine a Nuxt module, automatically merging defaults with user provided options, installing any hooks that are provided, and calling an optional setup function for full control.\n\nType\nfunction defineNuxtModule<OptionsT extends ModuleOptions> (definition: ModuleDefinition<OptionsT> | NuxtModule<OptionsT>): NuxtModule<OptionsT>\n\n\n\ntype ModuleOptions = Record<string, any>\n\n\n\ninterface ModuleDefinition<T extends ModuleOptions = ModuleOptions> {\n\n  meta?: ModuleMeta\n\n  defaults?: T | ((nuxt: Nuxt) => T)\n\n  schema?: T\n\n  hooks?: Partial<NuxtHooks>\n\n  setup?: (this: void, resolvedOptions: T, nuxt: Nuxt) => Awaitable<void | false | ModuleSetupReturn>\n\n}\n\n\n\ninterface NuxtModule<T extends ModuleOptions = ModuleOptions> {\n\n  (this: void, inlineOptions: T, nuxt: Nuxt): Awaitable<void | false | ModuleSetupReturn>\n\n  getOptions?: (inlineOptions?: T, nuxt?: Nuxt) => Promise<T>\n\n  getMeta?: () => Promise<ModuleMeta>\n\n}\n\n\n\ninterface ModuleSetupReturn {\n\n  timings?: {\n\n    setup?: number\n\n    [key: string]: number | undefined\n\n  }\n\n}\n\n\n\ninterface ModuleMeta {\n\n  name?: string\n\n  version?: string\n\n  configKey?: string\n\n  compatibility?: NuxtCompatibility\n\n  [key: string]: unknown\n\n}\n\nParameters\ndefinition\n\nType: ModuleDefinition<T> | NuxtModule<T>\n\nRequired: true\n\nA module definition object or a module function.\n\nmeta (optional)\nType: ModuleMeta\nMetadata of the module. It defines the module name, version, config key and compatibility.\ndefaults (optional)\nType: T | ((nuxt: Nuxt) => T)\nDefault options for the module. If a function is provided, it will be called with the Nuxt instance as the first argument.\nschema (optional)\nType: T\nSchema for the module options. If provided, options will be applied to the schema.\nhooks (optional)\nType: Partial<NuxtHooks>\nHooks to be installed for the module. If provided, the module will install the hooks.\nsetup (optional)\nType: (this: void, resolvedOptions: T, nuxt: Nuxt) => Awaitable<void | false | ModuleSetupReturn>\nSetup function for the module. If provided, the module will call the setup function.\nExamples\n// https://github.com/nuxt/starter/tree/module\n\nimport { defineNuxtModule } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'my-module',\n\n    configKey: 'myModule'\n\n  },\n\n  defaults: {\n\n    test: 123\n\n  },\n\n  setup (options, nuxt) {\n\n    nuxt.hook('modules:done', () => {\n\n      console.log('My module is ready with current test option: ', options.test)\n\n    })    \n\n  }\n\n})\n\ninstallModule\n\nInstall specified Nuxt module programmatically. This is helpful when your module depends on other modules. You can pass the module options as an object to inlineOptions and they will be passed to the module's setup function.\n\nType\nasync function installModule (moduleToInstall: string | NuxtModule, inlineOptions?: any, nuxt?: Nuxt)\n\nParameters\nmoduleToInstall\n\nType: string | NuxtModule\n\nRequired: true\n\nThe module to install. Can be either a string with the module name or a module object itself.\n\ninlineOptions\n\nType: any\n\nDefault: {}\n\nAn object with the module options to be passed to the module's setup function.\n\nnuxt\n\nType: Nuxt\n\nDefault: useNuxt()\n\nNuxt instance. If not provided, it will be retrieved from the context via useNuxt() call.\n\nExamples\nimport { defineNuxtModule, installModule } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({  \n\n  async setup (options, nuxt) {\n\n    // will install @nuxtjs/fontaine with Roboto font and Impact fallback\n\n    await installModule('@nuxtjs/fontaine', {\n\n      // module configuration\n\n      fonts: [\n\n        {\n\n          family: 'Roboto',\n\n          fallbacks: ['Impact'],\n\n          fallbackName: 'fallback-a',\n\n        }\n\n      ]\n\n    })\n\n  }\n\n})\n\n\nnuxi upgrade\n\nThe upgrade command upgrades Nuxt 3 to the latest version.\n\nProgrammatic Usage\n\nNuxt Kit provides a set of utilities to help you work with Nuxt programmatically. These functions allow you to load Nuxt, build Nuxt, and load Nuxt configuration."
  },
  {
    "title": "nuxi typecheck · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/typecheck",
    "html": "Commands\nnuxi typecheck\nSource\n\nThe typecheck command runs vue-tsc to check types throughout your app.\n\nTerminal\nnpx nuxi typecheck [--log-level] [rootDir]\n\n\nThe typecheck command runs vue-tsc to check types throughout your app.\n\nOption\tDefault\tDescription\nrootDir\t.\tThe directory of the target application.\nThis command sets process.env.NODE_ENV to production. To override, define NODE_ENV in a .env file or as a command-line argument.\nRead more on how to enable type-checking at build or development time.\n\nnuxi preview\n\nThe preview command starts a server to preview your application after the build command.\n\nnuxi upgrade\n\nThe upgrade command upgrades Nuxt 3 to the latest version."
  },
  {
    "title": "nuxi upgrade · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/upgrade",
    "html": "Commands\nnuxi upgrade\nSource\n\nThe upgrade command upgrades Nuxt 3 to the latest version.\n\nTerminal\nnpx nuxi upgrade [--force|-f]\n\n\nThe upgrade command upgrades Nuxt 3 to the latest version.\n\nOption\tDefault\tDescription\n--force, -f\tfalse\tRemoves node_modules and lock files before upgrade.\n\nnuxi typecheck\n\nThe typecheck command runs vue-tsc to check types throughout your app.\n\nModules\n\nNuxt Kit provides a set of utilities to help you create and use modules. You can use these utilities to create your own modules or to reuse existing modules."
  },
  {
    "title": "nuxi preview · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/preview",
    "html": "Commands\nnuxi preview\nSource\n\nThe preview command starts a server to preview your application after the build command.\n\nTerminal\nnpx nuxi preview [rootDir] [--dotenv]\n\n\nThe preview command starts a server to preview your Nuxt application after running the build command. The start command is an alias for preview. When running your application in production refer to the Deployment section.\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the application to preview.\n--dotenv\t.\tPoint to another .env file to load, relative to the root directory.\n\nThis command sets process.env.NODE_ENV to production. To override, define NODE_ENV in a .env file or as command-line argument.\n\nFor convenience, in preview mode, your .env file will be loaded into process.env. (However, in production you will need to ensure your environment variables are set yourself.)\n\nnuxi prepare\n\nThe prepare command creates a .nuxt directory in your application and generates types.\n\nnuxi typecheck\n\nThe typecheck command runs vue-tsc to check types throughout your app."
  },
  {
    "title": "nuxi prepare · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/prepare",
    "html": "Commands\nnuxi prepare\nSource\n\nThe prepare command creates a .nuxt directory in your application and generates types.\n\nTerminal\nnpx nuxi prepare [--log-level] [rootDir]\n\n\nThe prepare command creates a .nuxt directory in your application and generates types. This can be useful in a CI environment or as a postinstall command in your package.json.\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the application to prepare.\n\nnuxi init\n\nThe init command initializes a fresh Nuxt project.\n\nnuxi preview\n\nThe preview command starts a server to preview your application after the build command."
  },
  {
    "title": "nuxi info · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/info",
    "html": "Commands\nnuxi info\nSource\n\nThe info command logs information about the current or specified Nuxt project.\n\nTerminal\nnpx nuxi info [rootDir]\n\n\nThe info command logs information about the current or specified Nuxt project.\n\nOption\tDefault\tDescription\nrootDir\t.\tThe directory of the target application.\n\nnuxi generate\n\nPre-renders every route of the application and stores the result in plain HTML files.\n\nnuxi init\n\nThe init command initializes a fresh Nuxt project."
  },
  {
    "title": "nuxi devtools · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/devtools",
    "html": "Commands\nnuxi devtools\nSource\n\nThe devtools command allows you to enable or disable Nuxt DevTools on a per-project basis.\n\nTerminal\nnpx nuxi devtools enable|disable [rootDir]\n\n\nRunning nuxi devtools enable will install the Nuxt DevTools globally, and also enable it within the particular project you are using. It is saved as a preference in your user-level .nuxtrc. If you want to remove devtools support for a particular project, you can run nuxi devtools disable.\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the app you want to enable devtools for.\nRead more about the Nuxt DevTools.\n\nnuxi dev\n\nThe dev command starts a development server with hot module replacement at http://localhost:3000\n\nnuxi generate\n\nPre-renders every route of the application and stores the result in plain HTML files."
  },
  {
    "title": "nuxi generate · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/generate",
    "html": "Commands\nnuxi generate\nSource\n\nPre-renders every route of the application and stores the result in plain HTML files.\n\nTerminal\nnpx nuxi generate [rootDir] [--dotenv]\n\n\nThe generate command pre-renders every route of your application and stores the result in plain HTML files that you can deploy on any static hosting services. The command triggers the nuxi build command with the prerender argument set to true\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the application to generate\n--dotenv\t.\tPoint to another .env file to load, relative to the root directory.\nRead more about pre-rendering and static hosting.\n\nnuxi devtools\n\nThe devtools command allows you to enable or disable Nuxt DevTools on a per-project basis.\n\nnuxi info\n\nThe info command logs information about the current or specified Nuxt project."
  },
  {
    "title": "nuxi init · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/init",
    "html": "Commands\nnuxi init\nSource\n\nThe init command initializes a fresh Nuxt project.\n\nTerminal\nnpx nuxi init|create [--verbose|-v] [--template,-t] [dir]\n\n\nThe init command initializes a fresh Nuxt project using unjs/giget.\n\nOptions\nOption\tDefault\tDescription\n--template, -t\tv3\tSpecify template name or git repository to use as a template. Format is gh:org/name to use a custom github template.\n--force\tfalse\tForce clone to any existing directory.\n--offline\tfalse\tDo not attempt to download from github and only use local cache.\n--prefer-offline\tfalse\tTry local cache first to download templates.\n--shell\tfalse\tOpen shell in cloned directory (experimental).\nEnvironment variables\nNUXI_INIT_REGISTRY: Set to a custom template registry. (learn more).\nDefault registry is loaded from nuxt/starter/templates\n\nnuxi info\n\nThe info command logs information about the current or specified Nuxt project.\n\nnuxi prepare\n\nThe prepare command creates a .nuxt directory in your application and generates types."
  },
  {
    "title": "nuxi dev · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/dev",
    "html": "Commands\nnuxi dev\nSource\n\nThe dev command starts a development server with hot module replacement at http://localhost:3000\n\nTerminal\nnpx nuxi dev [rootDir] [--dotenv] [--log-level] [--clipboard] [--open, -o] [--no-clear] [--port, -p] [--host, -h] [--https] [--ssl-cert] [--ssl-key]\n\n\nThe dev command starts a development server with hot module replacement at http://localhost:3000\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the application to serve.\n--dotenv\t.\tPoint to another .env file to load, relative to the root directory.\n--clipboard\tfalse\tCopy URL to clipboard.\n--open, -o\tfalse\tOpen URL in browser.\n--no-clear\tfalse\tDoes not clear the console after startup.\n--port, -p\t3000\tPort to listen.\n--host, -h\tlocalhost\tHostname of the server.\n--https\tfalse\tListen with https protocol with a self-signed certificate by default.\n--ssl-cert\tnull\tSpecify a certificate for https.\n--ssl-key\tnull\tSpecify the key for the https certificate.\n\nThe port and host can also be set via NUXT_PORT, PORT, NUXT_HOST or HOST environment variables.\n\nAdditionally to the above options, nuxi can pass options through to listhen, e.g. --no-qr to turn off the dev server QR code. You can find the list of listhen options in the unjs/listhen docs.\n\nThis command sets process.env.NODE_ENV to development.\n\nIf you are using a self-signed certificate in development, you will need to set NODE_TLS_REJECT_UNAUTHORIZED=0 in your environment.\n\nnuxi cleanup\n\nRemove common generated Nuxt files and caches.\n\nnuxi devtools\n\nThe devtools command allows you to enable or disable Nuxt DevTools on a per-project basis."
  },
  {
    "title": "updateAppConfig · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/update-app-config",
    "html": "Utils\nupdateAppConfig\nSource\n\nUpdate the App Config at runtime.\n\nUpdates the app.config using deep assignment. Existing (nested) properties will be preserved.\nUsage\nconst appConfig = useAppConfig() // { foo: 'bar' }\n\n\n\nconst newAppConfig = { foo: 'baz' }\n\n\n\nupdateAppConfig(newAppConfig)\n\n\n\nconsole.log(appConfig) // { foo: 'baz' }\n\n Read more in Docs > Guide > Directory Structure > App Config.\n\nshowError\n\nNuxt provides a quick and simple way to show a full screen error page if needed.\n\nnuxi add\n\nScaffold an entity into your Nuxt application."
  },
  {
    "title": "nuxi build-module · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/build-module",
    "html": "Commands\nnuxi build-module\nSource\n\nNuxt command to build your Nuxt module before publishing.\n\nTerminal\nnpx nuxi build-module [--stub] [rootDir]\n\n\nThe build-module command runs @nuxt/module-builder to generate dist directory within your rootDir that contains the full build for your nuxt-module.\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the module to bundle.\n--stub\tfalse\tStub out your module for development using jiti. (note: This is mainly for development purposes.)\nRead more about @nuxt/module-builder.\n\nnuxi analyze\n\nAnalyze the production bundle or your Nuxt application.\n\nnuxi build\n\nBuild your Nuxt application."
  },
  {
    "title": "nuxi build · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/build",
    "html": "Commands\nnuxi build\nSource\n\nBuild your Nuxt application.\n\nTerminal\nnpx nuxi build [--prerender] [--dotenv] [--log-level] [rootDir]\n\n\nThe build command creates a .output directory with all your application, server and dependencies ready for production.\n\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the application to bundle.\n--prerender\tfalse\tPre-render every route of your application. (note: This is an experimental flag. The behavior might be changed.)\n--dotenv\t.\tPoint to another .env file to load, relative to the root directory.\nThis command sets process.env.NODE_ENV to production.\n\nnuxi build-module\n\nNuxt command to build your Nuxt module before publishing.\n\nnuxi cleanup\n\nRemove common generated Nuxt files and caches."
  },
  {
    "title": "setResponseStatus · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/set-response-status",
    "html": "Utils\nsetResponseStatus\nSource\n\nsetResponseStatus sets the statusCode (and optionally the statusMessage) of the response.\n\nNuxt provides composables and utilities for first-class server-side-rendering support.\n\nsetResponseStatus sets the statusCode (and optionally the statusMessage) of the response.\n\nconst event = useRequestEvent()\n\n\n\n// Set the status code to 404 for a custom 404 page\n\nsetResponseStatus(event, 404)\n\n\n\n// Set the status message as well\n\nsetResponseStatus(event, 404, 'Page Not Found')\n\nIn the browser, setResponseStatus will have no effect.\n Read more in Docs > Getting Started > Error Handling.\n\nsetPageLayout\n\nsetPageLayout allows you to dynamically change the layout of a page.\n\nshowError\n\nNuxt provides a quick and simple way to show a full screen error page if needed."
  },
  {
    "title": "nuxi cleanup · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/cleanup",
    "html": "Commands\nnuxi cleanup\nSource\n\nRemove common generated Nuxt files and caches.\n\nTerminal\nnpx nuxi clean|cleanup [rootDir]\n\n\nThe cleanup command removes common generated Nuxt files and caches, including:\n\n.nuxt\n.output\nnode_modules/.vite\nnode_modules/.cache\nOption\tDefault\tDescription\nrootDir\t.\tThe root directory of the project.\n\nnuxi build\n\nBuild your Nuxt application.\n\nnuxi dev\n\nThe dev command starts a development server with hot module replacement at http://localhost:3000"
  },
  {
    "title": "nuxi analyze · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/analyze",
    "html": "Commands\nnuxi analyze\nSource\n\nAnalyze the production bundle or your Nuxt application.\n\nTerminal\nnpx nuxi analyze [--log-level] [rootDir]\n\n\nThe analyze command builds Nuxt and analyzes the production bundle (experimental).\n\nOption\tDefault\tDescription\nrootDir\t.\tThe directory of the target application.\nThis command sets process.env.NODE_ENV to production.\n\nnuxi add\n\nScaffold an entity into your Nuxt application.\n\nnuxi build-module\n\nNuxt command to build your Nuxt module before publishing."
  },
  {
    "title": "nuxi add · Nuxt Commands",
    "url": "https://nuxt.com/docs/api/commands/add",
    "html": "Commands\nnuxi add\nSource\n\nScaffold an entity into your Nuxt application.\n\nTerminal\nnpx nuxi add [--cwd] [--force] <TEMPLATE> <NAME>\n\nOption\tDefault\tDescription\nTEMPLATE\t-\tSpecify a template of the file to be generated.\nNAME\t-\tSpecify a name of the file that will be created.\n--cwd\t.\tThe directory of the target application.\n--force\tfalse\tForce override file if it already exists.\n\nModifiers:\n\nSome templates support additional modifier flags to add a suffix (like .client or .get) to their name.\n\nTerminal\n# Generates `/plugins/sockets.client.ts`\n\nnpx nuxi add plugin sockets --client\n\nnuxi add component\nModifier flags: --mode client|server or --client or --server\nTerminal\n# Generates `components/TheHeader.vue`\n\nnpx nuxi add component TheHeader\n\nnuxi add composable\nTerminal\n# Generates `composables/foo.ts`\n\nnpx nuxi add composable foo\n\nnuxi add layout\nTerminal\n# Generates `layouts/custom.vue`\n\nnpx nuxi add layout custom\n\nnuxi add plugin\nModifier flags: --mode client|server or --clientor --server\nTerminal\n# Generates `plugins/analytics.ts`\n\nnpx nuxi add plugin analytics\n\nnuxi add page\nTerminal\n# Generates `pages/about.vue`\n\nnpx nuxi add page about\n\nTerminal\n# Generates `pages/category/[id].vue`\n\nnpx nuxi add page \"category/[id]\"\n\nnuxi add middleware\nModifier flags: --global\nTerminal\n# Generates `middleware/auth.ts`\n\nnpx nuxi add middleware auth\n\nnuxi add api\nModifier flags: --method (can accept connect, delete, get, head, options, patch, post, put or trace) or alternatively you can directly use --get, --post, etc.\nTerminal\n# Generates `server/api/hello.ts`\n\nnpx nuxi add api hello\n\n\nupdateAppConfig\n\nUpdate the App Config at runtime.\n\nnuxi analyze\n\nAnalyze the production bundle or your Nuxt application."
  },
  {
    "title": "showError · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/show-error",
    "html": "Utils\nshowError\nSource\n\nNuxt provides a quick and simple way to show a full screen error page if needed.\n\nWithin your pages, components and plugins you can use showError to show an error.\n\nParameters:\n\nerror: string | Error | Partial<{ cause, data, message, name, stack, statusCode, statusMessage }>\nshowError(\"😱 Oh no, an error has been thrown.\")\n\nshowError({\n\n  statusCode: 404,\n\n  statusMessage: \"Page Not Found\"\n\n})\n\n\nThe error is set in the state using useError() to create a reactive and SSR-friendly shared error state across components.\n\nshowError calls the app:error hook.\n Read more in Docs > Getting Started > Error Handling.\n\nsetResponseStatus\n\nsetResponseStatus sets the statusCode (and optionally the statusMessage) of the response.\n\nupdateAppConfig\n\nUpdate the App Config at runtime."
  },
  {
    "title": "setPageLayout · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/set-page-layout",
    "html": "Utils\nsetPageLayout\nSource\n\nsetPageLayout allows you to dynamically change the layout of a page.\n\nsetPageLayout relies on access to the Nuxt context and can only be called within components' setup functions, plugins, and route middleware.\nmiddleware/custom-layout.ts\nexport default defineNuxtRouteMiddleware((to) => {\n\n  // Set the layout on the route you are navigating _to_\n\n  setPageLayout('other')\n\n})\n\nIf you choose to set the layout dynamically on the server side, you must do so before the layout is rendered by Vue (that is, within a plugin or route middleware) to avoid a hydration mismatch.\n\nreloadNuxtApp\n\nreloadNuxtApp will perform a hard reload of the page.\n\nsetResponseStatus\n\nsetResponseStatus sets the statusCode (and optionally the statusMessage) of the response."
  },
  {
    "title": "reloadNuxtApp · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/reload-nuxt-app",
    "html": "Utils\nreloadNuxtApp\nSource\n\nreloadNuxtApp will perform a hard reload of the page.\n\nreloadNuxtApp will perform a hard reload of your app, re-requesting a page and its dependencies from the server.\n\nBy default, it will also save the current state of your app (that is, any state you could access with useState).\n\nYou can enable experimental restoration of this state by enabling the experimental.restoreState option in your nuxt.config file.\nType\nreloadNuxtApp(options?: ReloadNuxtAppOptions)\n\n\n\ninterface ReloadNuxtAppOptions {\n\n  ttl?: number\n\n  force?: boolean\n\n  path?: string\n\n  persistState?: boolean\n\n}\n\noptions (optional)\n\nType: ReloadNuxtAppOptions\n\nAn object accepting the following properties:\n\npath (optional)\nType: string\nDefault: window.location.pathname\nThe path to reload (defaulting to the current path). If this is different from the current window location it will trigger a navigation and add an entry in the browser history.\nttl (optional)\nType: number\nDefault: 10000\nThe number of milliseconds in which to ignore future reload requests. If called again within this time period, reloadNuxtApp will not reload your app to avoid reload loops.\nforce (optional)\nType: boolean\nDefault: false\nThis option allows bypassing reload loop protection entirely, forcing a reload even if one has occurred within the previously specified TTL.\npersistState (optional)\nType: boolean\nDefault: false\nWhether to dump the current Nuxt state to sessionStorage (as nuxt:reload:state). By default this will have no effect on reload unless experimental.restoreState is also set, or unless you handle restoring the state yourself.\n\nrefreshNuxtData\n\nrefreshNuxtData refetches all data from the server and updates the page.\n\nsetPageLayout\n\nsetPageLayout allows you to dynamically change the layout of a page."
  },
  {
    "title": "prefetchComponents · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/prefetch-components",
    "html": "Utils\nprefetchComponents\nSource\n\nNuxt provides utilities to give you control over prefetching components.\n\nPrefetching component downloads the code in the background, this is based on the assumption that the component will likely be used for rendering, enabling the component to load instantly if and when the user requests it. The component is downloaded and cached for anticipated future use without the user making an explicit request for it.\n\nUse prefetchComponents to manually prefetch individual components that have been registered globally in your Nuxt app. By default Nuxt registers these as async components. You must use the Pascal-cased version of the component name.\n\nawait prefetchComponents('MyGlobalComponent')\n\n\n\nawait prefetchComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])\n\nCurrent implementation behaves exactly the same as preloadComponents by preloading components instead of just prefetching we are working to improve this behavior.\nOn server, prefetchComponents will have no effect.\n\nonNuxtReady\n\nThe onNuxtReady composable allows running a callback after your app has finished initializing.\n\npreloadComponents\n\nNuxt provides utilities to give you control over preloading components."
  },
  {
    "title": "refreshNuxtData · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/refresh-nuxt-data",
    "html": "Utils\nrefreshNuxtData\nSource\n\nrefreshNuxtData refetches all data from the server and updates the page.\n\nrefreshNuxtData re-fetches all data from the server and updates the page as well as invalidates the cache of useAsyncData , useLazyAsyncData, useFetch and useLazyFetch.\nType\nrefreshNuxtData(keys?: string | string[])\n\n\nParameters:\n\nkeys:\nType: String | String[]\nrefreshNuxtData accepts a single or an array of strings as keys that are used to fetch the data. This parameter is optional. All useAsyncData and useFetch are re-fetched when no keys are specified.\nRefresh All Data\n\nThis example below refreshes all data being fetched using useAsyncData and useFetch on the current page.\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\nconst refreshing = ref(false)\n\nconst refreshAll = async () => {\n\n  refreshing.value = true\n\n  try {\n\n    await refreshNuxtData()\n\n  } finally {\n\n    refreshing.value = false\n\n  }\n\n}\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <button :disabled=\"refreshing\" @click=\"refreshAll\">\n\n      Refetch All Data\n\n    </button>\n\n  </div>\n\n</template>\n\nRefresh Specific Data\n\nThis example below refreshes only data where the key matches to count.\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\nconst { pending, data: count } = await useLazyAsyncData('count', () => $fetch('/api/count'))\n\nconst refresh = () => refreshNuxtData('count')\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    {{ pending ? 'Loading' : count }}\n\n  </div>\n\n  <button @click=\"refresh\">Refresh</button>\n\n</template>\n\n Read more in Docs > Getting Started > Data Fetching.\n\nprerenderRoutes\n\nprerenderRoutes hints to Nitro to prerender an additional route.\n\nreloadNuxtApp\n\nreloadNuxtApp will perform a hard reload of the page."
  },
  {
    "title": "prerenderRoutes · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/prerender-routes",
    "html": "Utils\nprerenderRoutes\nSource\n\nprerenderRoutes hints to Nitro to prerender an additional route.\n\nWhen prerendering, you can hint to Nitro to prerender additional paths, even if their URLs do not show up in the HTML of the generated page.\n\nconst route = useRoute()\n\n\n\nprerenderRoutes('/')\n\nprerenderRoutes(['/', '/about'])\n\nIn the browser, or if called outside prerendering, prerenderRoutes will have no effect.\n\npreloadRouteComponents\n\npreloadRouteComponents allows you to manually preload individual pages in your Nuxt app.\n\nrefreshNuxtData\n\nrefreshNuxtData refetches all data from the server and updates the page."
  },
  {
    "title": "preloadRouteComponents · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/preload-route-components",
    "html": "Utils\npreloadRouteComponents\nSource\n\npreloadRouteComponents allows you to manually preload individual pages in your Nuxt app.\n\nPreloading routes loads the components of a given route that the user might navigate to in future. This ensures that the components are available earlier and less likely to block the navigation, improving performance.\n\nNuxt already automatically preloads the necessary routes if you're using the NuxtLink component.\n Read more in Docs > API > Components > Nuxt Link.\nExample\n\nPreload a route when using navigateTo.\n\n// we don't await this async function, to avoid blocking rendering\n\n// this component's setup function\n\npreloadRouteComponents('/dashboard')\n\n\n\nconst submit = async () => {\n\n  const results = await $fetch('/api/authentication')\n\n\n\n  if (results.token) {\n\n    await navigateTo('/dashboard')\n\n  }\n\n}\n\n Read more in Docs > API > Utils > Navigate To.\nOn server, preloadRouteComponents will have no effect.\n\npreloadComponents\n\nNuxt provides utilities to give you control over preloading components.\n\nprerenderRoutes\n\nprerenderRoutes hints to Nitro to prerender an additional route."
  },
  {
    "title": "onNuxtReady · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/on-nuxt-ready",
    "html": "Utils\nonNuxtReady\nSource\n\nThe onNuxtReady composable allows running a callback after your app has finished initializing.\n\nonNuxtReady only runs on the client-side.\nIt is ideal for running code that should not block the initial rendering of your app.\nplugins/ready.client.ts\nexport default defineNuxtPlugin(() => {\n\n  onNuxtReady(async () => {\n\n    const myAnalyticsLibrary = await import('my-big-analytics-library')\n\n    // do something with myAnalyticsLibrary\n\n  })\n\n})\n\n\nIt is 'safe' to run even after your app has initialized. In this case, then the code will be registered to run in the next idle callback.\n\nonBeforeRouteUpdate\n\nThe onBeforeRouteUpdate composable allows registering a route guard within a component.\n\nprefetchComponents\n\nNuxt provides utilities to give you control over prefetching components."
  },
  {
    "title": "preloadComponents · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/preload-components",
    "html": "Utils\npreloadComponents\nSource\n\nNuxt provides utilities to give you control over preloading components.\n\nPreloading components loads components that your page will need very soon, which you want to start loading early in rendering lifecycle. This ensures they are available earlier and are less likely to block the page's render, improving performance.\n\nUse preloadComponents to manually preload individual components that have been registered globally in your Nuxt app. By default Nuxt registers these as async components. You must use the Pascal-cased version of the component name.\n\nawait preloadComponents('MyGlobalComponent')\n\n\n\nawait preloadComponents(['MyGlobalComponent1', 'MyGlobalComponent2'])\n\nOn server, preloadComponents will have no effect.\n\nprefetchComponents\n\nNuxt provides utilities to give you control over prefetching components.\n\npreloadRouteComponents\n\npreloadRouteComponents allows you to manually preload individual pages in your Nuxt app."
  },
  {
    "title": "onBeforeRouteLeave · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/on-before-route-leave",
    "html": "Utils\nonBeforeRouteLeave\nSource\n\nThe onBeforeRouteLeave composable allows registering a route guard within a component.\n\n Read more in Vue Router Docs.\n\nnavigateTo\n\nnavigateTo is a helper function that programmatically navigates users.\n\nonBeforeRouteUpdate\n\nThe onBeforeRouteUpdate composable allows registering a route guard within a component."
  },
  {
    "title": "onBeforeRouteUpdate · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/on-before-route-update",
    "html": "Utils\nonBeforeRouteUpdate\nSource\n\nThe onBeforeRouteUpdate composable allows registering a route guard within a component.\n\n Read more in Vue Router Docs.\n\nonBeforeRouteLeave\n\nThe onBeforeRouteLeave composable allows registering a route guard within a component.\n\nonNuxtReady\n\nThe onNuxtReady composable allows running a callback after your app has finished initializing."
  },
  {
    "title": "navigateTo · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/navigate-to",
    "html": "Utils\nnavigateTo\nSource\n\nnavigateTo is a helper function that programmatically navigates users.\n\nnavigateTo is available on both server side and client side.\nUsage\nWithin a Vue Component\n<script setup lang=\"ts\">\n\n// passing 'to' as a string\n\nawait navigateTo('/search')\n\n\n\n// ... or as a route object\n\nawait navigateTo({ path: '/search' })\n\n\n\n// ... or as a route object with query parameters\n\nawait navigateTo({\n\n  path: '/search',\n\n  query: {\n\n    page: 1,\n\n    sort: 'asc'\n\n  }\n\n})\n\n</script>\n\nWithin Route Middleware\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  if (to.path !== '/search') {\n\n    // setting the redirect code to '301 Moved Permanently'\n\n    return navigateTo('/search', { redirectCode: 301 })\n\n  }\n\n})\n\n Read more in Docs > Guide > Directory Structure > Middleware.\nExternal URL\n<script setup lang=\"ts\">\n\n// will throw an error;\n\n// navigating to an external URL is not allowed by default\n\nawait navigateTo('https://nuxt.com')\n\n\n\n// will redirect successfully with the 'external' parameter set to 'true'\n\nawait navigateTo('https://nuxt.com', {\n\n  external: true\n\n})\n\n</script>\n\nUsing open()\n<script setup lang=\"ts\">\n\n// will open 'https://nuxt.com' in a new tab\n\nawait navigateTo('https://nuxt.com', {  \n\n  open: {\n\n    target: '_blank',\n\n    windowFeatures: {\n\n      width: 500,\n\n      height: 500\n\n    }\n\n  }\n\n})\n\n</script>\n\nType\nnavigateTo(to: RouteLocationRaw | undefined | null, options?: NavigateToOptions) => Promise<void | NavigationFailure> | RouteLocationRaw\n\n\n\ninterface NavigateToOptions {\n\n  replace?: boolean\n\n  redirectCode?: number\n\n  external?: boolean\n\n  open?: OpenOptions\n\n}\n\nMake sure to always use await or return on result of navigateTo when calling it.\nParameters\nto\n\nType: RouteLocationRaw | undefined | null\n\nDefault: '/'\n\nto can be a plain string or a route object to redirect to. When passed as undefined or null, it will default to '/'.\n\noptions (optional)\n\nType: NavigateToOptions\n\nAn object accepting the following properties:\n\nreplace (optional)\nType: boolean\nDefault: false\nBy default, navigateTo pushes the given route into the Vue Router's instance on the client side.\nThis behavior can be changed by setting replace to true, to indicate that given route should be replaced.\nredirectCode (optional)\nType: number\nDefault: 302\nnavigateTo redirects to the given path and sets the redirect code to 302 Found by default when the redirection takes place on the server side.\nThis default behavior can be modified by providing different redirectCode. Commonly, 301 Moved Permanently can be used for permanent redirections.\nexternal (optional)\nType: boolean\nDefault: false\nAllows navigating to an external URL when set to true. Otherwise, navigateTo will throw an error, as external navigation is not allowed by default.\nopen (optional)\nType: OpenOptions\nAllows navigating to the URL using the open() method of the window. This option is only applicable on the client side and will be ignored on the server side.\nAn object accepting the following properties:\ntarget\nType: string\nDefault: '_blank'\nA string, without whitespace, specifying the name of the browsing context the resource is being loaded into.\nwindowFeatures (optional)\nType: OpenWindowFeatures\nAn object accepting the following properties:\npopup (optional)\nType: boolean\nwidth or innerWidth (optional)\nType: number\nheight or innerHeight (optional)\nType: number\nleft or screenX (optional)\nType: number\ntop or screenY (optional)\nType: number\nnoopener (optional)\nType: boolean\nnoreferrer (optional)\nType: boolean\n\nRefer to the documentation for more detailed information on the windowFeatures properties.\n\ndefineRouteRules\n\nDefine route rules for hybrid rendering at the page level.\n\nonBeforeRouteLeave\n\nThe onBeforeRouteLeave composable allows registering a route guard within a component."
  },
  {
    "title": "defineRouteRules · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/define-route-rules",
    "html": "Utils\ndefineRouteRules\nSource\n\nDefine route rules for hybrid rendering at the page level.\n\nThis feature is experimental and in order to use it you must enable the experimental.inlineRouteRules option in your nuxt.config.\nUsage\npages/index.vue\n<script setup>\n\ndefineRouteRules({\n\n  prerender: true\n\n})\n\n</script>\n\n\n\n<template>\n\n  <h1>Hello world!</h1>\n\n</template>\n\n\nWill be translated to:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  routeRules: {\n\n    '/': { prerender: true }\n\n  }\n\n})\n\nWhen running nuxt build, the home page will be pre-rendered in .output/public/index.html and statically served.\nNotes\nA rule defined in ~/pages/foo/bar.vue will be applied to /foo/bar requests.\nA rule in ~/pages/foo/[id].vue will be applied to /foo/** requests.\n\nFor more control, such as if you are using a custom path or alias set in the page's definePageMeta, you should set routeRules directly within your nuxt.config.\n\nRead more about the routeRules.\n\ndefinePageMeta\n\nDefine metadata for your page components.\n\nnavigateTo\n\nnavigateTo is a helper function that programmatically navigates users."
  },
  {
    "title": "definePageMeta · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/define-page-meta",
    "html": "Utils\ndefinePageMeta\nSource\n\nDefine metadata for your page components.\n\ndefinePageMeta is a compiler macro that you can use to set metadata for your page components located in the pages/ directory (unless set otherwise). This way you can set custom metadata for each static or dynamic route of your Nuxt application.\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  layout: 'default'\n\n})\n\n</script>\n\n Read more in Docs > Guide > Directory Structure > Pages > #page Metadata.\nType\ndefinePageMeta(meta: PageMeta) => void\n\n\n\ninterface PageMeta {\n\n  validate?: (route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>\n\n  redirect?: RouteRecordRedirectOption\n\n  name?: string\n\n  path?: string\n\n  alias?: string | string[]\n\n  pageTransition?: boolean | TransitionProps\n\n  layoutTransition?: boolean | TransitionProps\n\n  key?: false | string | ((route: RouteLocationNormalizedLoaded) => string)\n\n  keepalive?: boolean | KeepAliveProps\n\n  layout?: false | LayoutKey | Ref<LayoutKey> | ComputedRef<LayoutKey>\n\n  middleware?: MiddlewareKey | NavigationGuard | Array<MiddlewareKey | NavigationGuard>\n\n  scrollToTop?: boolean | ((to: RouteLocationNormalizedLoaded, from: RouteLocationNormalizedLoaded) => boolean)\n\n  [key: string]: unknown\n\n}\n\nParameters\nmeta\nType: PageMeta\nAn object accepting the following page metadata:\nname\nType: string\nYou may define a name for this page's route. By default, name is generated based on path inside the pages/ directory.\n\npath\nType: string\nYou may define a path matcher, if you have a more complex pattern than can be expressed with the file name.\n\nalias\nType: string | string[]\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nkeepalive\nType: boolean | KeepAliveProps\nSet to true when you want to preserve page state across route changes or use the KeepAliveProps for a fine-grained control.\n\nkey\nType: false | string | ((route: RouteLocationNormalizedLoaded) => string)\nSet key value when you need more control over when the <NuxtPage> component is re-rendered.\n\nlayout\nType: false | LayoutKey | Ref<LayoutKey> | ComputedRef<LayoutKey>\nSet a static or dynamic name of the layout for each route. This can be set to false in case the default layout needs to be disabled.\n\nlayoutTransition\nType: boolean | TransitionProps\nSet name of the transition to apply for current layout. You can also set this value to false to disable the layout transition.\n\nmiddleware\nType: MiddlewareKey | NavigationGuard | Array<MiddlewareKey | NavigationGuard>\nDefine anonymous or named middleware directly within definePageMeta. Learn more about route middleware.\n\npageTransition\nType: boolean | TransitionProps\nSet name of the transition to apply for current page. You can also set this value to false to disable the page transition.\n\nredirect\nType: RouteRecordRedirectOption\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nvalidate\nType: (route: RouteLocationNormalized) => boolean | Promise<boolean> | Partial<NuxtError> | Promise<Partial<NuxtError>>\nValidate whether a given route can validly be rendered with this page. Return true if it is valid, or false if not. If another match can't be found, this will mean a 404. You can also directly return an object with statusCode/statusMessage to respond immediately with an error (other matches will not be checked).\n\nscrollToTop\nType: boolean | (to: RouteLocationNormalized, from: RouteLocationNormalized) => boolean\nTell Nuxt to scroll to the top before rendering the page or not. If you want to overwrite the default scroll behavior of Nuxt, you can do so in ~/app/router.options.ts (see docs) for more info.\n\n[key: string]\nType: any\nApart from the above properties, you can also set custom metadata. You may wish to do so in a type-safe way by augmenting the type of the meta object.\nExamples\nBasic Usage\n\nThe example below demonstrates:\n\nhow key can be a function that returns a value;\nhow keepalive property makes sure that the <modal> component is not cached when switching between multiple components;\nadding pageType as a custom property:\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  key: (route) => route.fullPath,\n\n\n\n  keepalive: {\n\n    exclude: ['modal']\n\n  },\n\n\n\n  pageType: 'Checkout'\n\n})\n\n</script>\n\nDefining Middleware\n\nThe example below shows how the middleware can be defined using a function directly within the definePageMeta or set as a string that matches the middleware file name located in the middleware/ directory:\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  // define middleware as a function\n\n  middleware: [\n\n    function (to, from) {\n\n      const auth = useState('auth')\n\n\n\n      if (!auth.value.authenticated) {\n\n          return navigateTo('/login')\n\n      }\n\n\n\n      if (to.path !== '/checkout') {\n\n        return navigateTo('/checkout')\n\n      }\n\n    }\n\n  ],\n\n\n\n  // ... or a string\n\n  middleware: 'auth'\n\n\n\n  // ... or multiple strings\n\n  middleware: ['auth', 'another-named-middleware']\n\n})\n\n</script>\n\nDefining Layout\n\nYou can define the layout that matches the layout's file name located (by default) in the layouts/ directory. You can also disable the layout by setting the layout to false:\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  // set custom layout\n\n  layout: 'admin'\n\n\n\n  // ... or disable a default layout\n\n  layout: false\n\n})\n\n</script>\n\n\ndefineNuxtRouteMiddleware\n\nCreate named route middleware using defineNuxtRouteMiddleware helper function.\n\ndefineRouteRules\n\nDefine route rules for hybrid rendering at the page level."
  },
  {
    "title": "addRouteMiddleware · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/add-route-middleware",
    "html": "Utils\naddRouteMiddleware\nSource\n\naddRouteMiddleware() is a helper function to dynamically add middleware in your application.\n\nRoute middleware are navigation guards stored in the middleware/ directory of your Nuxt application (unless set otherwise).\nType\naddRouteMiddleware (name: string | RouteMiddleware, middleware?: RouteMiddleware, options: AddRouteMiddlewareOptions = {})\n\nParameters\nname\nType: string | RouteMiddleware\n\nCan be either a string or a function of type RouteMiddleware. Function takes the next route to as the first argument and the current route from as the second argument, both of which are Vue route objects.\n\nLearn more about available properties of route objects.\n\nmiddleware\nType: RouteMiddleware\n\nThe second argument is a function of type RouteMiddleware. Same as above, it provides to and from route objects. It becomes optional if the first argument in addRouteMiddleware() is already passed as a function.\n\noptions\nType: AddRouteMiddlewareOptions\n\nAn optional options argument lets you set the value of global to true to indicate whether the router middleware is global or not (set to false by default).\n\nExamples\nAnonymous Route Middleware\n\nAnonymous route middleware does not have a name. It takes a function as the first argument, making the second middleware argument redundant:\n\nplugins/my-plugin.ts\nexport default defineNuxtPlugin(() => {\n\n  addRouteMiddleware((to, from) => {\n\n    if (to.path === '/forbidden') {\n\n      return false\n\n    }\n\n  })\n\n})\n\nNamed Route Middleware\n\nNamed route middleware takes a string as the first argument and a function as the second.\n\nWhen defined in a plugin, it overrides any existing middleware of the same name located in the middleware/ directory:\n\nplugins/my-plugin.ts\nexport default defineNuxtPlugin(() => {\n\n  addRouteMiddleware('named-middleware', () => {\n\n    console.log('named middleware added in Nuxt plugin')\n\n  })\n\n})\n\nGlobal Route Middleware\n\nSet an optional, third argument { global: true } to indicate whether the route middleware is global:\n\nplugins/my-plugin.ts\nexport default defineNuxtPlugin(() => {\n\n  addRouteMiddleware('global-middleware', (to, from) => {\n\n      console.log('global middleware that runs on every route change')\n\n    },\n\n    { global: true }\n\n  )\n\n})\n\n\nabortNavigation\n\nabortNavigation is a helper function that prevents navigation from taking place and throws an error if one is set as a parameter.\n\nclearError\n\nThe clearError composable clears all handled errors."
  },
  {
    "title": "abortNavigation · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/abort-navigation",
    "html": "Utils\nabortNavigation\nSource\n\nabortNavigation is a helper function that prevents navigation from taking place and throws an error if one is set as a parameter.\n\nabortNavigation is only usable inside a route middleware handler.\nType\nabortNavigation(err?: Error | string): false\n\nParameters\nerr\nType: Error | string\nOptional error to be thrown by abortNavigation.\nExamples\n\nThe example below shows how you can use abortNavigation in a route middleware to prevent unauthorized route access:\n\nmiddleware/auth.ts\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  const user = useState('user')\n\n\n\n  if (!user.value.isAuthorized) {\n\n    return abortNavigation()\n\n  }\n\n \n\n  if (to.path !== '/edit-post') {\n\n    return navigateTo('/edit-post')\n\n  }\n\n})\n\nerr as a String\n\nYou can pass the error as a string:\n\nmiddleware/auth.ts\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  const user = useState('user')\n\n\n\n  if (!user.value.isAuthorized) {\n\n    return abortNavigation('Insufficient permissions.')\n\n  }\n\n})\n\nerr as an Error Object\n\nYou can pass the error as an Error object, e.g. caught by the catch-block:\n\nmiddleware/auth.ts\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  try {\n\n    /* code that might throw an error */\n\n  } catch (err) {\n\n    return abortNavigation(err)\n\n  }\n\n})\n\n\n$fetch\n\nNuxt uses ofetch to expose globally the $fetch helper for making HTTP requests.\n\naddRouteMiddleware\n\naddRouteMiddleware() is a helper function to dynamically add middleware in your application."
  },
  {
    "title": "$fetch · Nuxt Utils",
    "url": "https://nuxt.com/docs/api/utils/dollarfetch",
    "html": "Utils\n$fetch\nSource\n\nNuxt uses ofetch to expose globally the $fetch helper for making HTTP requests.\n\nNuxt uses ofetch to expose globally the $fetch helper for making HTTP requests within your Vue app or API routes.\n\nDuring server-side rendering, calling $fetch to fetch your internal API routes will directly call the relevant function (emulating the request), saving an additional API call.\nUsing $fetch in components without wrapping it with useAsyncData causes fetching the data twice: initially on the server, then again on the client-side during hydration, because $fetch does not transfer state from the server to the client. Thus, the fetch will be executed on both sides because the client has to get the data again.\n\nWe recommend to use useFetch or useAsyncData + $fetch to prevent double data fetching when fetching the component data.\n\napp.vue\n<script setup lang=\"ts\">\n\n// During SSR data is fetched twice, once on the server and once on the client.\n\nconst dataTwice = await $fetch('/api/item')\n\n\n\n// During SSR data is fetched only on the server side and transferred to the client.\n\nconst { data } = await useAsyncData('item', () => $fetch('/api/item'))\n\n\n\n// You can also useFetch as shortcut of useAsyncData + $fetch\n\nconst { data } = await useFetch('/api/item')\n\n</script>\n\n Read more in Docs > Getting Started > Data Fetching.\n\nYou can use $fetch for any method that are executed only on client-side.\n\npages/contact.vue\n<script setup lang=\"ts\">\n\nfunction contactForm() {\n\n  $fetch('/api/contact', {\n\n    method: 'POST',\n\n    body: { hello: 'world '}\n\n  })\n\n}\n\n</script>\n\n\n\n<template>\n\n  <button @click=\"contactForm\">Contact</button>\n\n</template>\n\n$fetch is the preferred way to make HTTP calls in Nuxt instead of @nuxt/http and @nuxtjs/axios that are made for Nuxt 2.\n\nuseState\n\nThe useState composable creates a reactive and SSR-friendly shared state.\n\nabortNavigation\n\nabortNavigation is a helper function that prevents navigation from taking place and throws an error if one is set as a parameter."
  },
  {
    "title": "useState · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-state",
    "html": "Composables\nuseState\nSource\n\nThe useState composable creates a reactive and SSR-friendly shared state.\n\nUsage\n// Create a reactive state and set default value\n\nconst count = useState('counter', () => Math.round(Math.random() * 100))\n\n Read more in Docs > Getting Started > State Management.\nBecause the data inside useState will be serialized to JSON, it is important that it does not contain anything that cannot be serialized, such as classes, functions or symbols.\nuseState is a reserved function name transformed by the compiler, so you should not name your own function useState.\nUsing shallowRef\n\nIf you don't need your state to be deeply reactive, you can combine useState with shallowRef. This can improve performance when your state contains large objects and arrays.\n\nconst state = useState('my-shallow-state', () => shallowRef({ deep: 'not reactive' }))\n\n// isShallow(state) === true\n\nType\nuseState<T>(init?: () => T | Ref<T>): Ref<T>\n\nuseState<T>(key: string, init?: () => T | Ref<T>): Ref<T>\n\nkey: A unique key ensuring that data fetching is properly de-duplicated across requests. If you do not provide a key, then a key that is unique to the file and line number of the instance of useState will be generated for you.\ninit: A function that provides initial value for the state when not initiated. This function can also return a Ref.\nT: (typescript only) Specify the type of state\n\nuseServerSeoMeta\n\nThe useServerSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.\n\n$fetch\n\nNuxt uses ofetch to expose globally the $fetch helper for making HTTP requests."
  },
  {
    "title": "useRuntimeConfig · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-runtime-config",
    "html": "Composables\nuseRuntimeConfig\nSource\n\nAccess runtime config variables with the useRuntimeConfig composable.\n\nUsage\napp.vue\n<script setup lang=\"ts\">\n\nconst config = useRuntimeConfig()\n\n</script>\n\nserver/api/foo.ts\nexport default defineEventHandler((event) => {\n\n  const config = useRuntimeConfig(event)\n\n})\n\n Read more in Docs > Guide > Going Further > Runtime Config.\nDefine Runtime Config\n\nThe example below shows how to set a public API base URL and a secret API token that is only accessible on the server.\n\nWe should always define runtimeConfig variables inside nuxt.config.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  runtimeConfig: {\n\n    // Private keys are only available on the server\n\n    apiSecret: '123',\n\n\n\n    // Public keys that are exposed to the client\n\n    public: {\n\n      apiBase: process.env.NUXT_PUBLIC_API_BASE || '/api'\n\n    }\n\n  }\n\n})\n\nVariables that need to be accessible on the server are added directly inside runtimeConfig. Variables that need to be accessible on both the client and the server are defined in runtimeConfig.public.\n Read more in Docs > Guide > Going Further > Runtime Config.\nAccess Runtime Config\n\nTo access runtime config, we can use useRuntimeConfig() composable:\n\nserver/api/test.ts\nexport default defineEventHandler((event) => {\n\n  const config = useRuntimeConfig(event)\n\n\n\n  // Access public variables\n\n  const result = await $fetch(`/test`, {\n\n    baseURL: config.public.apiBase,\n\n    headers: {\n\n      // Access a private variable (only available on the server)\n\n      Authorization: `Bearer ${config.apiSecret}`\n\n    }\n\n  })\n\n  return result\n\n}\n\n\nIn this example, since apiBase is defined within the public namespace, it is universally accessible on both server and client-side, while apiSecret is only accessible on the server-side.\n\nEnvironment Variables\n\nIt is possible to update runtime config values using a matching environment variable name prefixed with NUXT_.\n\n Read more in Docs > Guide > Going Further > Runtime Config.\nUsing the .env File\n\nWe can set the environment variables inside the .env file to make them accessible during development and build/generate.\n\n.env\nNUXT_PUBLIC_API_BASE = \"https://api.localhost:5555\"\nNUXT_API_SECRET = \"123\"\n\nAny environment variables set within .env file are accessed using process.env in the Nuxt app during development and build/generate.\nIn production runtime, you should use platform environment variables and .env is not used.\n Read more in Docs > Guide > Directory Structure > Env.\napp namespace\n\nNuxt uses app namespace in runtime-config with keys including baseURL and cdnURL. You can customize their values at runtime by setting environment variables.\n\nThis is a reserved namespace. You should not introduce additional keys inside app.\napp.baseURL\n\nBy default, the baseURL is set to '/'.\n\nHowever, the baseURL can be updated at runtime by setting the NUXT_APP_BASE_URL as an environment variable.\n\nThen, you can access this new base URL using config.app.baseURL:\n\n/plugins/my-plugin.ts\nexport default defineNuxtPlugin((NuxtApp) => {\n\n  const config = useRuntimeConfig()\n\n\n\n  // Access baseURL universally\n\n  const baseURL = config.app.baseURL\n\n})\n\napp.cdnURL\n\nThis example shows how to set a custom CDN url and access them using useRuntimeConfig().\n\nYou can use a custom CDN for serving static assets inside .output/public using the NUXT_APP_CDN_URL environment variable.\n\nAnd then access the new CDN url using config.app.cdnURL.\n\nserver/api/foo.ts\nexport default defineEventHandler((event) => {\n\n  const config = useRuntimeConfig()\n\n\n\n  // Access cdnURL universally\n\n  const cdnURL = config.app.cdnURL\n\n})\n\n Read more in Docs > Guide > Going Further > Runtime Config.\n\nuseRouter\n\nThe useRouter composable returns the router instance.\n\nuseSeoMeta\n\nThe useSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support."
  },
  {
    "title": "useRequestURL · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-request-url",
    "html": "Composables\nuseRequestURL\nSource\n\nAccess the incoming request URL with the useRequestURL composable.\n\nuseRequestURL is a helper function that returns an URL object working on both server-side and client-side.\n\npages/about.vue\nResult in development\n<script setup lang=\"ts\">\n\nconst url = useRequestURL()\n\n</script>\n\n\n\n<template>\n\n  <p>URL is: {{ url }}</p>\n\n  <p>Path is: {{ url.pathname }}</p>\n\n</template>\n\nRead about the URL instance properties on the MDN documentation.\n\nuseRequestHeaders\n\nUse useRequestHeaders to access the incoming request headers.\n\nuseRoute\n\nThe useRoute composable returns the current route."
  },
  {
    "title": "useRoute · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-route",
    "html": "Composables\nuseRoute\nSource\n\nThe useRoute composable returns the current route.\n\nWithin the template of a Vue component, you can access the route using $route.\nExample\n\nIn the following example, we call an API via useFetch using a dynamic page parameter - slug - as part of the URL.\n\n~/pages/[slug].vue\n<script setup lang=\"ts\">\n\nconst route = useRoute()\n\nconst { data: mountain } = await useFetch(`/api/mountains/${route.params.slug}`)\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <h1>{{ mountain.title }}</h1>\n\n    <p>{{ mountain.description }}</p>\n\n  </div>\n\n</template>\n\n\nIf you need to access the route query parameters (for example example in the path /test?example=true), then you can use useRoute().query instead of useRoute().params.\n\nAPI\n\nApart from dynamic parameters and query parameters, useRoute() also provides the following computed references related to the current route:\n\nfullPath: encoded URL associated with the current route that contains path, query and hash\nhash: decoded hash section of the URL that starts with a #\nmatched: array of normalized matched routes with current route location\nmeta: custom data attached to the record\nname: unique name for the route record\npath: encoded pathname section of the URL\nredirectedFrom: route location that was attempted to access before ending up on the current route location\n Read more in https://router.vuejs.org/api/interfaces/RouteLocationNormalizedLoaded.html.\n\nuseRequestURL\n\nAccess the incoming request URL with the useRequestURL composable.\n\nuseRouter\n\nThe useRouter composable returns the router instance."
  },
  {
    "title": "useNuxtData · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-nuxt-data",
    "html": "Composables\nuseNuxtData\nSource\n\nAccess the current cached value of data fetching composables.\n\nuseNuxtData gives you access to the current cached value of useAsyncData , useLazyAsyncData, useFetch and useLazyFetch with explicitly provided key.\nUsage\n\nThe example below shows how you can use cached data as a placeholder while the most recent data is being fetched from the server.\n\npages/posts.vue\n<script setup>\n\n// We can access same data later using 'posts' key\n\nconst { data } = await useFetch('/api/posts', { key: 'posts' })\n\n</script>\n\npages/posts/[id].vue\n// Access to the cached value of useFetch in posts.vue (parent route)\n\nconst { id } = useRoute().params\n\nconst { data: posts } = useNuxtData('posts')\n\nconst { data } = useLazyFetch(`/api/posts/${id}`, {\n\n  key: `post-${id}`,\n\n  default() {\n\n    // Find the individual post from the cache and set it as the default value.\n\n    return posts.value.find(post => post.id === id)\n\n  }\n\n})\n\nOptimistic Updates\n\nWe can leverage the cache to update the UI after a mutation, while the data is being invalidated in the background.\n\npages/todos.vue\n<script setup>\n\n// We can access same data later using 'todos' key\n\nconst { data } = await useAsyncData('todos', () => $fetch('/api/todos'))\n\n</script>\n\ncomponents/NewTodo.vue\n<script setup>\n\nconst newTodo = ref('')\n\nconst previousTodos = ref([])\n\n\n\n// Access to the cached value of useFetch in todos.vue\n\nconst { data: todos } = useNuxtData('todos')\n\n\n\nconst { data } = await useFetch('/api/addTodo', {\n\n  method: 'post',\n\n  body: {\n\n    todo: newTodo.value\n\n  },\n\n  onRequest () {\n\n    previousTodos.value = todos.value // Store the previously cached value to restore if fetch fails.\n\n\n\n    todos.value.push(newTodo.value) // Optimistically update the todos.\n\n  },\n\n  onRequestError () {\n\n    todos.value = previousTodos.value // Rollback the data if the request failed.\n\n  },\n\n  async onResponse () {\n\n    await refreshNuxtData('todos') // Invalidate todos in the background if the request succeeded.\n\n  }\n\n})\n\n</script>\n\nType\nuseNuxtData<DataT = any> (key: string): { data: Ref<DataT | null> }\n\n\nuseNuxtApp\n\nAccess the shared runtime context of the Nuxt Application.\n\nuseRequestEvent\n\nAccess the incoming request event with the useRequestEvent composable."
  },
  {
    "title": "useRequestHeaders · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-request-headers",
    "html": "Composables\nuseRequestHeaders\nSource\n\nUse useRequestHeaders to access the incoming request headers.\n\nYou can use built-in useRequestHeaders composable to access the incoming request headers within your pages, components, and plugins.\n\n// Get all request headers\n\nconst headers = useRequestHeaders()\n\n\n\n// Get only cookie request header\n\nconst headers = useRequestHeaders(['cookie'])\n\nIn the browser, useRequestHeaders will return an empty object.\nExample\n\nWe can use useRequestHeaders to access and proxy the initial request's authorization header to any future internal requests during SSR.\n\nThe example below adds the authorization request header to an isomorphic $fetch call.\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\nconst { data } = await useFetch('/api/confidential', {\n\n  headers: useRequestHeaders(['authorization'])\n\n})\n\n</script>\n\n\nuseRequestEvent\n\nAccess the incoming request event with the useRequestEvent composable.\n\nuseRequestURL\n\nAccess the incoming request URL with the useRequestURL composable."
  },
  {
    "title": "useRequestEvent · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-request-event",
    "html": "Composables\nuseRequestEvent\nSource\n\nAccess the incoming request event with the useRequestEvent composable.\n\nWithin your pages, components, and plugins you can use useRequestEvent to access the incoming request.\n\n// Get underlying request event\n\nconst event = useRequestEvent()\n\n\n\n// Get the URL\n\nconst url = event.path\n\nIn the browser, useRequestEvent will return undefined.\n\nuseNuxtData\n\nAccess the current cached value of data fetching composables.\n\nuseRequestHeaders\n\nUse useRequestHeaders to access the incoming request headers."
  },
  {
    "title": "useLazyFetch · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-lazy-fetch",
    "html": "Composables\nuseLazyFetch\nSource\n\nThis wrapper around useFetch triggers navigation immediately.\n\nDescription\n\nBy default, useFetch blocks navigation until its async handler is resolved. useLazyFetch provides a wrapper around useFetch that triggers navigation before the handler is resolved by setting the lazy option to true.\n\nuseLazyFetch has the same signature as useFetch.\n Read more in Docs > API > Composables > Use Fetch.\nExample\npages/index.vue\n<script setup lang=\"ts\">\n\n/* Navigation will occur before fetching is complete.\n\n  Handle pending and error states directly within your component's template\n\n*/\n\nconst { pending, data: posts } = await useLazyFetch('/api/posts')\n\nwatch(posts, (newPosts) => {\n\n  // Because posts might start out null, you won't have access\n\n  // to its contents immediately, but you can watch it.\n\n})\n\n</script>\n\n\n\n<template>\n\n  <div v-if=\"pending\">\n\n    Loading ...\n\n  </div>\n\n  <div v-else>\n\n    <div v-for=\"post in posts\">\n\n      <!-- do something -->\n\n    </div>\n\n  </div>\n\n</template>\n\nuseLazyFetch is a reserved function name transformed by the compiler, so you should not name your own function useLazyFetch.\n Read more in Docs > Getting Started > Data Fetching.\n\nuseLazyAsyncData\n\nThis wrapper around useAsyncData triggers navigation immediately.\n\nuseNuxtApp\n\nAccess the shared runtime context of the Nuxt Application."
  },
  {
    "title": "useLazyAsyncData · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-lazy-async-data",
    "html": "Composables\nuseLazyAsyncData\nSource\n\nThis wrapper around useAsyncData triggers navigation immediately.\n\nDescription\n\nBy default, useAsyncData blocks navigation until its async handler is resolved. useLazyAsyncData provides a wrapper around useAsyncData that triggers navigation before the handler is resolved by setting the lazy option to true.\n\nuseLazyAsyncData has the same signature as useAsyncData.\n Read more in Docs > API > Composables > Use Async Data.\nExample\npages/index.vue\n<script setup lang=\"ts\">\n\n/* Navigation will occur before fetching is complete.\n\n  Handle pending and error states directly within your component's template\n\n*/\n\nconst { pending, data: count } = await useLazyAsyncData('count', () => $fetch('/api/count'))\n\n\n\nwatch(count, (newCount) => {\n\n  // Because count might start out null, you won't have access\n\n  // to its contents immediately, but you can watch it.\n\n})\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    {{ pending ? 'Loading' : count }}\n\n  </div>\n\n</template>\n\nuseLazyAsyncData is a reserved function name transformed by the compiler, so you should not name your own function useLazyAsyncData.\n Read more in Docs > Getting Started > Data Fetching #uselazyasyncdata.\n\nuseHydration\n\nAllows full control of the hydration cycle to set and receive data from the server.\n\nuseLazyFetch\n\nThis wrapper around useFetch triggers navigation immediately."
  },
  {
    "title": "useHeadSafe · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-head-safe",
    "html": "Composables\nuseHeadSafe\nSource\n\nThe recommended way to provide head data with user input.\n\nThe useHeadSafe composable is a wrapper around the useHead composable that restricts the input to only allow safe values.\n\nUsage\n\nYou can pass all the same values as useHead\n\nuseHeadSafe({\n\n  script: [\n\n    { id: 'xss-script', innerHTML: 'alert(\"xss\")' }\n\n  ],\n\n  meta: [\n\n    { 'http-equiv': 'refresh', content: '0;javascript:alert(1)' }\n\n  ]\n\n})\n\n// Will safely generate\n\n// <script id=\"xss-script\"></script>\n\n// <meta content=\"0;javascript:alert(1)\">\n\nRead more on unhead documentation.\nType\nuseHeadSafe(input: MaybeComputedRef<HeadSafe>): void\n\n\nThe whitelist of safe values is:\n\nexport default {\n\n  htmlAttrs: ['id', 'class', 'lang', 'dir'],\n\n  bodyAttrs: ['id', 'class'],\n\n  meta: ['id', 'name', 'property', 'charset', 'content'],\n\n  noscript: ['id', 'textContent'],\n\n  script: ['id', 'type', 'textContent'],\n\n  link: ['id', 'color', 'crossorigin', 'fetchpriority', 'href', 'hreflang', 'imagesrcset', 'imagesizes', 'integrity', 'media', 'referrerpolicy', 'rel', 'sizes', 'type'],\n\n}\n\n\nSee @unhead/schema for more detailed types.\n\nuseFetch\n\nFetch data from an API endpoint with a SSR-friendly composable.\n\nuseHead\n\nuseHead customizes the head properties of individual pages of your Nuxt app."
  },
  {
    "title": "useHydration · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-hydration",
    "html": "Composables\nuseHydration\nSource\n\nAllows full control of the hydration cycle to set and receive data from the server.\n\nuseHydration is a built-in composable that provides a way to set data on the server side every time a new HTTP request is made and receive that data on the client side. This way useHydration allows you to take full control of the hydration cycle.\n\nThis is an advanced composable and is mostly used internally (useAsyncData) or by Nuxt modules.\nType\nsignature\nuseHydration <T> (key: string, get: () => T, set: (value: T) => void) => {}\n\n\nYou can use useHydration() within composables, plugins and components.\n\nuseHydration accepts three parameters:\n\nkey: unique key that identifies the data in your Nuxt application\nType: String\nget: function that returns the value to set the initial data\nType: Function\nset: function that receives the data on the client-side\nType: Function\n\nOnce the initial data is returned using the get function on the server side, you can access that data within nuxtApp.payload using the unique key that is passed as the first parameter in useHydration composable.\n\n Read more in Docs > Getting Started > Data Fetching.\n\nuseHead\n\nuseHead customizes the head properties of individual pages of your Nuxt app.\n\nuseLazyAsyncData\n\nThis wrapper around useAsyncData triggers navigation immediately."
  },
  {
    "title": "useHead · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-head",
    "html": "Composables\nuseHead\nSource\n\nuseHead customizes the head properties of individual pages of your Nuxt app.\n\nThe useHead composable function allows you to manage your head tags in a programmatic and reactive way, powered by Unhead. If the data comes from a user or other untrusted source, we recommend you check out useHeadSafe.\n\n Read more in Docs > Getting Started > Seo Meta.\nType\nuseHead(meta: MaybeComputedRef<MetaObject>): void\n\n\nBelow are the non-reactive types for useHead .\n\ninterface MetaObject {\n\n  title?: string\n\n  titleTemplate?: string | ((title?: string) => string)\n\n  base?: Base\n\n  link?: Link[]\n\n  meta?: Meta[]\n\n  style?: Style[]\n\n  script?: Script[]\n\n  noscript?: Noscript[]\n\n  htmlAttrs?: HtmlAttributes\n\n  bodyAttrs?: BodyAttributes\n\n}\n\n\nSee @unhead/schema for more detailed types.\n\nThe properties of useHead can be dynamic, accepting ref, computed and reactive properties. meta parameter can also accept a function returning an object to make the entire object reactive.\nParams\nmeta\n\nType: MetaObject\n\nAn object accepting the following head metadata:\n\nmeta: Each element in the array is mapped to a newly-created <meta> tag, where object properties are mapped to the corresponding attributes.\nType: Array<Record<string, any>>\nlink: Each element in the array is mapped to a newly-created <link> tag, where object properties are mapped to the corresponding attributes.\nType: Array<Record<string, any>>\nstyle: Each element in the array is mapped to a newly-created <style> tag, where object properties are mapped to the corresponding attributes.\nType: Array<Record<string, any>>\nscript: Each element in the array is mapped to a newly-created <script> tag, where object properties are mapped to the corresponding attributes.\nType: Array<Record<string, any>>\nnoscript: Each element in the array is mapped to a newly-created <noscript> tag, where object properties are mapped to the corresponding attributes.\nType: Array<Record<string, any>>\ntitleTemplate: Configures dynamic template to customize the page title on an individual page.\nType: string | ((title: string) => string)\ntitle: Sets static page title on an individual page.\nType: string\nbodyAttrs: Sets attributes of the <body> tag. Each object property is mapped to the corresponding attribute.\nType: Record<string, any>\nhtmlAttrs: Sets attributes of the <html> tag. Each object property is mapped to the corresponding attribute.\nType: Record<string, any>\n\nuseHeadSafe\n\nThe recommended way to provide head data with user input.\n\nuseHydration\n\nAllows full control of the hydration cycle to set and receive data from the server."
  },
  {
    "title": "useError · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-error",
    "html": "Composables\nuseError\nSource\n\nuseError composable returns the global Nuxt error that is being handled.\n\nThe composable returns the global Nuxt error that is being handled and it is available on both client and server.\n\nconst error = useError()\n\n\nuseError sets an error in the state and creates a reactive as well as SSR-friendly global Nuxt error across components.\n\nNuxt errors have the following properties:\n\ninterface {\n\n  //  HTTP response status code\n\n  statusCode: number\n\n  // HTTP response status message\n\n  statusMessage: string\n\n  // Error message\n\n  message: string\n\n}\n\n Read more in Docs > Getting Started > Error Handling.\n\nuseCookie\n\nuseCookie is an SSR-friendly composable to read and write cookies.\n\nuseFetch\n\nFetch data from an API endpoint with a SSR-friendly composable."
  },
  {
    "title": "useFetch · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-fetch",
    "html": "Composables\nuseFetch\nSource\n\nFetch data from an API endpoint with a SSR-friendly composable.\n\nThis composable provides a convenient wrapper around useAsyncData and $fetch. It automatically generates a key based on URL and fetch options, provides type hints for request url based on server routes, and infers API response type.\n\nuseFetch is a composable meant to be called directly in a setup function, plugin, or route middleware. It returns reactive composables and handles adding responses to the Nuxt payload so they can be passed from server to client without re-fetching the data on client side when the page hydrates.\nUsage\npages/index.vue\n<script setup>\n\nconst route = useRoute()\n\n\n\nconst { data, pending, error, refresh } = await useFetch(`https://api.nuxtjs.dev/mountains/${route.params.slug}`, {\n\n  pick: ['title']\n\n})\n\n</script>\n\n\nUsing the query option, you can add search parameters to your query. This option is extended from unjs/ofetch and is using unjs/ufo to create the URL. Objects are automatically stringified.\n\nconst param1 = ref('value1')\n\nconst { data, pending, error, refresh } = await useFetch('https://api.nuxtjs.dev/mountains', {\n\n  query: { param1, param2: 'value2' }\n\n})\n\n\nThe above example results in https://api.nuxtjs.dev/mountains?param1=value1&param2=value2.\n\nYou can also use interceptors:\n\nconst { data, pending, error, refresh } = await useFetch('/api/auth/login', {\n\n  onRequest({ request, options }) {\n\n    // Set the request headers\n\n    options.headers = options.headers || {}\n\n    options.headers.authorization = '...'\n\n  },\n\n  onRequestError({ request, options, error }) {\n\n    // Handle the request errors\n\n  },\n\n  onResponse({ request, response, options }) {\n\n    // Process the response data\n\n    localStorage.setItem('token', response._data.token)\n\n  },\n\n  onResponseError({ request, response, options }) {\n\n    // Handle the response errors\n\n  }\n\n})\n\nuseFetch is a reserved function name transformed by the compiler, so you should not name your own function useFetch.\n Read and edit a live example in Docs > Examples > Advanced > Use Custom Fetch Composable.\n Read more in Docs > Getting Started > Data Fetching.\n Read and edit a live example in Docs > Examples > Features > Data Fetching.\nParams\nURL: The URL to fetch.\nOptions (extends unjs/ofetch options & AsyncDataOptions):\nmethod: Request method.\nquery: Adds query search params to URL using ufo\nparams: Alias for query\nbody: Request body - automatically stringified (if an object is passed).\nheaders: Request headers.\nbaseURL: Base URL for the request.\ntimeout: Milliseconds to automatically abort request\nAll fetch options can be given a computed or ref value. These will be watched and new requests made automatically with any new values if they are updated.\nOptions (from useAsyncData):\nkey: a unique key to ensure that data fetching can be properly de-duplicated across requests, if not provided, it will be automatically generated based on URL and fetch options\nserver: whether to fetch the data on the server (defaults to true)\nlazy: whether to resolve the async function after loading the route, instead of blocking client-side navigation (defaults to false)\nimmediate: when set to false, will prevent the request from firing immediately. (defaults to true)\ndefault: a factory function to set the default value of the data, before the async function resolves - useful with the lazy: true or immediate: false option\ntransform: a function that can be used to alter handler function result after resolving\npick: only pick specified keys in this array from the handler function result\nwatch: watch an array of reactive sources and auto-refresh the fetch result when they change. Fetch options and URL are watched by default. You can completely ignore reactive sources by using watch: false. Together with immediate: false, this allows for a fully-manual useFetch.\ndeep: return data in a deep ref object (it is true by default). It can be set to false to return data in a shallow ref object, which can improve performance if your data does not need to be deeply reactive.\nIf you provide a function or ref as the url parameter, or if you provide functions as arguments to the options parameter, then the useFetch call will not match other useFetch calls elsewhere in your codebase, even if the options seem to be identical. If you wish to force a match, you may provide your own key in options.\nReturn Values\ndata: the result of the asynchronous function that is passed in.\npending: a boolean indicating whether the data is still being fetched.\nrefresh/execute: a function that can be used to refresh the data returned by the handler function.\nerror: an error object if the data fetching failed.\nstatus: a string indicating the status of the data request (\"idle\", \"pending\", \"success\", \"error\").\n\nBy default, Nuxt waits until a refresh is finished before it can be executed again.\n\nIf you have not fetched data on the server (for example, with server: false), then the data will not be fetched until hydration completes. This means even if you await useFetch on client-side, data will remain null within <script setup>.\nType\nSignature\nfunction useFetch<DataT, ErrorT>(\n\n  url: string | Request | Ref<string | Request> | () => string | Request,\n\n  options?: UseFetchOptions<DataT>\n\n): Promise<AsyncData<DataT, ErrorT>>\n\n\n\ntype UseFetchOptions<DataT> = {\n\n  key?: string\n\n  method?: string\n\n  query?: SearchParams\n\n  params?: SearchParams\n\n  body?: RequestInit['body'] | Record<string, any>\n\n  headers?: Record<string, string> | [key: string, value: string][] | Headers\n\n  baseURL?: string\n\n  server?: boolean\n\n  lazy?: boolean\n\n  immediate?: boolean\n\n  getCachedData?: (key: string) => DataT\n\n  deep?: boolean\n\n  default?: () => DataT\n\n  transform?: (input: DataT) => DataT\n\n  pick?: string[]\n\n  watch?: WatchSource[] | false\n\n}\n\n\n\ntype AsyncData<DataT, ErrorT> = {\n\n  data: Ref<DataT | null>\n\n  pending: Ref<boolean>\n\n  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>\n\n  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>\n\n  error: Ref<ErrorT | null>\n\n  status: Ref<AsyncDataRequestStatus>\n\n}\n\n\n\ninterface AsyncDataExecuteOptions {\n\n  dedupe?: boolean\n\n}\n\n\n\ntype AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'\n\n\nuseError\n\nuseError composable returns the global Nuxt error that is being handled.\n\nuseHeadSafe\n\nThe recommended way to provide head data with user input."
  },
  {
    "title": "useCookie · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-cookie",
    "html": "Composables\nuseCookie\nSource\n\nuseCookie is an SSR-friendly composable to read and write cookies.\n\nWithin your pages, components and plugins you can use useCookie, an SSR-friendly composable to read and write cookies.\n\nconst cookie = useCookie(name, options)\n\nuseCookie ref will automatically serialize and deserialize cookie value to JSON.\nExample\n\nThe example below creates a cookie called counter. If the cookie doesn't exist, it is initially set to a random value. Whenever we update the counter variable, the cookie will be updated accordingly.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst counter = useCookie('counter')\n\n\n\ncounter.value = counter.value || Math.round(Math.random() * 1000)\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <h1>Counter: {{ counter || '-' }}</h1>\n\n    <button @click=\"counter = null\">reset</button>\n\n    <button @click=\"counter--\">-</button>\n\n    <button @click=\"counter++\">+</button>\n\n  </div>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Advanced > Use Cookie.\nOptions\n\nCookie composable accepts several options which let you modify the behavior of cookies.\n\nMost of the options will be directly passed to the cookie package.\n\nmaxAge / expires\n\nUse these options to set the expiration of the cookie.\n\nmaxAge: Specifies the number (in seconds) to be the value for the Max-Age Set-Cookie attribute. The given number will be converted to an integer by rounding down. By default, no maximum age is set.\n\nexpires: Specifies the Date object to be the value for the Expires Set-Cookie attribute. By default, no expiration is set. Most clients will consider this a \"non-persistent cookie\" and will delete it on a condition like exiting a web browser application.\n\nThe cookie storage model specification states that if both expires and maxAge is set, then maxAge takes precedence, but not all clients may obey this, so if both are set, they should point to the same date and time!\nIf neither of expires and maxAge is set, the cookie will be session-only and removed when the user closes their browser.\nhttpOnly\n\nSpecifies the boolean value for the HttpOnly Set-Cookie attribute. When truthy, the HttpOnly attribute is set; otherwise it is not. By default, the HttpOnly attribute is not set.\n\nBe careful when setting this to true, as compliant clients will not allow client-side JavaScript to see the cookie in document.cookie.\nsecure\n\nSpecifies the boolean value for the Secure Set-Cookie attribute. When truthy, the Secure attribute is set; otherwise it is not. By default, the Secure attribute is not set.\n\nBe careful when setting this to true, as compliant clients will not send the cookie back to the server in the future if the browser does not have an HTTPS connection. This can lead to hydration errors.\ndomain\n\nSpecifies the value for the Domain Set-Cookie attribute. By default, no domain is set, and most clients will consider applying the cookie only to the current domain.\n\npath\n\nSpecifies the value for the Path Set-Cookie attribute. By default, the path is considered the \"default path\".\n\nsameSite\n\nSpecifies the boolean or string value for the SameSite Set-Cookie attribute.\n\ntrue will set the SameSite attribute to Strict for strict same-site enforcement.\nfalse will not set the SameSite attribute.\n'lax' will set the SameSite attribute to Lax for lax same-site enforcement.\n'none' will set the SameSite attribute to None for an explicit cross-site cookie.\n'strict' will set the SameSite attribute to Strict for strict same-site enforcement.\n\nMore information about the different enforcement levels can be found in the specification.\n\nencode\n\nSpecifies a function that will be used to encode a cookie's value. Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to encode a value into a string suited for a cookie's value.\n\nThe default encoder is the JSON.stringify + encodeURIComponent.\n\ndecode\n\nSpecifies a function that will be used to decode a cookie's value. Since the value of a cookie has a limited character set (and must be a simple string), this function can be used to decode a previously encoded cookie value into a JavaScript string or other object.\n\nThe default decoder is decodeURIComponent + destr.\n\nIf an error is thrown from this function, the original, non-decoded cookie value will be returned as the cookie's value.\ndefault\n\nSpecifies a function that returns the cookie's default value. The function can also return a Ref.\n\nreadonly\n\nAllows accessing a cookie value without the ability to set it.\n\nwatch\n\nSpecifies the boolean or string value for watch cookie ref data.\n\ntrue - Will watch cookie ref data changes and its nested properties (default).\nshallow - Will watch cookie ref data changes for only top level properties\nfalse - Will not watch cookie ref data changes.\n\nExample 1:\n\n<script setup lang=\"ts\">\n\nconst user = useCookie(\n\n  'userInfo',\n\n  {\n\n    default: () => ({ score: -1 }),\n\n    watch: false\n\n  }\n\n)\n\n\n\nif (user.value && user.value !== null) {\n\n  user.value.score++; // userInfo cookie not update with this change\n\n}\n\n</script>\n\n\n\n<template>\n\n  <div>User score: {{ user?.score }}</div>\n\n</template>\n\n\nExample 2:\n\n<script setup lang=\"ts\">\n\nconst list = useCookie(\n\n  'list',\n\n  {\n\n    default: () => [],\n\n    watch: 'shallow'\n\n  }\n\n)\n\n\n\nfunction add() {\n\n  list.value?.push(Math.round(Math.random() * 1000))\n\n  // list cookie not update with this change\n\n}\n\n\n\nfunction save() {\n\n  if (list.value && list.value !== null) {\n\n    list.value = [...list.value]\n\n    // list cookie update with this change\n\n  }\n\n}\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <h1>List</h1>\n\n    <pre>{{ list }}</pre>\n\n    <button @click=\"add\">Add</button>\n\n    <button @click=\"save\">Save</button>\n\n  </div>\n\n</template>\n\nCookies in API Routes\n\nYou can use getCookie and setCookie from h3 package to set cookies in server API routes.\n\nserver/api/counter.ts\nexport default defineEventHandler(event => {\n\n  // Read counter cookie\n\n  let counter = getCookie(event, 'counter') || 0\n\n\n\n  // Increase counter cookie by 1\n\n  setCookie(event, 'counter', ++counter)\n\n\n\n  // Send JSON response\n\n  return { counter }\n\n})\n\n Read and edit a live example in Docs > Examples > Advanced > Use Cookie.\n\nuseAsyncData\n\nuseAsyncData provides access to data that resolves asynchronously in a SSR-friendly composable.\n\nuseError\n\nuseError composable returns the global Nuxt error that is being handled."
  },
  {
    "title": "<Teleport> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/teleports",
    "html": "Components\n<Teleport>\n\nThe <Teleport> component teleports a component to a different location in the DOM.\n\nThe to target of <Teleport> expects a CSS selector string or an actual DOM node. Nuxt currently has SSR support for teleports to body only, with client-side support for other targets using a <ClientOnly> wrapper.\nBody Teleport\n<template>\n\n  <button @click=\"open = true\">\n\n    Open Modal\n\n  </button>\n\n  <Teleport to=\"body\">\n\n    <div v-if=\"open\" class=\"modal\">\n\n      <p>Hello from the modal!</p>\n\n      <button @click=\"open = false\">\n\n        Close\n\n      </button>\n\n    </div>\n\n  </Teleport>\n\n</template>\n\nClient-side Teleport\n<template>\n\n  <ClientOnly>\n\n    <Teleport to=\"#some-selector\">\n\n      <!-- content -->\n\n    </Teleport>\n\n  </ClientOnly>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Advanced > Teleport.\n\n<NuxtPicture>\n\nNuxt provides a <NuxtPicture> component to handle automatic image optimization.\n\nuseAppConfig\n\nAccess the reactive app config defined in the project."
  },
  {
    "title": "<NuxtPicture> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-picture",
    "html": "Components\n<NuxtPicture>\nSource\n\nNuxt provides a <NuxtPicture> component to handle automatic image optimization.\n\n<NuxtPicture> is a drop-in replacement for the native <picture> tag.\n\nUsage of <NuxtPicture> is almost identical to <NuxtImg> but it also allows serving modern formats like webp when possible.\n\nLearn more about the <picture> tag on MDN.\n\nSetup\n\nIn order to use <NuxtPicture> you should install and enable the Nuxt Image module:\n\nTerminal\nnpx nuxi@latest module add image\n\nRead more about the <NuxtPicture> component.\n\n<NuxtImg>\n\nNuxt provides a <NuxtImg> component to handle automatic image optimization.\n\n<Teleport>\n\nThe <Teleport> component teleports a component to a different location in the DOM."
  },
  {
    "title": "useAsyncData · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-async-data",
    "html": "Composables\nuseAsyncData\nSource\n\nuseAsyncData provides access to data that resolves asynchronously in a SSR-friendly composable.\n\nWithin your pages, components, and plugins you can use useAsyncData to get access to data that resolves asynchronously.\n\nuseAsyncData is a composable meant to be called directly in a setup function, plugin, or route middleware. It returns reactive composables and handles adding responses to the Nuxt payload so they can be passed from server to client without re-fetching the data on client side when the page hydrates.\nUsage\npages/index.vue\n<script setup>\n\nconst { data, pending, error, refresh } = await useAsyncData(\n\n  'mountains',\n\n  () => $fetch('https://api.nuxtjs.dev/mountains')\n\n)\n\n</script>\n\nWatch Params\n\nThe built-in watch option allows automatically rerunning the fetcher function when any changes are detected.\n\npages/index.vue\n<script setup>\n\nconst page = ref(1)\n\nconst { data: posts } = await useAsyncData(\n\n  'posts',\n\n  () => $fetch('https://fakeApi.com/posts', {\n\n    params: {\n\n      page: page.value\n\n    }\n\n  }), {\n\n    watch: [page]\n\n  }\n\n)\n\n</script>\n\nuseAsyncData is a reserved function name transformed by the compiler, so you should not name your own function useAsyncData .\n Read more in Docs > Getting Started > Data Fetching #useasyncdata.\nParams\nkey: a unique key to ensure that data fetching can be properly de-duplicated across requests. If you do not provide a key, then a key that is unique to the file name and line number of the instance of useAsyncData will be generated for you.\nhandler: an asynchronous function that must return a truthy value (for example, it should not be undefined or null) or the request may be duplicated on the client side\noptions:\nserver: whether to fetch the data on the server (defaults to true)\nlazy: whether to resolve the async function after loading the route, instead of blocking client-side navigation (defaults to false)\nimmediate: when set to false, will prevent the request from firing immediately. (defaults to true)\ndefault: a factory function to set the default value of the data, before the async function resolves - useful with the lazy: true or immediate: false option\ntransform: a function that can be used to alter handler function result after resolving\npick: only pick specified keys in this array from the handler function result\nwatch: watch reactive sources to auto-refresh\ndeep: return data in a deep ref object (it is true by default). It can be set to false to return data in a shallow ref object, which can improve performance if your data does not need to be deeply reactive.\nUnder the hood, lazy: false uses <Suspense> to block the loading of the route before the data has been fetched. Consider using lazy: true and implementing a loading state instead for a snappier user experience.\nYou can use useLazyAsyncData to have the same behavior as lazy: true with useAsyncData.\nReturn Values\ndata: the result of the asynchronous function that is passed in.\npending: a boolean indicating whether the data is still being fetched.\nrefresh/execute: a function that can be used to refresh the data returned by the handler function.\nerror: an error object if the data fetching failed.\nstatus: a string indicating the status of the data request (\"idle\", \"pending\", \"success\", \"error\").\n\nBy default, Nuxt waits until a refresh is finished before it can be executed again.\n\nIf you have not fetched data on the server (for example, with server: false), then the data will not be fetched until hydration completes. This means even if you await useAsyncData on the client side, data will remain null within <script setup>.\nType\nSignature\nfunction useAsyncData<DataT, DataE>(\n\n  handler: (nuxtApp?: NuxtApp) => Promise<DataT>,\n\n  options?: AsyncDataOptions<DataT>\n\n): AsyncData<DataT, DataE>\n\nfunction useAsyncData<DataT, DataE>(\n\n  key: string,\n\n  handler: (nuxtApp?: NuxtApp) => Promise<DataT>,\n\n  options?: AsyncDataOptions<DataT>\n\n): Promise<AsyncData<DataT, DataE>\n\n\n\ntype AsyncDataOptions<DataT> = {\n\n  server?: boolean\n\n  lazy?: boolean\n\n  immediate?: boolean\n\n  deep?: boolean\n\n  default?: () => DataT | Ref<DataT> | null\n\n  transform?: (input: DataT) => DataT\n\n  pick?: string[]\n\n  watch?: WatchSource[]\n\n  getCachedData?: (key: string) => DataT\n\n}\n\n\n\ntype AsyncData<DataT, ErrorT> = {\n\n  data: Ref<DataT | null>\n\n  pending: Ref<boolean>\n\n  refresh: (opts?: AsyncDataExecuteOptions) => Promise<void>\n\n  execute: (opts?: AsyncDataExecuteOptions) => Promise<void>\n\n  error: Ref<ErrorT | null>\n\n  status: Ref<AsyncDataRequestStatus>\n\n};\n\n\n\ninterface AsyncDataExecuteOptions {\n\n  dedupe?: boolean\n\n}\n\n\n\ntype AsyncDataRequestStatus = 'idle' | 'pending' | 'success' | 'error'\n\n Read more in Docs > Getting Started > Data Fetching.\n\nuseAppConfig\n\nAccess the reactive app config defined in the project.\n\nuseCookie\n\nuseCookie is an SSR-friendly composable to read and write cookies."
  },
  {
    "title": "useAppConfig · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-app-config",
    "html": "Composables\nuseAppConfig\nSource\n\nAccess the reactive app config defined in the project.\n\nUsage\nconst appConfig = useAppConfig()\n\n\n\nconsole.log(appConfig)\n\n Read more in Docs > Guide > Directory Structure > App Config.\n\n<Teleport>\n\nThe <Teleport> component teleports a component to a different location in the DOM.\n\nuseAsyncData\n\nuseAsyncData provides access to data that resolves asynchronously in a SSR-friendly composable."
  },
  {
    "title": "<NuxtImg> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-img",
    "html": "Components\n<NuxtImg>\nSource\n\nNuxt provides a <NuxtImg> component to handle automatic image optimization.\n\n<NuxtImg> is a drop-in replacement for the native <img> tag.\n\nUses built-in provider to optimize local and remote images\nConverts src to provider-optimized URLs\nAutomatically resizes images based on width and height\nGenerates responsive sizes when providing sizes option\nSupports native lazy loading as well as other <img> attributes\nSetup\n\nIn order to use <NuxtImg> you should install and enable the Nuxt Image module:\n\nTerminal\nnpx nuxi@latest module add image\n\nUsage\n\n<NuxtImg> outputs a native img tag directly (without any wrapper around it). Use it like you would use the <img> tag:\n\n<NuxtImg src=\"/nuxt-icon.png\" />\n\n\nWill result in:\n\n<img src=\"/nuxt-icon.png\" />\n\nRead more about the <NuxtImg> component.\n\n<NuxtIsland>\n\nNuxt provides the <NuxtIsland> component to render a non-interactive component without any client JS.\n\n<NuxtPicture>\n\nNuxt provides a <NuxtPicture> component to handle automatic image optimization."
  },
  {
    "title": "<NuxtIsland> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-island",
    "html": "Components\n<NuxtIsland>\nSource\n\nNuxt provides the <NuxtIsland> component to render a non-interactive component without any client JS.\n\nWhen rendering an island component, the content of the island component is static, thus no JS is downloaded client-side.\n\nChanging the island component props triggers a refetch of the island component to re-render it again.\n\nThis component is experimental and in order to use it you must enable the experimental.componentIslands option in your nuxt.config.\nGlobal styles of your application are sent with the response.\nServer only components use <NuxtIsland> under the hood\nProps\nname : Name of the component to render.\ntype: string\nrequired\nlazy: Make the component non-blocking.\ntype: boolean\ndefault: false\nprops: Props to send to the component to render.\ntype: Record<string, any>\nsource: Remote source to call the island to render.\ntype: string\nRemote islands need experimental.componentIslands to be 'local+remote' in your nuxt.config.\nSlots\n\nSlots can be passed to an island component if declared.\n\nEvery slot is interactive since the parent component is the one providing it.\n\nSome slots are reserved to NuxtIsland for special cases.\n\n#fallback: Specify the content to be rendered before the island loads (if the component is lazy) or if NuxtIsland fails to fetch the component.\n\n<NuxtWelcome>\n\nThe <NuxtWelcome> component greets users in new projects made from the starter template.\n\n<NuxtImg>\n\nNuxt provides a <NuxtImg> component to handle automatic image optimization."
  },
  {
    "title": "<NuxtWelcome> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-welcome",
    "html": "Components\n<NuxtWelcome>\nSource\n\nThe <NuxtWelcome> component greets users in new projects made from the starter template.\n\nIt includes links to the Nuxt documentation, source code, and social media accounts.\n\napp.vue\n<template>\n\n  <NuxtWelcome />\n\n</template>\n\nPreview the <NuxtWelcome /> component.\nThis component is part of nuxt/assets.\n\n<NuxtErrorBoundary>\n\nThe <NuxtErrorBoundary> component handles client-side errors happening in its default slot.\n\n<NuxtIsland>\n\nNuxt provides the <NuxtIsland> component to render a non-interactive component without any client JS."
  },
  {
    "title": "<NuxtLayout> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-layout",
    "html": "Components\n<NuxtLayout>\nSource\n\nNuxt provides the <NuxtLayout> component to show layouts on pages and error pages.\n\nYou can use <NuxtLayout /> component to activate the default layout on app.vue or error.vue.\n\napp.vue\n<template>\n\n  <NuxtLayout>\n\n    some page content\n\n  </NuxtLayout>\n\n</template>\n\n Read more in Docs > Guide > Directory Structure > Layouts.\nProps\nname: Specify a layout name to be rendered, can be a string, reactive reference or a computed property. It must match the name of the corresponding layout file in the layouts/ directory.\ntype: string\ndefault: default\npages/index.vue\n<script setup lang=\"ts\">\n\n// layouts/custom.vue\n\nconst layout = 'custom'\n\n</script>\n\n\n\n<template>\n\n  <NuxtLayout :name=\"layout\">\n\n    <NuxtPage />\n\n  </NuxtLayout>\n\n</template>\n\nPlease note the layout name is normalized to kebab-case, so if your layout file is named errorLayout.vue, it will become error-layout when passed as a name property to <NuxtLayout />.\nerror.vue\n<template>\n\n  <NuxtLayout name=\"error-layout\">\n\n    <NuxtPage />\n\n  </NuxtLayout>\n\n</template>\n\nRead more about dynamic layouts.\nAdditional Props\n\nNuxtLayout also accepts any additional props that you may need to pass to the layout. These custom props are then made accessible as attributes.\n\npages/some-page.vue\n<template>\n\n  <div>\n\n    <NuxtLayout name=\"custom\" title=\"I am a custom layout\">\n\n      <-- ... -->\n\n    </NuxtLayout>\n\n  </div>\n\n</template>\n\n\nIn the above example, the value of title will be available using $attrs.title in the template or useAttrs().title in <script setup> at custom.vue.\n\nlayouts/custom.vue\n<script setup lang=\"ts\">\n\nconst layoutCustomProps = useAttrs()\n\n\n\nconsole.log(layoutCustomProps.title) // I am a custom layout\n\n</script>\n\nTransitions\n\n<NuxtLayout /> renders incoming content via <slot />, which is then wrapped around Vue’s <Transition /> component to activate layout transition. For this to work as expected, it is recommended that <NuxtLayout /> is not the root element of the page component.\n\npages/index.vue\n<template>\n\n  <div>\n\n    <NuxtLayout name=\"custom\">\n\n      <template #header> Some header template content. </template>\n\n    </NuxtLayout>\n\n  </div>\n\n</template>\n\n Read more in Docs > Getting Started > Transitions.\nLayout's Ref\n\nTo get the ref of a layout component, access it through ref.value.layoutRef.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst layout = ref()\n\n\n\nfunction logFoo () {\n\n  layout.value.layoutRef.foo()\n\n}\n\n</script>\n\n\n\n<template>\n\n  <NuxtLayout ref=\"layout\" />\n\n</template>\n\n Read more in Docs > Guide > Directory Structure > Layouts.\n\n<NuxtPage>\n\nThe <NuxtPage> component is required to display pages located in the pages/ directory.\n\n<NuxtLink>\n\nNuxt provides <NuxtLink> component to handle any kind of links within your application."
  },
  {
    "title": "<NuxtLink> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-link",
    "html": "Components\n<NuxtLink>\nSource\n\nNuxt provides <NuxtLink> component to handle any kind of links within your application.\n\n<NuxtLink> is a drop-in replacement for both Vue Router's <RouterLink> component and HTML's <a> tag. It intelligently determines whether the link is internal or external and renders it accordingly with available optimizations (prefetching, default attributes, etc.)\nInternal Routing\n\nIn this example, we use <NuxtLink> component to link to another page of the application.\n\npages/index.vue\n<template>\n\n  <NuxtLink to=\"/about\">\n\n    About page\n\n  </NuxtLink>\n\n  <!-- <a href=\"/about\">...</a> (+Vue Router & prefetching) -->\n\n</template>\n\nExternal Routing\n\nIn this example, we use <NuxtLink> component to link to a website.\n\napp.vue\n<template>\n\n  <NuxtLink to=\"https://nuxtjs.org\">\n\n    Nuxt website\n\n  </NuxtLink>\n\n  <!-- <a href=\"https://nuxtjs.org\" rel=\"noopener noreferrer\">...</a> -->\n\n</template>\n\ntarget and rel Attributes\n\nIn this example, we use <NuxtLink> with target, rel, and noRel props.\n\napp.vue\n<template>\n\n  <NuxtLink to=\"https://twitter.com/nuxt_js\" target=\"_blank\">\n\n    Nuxt Twitter\n\n  </NuxtLink>\n\n  <!-- <a href=\"https://twitter.com/nuxt_js\" target=\"_blank\" rel=\"noopener noreferrer\">...</a> -->\n\n\n\n  <NuxtLink to=\"https://discord.nuxtjs.org\" target=\"_blank\" rel=\"noopener\">\n\n    Nuxt Discord\n\n  </NuxtLink>\n\n  <!-- <a href=\"https://discord.nuxtjs.org\" target=\"_blank\" rel=\"noopener\">...</a> -->\n\n\n\n  <NuxtLink to=\"https://github.com/nuxt\" no-rel>\n\n    Nuxt GitHub\n\n  </NuxtLink>\n\n  <!-- <a href=\"https://github.com/nuxt\">...</a> -->\n\n\n\n  <NuxtLink to=\"/contact\" target=\"_blank\">\n\n    Contact page opens in another tab\n\n  </NuxtLink>\n\n  <!-- <a href=\"/contact\" target=\"_blank\" rel=\"noopener noreferrer\">...</a> -->\n\n</template>\n\nProps\nto: Any URL or a route location object from Vue Router\nhref: An alias for to. If used with to, href will be ignored\ntarget: A target attribute value to apply on the link\nrel: A rel attribute value to apply on the link. Defaults to \"noopener noreferrer\" for external links.\nnoRel: If set to true, no rel attribute will be added to the link\nactiveClass: A class to apply on active links. Works the same as Vue Router's active-class prop on internal links. Defaults to Vue Router's default (\"router-link-active\")\nexactActiveClass: A class to apply on exact active links. Works the same as Vue Router's exact-active-class prop on internal links. Defaults to Vue Router's default \"router-link-exact-active\")\nreplace: Works the same as Vue Router's replace prop on internal links\nariaCurrentValue: An aria-current attribute value to apply on exact active links. Works the same as Vue Router's aria-current-value prop on internal links\nexternal: Forces the link to be considered as external (true) or internal (false). This is helpful to handle edge-cases\nprefetch and noPrefetch: Whether to enable prefetching assets for links that enter the view port.\nprefetchedClass: A class to apply to links that have been prefetched.\ncustom: Whether <NuxtLink> should wrap its content in an <a> element. It allows taking full control of how a link is rendered and how navigation works when it is clicked. Works the same as Vue Router's custom prop\nDefaults can be overwritten, see overwriting defaults if you want to change them.\nOverwriting Defaults\n\nYou can overwrite <NuxtLink> defaults by creating your own link component using defineNuxtLink.\n\ncomponents/MyNuxtLink.ts\nexport default defineNuxtLink({\n\n  componentName: 'MyNuxtLink',\n\n  /* see signature below for more */\n\n})\n\n\nYou can then use <MyNuxtLink /> component as usual with your new defaults.\n\ndefineNuxtLink Signature\ndefineNuxtLink({\n\n  componentName?: string;\n\n  externalRelAttribute?: string;\n\n  activeClass?: string;\n\n  exactActiveClass?: string;\n\n  prefetchedClass?: string;\n\n  trailingSlash?: 'append' | 'remove'\n\n}) => Component\n\ncomponentName: A name for the defined <NuxtLink> component.\nexternalRelAttribute: A default rel attribute value applied on external links. Defaults to \"noopener noreferrer\". Set it to \"\" to disable\nactiveClass: A default class to apply on active links. Works the same as Vue Router's linkActiveClass option. Defaults to Vue Router's default (\"router-link-active\")\nexactActiveClass: A default class to apply on exact active links. Works the same as Vue Router's linkExactActiveClass option. Defaults to Vue Router's default (\"router-link-exact-active\")\nprefetchedClass: A default class to apply to links that have been prefetched.\ntrailingSlash: An option to either add or remove trailing slashes in the href. If unset or not matching the valid values append or remove, it will be ignored.\n Read and edit a live example in Docs > Examples > Routing > Pages.\n\n<NuxtLayout>\n\nNuxt provides the <NuxtLayout> component to show layouts on pages and error pages.\n\n<NuxtLoadingIndicator>\n\nDisplay a progress bar between page navigations."
  },
  {
    "title": "<NuxtErrorBoundary> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-error-boundary",
    "html": "Components\n<NuxtErrorBoundary>\nSource\n\nThe <NuxtErrorBoundary> component handles client-side errors happening in its default slot.\n\nThe <NuxtErrorBoundary> uses Vue's onErrorCaptured hook under the hood.\nEvents\n@error: Event emitted when the default slot of the component throws an error.\n<template>\n\n  <NuxtErrorBoundary @error=\"logSomeError\">\n\n    <!-- ... -->\n\n  </NuxtErrorBoundary>\n\n</template>\n\nSlots\n#error: Specify a fallback content to display in case of error.\n  <template>\n\n    <NuxtErrorBoundary>\n\n      <!-- ... -->\n\n      <template #error=\"{ error }\">\n\n        <p>An error occurred: {{ error }}</p>\n\n      </template>\n\n    </NuxtErrorBoundary>\n\n  </template>\n\n Read more in Docs > Getting Started > Error Handling.\n\n<NuxtLoadingIndicator>\n\nDisplay a progress bar between page navigations.\n\n<NuxtWelcome>\n\nThe <NuxtWelcome> component greets users in new projects made from the starter template."
  },
  {
    "title": "<NuxtLoadingIndicator> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-loading-indicator",
    "html": "Components\n<NuxtLoadingIndicator>\nSource\n\nDisplay a progress bar between page navigations.\n\nUsage\n\nAdd <NuxtLoadingIndicator/> in your app.vue or layouts/.\n\napp.vue\n<template>\n\n  <NuxtLayout>\n\n    <div>\n\n      <NuxtLoadingIndicator /> <!-- here -->\n\n      <NuxtPage />\n\n    </div>\n\n  </NuxtLayout>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Routing > Pages.\nSlots\n\nYou can pass custom HTML or components through the loading indicator's default slot.\n\nProps\ncolor: The color of the loading bar. It can be set to false to turn off explicit color styling.\nheight: Height of the loading bar, in pixels (default 3).\nduration: Duration of the loading bar, in milliseconds (default 2000).\nthrottle: Throttle the appearing and hiding, in milliseconds (default 200).\nThis component is optional.\nTo achieve full customization, you can implement your own one based on its source code.\n\n<NuxtLink>\n\nNuxt provides <NuxtLink> component to handle any kind of links within your application.\n\n<NuxtErrorBoundary>\n\nThe <NuxtErrorBoundary> component handles client-side errors happening in its default slot."
  },
  {
    "title": "<NuxtPage> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-page",
    "html": "Components\n<NuxtPage>\nSource\n\nThe <NuxtPage> component is required to display pages located in the pages/ directory.\n\n<NuxtPage> is a built-in component that comes with Nuxt. It lets you display top-level or nested pages located in the pages/ directory.\n\n<NuxtPage> is a wrapper around <RouterView> component from Vue Router.\nIt accepts same name and route props.\nProps\nname: tells RouterView to render the component with the corresponding name in the matched route record's components option.\ntype: string\nroute: route location that has all of its components resolved.\ntype: RouteLocationNormalized\npageKey: control when the NuxtPage component is re-rendered.\ntype: string or function\nNuxt automatically resolves the name and route by scanning and rendering all Vue component files found in the /pages directory.\nExample\n\nFor example, passing static key, NuxtPage component is rendered only once when it is mounted.\n\napp.vue\n<template>\n\n  <NuxtPage page-key=\"static\" />\n\n</template>\n\n\nYou can also use a dynamic key based on the current route:\n\n<NuxtPage :page-key=\"route => route.fullPath\" />\n\nDon't use $route object here as it can cause problems with how <NuxtPage> renders pages with <Suspense>.\n\nAlternatively, pageKey can be passed as a key value via definePageMeta from the <script> section of your Vue component in the /pages directory.\n\npages/my-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  key: route => route.fullPath\n\n})\n\n</script>\n\n Read and edit a live example in Docs > Examples > Routing > Pages.\nPage's Ref\n\nTo get the ref of a page component, access it through ref.value.pageRef\n\napp.vue\n<script setup lang=\"ts\">\n\nconst page = ref()\n\n\n\nfunction logFoo () {\n\n  page.value.pageRef.foo()\n\n}\n\n</script>\n\n\n\n<template>\n\n  <NuxtPage ref=\"page\" />\n\n</template>\n\nCustom Props\n\nIn addition, <NuxtPage> also accepts custom props that you may need to pass further down the hierarchy.\n\nThese custom props are accessible via attrs in the Nuxt app.\n\n<NuxtPage :foobar=\"123\" />\n\n\nFor example, in the above example, the value of foobar will be available using $attrs.foobar in the template or useAttrs().foobar in <script setup>.\n\n Read more in Docs > Guide > Directory Structure > Pages.\n\n<NuxtClientFallback>\n\nNuxt provides the <NuxtClientFallback> component to render its content on the client if any of its children trigger an error in SSR\n\n<NuxtLayout>\n\nNuxt provides the <NuxtLayout> component to show layouts on pages and error pages."
  },
  {
    "title": "<NuxtClientFallback> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/nuxt-client-fallback",
    "html": "Components\n<NuxtClientFallback>\nSource (client)\nSource (server)\n\nNuxt provides the <NuxtClientFallback> component to render its content on the client if any of its children trigger an error in SSR\n\nThis component is experimental and in order to use it you must enable the experimental.clientFallback option in your nuxt.config.\nEvents\n@ssr-error: Event emitted when a child triggers an error in SSR. Note that this will only be triggered on the server.\n<template>\n\n  <NuxtClientFallback @ssr-error=\"logSomeError\">\n\n    <!-- ... -->\n\n  </NuxtClientFallback>\n\n</template>\n\nProps\nplaceholderTag | fallbackTag: Specify a fallback tag to be rendered if the slot fails to render.\ntype: string\ndefault: div\nplaceholder | fallback: Specify fallback content to be rendered if the slot fails to render.\ntype: string\nkeepFallback: Keep the fallback content if it failed to render server-side.\ntype: boolean\ndefault: false\n  <template>\n\n    <!-- render <span>Hello world</span> server-side if the default slot fails to render -->\n\n    <NuxtClientFallback fallback-tag=\"span\" fallback=\"Hello world\">\n\n      <BrokeInSsr />\n\n    </NuxtClientFallback>\n\n  </template>\n\nSlots\n#fallback: specify content to be displayed server-side if the slot fails to render.\n<template>\n\n  <NuxtClientFallback>\n\n    <!-- ... -->\n\n    <template #fallback>\n\n      <!-- this will be rendered on server side if the default slot fails to render in ssr -->\n\n      <p>Hello world</p>\n\n    </template>\n\n  </NuxtClientFallback>\n\n</template>\n\n\n<ClientOnly>\n\nRender components only in client-side with the <ClientOnly> component.\n\n<NuxtPage>\n\nThe <NuxtPage> component is required to display pages located in the pages/ directory."
  },
  {
    "title": "Migrate to Nuxt 3: Modules",
    "url": "https://nuxt.com/docs/migration/module-authors",
    "html": "Upgrade Guide\nMigrate to Nuxt 3\nModules\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 modules.\n\nModule Compatibility\n\nNuxt 3 has a basic backward compatibility layer for Nuxt 2 modules using @nuxt/kit auto wrappers. But there are usually steps to follow to make modules compatible with Nuxt 3 and sometimes, using Nuxt Bridge is required for cross-version compatibility.\n\nWe have prepared a Dedicated Guide for authoring Nuxt 3 ready modules using @nuxt/kit. Currently best migration path is to follow it and rewrite your modules. Rest of this guide includes preparation steps if you prefer to avoid a full rewrite yet making modules compatible with Nuxt 3.\n\nExplore Nuxt 3 compatible modules.\nPlugin Compatibility\n\nNuxt 3 plugins are not fully backward compatible with Nuxt 2.\n\n Read more in Docs > Guide > Directory Structure > Plugins.\nVue Compatibility\n\nPlugins or components using the Composition API need exclusive Vue 2 or Vue 3 support.\n\nBy using vue-demi they should be compatible with both Nuxt 2 and 3.\n\nModule Migration\n\nWhen Nuxt 3 users add your module, you will not have access to the module container (this.*) so you will need to use utilities from @nuxt/kit to access the container functionality.\n\nTest with @nuxt/bridge\n\nMigrating to @nuxt/bridge is the first and most important step for supporting Nuxt 3.\n\nIf you have a fixture or example in your module, add @nuxt/bridge package to its config (see example)\n\nMigrate from CommonJS to ESM\n\nNuxt 3 natively supports TypeScript and ECMAScript Modules. Please check Native ES Modules for more info and upgrading.\n\nEnsure Plugins Default Export\n\nIf you inject a Nuxt plugin that does not have export default (such as global Vue plugins), ensure you add export default () => { } to the end of it.\n\nBefore\nAfter\n// ~/plugins/vuelidate.js\n\nimport Vue from 'vue'\n\nimport Vuelidate from 'vuelidate'\n\n\n\nVue.use(Vuelidate)\n\nAvoid Runtime Modules\n\nWith Nuxt 3, Nuxt is now a build-time-only dependency, which means that modules shouldn't attempt to hook into the Nuxt runtime.\n\nYour module should work even if it's only added to buildModules (instead of modules). For example:\n\nAvoid updating process.env within a Nuxt module and reading by a Nuxt plugin; use runtimeConfig instead.\n(*) Avoid depending on runtime hooks like vue-renderer:* for production\n(*) Avoid adding serverMiddleware by importing them inside the module. Instead, add them by referencing a file path so that they are independent of the module's context\n\n(*) Unless it is for nuxt dev purpose only and guarded with if (nuxt.options.dev) { }.\n\nContinue reading about Nuxt 3 modules in the Modules Author Guide.\nUse TypeScript (Optional)\n\nWhile it is not essential, most of the Nuxt ecosystem is shifting to use TypeScript, so it is highly recommended to consider migration.\n\nYou can start migration by renaming .js files, to .ts. TypeScript is designed to be progressive!\nYou can use TypeScript syntax for Nuxt 2 and 3 modules and plugins without any extra dependencies.\n\nServer\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 server.\n\nHello World\n\nA minimal Nuxt 3 application only requires the `app.vue` and `nuxt.config.js` files."
  },
  {
    "title": "WASM · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/experimental/wasm",
    "html": "Examples\nExperimental\nWASM\n\nThis example demonstrates the server-side support of WebAssembly in Nuxt 3.\n\nLoading Sandbox...\n\nUse Custom Fetch Composable\n\nThis example shows a convenient wrapper for the useFetch composable from nuxt. It allows you to customize the fetch request with default values and user authentication token."
  },
  {
    "title": "<ClientOnly> · Nuxt Components",
    "url": "https://nuxt.com/docs/api/components/client-only",
    "html": "Components\n<ClientOnly>\nSource\n\nRender components only in client-side with the <ClientOnly> component.\n\nThe <ClientOnly> component renders its slot only in client-side. To import a component only on the client, register the component in a client-side only plugin.\n\nProps\nplaceholderTag | fallbackTag: specify a tag to be rendered server-side.\nplaceholder | fallback: specify a content to be rendered server-side.\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <ClientOnly fallback-tag=\"span\" fallback=\"Loading comments...\">\n\n      <Comment />\n\n    </ClientOnly>\n\n  </div>\n\n</template>\n\nSlots\n#fallback: specify a content to be displayed server-side.\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <ClientOnly>\n\n      <!-- ... -->\n\n      <template #fallback>\n\n        <!-- this will be rendered on server side -->\n\n        <p>Loading comments...</p>\n\n      </template>\n\n    </ClientOnly>\n\n  </div>\n\n</template>\n\n\nNightly Release Channel\n\nThe nightly release channel allows using Nuxt built directly from the latest commits to the repository.\n\n<NuxtClientFallback>\n\nNuxt provides the <NuxtClientFallback> component to render its content on the client if any of its children trigger an error in SSR"
  },
  {
    "title": "useCookie · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/use-cookie",
    "html": "Examples\nAdvanced\nuseCookie\n\nThis example shows how to use the useCookie API to persist small amounts of data that both client and server can use.\n\n Read more in Docs > API > Composables > Use Cookie.\nLoading Sandbox...\n\nTesting\n\nThis example shows how to test your Nuxt application.\n\nUse Custom Fetch Composable\n\nThis example shows a convenient wrapper for the useFetch composable from nuxt. It allows you to customize the fetch request with default values and user authentication token."
  },
  {
    "title": "Module Extend Pages · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/module-extend-pages",
    "html": "Examples\nAdvanced\nModule Extend Pages\n\nThis example defines a new `test` page using `extendPages` within a module.\n\n Read more in Docs > Guide > Going Further > Modules.\n Read more in Missing link.\n\nLocale\n\nThis example shows how to define a locale composable to handle the application's locale, both server and client side.\n\nTeleport\n\nThis example shows how to use the <Teleport> with client-side and server-side rendering."
  },
  {
    "title": "Use Custom Fetch Composable · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/use-custom-fetch-composable",
    "html": "Examples\nAdvanced\nUse Custom Fetch Composable\n\nThis example shows a convenient wrapper for the useFetch composable from nuxt. It allows you to customize the fetch request with default values and user authentication token.\n\nLoading Sandbox...\n\nuseCookie\n\nThis example shows how to use the useCookie API to persist small amounts of data that both client and server can use.\n\nWASM\n\nThis example demonstrates the server-side support of WebAssembly in Nuxt 3."
  },
  {
    "title": "JSX / TSX · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/jsx",
    "html": "Examples\nAdvanced\nJSX / TSX\n\nThis example shows how to use JSX syntax with typescript in Nuxt pages and components.\n\n Read more in https://vuejs.org/guide/extras/render-function.html#jsx-tsx.\nLoading Sandbox...\n\nError Handling\n\nThis example shows how to handle errors in different contexts: pages, plugins, components and middleware.\n\nLocale\n\nThis example shows how to define a locale composable to handle the application's locale, both server and client side."
  },
  {
    "title": "Teleport · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/teleport",
    "html": "Examples\nAdvanced\nTeleport\n\nThis example shows how to use the <Teleport> with client-side and server-side rendering.\n\nVue 3 provides the <Teleport> component which allows content to be rendered elsewhere in the DOM, outside of the Vue application.\n\nThis example shows how to use the <Teleport> with client-side and server-side rendering.\n\n Read more in Docs > API > Components > Teleports.\nLoading Sandbox...\n\nModule Extend Pages\n\nThis example defines a new `test` page using `extendPages` within a module.\n\nTesting\n\nThis example shows how to test your Nuxt application."
  },
  {
    "title": "Testing · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/testing",
    "html": "Examples\nAdvanced\nTesting\n\nThis example shows how to test your Nuxt application.\n\n Read more in Docs > Getting Started > Testing.\nLoading Sandbox...\n\nTeleport\n\nThis example shows how to use the <Teleport> with client-side and server-side rendering.\n\nuseCookie\n\nThis example shows how to use the useCookie API to persist small amounts of data that both client and server can use."
  },
  {
    "title": "Locale · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/locale",
    "html": "Examples\nAdvanced\nLocale\n\nThis example shows how to define a locale composable to handle the application's locale, both server and client side.\n\nYou can right-click to \"View Page Source\" and see that Nuxt renders the correct date in SSR based on the visitor's locale.\nLoading Sandbox...\n\nJSX / TSX\n\nThis example shows how to use JSX syntax with typescript in Nuxt pages and components.\n\nModule Extend Pages\n\nThis example defines a new `test` page using `extendPages` within a module."
  },
  {
    "title": "Layers · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/config-extends",
    "html": "Examples\nAdvanced\nLayers\n\nThis example shows how to use the extends key in `nuxt.config.ts`.\n\nThis example shows how to use the extends key in nuxt.config.ts to use the base/ directory as a base Nuxt application, and use its components, composables or config and override them if necessary.\n\n Read more in Docs > Getting Started > Layers.\nLoading Sandbox...\n\nUniversal Router\n\nThis example demonstrates Nuxt universal routing utilities without depending on `pages/` and `vue-router`.\n\nError Handling\n\nThis example shows how to handle errors in different contexts: pages, plugins, components and middleware."
  },
  {
    "title": "Error Handling · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/advanced/error-handling",
    "html": "Examples\nAdvanced\nError Handling\n\nThis example shows how to handle errors in different contexts: pages, plugins, components and middleware.\n\n Read more in Docs > Getting Started > Error Handling.\nLoading Sandbox...\n\nLayers\n\nThis example shows how to use the extends key in `nuxt.config.ts`.\n\nJSX / TSX\n\nThis example shows how to use JSX syntax with typescript in Nuxt pages and components."
  },
  {
    "title": "Universal Router · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/routing/universal-router",
    "html": "Examples\nRouting\nUniversal Router\n\nThis example demonstrates Nuxt universal routing utilities without depending on `pages/` and `vue-router`.\n\nLoading Sandbox...\n\nPages\n\nThis example shows how to use the pages/ directory to create application routes.\n\nLayers\n\nThis example shows how to use the extends key in `nuxt.config.ts`."
  },
  {
    "title": "Pages · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/routing/pages",
    "html": "Examples\nRouting\nPages\n\nThis example shows how to use the pages/ directory to create application routes.\n\n Read more in Docs > Guide > Directory Structure > Pages.\nLoading Sandbox...\n\nMiddleware\n\nThis example shows how to add route middleware with the middleware/ directory or with a plugin, and how to use them globally or per page.\n\nUniversal Router\n\nThis example demonstrates Nuxt universal routing utilities without depending on `pages/` and `vue-router`."
  },
  {
    "title": "Layouts · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/features/layouts",
    "html": "Examples\nFeatures\nLayouts\n\nThis example shows how to define default and custom layouts.\n\n Read more in Docs > Getting Started > Views #layouts.\n Read more in Docs > Guide > Directory Structure > Layouts.\nLoading Sandbox...\n\nMeta Tags\n\nThis example shows how to use the Nuxt helpers and composables for SEO and meta management.\n\nMiddleware\n\nThis example shows how to add route middleware with the middleware/ directory or with a plugin, and how to use them globally or per page."
  },
  {
    "title": "Middleware · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/routing/middleware",
    "html": "Examples\nRouting\nMiddleware\n\nThis example shows how to add route middleware with the middleware/ directory or with a plugin, and how to use them globally or per page.\n\n Read more in Docs > Guide > Directory Structure > Middleware.\nLoading Sandbox...\n\nLayouts\n\nThis example shows how to define default and custom layouts.\n\nPages\n\nThis example shows how to use the pages/ directory to create application routes."
  },
  {
    "title": "Meta Tags · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/features/meta-tags",
    "html": "Examples\nFeatures\nMeta Tags\n\nThis example shows how to use the Nuxt helpers and composables for SEO and meta management.\n\n Read more in Docs > Getting Started > Seo Meta.\nLoading Sandbox...\n\nState Management\n\nThis example shows how to use the `useState` composable to create a reactive and SSR-friendly shared state across components.\n\nLayouts\n\nThis example shows how to define default and custom layouts."
  },
  {
    "title": "Auto Imports · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/features/auto-imports",
    "html": "Examples\nFeatures\nAuto Imports\n\nThis example demonstrates the auto-imports feature in Nuxt.\n\nExample of the auto-imports feature in Nuxt with:\n\nVue components in the components/ directory are auto-imported and can be used directly in your templates.\nVue composables in the composables/ directory are auto-imported and can be used directly in your templates and JS/TS files.\nJS/TS variables and functions in the utils/ directory are auto-imported and can be used directly in your templates and JS/TS files.\n Read more in Docs > Guide > Directory Structure > Components.\n Read more in Docs > Guide > Directory Structure > Composables.\n Read more in Docs > Guide > Directory Structure > Utils.\nLoading Sandbox...\n\nHello World\n\nA minimal Nuxt 3 application only requires the `app.vue` and `nuxt.config.js` files.\n\nData Fetching\n\nThis example demonstrates data fetching with Nuxt 3 using built-in composables and API routes."
  },
  {
    "title": "State Management · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/features/state-management",
    "html": "Examples\nFeatures\nState Management\n\nThis example shows how to use the `useState` composable to create a reactive and SSR-friendly shared state across components.\n\n Read more in Docs > Getting Started > State Management.\n Read more in Docs > API > Composables > Use State.\nLoading Sandbox...\n\nData Fetching\n\nThis example demonstrates data fetching with Nuxt 3 using built-in composables and API routes.\n\nMeta Tags\n\nThis example shows how to use the Nuxt helpers and composables for SEO and meta management."
  },
  {
    "title": "Nuxt Configuration",
    "url": "https://nuxt.com/docs/api/nuxt-config#imports",
    "html": "Nuxt Configuration\n\nDiscover all the options you can use in your nuxt.config.ts file.\n\nThis file is auto-generated from Nuxt source code.\n_build\nType: boolean\nDefault: false\n_cli\nType: boolean\nDefault: false\n_generate\nType: boolean\nDefault: false\n_installedModules\nType: array\n_legacyGenerate\nType: boolean\nDefault: false\n_majorVersion\nType: number\nDefault: 3\n_modules\nType: array\n_nuxtConfigFile\n_nuxtConfigFiles\nType: array\n_prepare\nType: boolean\nDefault: false\n_requiredModules\n_start\nType: boolean\nDefault: false\nalias\nType: object\nDefault\n{\n\n  \"~\": \"/<rootDir>\",\n\n  \"@\": \"/<rootDir>\",\n\n  \"~~\": \"/<rootDir>\",\n\n  \"@@\": \"/<rootDir>\",\n\n  \"assets\": \"/<rootDir>/assets\",\n\n  \"public\": \"/<rootDir>/public\"\n\n}\n\nanalyzeDir\nType: string\nDefault: \"/<rootDir>/.nuxt/analyze\"\napp\nbaseURL\nType: string\nDefault: \"/\"\nbuildAssetsDir\nType: string\nDefault: \"/_nuxt/\"\ncdnURL\nType: string\nDefault: \"\"\nhead\nType: object\nDefault\n{\n\n  \"meta\": [\n\n    {\n\n      \"name\": \"viewport\",\n\n      \"content\": \"width=device-width, initial-scale=1\"\n\n    },\n\n    {\n\n      \"charset\": \"utf-8\"\n\n    }\n\n  ],\n\n  \"link\": [],\n\n  \"style\": [],\n\n  \"script\": [],\n\n  \"noscript\": []\n\n}\n\nkeepalive\nType: boolean\nDefault: false\nlayoutTransition\nType: boolean\nDefault: false\npageTransition\nType: boolean\nDefault: false\nrootId\nType: string\nDefault: \"__nuxt\"\nrootTag\nType: string\nDefault: \"div\"\nappConfig\nnuxt\nappDir\nType: string\nDefault: \"\"\nbuild\nanalyze\nType: object\nDefault\n{\n\n  \"template\": \"treemap\",\n\n  \"projectRoot\": \"/<rootDir>\",\n\n  \"filename\": \"/<rootDir>/.nuxt/analyze/{name}.html\"\n\n}\n\ntemplates\nType: array\ntranspile\nType: array\nbuildDir\nType: string\nDefault: \"/<rootDir>/.nuxt\"\nbuilder\nType: string\nDefault: \"@nuxt/vite-builder\"\ncomponents\nType: object\nDefault\n{\n\n  \"dirs\": [\n\n    {\n\n      \"path\": \"~/components/global\",\n\n      \"global\": true\n\n    },\n\n    \"~/components\"\n\n  ]\n\n}\n\ncss\nType: array\ndebug\nType: boolean\nDefault: false\ndev\nType: boolean\nDefault: false\ndevServer\nhost\nhttps\nType: boolean\nDefault: false\nloadingTemplate\nType: function\nport\nType: number\nDefault: 3000\nurl\nType: string\nDefault: \"http://localhost:3000\"\ndevServerHandlers\nType: array\ndevtools\ndir\nassets\nType: string\nDefault: \"assets\"\nlayouts\nType: string\nDefault: \"layouts\"\nmiddleware\nType: string\nDefault: \"middleware\"\nmodules\nType: string\nDefault: \"modules\"\npages\nType: string\nDefault: \"pages\"\nplugins\nType: string\nDefault: \"plugins\"\npublic\nType: string\nDefault: \"public\"\nstatic\nType: string\nDefault: \"public\"\nexperimental\nappManifest\nType: boolean\nDefault: true\nasyncContext\nType: boolean\nDefault: false\nasyncEntry\nType: boolean\nDefault: false\nclientFallback\nType: boolean\nDefault: false\ncomponentIslands\nType: boolean\nDefault: false\nconfigSchema\nType: boolean\nDefault: true\ncrossOriginPrefetch\nType: boolean\nDefault: false\ndefaults\nnuxtLink\ncomponentName\nType: string\nDefault: \"NuxtLink\"\nuseAsyncData\ndeep\nType: boolean\nDefault: true\nuseFetch\nemitRouteChunkError\nType: string\nDefault: \"automatic\"\nexternalVue\nType: boolean\nDefault: true\nheadNext\nType: boolean\nDefault: false\ninlineRouteRules\nType: boolean\nDefault: false\ninlineSSRStyles\nType: boolean\nDefault: true\nlocalLayerAliases\nType: boolean\nDefault: true\nnoScripts\nType: boolean\nDefault: false\nnoVueServer\nType: boolean\nDefault: false\npayloadExtraction\nType: boolean\nDefault: true\npolyfillVueUseHead\nType: boolean\nDefault: false\nreactivityTransform\nType: boolean\nDefault: false\nrenderJsonPayloads\nType: boolean\nDefault: true\nrespectNoSSRHeader\nType: boolean\nDefault: false\nrestoreState\nType: boolean\nDefault: false\ntemplateRouteInjection\nType: boolean\nDefault: true\ntreeshakeClientOnly\nType: boolean\nDefault: true\ntypedPages\nType: boolean\nDefault: false\ntypescriptBundlerResolution\nType: boolean\nDefault: false\nviewTransition\nType: boolean\nDefault: false\nwatcher\nType: string\nDefault: \"chokidar-granular\"\nwriteEarlyHints\nType: boolean\nDefault: false\nextends\nDefault: null\nextensions\nType: array\nDefault\n[\n\n  \".js\",\n\n  \".jsx\",\n\n  \".mjs\",\n\n  \".ts\",\n\n  \".tsx\",\n\n  \".vue\"\n\n]\n\ngenerate\nexclude\nType: array\nroutes\nType: array\nhooks\nDefault: null\nignore\nType: array\nDefault\n[\n\n  \"**/*.stories.{js,cts,mts,ts,jsx,tsx}\",\n\n  \"**/*.{spec,test}.{js,cts,mts,ts,jsx,tsx}\",\n\n  \"**/*.d.{cts,mts,ts}\",\n\n  \"**/.{pnpm-store,vercel,netlify,output,git,cache,data}\",\n\n  \".nuxt/analyze\",\n\n  \".nuxt\",\n\n  \"**/-*.*\"\n\n]\n\nignoreOptions\nignorePrefix\nType: string\nDefault: \"-\"\nimports\ndirs\nType: array\nglobal\nType: boolean\nDefault: false\nlogLevel\nType: string\nDefault: \"info\"\nmodules\nType: array\nmodulesDir\nType: array\nDefault\n[\n\n  \"/<rootDir>/node_modules\",\n\n  \"/Users/daniel/code/nuxt.js/packages/schema/node_modules\"\n\n]\n\nnitro\nrouteRules\nType: object\noptimization\nasyncTransforms\nasyncFunctions\nType: array\nDefault\n[\n\n  \"defineNuxtPlugin\",\n\n  \"defineNuxtRouteMiddleware\"\n\n]\n\nobjectDefinitions\ndefineNuxtComponent\nType: array\nDefault\n[\n\n  \"asyncData\",\n\n  \"setup\"\n\n]\n\ndefineNuxtPlugin\nType: array\nDefault\n[\n\n  \"setup\"\n\n]\n\ndefinePageMeta\nType: array\nDefault\n[\n\n  \"middleware\",\n\n  \"validate\"\n\n]\n\nkeyedComposables\nType: array\nDefault\n[\n\n  {\n\n    \"name\": \"defineNuxtComponent\",\n\n    \"argumentLength\": 2\n\n  },\n\n  {\n\n    \"name\": \"useState\",\n\n    \"argumentLength\": 2\n\n  },\n\n  {\n\n    \"name\": \"useFetch\",\n\n    \"argumentLength\": 3\n\n  },\n\n  {\n\n    \"name\": \"useAsyncData\",\n\n    \"argumentLength\": 3\n\n  },\n\n  {\n\n    \"name\": \"useLazyAsyncData\",\n\n    \"argumentLength\": 3\n\n  },\n\n  {\n\n    \"name\": \"useLazyFetch\",\n\n    \"argumentLength\": 3\n\n  }\n\n]\n\ntreeShake\ncomposables\nclient\nType: object\nDefault\n{\n\n  \"vue\": [\n\n    \"onServerPrefetch\",\n\n    \"onRenderTracked\",\n\n    \"onRenderTriggered\"\n\n  ],\n\n  \"#app\": [\n\n    \"definePayloadReducer\",\n\n    \"definePageMeta\"\n\n  ]\n\n}\n\nserver\nType: object\nDefault\n{\n\n  \"vue\": [\n\n    \"onBeforeMount\",\n\n    \"onMounted\",\n\n    \"onBeforeUpdate\",\n\n    \"onRenderTracked\",\n\n    \"onRenderTriggered\",\n\n    \"onActivated\",\n\n    \"onDeactivated\",\n\n    \"onBeforeUnmount\"\n\n  ],\n\n  \"#app\": [\n\n    \"definePayloadReviver\",\n\n    \"definePageMeta\"\n\n  ]\n\n}\n\npages\nType: boolean\nplugins\nType: array\npostcss\nplugins\nautoprefixer\ncssnano\nType: object\nrootDir\nType: string\nDefault: \"/<rootDir>\"\nrouteRules\nrouter\noptions\nhashMode\nType: boolean\nDefault: false\nscrollBehaviorType\nType: string\nDefault: \"auto\"\nruntimeConfig\nType: object\nDefault\n{\n\n  \"public\": {},\n\n  \"app\": {\n\n    \"baseURL\": \"/\",\n\n    \"buildAssetsDir\": \"/_nuxt/\",\n\n    \"cdnURL\": \"\"\n\n  }\n\n}\n\nserverDir\nType: string\nDefault: \"/<rootDir>/server\"\nserverHandlers\nType: array\nsourcemap\nType: object\nDefault\n{\n\n  \"server\": true,\n\n  \"client\": false\n\n}\n\nspaLoadingTemplate\nDefault: null\nsrcDir\nType: string\nDefault: \"/<rootDir>\"\nssr\nType: boolean\nDefault: true\ntelemetry\ntest\nType: boolean\nDefault: false\ntheme\nType: string\nDefault: null\ntypescript\nbuilder\nDefault: null\nincludeWorkspace\nType: boolean\nDefault: false\nshim\nType: boolean\nDefault: true\nstrict\nType: boolean\nDefault: true\ntsConfig\nType: object\nDefault\n{\n\n  \"compilerOptions\": {}\n\n}\n\ntypeCheck\nType: boolean\nDefault: false\nvite\nbuild\nassetsDir\nType: string\nDefault: \"_nuxt/\"\nemptyOutDir\nType: boolean\nDefault: false\nclearScreen\nType: boolean\nDefault: true\ndefine\nType: object\nDefault\n{\n\n  \"process.dev\": false,\n\n  \"import.meta.dev\": false,\n\n  \"process.test\": false,\n\n  \"import.meta.test\": false\n\n}\n\nesbuild\njsxFactory\nType: string\nDefault: \"h\"\njsxFragment\nType: string\nDefault: \"Fragment\"\ntsconfigRaw\nType: string\nDefault: \"{}\"\nmode\nType: string\nDefault: \"production\"\noptimizeDeps\nexclude\nType: array\nDefault\n[\n\n  \"vue-demi\"\n\n]\n\npublicDir\nType: string\nDefault: \"/<rootDir>/public\"\nresolve\nextensions\nType: array\nDefault\n[\n\n  \".mjs\",\n\n  \".js\",\n\n  \".ts\",\n\n  \".jsx\",\n\n  \".tsx\",\n\n  \".json\",\n\n  \".vue\"\n\n]\n\nroot\nType: string\nDefault: \"/<rootDir>\"\nserver\nfs\nallow\nType: array\nDefault\n[\n\n  \"/<rootDir>/.nuxt\",\n\n  \"/<rootDir>\",\n\n  \"/<rootDir>\",\n\n  \"/<rootDir>\",\n\n  \"/<rootDir>/node_modules\",\n\n  \"/Users/daniel/code/nuxt.js/packages/schema/node_modules\"\n\n]\n\nvue\nisProduction\nType: boolean\nDefault: true\nscript\ndefineModel\nType: boolean\nDefault: false\npropsDestructure\nType: boolean\nDefault: false\ntemplate\ncompilerOptions\nType: object\nvueJsx\nType: object\nvue\ncompilerOptions\ndefineModel\nType: boolean\nDefault: false\npropsDestructure\nType: boolean\nDefault: false\nruntimeCompiler\nType: boolean\nDefault: false\nwatch\nType: array\nwatchers\nchokidar\nignoreInitial\nType: boolean\nDefault: true\nrewatchOnRawEvents\nwebpack\naggregateTimeout\nType: number\nDefault: 1000\nwebpack\naggressiveCodeRemoval\nType: boolean\nDefault: false\nanalyze\nType: object\nDefault\n{\n\n  \"template\": \"treemap\",\n\n  \"projectRoot\": \"/<rootDir>\",\n\n  \"filename\": \"/<rootDir>/.nuxt/analyze/{name}.html\"\n\n}\n\ncssSourceMap\nType: boolean\nDefault: false\ndevMiddleware\nstats\nType: string\nDefault: \"none\"\nexperiments\nextractCSS\nType: boolean\nDefault: true\nfilenames\napp\nType: function\nchunk\nType: function\ncss\nType: function\nfont\nType: function\nimg\nType: function\nvideo\nType: function\nfriendlyErrors\nType: boolean\nDefault: true\nhotMiddleware\nloaders\ncss\nesModule\nType: boolean\nDefault: false\nimportLoaders\nType: number\nDefault: 0\nurl\nfilter\nType: function\ncssModules\nesModule\nType: boolean\nDefault: false\nimportLoaders\nType: number\nDefault: 0\nmodules\nlocalIdentName\nType: string\nDefault: \"[local]_[hash:base64:5]\"\nurl\nfilter\nType: function\nesbuild\nfile\nesModule\nType: boolean\nDefault: false\nfontUrl\nesModule\nType: boolean\nDefault: false\nlimit\nType: number\nDefault: 1000\nimgUrl\nesModule\nType: boolean\nDefault: false\nlimit\nType: number\nDefault: 1000\nless\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\npugPlain\nsass\nsassOptions\nindentedSyntax\nType: boolean\nDefault: true\nscss\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\nstylus\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\nvue\ncompilerOptions\nType: object\ndefineModel\nType: boolean\nDefault: false\npropsDestructure\nType: boolean\nDefault: false\ntransformAssetUrls\nembed\nType: string\nDefault: \"src\"\nobject\nType: string\nDefault: \"src\"\nsource\nType: string\nDefault: \"src\"\nvideo\nType: string\nDefault: \"src\"\nvueStyle\nDefault\n{\n\n  \"sourceMap\": false\n\n}\n\noptimization\nminimize\nType: boolean\nDefault: true\nminimizer\nruntimeChunk\nType: string\nDefault: \"single\"\nsplitChunks\nautomaticNameDelimiter\nType: string\nDefault: \"/\"\ncacheGroups\nchunks\nType: string\nDefault: \"all\"\noptimizeCSS\nType: boolean\nDefault: false\nplugins\nType: array\npostcss\npostcssOptions\nconfig\nplugins\nType: object\nDefault\n{\n\n  \"autoprefixer\": {},\n\n  \"cssnano\": {}\n\n}\n\nprofile\nType: boolean\nDefault: false\nserverURLPolyfill\nType: string\nDefault: \"url\"\nwarningIgnoreFilters\nType: array\nworkspaceDir\nType: string\nDefault: \"/<rootDir>\"\n\nImport meta\n\nUnderstand where your code is running using `import.meta`.\n\nGetting Help\n\nWe're a friendly community of developers and we'd love to help."
  },
  {
    "title": "Data Fetching · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/features/data-fetching",
    "html": "Examples\nFeatures\nData Fetching\n\nThis example demonstrates data fetching with Nuxt 3 using built-in composables and API routes.\n\n Read more in Docs > Getting Started > Data Fetching.\n Read more in Docs > Guide > Directory Structure > Server.\nLoading Sandbox...\n\nAuto Imports\n\nThis example demonstrates the auto-imports feature in Nuxt.\n\nState Management\n\nThis example shows how to use the `useState` composable to create a reactive and SSR-friendly shared state across components."
  },
  {
    "title": "useNuxtApp · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-nuxt-app",
    "html": "Composables\nuseNuxtApp\nSource\n\nAccess the shared runtime context of the Nuxt Application.\n\nuseNuxtApp is a built-in composable that provides a way to access shared runtime context of Nuxt, which is available on both client and server side. It helps you access the Vue app instance, runtime hooks, runtime config variables and internal states, such as ssrContext and payload.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst nuxtApp = useNuxtApp()\n\n</script>\n\nMethods\nprovide (name, value)\n\nnuxtApp is a runtime context that you can extend using Nuxt plugins. Use the provide function to create Nuxt plugins to make values and helper methods available in your Nuxt application across all composables and components.\n\nprovide function accepts name and value parameters.\n\nconst nuxtApp = useNuxtApp()\n\nnuxtApp.provide('hello', (name) => `Hello ${name}!`)\n\n\n\n// Prints \"Hello name!\"\n\nconsole.log(nuxtApp.$hello('name'))\n\n\nAs you can see in the example above, $hello has become the new and custom part of nuxtApp context and it is available in all places where nuxtApp is accessible.\n\nhook(name, cb)\n\nHooks available in nuxtApp allows you to customize the runtime aspects of your Nuxt application. You can use runtime hooks in Vue.js composables and Nuxt plugins to hook into the rendering lifecycle.\n\nhook function is useful for adding custom logic by hooking into the rendering lifecycle at a specific point. hook function is mostly used when creating Nuxt plugins.\n\nSee Runtime Hooks for available runtime hooks called by Nuxt.\n\nplugins/test.ts\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  nuxtApp.hook('page:start', () => {\n\n    /* your code goes here */\n\n  })\n\n  nuxtApp.hook('vue:error', (..._args) => {\n\n    console.log('vue:error')\n\n    // if (process.client) {\n\n    //   console.log(..._args)\n\n    // }\n\n  })\n\n})\n\ncallHook(name, ...args)\n\ncallHook returns a promise when called with any of the existing hooks.\n\nawait nuxtApp.callHook('my-plugin:init')\n\nProperties\n\nuseNuxtApp() exposes the following properties that you can use to extend and customize your app and share state, data and variables.\n\nvueApp\n\nvueApp is the global Vue.js application instance that you can access through nuxtApp.\n\nSome useful methods:\n\ncomponent() - Registers a global component if passing both a name string and a component definition, or retrieves an already registered one if only the name is passed.\ndirective() - Registers a global custom directive if passing both a name string and a directive definition, or retrieves an already registered one if only the name is passed(example).\nuse() - Installs a Vue.js Plugin (example).\n Read more in https://vuejs.org/api/application.html#application-api.\nssrContext\n\nssrContext is generated during server-side rendering and it is only available on the server side.\n\nNuxt exposes the following properties through ssrContext:\n\nurl (string) - Current request url.\nevent (unjs/h3 request event) - Access the request & response of the current route.\npayload (object) - NuxtApp payload object.\npayload\n\npayload exposes data and state variables from server side to client side. The following keys will be available on the client after they have been passed from the server side:\n\nserverRendered (boolean) - Indicates if response is server-side-rendered.\ndata (object) - When you fetch the data from an API endpoint using either useFetch or useAsyncData , resulting payload can be accessed from the payload.data. This data is cached and helps you prevent fetching the same data in case an identical request is made more than once.\napp.vue\nserver/api/count.ts\n<script setup lang=\"ts\">\n\nconst { data } = await useAsyncData('count', () => $fetch('/api/count'))\n\n</script>\n\n\nAfter fetching the value of count using useAsyncData in the example above, if you access payload.data, you will see { count: 1 } recorded there.\nWhen accessing the same payload.data from ssrcontext, you can access the same value on the server side as well.\nstate (object) - When you use useState composable in Nuxt to set shared state, this state data is accessed through payload.state.[name-of-your-state].\nplugins/my-plugin.ts\nexport const useColor = () => useState<string>('color', () => 'pink')\n\n\n\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  if (process.server) {\n\n    const color = useColor()\n\n  }\n\n})\n\n\nIt is also possible to use more advanced types, such as ref, reactive, shallowRef, shallowReactive and NuxtError.\nYou can also add your own types, with a special plugin helper:\nplugins/custom-payload.ts\n  /**\n\n   * This kind of plugin runs very early in the Nuxt lifecycle, before we revive the payload.\n\n   * You will not have access to the router or other Nuxt-injected properties.\n\n   */\n\nexport default definePayloadPlugin((nuxtApp) => {\n\n  definePayloadReducer('BlinkingText', data => data === '<blink>' && '_')\n\n  definePayloadReviver('BlinkingText', () => '<blink>')\n\n})\n\nisHydrating\n\nUse nuxtApp.isHydrating (boolean) to check if the Nuxt app is hydrating on the client side.\n\ncomponents/nuxt-error-boundary.ts\nexport default defineComponent({\n\n  setup (_props, { slots, emit }) {\n\n    const nuxtApp = useNuxtApp()\n\n    onErrorCaptured((err) => {\n\n      if (process.client && !nuxtApp.isHydrating) {\n\n        // ...\n\n      }\n\n    })\n\n  }\n\n})\n\nrunWithContext\nYou are likely here because you got a \"Nuxt instance unavailable\" message. Please use this method sparingly, and report examples that are causing issues, so that it can ultimately be solved at the framework level.\n\nThe runWithContext method is meant to be used to call a function and give it an explicit Nuxt context. Typically, the Nuxt context is passed around implicitly and you do not need to worry about this. However, when working with complex async/await scenarios in middleware/plugins, you can run into instances where the current instance has been unset after an async call.\n\nmiddleware/auth.ts\nexport default defineNuxtRouteMiddleware(async (to, from) => {\n\n  const nuxtApp = useNuxtApp()\n\n  let user\n\n  try {\n\n    user = await fetchUser()\n\n    // the Vue/Nuxt compiler loses context here because of the try/catch block.\n\n  } catch (e) {\n\n    user = null\n\n  }\n\n  if (!user) {\n\n    // apply the correct Nuxt context to our `navigateTo` call.  \n\n    return nuxtApp.runWithContext(() => navigateTo('/auth'))\n\n  }\n\n})\n\nUsage\nconst result = nuxtApp.runWithContext(() => functionWithContext())\n\nfunctionWithContext: Any function that requires the context of the current Nuxt application. This context will be correctly applied automatically.\n\nrunWithContext will return whatever is returned by functionWithContext.\n\nA Deeper Explanation of Context\n\nVue.js Composition API (and Nuxt composables similarly) work by depending on an implicit context. During the lifecycle, Vue sets the temporary instance of the current component (and Nuxt temporary instance of nuxtApp) to a global variable and unsets it in same tick. When rendering on the server side, there are multiple requests from different users and nuxtApp running in a same global context. Because of this, Nuxt and Vue immediately unset this global instance to avoid leaking a shared reference between two users or components.\n\nWhat it does mean? The Composition API and Nuxt Composables are only available during lifecycle and in same tick before any async operation:\n\n// --- Vue internal ---\n\nconst _vueInstance = null\n\nconst getCurrentInstance = () => _vueInstance\n\n// ---\n\n\n\n// Vue / Nuxt sets a global variable referencing to current component in _vueInstance when calling setup()\n\nasync function setup() {\n\n  getCurrentInstance() // Works\n\n  await someAsyncOperation() // Vue unsets the context in same tick before async operation!\n\n  getCurrentInstance() // null\n\n}\n\n\nThe classic solution to this, is caching the current instance on first call to a local variable like const instance = getCurrentInstance() and use it in the next composable call but the issue is that any nested composable calls now needs to explicitly accept the instance as an argument and not depend on the implicit context of composition-api. This is design limitation with composables and not an issue per-se.\n\nTo overcome this limitation, Vue does some behind the scenes work when compiling our application code and restores context after each call for <script setup>:\n\nconst __instance = getCurrentInstance() // Generated by Vue compiler\n\ngetCurrentInstance() // Works!\n\nawait someAsyncOperation() // Vue unsets the context\n\n__restoreInstance(__instance) // Generated by Vue compiler\n\ngetCurrentInstance() // Still works!\n\n\nFor a better description of what Vue actually does, see unjs/unctx#2 (comment).\n\nSolution\n\nThis is where runWithContext can be used to restore context, similarly to how <script setup> works.\n\nNuxt 3 internally uses unjs/unctx to support composables similar to Vue for plugins and middleware. This enables composables like navigateTo() to work without directly passing nuxtApp to them - bringing the DX and performance benefits of Composition API to the whole Nuxt framework.\n\nNuxt composables have the same design as the Vue Composition API and therefore need a similar solution to magically do this transform. Check out unjs/unctx#2 (proposal), unjs/unctx#4 (transform implementation), and nuxt/framework#3884 (Integration to Nuxt).\n\nVue currently only supports async context restoration for <script setup> for async/await usage. In Nuxt 3, the transform support for defineNuxtPlugin() and defineNuxtRouteMiddleware() was added, which means when you use them Nuxt automatically transforms them with context restoration.\n\nRemaining Issues\n\nThe unjs/unctx transformation to automatically restore context seems buggy with try/catch statements containing await which ultimately needs to be solved in order to remove the requirement of the workaround suggested above.\n\nNative Async Context\n\nUsing a new experimental feature, it is possible to enable native async context support using Node.js AsyncLocalStorage and new unctx support to make async context available natively to any nested async composable without needing a transform or manual passing/calling with context.\n\nNative async context support works currently in Bun and Node.\n Read more in Docs > Guide > Going Further > Experimental Features #asynccontext.\n\nuseLazyFetch\n\nThis wrapper around useFetch triggers navigation immediately.\n\nuseNuxtData\n\nAccess the current cached value of data fetching composables."
  },
  {
    "title": "Hello World · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/hello-world",
    "html": "Examples\nHello World\n\nA minimal Nuxt 3 application only requires the `app.vue` and `nuxt.config.js` files.\n\n Read more in Docs > Getting Started > Introduction.\nLoading Sandbox...\n\nModules\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 modules.\n\nAuto Imports\n\nThis example demonstrates the auto-imports feature in Nuxt."
  },
  {
    "title": "Auto-imports · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/auto-imports",
    "html": "Guide\nKey Concepts\nAuto-imports\n\nNuxt auto-imports components, composables, helper functions and Vue APIs.\n\nNuxt auto-imports components, composables and Vue.js APIs to use across your application without explicitly importing them.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst count = ref(1) // ref is auto-imported\n\n</script>\n\n\nThanks to its opinionated directory structure, Nuxt can auto-import your components/, composables/ and utils/.\n\nContrary to a classic global declaration, Nuxt preserves typings, IDEs completions and hints, and only includes what is used in your production code.\n\nIn the docs, every function that is not explicitly imported is auto-imported by Nuxt and can be used as-is in your code. You can find a reference for auto-imported components, composables and utilities in the API section.\nIn the server directory, Nuxt auto-imports exported functions and variables from server/utils/.\nYou can also auto-import functions exported from custom folders or third-party packages by configuring the imports section of your nuxt.config file.\nBuilt-in Auto-imports\n\nNuxt auto-imports functions and composables to perform data fetching, get access to the app context and runtime config, manage state or define components and plugins.\n\n<script setup lang=\"ts\">\n\n/* useAsyncData() and $fetch() are auto-imported */\n\nconst { data, refresh, pending } = await useFetch('/api/hello')\n\n</script>\n\n\nVue 3 exposes Reactivity APIs like ref or computed, as well as lifecycle hooks and helpers that are auto-imported by Nuxt.\n\n<script setup lang=\"ts\">\n\n/* ref() and computed() are auto-imported */\n\nconst count = ref(1)\n\nconst double = computed(() => count.value * 2)\n\n</script>\n\nVue and Nuxt composables\n\nWhen you are using the built-in Composition API composables provided by Vue and Nuxt, be aware that many of them rely on being called in the right context.\n\nDuring a component lifecycle, Vue tracks the temporary instance of the current component (and similarly, Nuxt tracks a temporary instance of nuxtApp) via a global variable, and then unsets it in same tick. This is essential when server rendering, both to avoid cross-request state pollution (leaking a shared reference between two users) and to avoid leakage between different components.\n\nThat means that (with very few exceptions) you cannot use them outside a Nuxt plugin, Nuxt route middleware or Vue setup function. On top of that, you must use them synchronously - that is, you cannot use await before calling a composable, except within <script setup> blocks, within the setup function of a component declared with defineNuxtComponent, in defineNuxtPlugin or in defineNuxtRouteMiddleware, where we perform a transform to keep the synchronous context even after the await.\n\nIf you get an error message like Nuxt instance is unavailable then it probably means you are calling a Nuxt composable in the wrong place in the Vue or Nuxt lifecycle.\n\nCheckout the asyncContext experimental feature to use Nuxt composables in async functions.\nSee the full explanation in this GitHub comment.\n\nExample of breaking code:\n\ncomposables/example.ts\n// trying to access runtime config outside a composable\n\nconst config = useRuntimeConfig()\n\n\n\nexport const useMyComposable = () => {\n\n  // accessing runtime config here\n\n}\n\n\nExample of working code:\n\ncomposables/example.ts\nexport const useMyComposable = () => {\n\n  // Because your composable is called in the right place in the lifecycle,\n\n  // useRuntimeConfig will also work\n\n  const config = useRuntimeConfig()\n\n\n\n  // ...\n\n}\n\nDirectory-based Auto-imports\n\nNuxt directly auto-imports files created in defined directories:\n\ncomponents/ for Vue components.\ncomposables/ for Vue composables.\nutils/ for helper functions and other utilities.\n Read and edit a live example in Docs > Examples > Features > Auto Imports.\nExplicit Imports\n\nNuxt exposes every auto-import with the #imports alias that can be used to make the import explicit if needed:\n\n<script setup lang=\"ts\">\n\nimport { ref, computed } from '#imports'\n\n\n\nconst count = ref(1)\n\nconst double = computed(() => count.value * 2)\n\n</script>\n\nDisabling Auto-imports\n\nIf you want to disable auto-importing composables and utilities, you can set imports.autoImport to false in the nuxt.config file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    autoImport: false\n\n  }\n\n})\n\n\nThis will disable auto-imports completely but it's still possible to use explicit imports from #imports.\n\nAuto-imported Components\n\nNuxt also automatically imports components from your ~/components directory, although this is configured separately from auto-importing composables and utility functions.\n\n Read more in Docs > Guide > Directory Structure > Components.\n\nTo disable auto-importing components from your own ~/components directory, you can set components.dirs to an empty array (though note that this will not affect components added by modules).\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  components: {\n\n    dirs: []\n\n  }\n\n})\n\nAuto-import from third-party packages\n\nNuxt also allows auto-importing from third-party packages.\n\nIf you are using the Nuxt module for that package, it is likely that the module has already configured auto-imports for that package.\n\nFor example, you could enable the auto-import of the useI18n composable from the vue-i18n package like this:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    presets: [\n\n      {\n\n        from: 'vue-i18n',\n\n        imports: ['useI18n']\n\n      }\n\n    ]\n\n  }\n\n})\n\n\nUpgrade Guide\n\nLearn how to upgrade to the latest Nuxt version.\n\nVue.js Development\n\nNuxt uses Vue.js and adds features such as component auto-imports, file-based routing and composables for a SSR-friendly usage."
  },
  {
    "title": "Custom Routing · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/custom-routing",
    "html": "Guide\nGoing Further\nCustom Routing\n\nIn Nuxt 3, your routing is defined by the structure of your files inside the pages directory. However, since it uses vue-router under the hood, Nuxt offers you several ways to add custom routes in your project.\n\nAdding custom routes\n\nIn Nuxt 3, your routing is defined by the structure of your files inside the pages directory. However, since it uses vue-router under the hood, Nuxt offers you several ways to add custom routes in your project.\n\nRouter Config\n\nUsing router options, you can optionally override or extend your routes using a function that accepts the scanned routes and returns customized routes.\n\nIf it returns null or undefined, Nuxt will fall back to the default routes (useful to modify input array).\n\napp/router.options.ts\nimport type { RouterConfig } from '@nuxt/schema'\n\n\n\nexport default <RouterConfig> {\n\n  // https://router.vuejs.org/api/interfaces/routeroptions.html#routes\n\n  routes: (_routes) => [\n\n    {\n\n      name: 'home',\n\n      path: '/',\n\n      component: () => import('~/pages/home.vue').then(r => r.default || r)\n\n    }\n\n  ],\n\n}\n\nNuxt will not augment any new routes you return from the routes function with metadata defined in definePageMeta of the component you provide. If you want that to happen, you should use the pages:extend hook which is called at build-time.\nPages Hook\n\nYou can add, change or remove pages from the scanned routes with the pages:extend nuxt hook.\n\nFor example, to prevent creating routes for any .ts files:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  hooks: {\n\n    'pages:extend' (pages) {\n\n      // add a route\n\n      pages.push({\n\n        name: 'profile',\n\n        path: '/profile',\n\n        file: '~/extra-pages/profile.vue'\n\n      })\n\n\n\n      // remove routes\n\n      function removePagesMatching (pattern: RegExp, pages: NuxtPage[] = []) {\n\n        const pagesToRemove = []\n\n        for (const page of pages) {\n\n          if (pattern.test(page.file)) {\n\n            pagesToRemove.push(page)\n\n          } else {\n\n            removePagesMatching(pattern, page.children)\n\n          }\n\n        }\n\n        for (const page of pagesToRemove) {\n\n          pages.splice(pages.indexOf(page), 1)\n\n        }\n\n      }\n\n      removePagesMatching(/\\.ts$/, pages)\n\n    }\n\n  }\n\n})\n\nNuxt Module\n\nIf you plan to add a whole set of pages related with a specific functionality, you might want to use a Nuxt module.\n\nThe Nuxt kit provides a few ways to add routes:\n\nextendPages (callback: pages => void)\nextendRouteRules (route: string, rule: NitroRouteConfig, options: ExtendRouteRulesOptions)\nRouter Options\n\nOn top of customizing options for vue-router, Nuxt offers additional options to customize the router.\n\nUsing app/router.options\n\nThis is the recommended way to specify router options.\n\napp/router.options.ts\nimport type { RouterConfig } from '@nuxt/schema'\n\n\n\nexport default <RouterConfig> {\n\n}\n\nUsing nuxt.config\n\nNote: Only JSON serializable options are configurable:\n\nlinkActiveClass\nlinkExactActiveClass\nend\nsensitive\nstrict\nhashMode\nscrollBehaviorType\nnuxt.config\nexport default defineNuxtConfig({\n\n  router: {\n\n    options: {}\n\n  }\n\n})\n\nHash Mode (SPA)\n\nYou can enable hash history in SPA mode using the hashMode config. In this mode, router uses a hash character (#) before the actual URL that is internally passed. When enabled, the URL is never sent to the server and SSR is not supported.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  ssr: false,\n\n  router: {\n\n    options: {\n\n      hashMode: true\n\n    }\n\n  }\n\n})\n\nScroll Behavior for hash links\n\nYou can optionally customize the scroll behavior for hash links. When you set the config to be smooth and you load a page with a hash link (e.g. https://example.com/blog/my-article#comments), you will see that the browser smoothly scrolls to this anchor.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  router: {\n\n    options: {\n\n      scrollBehaviorType: 'smooth'\n\n    }\n\n  }\n\n})\n\nCustom History (advanced)\n\nYou can optionally override history mode using a function that accepts the base URL and returns the history mode. If it returns null or undefined, Nuxt will fallback to the default history.\n\napp/router.options.ts\nimport type { RouterConfig } from '@nuxt/schema'\n\nimport { createMemoryHistory } from 'vue-router'\n\n\n\nexport default <RouterConfig> {\n\n  // https://router.vuejs.org/api/interfaces/routeroptions.html\n\n  history: base => process.client ? createMemoryHistory(base) : null /* default */\n\n}\n\n\nAuthoring Nuxt Layers\n\nNuxt provides a powerful system that allows you to extend the default files, configs, and much more.\n\nDebugging\n\nIn Nuxt 3, you can get started with debugging your application directly in the browser as well as in your IDE."
  },
  {
    "title": "Nightly Release Channel · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/nightly-release-channel",
    "html": "Guide\nGoing Further\nNightly Release Channel\n\nThe nightly release channel allows using Nuxt built directly from the latest commits to the repository.\n\nNuxt lands commits, improvements, and bug fixes every day. You can opt in to test them earlier before the next release.\n\nAfter a commit is merged into the main branch of nuxt/nuxt and passes all tests, we trigger an automated npm release, using GitHub Actions.\n\nYou can use these 'nightly' releases to beta test new features and changes.\n\nThe build and publishing method and quality of these 'nightly' releases are the same as stable ones. The only difference is that you should often check the GitHub repository for updates. There is a slight chance of regressions not being caught during the review process and by the automated tests. Therefore, we internally use this channel to double-check everything before each release.\n\nFeatures that are only available on the nightly release channel are marked with an alert in the documentation.\nOpting In\n\nUpdate nuxt dependency inside package.json:\n\npackage.json\n{\n\n  \"devDependencies\": {\n\n--    \"nuxt\": \"^3.0.0\"\n\n++    \"nuxt\": \"npm:nuxt-nightly@latest\"\n\n  }\n\n}\n\n\nRemove lockfile (package-lock.json, yarn.lock, pnpm-lock.yaml, or bun.lockb) and reinstall dependencies.\n\nOpting Out\n\nUpdate nuxt dependency inside package.json:\n\npackage.json\n{\n\n  \"devDependencies\": {\n\n--    \"nuxt\": \"npm:nuxt-nightly@latest\"\n\n++    \"nuxt\": \"^3.0.0\"\n\n  }\n\n}\n\n\nRemove lockfile (package-lock.json, yarn.lock, pnpm-lock.yaml, or bun.lockb) and reinstall dependencies.\n\nUsing Nightly nuxi\nAll cli dependencies are bundled because of the building method for reducing nuxi package size.\nYou can get dependency updates and CLI improvements using the nightly release channel.\n\nTo try the latest version of nuxt/cli:\n\nTerminal\nnpx nuxi-nightly@latest [command]\n\nRead more about the available commands.\n\nRuntime Config\n\nNuxt provides a runtime config API to expose configuration and secrets within your application.\n\n<ClientOnly>\n\nRender components only in client-side with the <ClientOnly> component."
  },
  {
    "title": "Runtime Config · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/runtime-config",
    "html": "Guide\nGoing Further\nRuntime Config\n\nNuxt provides a runtime config API to expose configuration and secrets within your application.\n\nExposing\n\nTo expose config and environment variables to the rest of your app, you will need to define runtime configuration in your nuxt.config file, using the runtimeConfig option.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  runtimeConfig: {\n\n    // The private keys which are only available within server-side\n\n    apiSecret: '123',\n\n    // Keys within public, will be also exposed to the client-side\n\n    public: {\n\n      apiBase: '/api'\n\n    }\n\n  }\n\n})\n\n\nWhen adding apiBase to the runtimeConfig.public, Nuxt adds it to each page payload. We can universally access apiBase in both server and browser.\n\nconst runtimeConfig = useRuntimeConfig()\n\n\n\nconsole.log(runtimeConfig.apiSecret)\n\nconsole.log(runtimeConfig.public.apiBase)\n\nPublic runtime config is accessible in Vue templates with $config.public.\nSerialization\n\nYour runtime config will be serialized before being passed to Nitro. This means that anything that cannot be serialized and then deserialized (such as functions, Sets, Maps, and so on), should not be set in your nuxt.config.\n\nInstead of passing non-serializable objects or functions into your application from your nuxt.config, you can place this code in a Nuxt or Nitro plugin or middleware.\n\nEnvironment Variables\n\nThe most common way to provide configuration is by using Environment Variables.\n\nNuxi CLI has built-in support for reading your .env file in development, build and generate. But when you run your built server, your .env file will not be read.\n Read more in Docs > Guide > Directory Structure > Env.\n\nRuntime config values are automatically replaced by matching environment variables at runtime.\n\nThere are two key requirements:\n\nYour desired variables must be defined in your nuxt.config. This ensures that arbitrary environment variables are not exposed to your application code.\nOnly a specially-named environment variable can override a runtime config property. That is, an uppercase environment variable starting with NUXT_ which uses _ to separate keys and case changes.\nExample\n.env\nNUXT_API_SECRET=api_secret_token\n\nNUXT_PUBLIC_API_BASE=https://nuxtjs.org\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  runtimeConfig: {\n\n    apiSecret: '', // can be overridden by NUXT_API_SECRET environment variable\n\n    public: {\n\n      apiBase: '', // can be overridden by NUXT_PUBLIC_API_BASE environment variable\n\n    }\n\n  },\n\n})\n\nReading\nVue App\n\nWithin the Vue part of your Nuxt app, you will need to call useRuntimeConfig() to access the runtime config.\n\nThe behavior is different between the client-side and server-side:\nOn client-side, only keys in runtimeConfig.public are available, and the object is both writable and reactive.\nOn server-side, the entire runtime config is available on the server-side, but it is read-only to avoid context sharing.\npages/index.vue\n<script setup lang=\"ts\">\n\nconst config = useRuntimeConfig()\n\n\n\nconsole.log('Runtime config:', config)\n\nif (process.server) {\n\n  console.log('API secret:', config.apiSecret)\n\n}\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <div>Check developer console!</div>\n\n  </div>\n\n</template>\n\nSecurity note: Be careful not to expose runtime config keys to the client-side by either rendering them or passing them to useState.\nPlugins\n\nIf you want to use the runtime config within any (custom) plugin, you can use useRuntimeConfig() inside of your defineNuxtPlugin function.\n\nplugins/config.ts\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  const config = useRuntimeConfig()\n\n\n\n  console.log('API base URL:', config.public.apiBase)\n\n});\n\nServer Routes\n\nYou can access runtime config within the server routes as well using useRuntimeConfig.\n\nserver/api/test.ts\nexport default defineEventHandler(async (event) => {\n\n  const { apiSecret } = useRuntimeConfig(event)\n\n  const result = await $fetch('https://my.api.com/test', {\n\n    headers: {\n\n      Authorization: `Bearer ${apiSecret}`\n\n    }\n\n  })\n\n  return result\n\n})\n\nGiving the event as argument to useRuntimeConfig is optional, but it is recommended to pass it to get the runtime config overwritten by environment variables at runtime for server routes.\nTyping Runtime Config\n\nNuxt tries to automatically generate a typescript interface from provided runtime config using unjs/untyped.\n\nBut it is also possible to type your runtime config manually:\n\nindex.d.ts\ndeclare module 'nuxt/schema' {\n\n  interface RuntimeConfig {\n\n    apiSecret: string\n\n  }\n\n  interface PublicRuntimeConfig {\n\n    apiBase: string\n\n  }\n\n}\n\n// It is always important to ensure you import/export something when augmenting a type\n\nexport {}\n\n\nDebugging\n\nIn Nuxt 3, you can get started with debugging your application directly in the browser as well as in your IDE.\n\nNightly Release Channel\n\nThe nightly release channel allows using Nuxt built directly from the latest commits to the repository."
  },
  {
    "title": "Debugging · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/debugging",
    "html": "Guide\nGoing Further\nDebugging\n\nIn Nuxt 3, you can get started with debugging your application directly in the browser as well as in your IDE.\n\nSourcemaps\n\nSourcemaps are enabled for your server build by default, and for the client build in dev mode, but you can enable them more specifically in your configuration.\n\nexport default defineNuxtConfig({\n\n  // or sourcemap: true\n\n  sourcemap: {\n\n    server: true,\n\n    client: true\n\n  }\n\n})\n\nDebugging in Your IDE\n\nIt is possible to debug your Nuxt app in your IDE while you are developing it.\n\nExample VS Code Debug Configuration\n\nYou may need to update the config below with a path to your web browser. For more information, visit the VS Code documentation about debug configuration.\n\n{\n\n  // Use IntelliSense to learn about possible attributes.\n\n  // Hover to view descriptions of existing attributes.\n\n  \"version\": \"0.2.0\",\n\n  \"configurations\": [\n\n    {\n\n      \"type\": \"chrome\",\n\n      \"request\": \"launch\",\n\n      \"name\": \"client: chrome\",\n\n      \"url\": \"http://localhost:3000\",\n\n      \"webRoot\": \"${workspaceFolder}\"\n\n    },\n\n    {\n\n      \"type\": \"node\",\n\n      \"request\": \"launch\",\n\n      \"name\": \"server: nuxt\",\n\n      \"outputCapture\": \"std\",\n\n      \"program\": \"${workspaceFolder}/node_modules/nuxi/bin/nuxi.mjs\",\n\n      \"args\": [\n\n        \"dev\"\n\n      ],\n\n    }\n\n  ],\n\n  \"compounds\": [\n\n    {\n\n      \"name\": \"fullstack: nuxt\",\n\n      \"configurations\": [\n\n        \"server: nuxt\",\n\n        \"client: chrome\"\n\n      ]\n\n    }\n\n  ]\n\n}\n\n\nIf you prefer your usual browser extensions, add this to the chrome configuration above:\n\n\"userDataDir\": false,\n\nExample JetBrains IDEs Debug Configuration\n\nYou can also debug your Nuxt app in JetBrains IDEs such as IntelliJ IDEA, WebStorm, or PhpStorm.\n\nCreate a new file in your project root directory and name it nuxt.run.xml.\nOpen the nuxt.run.xml file and paste the following debug configuration:\n<component name=\"ProjectRunConfigurationManager\">\n\n  <configuration default=\"false\" name=\"client: chrome\" type=\"JavascriptDebugType\" uri=\"http://localhost:3000\" useFirstLineBreakpoints=\"true\">\n\n    <method v=\"2\" />\n\n  </configuration>\n\n\n\n  <configuration default=\"false\" name=\"server: nuxt\" type=\"NodeJSConfigurationType\" application-parameters=\"dev\" path-to-js-file=\"$PROJECT_DIR$/node_modules/nuxi/bin/nuxi.mjs\" working-dir=\"$PROJECT_DIR$\">\n\n    <method v=\"2\" />\n\n  </configuration>\n\n\n\n  <configuration default=\"false\" name=\"fullstack: nuxt\" type=\"CompoundRunConfigurationType\">\n\n    <toRun name=\"client: chrome\" type=\"JavascriptDebugType\" />\n\n    <toRun name=\"server: nuxt\" type=\"NodeJSConfigurationType\" />\n\n    <method v=\"2\" />\n\n  </configuration>\n\n</component>\n\nOther IDEs\n\nIf you have another IDE and would like to contribute sample configuration, feel free to open a PR!\n\nCustom Routing\n\nIn Nuxt 3, your routing is defined by the structure of your files inside the pages directory. However, since it uses vue-router under the hood, Nuxt offers you several ways to add custom routes in your project.\n\nRuntime Config\n\nNuxt provides a runtime config API to expose configuration and secrets within your application."
  },
  {
    "title": "Authoring Nuxt Layers · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/layers",
    "html": "Guide\nGoing Further\nAuthoring Nuxt Layers\n\nNuxt provides a powerful system that allows you to extend the default files, configs, and much more.\n\nNuxt layers are a powerful feature that you can use to share and reuse partial Nuxt applications within a monorepo, or from a git repository or npm package. The layers structure is almost identical to a standard Nuxt application, which makes them easy to author and maintain.\n\n Read more in Docs > Getting Started > Layers.\n\nA minimal Nuxt layer directory should contain a nuxt.config.ts file to indicate it is a layer.\n\nbase/nuxt.config.ts\nexport default defineNuxtConfig({})\n\n\nAdditionally, certain other files in the layer directory will be auto-scanned and used by Nuxt for the project extending this layer.\n\ncomponents/* - Extend the default components\ncomposables/* - Extend the default composables\npages/* - Extend the default pages\nserver/* - Extend the default server endpoints & middleware\nutils/* - Extend the default utils\nnuxt.config.ts- Extend the default nuxt config\napp.config.ts - Extend the default app config\nBasic Example\nnuxt.config.ts\napp.vue\nbase/nuxt.config.ts\nbase/components/BaseComponent.vue\nexport default defineNuxtConfig({\n\n  extends: [\n\n    './base'\n\n  ]\n\n})\n\nIf you're interested in deepening your understanding about layers, consider examining a fully fleshed out nuxt.config.ts file on the Docus theme.\nStarter Template\n\nTo get started you can initialize a layer with the nuxt/starter/layer template. This will create a basic structure you can build upon. Execute this command within the terminal to get started:\n\nTerminal\nnpx nuxi init --template layer nuxt-layer\n\n\nFollow up on the README instructions for the next steps.\n\nCheck nuxt-themes/starter for a more opinionated starter for authoring Nuxt themes. It can be initialized with:\nTerminal\nnpx nuxi init --template gh:nuxt-themes/starter my-theme\n\nPublishing Layers\n\nYou can publish and share layers by either using a remote source or an npm package.\n\nGit Repository\n\nYou can use a git repository to share your Nuxt layer. Some examples:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  extends: [\n\n    'github:username/repoName',        // GitHub Remote Source\n\n    'github:username/repoName/base',   // GitHub Remote Source within /base directory\n\n    'github:username/repoName#dev',    // GitHub Remote Source from dev branch\n\n    'github:username/repoName#v1.0.0', // GitHub Remote Source from v1.0.0 tag\n\n    'gitlab:username/repoName',        // GitLab Remote Source example\n\n    'bitbucket:username/repoName',     // Bitbucket Remote Source example\n\n  ]\n\n})\n\nIf you want to extend a private remote source, you need to add the environment variable GIGET_AUTH=<token> to provide a token.\nCurrently, with git remote sources, if a layer has npm dependencies, you will need to manually install them in the target project. We are working on this to auto-install layer dependencies with git sources.\nnpm Package\n\nYou can publish Nuxt layers as an npm package that contains the files and dependencies you want to extend. This allows you to share your config with others, use it in multiple projects or use it privately.\n\nTo extend from an npm package, you need to make sure that the module is published to npm and installed in the user's project as a devDependency. Then you can use the module name to extend the current nuxt config:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  extends: [\n\n    // Node Module with scope\n\n    '@scope/moduleName',\n\n    // or just the module name\n\n    'moduleName'\n\n  ]\n\n})\n\n\nTo publish a layer directory as an npm package, you want to make sure that the package.json has the correct properties filled out. This will make sure that the files are included when the package is published.\n\npackage.json\n{\n\n  \"name\": \"my-theme\",\n\n  \"version\": \"1.0.0\",\n\n  \"type\": \"module\",\n\n  \"main\": \"./nuxt.config.ts\",\n\n  \"dependencies\": {},\n\n  \"devDependencies\": {\n\n    \"nuxt\": \"^3.0.0\"\n\n  }\n\n}\n\nMake sure any dependency imported in the layer is explicitly added to the dependencies. The nuxt dependency, and anything only used for testing the layer before publishing, should remain in the devDependencies field.\n\nNow you can proceed to publish the module to npm, either publicly or privately.\n\nWhen publishing the layer as a private npm package, you need to make sure you log in, to authenticate with npm to download the node module.\nTips\nRelative Paths and Aliases\n\nWhen importing using aliases (such as ~/ and @/) in a layer components and composables, note that aliases are resolved relative to the user's project paths. As a workaround, you can use relative paths to import them. We are working on a better solution for named layer aliases.\n\nAlso when using relative paths in nuxt.config file of a layer, (with exception of nested extends) they are resolved relative to user's project instead of the layer. As a workaround, use full resolved paths in nuxt.config:\n\nnuxt.config.ts\nimport { fileURLToPath } from 'url'\n\nimport { dirname, join } from 'path'\n\n\n\nconst currentDir = dirname(fileURLToPath(import.meta.url))\n\n\n\nexport default defineNuxtConfig({\n\n  css: [\n\n    join(currentDir, './assets/main.css')\n\n  ]\n\n})\n\nMulti-Layer Support for Nuxt Modules\n\nYou can use the internal array nuxt.options._layers to support custom multi-layer handling for your modules.\n\nmodules/my-module.ts\nexport default defineNuxtModule({\n\n  setup(_options, nuxt) {\n\n    for (const layer of nuxt.options._layers) {\n\n      // You can check for a custom directory existence to extend for each layer\n\n      console.log('Custom extension for', layer.cwd, layer.config)\n\n    }\n\n  }\n\n})\n\n\nNotes:\n\nEarlier items in the _layers array have higher priority and override later ones\nThe user's project is the first item in the _layers array\nGoing Deeper\n\nConfiguration loading and extends support is handled by unjs/c12, merged using unjs/defu and remote git sources are supported using unjs/giget. Check the docs and source code to learn more.\n\nCheckout our ongoing development to bring more improvements for layers support on GitHub.\n\nNuxtApp\n\nIn Nuxt 3, you can access runtime app context within composables, components and plugins.\n\nCustom Routing\n\nIn Nuxt 3, your routing is defined by the structure of your files inside the pages directory. However, since it uses vue-router under the hood, Nuxt offers you several ways to add custom routes in your project."
  },
  {
    "title": "NuxtApp · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/nuxt-app",
    "html": "Guide\nGoing Further\nNuxtApp\nSource\n\nIn Nuxt 3, you can access runtime app context within composables, components and plugins.\n\nIn Nuxt 3, you can access runtime app context within composables, components and plugins.\n\nIn Nuxt 2, this was referred to as Nuxt context.\nNuxt App Interface\nJump over the NuxtApp interface documentation.\nAccessing NuxtApp\n\nWithin composables, plugins and components you can access nuxtApp with useNuxtApp():\n\ncomposables/useMyComposable.ts\nexport function useMyComposable () {\n\n  const nuxtApp = useNuxtApp()\n\n  // access runtime nuxt app instance\n\n}\n\n\nPlugins also receive nuxtApp as the first argument for convenience.\n\n Read more in Docs > Guide > Directory Structure > Plugins.\nProviding Helpers\n\nYou can provide helpers to be usable across all composables and application. This usually happens within a Nuxt plugin.\n\nconst nuxtApp = useNuxtApp()\n\nnuxtApp.provide('hello', (name) => `Hello ${name}!`)\n\n\n\nconsole.log(nuxtApp.$hello('name')) // Prints \"Hello name!\"\n\nIt is possible to inject helpers by returning an object with a provide key in plugins.\nIn Nuxt 2 plugins, this was referred to as inject function.\n\nNuxt Kit\n\n@nuxt/kit provides features for module authors.\n\nAuthoring Nuxt Layers\n\nNuxt provides a powerful system that allows you to extend the default files, configs, and much more."
  },
  {
    "title": "Nuxt Kit · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/kit",
    "html": "Guide\nGoing Further\nNuxt Kit\n\n@nuxt/kit provides features for module authors.\n\nNuxt Kit provides composable utilities to make interacting with Nuxt Hooks, the Nuxt Interface and developing Nuxt Modules super easy.\n\nDiscover all Nuxt Kit utilities.\nUsage\nInstall Dependency\n\nYou can install the latest Nuxt Kit by adding it to the dependencies section of your package.json. However, please consider always explicitly installing the @nuxt/kit package even if it is already installed by Nuxt.\n\npackage.json\n{\n\n  \"dependencies\": {\n\n    \"@nuxt/kit\": \"npm:@nuxt/kit-nightly@latest\"\n\n  }\n\n}\n\nImport Kit Utilities\ntest.mjs\nimport { useNuxt } from '@nuxt/kit'\n\n Read more in Docs > API > Kit.\nNuxt Kit utilities are only available for modules and not meant to be imported in runtime (components, Vue composables, pages, plugins, or server routes).\n\nNuxt Kit is an esm-only package meaning that you cannot require('@nuxt/kit'). As a workaround, use dynamic import in the CommonJS context:\n\ntest.cjs\n// This does NOT work!\n\n// const kit = require('@nuxt/kit')\n\nasync function main() {\n\n  const kit = await import('@nuxt/kit')\n\n}\n\nmain()\n\n\nModule Author Guide\n\nLearn how to create a Nuxt Module to integrate, enhance or extend any Nuxt applications.\n\nNuxtApp\n\nIn Nuxt 3, you can access runtime app context within composables, components and plugins."
  },
  {
    "title": "Lifecycle Hooks · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/hooks",
    "html": "Guide\nGoing Further\nLifecycle Hooks\n\nNuxt provides a powerful hooking system to expand almost every aspect using hooks.\n\nThe hooking system is powered by unjs/hookable.\nNuxt Hooks (Build Time)\n\nThese hooks are available for Nuxt Modules and build context.\n\nWithin nuxt.config\nnuxt.config\nexport default defineNuxtConfig({\n\n  hooks: {\n\n    close: () => { }\n\n  }\n\n})\n\nWithin Nuxt Modules\nimport { defineNuxtModule } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup (options, nuxt) {\n\n    nuxt.hook('close', async () => { })\n\n  }\n\n})\n\nExplore all available Nuxt hooks.\nApp Hooks (Runtime)\n\nApp hooks can be mainly used by Nuxt Plugins to hook into rendering lifecycle but could also be used in Vue composables.\n\nplugins/test.ts\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  nuxtApp.hook('page:start', () => {\n\n    /* your code goes here */\n\n  })\n\n})\n\nExplore all available App hooks.\nServer Hooks (Runtime)\n\nThese hooks are available for server plugins to hook into Nitro's runtime behavior.\n\n~/server/plugins/test.ts\nexport default defineNitroPlugin((nitroApp) => {\n\n  nitroApp.hooks.hook('render:html', (html, { event }) => {\n\n    console.log('render:html', html)\n\n    html.bodyAppend.push('<hr>Appended by custom plugin')\n\n  })\n\n\n\n  nitroApp.hooks.hook('render:response', (response, { event }) => {\n\n    console.log('render:response', response)\n\n  })\n\n})\n\nLearn more about available Nitro lifecycle hooks.\nAdditional Hooks\n\nYou can add additional hooks by augmenting the types provided by Nuxt. This can be useful for modules.\n\nimport { HookResult } from \"@nuxt/schema\";\n\n\n\ndeclare module '#app' {\n\n  interface RuntimeNuxtHooks {\n\n    'your-nuxt-runtime-hook': () => HookResult\n\n  }\n\n  interface NuxtHooks {\n\n    'your-nuxt-hook': () => HookResult\n\n  }\n\n}\n\n\n\ndeclare module 'nitropack' {\n\n  interface NitroRuntimeHooks {\n\n    'your-nitro-hook': () => void;\n\n  }\n\n}\n\n\nHow Nuxt Works?\n\nNuxt is a minimal but highly customizable framework to build web applications.\n\nModule Author Guide\n\nLearn how to create a Nuxt Module to integrate, enhance or extend any Nuxt applications."
  },
  {
    "title": "How Nuxt Works? · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/internals",
    "html": "Guide\nGoing Further\nHow Nuxt Works?\n\nNuxt is a minimal but highly customizable framework to build web applications.\n\nThis guide helps you better understand Nuxt internals to develop new solutions and module integrations on top of Nuxt.\n\nThe Nuxt Interface\n\nWhen you start Nuxt in development mode with nuxi dev or building a production application with nuxi build, a common context will be created, referred to as nuxt internally. It holds normalized options merged with nuxt.config file, some internal state, and a powerful hooking system powered by unjs/hookable allowing different components to communicate with each other. You can think of it as Builder Core.\n\nThis context is globally available to be used with Nuxt Kit composables. Therefore only one instance of Nuxt is allowed to run per process.\n\nTo extend the Nuxt interface and hook into different stages of the build process, we can use Nuxt Modules.\n\nFor more details, check out the source code.\n\nThe NuxtApp Interface\n\nWhen rendering a page in the browser or on the server, a shared context will be created, referred to as nuxtApp. This context keeps vue instance, runtime hooks, and internal states like ssrContext and payload for hydration. You can think of it as Runtime Core.\n\nThis context can be accessed using useNuxtApp() composable within Nuxt plugins and <script setup> and vue composables. Global usage is possible for the browser but not on the server, to avoid sharing context between users.\n\nTo extend the nuxtApp interface and hook into different stages or access contexts, we can use Nuxt Plugins.\n\nCheck Nuxt App for more information about this interface.\n\nnuxtApp has the following properties:\n\nconst nuxtApp = {\n\n  vueApp, // the global Vue application: https://vuejs.org/api/application.html#application-api\n\n\n\n  versions, // an object containing Nuxt and Vue versions\n\n\n\n  // These let you call and add runtime NuxtApp hooks\n\n  // https://github.com/nuxt/nuxt/blob/main/packages/nuxt/src/app/nuxt.ts#L18\n\n  hooks,\n\n  hook,\n\n  callHook,\n\n\n\n  // Only accessible on server-side\n\n  ssrContext: {\n\n    url,\n\n    req,\n\n    res,\n\n    runtimeConfig,\n\n    noSSR,\n\n  },\n\n\n\n  // This will be stringified and passed from server to client\n\n  payload: {\n\n    serverRendered: true,\n\n    data: {},\n\n    state: {}\n\n  }\n\n\n\n  provide: (name: string, value: any) => void\n\n}\n\n\nFor more details, check out the source code.\n\nRuntime Context vs. Build Context\n\nNuxt builds and bundles project using Node.js but also has a runtime side.\n\nWhile both areas can be extended, that runtime context is isolated from build-time. Therefore, they are not supposed to share state, code, or context other than runtime configuration!\n\nnuxt.config and Nuxt Modules can be used to extend the build context, and Nuxt Plugins can be used to extend runtime.\n\nWhen building an application for production, nuxi build will generate a standalone build in the .output directory, independent of nuxt.config and Nuxt modules.\n\nExperimental Features\n\nEnable Nuxt experimental features to unlock new possibilities.\n\nLifecycle Hooks\n\nNuxt provides a powerful hooking system to expand almost every aspect using hooks."
  },
  {
    "title": "tsconfig.json · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/tsconfig",
    "html": "Guide\nDirectory Structure\ntsconfig.json\n\nNuxt generates a .nuxt/tsconfig.json file with sensible defaults and your aliases.\n\nNuxt automatically generates a .nuxt/tsconfig.json file with the resolved aliases you are using in your Nuxt project, as well as with other sensible defaults.\n\nYou can benefit from this by creating a tsconfig.json in the root of your project with the following content:\n\ntsconfig.json\n{\n\n  \"extends\": \"./.nuxt/tsconfig.json\"\n\n}\n\nAs you need to, you can customize the contents of this file. However, it is recommended that you don't overwrite target, module and moduleResolution.\nIf you need to customize your paths, this will override the auto-generated path aliases. Instead, we recommend that you add any path aliases you need to the alias property within your nuxt.config, where they will get picked up and added to the auto-generated tsconfig.\n\npackage.json\n\nThe package.json file contains all the dependencies and scripts for your application.\n\nExperimental Features\n\nEnable Nuxt experimental features to unlock new possibilities."
  },
  {
    "title": "Experimental Features · Nuxt Advanced",
    "url": "https://nuxt.com/docs/guide/going-further/experimental-features",
    "html": "Guide\nGoing Further\nExperimental Features\n\nEnable Nuxt experimental features to unlock new possibilities.\n\nThe Nuxt experimental features can be enabled in the Nuxt configuration file.\n\nInternally, Nuxt uses @nuxt/schema to define these experimental features. You can refer to the API documentation or the source code for more information.\n\nNote that these features are experimental and could be removed or modified in the future.\nasyncContext\n\nEnable native async context to be accessible for nested composables in Nuxt and in Nitro. This opens the possibility to use composables inside async composables and reduce the chance to get the Nuxt instance is unavailable error.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    asyncContext: true\n\n  }\n\n})\n\nSee full explanation on the GitHub pull-request.\nasyncEntry\n\nEnables generation of an async entry point for the Vue bundle, aiding module federation support.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    asyncEntry: true\n\n  }\n\n})\n\nexternalVue\n\nExternalizes vue, @vue/* and vue-router when building.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    externalVue: true\n\n  }\n\n})\n\nThis feature will likely be removed in a near future.\ntreeshakeClientOnly\n\nTree shakes contents of client-only components from server bundle.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    treeshakeClientOnly: true\n\n  }\n\n})\n\nemitRouteChunkError\n\nEmits app:chunkError hook when there is an error loading vite/webpack chunks. Default behavior is to perform a hard reload of the new route when a chunk fails to load.\n\nYou can disable automatic handling by setting this to false, or handle chunk errors manually by setting it to manual.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    emitRouteChunkError: 'automatic' // or 'manual' or false\n\n  }\n\n})\n\nrestoreState\n\nAllows Nuxt app state to be restored from sessionStorage when reloading the page after a chunk error or manual reloadNuxtApp() call.\n\nTo avoid hydration errors, it will be applied only after the Vue app has been mounted, meaning there may be a flicker on initial load.\n\nConsider carefully before enabling this as it can cause unexpected behavior, and consider providing explicit keys to useState as auto-generated keys may not match across builds.\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    restoreState: true\n\n  }\n\n})\n\ninlineRouteRules\n\nDefine route rules at the page level using defineRouteRules.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    inlineRouteRules: true\n\n  }\n\n})\n\n\nMatching route rules will be created, based on the page's path.\n\nRead more in defineRouteRules utility.\n Read more in Docs > Guide > Concepts > Rendering #hybrid Rendering.\ninlineSSRStyles\n\nInlines styles when rendering HTML. This is currently available only when using Vite. You can also pass a function that receives the path of a Vue component and returns a boolean indicating whether to inline the styles for that component.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    inlineSSRStyles: true // or a function to determine inlining\n\n  }\n\n})\n\nnoScripts\n\nDisables rendering of Nuxt scripts and JS resource hints. Can also be configured granularly within routeRules.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    noScripts: true\n\n  }\n\n})\n\nrenderJsonPayloads\n\nAllows rendering of JSON payloads with support for revivifying complex types.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    renderJsonPayloads: true\n\n  }\n\n})\n\nnoVueServer\n\nDisables Vue server renderer endpoint within Nitro.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    noVueServer: true\n\n  }\n\n})\n\npayloadExtraction\n\nEnables extraction of payloads of pages generated with nuxt generate.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    payloadExtraction: true\n\n  }\n\n})\n\nclientFallback\n\nEnables the experimental <NuxtClientFallback> component for rendering content on the client if there's an error in SSR.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    clientFallback: true\n\n  }\n\n})\n\ncrossOriginPrefetch\n\nEnables cross-origin prefetch using the Speculation Rules API.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    crossOriginPrefetch: true\n\n  }\n\n})\n\nRead more about the Speculation Rules API.\nviewTransition\n\nEnables View Transition API integration with client-side router.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    viewTransition: true\n\n  }\n\n})\n\n Read and edit a live example in https://stackblitz.com/edit/nuxt-view-transitions?file=app.vue.\nRead more about the View Transition API.\nwriteEarlyHints\n\nEnables writing of early hints when using node server.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    writeEarlyHints: true\n\n  }\n\n})\n\ncomponentIslands\n\nEnables experimental component islands support with <NuxtIsland> and .island.vue files.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    componentIslands: true // false or 'local+remote'\n\n  }\n\n})\n\n Read more in Docs > Guide > Directory Structure > Components #server Components.\nYou can follow the server components roadmap on GitHub.\nconfigSchema\n\nEnables config schema support.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    configSchema: true\n\n  }\n\n})\n\npolyfillVueUseHead\n\nAdds a compatibility layer for modules, plugins, or user code relying on the old @vueuse/head API.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    polyfillVueUseHead: false\n\n  }\n\n})\n\nrespectNoSSRHeader\n\nAllow disabling Nuxt SSR responses by setting the x-nuxt-no-ssr header.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    respectNoSSRHeader: false\n\n  }\n\n})\n\nlocalLayerAliases\n\nResolve ~, ~~, @ and @@ aliases located within layers with respect to their layer source and root directories.\n\nEnabled by default.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    localLayerAliases: true\n\n  }\n\n})\n\ntypedPages\n\nEnable the new experimental typed router using unplugin-vue-router.\n\nnuxt.config.ts\nexport defineNuxtConfig({\n\n  experimental: {\n\n    typedPages: true\n\n  }\n\n})\n\n\nOut of the box, this will enable typed usage of navigateTo, <NuxtLink>, router.push() and more.\n\nYou can even get typed params within a page by using const route = useRoute('route-name').\n\nwatcher\n\nSet an alternative watcher that will be used as the watching service for Nuxt.\n\nNuxt uses chokidar-granular by default, which will ignore top-level directories (like node_modules and .git) that are excluded from watching.\n\nYou can set this instead to parcel to use @parcel/watcher, which may improve performance in large projects or on Windows platforms.\n\nYou can also set this to chokidar to watch all files in your source directory.\n\nnuxt.config.ts\nexport defineNuxtConfig({ \n\n  experimental: { \n\n      watcher: 'chokidar-granular' // 'chokidar' or 'parcel' are also options\n\n  } \n\n})\n\n\ntsconfig.json\n\nNuxt generates a .nuxt/tsconfig.json file with sensible defaults and your aliases.\n\nHow Nuxt Works?\n\nNuxt is a minimal but highly customizable framework to build web applications."
  },
  {
    "title": "package.json · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/package",
    "html": "Guide\nDirectory Structure\npackage.json\n\nThe package.json file contains all the dependencies and scripts for your application.\n\nThe minimal package.json of your Nuxt application should looks like:\n\npackage.json\n{\n\n  \"name\": \"nuxt-app\",\n\n  \"private\": true,\n\n  \"type\": \"module\",\n\n  \"scripts\": {\n\n    \"build\": \"nuxt build\",\n\n    \"dev\": \"nuxt dev\",\n\n    \"generate\": \"nuxt generate\",\n\n    \"preview\": \"nuxt preview\",\n\n    \"postinstall\": \"nuxt prepare\"\n\n  },\n\n  \"devDependencies\": {\n\n    \"@nuxt/devtools\": \"latest\",\n\n    \"nuxt\": \"latest\",\n\n    \"vue\": \"latest\",\n\n    \"vue-router\": \"latest\"\n\n  }\n\n}\n\nRead more about the package.json file.\n\nnuxt.config.ts\n\nNuxt can be easily configured with a single nuxt.config file.\n\ntsconfig.json\n\nNuxt generates a .nuxt/tsconfig.json file with sensible defaults and your aliases."
  },
  {
    "title": "app.vue · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/app",
    "html": "Guide\nDirectory Structure\napp.vue\n\nThe app.vue file is the main component of your Nuxt application.\n\nMinimal Usage\n\nWith Nuxt 3, the pages/ directory is optional. If not present, Nuxt won't include vue-router dependency. This is useful when working on a landing page or an application that does not need routing.\n\napp.vue\n<template>\n\n  <h1>Hello World!</h1>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Hello World.\nUsage with Pages\n\nIf you have a pages/ directory, to display the current page, use the <NuxtPage> component:\n\napp.vue\n<template>\n\n  <div>\n\n    <NuxtLayout>\n\n      <NuxtPage/>\n\n    </NuxtLayout>\n\n  </div>\n\n</template>\n\nSince <NuxtPage> internally uses Vue's <Suspense> component, it cannot be set as a root element.\nRemember that app.vue acts as the main component of your Nuxt application. Anything you add to it (JS and CSS) will be global and included in every page.\nIf you want to have the possibility to customize the structure around the page between pages, check out the layouts/ directory.\n\napp.config.ts\n\nExpose reactive configuration within your application with the App Config file.\n\nnuxt.config.ts\n\nNuxt can be easily configured with a single nuxt.config file."
  },
  {
    "title": ".nuxtignore · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/nuxtignore",
    "html": "Guide\nDirectory Structure\n.nuxtignore\n\nThe .nuxtignore file lets Nuxt ignore files in your project’s root directory during the build phase.\n\nThe .nuxtignore file tells Nuxt to ignore files in your project’s root directory (rootDir) during the build phase.\n\nIt is subject to the same specification as .gitignore and .eslintignore files, in which each line is a glob pattern indicating which files should be ignored.\n\nYou can also configure ignoreOptions, ignorePrefix and ignore in your nuxt.config file.\nUsage\n.nuxtignore\n# ignore layout foo.vue\n\nlayouts/foo.vue\n\n# ignore layout files whose name ends with -ignore.vue\n\nlayouts/*-ignore.vue\n\n\n\n# ignore page bar.vue\n\npages/bar.vue\n\n# ignore page inside ignore folder\n\npages/ignore/*.vue\n\n\n\n# ignore route middleware files under foo folder except foo/bar.js\n\nmiddleware/foo/*.js\n\n!middleware/foo/bar.js\n\nMore details about the spec are in the gitignore documentation.\n\n.gitignore\n\nA .gitignore file specifies intentionally untracked files that git should ignore.\n\napp.config.ts\n\nExpose reactive configuration within your application with the App Config file."
  },
  {
    "title": "app.config.ts · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/app-config",
    "html": "Guide\nDirectory Structure\napp.config.ts\n\nExpose reactive configuration within your application with the App Config file.\n\nNuxt 3 provides an app.config config file to expose reactive configuration within your application with the ability to update it at runtime within lifecycle or using a nuxt plugin and editing it with HMR (hot-module-replacement).\n\nYou can easily provide runtime app configuration using app.config.ts file. It can have either of .ts, .js, or .mjs extensions.\n\napp.config.ts\nexport default defineAppConfig({\n\n  foo: 'bar'\n\n})\n\nDo not put any secret values inside app.config file. It is exposed to the user client bundle.\nUsage\n\nTo expose config and environment variables to the rest of your app, you will need to define configuration in app.config file.\n\napp.config.ts\nexport default defineAppConfig({\n\n  theme: {\n\n    primaryColor: '#ababab'\n\n  }\n\n})\n\n\nWhen adding theme to the app.config, Nuxt uses Vite or webpack to bundle the code. We can universally access theme both when server-rendering the page and in the browser using useAppConfig composable.\n\npages/index.vue\n<script setup>\n\nconst appConfig = useAppConfig()\n\n\n\nconsole.log(appConfig.theme)\n\n</script>\n\n\nWhen configuring a custom srcDir, make sure to place the app.config file at the root of the new srcDir path.\n\nTyping App Config\n\nNuxt tries to automatically generate a TypeScript interface from provided app config so you won't have to type it yourself.\n\nHowever, there are some cases where you might want to type it yourself. There are two possible things you might want to type.\n\nApp Config Input\n\nAppConfigInput might be used by module authors who are declaring what valid input options are when setting app config. This will not affect the type of useAppConfig().\n\nindex.d.ts\ndeclare module 'nuxt/schema' {\n\n  interface AppConfigInput {\n\n    /** Theme configuration */\n\n    theme?: {\n\n      /** Primary app color */\n\n      primaryColor?: string\n\n    }\n\n  }\n\n}\n\n\n\n// It is always important to ensure you import/export something when augmenting a type\n\nexport {}\n\nApp Config Output\n\nIf you want to type the result of calling useAppConfig(), then you will want to extend AppConfig.\n\nBe careful when typing AppConfig as you will overwrite the types Nuxt infers from your actually defined app config.\nindex.d.ts\ndeclare module 'nuxt/schema' {\n\n  interface AppConfig {\n\n    // This will entirely replace the existing inferred `theme` property\n\n    theme: {\n\n      // You might want to type this value to add more specific types than Nuxt can infer,\n\n      // such as string literal types\n\n      primaryColor?: 'red' | 'blue'\n\n    }\n\n  }\n\n}\n\n\n\n// It is always important to ensure you import/export something when augmenting a type\n\nexport {}\n\nMerging Strategy\n\nNuxt uses a custom merging strategy for the AppConfig within the layers of your application.\n\nThis strategy is implemented using a Function Merger, which allows defining a custom merging strategy for every key in app.config that has an array as value.\n\nThe Function Merger should only be used in the base app.config of your application.\n\nHere's an example of how you can use:\n\nlayer/app.config.ts\napp.config.ts\nexport default defineAppConfig({\n\n  // Default array value\n\n  array: ['hello'],\n\n})\n\n\n.nuxtignore\n\nThe .nuxtignore file lets Nuxt ignore files in your project’s root directory during the build phase.\n\napp.vue\n\nThe app.vue file is the main component of your Nuxt application."
  },
  {
    "title": ".gitignore · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/gitignore",
    "html": "Guide\nDirectory Structure\n.gitignore\n\nA .gitignore file specifies intentionally untracked files that git should ignore.\n\nA .gitignore file specifies intentionally untracked files that git should ignore.\n\n Read more in the git documentation.\n\nWe recommend having a .gitignore file that has at least the following entries present:\n\n.gitignore\n# Nuxt dev/build outputs\n\n.output\n\n.data\n\n.nuxt\n\n.nitro\n\n.cache\n\ndist\n\n\n\n# Node dependencies\n\nnode_modules\n\n\n\n# Logs\n\nlogs\n\n*.log\n\n\n\n# Misc\n\n.DS_Store\n\n\n\n# Local env files\n\n.env\n\n.env.*\n\n!.env.example\n\n\n.env\n\nA .env file specifies your build/dev-time environment variables.\n\n.nuxtignore\n\nThe .nuxtignore file lets Nuxt ignore files in your project’s root directory during the build phase."
  },
  {
    "title": ".env · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/env",
    "html": "Guide\nDirectory Structure\n.env\n\nA .env file specifies your build/dev-time environment variables.\n\nThis file should be added to your .gitignore file to avoid pushing secrets to your repository.\nDev, Build and Generate Time\n\nNuxt CLI has built-in dotenv support in development mode and when running nuxi build and nuxi generate.\n\nIn addition to any process environment variables, if you have a .env file in your project root directory, it will be automatically loaded at dev, build and generate time. Any environment variables set there will be accessible within your nuxt.config file and modules.\n\n.env\nMY_ENV_VARIABLE=hello\n\nNote that removing a variable from .env or removing the .env file entirely will not unset values that have already been set.\nCustom File\n\nIf you want to use a different file - for example, to use .env.local or .env.production - you can do so by passing the --dotenv flag when using nuxi.\n\nTerminal\nnpx nuxi dev --dotenv .env.local\n\n\nWhen updating .env in development mode, the Nuxt instance is automatically restarted to apply new values to the process.env.\n\nProduction Preview\n\nAfter your server is built, you are responsible for setting environment variables when you run the server.\n\nYour .env file will not be read at this point. How you do this is different for every environment.\n\nFor local production preview purpose, we recommend using nuxi preview since using this command, the .env file will be loaded into process.env for convenience. Note that this command requires dependencies to be installed in the package directory.\n\nOr you could pass the environment variables as arguments using the terminal. For example, on Linux or macOS:\n\nTerminal\nDATABASE_HOST=mydatabaseconnectionstring node .output/server/index.mjs\n\n\nNote that for a purely static site, it is not possible to set runtime configuration config after your project is prerendered.\n\n Read more in Docs > Guide > Going Further > Runtime Config.\nIf you want to use environment variables set at build time but do not care about updating these down the line (or only need to update them reactively within your app) then appConfig may be a better choice. You can define appConfig both within your nuxt.config (using environment variables) and also within an ~/app.config.ts file in your project.\n Read more in Docs > Guide > Directory Structure > App Config.\n\nutils\n\nUse the utils/ directory to auto-import your utility functions throughout your application.\n\n.gitignore\n\nA .gitignore file specifies intentionally untracked files that git should ignore."
  },
  {
    "title": "utils/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/utils",
    "html": "Guide\nDirectory Structure\nutils\n\nUse the utils/ directory to auto-import your utility functions throughout your application.\n\nThe main purpose of the utils/ directory is to allow a semantic distinction between your Vue composables and other auto-imported utility functions.\n\nUsage\n\nMethod 1: Using named export\n\nutils/index.ts\nexport const { format: formatNumber } = Intl.NumberFormat('en-GB', {\n\n  notation: 'compact',\n\n  maximumFractionDigits: 1\n\n})\n\n\nMethod 2: Using default export\n\nutils/random-entry.ts or utils/randomEntry.ts\n// It will be available as randomEntry() (camelCase of file name without extension)\n\nexport default function (arr: Array<any>) {\n\n  return arr[Math.floor(Math.random() * arr.length)]\n\n}\n\n\nYou can now use auto imported utility functions in .js, .ts and .vue files\n\napp.vue\n<template>\n\n  <p>{{ formatNumber(1234) }}</p>\n\n</template>\n\n Read more in Docs > Guide > Concepts > Auto Imports.\n Read and edit a live example in Docs > Examples > Features > Auto Imports.\nThe way utils/ auto-imports work and are scanned is identical to the composables/ directory.\nThese utils are only available within the Vue part of your app.\nOnly server/utils are auto-imported in the server/ directory.\n\nserver\n\nThe server/ directory is used to register API and server handlers to your application.\n\n.env\n\nA .env file specifies your build/dev-time environment variables."
  },
  {
    "title": "server/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/server",
    "html": "Guide\nDirectory Structure\nserver\n\nThe server/ directory is used to register API and server handlers to your application.\n\nNuxt automatically scans files inside these directories to register API and server handlers with Hot Module Replacement (HMR) support.\n\nDirectory structure\n-| server/\n\n---| api/\n\n-----| hello.ts      # /api/hello\n\n---| routes/\n\n-----| bonjour.ts    # /bonjour\n\n---| middleware/\n\n-----| log.ts        # log all requests\n\n\nEach file should export a default function defined with defineEventHandler() or eventHandler() (alias).\n\nThe handler can directly return JSON data, a Promise, or use event.node.res.end() to send a response.\n\nserver/api/hello.ts\nexport default defineEventHandler((event) => {\n\n  return {\n\n    hello: 'world'\n\n  }\n\n})\n\n\nYou can now universally call this API in your pages and components:\n\npages/index.vue\n<script setup lang=\"ts\">\n\nconst { data } = await useFetch('/api/hello')\n\n</script>\n\n\n\n<template>\n\n  <pre>{{ data }}</pre>\n\n</template>\n\nServer Routes\n\nFiles inside the ~/server/api are automatically prefixed with /api in their route.\n\nTo add server routes without /api prefix, put them into ~/server/routes directory.\n\nExample:\n\nserver/routes/hello.ts\nexport default defineEventHandler(() => 'Hello World!')\n\n\nGiven the example above, the /hello route will be accessible at http://localhost:3000/hello.\n\nNote that currently server routes do not support the full functionality of dynamic routes as pages do.\nServer Middleware\n\nNuxt will automatically read in any file in the ~/server/middleware to create server middleware for your project.\n\nMiddleware handlers will run on every request before any other server route to add or check headers, log requests, or extend the event's request object.\n\nMiddleware handlers should not return anything (nor close or respond to the request) and only inspect or extend the request context or throw an error.\n\nExamples:\n\nserver/middleware/log.ts\nexport default defineEventHandler((event) => {\n\n  console.log('New request: ' + getRequestURL(event))\n\n})\n\nserver/middleware/auth.ts\nexport default defineEventHandler((event) => {\n\n  event.context.auth = { user: 123 }\n\n})\n\nServer Plugins\n\nNuxt will automatically read any files in the ~/server/plugins directory and register them as Nitro plugins. This allows extending Nitro's runtime behavior and hooking into lifecycle events.\n\nExample:\n\nserver/plugins/nitroPlugin.ts\nexport default defineNitroPlugin((nitroApp) => {\n\n  console.log('Nitro plugin', nitroApp)\n\n})\n\n Read more in Nitro Plugins.\nServer Utilities\n\nServer routes are powered by unjs/h3 which comes with a handy set of helpers.\n\n Read more in Available H3 Request Helpers.\n\nYou can add more helpers yourself inside the ~/server/utils directory.\n\nFor example, you can define a custom handler utility that wraps the original handler and performs additional operations before returning the final response.\n\nExample:\n\nserver/utils/handler.ts\nimport type { EventHandler, EventHandlerRequest } from 'h3'\n\n\n\nexport const defineWrappedResponseHandler = <T extends EventHandlerRequest, D> (\n\n  handler: EventHandler<T, D>\n\n): EventHandler<T, D> =>\n\n  defineEventHandler<T>(async event => {\n\n    try {\n\n      // do something before the route handler\n\n      const response = await handler(event)\n\n      // do something after the route handler\n\n      return { response }\n\n    } catch (err) {\n\n      // Error handling\n\n      return { err }\n\n    }\n\n  })\n\nServer Types\nThis feature is available from Nuxt >= 3.5\n\nTo improve clarity within your IDE between the auto-imports from 'nitro' and 'vue', you can add a ~/server/tsconfig.json with the following content:\n\nserver/tsconfig.json\n{\n\n  \"extends\": \"../.nuxt/tsconfig.server.json\"\n\n}\n\n\nCurrently, these values won't be respected when type checking (nuxi typecheck), but you should get better type hints in your IDE.\n\nRecipes\nRoute Parameters\n\nServer routes can use dynamic parameters within brackets in the file name like /api/hello/[name].ts and be accessed via event.context.params.\n\nserver/api/hello/[name].ts\nexport default defineEventHandler((event) => {\n\n  const name = getRouterParam(event, 'name')\n\n\n\n  return `Hello, ${name}!`\n\n})\n\n\nYou can now universally call this API on /api/hello/nuxt and get Hello, nuxt!.\n\nMatching HTTP Method\n\nHandle file names can be suffixed with .get, .post, .put, .delete, ... to match request's HTTP Method.\n\nserver/api/test.get.ts\nexport default defineEventHandler(() => 'Test get handler')\n\nserver/api/test.post.ts\nexport default defineEventHandler(() => 'Test post handler')\n\n\nGiven the example above, fetching /test with:\n\nGET method: Returns Test get handler\nPOST method: Returns Test post handler\nAny other method: Returns 405 error\n\nYou can also use index.[method].ts inside a directory for structuring your code differently, this is useful to create API namespaces.\n\nserver/api/foo/index.get.ts\nserver/api/foo/index.post.ts\nserver/api/foo/bar.get.ts\nexport default defineEventHandler((event) => {\n\n  // handle GET requests for the `api/foo` endpoint\n\n})\n\nCatch-all Route\n\nCatch-all routes are helpful for fallback route handling.\n\nFor example, creating a file named ~/server/api/foo/[...].ts will register a catch-all route for all requests that do not match any route handler, such as /api/foo/bar/baz.\n\nserver/api/foo/[...].ts\nexport default defineEventHandler((event) => {\n\n  // event.context.path to get the route path: '/api/foo/bar/baz'\n\n  // event.context.params._ to get the route segment: 'bar/baz'\n\n  return `Default foo handler`\n\n})\n\n\nYou can set a name for the catch-all route by using ~/server/api/foo/[...slug].ts and access it via event.context.params.slug.\n\nserver/api/foo/[...slug].ts\nexport default defineEventHandler((event) => {\n\n  // event.context.params.slug to get the route segment: 'bar/baz'\n\n  return `Default foo handler`\n\n})\n\nBody Handling\nserver/api/submit.post.ts\nexport default defineEventHandler(async (event) => {\n\n  const body = await readBody(event)\n\n  return { body }\n\n})\n\n\nYou can now universally call this API using:\n\napp.vue\n<script setup>\n\nasync function submit() {\n\n  const { body } = await $fetch('/api/submit', {\n\n    method: 'post',\n\n    body: { test: 123 }\n\n  })\n\n}\n\n</script>\n\nWe are using submit.post.ts in the filename only to match requests with POST method that can accept the request body. When using readBody within a GET request, readBody will throw a 405 Method Not Allowed HTTP error.\nQuery Parameters\n\nSample query /api/query?foo=bar&baz=qux\n\nserver/api/query.get.ts\nexport default defineEventHandler((event) => {\n\n  const query = getQuery(event)\n\n\n\n  return { a: query.foo, b: query.baz }\n\n})\n\nError Handling\n\nIf no errors are thrown, a status code of 200 OK will be returned.\n\nAny uncaught errors will return a 500 Internal Server Error HTTP Error.\n\nTo return other error codes, throw an exception with createError:\n\nserver/api/validation/[id].ts\nexport default defineEventHandler((event) => {\n\n  const id = parseInt(event.context.params.id) as number\n\n\n\n  if (!Number.isInteger(id)) {\n\n    throw createError({\n\n      statusCode: 400,\n\n      statusMessage: 'ID should be an integer',\n\n    })\n\n  }\n\n  return 'All good'\n\n})\n\nStatus Codes\n\nTo return other status codes, use the setResponseStatus utility.\n\nFor example, to return 202 Accepted\n\nserver/api/validation/[id].ts\nexport default defineEventHandler((event) => {\n\n  setResponseStatus(event, 202)\n\n})\n\nRuntime Config\nserver/api/foo.ts\nnuxt.config.ts\n.env\nexport default defineEventHandler(async (event) => {\n\n  const config = useRuntimeConfig(event)\n\n\n\n  const repo = await $fetch('https://api.github.com/repos/nuxt/nuxt', {\n\n    headers: {\n\n      Authorization: `token ${config.githubToken}`\n\n    }\n\n  })\n\n\n\n  return repo\n\n})\n\nGiving the event as argument to useRuntimeConfig is optional, but it is recommended to pass it to get the runtime config overwritten by environment variables at runtime for server routes.\nRequest Cookies\nserver/api/cookies.ts\nexport default defineEventHandler((event) => {\n\n  const cookies = parseCookies(event)\n\n\n\n  return { cookies }\n\n})\n\nAdvanced Usage\nNitro Config\n\nYou can use nitro key in nuxt.config to directly set Nitro configuration.\n\nThis is an advanced option. Custom config can affect production deployments, as the configuration interface might change over time when Nitro is upgraded in semver-minor versions of Nuxt.\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  // https://nitro.unjs.io/config\n\n  nitro: {}\n\n})\n\n Read more in Docs > Guide > Concepts > Server Engine.\nNested Router\nserver/api/hello/[...slug].ts\nimport { createRouter, defineEventHandler, useBase } from 'h3'\n\n\n\nconst router = createRouter()\n\n\n\nrouter.get('/test', defineEventHandler(() => 'Hello World'))\n\n\n\nexport default useBase('/api/hello', router.handler)\n\nSending Streams\nThis is an experimental feature and is available in all environments.\nserver/api/foo.get.ts\nimport fs from 'node:fs'\n\nimport { sendStream } from 'h3'\n\n\n\nexport default defineEventHandler((event) => {\n\n  return sendStream(event, fs.createReadStream('/path/to/file'))\n\n})\n\nSending Redirect\nserver/api/foo.get.ts\nexport default defineEventHandler(async (event) => {\n\n  await sendRedirect(event, '/path/redirect/to', 302)\n\n})\n\nLegacy Handler or Middleware\nserver/api/legacy.ts\nexport default fromNodeMiddleware((req, res) => {\n\n  res.end('Legacy handler')\n\n})\n\nLegacy support is possible using unjs/h3, but it is advised to avoid legacy handlers as much as you can.\nserver/middleware/legacy.ts\nexport default fromNodeMiddleware((req, res, next) => {\n\n  console.log('Legacy middleware')\n\n  next()\n\n})\n\nNever combine next() callback with a legacy middleware that is async or returns a Promise.\nServer Storage\n\nNitro provides a cross-platform storage layer. In order to configure additional storage mount points, you can use nitro.storage, or server plugins.\n\nExample of adding a Redis storage:\n\nUsing nitro.storage:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  nitro: {\n\n    storage: {\n\n      redis: {\n\n        driver: 'redis',\n\n        /* redis connector options */\n\n        port: 6379, // Redis port\n\n        host: \"127.0.0.1\", // Redis host\n\n        username: \"\", // needs Redis >= 6\n\n        password: \"\",\n\n        db: 0, // Defaults to 0\n\n        tls: {} // tls/ssl\n\n      }\n\n    }\n\n  }\n\n})\n\n\nThen in your API handler:\n\nserver/api/storage/test.ts\nexport default defineEventHandler(async (event) => {\n\n  // List all keys with\n\n  const keys = await useStorage('redis').getKeys()\n\n\n\n  // Set a key with\n\n  await useStorage('redis').setItem('foo', 'bar')\n\n\n\n  // Remove a key with\n\n  await useStorage('redis').removeItem('foo')\n\n\n\n  return {}\n\n})\n\nRead more about Nitro Storage Layer.\n\nAlternatively, you can create a storage mount point using a server plugin and runtime config:\n\nserver/plugins/storage.ts\nnuxt.config.ts\nimport redisDriver from 'unstorage/drivers/redis'\n\n\n\nexport default defineNitroPlugin(() => {\n\n  const storage = useStorage()\n\n\n\n  // Dynamically pass in credentials from runtime configuration, or other sources\n\n  const driver = redisDriver({\n\n      base: 'redis',\n\n      host: useRuntimeConfig().redis.host,\n\n      port: useRuntimeConfig().redis.port,\n\n      /* other redis connector options */\n\n    })\n\n\n\n  // Mount driver\n\n  storage.mount('redis', driver)\n\n})\n\n\npublic\n\nThe public/ directory is used to serve your website's static assets.\n\nutils\n\nUse the utils/ directory to auto-import your utility functions throughout your application."
  },
  {
    "title": "node_modules/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/node_modules",
    "html": "Guide\nDirectory Structure\nnode_modules\n\nThe package manager stores the dependencies of your project in the node_modules/ directory.\n\nThe package manager (npm or yarn or pnpm or bun) creates this directory to store the dependencies of your project.\n\nThis directory should be added to your .gitignore file to avoid pushing the dependencies to your repository.\n\nmodules\n\nUse the modules/ directory to automatically register local modules within your application.\n\npages\n\nNuxt provides file-based routing to create routes within your web application."
  },
  {
    "title": "public/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/public",
    "html": "Guide\nDirectory Structure\npublic\n\nThe public/ directory is used to serve your website's static assets.\n\nFiles contained within the public/ directory are served at the root and are not modified by the build process. This is suitable for files that have to keep their names (e.g. robots.txt) or likely won't change (e.g. favicon.ico).\n\nDirectory structure\n-| public/\n\n---| favicon.ico\n\n---| og-image.png\n\n---| robots.txt\n\napp.vue\n<script setup>\n\nuseSeoMeta({\n\n  ogImage: '/og-image.png'\n\n})\n\n</script>\n\nThis is known as the static/ directory in Nuxt 2.\n\nplugins\n\nNuxt has a plugins system to use Vue plugins and more at the creation of your Vue application.\n\nserver\n\nThe server/ directory is used to register API and server handlers to your application."
  },
  {
    "title": "plugins/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/plugins",
    "html": "Guide\nDirectory Structure\nplugins\n\nNuxt has a plugins system to use Vue plugins and more at the creation of your Vue application.\n\nNuxt automatically reads the files in the plugins/ directory and loads them at the creation of the Vue application.\n\nAll plugins inside are auto-registered, you don't need not add them to your nuxt.config separately.\nYou can use .server or .client suffix in the file name to load a plugin only on the server or client side.\nRegistered Plugins\n\nOnly files at the top level of the directory (or index files within any subdirectories) will be auto-registered as plugins.\n\nDirectory sturcture\n-| plugins/\n\n---| foo.ts      // scanned\n\n---| bar/\n\n-----| baz.ts    // not scanned\n\n-----| foz.vue   // not scanned\n\n-----| index.ts  // currently scanned but deprecated\n\n\nOnly foo.ts and bar/index.ts would be registered.\n\nTo add plugins in subdirectories, you can use the plugins option in nuxt.config.ts:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  plugins: [\n\n    '~/plugins/bar/baz',\n\n    '~/plugins/bar/foz'\n\n  ]\n\n})\n\nCreating Plugins\n\nThe only argument passed to a plugin is nuxtApp.\n\nplugins/hello.ts\nexport default defineNuxtPlugin(nuxtApp => {\n\n  // Doing something with nuxtApp\n\n})\n\nObject Syntax Plugins\n\nIt is also possible to define a plugin using an object syntax, for more advanced use cases. For example:\n\nplugins/hello.ts\nexport default defineNuxtPlugin({\n\n  name: 'my-plugin',\n\n  enforce: 'pre', // or 'post'\n\n  async setup (nuxtApp) {\n\n    // this is the equivalent of a normal functional plugin\n\n  },\n\n  hooks: {\n\n    // You can directly register Nuxt app runtime hooks here\n\n    'app:created'() {\n\n      const nuxtApp = useNuxtApp()\n\n      // do something in the hook\n\n    }\n\n  },\n\n  env: {\n\n    // Set this value to `false` if you don't want the plugin to run when rendering server-only or island components.\n\n    islands: true\n\n  }\n\n})\n\nIf you are using the object-syntax, the properties may be statically analyzed in future to produce a more optimized build. So you should not define them at runtime.\nFor example, setting enforce: process.server ? 'pre' : 'post' would defeat any future optimization Nuxt is able to do for your plugins.\nRegistration Order\n\nYou can control the order in which plugins are registered by prefixing with 'alphabetical' numbering to the file names.\n\nDirectory structure\nplugins/\n\n | - 01.myPlugin.ts\n\n | - 02.myOtherPlugin.ts\n\n\nIn this example, 02.myOtherPlugin.ts will be able to access anything that was injected by 01.myPlugin.ts.\n\nThis is useful in situations where you have a plugin that depends on another plugin.\n\nIn case you're new to 'alphabetical' numbering, remember that filenames are sorted as strings, not as numeric values. For example, 10.myPlugin.ts would come before 2.myOtherPlugin.ts. This is why the example prefixes single digit numbers with 0.\nLoading Strategy\n\nBy default, Nuxt loads plugins sequentially. You can define a plugin as parallel so Nuxt won't wait the end of the plugin's execution before loading the next plugin.\n\nplugins/hello.ts\nexport default defineNuxtPlugin({\n\n  name: 'my-plugin',\n\n  parallel: true,\n\n  async setup (nuxtApp) {\n\n    // the next plugin will be executed immediately\n\n  }\n\n})\n\nUsing Composables\n\nYou can use composables as well as utils within Nuxt plugins:\n\nplugins/hello.ts\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  const foo = useFoo()\n\n})\n\n\nHowever, keep in mind there are some limitations and differences:\n\nIf a composable depends on another plugin registered later, it might not work.\nPlugins are called in order sequentially and before everything else. You might use a composable that depends on another plugin which has not been called yet.\nIf a composable depends on the Vue.js lifecycle, it won't work.\nNormally, Vue.js composables are bound to the current component instance while plugins are only bound to nuxtApp instance.\nProviding Helpers\n\nIf you would like to provide a helper on the NuxtApp instance, return it from the plugin under a provide key.\n\nplugins/hello.ts\nexport default defineNuxtPlugin(() => {\n\n  return {\n\n    provide: {\n\n      hello: (msg: string) => `Hello ${msg}!`\n\n    }\n\n  }\n\n})\n\n\nYou can then use the helper in your components:\n\ncomponents/Hello.vue\n<script setup lang=\"ts\">\n\n// alternatively, you can also use it here\n\nconst { $hello } = useNuxtApp()\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    {{ $hello('world') }}\n\n  </div>\n\n</template>\n\nNote that we highly recommend using composables instead of providing helpers to avoid polluting the global namespace and keep your main bundle entry small.\nTyping Plugins\n\nIf you return your helpers from the plugin, they will be typed automatically; you'll find them typed for the return of useNuxtApp() and within your templates.\n\nIf you need to use a provided helper within another plugin, you can call useNuxtApp() to get the typed version. But in general, this should be avoided unless you are certain of the plugins' order.\n\nFor advanced use-cases, you can declare the type of injected properties like this:\n\nindex.d.ts\ndeclare module '#app' {\n\n  interface NuxtApp {\n\n    $hello (msg: string): string\n\n  }\n\n}\n\n\n\ndeclare module 'vue' {\n\n  interface ComponentCustomProperties {\n\n    $hello (msg: string): string\n\n  }\n\n}\n\n\n\nexport {}\n\nIf you are using WebStorm, you may need to augment @vue/runtime-core until this issue is resolved.\nVue Plugins\n\nIf you want to use Vue plugins, like vue-gtag to add Google Analytics tags, you can use a Nuxt plugin to do so.\n\nFirst, install the Vue plugin dependency:\n\nyarn\nnpm\npnpm\nbun\nyarn add --dev vue-gtag-next\n\n\nThen create a plugin file:\n\nplugins/vue-gtag.client.ts\nimport VueGtag, { trackRouter } from 'vue-gtag-next'\n\n\n\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  nuxtApp.vueApp.use(VueGtag, {\n\n    property: {\n\n      id: 'GA_MEASUREMENT_ID'\n\n    }\n\n  })\n\n  trackRouter(useRouter())\n\n})\n\nVue Directives\n\nSimilarly, you can register a custom Vue directive in a plugin.\n\nplugins/my-directive.ts\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  nuxtApp.vueApp.directive('focus', {\n\n    mounted (el) {\n\n      el.focus()\n\n    },\n\n    getSSRProps (binding, vnode) {\n\n      // you can provide SSR-specific props here\n\n      return {}\n\n    }\n\n  })\n\n})\n\nIf you register a Vue directive, you must register it on both client and server side unless you are only using it when rendering one side. If the directive only makes sense from a client side, you can always move it to ~/plugins/my-directive.client.ts and provide a 'stub' directive for the server in ~/plugins/my-directive.server.ts.\n Read more in Custom Directives on Vue Docs.\n\npages\n\nNuxt provides file-based routing to create routes within your web application.\n\npublic\n\nThe public/ directory is used to serve your website's static assets."
  },
  {
    "title": "modules/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/modules",
    "html": "Guide\nDirectory Structure\nmodules\n\nUse the modules/ directory to automatically register local modules within your application.\n\nIt is a good place to place any local modules you develop while building your application.\n\nThe auto-registered files patterns are:\n\nmodules/*/index.ts\nmodules/*.ts\n\nYou don't need to add those local modules to your nuxt.config.ts separately.\n\nmodules/hello/index.ts\nmodules/hello/runtime/api-route.ts\n// `nuxt/kit` is a helper subpath import you can use when defining local modules\n\n// that means you do not need to add `@nuxt/kit` to your project's dependencies\n\nimport { createResolver, defineNuxtModule, addServerHandler } from 'nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  meta: {\n\n    name: 'hello'\n\n  },\n\n  setup () {\n\n    const { resolve } = createResolver(import.meta.url)\n\n\n\n    // Add an API route\n\n    addServerHandler({\n\n      route: '/api/hello',\n\n      handler: resolve('./runtime/api-route')\n\n    })\n\n  }\n\n})\n\n\nWhen starting Nuxt, the hello module will be registered and the /api/hello route will be available.\n\nLocal modules are registered in alphabetical order. You can change the order by adding a number to the front of each directory name:\n\nDirectory structure\nmodules/\n\n  1.first-module/\n\n    index.ts\n\n  2.second-module.ts\n\n Read more in Docs > Guide > Going Further > Modules.\n\nmiddleware\n\nNuxt provides middleware to run code before navigating to a particular route.\n\nnode_modules\n\nThe package manager stores the dependencies of your project in the node_modules/ directory."
  },
  {
    "title": "middleware/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/middleware",
    "html": "Guide\nDirectory Structure\nmiddleware\n\nNuxt provides middleware to run code before navigating to a particular route.\n\nNuxt provides a customizable route middleware framework you can use throughout your application, ideal for extracting code that you want to run before navigating to a particular route.\n\nThere are three kinds of route middleware:\n\nAnonymous (or inline) route middleware are defined directly within the page.\nNamed route middleware, placed in the middleware/ and automatically loaded via asynchronous import when used on a page.\nGlobal route middleware, placed in the middleware/ with a .global suffix and is run on every route change.\n\nThe first two kinds of route middleware can be defined in definePageMeta.\n\nName of middleware are normalized to kebab-case: myMiddleware becomes my-middleware.\nRoute middleware run within the Vue part of your Nuxt app. Despite the similar name, they are completely different from server middleware, which are run in the Nitro server part of your app.\nUsage\n\nRoute middleware are navigation guards that receive the current route and the next route as arguments.\n\nmiddleware/my-middleware.ts\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  if (to.params.id === '1') {\n\n    return abortNavigation()\n\n  }\n\n  // In a real app you would probably not redirect every route to `/`\n\n  // however it is important to check `to.path` before redirecting or you\n\n  // might get an infinite redirect loop\n\n  if (to.path !== '/') {\n\n    return navigateTo('/')\n\n  }\n\n})\n\n\nNuxt provides two globally available helpers that can be returned directly from the middleware.\n\nnavigateTo - Redirects to the given route\nabortNavigation - Aborts the navigation, with an optional error message.\n\nUnlike navigation guards from vue-router, a third next() argument is not passed, and redirect or route cancellation is handled by returning a value from the middleware.\n\nPossible return values are:\n\nnothing - does not block navigation and will move to the next middleware function, if any, or complete the route navigation\nreturn navigateTo('/') - redirects to the given path and will set the redirect code to 302 Found if the redirect happens on the server side\nreturn navigateTo('/', { redirectCode: 301 }) - redirects to the given path and will set the redirect code to 301 Moved Permanently if the redirect happens on the server side\nreturn abortNavigation() - stops the current navigation\nreturn abortNavigation(error) - rejects the current navigation with an error\n Read more in Docs > API > Utils > Navigate To.\n Read more in Docs > API > Utils > Abort Navigation.\nWe recommend using the helper functions above for performing redirects or stopping navigation. Other possible return values described in the vue-router docs may work but there may be breaking changes in future.\nMiddleware Order\n\nMiddleware runs in the following order:\n\nGlobal Middleware\nPage defined middleware order (if there are multiple middleware declared with the array syntax)\n\nFor example, assuming you have the following middleware and component:\n\nmiddleware/ directory\nmiddleware/\n\n--| analytics.global.ts\n\n--| setup.global.ts\n\n--| auth.ts\n\npages/profile.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  middleware: [\n\n    function (to, from) {\n\n      // Custom inline middleware\n\n    },\n\n    'auth',\n\n  ],\n\n});\n\n</script>\n\n\nYou can expect the middleware to be run in the following order:\n\nanalytics.global.ts\nsetup.global.ts\nCustom inline middleware\nauth.ts\nOrdering Global Middleware\n\nBy default, global middleware is executed alphabetically based on the filename.\n\nHowever, there may be times you want to define a specific order. For example, in the last scenario, setup.global.ts may need to run before analytics.global.ts. In that case, we recommend prefixing global middleware with 'alphabetical' numbering.\n\nDirectory structure\nmiddleware/\n\n--| 01.setup.global.ts\n\n--| 02.analytics.global.ts\n\n--| auth.ts\n\nIn case you're new to 'alphabetical' numbering, remember that filenames are sorted as strings, not as numeric values. For example, 10.new.global.ts would come before 2.new.global.ts. This is why the example prefixes single digit numbers with 0.\nWhen Middleware Runs\n\nIf your site is server-rendered or generated, middleware for the initial page will be executed both when the page is rendered and then again on the client. This might be needed if your middleware needs a browser environment, such as if you have a generated site, aggressively cache responses, or want to read a value from local storage.\n\nHowever, if you want to avoid this behaviour you can do so:\n\nmiddleware/example.ts\nexport default defineNuxtRouteMiddleware(to => {\n\n  // skip middleware on server\n\n  if (process.server) return\n\n  // skip middleware on client side entirely\n\n  if (process.client) return\n\n  // or only skip middleware on initial client load\n\n  const nuxtApp = useNuxtApp()\n\n  if (process.client && nuxtApp.isHydrating && nuxtApp.payload.serverRendered) return\n\n})\n\nAdding Middleware Dynamically\n\nIt is possible to add global or named route middleware manually using the addRouteMiddleware() helper function, such as from within a plugin.\n\nexport default defineNuxtPlugin(() => {\n\n  addRouteMiddleware('global-test', () => {\n\n    console.log('this global middleware was added in a plugin and will be run on every route change')\n\n  }, { global: true })\n\n\n\n  addRouteMiddleware('named-test', () => {\n\n    console.log('this named middleware was added in a plugin and would override any existing middleware of the same name')\n\n  })\n\n})\n\nExample\nDirectory Structure\n-| middleware/\n\n---| auth.ts\n\n\nIn your page file, you can reference this route middleware:\n\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  middleware: [\"auth\"]\n\n  // or middleware: 'auth'\n\n})\n\n</script>\n\n\nNow, before navigation to that page can complete, the auth route middleware will be run.\n\n Read and edit a live example in Docs > Examples > Routing > Middleware.\n\nlayouts\n\nNuxt provides a layouts framework to extract common UI patterns into reusable layouts.\n\nmodules\n\nUse the modules/ directory to automatically register local modules within your application."
  },
  {
    "title": "composables/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/composables",
    "html": "Guide\nDirectory Structure\ncomposables\n\nUse the composables/ directory to auto-import your Vue composables into your application.\n\nUsage\n\nMethod 1: Using named export\n\ncomposables/useFoo.ts\nexport const useFoo = () => {\n\n  return useState('foo', () => 'bar')\n\n}\n\n\nMethod 2: Using default export\n\ncomposables/use-foo.ts or composables/useFoo.ts\n// It will be available as useFoo() (camelCase of file name without extension)\n\nexport default function () {\n\n  return useState('foo', () => 'bar')\n\n}\n\n\nUsage: You can now use auto imported composable in .js, .ts and .vue files\n\napp.vue\n<script setup lang=\"ts\">\n\nconst foo = useFoo()\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    {{ foo }}\n\n  </div>\n\n</template>\n\n Read more in Docs > Guide > Concepts > Auto Imports.\n Read and edit a live example in Docs > Examples > Features > Auto Imports.\nTypes\n\nUnder the hood, Nuxt auto generates the file .nuxt/imports.d.ts to declare the types.\n\nBe aware that you have to run nuxi prepare, nuxi dev or nuxi build in order to let Nuxt generate the types.\n\nIf you create a composable without having the dev server running, TypeScript will throw an error, such as Cannot find name 'useBar'.\nExamples\nNested Composables\n\nYou can use a composable within another composable using auto imports:\n\ncomposables/test.ts\nexport const useFoo = () => {\n\n  const nuxtApp = useNuxtApp()\n\n  const bar = useBar()\n\n}\n\nAccess plugin injections\n\nYou can access plugin injections from composables:\n\ncomposables/test.ts\nexport const useHello = () => {\n\n  const nuxtApp = useNuxtApp()\n\n  return nuxtApp.$hello\n\n}\n\nHow Files Are Scanned\n\nNuxt only scans files at the top level of the composables/ directory, e.g.:\n\nDirectory Structure\n| composables/\n\n---| index.ts     // scanned\n\n---| useFoo.ts    // scanned\n\n-----| nested/\n\n-------| utils.ts // not scanned\n\n\nOnly composables/index.ts and composables/useFoo.ts would be searched for imports.\n\nTo get auto imports working for nested modules, you could either re-export them (recommended) or configure the scanner to include nested directories:\n\nExample: Re-export the composables you need from the composables/index.ts file:\n\ncomposables/index.ts\n// Enables auto import for this export\n\nexport { utils } from './nested/utils.ts'\n\n\nExample: Scan nested directories inside the composables/ folder:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    dirs: [\n\n      // Scan top-level modules\n\n      'composables',\n\n      // ... or scan modules nested one level deep with a specific name and file extension\n\n      'composables/*/index.{ts,js,mjs,mts}',\n\n      // ... or scan all modules within given directory\n\n      'composables/**'\n\n    ]\n\n  }\n\n})\n\n\ncomponents\n\nThe components/ directory is where you put all your Vue components.\n\ncontent\n\nUse the content/ directory to create a file-based CMS for your application."
  },
  {
    "title": "content/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/content",
    "html": "Guide\nDirectory Structure\ncontent\n\nUse the content/ directory to create a file-based CMS for your application.\n\nNuxt Content reads the content/ directory in your project and parses .md, .yml, .csv and .json files to create a file-based CMS for your application.\n\nRender your content with built-in components.\nQuery your content with a MongoDB-like API.\nUse your Vue components in Markdown files with the MDC syntax.\nAutomatically generate your navigation.\nLearn more in Nuxt Content documentation.\nEnable Nuxt Content\n\nInstall the @nuxt/content module in your project as well as adding it to your nuxt.config.ts with one command:\n\nTerminal\nnpx nuxi module add content\n\nCreate Content\n\nPlace your markdown files inside the content/ directory:\n\ncontent/index.md\n# Hello Content\n\n\nThe module automatically loads and parses them.\n\nRender Content\n\nTo render content pages, add a catch-all route using the <ContentDoc> component:\n\npages/[...slug].vue\n<template>\n\n  <main>\n\n    <!-- ContentDoc returns content for `$route.path` by default or you can pass a `path` prop -->\n\n    <ContentDoc />\n\n  </main>\n\n</template>\n\nDocumentation\nHead over to https://content.nuxt.com to learn more about the Content module features, such as how to build queries and use Vue components in your Markdown files with the MDC syntax.\n\ncomposables\n\nUse the composables/ directory to auto-import your Vue composables into your application.\n\nlayouts\n\nNuxt provides a layouts framework to extract common UI patterns into reusable layouts."
  },
  {
    "title": "layouts/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/layouts",
    "html": "Guide\nDirectory Structure\nlayouts\n\nNuxt provides a layouts framework to extract common UI patterns into reusable layouts.\n\nFor best performance, components placed in this directory will be automatically loaded via asynchronous import when used.\nEnable Layouts\n\nLayouts are enabled by adding <NuxtLayout> to your app.vue:\n\napp.vue\n<template>\n\n  <NuxtLayout>\n\n    <NuxtPage />\n\n  </NuxtLayout>\n\n</template>\n\n\nTo use a layout:\n\nSet a layout property in your page with definePageMeta.\nSet the name prop of <NuxtLayout>.\nThe layout name is normalized to kebab-case, so someLayout becomes some-layout.\nIf not layout is specified, layouts/default.vue will be used.\nIf you only have a single layout in your application, we recommend using app.vue instead.\nUnlike other components, your layouts must have a single root element to allow Nuxt to apply transitions between layout changes - and this root element cannot be a <slot />.\nDefault Layout\n\nAdd a ~/layouts/default.vue:\n\nlayouts/default.vue\n<template>\n\n  <div>\n\n    <p>Some default layout content shared across all pages</p>\n\n    <slot />\n\n  </div>\n\n</template>\n\n\nIn a layout file, the content of the page will be displayed in the <slot /> component.\n\nNamed Layout\nDirectory Structure\n-| layouts/\n\n---| default.vue\n\n---| custom.vue\n\n\nThen you can use the custom layout in your page:\n\npages/about.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  layout: 'custom'\n\n})\n\n</script>\n\nLearn more about definePageMeta.\n\nYou can directly override the default layout for all pages using the name property of <NuxtLayout>:\n\napp.vue\n<script setup lang=\"ts\">\n\n// You might choose this based on an API call or logged-in status\n\nconst layout = \"custom\";\n\n</script>\n\n\n\n<template>\n\n  <NuxtLayout :name=\"layout\">\n\n    <NuxtPage />\n\n  </NuxtLayout>\n\n</template>\n\n\nIf you have a layout in nested directories, the layout's name will be based on its own path directory and filename, with duplicate segments being removed.\n\nFile\tLayout Name\n~/layouts/desktop/default.vue\tdesktop-default\n~/layouts/desktop-base/base.vue\tdesktop-base\n~/layouts/desktop/index.vue\tdesktop\n\nFor clarity, we recommend that the layout's filename matches its name:\n\nFile\tLayout Name\n~/layouts/desktop/DesktopDefault.vue\tdesktop-default\n~/layouts/desktop-base/DesktopBase.vue\tdesktop-base\n~/layouts/desktop/Desktop.vue\tdesktop\n Read and edit a live example in Docs > Examples > Features > Layouts.\nChanging the Layout Dynamically\n\nYou can also use the setPageLayout helper to change the layout dynamically:\n\n<script setup lang=\"ts\">\n\nfunction enableCustomLayout () {\n\n  setPageLayout('custom')\n\n}\n\ndefinePageMeta({\n\n  layout: false,\n\n});\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <button @click=\"enableCustomLayout\">Update layout</button>\n\n  </div>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Features > Layouts.\nOverriding a Layout on a Per-page Basis\n\nIf you are using pages, you can take full control by setting layout: false and then using the <NuxtLayout> component within the page.\n\npages/index.vue\nlayouts/custom.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  layout: false,\n\n})\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <NuxtLayout name=\"custom\">\n\n      <template #header> Some header template content. </template>\n\n\n\n      The rest of the page\n\n    </NuxtLayout>\n\n  </div>\n\n</template>\n\nIf you use <NuxtLayout> within your pages, make sure it is not the root element (or disable layout/page transitions).\n\ncontent\n\nUse the content/ directory to create a file-based CMS for your application.\n\nmiddleware\n\nNuxt provides middleware to run code before navigating to a particular route."
  },
  {
    "title": "components/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/components",
    "html": "Guide\nDirectory Structure\ncomponents\n\nThe components/ directory is where you put all your Vue components.\n\nNuxt automatically imports any components in this directory (along with components that are registered by any modules you may be using).\n\nDirectory Structure\n| components/\n\n--| AppHeader.vue\n\n--| AppFooter.vue\n\napp.vue\n<template>\n\n  <div>\n\n    <AppHeader />\n\n    <NuxtPage />\n\n    <AppFooter />\n\n  </div>\n\n</template>\n\nComponent Names\n\nIf you have a component in nested directories such as:\n\nDirectory Structure\n| components/\n\n--| base/\n\n----| foo/\n\n------| Button.vue\n\n\n... then the component's name will be based on its own path directory and filename, with duplicate segments being removed. Therefore, the component's name will be:\n\n<BaseFooButton />\n\nFor clarity, we recommend that the component's filename matches its name. So, in the example above, you could rename Button.vue to be BaseFooButton.vue.\n\nIf you want to auto-import components based only on its name, not path, then you need to set pathPrefix option to false using extended form of the configuration object:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  components: [\n\n    {\n\n      path: '~/components',\n\n+     pathPrefix: false,\n\n    },\n\n  ],\n\n});\n\n\nThis registers the components using the same strategy as used in Nuxt 2. For example, ~/components/Some/MyComponent.vue will be usable as <MyComponent> and not <SomeMyComponent>.\n\nDynamic Components\n\nIf you want to use the Vue <component :is=\"someComputedComponent\"> syntax, you need to use the resolveComponent helper provided by Vue or import the component directly from #components and pass it into is prop.\n\nFor example:\n\npages/index.vue\n<script setup lang=\"ts\">\n\nimport { SomeComponent } from '#components'\n\n\n\nconst MyButton = resolveComponent('MyButton')\n\n</script>\n\n\n\n<template>\n\n  <component :is=\"clickable ? MyButton : 'div'\" />\n\n  <component :is=\"SomeComponent\" />\n\n</template>\n\nIf you are using resolveComponent to handle dynamic components, make sure not to insert anything but the name of the component, which must be a string and not a variable.\n\nAlternatively, though not recommended, you can register all your components globally, which will create async chunks for all your components and make them available throughout your application.\n\n  export default defineNuxtConfig({\n\n    components: {\n\n+     global: true,\n\n+     dirs: ['~/components']\n\n    },\n\n  })\n\n\nYou can also selectively register some components globally by placing them in a ~/components/global directory.\n\nThe global option can also be set per component directory.\nDynamic Imports\n\nTo dynamically import a component (also known as lazy-loading a component) all you need to do is add the Lazy prefix to the component's name. This is particularly useful if the component is not always needed.\n\nBy using the Lazy prefix you can delay loading the component code until the right moment, which can be helpful for optimizing your JavaScript bundle size.\n\npages/index.vue\n<script setup>\n\nconst show = ref(false)\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <h1>Mountains</h1>\n\n    <LazyMountainsList v-if=\"show\" />\n\n    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n\n  </div>\n\n</template>\n\nDirect Imports\n\nYou can also explicitly import components from #components if you want or need to bypass Nuxt's auto-importing functionality.\n\npages/index.vue\n<script setup lang=\"ts\">\n\nimport { NuxtLink, LazyMountainsList } from '#components'\n\n\n\nconst show = ref(false)\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <h1>Mountains</h1>\n\n    <LazyMountainsList v-if=\"show\" />\n\n    <button v-if=\"!show\" @click=\"show = true\">Show List</button>\n\n    <NuxtLink to=\"/\">Home</NuxtLink>\n\n  </div>\n\n</template>\n\nCustom Directories\n\nBy default, only the ~/components directory is scanned. If you want to add other directories, or change how the components are scanned within a subfolder of this directory, you can add additional directories to the configuration:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  components: [\n\n    // ~/calendar-module/components/event/Update.vue => <EventUpdate />\n\n    { path: '~/calendar-module/components' },\n\n\n\n    // ~/user-module/components/account/UserDeleteDialog.vue => <UserDeleteDialog />\n\n    { path: '~/user-module/components', pathPrefix: false },\n\n\n\n    // ~/components/special-components/Btn.vue => <SpecialBtn />\n\n    { path: '~/components/special-components', prefix: 'Special' },\n\n\n\n    // It's important that this comes last if you have overrides you wish to apply\n\n    // to sub-directories of `~/components`.\n\n    //\n\n    // ~/components/Btn.vue => <Btn />\n\n    // ~/components/base/Btn.vue => <BaseBtn />\n\n    '~/components'\n\n  ]\n\n})\n\nnpm Packages\n\nIf you want to auto-import components from an npm package, you can use addComponent in a local module to register them.\n\n~/modules/register-component.ts\napp.vue\nimport { addComponent, defineNuxtModule } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  setup() {\n\n    // import { MyComponent as MyAutoImportedComponent } from 'my-npm-package'\n\n    addComponent({\n\n      name: 'MyAutoImportedComponent',\n\n      export: 'MyComponent',\n\n      filePath: 'my-npm-package',\n\n    })\n\n  },\n\n})\n\nAny nested directories need to be added first as they are scanned in order.\nComponent Extensions\n\nBy default, any file with an extension specified in the extensions key of nuxt.config.ts is treated as a component. If you need to restrict the file extensions that should be registered as components, you can use the extended form of the components directory declaration and its extensions key:\n\nexport default defineNuxtConfig({\n\n  components: [\n\n    {\n\n      path: '~/components',\n\n+     extensions: ['.vue'],\n\n    }\n\n  ]\n\n})\n\nClient Components\n\nIf a component is meant to be rendered only client-side, you can add the .client suffix to your component.\n\nDirectory Structure\n| components/\n\n--| Comments.client.vue\n\npages/example.vue\n<template>\n\n  <div>\n\n    <!-- this component will only be rendered on client side -->\n\n    <Comments />\n\n  </div>\n\n</template>\n\nThis feature only works with Nuxt auto-imports and #components imports. Explicitly importing these components from their real paths does not convert them into client-only components.\n.client components are rendered only after being mounted. To access the rendered template using onMounted(), add await nextTick() in the callback of the onMounted() hook.\nServer Components\n\nServer components allow server-rendering individual components within your client-side apps. It's possible to use server components within Nuxt, even if you are generating a static site. That makes it possible to build complex sites that mix dynamic components, server-rendered HTML and even static chunks of markup.\n\nServer components can either be used on their own or paired with a client component.\n\nWatch Learn Vue video about Nuxt Server Components.\nRead Daniel Roe's guide to Nuxt server components\nStandalone server components\n\nStandalone server components will always be rendered on the server, also known as Islands components.\n\nWhen their props update, this will result in a network request that will update the rendered HTML in-place.\n\nServer components are currently experimental and in order to use them, you need to enable the 'component islands' feature in your nuxt.config:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  experimental: {\n\n    componentIslands: true\n\n  }\n\n})\n\n\nNow you can register server-only components with the .server suffix and use them anywhere in your application automatically.\n\nDirectory Structure\n| components/\n\n--| HighlightedMarkdown.server.vue\n\npages/example.vue\n<template>\n\n  <div>\n\n    <!--\n\n      this will automatically be rendered on the server, meaning your markdown parsing + highlighting\n\n      libraries are not included in your client bundle.\n\n     -->\n\n    <HighlightedMarkdown markdown=\"# Headline\" />\n\n  </div>\n\n</template>\n\n\nServer-only components use <NuxtIsland> under the hood, meaning that lazy prop and #fallback slot are both passed down to it.\n\nServer Component Context\n\nWhen rendering a server-only or island component, <NuxtIsland> makes a fetch request which comes back with a NuxtIslandResponse. (This is an internal request if rendered on the server, or a request that you can see in the network tab if it's rendering on client-side navigation.)\n\nThis means:\n\nA new Vue app will be created server-side to create the NuxtIslandResponse.\nA new 'island context' will be created while rendering the component.\nYou can't access the 'island context' from the rest of your app and you can't access the context of the rest of your app from the island component. In other words, the server component or island is isolated from the rest of your app.\nYour plugins will run again when rendering the island, unless they have env: { islands: false } set (which you can do in an object-syntax plugin).\n\nWithin an island component, you can access its island context through nuxtApp.ssrContext.islandContext. Note that while island components are still marked as experimental, the format of this context may change.\n\nSlots can be interactive and are wrapped within a <div> with display: contents;\nPaired with a Client component\n\nIn this case, the .server + .client components are two 'halves' of a component and can be used in advanced use cases for separate implementations of a component on server and client side.\n\nDirectory Structure\n| components/\n\n--| Comments.client.vue\n\n--| Comments.server.vue\n\npages/example.vue\n<template>\n\n  <div>\n\n    <!-- this component will render Comments.server on the server then Comments.client once mounted in the browser -->\n\n    <Comments />\n\n  </div>\n\n</template>\n\n<ClientOnly> Component\n\nNuxt provides the <ClientOnly> component for purposely rendering a component only on client side.\n\npages/example.vue\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <ClientOnly>\n\n      <!-- this component will only be rendered on client-side -->\n\n      <Comments />\n\n    </ClientOnly>\n\n  </div>\n\n</template>\n\n\nUse a slot as fallback until <ClientOnly> is mounted on client side.\n\npages/example.vue\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <!-- This renders the \"span\" element on the server side -->\n\n    <ClientOnly fallbackTag=\"span\">\n\n      <!-- this component will only be rendered on client side -->\n\n      <Comments />\n\n      <template #fallback>\n\n        <!-- this will be rendered on server side -->\n\n        <p>Loading comments...</p>\n\n      </template>\n\n    </ClientOnly>\n\n  </div>\n\n</template>\n\n<DevOnly> Component\n\nNuxt provides the <DevOnly> component to render a component only during development.\n\nThe content will not be included in production builds and tree-shaken.\n\npages/example.vue\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <DevOnly>\n\n      <!-- this component will only be rendered during development -->\n\n      <LazyDebugBar />\n\n\n\n      <!-- if you ever require to have a replacement during production -->\n\n      <!-- be sure to test these using `nuxt preview` -->\n\n      <template #fallback>\n\n        <div><!-- empty div for flex.justify-between --></div>\n\n      </template>\n\n    </DevOnly>\n\n  </div>\n\n</template>\n\n<NuxtClientFallback> Component\n\nNuxt provides the <NuxtClientFallback> component to render its content on the client if any of its children trigger an error in SSR. You can specify a fallbackTag to make it render a specific tag if it fails to render on the server.\n\npages/example.vue\n<template>\n\n  <div>\n\n    <Sidebar />\n\n    <!-- this component will be rendered on client-side -->\n\n    <NuxtClientFallback fallback-tag=\"span\">\n\n      <Comments />\n\n      <BrokeInSSR />\n\n    </NuxtClientFallback>\n\n  </div>\n\n</template>\n\nLibrary Authors\n\nMaking Vue component libraries with automatic tree-shaking and component registration is super easy. ✨\n\nYou can use the components:dirs hook to extend the directory list without requiring user configuration in your Nuxt module.\n\nImagine a directory structure like this:\n\nDirectory Structure\n| node_modules/\n\n---| awesome-ui/\n\n------| components/\n\n---------| Alert.vue\n\n---------| Button.vue\n\n------| nuxt.js\n\n| pages/\n\n---| index.vue\n\n| nuxt.config.js\n\n\nThen in awesome-ui/nuxt.js you can use the components:dirs hook:\n\nimport { defineNuxtModule, createResolver } from '@nuxt/kit'\n\n\n\nexport default defineNuxtModule({\n\n  hooks: {\n\n    'components:dirs': (dirs) => {\n\n      const { resolve } = createResolver(import.meta.url)\n\n      // Add ./components dir to the list\n\n      dirs.push({\n\n        path: resolve('./components'),\n\n        prefix: 'awesome'\n\n      })\n\n    }\n\n  }\n\n})\n\n\nThat's it! Now in your project, you can import your UI library as a Nuxt module in your nuxt.config file:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  modules: ['awesome-ui/nuxt']\n\n})\n\n\n... and directly use the module components (prefixed with awesome-) in our pages/index.vue:\n\n<template>\n\n  <div>\n\n    My <AwesomeButton>UI button</AwesomeButton>!\n\n    <awesome-alert>Here's an alert!</awesome-alert>\n\n  </div>\n\n</template>\n\n\nIt will automatically import the components only if used and also support HMR when updating your components in node_modules/awesome-ui/components/.\n\n Read and edit a live example in Docs > Examples > Features > Auto Imports.\n\nassets\n\nThe assets/ directory is used to add all the website's assets that the build tool will process.\n\ncomposables\n\nUse the composables/ directory to auto-import your Vue composables into your application."
  },
  {
    "title": "TypeScript · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/typescript",
    "html": "Guide\nKey Concepts\nTypeScript\n\nNuxt 3 is fully typed and provides helpful shortcuts to ensure you have access to accurate type information when you are coding.\n\nType-checking\n\nBy default, Nuxt doesn't check types when you run nuxi dev or nuxi build, for performance reasons.\n\nTo enable type-checking at build or development time, install vue-tsc and typescript as development dependency:\n\nyarn\nnpm\npnpm\nbun\nyarn add --dev vue-tsc typescript\n\n\nThen, run nuxi typecheck command to check your types:\n\nTerminal\nnpx nuxi typecheck\n\n\nTo enable type-checking at build time, you can also use the typescript.typeCheck option in your nuxt.config file:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  typescript: {\n\n    typeCheck: true\n\n  }\n\n})\n\nAuto-generated Types\n\nWhen you run nuxi dev or nuxi build, Nuxt generates the following files for IDE type support (and type checking):\n\n.nuxt/nuxt.d.ts\n\nThis file contains the types of any modules you are using, as well as the key types that Nuxt 3 requires. Your IDE should recognize these types automatically.\n\nSome of the references in the file are to files that are only generated within your buildDir (.nuxt) and therefore for full typings, you will need to run nuxi dev or nuxi build.\n\n.nuxt/tsconfig.json\n\nThis file contains the recommended basic TypeScript configuration for your project, including resolved aliases injected by Nuxt or modules you are using, so you can get full type support and path auto-complete for aliases like ~/file or #build/file.\n\nRead more about how to extend this configuration.\n\nNitro also auto-generates types for API routes. Plus, Nuxt also generates types for globally available components and auto-imports from your composables, plus other core functionality.\nKeep in mind that all options extended from ./.nuxt/tsconfig.json will be overwritten by the options defined in your tsconfig.json. Overwriting options such as \"compilerOptions.paths\" with your own configuration will lead TypeScript to not factor in the module resolutions from ./.nuxt/tsconfig.json. This can lead to module resolutions such as #imports not being recognized.\n\nIn case you need to extend options provided by ./.nuxt/tsconfig.json further, you can use the alias property within your nuxt.config. nuxi will pick them up and extend ./.nuxt/tsconfig.json accordingly.\nStricter Checks\n\nTypeScript comes with certain checks to give you more safety and analysis of your program.\n\nOnce you’ve converted your codebase to TypeScript and felt familiar with it, you can start enabling these checks for greater safety (read more).\n\nIn order to enable strict type checking, you have to update nuxt.config:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  typescript: {\n\n    strict: true\n\n  }\n\n})\n\n\nES Modules\n\nNuxt 3 (and Bridge) uses Native ES Modules.\n\n.nuxt\n\nNuxt uses the .nuxt/ directory in development to generate your Vue application."
  },
  {
    "title": "assets/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/assets",
    "html": "Guide\nDirectory Structure\nassets\n\nThe assets/ directory is used to add all the website's assets that the build tool will process.\n\nThe directory usually contains the following types of files:\n\nStylesheets (CSS, SASS, etc.)\nFonts\nImages that won't be served from the public/ directory.\n\nIf you want to serve assets from the server, we recommend taking a look at the public/ directory.\n\n Read more in Docs > Getting Started > Assets.\n\n.output\n\nNuxt creates the .output/ directory when building your application for production.\n\ncomponents\n\nThe components/ directory is where you put all your Vue components."
  },
  {
    "title": ".output/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/output",
    "html": "Guide\nDirectory Structure\n.output\n\nNuxt creates the .output/ directory when building your application for production.\n\nThis directory should be added to your .gitignore file to avoid pushing the build output to your repository.\n\nUse this directory to deploy your Nuxt application to production.\n\n Read more in Docs > Getting Started > Deployment.\nYou should not touch any files inside since the whole directory will be re-created when running nuxt build.\n\n.nuxt\n\nNuxt uses the .nuxt/ directory in development to generate your Vue application.\n\nassets\n\nThe assets/ directory is used to add all the website's assets that the build tool will process."
  },
  {
    "title": ".nuxt/ · Nuxt Directory Structure",
    "url": "https://nuxt.com/docs/guide/directory-structure/nuxt",
    "html": "Guide\nDirectory Structure\n.nuxt\n\nNuxt uses the .nuxt/ directory in development to generate your Vue application.\n\nThis directory should be added to your .gitignore file to avoid pushing the dev build output to your repository.\n\nThis directory is interesting if you want to learn more about the files Nuxt generates based on your directory structure.\n\nNuxt also provides a Virtual File System (VFS) for modules to add templates to this directory without writing them to disk.\n\nYou can explore the generated files by opening the Nuxt DevTools in development mode and navigating to the Virtual Files tab.\n\nYou should not touch any files inside since the whole directory will be re-created when running nuxt dev.\n\nTypeScript\n\nNuxt 3 is fully typed and provides helpful shortcuts to ensure you have access to accurate type information when you are coding.\n\n.output\n\nNuxt creates the .output/ directory when building your application for production."
  },
  {
    "title": "Vue.js Development · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/vuejs-development",
    "html": "Guide\nKey Concepts\nVue.js Development\n\nNuxt uses Vue.js and adds features such as component auto-imports, file-based routing and composables for a SSR-friendly usage.\n\nNuxt integrates Vue 3, the new major release of Vue that enables new patterns for Nuxt users.\n\nWhile an in-depth knowledge of Vue is not required to use Nuxt, we recommend that you read the documentation and go through some of the examples on vuejs.org.\n\nNuxt has always used Vue as a frontend framework.\n\nWe chose to build Nuxt on top of Vue for these reasons:\n\nThe reactivity model of Vue, where a change in data automatically triggers a change in the interface.\nThe component-based templating, while keeping HTML as the common language of the web, enables intuitive patterns to keep your interface consistent, yet powerful.\nFrom small projects to large web applications, Vue keeps performing well at scale to ensure that your application keeps delivering value to your users.\nVue with Nuxt\nSingle File Components\n\nVue’s single-file components (SFC or *.vue files) encapsulate the markup (<template>), logic (<script>) and styling (<style>) of a Vue component. Nuxt provides a zero-config experience for SFCs with Hot Module Replacement that offers a seamless developer experience.\n\nAuto-imports\n\nEvery Vue component created in the components/ directory of a Nuxt project will be available in your project without having to import it. If a component is not used anywhere, your production’s code will not include it.\n\n Read more in Docs > Guide > Concepts > Auto Imports.\nVue Router\n\nMost applications need multiple pages and a way to navigate between them. This is called routing. Nuxt uses a pages/ directory and naming conventions to directly create routes mapped to your files using the official Vue Router library.\n\n Read more in Docs > Getting Started > Routing.\n Read and edit a live example in Docs > Examples > Features > Auto Imports.\nDifferences with Nuxt 2 / Vue 2\n\nNuxt 3 is based on Vue 3. The new major Vue version introduces several changes that Nuxt takes advantage of:\n\nBetter performance\nComposition API\nTypeScript support\nFaster Rendering\n\nThe Vue Virtual DOM (VDOM) has been rewritten from the ground up and allows for better rendering performance. On top of that, when working with compiled Single-File Components, the Vue compiler can further optimize them at build time by separating static and dynamic markup.\n\nThis results in faster first rendering (component creation) and updates, and less memory usage. In Nuxt 3, it enables faster server-side rendering as well.\n\nSmaller Bundle\n\nWith Vue 3 and Nuxt 3, a focus has been put on bundle size reduction. With version 3, most of Vue’s functionality, including template directives and built-in components, is tree-shakable. Your production bundle will not include them if you don’t use them.\n\nThis way, a minimal Vue 3 application can be reduced to 12 kb gzipped.\n\nComposition API\n\nThe only way to provide data and logic to components in Vue 2 was through the Options API, which allows you to return data and methods to a template with pre-defined properties like data and methods:\n\n<script>\n\nexport default {\n\n  data() {\n\n    return {\n\n      count: 0\n\n    }\n\n  },\n\n  methods: {\n\n    increment(){\n\n      this.count++\n\n    }\n\n  }\n\n}\n\n</script>\n\n\nThe Composition API introduced in Vue 3 is not a replacement of the Options API, but it enables better logic reuse throughout an application, and is a more natural way to group code by concern in complex components.\n\nUsed with the setup keyword in the <script> definition, here is the above component rewritten with Composition API and Nuxt 3’s auto-imported Reactivity APIs:\n\ncomponents/Counter.vue\n<script setup lang=\"ts\">\n\nconst count = ref(0)\n\nconst increment = () => count.value++\n\n</script>\n\n\nThe goal of Nuxt 3 is to provide a great developer experience around the Composition API.\n\nUse auto-imported Reactivity functions from Vue and Nuxt 3 built-in composables.\nWrite your own auto-imported reusable functions in the composables/ directory.\nTypeScript Support\n\nBoth Vue 3 and Nuxt 3 are written in TypeScript. A fully typed codebase prevents mistakes and documents APIs usage. This doesn’t mean that you have to write your application in TypeScript to take advantage of it. With Nuxt 3, you can opt-in by renaming your file from .js to .ts , or add <script setup lang=\"ts\"> in a component.\n\nRead the details about TypeScript in Nuxt 3\n\nAuto-imports\n\nNuxt auto-imports components, composables, helper functions and Vue APIs.\n\nRendering Modes\n\nLearn about the different rendering modes available in Nuxt."
  },
  {
    "title": "ES Modules · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/esm",
    "html": "Guide\nKey Concepts\nES Modules\n\nNuxt 3 (and Bridge) uses Native ES Modules.\n\nThis guide helps explain what ES Modules are and how to make a Nuxt app (or upstream library) compatible with ESM.\n\nBackground\nCommonJS Modules\n\nCommonJS (CJS) is a format introduced by Node.js that allows sharing functionality between isolated JavaScript modules (read more). You might be already familiar with this syntax:\n\nconst a = require('./a')\n\n\n\nmodule.exports.a = a\n\n\nBundlers like webpack and Rollup support this syntax and allow you to use modules written in CommonJS in the browser.\n\nESM Syntax\n\nMost of the time, when people talk about ESM vs CJS, they are talking about a different syntax for writing modules.\n\nimport a from './a'\n\n\n\nexport { a }\n\n\nBefore ECMAScript Modules (ESM) became a standard (it took more than 10 years!), tooling like webpack and even languages like TypeScript started supporting so-called ESM syntax. However, there are some key differences with actual spec; here's a helpful explainer.\n\nWhat is 'Native' ESM?\n\nYou may have been writing your app using ESM syntax for a long time. After all, it's natively supported by the browser, and in Nuxt 2 we compiled all the code you wrote to the appropriate format (CJS for server, ESM for browser).\n\nWhen adding modules to your package, things were a little different. A sample library might expose both CJS and ESM versions, and let us pick which one we wanted:\n\n{\n\n  \"name\": \"sample-library\",\n\n  \"main\": \"dist/sample-library.cjs.js\",\n\n  \"module\": \"dist/sample-library.esm.js\"\n\n}\n\n\nSo in Nuxt 2, the bundler (webpack) would pull in the CJS file ('main') for the server build and use the ESM file ('module') for the client build.\n\nHowever, in recent Node.js LTS releases, it is now possible to use native ESM module within Node.js. That means that Node.js itself can process JavaScript using ESM syntax, although it doesn't do it by default. The two most common ways to enable ESM syntax are:\n\nset type: 'module' within your package.json and keep using .js extension\nuse the .mjs file extensions (recommended)\n\nThis is what we do for Nuxt Nitro; we output a .output/server/index.mjs file. That tells Node.js to treat this file as a native ES module.\n\nWhat Are Valid Imports in a Node.js Context?\n\nWhen you import a module rather than require it, Node.js resolves it differently. For example, when you import sample-library, Node.js will look not for the main but for the exports or module entry in that library's package.json.\n\nThis is also true of dynamic imports, like const b = await import('sample-library').\n\nNode supports the following kinds of imports (see docs):\n\nfiles ending in .mjs - these are expected to use ESM syntax\nfiles ending in .cjs - these are expected to use CJS syntax\nfiles ending in .js - these are expected to use CJS syntax unless their package.json has type: 'module'\nWhat Kinds of Problems Can There Be?\n\nFor a long time module authors have been producing ESM-syntax builds but using conventions like .esm.js or .es.js, which they have added to the module field in their package.json. This hasn't been a problem until now because they have only been used by bundlers like webpack, which don't especially care about the file extension.\n\nHowever, if you try to import a package with an .esm.js file in a Node.js ESM context, it won't work, and you'll get an error like:\n\nTerminal\n(node:22145) Warning: To load an ES module, set \"type\": \"module\" in the package.json or use the .mjs extension.\n\n/path/to/index.js:1\n\n\n\nexport default {}\n\n^^^^^^\n\n\n\nSyntaxError: Unexpected token 'export'\n\n    at wrapSafe (internal/modules/cjs/loader.js:1001:16)\n\n    at Module._compile (internal/modules/cjs/loader.js:1049:27)\n\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10)\n\n    ....\n\n    at async Object.loadESM (internal/process/esm_loader.js:68:5)\n\n\nYou might also get this error if you have a named import from an ESM-syntax build that Node.js thinks is CJS:\n\nTerminal\nfile:///path/to/index.mjs:5\n\nimport { named } from 'sample-library'\n\n         ^^^^^\n\nSyntaxError: Named export 'named' not found. The requested module 'sample-library' is a CommonJS module, which may not support all module.exports as named exports.\n\n\n\nCommonJS modules can always be imported via the default export, for example using:\n\n\n\nimport pkg from 'sample-library';\n\nconst { named } = pkg;\n\n\n\n    at ModuleJob._instantiate (internal/modules/esm/module_job.js:120:21)\n\n    at async ModuleJob.run (internal/modules/esm/module_job.js:165:5)\n\n    at async Loader.import (internal/modules/esm/loader.js:177:24)\n\n    at async Object.loadESM (internal/process/esm_loader.js:68:5)\n\nTroubleshooting ESM Issues\n\nIf you encounter these errors, the issue is almost certainly with the upstream library. They need to fix their library to support being imported by Node.\n\nTranspiling Libraries\n\nIn the meantime, you can tell Nuxt not to try to import these libraries by adding them to build.transpile:\n\nexport default defineNuxtConfig({\n\n  build: {\n\n    transpile: ['sample-library']\n\n  }\n\n})\n\n\nYou may find that you also need to add other packages that are being imported by these libraries.\n\nAliasing Libraries\n\nIn some cases, you may also need to manually alias the library to the CJS version, for example:\n\nexport default defineNuxtConfig({\n\n  alias: {\n\n    'sample-library': 'sample-library/dist/sample-library.cjs.js'\n\n  }\n\n})\n\nDefault Exports\n\nA dependency with CommonJS format, can use module.exports or exports to provide a default export:\n\nnode_modules/cjs-pkg/index.js\nmodule.exports = { test: 123 }\n\n// or\n\nexports.test = 123\n\n\nThis normally works well if we require such dependency:\n\ntest.cjs\nconst pkg = require('cjs-pkg')\n\n\n\nconsole.log(pkg) // { test: 123 }\n\n\nNode.js in native ESM mode, typescript with esModuleInterop enabled and bundlers such as webpack, provide a compatibility mechanism so that we can default import such library. This mechanism is often referred to as \"interop require default\":\n\nimport pkg from 'cjs-pkg'\n\n\n\nconsole.log(pkg) // { test: 123 }\n\n\nHowever, because of the complexities of syntax detection and different bundle formats, there is always a chance that the interop default fails and we end up with something like this:\n\nimport pkg from 'cjs-pkg'\n\n\n\nconsole.log(pkg) // { default: { test: 123 } }\n\n\nAlso when using dynamic import syntax (in both CJS and ESM files), we always have this situation:\n\nimport('cjs-pkg').then(console.log) // [Module: null prototype] { default: { test: '123' } }\n\n\nIn this case, we need to manually interop the default export:\n\n// Static import\n\nimport { default as pkg } from 'cjs-pkg'\n\n\n\n// Dynamic import\n\nimport('cjs-pkg').then(m => m.default || m).then(console.log)\n\n\nFor handling more complex situations and more safety, we recommend and internally use mlly in Nuxt 3 that can preserve named exports.\n\nimport { interopDefault } from 'mlly'\n\n\n\n// Assuming the shape is { default: { foo: 'bar' }, baz: 'qux' }\n\nimport myModule from 'my-module'\n\n\n\nconsole.log(interopDefault(myModule)) // { foo: 'bar', baz: 'qux' }\n\nLibrary Author Guide\n\nThe good news is that it's relatively simple to fix issues of ESM compatibility. There are two main options:\n\nYou can rename your ESM files to end with .mjs.\nThis is the recommended and simplest approach. You may have to sort out issues with your library's dependencies and possibly with your build system, but in most cases, this should fix the problem for you. It's also recommended to rename your CJS files to end with .cjs, for the greatest explicitness.\nYou can opt to make your entire library ESM-only.\nThis would mean setting type: 'module' in your package.json and ensuring that your built library uses ESM syntax. However, you may face issues with your dependencies - and this approach means your library can only be consumed in an ESM context.\nMigration\n\nThe initial step from CJS to ESM is updating any usage of require to use import instead:\n\nBefore\nAfter\nmodule.exports = ...\n\n\n\nexports.hello = ...\n\nBefore\nAfter\nconst myLib = require('my-lib')\n\n\nIn ESM Modules, unlike CJS, require, require.resolve, __filename and __dirname globals are not available and should be replaced with import() and import.meta.filename.\n\nBefore\nAfter\nimport { join } from 'path'\n\n\n\nconst newDir = join(__dirname, 'new-dir')\n\nBefore\nAfter\nconst someFile = require.resolve('./lib/foo.js')\n\nBest Practices\nPrefer named exports rather than default export. This helps reduce CJS conflicts. (see Default exports section)\nAvoid depending on Node.js built-ins and CommonJS or Node.js-only dependencies as much as possible to make your library usable in Browsers and Edge Workers without needing Nitro polyfills.\nUse new exports field with conditional exports. (read more).\n{\n\n  \"exports\": {\n\n    \".\": {\n\n      \"import\": \"./dist/mymodule.mjs\"\n\n    }\n\n  }\n\n}\n\n\nModules\n\nNuxt provides a module system to extend the framework core and simplify integrations.\n\nTypeScript\n\nNuxt 3 is fully typed and provides helpful shortcuts to ensure you have access to accurate type information when you are coding."
  },
  {
    "title": "Auto-imports · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/auto-imports",
    "html": "Guide\nKey Concepts\nAuto-imports\n\nNuxt auto-imports components, composables, helper functions and Vue APIs.\n\nNuxt auto-imports components, composables and Vue.js APIs to use across your application without explicitly importing them.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst count = ref(1) // ref is auto-imported\n\n</script>\n\n\nThanks to its opinionated directory structure, Nuxt can auto-import your components/, composables/ and utils/.\n\nContrary to a classic global declaration, Nuxt preserves typings, IDEs completions and hints, and only includes what is used in your production code.\n\nIn the docs, every function that is not explicitly imported is auto-imported by Nuxt and can be used as-is in your code. You can find a reference for auto-imported components, composables and utilities in the API section.\nIn the server directory, Nuxt auto-imports exported functions and variables from server/utils/.\nYou can also auto-import functions exported from custom folders or third-party packages by configuring the imports section of your nuxt.config file.\nBuilt-in Auto-imports\n\nNuxt auto-imports functions and composables to perform data fetching, get access to the app context and runtime config, manage state or define components and plugins.\n\n<script setup lang=\"ts\">\n\n/* useAsyncData() and $fetch() are auto-imported */\n\nconst { data, refresh, pending } = await useFetch('/api/hello')\n\n</script>\n\n\nVue 3 exposes Reactivity APIs like ref or computed, as well as lifecycle hooks and helpers that are auto-imported by Nuxt.\n\n<script setup lang=\"ts\">\n\n/* ref() and computed() are auto-imported */\n\nconst count = ref(1)\n\nconst double = computed(() => count.value * 2)\n\n</script>\n\nVue and Nuxt composables\n\nWhen you are using the built-in Composition API composables provided by Vue and Nuxt, be aware that many of them rely on being called in the right context.\n\nDuring a component lifecycle, Vue tracks the temporary instance of the current component (and similarly, Nuxt tracks a temporary instance of nuxtApp) via a global variable, and then unsets it in same tick. This is essential when server rendering, both to avoid cross-request state pollution (leaking a shared reference between two users) and to avoid leakage between different components.\n\nThat means that (with very few exceptions) you cannot use them outside a Nuxt plugin, Nuxt route middleware or Vue setup function. On top of that, you must use them synchronously - that is, you cannot use await before calling a composable, except within <script setup> blocks, within the setup function of a component declared with defineNuxtComponent, in defineNuxtPlugin or in defineNuxtRouteMiddleware, where we perform a transform to keep the synchronous context even after the await.\n\nIf you get an error message like Nuxt instance is unavailable then it probably means you are calling a Nuxt composable in the wrong place in the Vue or Nuxt lifecycle.\n\nCheckout the asyncContext experimental feature to use Nuxt composables in async functions.\nSee the full explanation in this GitHub comment.\n\nExample of breaking code:\n\ncomposables/example.ts\n// trying to access runtime config outside a composable\n\nconst config = useRuntimeConfig()\n\n\n\nexport const useMyComposable = () => {\n\n  // accessing runtime config here\n\n}\n\n\nExample of working code:\n\ncomposables/example.ts\nexport const useMyComposable = () => {\n\n  // Because your composable is called in the right place in the lifecycle,\n\n  // useRuntimeConfig will also work\n\n  const config = useRuntimeConfig()\n\n\n\n  // ...\n\n}\n\nDirectory-based Auto-imports\n\nNuxt directly auto-imports files created in defined directories:\n\ncomponents/ for Vue components.\ncomposables/ for Vue composables.\nutils/ for helper functions and other utilities.\n Read and edit a live example in Docs > Examples > Features > Auto Imports.\nExplicit Imports\n\nNuxt exposes every auto-import with the #imports alias that can be used to make the import explicit if needed:\n\n<script setup lang=\"ts\">\n\nimport { ref, computed } from '#imports'\n\n\n\nconst count = ref(1)\n\nconst double = computed(() => count.value * 2)\n\n</script>\n\nDisabling Auto-imports\n\nIf you want to disable auto-importing composables and utilities, you can set imports.autoImport to false in the nuxt.config file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    autoImport: false\n\n  }\n\n})\n\n\nThis will disable auto-imports completely but it's still possible to use explicit imports from #imports.\n\nAuto-imported Components\n\nNuxt also automatically imports components from your ~/components directory, although this is configured separately from auto-importing composables and utility functions.\n\n Read more in Docs > Guide > Directory Structure > Components.\n\nTo disable auto-importing components from your own ~/components directory, you can set components.dirs to an empty array (though note that this will not affect components added by modules).\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  components: {\n\n    dirs: []\n\n  }\n\n})\n\nAuto-import from third-party packages\n\nNuxt also allows auto-importing from third-party packages.\n\nIf you are using the Nuxt module for that package, it is likely that the module has already configured auto-imports for that package.\n\nFor example, you could enable the auto-import of the useI18n composable from the vue-i18n package like this:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    presets: [\n\n      {\n\n        from: 'vue-i18n',\n\n        imports: ['useI18n']\n\n      }\n\n    ]\n\n  }\n\n})\n\n\nUpgrade Guide\n\nLearn how to upgrade to the latest Nuxt version.\n\nVue.js Development\n\nNuxt uses Vue.js and adds features such as component auto-imports, file-based routing and composables for a SSR-friendly usage."
  },
  {
    "title": "Rendering Modes · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/rendering",
    "html": "Guide\nKey Concepts\nRendering Modes\n\nLearn about the different rendering modes available in Nuxt.\n\nNuxt supports different rendering modes, universal rendering, client-side rendering but also offers hybrid-rendering and the possibility to render your application on CDN Edge Servers.\n\nBoth the browser and server can interpret JavaScript code to turn Vue.js components into HTML elements. This step is called rendering. Nuxt supports both universal and client-side rendering. The two approaches have benefits and downsides that we will cover.\n\nBy default, Nuxt uses universal rendering to provide better user experience, performance and to optimize search engine indexing, but you can switch rendering modes in one line of configuration.\n\nUniversal Rendering\n\nWhen the browser requests a URL with universal (server-side + client-side) rendering enabled, the server returns a fully rendered HTML page to the browser. Whether the page has been generated in advance and cached or is rendered on the fly, at some point, Nuxt has run the JavaScript (Vue.js) code in a server environment, producing an HTML document. Users immediately get the content of our application, contrary to client-side rendering. This step is similar to traditional server-side rendering performed by PHP or Ruby applications.\n\nTo not lose the benefits of the client-side rendering method, such as dynamic interfaces and pages transitions, the Client (browser) loads the JavaScript code that runs on the Server in the background once the HTML document has been downloaded. The browser interprets it again (hence Universal rendering) and Vue.js takes control of the document and enables interactivity.\n\nMaking a static page interactive in the browser is called \"Hydration\".\n\nUniversal rendering allows a Nuxt application to provide quick page load times while preserving the benefits of client-side rendering. Furthermore, as the content is already present in the HTML document, crawlers can index it without overhead.\n\nBenefits of server-side rendering:\n\nPerformance: Users can get immediate access to the page's content because browsers can display static content much faster than JavaScript-generated one. At the same time, Nuxt preserves the interactivity of a web application when the hydration process happens.\nSearch Engine Optimization: Universal rendering delivers the entire HTML content of the page to the browser as a classic server application. Web crawlers can directly index the page's content, which makes Universal rendering a great choice for any content that you want to index quickly.\n\nDownsides of server-side rendering:\n\nDevelopment constraints: Server and browser environments don't provide the same APIs, and it can be tricky to write code that can run on both sides seamlessly. Fortunately, Nuxt provides guidelines and specific variables to help you determine where a piece of code is executed.\nCost: A server needs to be running in order to render pages on the fly. This adds a monthly cost like any traditional server. However, the server calls are highly reduced thanks to universal rendering with the browser taking over on client-side navigation. A cost reduction is possible by leveraging edge-side-rendering.\n\nUniversal rendering is very versatile and can fit almost any use case, and is especially appropriate for any content-oriented websites: blogs, marketing websites, portfolios, e-commerce sites, and marketplaces.\n\nFor more examples about writing Vue code without hydration mismatch, see the Vue docs.\nWhen importing a library that relies on browser APIs and has side effects, make sure the component importing it is only called client-side. Bundlers do not treeshake imports of modules containing side effects.\nClient-Side Rendering\n\nOut of the box, a traditional Vue.js application is rendered in the browser (or client). Then, Vue.js generates HTML elements after the browser downloads and parses all the JavaScript code containing the instructions to create the current interface.\n\nBenefits of client-side rendering:\n\nDevelopment speed: When working entirely on the client-side, we don't have to worry about the server compatibility of the code, for example, by using browser-only APIs like the window object.\nCheaper: Running a server adds a cost of infrastructure as you would need to run on a platform that supports JavaScript. We can host Client-only applications on any static server with HTML, CSS, and JavaScript files.\nOffline: Because code entirely runs in the browser, it can nicely keep working while the internet is unavailable.\n\nDownsides of client-side rendering:\n\nPerformance: The user has to wait for the browser to download, parse and run JavaScript files. Depending on the network for the download part and the user's device for the parsing and execution, this can take some time and impact the user's experience.\nSearch Engine Optimization: Indexing and updating the content delivered via client-side rendering takes more time than with a server-rendered HTML document. This is related to the performance drawback we discussed, as search engine crawlers won't wait for the interface to be fully rendered on their first try to index the page. Your content will take more time to show and update in search results pages with pure client-side rendering.\n\nClient-side rendering is a good choice for heavily interactive web applications that don't need indexing or whose users visit frequently. It can leverage browser caching to skip the download phase on subsequent visits, such as SaaS, back-office applications, or online games.\n\nYou can enable client-side only rendering with Nuxt in your nuxt.config.ts:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  ssr: false\n\n})\n\nIf you do use ssr: false, you should also place an HTML file in ~/app/spa-loading-template.html with some HTML you would like to use to render a loading screen that will be rendered until your app is hydrated.\n Read more in SPA Loading Template.\nHybrid Rendering\n\nHybrid rendering allows different caching rules per route using Route Rules and decides how the server should respond to a new request on a given URL.\n\nPreviously every route/page of a Nuxt application and server must use the same rendering mode, universal or client-side. In various cases, some pages could be generated at build time, while others should be client-side rendered. For example, think of a content website with an admin section. Every content page should be primarily static and generated once, but the admin section requires registration and behaves more like a dynamic application.\n\nNuxt 3 includes route rules and hybrid rendering support. Using route rules you can define rules for a group of nuxt routes, change rendering mode or assign a cache strategy based on route!\n\nNuxt server will automatically register corresponding middleware and wrap routes with cache handlers using Nitro caching layer.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  routeRules: {\n\n    // Homepage pre-rendered at build time\n\n    '/': { prerender: true },\n\n    // Product page generated on-demand, revalidates in background\n\n    '/products/**': { swr: 3600 },\n\n    // Blog post generated on-demand once until next deploy\n\n    '/blog/**': { isr: true },\n\n    // Admin dashboard renders only on client-side\n\n    '/admin/**': { ssr: false },\n\n    // Add cors headers on API routes\n\n    '/api/**': { cors: true },\n\n    // Redirects legacy urls\n\n    '/old-page': { redirect: '/new-page' }\n\n  }\n\n})\n\nRoute Rules\n\nThe different properties you can use are the following:\n\nredirect: string - Define server-side redirects.\nssr: boolean - Disables server-side rendering for sections of your app and make them SPA-only with ssr: false\ncors: boolean - Automatically adds cors headers with cors: true - you can customize the output by overriding with headers\nheaders: object - Add specific headers to sections of your site - for example, your assets\nswr: number|boolean - Add cache headers to the server response and cache it on the server or reverse proxy for a configurable TTL (time to live). The node-server preset of Nitro is able to cache the full response. When the TTL expired, the cached response will be sent while the page will be regenerated in the background. If true is used, a stale-while-revalidate header is added without a MaxAge.\nisr: number|boolean - The behavior is the same as swr except that we are able to add the response to the CDN cache on platforms that support this (currently Netlify or Vercel). If true is used, the content persists until the next deploy inside the CDN.\nprerender:boolean - Prerenders routes at build time and includes them in your build as static assets\nexperimentalNoScripts: boolean - Disables rendering of Nuxt scripts and JS resource hints for sections of your site.\n\nWhenever possible, route rules will be automatically applied to the deployment platform's native rules for optimal performances (Netlify and Vercel are currently supported).\n\nNote that Hybrid Rendering is not available when using nuxt generate.\n\nExamples:\n\nNuxt Vercel ISR\n\nExample of a Nuxt application with hybrid rendering deployed on Vercel.\n\nEdge-Side Rendering\n\nEdge-Side Rendering (ESR) is a powerful feature introduced in Nuxt 3 that allows the rendering of your Nuxt application closer to your users via edge servers of a Content Delivery Network (CDN). By leveraging ESR, you can ensure improved performance and reduced latency, thereby providing an enhanced user experience.\n\nWith ESR, the rendering process is pushed to the 'edge' of the network - the CDN's edge servers. Note that ESR is more a deployment target than an actual rendering mode.\n\nWhen a request for a page is made, instead of going all the way to the original server, it's intercepted by the nearest edge server. This server generates the HTML for the page and sends it back to the user. This process minimizes the physical distance the data has to travel, reducing latency and loading the page faster.\n\nEdge-side rendering is possible thanks to Nitro, the server engine that powers Nuxt 3. It offers cross-platform support for Node.js, Deno, Cloudflare Workers, and more.\n\nThe current platforms where you can leverage ESR are:\n\nCloudflare Pages with zero configuration using the git integration and the nuxt build command\nLagon using the NITRO_PRESET=lagon npx nuxt build command\nVercel Edge Functions using the nuxt build command and NITRO_PRESET=vercel-edge environment variable\nNetlify Edge Functions using the nuxt build command and NITRO_PRESET=netlify-edge environment variable\n\nNote that Hybrid Rendering can be used when using Edge-Side Rendering with route rules.\n\nYou can explore open source examples deployed on some of the platform mentioned above:\n\nNuxt Todos Edge\n\nA todos application with user authentication, SSR and SQLite.\n\nAtinotes\n\nAn editable website with universal rendering based on CloudFlare KV.\n\nVue.js Development\n\nNuxt uses Vue.js and adds features such as component auto-imports, file-based routing and composables for a SSR-friendly usage.\n\nServer Engine\n\nNuxt 3 is powered by a new server engine: Nitro."
  },
  {
    "title": "Modules · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/modules",
    "html": "Guide\nKey Concepts\nModules\n\nNuxt provides a module system to extend the framework core and simplify integrations.\n\nExploring Nuxt Modules\n\nWhen developing production-grade applications with Nuxt you might find that the framework's core functionality is not enough. Nuxt can be extended with configuration options and plugins, but maintaining these customizations across multiple projects can be tedious, repetitive and time-consuming. On the other hand, supporting every project's needs out of the box would make Nuxt very complex and hard to use.\n\nThis is one of the reasons why Nuxt provides a module system that makes it possible to extend the core. Nuxt modules are async functions that sequentially run when starting Nuxt in development mode using nuxi dev or building a project for production with nuxi build. They can override templates, configure webpack loaders, add CSS libraries, and perform many other useful tasks.\n\nBest of all, Nuxt modules can be distributed in npm packages. This makes it possible for them to be reused across projects and shared with the community, helping create an ecosystem of high-quality add-ons.\n\nExplore Nuxt Modules\nAdd Nuxt Modules\n\nOnce you have installed the modules you can add them to your nuxt.config.ts file under the modules property. Module developers usually provide additional steps and details for usage.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  modules: [\n\n    // Using package name (recommended usage)\n\n    '@nuxtjs/example',\n\n\n\n    // Load a local module\n\n    './modules/example',\n\n\n\n    // Add module with inline-options\n\n    ['./modules/example', { token: '123' }]\n\n\n\n    // Inline module definition\n\n    async (inlineOptions, nuxt) => { }\n\n  ]\n\n})\n\nNuxt modules are now build-time-only, and the buildModules property used in Nuxt 2 is deprecated in favor of modules.\nCreate a Nuxt Module\n\nEveryone has the opportunity to develop modules and we cannot wait to see what you will build.\n\n Read more in Module Author Guide.\n\nServer Engine\n\nNuxt 3 is powered by a new server engine: Nitro.\n\nES Modules\n\nNuxt 3 (and Bridge) uses Native ES Modules."
  },
  {
    "title": "Server Engine · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/server-engine",
    "html": "Guide\nKey Concepts\nServer Engine\n\nNuxt 3 is powered by a new server engine: Nitro.\n\nWhile building Nuxt 3, we created a new server engine: Nitro.\n\nIt is shipped with many features:\n\nCross-platform support for Node.js, Browsers, service-workers and more.\nServerless support out-of-the-box.\nAPI routes support.\nAutomatic code-splitting and async-loaded chunks.\nHybrid mode for static + serverless sites.\nDevelopment server with hot module reloading.\nAPI Layer\n\nServer API endpoints and Middleware are added by Nitro that internally uses h3.\n\nKey features include:\n\nHandlers can directly return objects/arrays for an automatically-handled JSON response\nHandlers can return promises, which will be awaited (res.end() and next() are also supported)\nHelper functions for body parsing, cookie handling, redirects, headers and more\n\nCheck out the h3 docs for more information.\n\nLearn more about the API layer in the server/ directory.\nDirect API Calls\n\nNitro allows 'direct' calling of routes via the globally-available $fetch helper. This will make an API call to the server if run on the browser, but will directly call the relevant function if run on the server, saving an additional API call.\n\n$fetch API is using ofetch, with key features including:\n\nAutomatic parsing of JSON responses (with access to raw response if needed)\nRequest body and params are automatically handled, with correct Content-Type headers\n\nFor more information on $fetch features, check out ofetch.\n\nTyped API Routes\n\nWhen using API routes (or middleware), Nitro will generate typings for these routes as long as you are returning a value instead of using res.end() to send a response.\n\nYou can access these types when using $fetch() or useFetch().\n\nStandalone Server\n\nNitro produces a standalone server dist that is independent of node_modules.\n\nThe server in Nuxt 2 is not standalone and requires part of Nuxt core to be involved by running nuxt start (with the nuxt-start or nuxt distributions) or custom programmatic usage, which is fragile and prone to breakage and not suitable for serverless and service-worker environments.\n\nNuxt 3 generates this dist when running nuxt build into a .output directory.\n\nThe output contains runtime code to run your Nuxt server in any environment (including experimental browser service workers!) and serve your static files, making it a true hybrid framework for the JAMstack. In addition, Nuxt implements a native storage layer, supporting multi-source drivers and local assets.\n\nRead more about Nitro engine on GitHub.\n\nRendering Modes\n\nLearn about the different rendering modes available in Nuxt.\n\nModules\n\nNuxt provides a module system to extend the framework core and simplify integrations."
  },
  {
    "title": "Testing · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/testing",
    "html": "Get Started\nTesting\n\nHow to test your Nuxt application.\n\nTest utils are still in development and the API and behavior may change. Currently, it is in preview stage but not yet ready for testing production apps. If you are a module author, you can find more specific information in the Module Author's guide\n\nIn Nuxt 3, we have a rewritten version of @nuxt/test-utils. We support Vitest and Jest as test runners.\n\nInstallation\nyarn\nnpm\npnpm\nbun\nyarn add --dev @nuxt/test-utils vitest\n\nSetup\n\nIn each describe block where you are taking advantage of the @nuxt/test-utils helper methods, you will need to set up the test context before beginning.\n\ntest/my-test.spec.ts\nimport { describe, test } from 'vitest'\n\nimport { setup, $fetch } from '@nuxt/test-utils'\n\n\n\ndescribe('My test', async () => {\n\n  await setup({\n\n    // test context options\n\n  })\n\n\n\n  test('my test', () => {\n\n    // ...\n\n  })\n\n})\n\n\nBehind the scenes, setup performs a number of tasks in beforeAll, beforeEach, afterEach and afterAll to set up the Nuxt test environment correctly.\n\nPlease use the options below for the setup method.\n\nNuxt Config\nrootDir: Path to a directory with a Nuxt app to be put under test.\nType: string\nDefault: '.'\nconfigFile: Name of the configuration file.\nType: string\nDefault: 'nuxt.config'\nTimings\nsetupTimeout: The amount of time (in milliseconds) to allow for setupTest to complete its work (which could include building or generating files for a Nuxt application, depending on the options that are passed).\nType: number\nDefault: 60000\nFeatures\nserver: Whether to launch a server to respond to requests in the test suite.\nType: boolean\nDefault: true\nport: If provided, set the launched test server port to the value.\nType: number | undefined\nDefault: undefined\nbuild: Whether to run a separate build step.\nType: boolean\nDefault: true (false if browser or server is disabled)\nbrowser: Under the hood, Nuxt test utils uses playwright to carry out browser testing. If this option is set, a browser will be launched and can be controlled in the subsequent test suite.\nType: boolean\nDefault: false\nbrowserOptions\nType: object with the following properties\ntype: The type of browser to launch - either chromium, firefox or webkit\nlaunch: object of options that will be passed to playwright when launching the browser. See full API reference.\nrunner: Specify the runner for the test suite. Currently, Vitest is recommended.\nType: 'vitest' | 'jest'\nDefault: 'vitest'\nAPIs\n$fetch(url)\n\nGet the HTML of a server-rendered page.\n\nimport { $fetch } from '@nuxt/test-utils'\n\n\n\nconst html = await $fetch('/')\n\nfetch(url)\n\nGet the response of a server-rendered page.\n\nimport { fetch } from '@nuxt/test-utils'\n\n\n\nconst res = await fetch('/')\n\nconst { body, headers } = res\n\nurl(path)\n\nGet the full URL for a given page (including the port the test server is running on.)\n\nimport { url } from '@nuxt/test-utils'\n\n\n\nconst pageUrl = url('/page')\n\n// 'http://localhost:6840/page'\n\nTesting in a Browser\nWe are working on it, stay tuned!\n\nDeployment\n\nLearn how to deploy your Nuxt application to any hosting provider.\n\nUpgrade Guide\n\nLearn how to upgrade to the latest Nuxt version."
  },
  {
    "title": "Upgrade Guide · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/upgrade",
    "html": "Get Started\nUpgrade Guide\n\nLearn how to upgrade to the latest Nuxt version.\n\nUpgrading Nuxt 3\nLatest release\n\nTo upgrade Nuxt 3 to the latest release, use the nuxi upgrade command.\n\nTerminal\nnpx nuxi upgrade\n\nNightly Release Channel\n\nTo use the latest Nuxt 3 build and test features before their release, read about the nightly release channel guide.\n\nNuxt 2 vs Nuxt 3\n\nIn the table below, there is a quick comparison between 3 versions of Nuxt:\n\nFeature / Version\tNuxt 2\tNuxt Bridge\tNuxt 3\nVue\t2\t2\t3\nStability\t😊 Stable\t😌 Semi-stable\t😊 Stable\nPerformance\t🏎 Fast\t✈️ Faster\t🚀 Fastest\nNitro Engine\t❌\t✅\t✅\nESM support\t🌙 Partial\t👍 Better\t✅\nTypeScript\t☑️ Opt-in\t🚧 Partial\t✅\nComposition API\t❌\t🚧 Partial\t✅\nOptions API\t✅\t✅\t✅\nComponents Auto Import\t✅\t✅\t✅\n<script setup> syntax\t❌\t🚧 Partial\t✅\nAuto Imports\t❌\t✅\t✅\nwebpack\t4\t4\t5\nVite\t⚠️ Partial\t🚧 Partial\t✅\nNuxi CLI\t❌ Old\t✅ nuxi\t✅ nuxi\nStatic sites\t✅\t✅\t✅\nNuxt 2 to Nuxt 3\n\nThe migration guide provides a step-by-step comparison of Nuxt 2 features to Nuxt 3 features and guidance to adapt your current application.\n\nCheck out the guide to migrating from Nuxt 2 to Nuxt 3.\nNuxt 2 to Nuxt Bridge\n\nIf you prefer to progressively migrate your Nuxt 2 application to Nuxt 3, you can use Nuxt Bridge. Nuxt Bridge is a compatibility layer that allows you to use Nuxt 3 features in Nuxt 2 with an opt-in mechanism.\n\nMigrate from Nuxt 2 to Nuxt Bridge\n\nTesting\n\nHow to test your Nuxt application.\n\nAuto-imports\n\nNuxt auto-imports components, composables, helper functions and Vue APIs."
  },
  {
    "title": "Deployment · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/deployment",
    "html": "Get Started\nDeployment\n\nLearn how to deploy your Nuxt application to any hosting provider.\n\nA Nuxt application can be deployed on a Node.js server, pre-rendered for static hosting, or deployed to serverless or edge (CDN) environments.\n\nIf you are looking for a list of cloud providers that support Nuxt 3, see the Hosting providers section.\nNode.js Server\n\nDiscover the Node.js server preset with Nitro to deploy on any Node hosting.\n\nDefault output format if none is specified or auto-detected\n\nLoads only the required chunks to render the request for optimal cold start timing\n\nUseful for deploying Nuxt apps to any Node.js hosting\nEntry Point\n\nWhen running nuxt build with the Node server preset, the result will be an entry point that launches a ready-to-run Node server.\n\nTerminal\nnode .output/server/index.mjs\n\n\nThis will launch your production Nuxt server that listens on port 3000 by default.\n\nIt respects the following runtime environment variables:\n\nNITRO_PORT or PORT (defaults to 3000)\nNITRO_HOST or HOST (defaults to '0.0.0.0')\nNITRO_SSL_CERT and NITRO_SSL_KEY - if both are present, this will launch the server in HTTPS mode. In the vast majority of cases, this should not be used other than for testing, and the Nitro server should be run behind a reverse proxy like nginx or Cloudflare which terminates SSL.\nPM2\n\nPM2 (Process Manager 2) is a fast and easy solution for hosting your Nuxt application on your server or VM.\n\nTo use pm2, use an ecosystem.config.js:\n\necosystem.config.js\nmodule.exports = {\n\n  apps: [\n\n    {\n\n      name: 'NuxtAppName',\n\n      port: '3000',\n\n      exec_mode: 'cluster',\n\n      instances: 'max',\n\n      script: './.output/server/index.mjs'\n\n    }\n\n  ]\n\n}\n\nCluster Mode\n\nYou can use NITRO_PRESET=node_cluster in order to leverage multi-process performance using Node.js cluster module.\n\nBy default, the workload gets distributed to the workers with the round robin strategy.\n\nLearn More\n Read more in the Nitro documentation for node-server preset.\nStatic Hosting\n\nThere are two ways to deploy a Nuxt application to any static hosting services:\n\nStatic site generation (SSG) with ssr: true pre-renders routes of your application at build time. (This is the default behavior when running nuxi generate.) It will also generate /200.html and /404.html single-page app fallback pages, which can render dynamic routes or 404 errors on the client (though you may need to configure this on your static host).\nAlternatively, you can prerender your site with ssr: false (static single-page app). This will produce HTML pages with an empty <div id=\"__nuxt\"></div> where your Vue app would normally be rendered. You will lose many SEO benefits of prerendering your site, so it is suggested instead to use <ClientOnly> to wrap the portions of your site that cannot be server rendered (if any).\nCrawl-based Pre-rendering\n\nUse the nuxi generate command to build and pre-render your application using the Nitro crawler. This command is similar to nuxt build with the nitro.static option set to true, or running nuxt build --prerender.\n\nTerminal\nnpx nuxi generate\n\n\nThat's it! You can now deploy the .output/public directory to any static hosting service or preview it locally with npx serve .output/public.\n\nWorking of the Nitro crawler:\n\nLoad the HTML of your application's root route (/), any non-dynamic pages in your ~/pages directory, and any other routes in the nitro.prerender.routes array.\nSave the HTML and payload.json to the ~/.output/public/ directory to be served statically.\nFind all anchor tags (<a href=\"...\">) in the HTML to navigate to other routes.\nRepeat steps 1-3 for each anchor tag found until there are no more anchor tags to crawl.\n\nThis is important to understand since pages that are not linked to a discoverable page can't be pre-rendered automatically.\n\nRead more about the nuxi generate command.\nSelective Pre-rendering\n\nYou can manually specify routes that Nitro will fetch and pre-render during the build or ignore routes that you don't want to pre-render like /dynamic in the nuxt.config file:\n\nnuxt.config.ts\ndefineNuxtConfig({\n\n  nitro: {\n\n    prerender: {\n\n      routes: ['/user/1', '/user/2'],\n\n      ignore: ['/dynamic']\n\n    }\n\n  }\n\n})\n\n\nYou can combine this with the crawLinks option to pre-render a set of routes that the crawler can't discover like your /sitemap.xml or /robots.txt:\n\nnuxt.config.ts\ndefineNuxtConfig({\n\n  nitro: {\n\n    prerender: {\n\n      crawlLinks: true,\n\n      routes: ['/sitemap.xml', '/robots.txt']\n\n    }\n\n  }\n\n})\n\n\nSetting nitro.prerender to true is similar to nitro.prerender.crawlLinks to true.\n\nRead more about pre-rendering in the Nitro documentation.\nClient-side Only Rendering\n\nIf you don't want to pre-render your routes, another way of using static hosting is to set the ssr property to false in the nuxt.config file. The nuxi generate command will then output an .output/public/index.html entrypoint and JavaScript bundles like a classic client-side Vue.js application.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  ssr: false\n\n})\n\nHosting Providers\n\nNuxt 3 can be deployed to several cloud providers with a minimal amount of configuration:\n\n Read more in Deploy.\nPresets\n\nIn addition to Node.js servers and static hosting services, a Nuxt 3 project can be deployed with several well-tested presets and minimal amount of configuration.\n\nYou can explicitly set the desired preset in the nuxt.config.ts file:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  nitro: {\n\n    preset: 'node-server'\n\n  }\n\n})\n\n\n... or use the NITRO_PRESET environment variable when running nuxt build:\n\nTerminal\nNITRO_PRESET=node-server nuxt build\n\n\n🔎 Check the Nitro deployment for all possible deployment presets and providers.\n\nCDN Proxy\n\nIn most cases, Nuxt can work with third-party content that is not generated or created by Nuxt itself. But sometimes such content can cause problems, especially Cloudflare's \"Minification and Security Options\".\n\nAccordingly, you should make sure that the following options are unchecked / disabled in Cloudflare. Otherwise, unnecessary re-rendering or hydration errors could impact your production application.\n\nSpeed > Optimization > Auto Minify: Uncheck JavaScript, CSS and HTML\nSpeed > Optimization > Disable \"Rocket Loader™\"\nSpeed > Optimization > Disable \"Mirage\"\nScrape Shield > Disable \"Email Address Obfuscation\"\nScrape Shield > Disable \"Server-side Excludes\"\n\nWith these settings, you can be sure that Cloudflare won't inject scripts into your Nuxt application that may cause unwanted side effects.\n\nLayers\n\nNuxt provides a powerful system that allows you to extend the default files, configs, and much more.\n\nTesting\n\nHow to test your Nuxt application."
  },
  {
    "title": "Transitions · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/transitions",
    "html": "Get Started\nTransitions\n\nApply transitions between pages and layouts with Vue or native browser View Transitions.\n\nNuxt leverages Vue's <Transition> component to apply transitions between pages and layouts.\nPage transitions\n\nYou can enable page transitions to apply an automatic transition for all your pages.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  app: {\n\n    pageTransition: { name: 'page', mode: 'out-in' }\n\n  },\n\n})\n\nIf you are changing layouts as well as page, the page transition you set here will not run. Instead, you should set a layout transition.\n\nTo start adding transition between your pages, add the following CSS to your app.vue:\n\napp.vue\npages/index.vue\npages/about.vue\n<template>\n\n  <NuxtPage />\n\n</template>\n\n\n\n<style>\n\n.page-enter-active,\n\n.page-leave-active {\n\n  transition: all 0.4s;\n\n}\n\n.page-enter-from,\n\n.page-leave-to {\n\n  opacity: 0;\n\n  filter: blur(1rem);\n\n}\n\n</style>\n\n\nThis produces the following result when navigating between pages:\n\nTo set a different transition for a page, set the pageTransition key in definePageMeta of the page:\n\npages/about.vue\napp.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  pageTransition: {\n\n    name: 'rotate'\n\n  }\n\n})\n\n</script>\n\n\nMoving to the about page will add the 3d rotation effect:\n\nLayout transitions\n\nYou can enable layout transitions to apply an automatic transition for all your layouts.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  app: {\n\n    layoutTransition: { name: 'layout', mode: 'out-in' }\n\n  },\n\n})\n\n\nTo start adding transition between your pages and layouts, add the following CSS to your app.vue:\n\napp.vue\nlayouts/default.vue\nlayouts/orange.vue\npages/index.vue\npages/about.vue\n<template>\n\n  <NuxtLayout>\n\n    <NuxtPage />\n\n  </NuxtLayout>\n\n</template>\n\n\n\n<style>\n\n.layout-enter-active,\n\n.layout-leave-active {\n\n  transition: all 0.4s;\n\n}\n\n.layout-enter-from,\n\n.layout-leave-to {\n\n  filter: grayscale(1);\n\n}\n\n</style>\n\n\nThis produces the following result when navigating between pages:\n\nSimilar to pageTransition, you can apply a custom layoutTransition to the page component using definePageMeta:\n\npages/about.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  layout: 'orange',\n\n  layoutTransition: {\n\n    name: 'slide-in'\n\n  }\n\n})\n\n</script>\n\nGlobal settings\n\nYou can customize these default transition names globally using nuxt.config.\n\nBoth pageTransition and layoutTransition keys accept TransitionProps as JSON serializable values where you can pass the name, mode and other valid transition-props of the custom CSS transition.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  app: {\n\n    pageTransition: {\n\n      name: 'fade',\n\n      mode: 'out-in' // default\n\n    },\n\n    layoutTransition: {\n\n      name: 'slide',\n\n      mode: 'out-in' // default\n\n    }\n\n  }\n\n})\n\nIf you change the name property, you also have to rename the CSS classes accordingly.\n\nTo override the global transition property, use the definePageMeta to define page or layout transitions for a single Nuxt page and override any page or layout transitions that are defined globally in nuxt.config file.\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  pageTransition: {\n\n    name: 'bounce',\n\n    mode: 'out-in' // default\n\n  }\n\n})\n\n</script>\n\nDisable Transitions\n\npageTransition and layoutTransition can be disabled for a specific route:\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  pageTransition: false,\n\n  layoutTransition: false\n\n})\n\n</script>\n\n\nOr globally in the nuxt.config:\n\nnuxt.config.ts\ndefineNuxtConfig({\n\n  app: {\n\n    pageTransition: false,\n\n    layoutTransition: false\n\n  }\n\n})\n\nJavaScript Hooks\n\nFor advanced use-cases, you can use JavaScript hooks to create highly dynamic and custom transitions for your Nuxt pages.\n\nThis way presents perfect use-cases for JavaScript animation libraries such as GSAP.\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  pageTransition: {\n\n    name: 'custom-flip',\n\n    mode: 'out-in',\n\n    onBeforeEnter: (el) => {\n\n      console.log('Before enter...')\n\n    },\n\n    onEnter: (el, done) => {},\n\n    onAfterEnter: (el) => {}\n\n  }\n\n})\n\n</script>\n\nLearn more about additional JavaScript hooks available in the Transition component.\nDynamic Transitions\n\nTo apply dynamic transitions using conditional logic, you can leverage inline middleware to assign a different transition name to to.meta.pageTransition.\n\npages/[id].vue\nlayouts/default.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  pageTransition: {\n\n    name: 'slide-right',\n\n    mode: 'out-in'\n\n  },\n\n  middleware (to, from) {\n\n    to.meta.pageTransition.name = +to.params.id > +from.params.id ? 'slide-left' : 'slide-right'\n\n  }\n\n})\n\n</script>\n\n\n\n<template>\n\n  <h1>#{{ $route.params.id }}</h1>\n\n</template>\n\n\n\n<style>\n\n.slide-left-enter-active,\n\n.slide-left-leave-active,\n\n.slide-right-enter-active,\n\n.slide-right-leave-active {\n\n  transition: all 0.2s;\n\n}\n\n.slide-left-enter-from {\n\n  opacity: 0;\n\n  transform: translate(50px, 0);\n\n}\n\n.slide-left-leave-to {\n\n  opacity: 0;\n\n  transform: translate(-50px, 0);\n\n}\n\n.slide-right-enter-from {\n\n  opacity: 0;\n\n  transform: translate(-50px, 0);\n\n}\n\n.slide-right-leave-to {\n\n  opacity: 0;\n\n  transform: translate(50px, 0);\n\n}\n\n</style>\n\n\nThe page now applies the slide-left transition when going to the next id and slide-right for the previous:\n\nTransition with NuxtPage\n\nWhen <NuxtPage /> is used in app.vue, transition-props can be passed directly as a component props to activate global transition.\n\napp.vue\n<template>\n\n  <div>\n\n    <NuxtLayout>\n\n      <NuxtPage :transition=\"{\n\n        name: 'bounce',\n\n        mode: 'out-in'\n\n      }\" />\n\n    </NuxtLayout>\n\n  </div>\n\n</template>\n\nRemember, this page transition cannot be overridden with definePageMeta on individual pages.\nView Transitions API (experimental)\n\nNuxt ships with an experimental implementation of the View Transitions API (see MDN). This is an exciting new way to implement native browser transitions which (among other things) have the ability to transition between unrelated elements on different pages.\n\nThe Nuxt integration is under active development, but can be enabled with the experimental.viewTransition option in your configuration file:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  experimental: {\n\n    viewTransition: true\n\n  }\n\n})\n\n\nIf you are also using Vue transitions like pageTransition and layoutTransition (see above) to achieve the same result as the new View Transitions API, then you may wish to disable Vue transitions if the user's browser supports the newer, native web API. You can do this by creating ~/middleware/disable-vue-transitions.global.ts with the following contents:\n\nexport default defineNuxtRouteMiddleware(to => {\n\n  if (import.meta.server || !document.startViewTransition) { return }\n\n\n\n  // Disable built-in Vue transitions\n\n  to.meta.pageTransition = false\n\n  to.meta.layoutTransition = false\n\n})\n\nKnown issues\nView transitions may not work as expected with nested pages/layouts/async components owing to this upstream Vue bug: https://github.com/vuejs/core/issues/5513. If you make use of this pattern, you may need to delay adopting this experimental feature or implement it yourself. Feedback is very welcome.\nIf you perform data fetching within your page setup functions, that you may wish to reconsider using this feature for the moment. (By design, View Transitions completely freeze DOM updates whilst they are taking place.) We're looking at restrict the View Transition to the final moments before <Suspense> resolves, but in the interim you may want to consider carefully whether to adopt this feature if this describes you.\n\nSEO and Meta\n\nImprove your Nuxt app's SEO with powerful head config, composables and components.\n\nData fetching\n\nNuxt provides composables to handle data fetching within your application."
  },
  {
    "title": "Server · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/server",
    "html": "Get Started\nServer\n\nBuild full-stack applications with Nuxt's server framework. You can fetch data from your database or another server, create APIs, or even generate static server-side content like a sitemap or a RSS feed - all from a single codebase.\n\n Read more in Docs > Guide > Directory Structure > Server.\nPowered by Nitro\n\nNuxt's server is Nitro. It was originally created for Nuxt but is now part of UnJS and open for other frameworks - and can even be used on its own.\n\nUsing Nitro gives Nuxt superpowers:\n\nFull control of the server-side part of your app\nUniversal deployment on any provider (many zero-config)\nHybrid rendering\n\nNitro is internally using h3, a minimal H(TTP) framework built for high performance and portability.\n\nServer Endpoints & Middleware\n\nYou can easily manage the server-only part of your Nuxt app, from API endpoints to middleware.\n\nBoth endpoints and middleware can be defined like this:\n\nserver/api/test.ts\nexport default defineEventHandler(async (event) => {\n\n  // ... Do whatever you want here\n\n})\n\n\nAnd you can directly return text, json, html or even a stream.\n\nOut-of-the-box, it supports hot module replacement and auto-import like the other parts of your Nuxt application.\n\n Read more in Docs > Guide > Directory Structure > Server.\nUniversal Deployment\n\nNitro offers the ability to deploy your Nuxt app anywhere, from a bare metal server to the edge network, with a start time of just a few milliseconds. That's fast!\n\n Read more in Blog > Nuxt On The Edge.\n\nThere are more than 15 presets to build your Nuxt app for different cloud providers and servers, including:\n\nCloudflare Workers\nNetlify Functions\nVercel Edge Network\nLagon\n\nOr for other runtimes:\n\nDeno\n\nBun\n\n Read more in Docs > Getting Started > Deployment.\nHybrid Rendering\n\nNitro has a powerful feature called routeRules which allows you to define a set of rules to customize how each route of your Nuxt app is rendered (and more).\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  routeRules: {\n\n    // Generated at build time for SEO purpose\n\n    '/': { prerender: true },\n\n    // Cached for 1 hour\n\n    '/api/*': { cache: { maxAge: 60 * 60 } },\n\n    // Redirection to avoid 404\n\n    '/old-page': {\n\n      redirect: { to: { '/new-page', statusCode: 302 }\n\n    }\n\n    // ...\n\n  }\n\n})\n\nLearn about all available route rules are available to customize the rendering mode of your routes.\n\nIn addition, there are some route rules (for example, ssr and experimentalNoScripts) that are Nuxt specific to change the behavior when rendering your pages to HTML.\n\nSome route rules (redirect and prerender) also affect client-side behavior.\n\nNitro is used to build the app for server side rendering, as well as pre-rendering.\n\n Read more in Docs > Guide > Concepts > Rendering.\n\nError Handling\n\nLearn how to catch and handle errors in Nuxt.\n\nLayers\n\nNuxt provides a powerful system that allows you to extend the default files, configs, and much more."
  },
  {
    "title": "Layers · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/layers",
    "html": "Get Started\nLayers\n\nNuxt provides a powerful system that allows you to extend the default files, configs, and much more.\n\nOne of the core features of Nuxt 3 is the layers and extending support. You can extend a default Nuxt application to reuse components, utils, and configuration. The layers structure is almost identical to a standard Nuxt application which makes them easy to author and maintain.\n\nUse Cases\nShare reusable configuration presets across projects using nuxt.config and app.config\nCreate a component library using components/ directory\nCreate utility and composable library using composables/ and utils/ directories\nCreate Nuxt module presets\nShare standard setup across projects\nCreate Nuxt themes\nUsage\n\nYou can extend a layer by adding the extends property to the nuxt.config.ts file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  extends: [\n\n    '../base',                     // Extend from a local layer\n\n    '@my-themes/awesome',          // Extend from an installed npm package\n\n    'github:my-themes/awesome#v1', // Extend from a git repository\n\n  ]\n\n})\n\nRead more about layers in the Layer Author Guide.\nWatch Learn Vue video about Nuxt Layers.\nExamples\nNuxt Docus Theme\nNuxt Content Wind Theme\n\nServer\n\nBuild full-stack applications with Nuxt's server framework. You can fetch data from your database or another server, create APIs, or even generate static server-side content like a sitemap or a RSS feed - all from a single codebase.\n\nDeployment\n\nLearn how to deploy your Nuxt application to any hosting provider."
  },
  {
    "title": "Error Handling · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/error-handling",
    "html": "Get Started\nError Handling\n\nLearn how to catch and handle errors in Nuxt.\n\nNuxt 3 is a full-stack framework, which means there are several sources of unpreventable user runtime errors that can happen in different contexts:\n\nErrors during the Vue rendering lifecycle (SSR & CSR)\nErrors during Nitro server lifecycle (server/ directory)\nServer and client startup errors (SSR + CSR)\nErrors downloading JS chunks\nSSR stands for Server-Side Rendering and CSR for Client-Side Rendering.\nVue Rendering Lifecycle\n\nYou can hook into Vue errors using onErrorCaptured.\n\nIn addition, Nuxt provides a vue:error hook that will be called if any errors propagate up to the top level.\n\nIf you are using an error reporting framework, you can provide a global handler through vueApp.config.errorHandler. It will receive all Vue errors, even if they are handled.\n\nplugins/error-handler.ts\nexport default defineNuxtPlugin((nuxtApp) => {\n\n  nuxtApp.vueApp.config.errorHandler = (error, instance, info) => {\n\n    // handle error, e.g. report to a service\n\n  }\n\n\n\n  // Also possible\n\n  nuxtApp.hook('vue:error', (error, instance, info) => {\n\n    // handle error, e.g. report to a service\n\n  })\n\n})\n\nNote that the vue:error hook is based on onErrorCaptured lifecycle hook.\nStartup Errors\n\nNuxt will call the app:error hook if there are any errors in starting your Nuxt application.\n\nThis includes:\n\nrunning Nuxt plugins\nprocessing app:created and app:beforeMount hooks\nrendering your Vue app to HTML (during SSR)\nmounting the app (on client-side), though you should handle this case with onErrorCaptured or with vue:error\nprocessing the app:mounted hook\nNitro Server Lifecycle\n\nYou cannot currently define a server-side handler for these errors, but can render an error page, see the Render an Error Page section.\n\nErrors with JS chunks\n\nYou might encounter chunk loading errors due to a network connectivity failure or a new deployment (which invalidates your old, hashed JS chunk URLs). Nuxt provides built-in support for handling chunk loading errors by performing a hard reload when a chunk fails to load during route navigation.\n\nYou can change this behavior by setting experimental.emitRouteChunkError to false (to disable hooking into these errors at all) or to manual if you want to handle them yourself. If you want to handle chunk loading errors manually, you can check out the the automatic implementation for ideas.\n\nError Page\nWhen Nuxt encounters a fatal error (any unhandled error on the server, or an error created with fatal: true on the client) it will either render a JSON response (if requested with Accept: application/json header) or trigger a full-screen error page.\n\nAn error may occur during the server lifecycle when:\n\nprocessing your Nuxt plugins\nrendering your Vue app into HTML\na server API route throws an error\n\nIt can also occur on the client side when:\n\nprocessing your Nuxt plugins\nbefore mounting the application (app:beforeMount hook)\nmounting your app if the error was not handled with onErrorCaptured or vue:error hook\nthe Vue app is initialized and mounted in browser (app:mounted).\nDiscover all the Nuxt lifecycle hooks.\n\nCustomize the default error page by adding ~/error.vue in the source directory of your application, alongside app.vue.\n\nerror.vue\n<script setup lang=\"ts\">\n\nconst props = defineProps({\n\n  error: Object\n\n})\n\n\n\nconst handleError = () => clearError({ redirect: '/' })\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <h2>{{ error.statusCode }}</h2>\n\n    <button @click=\"handleError\">Clear errors</button>\n\n  </div>\n\n</template>\n\nAlthough it is called an 'error page' it's not a route and shouldn't be placed in your ~/pages directory. For the same reason, you shouldn't use definePageMeta within this page.\n\nThe error page has a single prop - error which contains an error for you to handle.\n\nThe error object provides the fields:\n\n{\n\n  url: string\n\n  statusCode: number\n\n  statusMessage: string\n\n  message: string\n\n  description: string\n\n  data: any\n\n}\n\n\nIf you have an error with custom fields they will be lost; you should assign them to data instead:\n\nthrow createError({\n\n  statusCode: 404,\n\n  statusMessage: 'Page Not Found',\n\n  data: {\n\n    myCustomField: true\n\n  }\n\n})\n\n\nFor custom errors we highly recommend to use onErrorCaptured composable that can be called in a page/component setup function or vue:error runtime nuxt hook that can be configured in a nuxt plugin.\n\nplugins/error-handler.ts\nexport default defineNuxtPlugin(nuxtApp => {\n\n  nuxtApp.hook('vue:error', (err) => {\n\n    //\n\n  })\n\n})\n\n\nWhen you are ready to remove the error page, you can call the clearError helper function, which takes an optional path to redirect to (for example, if you want to navigate to a 'safe' page).\n\nMake sure to check before using anything dependent on Nuxt plugins, such as $route or useRouter, as if a plugin threw an error, then it won't be re-run until you clear the error.\nIf you are running on Node 16 and you set any cookies when rendering your error page, they will overwrite cookies previously set. We recommend using a newer version of Node as Node 16 reached end-of-life in September 2023.\nError Utils\nuseError\nTS Signature\nfunction useError (): Ref<Error | { url, statusCode, statusMessage, message, description, data }>\n\n\nThis function will return the global Nuxt error that is being handled.\n\nRead more about useError composable.\ncreateError\nTS Signature\nfunction createError (err: { cause, data, message, name, stack, statusCode, statusMessage, fatal }): Error\n\n\nCreate an error object with additional metadata. It is usable in both the Vue and Server portions of your app, and is meant to be thrown.\n\nIf you throw an error created with createError:\n\non server-side, it will trigger a full-screen error page which you can clear with clearError.\non client-side, it will throw a non-fatal error for you to handle. If you need to trigger a full-screen error page, then you can do this by setting fatal: true.\npages/movies/[slug].vue\n<script setup lang=\"ts\">\n\nconst route = useRoute()\n\nconst { data } = await useFetch(`/api/movies/${route.params.slug}`)\n\n\n\nif (!data.value) {\n\n  throw createError({\n\n    statusCode: 404,\n\n    statusMessage: 'Page Not Found'\n\n  })\n\n}\n\n</script>\n\nRead more about createError util.\nshowError\nTS Signature\nfunction showError (err: string | Error | { statusCode, statusMessage }): Error\n\n\nYou can call this function at any point on client-side, or (on server side) directly within middleware, plugins or setup() functions. It will trigger a full-screen error page which you can clear with clearError.\n\nIt is recommended instead to use throw createError().\n\nRead more about showError util.\nclearError\nTS Signature\nfunction clearError (options?: { redirect?: string }): Promise<void>\n\n\nThis function will clear the currently handled Nuxt error. It also takes an optional path to redirect to (for example, if you want to navigate to a 'safe' page).\n\nRead more about clearError util.\nRender Error in Component\n\nNuxt also provides a <NuxtErrorBoundary> component that allows you to handle client-side errors within your app, without replacing your entire site with an error page.\n\nThis component is responsible for handling errors that occur within its default slot. On client-side, it will prevent the error from bubbling up to the top level, and will render the #error slot instead.\n\nThe #error slot will receive error as a prop. (If you set error = null it will trigger re-rendering the default slot; you'll need to ensure that the error is fully resolved first or the error slot will just be rendered a second time.)\n\nIf you navigate to another route, the error will be cleared automatically.\npages/index.vue\n<template>\n\n  <!-- some content -->\n\n  <NuxtErrorBoundary @error=\"someErrorLogger\">\n\n    <!-- You use the default slot to render your content -->\n\n    <template #error=\"{ error, clearError }\">\n\n      You can display the error locally here: {{ error }}\n\n      <button @click=\"clearError\">\n\n        This will clear the error.\n\n      </button>\n\n    </template>\n\n  </NuxtErrorBoundary>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Advanced > Error Handling.\n\nState Management\n\nNuxt provides powerful state management libraries and the useState composable to create a reactive and SSR-friendly shared state.\n\nServer\n\nBuild full-stack applications with Nuxt's server framework. You can fetch data from your database or another server, create APIs, or even generate static server-side content like a sitemap or a RSS feed - all from a single codebase."
  },
  {
    "title": "State Management · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/state-management",
    "html": "Get Started\nState Management\n\nNuxt provides powerful state management libraries and the useState composable to create a reactive and SSR-friendly shared state.\n\nNuxt provides the useState composable to create a reactive and SSR-friendly shared state across components.\n\nuseState is an SSR-friendly ref replacement. Its value will be preserved after server-side rendering (during client-side hydration) and shared across all components using a unique key.\n\nBecause the data inside useState will be serialized to JSON, it is important that it does not contain anything that cannot be serialized, such as classes, functions or symbols.\nRead more about useState composable.\nBest Practices\nNever define const state = ref() outside of <script setup> or setup() function.\nSuch state will be shared across all users visiting your website and can lead to memory leaks!\nInstead use const useX = () => useState('x')\nExamples\nBasic Usage\n\nIn this example, we use a component-local counter state. Any other component that uses useState('counter') shares the same reactive state.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst counter = useState('counter', () => Math.round(Math.random() * 1000))\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    Counter: {{ counter }}\n\n    <button @click=\"counter++\">\n\n      +\n\n    </button>\n\n    <button @click=\"counter--\">\n\n      -\n\n    </button>\n\n  </div>\n\n</template>\n\n Read and edit a live example in Docs > Examples > Features > State Management.\nTo globally invalidate cached state, see clearNuxtState util.\nAdvanced Usage\n\nIn this example, we use a composable that detects the user's default locale from the HTTP request headers and keeps it in a locale state.\n\ncomposables/locale.ts\napp.vue\nimport type { Ref } from 'vue'\n\n\n\nexport const useLocale = () => {\n\n  return useState<string>('locale', () => useDefaultLocale().value)\n\n}\n\n\n\nexport const useDefaultLocale = (fallback = 'en-US') => {\n\n  const locale = ref(fallback)\n\n  if (process.server) {    \n\n    const reqLocale = useRequestHeaders()['accept-language']?.split(',')[0]\n\n    if (reqLocale) {\n\n      locale.value = reqLocale\n\n    }\n\n  } else if (process.client) {\n\n    const navLang = navigator.language\n\n    if (navLang) {\n\n      locale.value = navLang\n\n    }\n\n  }\n\n  return locale\n\n}\n\n\n\nexport const useLocales = () => {\n\n  const locale = useLocale()\n\n  const locales = ref([\n\n    'en-US',\n\n    'en-GB',\n\n    ...\n\n    'ja-JP-u-ca-japanese'\n\n  ])\n\n  if (!locales.value.includes(locale.value)) {\n\n    locales.value.unshift(locale.value)\n\n  }\n\n  return locales\n\n}\n\n\n\nexport const useLocaleDate = (date: Ref<Date> | Date, locale = useLocale()) => {\n\n  return computed(() => new Intl.DateTimeFormat(locale.value, { dateStyle: 'full' }).format(unref(date)))\n\n}\n\n Read and edit a live example in Docs > Examples > Advanced > Locale.\nShared State\n\nBy using auto-imported composables we can define global type-safe states and import them across the app.\n\ncomposables/states.ts\nexport const useCounter = () => useState<number>('counter', () => 0)\n\nexport const useColor = () => useState<string>('color', () => 'pink')\n\napp.vue\n<script setup lang=\"ts\">\n\nconst color = useColor() // Same as useState('color')\n\n</script>\n\n\n\n<template>\n\n  <p>Current color: {{ color }}</p>\n\n</template>\n\nUsing third-party libraries\n\nNuxt used to rely on the Vuex library to provide global state management. If you are migrating from Nuxt 2, please head to the migration guide.\n\nNuxt is not opinionated about state management, so feel free to choose the right solution for your needs. There are multiple integrations with the most popular state management libraries, including:\n\nPinia - the official Vue recommendation\nHarlem - immutable global state management\nXState - state machine approach with tools for visualizing and testing your state logic\n\nData fetching\n\nNuxt provides composables to handle data fetching within your application.\n\nError Handling\n\nLearn how to catch and handle errors in Nuxt."
  },
  {
    "title": "Data fetching · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/data-fetching",
    "html": "Get Started\nData fetching\n\nNuxt provides composables to handle data fetching within your application.\n\nNuxt comes with two composables and a built-in library to perform data-fetching in browser or server environments: useFetch, useAsyncData and $fetch.\n\nIn a nutshell:\n\nuseFetch is the most straightforward way to handle data fetching in a component setup function.\n$fetch is great to make network requests based on user interaction.\nuseAsyncData, combined with $fetch, offers more fine-grained control.\n\nBoth useFetch and useAsyncData share a common set of options and patterns that we will detail in the last sections.\n\nBefore that, it's imperative to know why these composables exist in the first place.\n\nWhy using specific composables?\n\nWhen using a framework like Nuxt that can perform calls and render pages on both client and server environments, some challenges must be addressed. This is why Nuxt provides composables to wrap your queries, instead of letting the developer rely on $fetch calls alone.\n\nNetwork calls duplication\n\nThe useFetch and useAsyncData composables ensure that once an API call is made on the server, the data is properly forwarded to the client in the payload.\n\nThe payload is a JavaScript object accessible through useNuxtApp().payload. It is used on the client to avoid refetching the same data when the code is executed in the browser.\n\nUse the Nuxt DevTools to inspect this data in the Payload tab.\nSuspense\n\nNuxt uses Vue’s <Suspense> component under the hood to prevent navigation before every async data is available to the view. The data fetching composables can help you leverage this feature and use what suits best on a per-calls basis.\n\nuseFetch\n\nThe useFetch composable is the most straightforward way to perform data fetching.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst { data: count } = await useFetch('/api/count')\n\n</script>\n\n\n\n<template>\n\n  Page visits: {{ count }}\n\n</template>\n\n\nThis composable is a wrapper around the useAsyncData composable and $fetch utility.\n\n Read more in Docs > API > Composables > Use Fetch.\n Read and edit a live example in Docs > Examples > Features > Data Fetching.\n$fetch\n\nNuxt includes the ofetch library, and is auto-imported as the $fetch alias globally across your application. It's what useFetch uses behind the scenes.\n\nconst users = await $fetch('/api/users').catch((error) => error.data)\n\nBeware that using only $fetch will not provide network calls de-duplication and navigation prevention. It is recommended to use $fetch when posting data to an event handler, when doing client-side only logic, or combined with useAsyncData.\n\nThe ofetch library is built on top of the fetch API and adds handy features to it:\n\nWorks the same way in browser, Node or worker environments\nAutomatic response parsing\nError handling\nAuto-retry\nInterceptors\nRead the full documentation of ofetch\nRead more about $fetch\nuseAsyncData\n\nThe useAsyncData composable is responsible for wrapping async logic and returning the result once it is resolved.\n\nIndeed, useFetch(url) is nearly equivalent to useAsyncData(url, () => $fetch(url)) - it's developer experience sugar for the most common use case.\n\nThere are some cases when using the useFetch composable is not appropriate, for example when a CMS or a third-party provide their own query layer. In this case, you can use useAsyncData to wrap your calls and still keep the benefits provided by the composable.\n\nThe first argument of useAsyncData is the unique key used to cache the response of the second argument, the querying function. This argument can be ignored by directly passing the querying function. In that case, it will be auto-generated.\n\nconst { data, error } = await useAsyncData('users', () => myGetFunction('users'))\n\n\nSince the autogenerated key only takes into account the file and line where useAsyncData is invoked, it is recommended to always create your own key to avoid unwanted behavior, if you are creating your own custom composable that is wrapping useAsyncData.\n\nconst id = ref(1)\n\n\n\nconst { data, error } = await useAsyncData(`user:${id.value}`, () => {\n\n  return myGetFunction('users', { id: id.value })\n\n})\n\n\nThe useAsyncData composable is a great way to wrap and wait for multiple useFetch to be done, and then retrieve the results of each.\n\nconst { data: discounts, pending } = await useAsyncData('cart-discount', async () => {\n\n  const [coupons, offers] = await Promise.all([$fetch('/cart/coupons'), $fetch('/cart/offers')])\n\n\n\n  return {\n\n    coupons,\n\n    offers\n\n  }\n\n})\n\nRead more about useAsyncData\nOptions\n\nuseAsyncData and useFetch return the same object type and accept a common set of options as their last argument. They can help you control the composables behavior, such as navigation blocking, caching or execution.\n\nLazy\n\nBy default, data fetching composables will wait for the resolution of their asynchronous function before navigating to a new page by using Vue’s Suspense. This feature can be ignored on client-side navigation with the lazy option. In that case, you will have to manually handle loading state using the pending value.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst { pending, data: posts } = useFetch('/api/posts', {\n\n  lazy: true\n\n})\n\n</script>\n\n\n\n<template>\n\n  <!-- you will need to handle a loading state -->\n\n  <div v-if=\"pending\">\n\n    Loading ...\n\n  </div>\n\n  <div v-else>\n\n    <div v-for=\"post in posts\">\n\n      <!-- do something -->\n\n    </div>\n\n  </div>\n\n</template>\n\n\nYou can alternatively use useLazyFetch and useLazyAsyncData as convenient methods to perform the same.\n\nconst { pending, data: posts } = useLazyFetch('/api/posts')\n\nRead more about useLazyFetch\nRead more about useLazyAsyncData\nClient-only fetching\n\nBy default, data fetching composables will perform their asynchronous function on both client and server environments. Set the server option to false to only perform the call on the client-side. On initial load, the data will not be fetched before hydration is complete so you have to handle a pending state, though on subsequent client-side navigation the data will be awaited before loading the page.\n\nCombined with the lazy option, this can be useful for data that is not needed on the first render (for example, non-SEO sensitive data).\n\n/* This call is performed before hydration */\n\nconst { article } = await useFetch('api/article')\n\n\n\n/* This call will only be performed on the client */\n\nconst { pending, data: posts } = useFetch('/api/comments', {\n\n  lazy: true,\n\n  server: false\n\n})\n\n\nThe useFetch composable is meant to be invoked in setup method or called directly at the top level of a function in lifecycle hooks, otherwise you should use $fetch method.\n\nMinimize payload size\n\nThe pick option helps you to minimize the payload size stored in your HTML document by only selecting the fields that you want returned from the composables.\n\n<script setup lang=\"ts\">\n\n/* only pick the fields used in your template */\n\nconst { data: mountain } = await useFetch('/api/mountains/everest', { pick: ['title', 'description'] })\n\n</script>\n\n\n\n<template>\n\n  <h1>{{ mountain.title }}</h1>\n\n  <p>{{ mountain.description }}</p>\n\n</template>\n\n\nIf you need more control or map over several objects, you can use the transform function to alter the result of the query.\n\nconst { data: mountains } = await useFetch('/api/mountains', { \n\n  transform: (mountains) => {\n\n    return mountains.map(mountain => ({ title: mountain.title, description: mountain.description }))\n\n  }\n\n})\n\nBoth pick and transform don't prevent the unwanted data from being fetched initially. But they will prevent unwanted data from being added to the payload transferred from server to client.\nCaching and refetching\nKeys\n\nuseFetch and useAsyncData use keys to prevent refetching the same data.\n\nuseFetch uses the provided URL as a key. Alternatively, a key value can be provided in the options object passed as a last argument.\nuseAsyncData uses its first argument as a key if it is a string. If the first argument is the handler function that performs the query, then a key that is unique to the file name and line number of the instance of useAsyncData will be generated for you.\nTo get the cached data by key, you can use useNuxtData\nRefresh and execute\n\nIf you want to fetch or refresh data manually, use the execute or refresh function provided by the composables.\n\n<script setup lang=\"ts\">\n\nconst { data, error, execute, refresh } = await useFetch('/api/users')\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <p>{{ data }}</p>\n\n    <button @click=\"refresh\">Refresh data</button>\n\n  </div>\n\n</template>\n\n\nThe execute function is an alias for refresh that works in exactly the same way but is more semantic for cases when the fetch is not immediate.\n\nTo globally refetch or invalidate cached data, see clearNuxtData and refreshNuxtData.\nWatch\n\nTo re-run your fetching function each time other reactive values in your application change, use the watch option. You can use it for one or multiple watchable elements.\n\nconst id = ref(1)\n\n\n\nconst { data, error, refresh } = await useFetch('/api/users', {\n\n  /* Changing the id will trigger a refetch */\n\n  watch: [id]\n\n})\n\n\nNote that watching a reactive value won't change the URL fetched. For example, this will keep fetching the same initial ID of the user because the URL is constructed at the moment the function is invoked.\n\nconst id = ref(1)\n\n\n\nconst { data, error, refresh } = await useFetch(`/api/users/${id.value}`, {\n\n  watch: [id]\n\n})\n\n\nIf you need to change the URL based on a reactive value, you may want to use a computed URL instead.\n\nComputed URL\n\nSometimes you may need to compute an URL from reactive values, and refresh the data each time these change. Instead of juggling your way around, you can attach each param as a reactive value. Nuxt will automatically use the reactive value and re-fetch each time it changes.\n\nconst id = ref(null)\n\n\n\nconst { data, pending } = useLazyFetch('/api/user', {\n\n  query: {\n\n    user_id: id\n\n  }\n\n})\n\n\nIn the case of more complex URL construction, you may use a callback as a computed getter that returns the URL string.\n\nEvery time a dependency changes, the data will be fetched using the newly constructed URL. Combine this with not-immediate, and you can wait until the reactive element changes before fetching.\n\n<script setup lang=\"ts\">\n\nconst id = ref(null)\n\n\n\nconst { data, pending, status } = useLazyFetch(() => `/api/users/${id.value}`, {\n\n  immediate: false\n\n})\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <!-- disable the input while fetching -->\n\n    <input v-model=\"id\" type=\"number\" :disabled=\"pending\"/>\n\n\n\n    <div v-if=\"status === 'idle'\">\n\n      Type an user ID\n\n    </div>\n\n    \n\n    <div v-else-if=\"pending\">\n\n      Loading ...\n\n    </div>\n\n\n\n    <div v-else>\n\n      {{ data }}\n\n    </div>\n\n  </div>\n\n</template>\n\n\nIf you need to force a refresh when other reactive values change, you can also watch other values.\n\nNot immediate\n\nThe useFetch composable will start fetching data the moment is invoked. You may prevent this by setting immediate: false, for example, to wait for user interaction.\n\nWith that, you will need both the status to handle the fetch lifecycle, and execute to start the data fetch.\n\n<script setup lang=\"ts\">\n\nconst { data, error, execute, pending, status } = await useLazyFetch('/api/comments')\n\n</script>\n\n\n\n<template>\n\n  <div v-if=\"status === 'idle'\">\n\n    <button @click=\"execute\">Get data</button>\n\n  </div>\n\n\n\n  <div v-else-if=\"pending\">\n\n    Loading comments...\n\n  </div>\n\n\n\n  <div v-else>\n\n    {{ data }}\n\n  </div>\n\n</template>\n\n\nFor finer control, the status variable can be:\n\nidle when the fetch hasn't started\npending when a fetch has started but not yet completed\nerror when the fetch fails\nsuccess when the fetch is completed successfully\nPassing Headers and cookies\n\nWhen we call $fetch in the browser, user headers like cookie will be directly sent to the API. But during server-side-rendering, since the $fetch request takes place 'internally' within the server, it doesn't include the user's browser cookies, nor does it pass on cookies from the fetch response.\n\nPass Client Headers to the API\n\nWe can use useRequestHeaders to access and proxy cookies to the API from server-side.\n\nThe example below adds the request headers to an isomorphic $fetch call to ensure that the API endpoint has access to the same cookie header originally sent by the user.\n\n<script setup lang=\"ts\">\n\nconst headers = useRequestHeaders(['cookie'])\n\n\n\nconst { data } = await useFetch('/api/me', { headers })\n\n</script>\n\nBe very careful before proxying headers to an external API and just include headers that you need. Not all headers are safe to be bypassed and might introduce unwanted behavior. Here is a list of common headers that are NOT to be proxied:\nhost, accept\ncontent-length, content-md5, content-type\nx-forwarded-host, x-forwarded-port, x-forwarded-proto\ncf-connecting-ip, cf-ray\nPass Cookies From Server-side API Calls on SSR Response\n\nIf you want to pass on/proxy cookies in the other direction, from an internal request back to the client, you will need to handle this yourself.\n\ncomposables/fetch.ts\nimport { appendResponseHeader, H3Event } from 'h3'\n\n\n\nexport const fetchWithCookie = async (event: H3Event, url: string) => {\n\n  /* Get the response from the server endpoint */\n\n  const res = await $fetch.raw(url)\n\n  /* Get the cookies from the response */\n\n  const cookies = (res.headers.get('set-cookie') || '').split(',')\n\n  /* Attach each cookie to our incoming Request */\n\n  for (const cookie of cookies) {\n\n    appendResponseHeader(event, 'set-cookie', cookie)\n\n  }\n\n  /* Return the data of the response */\n\n  return res._data\n\n}\n\n<script setup lang=\"ts\">\n\n// This composable will automatically pass cookies to the client\n\nconst event = useRequestEvent()\n\n\n\nconst result = await fetchWithCookie(event, '/api/with-cookie')\n\n\n\nonMounted(() => console.log(document.cookie))\n\n</script>\n\nOptions API support\n\nNuxt 3 provides a way to perform asyncData fetching within the Options API. You must wrap your component definition within defineNuxtComponent for this to work.\n\n<script>\n\nexport default defineNuxtComponent({\n\n  /* Use the fetchKey option to provide a unique key */\n\n  fetchKey: 'hello',\n\n  async asyncData () {\n\n    return {\n\n      hello: await $fetch('/api/hello')\n\n    }\n\n  }\n\n})\n\n</script>\n\nUsing <script setup lang=\"ts\"> is the recommended way of declaring Vue components in Nuxt 3.\n Read more in Docs > API > Utils > Define Nuxt Component.\nSerialization\n\nWhen fetching data from the server directory, the response is serialized using JSON.stringify. However, since serialization is limited to only JavaScript primitive types, Nuxt does its best to convert the return type of $fetch and useFetch to match the actual value.\n\nLearn more about JSON.stringify limitations.\nExample\nserver/api/foo.ts\nexport default defineEventHandler(() => {\n\n  return new Date()\n\n})\n\napp.vue\n<script setup lang=\"ts\">\n\n// Type of `data` is inferred as string even though we returned a Date object\n\nconst { data } = await useFetch('/api/foo')\n\n</script>\n\nCustom serializer function\n\nTo customize the serialization behavior, you can define a toJSON function on your returned object. If you define a toJSON method, Nuxt will respect the return type of the function and will not try to convert the types.\n\nserver/api/bar.ts\nexport default defineEventHandler(() => {\n\n  const data = {\n\n    createdAt: new Date(),\n\n\n\n    toJSON() {\n\n      return {\n\n        createdAt: {\n\n          year: this.createdAt.getFullYear(),\n\n          month: this.createdAt.getMonth(),\n\n          day: this.createdAt.getDate(),\n\n        },\n\n      }\n\n    },\n\n  }\n\n  return data\n\n})\n\napp.vue\n<script setup lang=\"ts\">\n\n// Type of `data` is inferred as\n\n// {\n\n//   createdAt: {\n\n//     year: number\n\n//     month: number\n\n//     day: number\n\n//   }\n\n// }\n\nconst { data } = await useFetch('/api/bar')\n\n</script>\n\nUsing an alternative serializer\n\nNuxt does not currently support an alternative serializer to JSON.stringify. However, you can return your payload as a normal string and utilize the toJSON method to maintain type safety.\n\nIn the example below, we use superjson as our serializer.\n\nserver/api/superjson.ts\nimport superjson from 'superjson'\n\n\n\nexport default defineEventHandler(() => {\n\n  const data = {\n\n    createdAt: new Date(),\n\n\n\n    // Workaround the type conversion\n\n    toJSON() {\n\n      return this\n\n    }\n\n  }\n\n\n\n  // Serialize the output to string, using superjson\n\n  return superjson.stringify(data) as unknown as typeof data\n\n})\n\napp.vue\n<script setup lang=\"ts\">\n\nimport superjson from 'superjson'\n\n\n\n// `date` is inferred as { createdAt: Date } and you can safely use the Date object methods\n\nconst { data } = await useFetch('/api/superjson', {\n\n  transform: (value) => {\n\n    return superjson.parse(value as unknown as string)\n\n  },\n\n})\n\n</script>\n\n\nTransitions\n\nApply transitions between pages and layouts with Vue or native browser View Transitions.\n\nState Management\n\nNuxt provides powerful state management libraries and the useState composable to create a reactive and SSR-friendly shared state."
  },
  {
    "title": "SEO and Meta · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/seo-meta",
    "html": "Get Started\nSEO and Meta\n\nImprove your Nuxt app's SEO with powerful head config, composables and components.\n\nDefaults\n\nOut-of-the-box, Nuxt provides sane defaults, which you can override if needed.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  app: {\n\n    head: {\n\n      charset: 'utf-8',\n\n      viewport: 'width=device-width, initial-scale=1',\n\n    }\n\n  }\n\n})\n\n\nProviding an app.head property in your nuxt.config.ts allows you to customize the head for your entire app.\n\nThis method does not allow you to provide reactive data. We recommend to use useHead() in app.vue.\n\nShortcuts are available to make configuration easier: charset and viewport. You can also provide any of the keys listed below in Types.\n\nuseHead\n\nThe useHead composable function allows you to manage your head tags in a programmatic and reactive way, powered by Unhead.\n\nAs with all composables, it can only be used with a components setup and lifecycle hooks.\n\napp.vue\n<script setup lang=\"ts\">\n\nuseHead({\n\n  title: 'My App',\n\n  meta: [\n\n    { name: 'description', content: 'My amazing site.' }\n\n  ],\n\n  bodyAttrs: {\n\n    class: 'test'\n\n  },\n\n  script: [ { innerHTML: 'console.log(\\'Hello world\\')' } ]\n\n})\n\n</script>\n\n\nWe recommend to take a look at the useHead and useHeadSafe composables.\n\nuseSeoMeta\n\nThe useSeoMeta composable lets you define your site's SEO meta tags as a flat object with full TypeScript support.\n\nThis helps you avoid typos and common mistakes, such as using name instead of property.\n\napp.vue\n<script setup lang=\"ts\">\n\nuseSeoMeta({\n\n  title: 'My Amazing Site',\n\n  ogTitle: 'My Amazing Site',\n\n  description: 'This is my amazing site, let me tell you all about it.',\n\n  ogDescription: 'This is my amazing site, let me tell you all about it.',\n\n  ogImage: 'https://example.com/image.png',\n\n  twitterCard: 'summary_large_image',\n\n})\n\n</script>\n\n Read more in Docs > API > Composables > Use Seo Meta.\nComponents\n\nNuxt provides <Title>, <Base>, <NoScript>, <Style>, <Meta>, <Link>, <Body>, <Html> and <Head> components so that you can interact directly with your metadata within your component's template.\n\nBecause these component names match native HTML elements, it is very important that they are capitalized in the template.\n\n<Head> and <Body> can accept nested meta tags (for aesthetic reasons) but this has no effect on where the nested meta tags are rendered in the final HTML.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst title = ref('Hello World')\n\n</script>\n\n\n\n<template>\n\n  <div>\n\n    <Head>\n\n      <Title>{{ title }}</Title>\n\n      <Meta name=\"description\" :content=\"title\" />\n\n      <Style type=\"text/css\" children=\"body { background-color: green; }\" />\n\n    </Head>\n\n\n\n    <h1>{{ title }}</h1>\n\n  </div>\n\n</template>\n\nTypes\n\nBelow are the non-reactive types used for useHead, app.head and components.\n\ninterface MetaObject {\n\n  title?: string\n\n  titleTemplate?: string | ((title?: string) => string)\n\n  templateParams?: Record<string, string | Record<string, string>>\n\n  base?: Base\n\n  link?: Link[]\n\n  meta?: Meta[]\n\n  style?: Style[]\n\n  script?: Script[]\n\n  noscript?: Noscript[];\n\n  htmlAttrs?: HtmlAttributes;\n\n  bodyAttrs?: BodyAttributes;\n\n}\n\n\nSee @unhead/schema for more detailed types.\n\nFeatures\nReactivity\n\nReactivity is supported on all properties, as computed, getters and reactive.\n\nIt's recommended to use getters (() => value) over computed (computed(() => value)).\n\nuseHead\nuseSeoMeta\nComponents\n<script setup lang=\"ts\">\n\nconst description = ref('My amazing site.')\n\n\n\nuseHead({\n\n  meta: [\n\n    { name: 'description', content: description }\n\n  ],\n\n})\n\n</script>\n\nTitle Template\n\nYou can use the titleTemplate option to provide a dynamic template for customizing the title of your site. for example, by adding the name of your site to the title of every page.\n\nThe titleTemplate can either be a string, where %s is replaced with the title, or a function.\n\nIf you want to use a function (for full control), then this cannot be set in your nuxt.config, and it is recommended instead to set it within your app.vue file, where it will apply to all pages on your site:\n\nuseHead\n<script setup lang=\"ts\">\n\nuseHead({\n\n  titleTemplate: (titleChunk) => {\n\n    return titleChunk ? `${titleChunk} - Site Title` : 'Site Title';\n\n  }\n\n})\n\n</script>\n\n\nNow, if you set the title to My Page with useHead on another page of your site, the title would appear as 'My Page - Site Title' in the browser tab. You could also pass null to default to the site title.\n\nBody Tags\n\nYou can use the tagPosition: 'bodyClose' option on applicable tags to append them to the end of the <body> tag.\n\nFor example:\n\n<script setup lang=\"ts\">\n\nuseHead({\n\n  script: [\n\n    {\n\n      src: 'https://third-party-script.com',\n\n      // valid options are: 'head' | 'bodyClose' | 'bodyOpen'\n\n      tagPosition: 'bodyClose'\n\n    }\n\n  ]\n\n})\n\n</script>\n\nExamples\nWith definePageMeta\n\nWithin your pages/ directory, you can use definePageMeta along with useHead to set metadata based on the current route.\n\nFor example, you can first set the current page title (this is extracted at build time via a macro, so it can't be set dynamically):\n\npages/some-page.vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  title: 'Some Page'\n\n})\n\n</script>\n\n\nAnd then in your layout file, you might use the route's metadata you have previously set:\n\nlayouts/default.vue\n<script setup lang=\"ts\">\n\nconst route = useRoute()\n\n\n\nuseHead({\n\n  meta: [{ property: 'og:title', content: `App Name - ${route.meta.title}` }]\n\n})\n\n</script>\n\n Read and edit a live example in Docs > Examples > Features > Meta Tags.\n Read more in Docs > Guide > Directory Structure > Pages > #page Metadata.\nDynamic Title\n\nIn the example below, titleTemplate is set either as a string with the %s placeholder or as a function, which allows greater flexibility in setting the page title dynamically for each route of your Nuxt app:\n\napp.vue\n<script setup lang=\"ts\">\n\nuseHead({\n\n  // as a string,\n\n  // where `%s` is replaced with the title\n\n  titleTemplate: '%s - Site Title',\n\n  // ... or as a function\n\n  titleTemplate: (productCategory) => {\n\n    return productCategory\n\n      ? `${productCategory} - Site Title`\n\n      : 'Site Title'\n\n  }\n\n})\n\n</script>\n\n\nnuxt.config is also used as an alternative way of setting the page title. However, nuxt.config does not allow the page title to be dynamic. Therefore, it is recommended to use titleTemplate in the app.vue file to add a dynamic title, which is then applied to all routes of your Nuxt app.\n\nExternal CSS\n\nThe example below shows how you might enable Google Fonts using either the link property of the useHead composable or using the <Link> component:\n\nuseHead\nComponents\n<script setup lang=\"ts\">\n\nuseHead({\n\n  link: [\n\n    {\n\n      rel: 'preconnect',\n\n      href: 'https://fonts.googleapis.com'\n\n    },\n\n    {\n\n      rel: 'stylesheet',\n\n      href: 'https://fonts.googleapis.com/css2?family=Roboto&display=swap',\n\n      crossorigin: ''\n\n    }\n\n  ]\n\n})\n\n</script>\n\n\nRouting\n\nNuxt file-system routing creates a route for every file in the pages/ directory.\n\nTransitions\n\nApply transitions between pages and layouts with Vue or native browser View Transitions."
  },
  {
    "title": "Styling · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/styling",
    "html": "Get Started\nStyling\n\nLearn how to style your Nuxt application.\n\nNuxt is highly flexible when it comes to styling. Write your own styles, or reference local and external stylesheets. You can use CSS preprocessors, CSS frameworks, UI libraries and Nuxt modules to style your application.\n\nLocal Stylesheets\n\nIf you're writing local stylesheets, the natural place to put them is the assets/ directory.\n\nImporting Within Components\n\nYou can import stylesheets in your pages, layouts and components directly. You can use a javascript import, or a css @import statement.\n\npages/index.vue\n<script>\n\n// Use a static import for server-side compatibility\n\nimport '~/assets/css/first.css'\n\n\n\n// Caution: Dynamic imports are not server-side compatible\n\nimport('~/assets/css/first.css')\n\n</script>\n\n\n\n<style>\n\n@import url(\"~/assets/css/second.css\");\n\n</style>\n\nThe stylesheets will be inlined in the HTML rendered by Nuxt.\nThe CSS Property\n\nYou can also use the css property in the Nuxt configuration. The natural place for your stylesheets is the assets/ directory. You can then reference its path and Nuxt will include it to all the pages of your application.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  css: ['~/assets/css/main.css']\n\n})\n\nThe stylesheets will be inlined in the HTML rendered by Nuxt, injected globally and present in all pages.\nWorking With Fonts\n\nPlace your local fonts files in your ~/public/ directory, for example in ~/public/fonts. You can then reference them in your stylesheets using url().\n\nassets/css/main.css\n@font-face {\n\n  font-family: 'FarAwayGalaxy';\n\n  src: url('/fonts/FarAwayGalaxy.woff') format('woff');\n\n  font-weight: normal;\n\n  font-style: normal;\n\n  font-display: swap;\n\n}\n\n\nThen reference your fonts by name in your stylesheets, pages or components:\n\n<style>\n\nh1 {\n\n  font-family: 'FarAwayGalaxy', sans-serif;\n\n}\n\n</style>\n\nStylesheets Distributed Through NPM\n\nYou can also reference stylesheets that are distributed through npm. Let's use the popular animate.css library as an example.\n\nTerminal\nnpm install animate.css\n\n\nThen you can reference it directly in your pages, layouts and components:\n\napp.vue\n<script>\n\nimport 'animate.css'\n\n</script>\n\n\n\n<style>\n\n@import url(\"animate.css\");\n\n</style>\n\n\nThe package can also be referenced as a string in the css property of your Nuxt configuration.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  css: ['animate.css']\n\n})\n\nExternal Stylesheets\n\nYou can include external stylesheets in your application by adding a link element in the head section of your nuxt.config file. You can achieve this result using different methods. Note that local stylesheets can also be included like this.\n\nYou can manipulate the head with the app.head property of your Nuxt configuration:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  app: {\n\n    head: {\n\n      link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]\n\n    }\n\n}})\n\nDynamically Adding Stylesheets\n\nYou can use the useHead composable to dynamically set a value in your head in your code.\n\n Read more in Docs > API > Composables > Use Head.\nuseHead({\n\n  link: [{ rel: 'stylesheet', href: 'https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css' }]\n\n})\n\n\nNuxt uses unhead under the hood, and you can refer to its full documentation here.\n\nModifying The Rendered Head With A Nitro Plugin\n\nIf you need more advanced control, you can intercept the rendered html with a hook and modify the head programmatically.\n\nCreate a plugin in ~/server/plugins/my-plugin.ts like this:\n\nserver/plugins/my-plugin.ts\nexport default defineNitroPlugin((nitro) => {\n\n  nitro.hooks.hook('render:html', (html) => {\n\n    html.head.push('<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css\">')\n\n  })\n\n})\n\n\nExternal stylesheets are render-blocking resources: they must be loaded and processed before the browser renders the page. Web pages that contain unnecessarily large styles take longer to render. You can read more about it on web.dev.\n\nUsing Preprocessors\n\nTo use a preprocessor like SCSS, Sass, Less or Stylus, install it first.\n\nSass & SCSS\nLess\nStylus\nnpm install sass\n\n\nThe natural place to write your stylesheets is the assets directory. You can then import your source files in your app.vue (or layouts files) using your preprocessor's syntax.\n\npages/app.vue\n<style lang=\"scss\">\n\n@use \"~/assets/scss/main.scss\";\n\n</style>\n\n\nAlternatively, you can use the css property of your Nuxt configuration.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  css: ['~/assets/scss/main.scss']\n\n})\n\nIn both cases, the compiled stylesheets will be inlined in the HTML rendered by Nuxt.\n\nIf you need to inject code in pre-processed files, like a sass partial with color variables, you can do so with the vite preprocessors options.\n\nCreate some partials in your assets directory:\n\nassets/_colors.scss\nassets/_colors.sass\n$primary: #49240F;\n\n$secondary: #E4A79D;\n\n\nThen in your nuxt.config :\n\nSCSS\nSASS\nexport default defineNuxtConfig({\n\n  vite: {\n\n    css: {\n\n      preprocessorOptions: {\n\n        scss: {\n\n          additionalData: '@use \"@/assets/_colors.scss\" as *;'\n\n        }\n\n      }\n\n    }\n\n  }\n\n})\n\n\nNuxt uses Vite by default. If you wish to use webpack instead, refer to each preprocessor loader documentation.\n\nSingle File Components (SFC) Styling\n\nOne of the best things about Vue and SFC is how great it is at naturally dealing with styling. You can directly write CSS or preprocessor code in the style block of your components file, therefore you will have fantastic developer experience without having to use something like CSS-in-JS. However if you wish to use CSS-in-JS, you can find 3rd party libraries and modules that support it, such as pinceau.\n\nYou can refer to the Vue docs for a comprehensive reference about styling components in SFC.\n\nClass And Style Bindings\n\nYou can leverage Vue SFC features to style your components with class and style attributes.\n\nRef and Reactive\nComputed\nArray\nStyle\n<script setup lang=\"ts\">\n\nconst isActive = ref(true)\n\nconst hasError = ref(false)\n\nconst classObject = reactive({\n\n  active: true,\n\n  'text-danger': false\n\n})\n\n</script>\n\n\n\n<template>\n\n  <div class=\"static\" :class=\"{ active: isActive, 'text-danger': hasError }\"></div>\n\n  <div :class=\"classObject\"></div>\n\n</template>\n\n\nRefer to the Vue docs for more information.\n\nDynamic Styles With v-bind\n\nYou can reference JavaScript variable and expression within your style blocks with the v-bind function. The binding will be dynamic, meaning that if the variable value changes, the style will be updated.\n\n<script setup lang=\"ts\">\n\nconst color = ref(\"red\")\n\n</script>\n\n\n\n<template>\n\n  <div class=\"text\">hello</div>\n\n</template>\n\n\n\n<style>\n\n.text {\n\n  color: v-bind(color);\n\n}\n\n</style>\n\nScoped Styles\n\nThe scoped attribute allows you to style components in isolation. The styles declared with this attribute will only apply to this component.\n\n<template>\n\n  <div class=\"example\">hi</div>\n\n</template>\n\n\n\n<style scoped>\n\n.example {\n\n  color: red;\n\n}\n\n</style>\n\nCSS Modules\n\nYou can use CSS Modules with the module attribute. Access it with the injected $style variable.\n\n<template>\n\n  <p :class=\"$style.red\">This should be red</p>\n\n</template>\n\n\n\n<style module>\n\n.red {\n\n  color: red;\n\n}\n\n</style>\n\nPreprocessors Support\n\nSFC style blocks support preprocessors syntax. Vite come with built-in support for .scss, .sass, .less, .styl and .stylus files without configuration. You just need to install them first, and they will be available directly in SFC with the lang attribute.\n\nSCSS\nSass\nLESS\nStylus\n<style lang=\"scss\">\n\n  /* Write scss here */\n\n</style>\n\n\nYou can refer to the Vite CSS docs and the @vitejs/plugin-vue docs. For webpack users, refer to the vue loader docs.\n\nUsing PostCSS\n\nNuxt comes with postcss built-in. You can configure it in your nuxt.config file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  postcss: {\n\n    plugins: {\n\n      'postcss-nested': {}\n\n      \"postcss-custom-media\": {}\n\n    }\n\n  }\n\n})\n\n\nFor proper syntax highlighting in SFC, you can use the postcss lang attribute.\n\n<style lang=\"postcss\">\n\n  /* Write stylus here */\n\n</style>\n\n\nBy default, Nuxt comes with the following plugins already pre-configured:\n\npostcss-import: Improves the @import rule\npostcss-url: Transforms url() statements\nautoprefixer: Automatically adds vendor prefixes\ncssnano: Minification and purge\nLeveraging Layouts For Multiple Styles\n\nIf you need to style different parts of your application completely differently, you can use layouts. Use different styles for different layouts.\n\n<template>\n\n  <div class=\"default-layout\">\n\n    <h1>Default Layout</h1>\n\n    <slot />\n\n  </div>\n\n</template>\n\n\n\n<style>\n\n.default-layout {\n\n  color: red;\n\n}\n\n</style>\n\n Read more in Docs > Guide > Directory Structure > Layouts.\nThird Party Libraries And Modules\n\nNuxt isn't opinionated when it comes to styling and provides you with a wide variety of options. You can use any styling tool that you want, such as popular libraries like UnoCSS or Tailwind CSS.\n\nThe community and the Nuxt team have developed plenty of Nuxt modules to makes the integration easier. You can discover them on the modules section of the website. Here are a few modules to help you get started:\n\nUnoCSS: Instant on-demand atomic CSS engine\nTailwind CSS: Utility-first CSS framework\nFontaine: Font metric fallback\nPinceau: Adaptable styling framework\nNuxt UI: A UI Library for Modern Web Apps\n\nNuxt modules provide you with a good developer experience out of the box, but remember that if your favorite tool doesn't have a module, it doesn't mean that you can't use it with Nuxt! You can configure it yourself for your own project. Depending on the tool, you might need to use a Nuxt plugin and/or make your own module. Share them with the community if you do!\n\nEasily Load Webfonts\n\nYou can use the Nuxt Google Fonts module to load Google Fonts.\n\nIf you are using UnoCSS, note that it comes with a web fonts presets to conveniently load fonts from common providers, including Google Fonts and more.\n\nAdvanced\nTransitions\n\nNuxt comes with the same <Transition> element that Vue has, and also has support for the experimental View Transitions API.\n\n Read more in Docs > Getting Started > Transitions.\nFont Advanced Optimization\n\nWe would recommend using Fontaine to reduce your CLS. If you need something more advanced, consider creating a Nuxt module to extend the build process or the Nuxt runtime.\n\nAlways remember to take advantage of the various tools and techniques available in the Web ecosystem at large to make styling your application easier and more efficient. Whether you're using native CSS, a preprocessor, postcss, a UI library or a module, Nuxt has got you covered. Happy styling!\nLCP Advanced optimizations\n\nYou can do the following to speed-up the download of your global CSS files:\n\nUse a CDN so the files are physically closer to your users\nCompress your assets, ideally using Brotli\nUse HTTP2/HTTP3 for delivery\nHost your assets on the same domain (do not use a different subdomain)\n\nMost of these things should be done for you automatically if you're using modern platforms like Cloudflare, Netlify or Vercel. You can find an LCP optimization guide on web.dev.\n\nIf all of your CSS is inlined by Nuxt, you can (experimentally) completely stop external CSS files from being referenced in your rendered HTML. You can achieve that with a hook, that you can place in a module, or in your Nuxt configuration file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  hooks: {\n\n    'build:manifest': (manifest) => {\n\n      // find the app entry, css list\n\n      const css = manifest['node_modules/nuxt/dist/app/entry.js']?.css\n\n      if (css) {\n\n        // start from the end of the array and go to the beginning\n\n        for (let i = css.length - 1; i >= 0; i--) {\n\n          // if it starts with 'entry', remove it from the list\n\n          if (css[i].startsWith('entry')) css.splice(i, 1)\n\n        }\n\n      }\n\n    },\n\n  },\n\n})\n\n\nAssets\n\nNuxt offers two options for your assets.\n\nRouting\n\nNuxt file-system routing creates a route for every file in the pages/ directory."
  },
  {
    "title": "Routing · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/routing",
    "html": "Get Started\nRouting\n\nNuxt file-system routing creates a route for every file in the pages/ directory.\n\nOne core feature of Nuxt is the file system router. Every Vue file inside the pages/ directory creates a corresponding URL (or route) that displays the contents of the file. By using dynamic imports for each page, Nuxt leverages code-splitting to ship the minimum amount of JavaScript for the requested route.\n\nPages\n\nNuxt routing is based on vue-router and generates the routes from every component created in the pages/ directory, based on their filename.\n\nThis file system routing uses naming conventions to create dynamic and nested routes:\n\nDirectory Structure\nGenerated Router File\n| pages/\n\n---| about.vue\n\n---| index.vue\n\n---| posts/\n\n-----| [id].vue\n\n Read more in Docs > Guide > Directory Structure > Pages.\nNavigation\n\nThe <NuxtLink> component links pages between them. It renders an <a> tag with the href attribute set to the route of the page. Once the application is hydrated, page transitions are performed in JavaScript by updating the browser URL. This prevents full-page refreshes and allows for animated transitions.\n\nWhen a <NuxtLink> enters the viewport on the client side, Nuxt will automatically prefetch components and payload (generated pages) of the linked pages ahead of time, resulting in faster navigation.\n\npages/app.vue\n<template>\n\n  <header>\n\n    <nav>\n\n      <ul>\n\n        <li><NuxtLink to=\"/about\">About</NuxtLink></li>\n\n        <li><NuxtLink to=\"/posts/1\">Post 1</NuxtLink></li>\n\n        <li><NuxtLink to=\"/posts/2\">Post 2</NuxtLink></li>\n\n      </ul>\n\n    </nav>\n\n  </header>\n\n</template>\n\n Read more in Docs > API > Components > Nuxt Link.\nRoute Parameters\n\nThe useRoute() composable can be used in a <script setup> block or a setup() method of a Vue component to access the current route details.\n\npages/posts/[id].vue\n<script setup lang=\"ts\">\n\nconst route = useRoute()\n\n\n\n// When accessing /posts/1, route.params.id will be 1\n\nconsole.log(route.params.id)\n\n</script>\n\n Read more in Docs > API > Composables > Use Route.\nRoute Middleware\n\nNuxt provides a customizable route middleware framework you can use throughout your application, ideal for extracting code that you want to run before navigating to a particular route.\n\nRoute middleware runs within the Vue part of your Nuxt app. Despite the similar name, they are completely different from server middleware, which are run in the Nitro server part of your app.\n\nThere are three kinds of route middleware:\n\nAnonymous (or inline) route middleware, which are defined directly in the pages where they are used.\nNamed route middleware, which are placed in the middleware/ directory and will be automatically loaded via asynchronous import when used on a page. (Note: The route middleware name is normalized to kebab-case, so someMiddleware becomes some-middleware.)\nGlobal route middleware, which are placed in the middleware/ directory (with a .global suffix) and will be automatically run on every route change.\n\nExample of an auth middleware protecting the /dashboard page:\n\nmiddleware/auth.ts\npages/dashboard.vue\nexport default defineNuxtRouteMiddleware((to, from) => {\n\n  // isAuthenticated() is an example method verifying if a user is authenticated\n\n  if (isAuthenticated() === false) {\n\n    return navigateTo('/login')\n\n  }\n\n})\n\n Read more in Docs > Guide > Directory Structure > Middleware.\nRoute Validation\n\nNuxt offers route validation via the validate property in definePageMeta() in each page you wish to validate.\n\nThe validate property accepts the route as an argument. You can return a boolean value to determine whether or not this is a valid route to be rendered with this page. If you return false, and another match can't be found, this will cause a 404 error. You can also directly return an object with statusCode/statusMessage to respond immediately with an error (other matches will not be checked).\n\nIf you have a more complex use case, then you can use anonymous route middleware instead.\n\npages/posts/[id].vue\n<script setup lang=\"ts\">\n\ndefinePageMeta({\n\n  validate: async (route) => {\n\n    // Check if the id is made up of digits\n\n    return /^\\d+$/.test(route.params.id)\n\n  }\n\n})\n\n</script>\n\n Read more in Docs > API > Utils > Define Page Meta.\n\nStyling\n\nLearn how to style your Nuxt application.\n\nSEO and Meta\n\nImprove your Nuxt app's SEO with powerful head config, composables and components."
  },
  {
    "title": "Assets · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/assets",
    "html": "Get Started\nAssets\n\nNuxt offers two options for your assets.\n\nNuxt uses two directories to handle assets like stylesheets, fonts or images.\n\nThe public/ directory content is served at the server root as-is.\nThe assets/ directory contains by convention every asset that you want the build tool (Vite or webpack) to process.\nPublic Directory\n\nThe public/ directory is used as a public server for static assets publicly available at a defined URL of your application.\n\nYou can get a file in the public/ directory from your application's code or from a browser by the root URL /.\n\nExample\n\nFor example, referencing an image file in the public/img/ directory, available at the static URL /img/nuxt.png:\n\napp.vue\n<template>\n\n  <img src=\"/img/nuxt.png\" alt=\"Discover Nuxt 3\" />\n\n</template>\n\nAssets Directory\n\nNuxt uses Vite (default) or webpack to build and bundle your application. The main function of these build tools is to process JavaScript files, but they can be extended through plugins (for Vite) or loaders (for webpack) to process other kind of assets, like stylesheets, fonts or SVG. This step transforms the original file mainly for performance or caching purposes (such as stylesheets minification or browser cache invalidation).\n\nBy convention, Nuxt uses the assets/ directory to store these files but there is no auto-scan functionality for this directory, and you can use any other name for it.\n\nIn your application's code, you can reference a file located in the assets/ directory by using the ~/assets/ path.\n\nExample\n\nFor example, referencing an image file that will be processed if a build tool is configured to handle this file extension:\n\napp.vue\n<template>\n\n  <img src=\"~/assets/img/nuxt.png\" alt=\"Discover Nuxt 3\" />\n\n</template>\n\nNuxt won't serve files in the assets/ directory at a static URL like /assets/my-file.png. If you need a static URL, use the public/ directory.\nGlobal Styles Imports\n\nTo globally insert statements in your Nuxt components styles, you can use the Vite option at your nuxt.config file.\n\nExample\n\nIn this example, there is a sass partial file containing color variables to be used by your Nuxt pages and components\n\nassets/_colors.scss\nassets/_colors.sass\n$primary: #49240F;\n\n$secondary: #E4A79D;\n\n\nIn your nuxt.config\n\nSCSS\nSASS\nexport default defineNuxtConfig({\n\n  vite: {\n\n    css: {\n\n      preprocessorOptions: {\n\n        scss: {\n\n          additionalData: '@use \"@/assets/_colors.scss\" as *;'\n\n        }\n\n      }\n\n    }\n\n  }\n\n})\n\n\nViews\n\nNuxt provides several component layers to implement the user interface of your application.\n\nStyling\n\nLearn how to style your Nuxt application."
  },
  {
    "title": "Views · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/views",
    "html": "Get Started\nViews\n\nNuxt provides several component layers to implement the user interface of your application.\n\napp.vue\n\nBy default, Nuxt will treat this file as the entrypoint and render its content for every route of the application.\n\napp.vue\n<template>\n\n  <div>\n\n   <h1>Welcome to the homepage</h1>\n\n  </div>\n\n</template>\n\nIf you are familiar with Vue, you might wonder where main.js is (the file that normally creates a Vue app). Nuxt does this behind the scene.\nComponents\n\nMost components are reusable pieces of the user interface, like buttons and menus. In Nuxt, you can create these components in the components/ directory, and they will be automatically available across your application without having to explicitly import them.\n\napp.vue\ncomponents/AppAlert.vue\n<template>\n\n  <div>\n\n    <h1>Welcome to the homepage</h1>\n\n    <AppAlert>\n\n      This is an auto-imported component.\n\n    </AppAlert>\n\n  </div>\n\n</template>\n\nPages\n\nPages represent views for each specific route pattern. Every file in the pages/ directory represents a different route displaying its content.\n\nTo use pages, create pages/index.vue file and add <NuxtPage /> component to the app.vue (or remove app.vue for default entry). You can now create more pages and their corresponding routes by adding new files in the pages/ directory.\n\npages/index.vue\npages/about.vue\n<template>\n\n  <div>\n\n    <h1>Welcome to the homepage</h1>\n\n    <AppAlert>\n\n      This is an auto-imported component\n\n    </AppAlert>\n\n  </div>\n\n</template>\n\n Read more in Routing Section.\nLayouts\n\nLayouts are wrappers around pages that contain a common User Interface for several pages, such as a header and footer display. Layouts are Vue files using <slot /> components to display the page content. The layouts/default.vue file will be used by default. Custom layouts can be set as part of your page metadata.\n\nIf you only have a single layout in your application, we recommend using app.vue with <NuxtPage /> instead.\nlayouts/default.vue\npages/index.vue\npages/about.vue\n<template>\n\n  <div>\n\n    <AppHeader />\n\n    <slot />\n\n    <AppFooter />\n\n  </div>\n\n</template>\n\n\nIf you want to create more layouts and learn how to use them in your pages, find more information in the Layouts section.\n\nAdvanced: Extending the HTML template\nIf you only need to modify the <head>, you can refer to the SEO and meta section.\n\nYou can have full control over the HTML template by adding a Nitro plugin that registers a hook. The callback function of the render:html hook allows you to mutate the HTML before it is sent to the client.\n\nserver/plugins/extend-html.ts\nexport default defineNitroPlugin((nitroApp) => {\n\n  nitroApp.hooks.hook('render:html', (html, { event }) => { \n\n    // This will be an object representation of the html template.\n\n    console.log(html)\n\n    html.head.push(`<meta name=\"description\" content=\"My custom description\" />`)\n\n  })\n\n  // You can also intercept the response here.\n\n  nitroApp.hooks.hook('render:response', (response, { event }) => { console.log(response) })\n\n})\n\n Read more in Docs > Guide > Going Further > Hooks.\n\nConfiguration\n\nNuxt is configured with sensible defaults to make you productive.\n\nAssets\n\nNuxt offers two options for your assets."
  },
  {
    "title": "Configuration · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/configuration",
    "html": "Get Started\nConfiguration\n\nNuxt is configured with sensible defaults to make you productive.\n\nBy default, Nuxt is configured to cover most use cases. The nuxt.config.ts file can override or extend this default configuration.\n\nNuxt Configuration\n\nThe nuxt.config.ts file is located at the root of a Nuxt project and can override or extend the application's behavior.\n\nA minimal configuration file exports the defineNuxtConfig function containing an object with your configuration. The defineNuxtConfig helper is globally available without import.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  // My Nuxt config\n\n})\n\n\nThis file will often be mentioned in the documentation, for example to add custom scripts, register modules or change rendering modes.\n\nEvery option is described in the Configuration Reference.\nYou don't have to use TypeScript to build an application with Nuxt. However, it is strongly recommended to use the .ts extension for the nuxt.config file. This way you can benefit from hints in your IDE to avoid typos and mistakes while editing your configuration.\nEnvironment overrides\n\nYou can configure fully typed, per-environment overrides in your nuxt.config\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  $production: {\n\n    routeRules: {\n\n      '/**': { isr: true }\n\n    }\n\n  },\n\n  $development: {\n\n    //\n\n  }\n\n})\n\nIf you're authoring layers, you can also use the $meta key to provide metadata that you or the consumers of your layer might use.\nEnvironment Variables and Private Tokens\n\nThe runtimeConfig API exposes values like environment variables to the rest of your application. By default, these keys are only available server-side. The keys within runtimeConfig.public are also available client-side.\n\nThose values should be defined in nuxt.config and can be overridden using environment variables.\n\nnuxt.config.ts\n.env\nexport default defineNuxtConfig({\n\n  runtimeConfig: {\n\n    // The private keys which are only available server-side\n\n    apiSecret: '123',\n\n    // Keys within public are also exposed client-side\n\n    public: {\n\n      apiBase: '/api'\n\n    }\n\n  }\n\n})\n\n\nThese variables are exposed to the rest of your application using the useRuntimeConfig() composable.\n\npages/index.vue\n<script setup lang=\"ts\">\n\nconst runtimeConfig = useRuntimeConfig()\n\n</script>\n\n Read more in Docs > Guide > Going Further > Runtime Config.\nApp Configuration\n\nThe app.config.ts file, located in the source directory (by default the root of the project), is used to expose public variables that can be determined at build time. Contrary to the runtimeConfig option, these can not be overridden using environment variables.\n\nA minimal configuration file exports the defineAppConfig function containing an object with your configuration. The defineAppConfig helper is globally available without import.\n\napp.config.ts\nexport default defineAppConfig({\n\n  title: 'Hello Nuxt',\n\n  theme: {\n\n    dark: true,\n\n    colors: {\n\n      primary: '#ff0000'\n\n    }\n\n  }\n\n})\n\n\nThese variables are exposed to the rest of your application using the useAppConfig composable.\n\npages/index.vue\n<script setup lang=\"ts\">\n\nconst appConfig = useAppConfig()\n\n</script>\n\n Read more in Docs > Guide > Directory Structure > App Config.\nruntimeConfig vs app.config\n\nAs stated above, runtimeConfig and app.config are both used to expose variables to the rest of your application. To determine whether you should use one or the other, here are some guidelines:\n\nruntimeConfig: Private or public tokens that need to be specified after build using environment variables.\napp.config : Public tokens that are determined at build time, website configuration such as theme variant, title and any project config that are not sensitive.\nFeature\truntimeConfig\tapp.config\nClient Side\tHydrated\tBundled\nEnvironment Variables\t✅ Yes\t❌ No\nReactive\t✅ Yes\t✅ Yes\nTypes support\t✅ Partial\t✅ Yes\nConfiguration per Request\t❌ No\t✅ Yes\nHot Module Replacement\t❌ No\t✅ Yes\nNon primitive JS types\t❌ No\t✅ Yes\nExternal Configuration Files\n\nNuxt uses nuxt.config.ts file as the single source of trust for configurations and skips reading external configuration files. During the course of building your project, you may have a need to configure those. The following table highlights common configurations and, where applicable, how they can be configured with Nuxt.\n\nName\tConfig File\tHow To Configure\nNitro\tnitro.config.ts\tUse nitro key in nuxt.config\nPostCSS\tpostcss.config.js\tUse postcss key in nuxt.config\nVite\tvite.config.ts\tUse vite key in nuxt.config\nwebpack\twebpack.config.ts\tUse webpack key in nuxt.config\n\nHere is a list of other common config files:\n\nName\tConfig File\tHow To Configure\nTypeScript\ttsconfig.json\tMore Info\nESLint\t.eslintrc.js\tMore Info\nPrettier\t.prettierrc.json\tMore Info\nStylelint\t.stylelintrc.json\tMore Info\nTailwindCSS\ttailwind.config.js\tMore Info\nVitest\tvitest.config.ts\tMore Info\nVue Configuration\nWith Vite\n\nIf you need to pass options to @vitejs/plugin-vue or @vitejs/plugin-vue-jsx, you can do this in your nuxt.config file.\n\nvite.vue for @vitejs/plugin-vue. Check available options here.\nvite.vueJsx for @vitejs/plugin-vue-jsx. Check available options here.\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  vite: {\n\n    vue: {\n\n      customElement: true\n\n    },\n\n    vueJsx: {\n\n      mergeProps: true\n\n    }\n\n  }\n\n})\n\n Read more in Docs > API > Configuration > Nuxt Config #vue.\nWith webpack\n\nIf you use webpack and need to configure vue-loader, you can do this using webpack.loaders.vue key inside your nuxt.config file. The available options are defined here.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  webpack: {\n\n    loaders: {\n\n      vue: {\n\n        hotReload: true,\n\n      }\n\n    }\n\n  }\n\n})\n\n Read more in Docs > API > Configuration > Nuxt Config #loaders.\nEnabling Experimental Vue Features\n\nYou may need to enable experimental features in Vue, such as defineModel or propsDestructure. Nuxt provides an easy way to do that in nuxt.config.ts, no matter which builder you are using:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  vue: {\n\n    defineModel: true,\n\n    propsDestructure: true\n\n  }\n\n})\n\nexperimental reactivityTransform migration from Vue 3.4 and Nuxt 3.9\n\nSince Nuxt 3.9 and Vue 3.4, reactivityTransform has been moved from Vue to Vue Macros which has a Nuxt integration.\n\n Read more in Docs > API > Configuration > Nuxt Config #vue 1.\n\nInstallation\n\nGet started with Nuxt quickly with our online starters or start locally with your terminal.\n\nViews\n\nNuxt provides several component layers to implement the user interface of your application."
  },
  {
    "title": "Installation · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/installation",
    "html": "Get Started\nInstallation\n\nGet started with Nuxt quickly with our online starters or start locally with your terminal.\n\nPlay Online\n\nYou can start playing with Nuxt 3 in your browser using our online sandboxes:\n\nOpen on StackBlitz\n\nOpen on CodeSandbox\n\nStart with one of our starters and themes directly by opening nuxt.new.\n\nNew Project\nPrerequisites\nNode.js - v18.0.0 or newer\nText editor - We recommend Visual Studio Code with the Volar Extension\nTerminal - In order to run Nuxt commands\nAdditional notes for an optimal setup:\n\nOpen a terminal (if you're using Visual Studio Code, you can open an integrated terminal) and use the following command to create a new starter project:\n\nnpx\npnpm\nbun\nnpx nuxi@latest init <project-name>\n\n\nOpen your project folder in Visual Studio Code:\n\nTerminal\ncode <project-name>\n\n\nOr change directory into your new project from your terminal:\n\ncd <project-name>\n\n\nInstall the dependencies:\n\nyarn\nnpm\npnpm\nbun\nyarn install\n\nDevelopment Server\n\nNow you'll be able to start your Nuxt app in development mode:\n\nyarn\nnpm\npnpm\nbun\nyarn dev -o\n\nWell done! A browser window should automatically open for http://localhost:3000.\nNext Steps\n\nNow that you've created your Nuxt 3 project, you are ready to start building your application.\n\n Read more in Nuxt Concepts.\n\nIntroduction\n\nNuxt's goal is to make web development intuitive and performant with a great Developer Experience in mind.\n\nConfiguration\n\nNuxt is configured with sensible defaults to make you productive."
  },
  {
    "title": "Getting Help · Nuxt Community",
    "url": "https://nuxt.com/docs/community/getting-help",
    "html": "Community\nGetting Help\n\nWe're a friendly community of developers and we'd love to help.\n\nAt some point, you may find that there's an issue you need some help with.\n\nBut don't worry! We're a friendly community of developers and we'd love to help.\n\n\"I can't figure out how to (...).\"\n\nYou've read through these docs and you think it should be possible, but it's not clear how. The best thing is to open a GitHub Discussion.\n\nPlease don't feel embarrassed about asking a question that you think is easy - we've all been there! ❤️\n\nEveryone you'll encounter is helping out because they care, not because they are paid to do so. The kindest thing to do is make it easy for them to help you. Here are some ideas:\n\nExplain what your objective is, not just the problem you're facing. \"I need to ensure my form inputs are accessible, so I'm trying to get the ids to match between server and client.\"\nMake sure you've first read the docs and used your favorite search engine. Let people know by saying something like \"I've Googled for 'nuxt script setup' but I couldn't find code examples anywhere.\"\nExplain what you've tried. Tell people the kind of solutions you've experimented with, and why. Often this can make people's advice more relevant to your situation.\nShare your code. People probably won't be able to help if they just see an error message or a screenshot - but that all changes if you share your code in a copy/pasteable format - preferably in the form of a minimal reproduction like a CodeSandbox.\n\nAnd finally, just ask the question! There's no need to ask permission to ask a question or wait for someone to reply to your 'hello'. If you do, you might not get a response because people are waiting for the whole question before engaging.\n\n\"Could there be a bug?\"\n\nSomething isn't working the way that the docs say that it should. You're not sure if it's a bug. You've searched through the open issues and discussions but you can't find anything. (if there is a closed issue, please create a new one)\n\nWe recommend taking a look at how to report bugs. Nuxt 3 is still in active development, and every issue helps make it better.\n\nNuxt Configuration\n\nDiscover all the options you can use in your nuxt.config.ts file.\n\nReporting Bugs\n\nOne of the most valuable roles in open source is taking the time to report bugs helpfully."
  },
  {
    "title": "useAppConfig · Nuxt Composables",
    "url": "https://nuxt.com/docs/api/composables/use-app-config",
    "html": "Composables\nuseAppConfig\nSource\n\nAccess the reactive app config defined in the project.\n\nUsage\nconst appConfig = useAppConfig()\n\n\n\nconsole.log(appConfig)\n\n Read more in Docs > Guide > Directory Structure > App Config.\n\n<Teleport>\n\nThe <Teleport> component teleports a component to a different location in the DOM.\n\nuseAsyncData\n\nuseAsyncData provides access to data that resolves asynchronously in a SSR-friendly composable."
  },
  {
    "title": "Hello World · Nuxt Examples",
    "url": "https://nuxt.com/docs/examples/hello-world",
    "html": "Examples\nHello World\n\nA minimal Nuxt 3 application only requires the `app.vue` and `nuxt.config.js` files.\n\n Read more in Docs > Getting Started > Introduction.\nLoading Sandbox...\n\nModules\n\nLearn how to migrate from Nuxt 2 to Nuxt 3 modules.\n\nAuto Imports\n\nThis example demonstrates the auto-imports feature in Nuxt."
  },
  {
    "title": "Auto-imports · Nuxt Concepts",
    "url": "https://nuxt.com/docs/guide/concepts/auto-imports",
    "html": "Guide\nKey Concepts\nAuto-imports\n\nNuxt auto-imports components, composables, helper functions and Vue APIs.\n\nNuxt auto-imports components, composables and Vue.js APIs to use across your application without explicitly importing them.\n\napp.vue\n<script setup lang=\"ts\">\n\nconst count = ref(1) // ref is auto-imported\n\n</script>\n\n\nThanks to its opinionated directory structure, Nuxt can auto-import your components/, composables/ and utils/.\n\nContrary to a classic global declaration, Nuxt preserves typings, IDEs completions and hints, and only includes what is used in your production code.\n\nIn the docs, every function that is not explicitly imported is auto-imported by Nuxt and can be used as-is in your code. You can find a reference for auto-imported components, composables and utilities in the API section.\nIn the server directory, Nuxt auto-imports exported functions and variables from server/utils/.\nYou can also auto-import functions exported from custom folders or third-party packages by configuring the imports section of your nuxt.config file.\nBuilt-in Auto-imports\n\nNuxt auto-imports functions and composables to perform data fetching, get access to the app context and runtime config, manage state or define components and plugins.\n\n<script setup lang=\"ts\">\n\n/* useAsyncData() and $fetch() are auto-imported */\n\nconst { data, refresh, pending } = await useFetch('/api/hello')\n\n</script>\n\n\nVue 3 exposes Reactivity APIs like ref or computed, as well as lifecycle hooks and helpers that are auto-imported by Nuxt.\n\n<script setup lang=\"ts\">\n\n/* ref() and computed() are auto-imported */\n\nconst count = ref(1)\n\nconst double = computed(() => count.value * 2)\n\n</script>\n\nVue and Nuxt composables\n\nWhen you are using the built-in Composition API composables provided by Vue and Nuxt, be aware that many of them rely on being called in the right context.\n\nDuring a component lifecycle, Vue tracks the temporary instance of the current component (and similarly, Nuxt tracks a temporary instance of nuxtApp) via a global variable, and then unsets it in same tick. This is essential when server rendering, both to avoid cross-request state pollution (leaking a shared reference between two users) and to avoid leakage between different components.\n\nThat means that (with very few exceptions) you cannot use them outside a Nuxt plugin, Nuxt route middleware or Vue setup function. On top of that, you must use them synchronously - that is, you cannot use await before calling a composable, except within <script setup> blocks, within the setup function of a component declared with defineNuxtComponent, in defineNuxtPlugin or in defineNuxtRouteMiddleware, where we perform a transform to keep the synchronous context even after the await.\n\nIf you get an error message like Nuxt instance is unavailable then it probably means you are calling a Nuxt composable in the wrong place in the Vue or Nuxt lifecycle.\n\nCheckout the asyncContext experimental feature to use Nuxt composables in async functions.\nSee the full explanation in this GitHub comment.\n\nExample of breaking code:\n\ncomposables/example.ts\n// trying to access runtime config outside a composable\n\nconst config = useRuntimeConfig()\n\n\n\nexport const useMyComposable = () => {\n\n  // accessing runtime config here\n\n}\n\n\nExample of working code:\n\ncomposables/example.ts\nexport const useMyComposable = () => {\n\n  // Because your composable is called in the right place in the lifecycle,\n\n  // useRuntimeConfig will also work\n\n  const config = useRuntimeConfig()\n\n\n\n  // ...\n\n}\n\nDirectory-based Auto-imports\n\nNuxt directly auto-imports files created in defined directories:\n\ncomponents/ for Vue components.\ncomposables/ for Vue composables.\nutils/ for helper functions and other utilities.\n Read and edit a live example in Docs > Examples > Features > Auto Imports.\nExplicit Imports\n\nNuxt exposes every auto-import with the #imports alias that can be used to make the import explicit if needed:\n\n<script setup lang=\"ts\">\n\nimport { ref, computed } from '#imports'\n\n\n\nconst count = ref(1)\n\nconst double = computed(() => count.value * 2)\n\n</script>\n\nDisabling Auto-imports\n\nIf you want to disable auto-importing composables and utilities, you can set imports.autoImport to false in the nuxt.config file.\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    autoImport: false\n\n  }\n\n})\n\n\nThis will disable auto-imports completely but it's still possible to use explicit imports from #imports.\n\nAuto-imported Components\n\nNuxt also automatically imports components from your ~/components directory, although this is configured separately from auto-importing composables and utility functions.\n\n Read more in Docs > Guide > Directory Structure > Components.\n\nTo disable auto-importing components from your own ~/components directory, you can set components.dirs to an empty array (though note that this will not affect components added by modules).\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  components: {\n\n    dirs: []\n\n  }\n\n})\n\nAuto-import from third-party packages\n\nNuxt also allows auto-importing from third-party packages.\n\nIf you are using the Nuxt module for that package, it is likely that the module has already configured auto-imports for that package.\n\nFor example, you could enable the auto-import of the useI18n composable from the vue-i18n package like this:\n\nnuxt.config.ts\nexport default defineNuxtConfig({\n\n  imports: {\n\n    presets: [\n\n      {\n\n        from: 'vue-i18n',\n\n        imports: ['useI18n']\n\n      }\n\n    ]\n\n  }\n\n})\n\n\nUpgrade Guide\n\nLearn how to upgrade to the latest Nuxt version.\n\nVue.js Development\n\nNuxt uses Vue.js and adds features such as component auto-imports, file-based routing and composables for a SSR-friendly usage."
  },
  {
    "title": "Introduction · Get Started with Nuxt",
    "url": "https://nuxt.com/docs/getting-started/introduction",
    "html": "Get Started\nIntroduction\n\nNuxt's goal is to make web development intuitive and performant with a great Developer Experience in mind.\n\nNuxt is a free and open-source framework with an intuitive and extendable way to create type-safe, performant and production-grade full-stack web applications and websites with Vue.js.\n\nWe made everything so you can start writing .vue files from the beginning while enjoying hot module replacement in development and a performant application in production with server-side rendering by default.\n\nNuxt has no vendor lock-in, allowing you to deploy your application everywhere, even on the edge.\n\nAutomation and Conventions\n\nNuxt uses conventions and an opinionated directory structure to automate repetitive tasks and allow developers to focus on pushing features. The configuration file can still customize and override its default behaviors.\n\nFile-based routing: define routes based on the structure of your pages/ directory. This can make it easier to organize your application and avoid the need for manual route configuration.\nCode splitting: Nuxt automatically splits your code into smaller chunks, which can help reduce the initial load time of your application.\nServer-side rendering out of the box: Nuxt comes with built-in SSR capabilities, so you don't have to set up a separate server yourself.\nAuto-imports: write Vue composables and components in their respective directories and use them without having to import them with the benefits of tree-shaking and optimized JS bundles.\nData-fetching utilities: Nuxt provides composables to handle SSR-compatible data fetching as well as different strategies.\nZero-config TypeScript support: write type-safe code without having to learn TypeScript with our auto-generated types and tsconfig.json\nConfigured build tools: we use Vite by default to support hot module replacement (HMR) in development and bundling your code for production with best-practices baked-in.\n\nNuxt takes care of these and provides both frontend and backend functionality so you can focus on what matters: creating your web application.\n\nServer-Side Rendering\n\nNuxt comes with built-in server-side rendering (SSR) capabilities by default, without having to configure a server yourself, which has many benefits for web applications:\n\nFaster initial page load time: Nuxt sends a fully rendered HTML page to the browser, which can be displayed immediately. This can provide a faster perceived page load time and a better user experience (UX), especially on slower networks or devices.\nImproved SEO: search engines can better index SSR pages because the HTML content is available immediately, rather than requiring JavaScript to render the content on the client-side.\nBetter performance on low-powered devices: it reduces the amount of JavaScript that needs to be downloaded and executed on the client-side, which can be beneficial for low-powered devices that may struggle with processing heavy JavaScript applications.\nBetter accessibility: the content is immediately available on the initial page load, improving accessibility for users who rely on screen readers or other assistive technologies.\nEasier caching: pages can be cached on the server-side, which can further improve performance by reducing the amount of time it takes to generate and send the content to the client.\n\nOverall, server-side rendering can provide a faster and more efficient user experience, as well as improve search engine optimization and accessibility.\n\nAs Nuxt is a versatile framework, it gives you the possibility to statically render your whole application to a static hosting with nuxt generate, disable SSR globally with the ssr: false option or leverage hybrid rendering by setting up the routeRules option.\n\n Read more in Nuxt rendering modes.\nServer engine\n\nThe Nuxt server engine Nitro unlocks new full-stack capabilities.\n\nIn development, it uses Rollup and Node.js workers for your server code and context isolation. It also generates your server API by reading files in server/api/ and server middleware from server/middleware/.\n\nIn production, Nitro builds your app and server into one universal .output directory. This output is light: minified and removed from any Node.js modules (except polyfills). You can deploy this output on any system supporting JavaScript, from Node.js, Serverless, Workers, Edge-side rendering or purely static.\n\n Read more in Nuxt server engine.\nProduction-ready\n\nA Nuxt application can be deployed on a Node or Deno server, pre-rendered to be hosted in static environments, or deployed to serverless and edge providers.\n\n Read more in Deployment section.\nModular\n\nA module system allows to extend Nuxt with custom features and integrations with third-party services.\n\n Read more in Nuxt Modules Concept.\nArchitecture\n\nNuxt is composed of different core packages:\n\nCore Engine: nuxt\nBundlers: @nuxt/vite-builder and @nuxt/webpack-builder\nCommand line interface: nuxi\nServer engine: nitro\nDevelopment kit: @nuxt/kit\nNuxt 2 Bridge: @nuxt/bridge\n\nWe recommend reading each concept to have a full vision of Nuxt capabilities and the scope of each package.\n\n \n\nInstallation\n\nGet started with Nuxt quickly with our online starters or start locally with your terminal."
  }
]
