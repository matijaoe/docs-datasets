[
  {
    "title": "TypeScript: Handbook - Classes",
    "url": "https://www.typescriptlang.org/docs/handbook/classes.html",
    "html": "This page has been deprecated\n\nThis handbook page has been replaced, go to the new page\n\nGo to new page\nClasses\n\nTraditional JavaScript uses functions and prototype-based inheritance to build up reusable components, but this may feel a bit awkward to programmers more comfortable with an object-oriented approach, where classes inherit functionality and objects are built from these classes. Starting with ECMAScript 2015, also known as ECMAScript 6, JavaScript programmers can build their applications using this object-oriented class-based approach. In TypeScript, we allow developers to use these techniques now, and compile them down to JavaScript that works across all major browsers and platforms, without having to wait for the next version of JavaScript.\n\nClasses\n\nLet’s take a look at a simple class-based example:\n\nclass Greeter {\n  greeting: string;\n \n  constructor(message: string) {\n    this.greeting = message;\n  }\n \n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n \nlet greeter = new Greeter(\"world\");\nTry\n\nThe syntax should look familiar if you’ve used C# or Java before. We declare a new class Greeter. This class has three members: a property called greeting, a constructor, and a method greet.\n\nYou’ll notice that in the class when we refer to one of the members of the class we prepend this.. This denotes that it’s a member access.\n\nIn the last line we construct an instance of the Greeter class using new. This calls into the constructor we defined earlier, creating a new object with the Greeter shape, and running the constructor to initialize it.\n\nInheritance\n\nIn TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.\n\nLet’s take a look at an example:\n\nclass Animal {\n  move(distanceInMeters: number = 0) {\n    console.log(`Animal moved ${distanceInMeters}m.`);\n  }\n}\n \nclass Dog extends Animal {\n  bark() {\n    console.log(\"Woof! Woof!\");\n  }\n}\n \nconst dog = new Dog();\ndog.bark();\ndog.move(10);\ndog.bark();\nTry\n\nThis example shows the most basic inheritance feature: classes inherit properties and methods from base classes. Here, Dog is a derived class that derives from the Animal base class using the extends keyword. Derived classes are often called subclasses, and base classes are often called superclasses.\n\nBecause Dog extends the functionality from Animal, we were able to create an instance of Dog that could both bark() and move().\n\nLet’s now look at a more complex example.\n\nclass Animal {\n  name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n  move(distanceInMeters: number = 0) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\n \nclass Snake extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 5) {\n    console.log(\"Slithering...\");\n    super.move(distanceInMeters);\n  }\n}\n \nclass Horse extends Animal {\n  constructor(name: string) {\n    super(name);\n  }\n  move(distanceInMeters = 45) {\n    console.log(\"Galloping...\");\n    super.move(distanceInMeters);\n  }\n}\n \nlet sam = new Snake(\"Sammy the Python\");\nlet tom: Animal = new Horse(\"Tommy the Palomino\");\n \nsam.move();\ntom.move(34);\nTry\n\nThis example covers a few other features we didn’t previously mention. Again, we see the extends keywords used to create two new subclasses of Animal: Horse and Snake.\n\nOne difference from the prior example is that each derived class that contains a constructor function must call super() which will execute the constructor of the base class. What’s more, before we ever access a property on this in a constructor body, we have to call super(). This is an important rule that TypeScript will enforce.\n\nThe example also shows how to override methods in the base class with methods that are specialized for the subclass. Here both Snake and Horse create a move method that overrides the move from Animal, giving it functionality specific to each class. Note that even though tom is declared as an Animal, since its value is a Horse, calling tom.move(34) will call the overriding method in Horse:\n\nSlithering...\nSammy the Python moved 5m.\nGalloping...\nTommy the Palomino moved 34m.\nPublic, private, and protected modifiers\nPublic by default\n\nIn our examples, we’ve been able to freely access the members that we declared throughout our programs. If you’re familiar with classes in other languages, you may have noticed in the above examples we haven’t had to use the word public to accomplish this; for instance, C# requires that each member be explicitly labeled public to be visible. In TypeScript, each member is public by default.\n\nYou may still mark a member public explicitly. We could have written the Animal class from the previous section in the following way:\n\nclass Animal {\n  public name: string;\n \n  public constructor(theName: string) {\n    this.name = theName;\n  }\n \n  public move(distanceInMeters: number) {\n    console.log(`${this.name} moved ${distanceInMeters}m.`);\n  }\n}\nTry\nECMAScript Private Fields\n\nWith TypeScript 3.8, TypeScript supports the new JavaScript syntax for private fields:\n\nclass Animal {\n  #name: string;\n  constructor(theName: string) {\n    this.#name = theName;\n  }\n}\n \nnew Animal(\"Cat\").#name;\nProperty '#name' is not accessible outside class 'Animal' because it has a private identifier.\nProperty '#name' is not accessible outside class 'Animal' because it has a private identifier.\nTry\n\nThis syntax is built into the JavaScript runtime and can have better guarantees about the isolation of each private field. Right now, the best documentation for these private fields is in the TypeScript 3.8 release notes.\n\nUnderstanding TypeScript’s \nprivate\n\nTypeScript also has its own way to declare a member as being marked private, it cannot be accessed from outside of its containing class. For example:\n\nclass Animal {\n  private name: string;\n \n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nnew Animal(\"Cat\").name;\nProperty 'name' is private and only accessible within class 'Animal'.\nProperty 'name' is private and only accessible within class 'Animal'.\nTry\n\nTypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.\n\nHowever, when comparing types that have private and protected members, we treat these types differently. For two types to be considered compatible, if one of them has a private member, then the other must have a private member that originated in the same declaration. The same applies to protected members.\n\nLet’s look at an example to better see how this plays out in practice:\n\nclass Animal {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nclass Rhino extends Animal {\n  constructor() {\n    super(\"Rhino\");\n  }\n}\n \nclass Employee {\n  private name: string;\n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nlet animal = new Animal(\"Goat\");\nlet rhino = new Rhino();\nlet employee = new Employee(\"Bob\");\n \nanimal = rhino;\nanimal = employee;\nType 'Employee' is not assignable to type 'Animal'.\n  Types have separate declarations of a private property 'name'.\nType 'Employee' is not assignable to type 'Animal'.\n  Types have separate declarations of a private property 'name'.\nTry\n\nIn this example, we have an Animal and a Rhino, with Rhino being a subclass of Animal. We also have a new class Employee that looks identical to Animal in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because Animal and Rhino share the private side of their shape from the same declaration of private name: string in Animal, they are compatible. However, this is not the case for Employee. When we try to assign from an Employee to Animal we get an error that these types are not compatible. Even though Employee also has a private member called name, it’s not the one we declared in Animal.\n\nUnderstanding \nprotected\n\nThe protected modifier acts much like the private modifier with the exception that members declared protected can also be accessed within deriving classes. For example,\n\nclass Person {\n  protected name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n \nclass Employee extends Person {\n  private department: string;\n \n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n \n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\n \nlet howard = new Employee(\"Howard\", \"Sales\");\nconsole.log(howard.getElevatorPitch());\nconsole.log(howard.name);\nProperty 'name' is protected and only accessible within class 'Person' and its subclasses.\nProperty 'name' is protected and only accessible within class 'Person' and its subclasses.\nTry\n\nNotice that while we can’t use name from outside of Person, we can still use it from within an instance method of Employee because Employee derives from Person.\n\nA constructor may also be marked protected. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,\n\nclass Person {\n  protected name: string;\n  protected constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \n// Employee can extend Person\nclass Employee extends Person {\n  private department: string;\n \n  constructor(name: string, department: string) {\n    super(name);\n    this.department = department;\n  }\n \n  public getElevatorPitch() {\n    return `Hello, my name is ${this.name} and I work in ${this.department}.`;\n  }\n}\n \nlet howard = new Employee(\"Howard\", \"Sales\");\nlet john = new Person(\"John\");\nConstructor of class 'Person' is protected and only accessible within the class declaration.\nConstructor of class 'Person' is protected and only accessible within the class declaration.\nTry\nReadonly modifier\n\nYou can make properties readonly by using the readonly keyword. Readonly properties must be initialized at their declaration or in the constructor.\n\nclass Octopus {\n  readonly name: string;\n  readonly numberOfLegs: number = 8;\n \n  constructor(theName: string) {\n    this.name = theName;\n  }\n}\n \nlet dad = new Octopus(\"Man with the 8 strong legs\");\ndad.name = \"Man with the 3-piece suit\";\nCannot assign to 'name' because it is a read-only property.\nCannot assign to 'name' because it is a read-only property.\nTry\nParameter properties\n\nIn our last example, we had to declare a readonly member name and a constructor parameter theName in the Octopus class. This is needed in order to have the value of theName accessible after the Octopus constructor is executed. Parameter properties let you create and initialize a member in one place. Here’s a further revision of the previous Octopus class using a parameter property:\n\nclass Octopus {\n  readonly numberOfLegs: number = 8;\n  constructor(readonly name: string) {}\n}\n \nlet dad = new Octopus(\"Man with the 8 strong legs\");\ndad.name;\nTry\n\nNotice how we dropped theName altogether and just use the shortened readonly name: string parameter on the constructor to create and initialize the name member. We’ve consolidated the declarations and assignment into one location.\n\nParameter properties are declared by prefixing a constructor parameter with an accessibility modifier or readonly, or both. Using private for a parameter property declares and initializes a private member; likewise, the same is done for public, protected, and readonly.\n\nAccessors\n\nTypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.\n\nLet’s convert a simple class to use get and set. First, let’s start with an example without getters and setters.\n\nclass Employee {\n  fullName: string;\n}\n \nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\n \nif (employee.fullName) {\n  console.log(employee.fullName);\n}\nTry\n\nWhile allowing people to randomly set fullName directly is pretty handy, we may also want enforce some constraints when fullName is set.\n\nIn this version, we add a setter that checks the length of the newName to make sure it’s compatible with the max-length of our backing database field. If it isn’t we throw an error notifying client code that something went wrong.\n\nTo preserve existing functionality, we also add a simple getter that retrieves fullName unmodified.\n\nconst fullNameMaxLength = 10;\n \nclass Employee {\n  private _fullName: string = \"\";\n \n  get fullName(): string {\n    return this._fullName;\n  }\n \n  set fullName(newName: string) {\n    if (newName && newName.length > fullNameMaxLength) {\n      throw new Error(\"fullName has a max length of \" + fullNameMaxLength);\n    }\n \n    this._fullName = newName;\n  }\n}\n \nlet employee = new Employee();\nemployee.fullName = \"Bob Smith\";\n \nif (employee.fullName) {\n  console.log(employee.fullName);\n}\nTry\n\nTo prove to ourselves that our accessor is now checking the length of values, we can attempt to assign a name longer than 10 characters and verify that we get an error.\n\nA couple of things to note about accessors:\n\nFirst, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a get and no set are automatically inferred to be readonly. This is helpful when generating a .d.ts file from your code, because users of your property can see that they can’t change it.\n\nStatic Properties\n\nUp to this point, we’ve only talked about the instance members of the class, those that show up on the object when it’s instantiated. We can also create static members of a class, those that are visible on the class itself rather than on the instances. In this example, we use static on the origin, as it’s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending this. in front of instance accesses, here we prepend Grid. in front of static accesses.\n\nclass Grid {\n  static origin = { x: 0, y: 0 };\n \n  calculateDistanceFromOrigin(point: { x: number; y: number }) {\n    let xDist = point.x - Grid.origin.x;\n    let yDist = point.y - Grid.origin.y;\n    return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\n  }\n \n  constructor(public scale: number) {}\n}\n \nlet grid1 = new Grid(1.0); // 1x scale\nlet grid2 = new Grid(5.0); // 5x scale\n \nconsole.log(grid1.calculateDistanceFromOrigin({ x: 10, y: 10 }));\nconsole.log(grid2.calculateDistanceFromOrigin({ x: 10, y: 10 }));\nTry\nAbstract Classes\n\nAbstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The abstract keyword is used to define abstract classes as well as abstract methods within an abstract class.\n\nabstract class Animal {\n  abstract makeSound(): void;\n \n  move(): void {\n    console.log(\"roaming the earth...\");\n  }\n}\nTry\n\nMethods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the abstract keyword and may optionally include access modifiers.\n\nabstract class Department {\n  constructor(public name: string) {}\n \n  printName(): void {\n    console.log(\"Department name: \" + this.name);\n  }\n \n  abstract printMeeting(): void; // must be implemented in derived classes\n}\n \nclass AccountingDepartment extends Department {\n  constructor() {\n    super(\"Accounting and Auditing\"); // constructors in derived classes must call super()\n  }\n \n  printMeeting(): void {\n    console.log(\"The Accounting Department meets each Monday at 10am.\");\n  }\n \n  generateReports(): void {\n    console.log(\"Generating accounting reports...\");\n  }\n}\n \nlet department: Department; // ok to create a reference to an abstract type\ndepartment = new Department(); // error: cannot create an instance of an abstract class\nCannot create an instance of an abstract class.\nCannot create an instance of an abstract class.\ndepartment = new AccountingDepartment(); // ok to create and assign a non-abstract subclass\ndepartment.printName();\ndepartment.printMeeting();\ndepartment.generateReports(); // error: department is not of type AccountingDepartment, cannot access generateReports\nProperty 'generateReports' does not exist on type 'Department'.\nProperty 'generateReports' does not exist on type 'Department'.\nTry\nAdvanced Techniques\nConstructor functions\n\nWhen you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the instance of the class.\n\nclass Greeter {\n  greeting: string;\n \n  constructor(message: string) {\n    this.greeting = message;\n  }\n \n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n \nlet greeter: Greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet()); // \"Hello, world\"\nTry\n\nHere, when we say let greeter: Greeter, we’re using Greeter as the type of instances of the class Greeter. This is almost second nature to programmers from other object-oriented languages.\n\nWe’re also creating another value that we call the constructor function. This is the function that is called when we new up instances of the class. To see what this looks like in practice, let’s take a look at the JavaScript created by the above example:\n\nlet Greeter = (function () {\n  function Greeter(message) {\n    this.greeting = message;\n  }\n \n  Greeter.prototype.greet = function () {\n    return \"Hello, \" + this.greeting;\n  };\n \n  return Greeter;\n})();\n \nlet greeter;\ngreeter = new Greeter(\"world\");\nconsole.log(greeter.greet()); // \"Hello, world\"\nTry\n\nHere, let Greeter is going to be assigned the constructor function. When we call new and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an instance side and a static side.\n\nLet’s modify the example a bit to show this difference:\n\nclass Greeter {\n  static standardGreeting = \"Hello, there\";\n  greeting: string;\n  greet() {\n    if (this.greeting) {\n      return \"Hello, \" + this.greeting;\n    } else {\n      return Greeter.standardGreeting;\n    }\n  }\n}\n \nlet greeter1: Greeter;\ngreeter1 = new Greeter();\nconsole.log(greeter1.greet()); // \"Hello, there\"\n \nlet greeterMaker: typeof Greeter = Greeter;\ngreeterMaker.standardGreeting = \"Hey there!\";\n \nlet greeter2: Greeter = new greeterMaker();\nconsole.log(greeter2.greet()); // \"Hey there!\"\n \nlet greeter3: Greeter;\ngreeter3 = new Greeter();\nconsole.log(greeter3.greet()); // \"Hey there!\"\nTry\n\nIn this example, greeter1 works similarly to before. We instantiate the Greeter class, and use this object. This we have seen before.\n\nNext, we then use the class directly. Here we create a new variable called greeterMaker. This variable will hold the class itself, or said another way its constructor function. Here we use typeof Greeter, that is “give me the type of the Greeter class itself” rather than the instance type. Or, more precisely, “give me the type of the symbol called Greeter,” which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the Greeter class. We show this by using new on greeterMaker, creating new instances of Greeter and invoking them as before. It is also good to mention that changing static property is frowned upon, here greeter3 has \"Hey there!\" instead of \"Hello, there\" on standardGreeting.\n\nUsing a class as an interface\n\nAs we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.\n\nclass Point {\n  x: number;\n  y: number;\n}\n \ninterface Point3d extends Point {\n  z: number;\n}\n \nlet point3d: Point3d = { x: 1, y: 2, z: 3 };\nTry\nOn this page\nClasses\nInheritance\nPublic, private, and protected modifiers\nPublic by default\nECMAScript Private Fields\nUnderstanding TypeScript’s private\nUnderstanding protected\nReadonly modifier\nParameter properties\nAccessors\nStatic Properties\nAbstract Classes\nAdvanced Techniques\nConstructor functions\nUsing a class as an interface\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nRC\nDR\nOT\nNS\nBW\n25+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.389 seconds."
  },
  {
    "title": "TypeScript: Documentation - Global: Plugin",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-plugin-d-ts.html",
    "html": "Global: Plugin\nUMD\n\nA UMD module is one that can either be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as Moment.js, are written this way. For example, in Node.js or using RequireJS, you would write:\n\nimport moment = require(\"moment\");\nconsole.log(moment.format());\n\nwhereas in a vanilla browser environment you would write:\n\nconsole.log(moment.format());\nIdentifying a UMD library\n\nUMD modules check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n\nIf you see tests for typeof define, typeof window, or typeof module in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing require, and a “Using in the browser” example showing using a <script> tag to load the script.\n\nExamples of UMD libraries\n\nMost popular libraries are now available as UMD packages. Examples include jQuery, Moment.js, lodash, and many more.\n\nTemplate\n\nThere are three templates available for modules, module.d.ts, module-class.d.ts and module-function.d.ts.\n\nUse module-function.d.ts if your module can be called like a function:\n\nvar x = require(\"foo\");\n// Note: calling 'x' as a function\nvar y = x(42);\n\nBe sure to read the footnote “The Impact of ES6 on Module Call Signatures”\n\nUse module-class.d.ts if your module can be constructed using new:\n\nvar x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nvar y = new x(\"hello\");\n\nThe same footnote applies to these modules.\n\nIf your module is not callable or constructable, use the module.d.ts file.\n\nModule Plugin\n or \nUMD Plugin\n\nA module plugin changes the shape of another module (either UMD or module). For example, in Moment.js, moment-range adds a new range method to the moment object.\n\nFor the purposes of writing a declaration file, you’ll write the same code whether the module being changed is a plain module or UMD module.\n\nTemplate\n\nUse the module-plugin.d.ts template.\n\nGlobal Plugin\n\nA global plugin is global code that changes the shape of some global. As with global-modifying modules, these raise the possibility of runtime conflict.\n\nFor example, some libraries add new functions to Array.prototype or String.prototype.\n\nIdentifying global plugins\n\nGlobal plugins are generally easy to identify from their documentation.\n\nYou’ll see examples that look like this:\n\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\nTemplate\n\nUse the global-plugin.d.ts template.\n\nGlobal-modifying Modules\n\nA global-modifying module alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to String.prototype when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.\n\nIdentifying global-modifying modules\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a require call to activate their effects.\n\nYou might see documentation like this:\n\n// 'require' call that doesn't use its return value\nvar unused = require(\"magic-string-time\");\n/* or */\nrequire(\"magic-string-time\");\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\nTemplate\n\nUse the global-modifying-module.d.ts template.\n\nConsuming Dependencies\n\nThere are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.\n\nDependencies on Global Libraries\n\nIf your library depends on a global library, use a /// <reference types=\"...\" /> directive:\n\n/// <reference types=\"someLib\" />\nfunction getThing(): someLib.thing;\nDependencies on Modules\n\nIf your library depends on a module, use an import statement:\n\nimport * as moment from \"moment\";\nfunction getThing(): moment;\nDependencies on UMD libraries\nFrom a Global Library\n\nIf your global library depends on a UMD module, use a /// <reference types directive:\n\n/// <reference types=\"moment\" />\nfunction getThing(): moment;\nFrom a Module or UMD Library\n\nIf your module or UMD library depends on a UMD library, use an import statement:\n\nimport * as someLib from \"someLib\";\n\nDo not use a /// <reference directive to declare a dependency to a UMD library!\n\nFootnotes\nPreventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types namespaced by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\ndeclare namespace cats {\n  interface KittySettings {}\n}\n\nBut not\n\n// at top-level\ninterface CatsKittySettings {}\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\nThe Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\nThe Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\nimport exp = require(\"express\");\nvar app = exp();\n\nIn ES6 module loaders, the top-level object (here imported as exp) can only have properties; the top-level module object is never callable. The most common solution here is to define a default export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the default export.\n\nLibrary file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n\nThese could be imported as\n\nvar a = require(\"myLib\");\nvar b = require(\"myLib/foo\");\nvar c = require(\"myLib/bar\");\nvar d = require(\"myLib/bar/baz\");\n\nYour declaration files should thus be\n\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n/*~ This template shows how to write a global plugin. */\n/*~ Write a declaration for the original type and add new members.\n *~ For example, this adds a 'toBinaryString' method with overloads to\n *~ the built-in number type.\n */\ninterface Number {\n  toBinaryString(opts?: MyLibrary.BinaryFormatOptions): string;\n  toBinaryString(\n    callback: MyLibrary.BinaryFormatCallback,\n    opts?: MyLibrary.BinaryFormatOptions\n  ): string;\n}\n/*~ If you need to declare several types, place them inside a namespace\n *~ to avoid adding too many things to the global namespace.\n */\ndeclare namespace MyLibrary {\n  type BinaryFormatCallback = (n: number) => string;\n  interface BinaryFormatOptions {\n    prefix?: string;\n    padding: number;\n  }\n}\nOn this page\nUMD\nIdentifying a UMD library\nExamples of UMD libraries\nTemplate\nModule Plugin or UMD Plugin\nTemplate\nGlobal Plugin\nIdentifying global plugins\nTemplate\nGlobal-modifying Modules\nIdentifying global-modifying modules\nTemplate\nConsuming Dependencies\nDependencies on Global Libraries\nDependencies on Modules\nDependencies on UMD libraries\nFootnotes\nPreventing Name Conflicts\nThe Impact of ES6 on Module Plugins\nThe Impact of ES6 on Module Call Signatures\nLibrary file layout\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nMF\nJH\nJ\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.338 seconds."
  },
  {
    "title": "TypeScript: Handbook - Generics",
    "url": "https://www.typescriptlang.org/docs/handbook/generics.html#generic-types",
    "html": "This page has been deprecated\n\nThis handbook page has been replaced, go to the new page\n\nGo to new page\nGenerics\n\nA major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.\n\nIn languages like C# and Java, one of the main tools in the toolbox for creating reusable components is generics, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.\n\nHello World of Generics\n\nTo start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echo command.\n\nWithout generics, we would either have to give the identity function a specific type:\n\nfunction identity(arg: number): number {\n  return arg;\n}\nTry\n\nOr, we could describe the identity function using the any type:\n\nfunction identity(arg: any): any {\n  return arg;\n}\nTry\n\nWhile using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.\n\nInstead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a type variable, a special kind of variable that works on types rather than values.\n\nfunction identity<T>(arg: T): T {\n  return arg;\n}\nTry\n\nWe’ve now added a type variable T to the identity function. This T allows us to capture the type the user provides (e.g. number), so that we can use that information later. Here, we use T again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.\n\nWe say that this version of the identity function is generic, as it works over a range of types. Unlike using any, it’s also just as precise (ie, it doesn’t lose any information) as the first identity function that used numbers for the argument and return type.\n\nOnce we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:\n\nlet output = identity<string>(\"myString\");\n      \nlet output: string\nTry\n\nHere we explicitly set T to be string as one of the arguments to the function call, denoted using the <> around the arguments rather than ().\n\nThe second way is also perhaps the most common. Here we use type argument inference — that is, we want the compiler to set the value of T for us automatically based on the type of the argument we pass in:\n\nlet output = identity(\"myString\");\n      \nlet output: string\nTry\n\nNotice that we didn’t have to explicitly pass the type in the angle brackets (<>); the compiler just looked at the value \"myString\", and set T to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.\n\nWorking with Generic Type Variables\n\nWhen you begin to use generics, you’ll notice that when you create generic functions like identity, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.\n\nLet’s take our identity function from earlier:\n\nfunction identity<T>(arg: T): T {\n  return arg;\n}\nTry\n\nWhat if we want to also log the length of the argument arg to the console with each call? We might be tempted to write this:\n\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);\nProperty 'length' does not exist on type 'T'.\nProperty 'length' does not exist on type 'T'.\n  return arg;\n}\nTry\n\nWhen we do, the compiler will give us an error that we’re using the .length member of arg, but nowhere have we said that arg has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a number instead, which does not have a .length member.\n\nLet’s say that we’ve actually intended this function to work on arrays of T rather than T directly. Since we’re working with arrays, the .length member should be available. We can describe this just like we would create arrays of other types:\n\nfunction loggingIdentity<T>(arg: T[]): T[] {\n  console.log(arg.length);\n  return arg;\n}\nTry\n\nYou can read the type of loggingIdentity as “the generic function loggingIdentity takes a type parameter T, and an argument arg which is an array of Ts, and returns an array of Ts.” If we passed in an array of numbers, we’d get an array of numbers back out, as T would bind to number. This allows us to use our generic type variable T as part of the types we’re working with, rather than the whole type, giving us greater flexibility.\n\nWe can alternatively write the sample example this way:\n\nfunction loggingIdentity<T>(arg: Array<T>): Array<T> {\n  console.log(arg.length); // Array has a .length, so no more error\n  return arg;\n}\nTry\n\nYou may already be familiar with this style of type from other languages. In the next section, we’ll cover how you can create your own generic types like Array<T>.\n\nGeneric Types\n\nIn previous sections, we created generic identity functions that worked over a range of types. In this section, we’ll explore the type of the functions themselves and how to create generic interfaces.\n\nThe type of generic functions is just like those of non-generic functions, with the type parameters listed first, similarly to function declarations:\n\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: <T>(arg: T) => T = identity;\nTry\n\nWe could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.\n\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: <U>(arg: U) => U = identity;\nTry\n\nWe can also write the generic type as a call signature of an object literal type:\n\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: { <T>(arg: T): T } = identity;\nTry\n\nWhich leads us to writing our first generic interface. Let’s take the object literal from the previous example and move it to an interface:\n\ninterface GenericIdentityFn {\n  <T>(arg: T): T;\n}\n \nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn = identity;\nTry\n\nIn a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we’re generic over (e.g. Dictionary<string> rather than just Dictionary). This makes the type parameter visible to all the other members of the interface.\n\ninterface GenericIdentityFn<T> {\n  (arg: T): T;\n}\n \nfunction identity<T>(arg: T): T {\n  return arg;\n}\n \nlet myIdentity: GenericIdentityFn<number> = identity;\nTry\n\nNotice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use GenericIdentityFn, we now will also need to specify the corresponding type argument (here: number), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.\n\nIn addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.\n\nGeneric Classes\n\nA generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (<>) following the name of the class.\n\nclass GenericNumber<T> {\n  zeroValue: T;\n  add: (x: T, y: T) => T;\n}\n \nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function (x, y) {\n  return x + y;\n};\nTry\n\nThis is a pretty literal use of the GenericNumber class, but you may have noticed that nothing is restricting it to only use the number type. We could have instead used string or even more complex objects.\n\nlet stringNumeric = new GenericNumber<string>();\nstringNumeric.zeroValue = \"\";\nstringNumeric.add = function (x, y) {\n  return x + y;\n};\n \nconsole.log(stringNumeric.add(stringNumeric.zeroValue, \"test\"));\nTry\n\nJust as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.\n\nAs we covered in our section on classes, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class’s type parameter.\n\nGeneric Constraints\n\nIf you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our loggingIdentity example, we wanted to be able to access the .length property of arg, but the compiler could not prove that every type had a .length property, so it warns us that we can’t make this assumption.\n\nfunction loggingIdentity<T>(arg: T): T {\n  console.log(arg.length);\nProperty 'length' does not exist on type 'T'.\nProperty 'length' does not exist on type 'T'.\n  return arg;\n}\nTry\n\nInstead of working with any and all types, we’d like to constrain this function to work with any and all types that also have the .length property. As long as the type has this member, we’ll allow it, but it’s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.\n\nTo do so, we’ll create an interface that describes our constraint. Here, we’ll create an interface that has a single .length property and then we’ll use this interface and the extends keyword to denote our constraint:\n\ninterface Lengthwise {\n  length: number;\n}\n \nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // Now we know it has a .length property, so no more error\n  return arg;\n}\nTry\n\nBecause the generic function is now constrained, it will no longer work over any and all types:\n\nloggingIdentity(3);\nArgument of type 'number' is not assignable to parameter of type 'Lengthwise'.\nArgument of type 'number' is not assignable to parameter of type 'Lengthwise'.\nTry\n\nInstead, we need to pass in values whose type has all the required properties:\n\nloggingIdentity({ length: 10, value: 3 });\nTry\nUsing Type Parameters in Generic Constraints\n\nYou can declare a type parameter that is constrained by another type parameter. For example, here we’d like to get a property from an object given its name. We’d like to ensure that we’re not accidentally grabbing a property that does not exist on the obj, so we’ll place a constraint between the two types:\n\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key];\n}\n \nlet x = { a: 1, b: 2, c: 3, d: 4 };\n \ngetProperty(x, \"a\");\ngetProperty(x, \"m\");\nArgument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.\nArgument of type '\"m\"' is not assignable to parameter of type '\"a\" | \"b\" | \"c\" | \"d\"'.\nTry\nUsing Class Types in Generics\n\nWhen creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,\n\nfunction create<T>(c: { new (): T }): T {\n  return new c();\n}\nTry\n\nA more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.\n\nclass BeeKeeper {\n  hasMask: boolean;\n}\n \nclass ZooKeeper {\n  nametag: string;\n}\n \nclass Animal {\n  numLegs: number;\n}\n \nclass Bee extends Animal {\n  keeper: BeeKeeper;\n}\n \nclass Lion extends Animal {\n  keeper: ZooKeeper;\n}\n \nfunction createInstance<A extends Animal>(c: new () => A): A {\n  return new c();\n}\n \ncreateInstance(Lion).keeper.nametag;\ncreateInstance(Bee).keeper.hasMask;\nTry\nOn this page\nHello World of Generics\nWorking with Generic Type Variables\nGeneric Types\nGeneric Classes\nGeneric Constraints\nUsing Type Parameters in Generic Constraints\nUsing Class Types in Generics\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nRC\nOT\nDR\nMH\nRC\n15+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 11.339 seconds."
  },
  {
    "title": "TypeScript: Documentation - Templates",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates.html",
    "html": "Templates\n\nglobal-modifying-module.d.ts\n\nglobal-plugin.d.ts\nglobal.d.ts\nmodule-class.d.ts\nmodule-function.d.ts\nmodule-plugin.d.ts\nmodule.d.ts\nOn this page\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\n1+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 9.111 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.3",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-3.html",
    "html": "TypeScript 4.3\nSeparate Write Types on Properties\n\nIn JavaScript, it’s pretty common for APIs to convert values that are passed in before storing them. This often happens with getters and setters too. For example, let’s imagine we’ve got a class with a setter that always converts a value into a number before saving it in a private field.\n\nclass Thing {\n  #size = 0;\n \n  get size() {\n    return this.#size;\n  }\n  set size(value) {\n    let num = Number(value);\n \n    // Don't allow NaN and stuff.\n    if (!Number.isFinite(num)) {\n      this.#size = 0;\n      return;\n    }\n \n    this.#size = num;\n  }\n}\nTry\n\nHow would we type this JavaScript code in TypeScript? Well, technically we don’t have to do anything special here - TypeScript can look at this with no explicit types and can figure out that size is a number.\n\nThe problem is that size allows you to assign more than just numbers to it. We could get around this by saying that size has the type unknown or any like in this snippet:\n\nclass Thing {\n  // ...\n  get size(): unknown {\n    return this.#size;\n  }\n}\n\nBut that’s no good - unknown forces people reading size to do a type assertion, and any won’t catch any mistakes. If we really want to model APIs that convert values, previous versions of TypeScript forced us to pick between being precise (which makes reading values easier, and writing harder) and being permissive (which makes writing values easier, and reading harder).\n\nThat’s why TypeScript 4.3 allows you to specify types for reading and writing to properties.\n\nclass Thing {\n  #size = 0;\n \n  get size(): number {\n    return this.#size;\n  }\n \n  set size(value: string | number | boolean) {\n    let num = Number(value);\n \n    // Don't allow NaN and stuff.\n    if (!Number.isFinite(num)) {\n      this.#size = 0;\n      return;\n    }\n \n    this.#size = num;\n  }\n}\nTry\n\nIn the above example, our set accessor takes a broader set of types (strings, booleans, and numbers), but our get accessor always guarantees it will be a number. Now we can finally assign other types to these properties with no errors!\n\nlet thing = new Thing();\n \n// Assigning other types to `thing.size` works!\nthing.size = \"hello\";\nthing.size = true;\nthing.size = 42;\n \n// Reading `thing.size` always produces a number!\nlet mySize: number = thing.size;\nTry\n\nWhen considering how two properties with the same name relate to each other, TypeScript will only use the “reading” type (e.g. the type on the get accessor above). “Writing” types are only considered when directly writing to a property.\n\nKeep in mind, this isn’t a pattern that’s limited to classes. You can write getters and setters with different types in object literals.\n\nfunction makeThing(): Thing {\n  let size = 0;\n  return {\n    get size(): number {\n      return size;\n    },\n    set size(value: string | number | boolean) {\n      let num = Number(value);\n      // Don't allow NaN and stuff.\n      if (!Number.isFinite(num)) {\n        size = 0;\n        return;\n      }\n      size = num;\n    },\n  };\n}\n\nIn fact, we’ve added syntax to interfaces/object types to support different reading/writing types on properties.\n\n// Now valid!\ninterface Thing {\n    get size(): number\n    set size(value: number | string | boolean);\n}\n\nOne limitation of using different types for reading and writing properties is that the type for reading a property has to be assignable to the type that you’re writing. In other words, the getter type has to be assignable to the setter. This ensures some level of consistency, so that a property is always assignable to itself.\n\nFor more information on this feature, take a look at the implementing pull request.\n\noverride\n and the \n--noImplicitOverride\n Flag\n\nWhen extending classes in JavaScript, the language makes it super easy (pun intended) to override methods - but unfortunately, there are some mistakes that you can run into.\n\nOne big one is missing renames. For example, take the following classes:\n\nclass SomeComponent {\n  show() {\n    // ...\n  }\n  hide() {\n    // ...\n  }\n}\nclass SpecializedComponent extends SomeComponent {\n  show() {\n    // ...\n  }\n  hide() {\n    // ...\n  }\n}\n\nSpecializedComponent subclasses SomeComponent, and overrides the show and hide methods. What happens if someone decides to rip out show and hide and replace them with a single method?\n\n class SomeComponent {\n-    show() {\n-        // ...\n-    }\n-    hide() {\n-        // ...\n-    }\n+    setVisible(value: boolean) {\n+        // ...\n+    }\n }\n class SpecializedComponent extends SomeComponent {\n     show() {\n         // ...\n     }\n     hide() {\n         // ...\n     }\n }\n\nOh no! Our SpecializedComponent didn’t get updated. Now it’s just adding these two useless show and hide methods that probably won’t get called.\n\nPart of the issue here is that a user can’t make it clear whether they meant to add a new method, or to override an existing one. That’s why TypeScript 4.3 adds the override keyword.\n\nclass SpecializedComponent extends SomeComponent {\n    override show() {\n        // ...\n    }\n    override hide() {\n        // ...\n    }\n}\n\nWhen a method is marked with override, TypeScript will always make sure that a method with the same name exists in a the base class.\n\nclass SomeComponent {\n    setVisible(value: boolean) {\n        // ...\n    }\n}\nclass SpecializedComponent extends SomeComponent {\n    override show() {\nThis member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.\nThis member cannot have an 'override' modifier because it is not declared in the base class 'SomeComponent'.\n \n    }\n}\nTry\n\nThis is a big improvement, but it doesn’t help if you forget to write override on a method - and that’s a big mistake users can run into also.\n\nFor example, you might accidentally “trample over” a method that exists in a base class without realizing it.\n\nclass Base {\n  someHelperMethod() {\n    // ...\n  }\n}\nclass Derived extends Base {\n  // Oops! We weren't trying to override here,\n  // we just needed to write a local helper method.\n  someHelperMethod() {\n    // ...\n  }\n}\n\nThat’s why TypeScript 4.3 also provides a new noImplicitOverride flag. When this option is turned on, it becomes an error to override any method from a superclass unless you explicitly use an override keyword. In that last example, TypeScript would error under noImplicitOverride, and give us a clue that we probably need to rename our method inside of Derived.\n\nWe’d like to extend our thanks to our community for the implementation here. The work for these items was implemented in a pull request by Wenlu Wang, though an earlier pull request implementing only the override keyword by Paul Cody Johnston served as a basis for direction and discussion. We extend our gratitude for putting in the time for these features.\n\nTemplate String Type Improvements\n\nIn recent versions, TypeScript introduced a new type construct: template string types. These are types that either construct new string-like types by concatenating…\n\ntype Color = \"red\" | \"blue\";\ntype Quantity = \"one\" | \"two\";\ntype SeussFish = `${Quantity | Color} fish`;\n// same as\n//   type SeussFish = \"one fish\" | \"two fish\"\n//                  | \"red fish\" | \"blue fish\";\n\n…or match patterns of other string-like types.\n\ndeclare let s1: `${number}-${number}-${number}`;\ndeclare let s2: `1-2-3`;\n// Works!\ns1 = s2;\n\nThe first change we made is just in when TypeScript will infer a template string type. When a template string is contextually typed by a string-literal-like type (i.e. when TypeScript sees we’re passing a template string to something that takes a literal type) it will try to give that expression a template type.\n\nfunction bar(s: string): `hello ${string}` {\n    // Previously an error, now works!\n    return `hello ${s}`;\n}\n\nThis also kicks in when inferring types, and the type parameter extends string\n\ndeclare let s: string;\ndeclare function f<T extends string>(x: T): T;\n// Previously: string\n// Now       : `hello ${string}`\nlet x2 = f(`hello ${s}`);\n\nThe second major change here is that TypeScript can now better-relate, and infer between, different template string types.\n\nTo see this, take the following example code:\n\ndeclare let s1: `${number}-${number}-${number}`;\ndeclare let s2: `1-2-3`;\ndeclare let s3: `${number}-2-3`;\ns1 = s2;\ns1 = s3;\n\nWhen checking against a string literal type like on s2, TypeScript could match against the string contents and figure out that s2 was compatible with s1 in the first assignment; however, as soon as it saw another template string, it just gave up. As a result, assignments like s3 to s1 just didn’t work.\n\nTypeScript now actually does the work to prove whether or not each part of a template string can successfully match. You can now mix and match template strings with different substitutions and TypeScript will do a good job to figure out whether they’re really compatible.\n\ndeclare let s1: `${number}-${number}-${number}`;\ndeclare let s2: `1-2-3`;\ndeclare let s3: `${number}-2-3`;\ndeclare let s4: `1-${number}-3`;\ndeclare let s5: `1-2-${number}`;\ndeclare let s6: `${number}-2-${number}`;\n// Now *all of these* work!\ns1 = s2;\ns1 = s3;\ns1 = s4;\ns1 = s5;\ns1 = s6;\n\nIn doing this work, we were also sure to add better inference capabilities. You can see an example of these in action:\n\ndeclare function foo<V extends string>(arg: `*${V}*`): V;\nfunction test<T extends string>(s: string, n: number, b: boolean, t: T) {\n    let x1 = foo(\"*hello*\");            // \"hello\"\n    let x2 = foo(\"**hello**\");          // \"*hello*\"\n    let x3 = foo(`*${s}*` as const);    // string\n    let x4 = foo(`*${n}*` as const);    // `${number}`\n    let x5 = foo(`*${b}*` as const);    // \"true\" | \"false\"\n    let x6 = foo(`*${t}*` as const);    // `${T}`\n    let x7 = foo(`**${s}**` as const);  // `*${string}*`\n}\n\nFor more information, see the original pull request on leveraging contextual types, along with the pull request that improved inference and checking between template types.\n\nECMAScript \n#private\n Class Elements\n\nTypeScript 4.3 expands which elements in a class can be given #private #names to make them truly private at run-time. In addition to properties, methods and accessors can also be given private names.\n\nclass Foo {\n  #someMethod() {\n    //...\n  }\n  get #someValue() {\n    return 100;\n  }\n  publicMethod() {\n    // These work.\n    // We can access private-named members inside this class.\n    this.#someMethod();\n    return this.#someValue;\n  }\n}\nnew Foo().#someMethod();\n//        ~~~~~~~~~~~\n// error!\n// Property '#someMethod' is not accessible\n// outside class 'Foo' because it has a private identifier.\nnew Foo().#someValue;\n//        ~~~~~~~~~~\n// error!\n// Property '#someValue' is not accessible\n// outside class 'Foo' because it has a private identifier.\n\nEven more broadly, static members can now also have private names.\n\nclass Foo {\n  static #someMethod() {\n    // ...\n  }\n}\nFoo.#someMethod();\n//  ~~~~~~~~~~~\n// error!\n// Property '#someMethod' is not accessible\n// outside class 'Foo' because it has a private identifier.\n\nThis feature was authored in a pull request from our friends at Bloomberg - written by Titian Cernicova-Dragomirand Kubilay Kahveci, with support and expertise from Joey Watts, Rob Palmer, and Tim McClure. We’d like to extend our thanks to all of them!\n\nConstructorParameters\n Works on Abstract Classes\n\nIn TypeScript 4.3, the ConstructorParameters type helper now works on abstract classes.\n\nabstract class C {\n  constructor(a: string, b: number) {\n    // ...\n  }\n}\n// Has the type '[a: string, b: number]'.\ntype CParams = ConstructorParameters<typeof C>;\n\nThis is thanks to work done in TypeScript 4.2, where construct signatures can be marked as abstract:\n\ntype MyConstructorOf<T> = {\n    abstract new(...args: any[]): T;\n}\n// or using the shorthand syntax:\ntype MyConstructorOf<T> = abstract new (...args: any[]) => T;\n\nYou can see the change in more detail on GitHub.\n\nContextual Narrowing for Generics\n\nTypeScript 4.3 now includes some slightly smarter type-narrowing logic on generic values. This allows TypeScript to accept more patterns, and sometimes even catch mistakes.\n\nFor some motivation, let’s say we’re trying to write a function called makeUnique. It’ll take a Set or an Array of elements, and if it’s given an Array, it’ll sort that Array remove duplicates according to some comparison function. After all that, it will return the original collection.\n\nfunction makeUnique<T>(\n  collection: Set<T> | T[],\n  comparer: (x: T, y: T) => number\n): Set<T> | T[] {\n  // Early bail-out if we have a Set.\n  // We assume the elements are already unique.\n  if (collection instanceof Set) {\n    return collection;\n  }\n  // Sort the array, then remove consecutive duplicates.\n  collection.sort(comparer);\n  for (let i = 0; i < collection.length; i++) {\n    let j = i;\n    while (\n      j < collection.length &&\n      comparer(collection[i], collection[j + 1]) === 0\n    ) {\n      j++;\n    }\n    collection.splice(i + 1, j - i);\n  }\n  return collection;\n}\n\nLet’s leave questions about this function’s implementation aside, and assume it arose from the requirements of a broader application. Something that you might notice is that the signature doesn’t capture the original type of collection. We can do that by adding a type parameter called C in place of where we’ve written Set<T> | T[].\n\n- function makeUnique<T>(collection: Set<T> | T[], comparer: (x: T, y: T) => number): Set<T> | T[]\n+ function makeUnique<T, C extends Set<T> | T[]>(collection: C, comparer: (x: T, y: T) => number): C\n\nIn TypeScript 4.2 and earlier, you’d end up with a bunch of errors as soon as you tried this.\n\nfunction makeUnique<T, C extends Set<T> | T[]>(\n  collection: C,\n  comparer: (x: T, y: T) => number\n): C {\n  // Early bail-out if we have a Set.\n  // We assume the elements are already unique.\n  if (collection instanceof Set) {\n    return collection;\n  }\n  // Sort the array, then remove consecutive duplicates.\n  collection.sort(comparer);\n  //         ~~~~\n  // error: Property 'sort' does not exist on type 'C'.\n  for (let i = 0; i < collection.length; i++) {\n    //                             ~~~~~~\n    // error: Property 'length' does not exist on type 'C'.\n    let j = i;\n    while (\n      j < collection.length &&\n      comparer(collection[i], collection[j + 1]) === 0\n    ) {\n      //                    ~~~~~~\n      // error: Property 'length' does not exist on type 'C'.\n      //                                       ~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~\n      // error: Element implicitly has an 'any' type because expression of type 'number'\n      //        can't be used to index type 'Set<T> | T[]'.\n      j++;\n    }\n    collection.splice(i + 1, j - i);\n    //         ~~~~~~\n    // error: Property 'splice' does not exist on type 'C'.\n  }\n  return collection;\n}\n\nEw, errors! Why is TypeScript being so mean to us?\n\nThe issue is that when we perform our collection instanceof Set check, we’re expecting that to act as a type guard that narrows the type from Set<T> | T[] to Set<T> and T[] depending on the branch we’re in; however, we’re not dealing with a Set<T> | T[], we’re trying to narrow the generic value collection, whose type is C.\n\nIt’s a very subtle distinction, but it makes a difference. TypeScript can’t just grab the constraint of C (which is Set<T> | T[]) and narrow that. If TypeScript did try to narrow from Set<T> | T[], it would forget that collection is also a C in each branch because there’s no easy way to preserve that information. If hypothetically TypeScript tried that approach, it would break the above example in a different way. At the return positions, where the function expects values with the type C, we would instead get a Set<T> and a T[] in each branch, which TypeScript would reject.\n\nfunction makeUnique<T>(\n  collection: Set<T> | T[],\n  comparer: (x: T, y: T) => number\n): Set<T> | T[] {\n  // Early bail-out if we have a Set.\n  // We assume the elements are already unique.\n  if (collection instanceof Set) {\n    return collection;\n    //     ~~~~~~~~~~\n    // error: Type 'Set<T>' is not assignable to type 'C'.\n    //          'Set<T>' is assignable to the constraint of type 'C', but\n    //          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.\n  }\n  // ...\n  return collection;\n  //     ~~~~~~~~~~\n  // error: Type 'T[]' is not assignable to type 'C'.\n  //          'T[]' is assignable to the constraint of type 'C', but\n  //          'C' could be instantiated with a different subtype of constraint 'Set<T> | T[]'.\n}\n\nSo how does TypeScript 4.3 change things? Well, basically in a few key places when writing code, all the type system really cares about is the constraint of a type. For example, when we write collection.length, TypeScript doesn’t care about the fact that collection has the type C, it only cares about the properties available, which are determined by the constraint T[] | Set<T>.\n\nIn cases like this, TypeScript will grab the narrowed type of the constraint because that will give you the data you care about; however, in any other case, we’ll just try to narrow the original generic type (and often end up with the original generic type).\n\nIn other words, based on how you use a generic value, TypeScript will narrow it a little differently. The end result is that the entire above example compiles with no type-checking errors.\n\nFor more details, you can look at the original pull request on GitHub.\n\nAlways-Truthy Promise Checks\n\nUnder strictNullChecks, checking whether a Promise is “truthy” in a conditional will trigger an error.\n\nasync function foo(): Promise<boolean> {\n  return false;\n}\nasync function bar(): Promise<string> {\n  if (foo()) {\n    //  ~~~~~\n    // Error!\n    // This condition will always return true since\n    // this 'Promise<boolean>' appears to always be defined.\n    // Did you forget to use 'await'?\n    return \"true\";\n  }\n  return \"false\";\n}\n\nThis change was contributed by Jack Works, and we extend our thanks to them!\n\nstatic\n Index Signatures\n\nIndex signatures allow us to set more properties on a value than a type explicitly declares.\n\nclass Foo {\n  hello = \"hello\";\n  world = 1234;\n  // This is an index signature:\n  [propName: string]: string | number | undefined;\n}\nlet instance = new Foo();\n// Valid assignment\ninstance[\"whatever\"] = 42;\n// Has type 'string | number | undefined'.\nlet x = instance[\"something\"];\n\nUp until now, an index signature could only be declared on the instance side of a class. Thanks to a pull request from Wenlu Wang, index signatures can now be declared as static.\n\nclass Foo {\n  static hello = \"hello\";\n  static world = 1234;\n  static [propName: string]: string | number | undefined;\n}\n// Valid.\nFoo[\"whatever\"] = 42;\n// Has type 'string | number | undefined'\nlet x = Foo[\"something\"];\n\nThe same sorts of rules apply for index signatures on the static side of a class as they do for the instance side - namely, that every other static property has to be compatible with the index signature.\n\nclass Foo {\n  static prop = true;\n  //     ~~~~\n  // Error! Property 'prop' of type 'boolean'\n  // is not assignable to string index type\n  // 'string | number | undefined'.\n  static [propName: string]: string | number | undefined;\n}\n.tsbuildinfo\n Size Improvements\n\nIn TypeScript 4.3, .tsbuildinfo files that are generated as part of incremental builds should be significantly smaller. This is thanks to several optimizations in the internal format, creating tables with numeric identifiers to be used throughout the file instead of repeating full paths and similar information. This work was spear-headed by Tobias Koppers in their pull request, serving as inspiration for the ensuing pull request and further optimizations.\n\nWe have seen significant reductions of .tsbuildinfo file sizes including\n\n1MB to 411 KB\n14.9MB to 1MB\n1345MB to 467MB\n\nNeedless to say, these sorts of savings in size translate to slightly faster build times as well.\n\nLazier Calculations in \n--incremental\n and \n--watch\n Compilations\n\nOne of the issues with incremental and --watch modes are that while they make later compilations go faster, the initial compilation can be a bit slower - in some cases, significantly slower. This is because these modes have to perform a bunch of book-keeping, computing information about the current project, and sometimes saving that data in a .tsbuildinfo file for later builds.\n\nThat’s why on top of .tsbuildinfo size improvements, TypeScript 4.3 also ships some changes to incremental and --watch modes that make the first build of a project with these flags just as fast as an ordinary build! To do this, much of the information that would ordinarily be computed up-front is instead done on an on-demand basis for later builds. While this can add some overhead to a subsequent build, TypeScript’s incremental and --watch functionality will still typically operate on a much smaller set of files, and any needed information will be saved afterwards. In a sense, incremental and --watch builds will “warm up” and get faster at compiling files once you’ve updated them a few times.\n\nIn a repository with 3000 files, this reduced initial build times to almost a third!\n\nThis work was started by Tobias Koppers, whose work ensued in the resulting final change for this functionality. We’d like to extend a great thanks to Tobias for helping us find these opportunities for improvements!\n\nImport Statement Completions\n\nOne of the biggest pain-points users run into with import and export statements in JavaScript is the order - specifically that imports are written as\n\nimport { func } from \"./module.js\";\n\ninstead of\n\nfrom \"./module.js\" import { func };\n\nThis causes some pain when writing out a full import statement from scratch because auto-complete wasn’t able to work correctly. For example, if you start writing something like import {, TypeScript has no idea what module you’re planning on importing from, so it couldn’t provide any scoped-down completions.\n\nTo alleviate this, we’ve leveraged the power of auto-imports! Auto-imports already deal with the issue of not being able to narrow down completions from a specific module - their whole point is to provide every possible export and automatically insert an import statement at the top of your file.\n\nSo when you now start writing an import statement that doesn’t have a path, we’ll provide you with a list of possible imports. When you commit a completion, we’ll complete the full import statement, including the path that you were going to write.\n\nThis work requires editors that specifically support the feature. You’ll be able to try this out by using the latest Insiders versions of Visual Studio Code.\n\nFor more information, take a look at the implementing pull request!\n\nEditor Support for \n@link\n Tags\n\nTypeScript can now understand @link tags, and will try to resolve declarations that they link to. What this means is that you’ll be able to hover over names within @link tags and get quick information, or use commands like go-to-definition or find-all-references.\n\nFor example, you’ll be able to go-to-definition on plantCarrot in @link plantCarrot in the example below and a TypeScript-supported editor will jump to plantCarrot’s function declaration.\n\n/**\n * To be called 70 to 80 days after {@link plantCarrot}.\n */\nfunction harvestCarrot(carrot: Carrot) {}\n/**\n * Call early in spring for best results. Added in v2.1.0.\n * @param seed Make sure it's a carrot seed!\n */\nfunction plantCarrot(seed: Seed) {\n  // TODO: some gardening\n}\n\nFor more information, see the pull request on GitHub!\n\nGo-to-Definition on Non-JavaScript File Paths\n\nMany loaders allow users to include assets in their applications using JavaScript imports. They’ll typically be written as something like import \"./styles.css\" or the like.\n\nUp until now, TypeScript’s editor functionality wouldn’t even attempt to read this file, so go-to-definition would typically fail. At best, go-to-definition would jump to a declaration like declare module \"*.css\" if it could find something along those lines.\n\nTypeScript’s language service now tries to jump to the correct file when you perform a go-to-definition on relative file paths, even if they’re not JavaScript or TypeScript files! Try it out with imports to CSS, SVGs, PNGs, font files, Vue files, and more.\n\nFor more information, you can check out the implementing pull request.\n\nBreaking Changes\nlib.d.ts\n Changes\n\nAs with every TypeScript version, declarations for lib.d.ts (especially the declarations generated for web contexts), have changed. In this release, we leveraged Mozilla’s browser-compat-data to remove APIs that no browser implements. While it is unlike that you are using them, APIs such as Account, AssertionOptions, RTCStatsEventInit, MSGestureEvent, DeviceLightEvent, MSPointerEvent, ServiceWorkerMessageEvent, and WebAuthentication have all been removed from lib.d.ts. This is discussed in some detail here.\n\nhttps://github.com/microsoft/TypeScript-DOM-lib-generator/issues/991\n\nuseDefineForClassFields\n now defaults to true on \nesnext\n and eventually on \nes2022\n\nIn 2021 the class fields feature was added into the JavaScript specification with behavior which differed from how TypeScript had implemented it. In preparation for this, in TypeScript 3.7, a flag was added (useDefineForClassFields) to migrate to emitted JavaScript to match the JavaScript standard behavior.\n\nNow that the feature is in JavaScript we are changing the default to true for ES2022 and above, including ESNext.\n\nErrors on Always-Truthy Promise Checks\n\nUnder strictNullChecks, using a Promise that always appears to be defined within a condition check is now considered an error.\n\ndeclare var p: Promise<number>;\nif (p) {\n  //  ~\n  // Error!\n  // This condition will always return true since\n  // this 'Promise<number>' appears to always be defined.\n  //\n  // Did you forget to use 'await'?\n}\n\nFor more details, see the original change.\n\nUnion Enums Cannot Be Compared to Arbitrary Numbers\n\nCertain enums are considered union enums when their members are either automatically filled in, or trivially written. In those cases, an enum can recall each value that it potentially represents.\n\nIn TypeScript 4.3, if a value with a union enum type is compared with a numeric literal that it could never be equal to, then the type-checker will issue an error.\n\nenum E {\n  A = 0,\n  B = 1,\n}\nfunction doSomething(x: E) {\n  // Error! This condition will always return 'false' since the types 'E' and '-1' have no overlap.\n  if (x === -1) {\n    // ...\n  }\n}\n\nAs a workaround, you can re-write an annotation to include the appropriate literal type.\n\nenum E {\n  A = 0,\n  B = 1,\n}\n// Include -1 in the type, if we're really certain that -1 can come through.\nfunction doSomething(x: E | -1) {\n  if (x === -1) {\n    // ...\n  }\n}\n\nYou can also use a type-assertion on the value.\n\nenum E {\n  A = 0,\n  B = 1,\n}\nfunction doSomething(x: E) {\n  // Use a type assertion on 'x' because we know we're not actually just dealing with values from 'E'.\n  if ((x as number) === -1) {\n    // ...\n  }\n}\n\nAlternatively, you can re-declare your enum to have a non-trivial initializer so that any number is both assignable and comparable to that enum. This may be useful if the intent is for the enum to specify a few well-known values.\n\nenum E {\n  // the leading + on 0 opts TypeScript out of inferring a union enum.\n  A = +0,\n  B = 1,\n}\n\nFor more details, see the original change\n\nOn this page\nSeparate Write Types on Properties\noverride and the --noImplicitOverride Flag\nTemplate String Type Improvements\nECMAScript #private Class Elements\nConstructorParameters Works on Abstract Classes\nContextual Narrowing for Generics\nAlways-Truthy Promise Checks\nstatic Index Signatures\n.tsbuildinfo Size Improvements\nLazier Calculations in --incremental and --watch Compilations\nImport Statement Completions\nEditor Support for @link Tags\nGo-to-Definition on Non-JavaScript File Paths\nBreaking Changes\nlib.d.ts Changes\nuseDefineForClassFields now defaults to true on esnext and eventually on es2022\nErrors on Always-Truthy Promise Checks\nUnion Enums Cannot Be Compared to Arbitrary Numbers\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nEL\nNT\nMS\nJB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.424 seconds."
  },
  {
    "title": "TypeScript: Handbook - Interfaces",
    "url": "https://www.typescriptlang.org/docs/handbook/interfaces.html",
    "html": "This page has been deprecated\n\nThis handbook page has been replaced, go to the new page\n\nGo to new page\nInterfaces\n\nOne of TypeScript’s core principles is that type checking focuses on the shape that values have. This is sometimes called “duck typing” or “structural subtyping”. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.\n\nOur First Interface\n\nThe easiest way to see how interfaces work is to start with a simple example:\n\nfunction printLabel(labeledObj: { label: string }) {\n  console.log(labeledObj.label);\n}\n \nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\nTry\n\nThe type checker checks the call to printLabel. The printLabel function has a single parameter that requires that the object passed in has a property called label of type string. Notice that our object actually has more properties than this, but the compiler only checks that at least the ones required are present and match the types required. There are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit.\n\nWe can write the same example again, this time using an interface to describe the requirement of having the label property that is a string:\n\ninterface LabeledValue {\n  label: string;\n}\n \nfunction printLabel(labeledObj: LabeledValue) {\n  console.log(labeledObj.label);\n}\n \nlet myObj = { size: 10, label: \"Size 10 Object\" };\nprintLabel(myObj);\nTry\n\nThe interface LabeledValue is a name we can now use to describe the requirement in the previous example. It still represents having a single property called label that is of type string. Notice we didn’t have to explicitly say that the object we pass to printLabel implements this interface like we might have to in other languages. Here, it’s only the shape that matters. If the object we pass to the function meets the requirements listed, then it’s allowed.\n\nIt’s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.\n\nOptional Properties\n\nNot all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like “option bags” where you pass an object to a function that only has a couple of properties filled in.\n\nHere’s an example of this pattern:\n\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n \nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.color) {\n    newSquare.color = config.color;\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n \nlet mySquare = createSquare({ color: \"black\" });\nTry\n\nInterfaces with optional properties are written similar to other interfaces, with each optional property denoted by a ? at the end of the property name in the declaration.\n\nThe advantage of optional properties is that you can describe these possibly available properties while still also preventing use of properties that are not part of the interface. For example, had we mistyped the name of the color property in createSquare, we would get an error message letting us know:\n\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n \nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  let newSquare = { color: \"white\", area: 100 };\n  if (config.clor) {\nProperty 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?\nProperty 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?\n    // Error: Property 'clor' does not exist on type 'SquareConfig'\n    newSquare.color = config.clor;\nProperty 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?\nProperty 'clor' does not exist on type 'SquareConfig'. Did you mean 'color'?\n  }\n  if (config.width) {\n    newSquare.area = config.width * config.width;\n  }\n  return newSquare;\n}\n \nlet mySquare = createSquare({ color: \"black\" });\nTry\nReadonly properties\n\nSome properties should only be modifiable when an object is first created. You can specify this by putting readonly before the name of the property:\n\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\nTry\n\nYou can construct a Point by assigning an object literal. After the assignment, x and y can’t be changed.\n\nlet p1: Point = { x: 10, y: 20 };\np1.x = 5; // error!\nCannot assign to 'x' because it is a read-only property.\nCannot assign to 'x' because it is a read-only property.\nTry\n\nTypeScript comes with a ReadonlyArray<T> type that is the same as Array<T> with all mutating methods removed, so you can make sure you don’t change your arrays after creation:\n\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\n \nro[0] = 12; // error!\nIndex signature in type 'readonly number[]' only permits reading.\nIndex signature in type 'readonly number[]' only permits reading.\nro.push(5); // error!\nProperty 'push' does not exist on type 'readonly number[]'.\nProperty 'push' does not exist on type 'readonly number[]'.\nro.length = 100; // error!\nCannot assign to 'length' because it is a read-only property.\nCannot assign to 'length' because it is a read-only property.\na = ro; // error!\nThe type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.\nThe type 'readonly number[]' is 'readonly' and cannot be assigned to the mutable type 'number[]'.\nTry\n\nOn the last line of the snippet you can see that even assigning the entire ReadonlyArray back to a normal array is illegal. You can still override it with a type assertion, though:\n\nlet a: number[] = [1, 2, 3, 4];\nlet ro: ReadonlyArray<number> = a;\n \na = ro as number[];\nTry\nreadonly\n vs \nconst\n\nThe easiest way to remember whether to use readonly or const is to ask whether you’re using it on a variable or a property. Variables use const whereas properties use readonly.\n\nExcess Property Checks\n\nIn our first example using interfaces, TypeScript lets us pass { size: number; label: string; } to something that only expected a { label: string; }. We also just learned about optional properties, and how they’re useful when describing so-called “option bags”.\n\nHowever, combining the two naively would allow an error to sneak in. For example, taking our last example using createSquare:\n\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n}\n \nfunction createSquare(config: SquareConfig): { color: string; area: number } {\n  return {\n    color: config.color || \"red\",\n    area: config.width ? config.width * config.width : 20,\n  };\n}\n \nlet mySquare = createSquare({ colour: \"red\", width: 100 });\nArgument of type '{ colour: string; width: number; }' is not assignable to parameter of type 'SquareConfig'.\n  Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?\nArgument of type '{ colour: string; width: number; }' is not assignable to parameter of type 'SquareConfig'.\n  Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?\nTry\n\nNotice the given argument to createSquare is spelled colour instead of color. In plain JavaScript, this sort of thing fails silently.\n\nYou could argue that this program is correctly typed, since the width properties are compatible, there’s no color property present, and the extra colour property is insignificant.\n\nHowever, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error:\n\nlet mySquare = createSquare({ colour: \"red\", width: 100 });\nArgument of type '{ colour: string; width: number; }' is not assignable to parameter of type 'SquareConfig'.\n  Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?\nArgument of type '{ colour: string; width: number; }' is not assignable to parameter of type 'SquareConfig'.\n  Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?\nTry\n\nGetting around these checks is actually really simple. The easiest method is to just use a type assertion:\n\nlet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);\nTry\n\nHowever, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If SquareConfig can have color and width properties with the above types, but could also have any number of other properties, then we could define it like so:\n\ninterface SquareConfig {\n  color?: string;\n  width?: number;\n  [propName: string]: any;\n}\nTry\n\nWe’ll discuss index signatures in a bit, but here we’re saying a SquareConfig can have any number of properties, and as long as they aren’t color or width, their types don’t matter.\n\nOne final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since squareOptions won’t undergo excess property checks, the compiler won’t give you an error.\n\nlet squareOptions = { colour: \"red\", width: 100 };\nlet mySquare = createSquare(squareOptions);\nTry\n\nThe above workaround will work as long as you have a common property between squareOptions and SquareConfig. In this example, it was the property width. It will however, fail if the variable does not have any common object property. For example:\n\nlet squareOptions = { colour: \"red\" };\nlet mySquare = createSquare(squareOptions);\nType '{ colour: string; }' has no properties in common with type 'SquareConfig'.\nType '{ colour: string; }' has no properties in common with type 'SquareConfig'.\nTry\n\nKeep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a color or colour property to createSquare, you should fix up the definition of SquareConfig to reflect that.\n\nFunction Types\n\nInterfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.\n\nTo describe a function type with an interface, we give the interface a call signature. This is like a function declaration with only the parameter list and return type given. Each parameter in the parameter list requires both name and type.\n\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\nTry\n\nOnce defined, we can use this function type interface like we would other interfaces. Here, we show how you can create a variable of a function type and assign it a function value of the same type.\n\nlet mySearch: SearchFunc;\n \nmySearch = function (source: string, subString: string): boolean {\n  let result = source.search(subString);\n  return result > -1;\n};\nTry\n\nFor function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:\n\nlet mySearch: SearchFunc;\n \nmySearch = function (src: string, sub: string): boolean {\n  let result = src.search(sub);\n  return result > -1;\n};\nTry\n\nFunction parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript’s contextual typing can infer the argument types since the function value is assigned directly to a variable of type SearchFunc. Here, also, the return type of our function expression is implied by the values it returns (here false and true).\n\nlet mySearch: SearchFunc;\n \nmySearch = function (src, sub) {\n  let result = src.search(sub);\n  return result > -1;\n};\nTry\n\nHad the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn’t match the return type described in the SearchFunc interface.\n\nlet mySearch: SearchFunc;\n \nmySearch = function (src, sub) {\nType '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'.\nType '(src: string, sub: string) => string' is not assignable to type 'SearchFunc'.\n  Type 'string' is not assignable to type 'boolean'.\n  let result = src.search(sub);\n  return \"string\";\n};\nTry\nIndexable Types\n\nSimilarly to how we can use interfaces to describe function types, we can also describe types that we can “index into” like a[10], or ageMap[\"daniel\"]. Indexable types have an index signature that describes the types we can use to index into the object, along with the corresponding return types when indexing.\n\nLet’s take an example:\n\ninterface StringArray {\n  [index: number]: string;\n}\n \nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n \nlet myStr: string = myArray[0];\nTry\n\nAbove, we have a StringArray interface that has an index signature. This index signature states that when a StringArray is indexed with a number, it will return a string.\n\nThere are four types of supported index signatures: string, number, symbol and template strings. It is possible to support many types of indexers, but the type returned from a numeric indexer must be a subtype of the type returned from the string indexer.\n\nThis is because when indexing with a number, JavaScript will actually convert that to a string before indexing into an object. That means that indexing with 100 (a number) is the same thing as indexing with \"100\" (a string), so the two need to be consistent.\n\ninterface Animal {\n  name: string;\n}\n \ninterface Dog extends Animal {\n  breed: string;\n}\n \n// Error: indexing with a numeric string might get you a completely separate type of Animal!\ninterface NotOkay {\n  [x: number]: Animal;\n'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.\n'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.\n  [x: string]: Dog;\n}\nTry\n\nWhile string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj[\"property\"]. In the following example, name’s type does not match the string index’s type, and the type checker gives an error:\n\ninterface NumberDictionary {\n  [index: string]: number;\n \n  length: number; // ok, length is a number\n  name: string; // error, the type of 'name' is not a subtype of the indexer\nProperty 'name' of type 'string' is not assignable to 'string' index type 'number'.\nProperty 'name' of type 'string' is not assignable to 'string' index type 'number'.\n}\nTry\n\nHowever, properties of different types are acceptable if the index signature is a union of the property types:\n\ninterface NumberOrStringDictionary {\n  [index: string]: number | string;\n \n  length: number; // ok, length is a number\n  name: string; // ok, name is a string\n}\nTry\n\nFinally, you can make index signatures readonly in order to prevent assignment to their indices:\n\ninterface ReadonlyStringArray {\n  readonly [index: number]: string;\n}\n \nlet myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];\nmyArray[2] = \"Mallory\"; // error!\nIndex signature in type 'ReadonlyStringArray' only permits reading.\nIndex signature in type 'ReadonlyStringArray' only permits reading.\nTry\n\nYou can’t set myArray[2] because the index signature is readonly.\n\nIndexable Types with Template Strings\n\nA template string can be used to indicate that a particular pattern is allowed, but not all. For example, a HTTP headers object may have a set list of known headers and support any custom defined properties which are prefixed with x-.\n\ninterface HeadersResponse {\n  \"content-type\": string,\n  date: string,\n  \"content-length\": string\n \n  // Permit any property starting with 'x-'.\n  [headerName: `x-${string}`]: string;\n}\n \nfunction handleResponse(r: HeadersResponse) {\n  // Handle known, and x- prefixed\n  const type = r[\"content-type\"]\n  const poweredBy = r[\"x-powered-by\"]\n \n  // Unknown keys without the prefix raise errors\n  const origin = r.origin\nProperty 'origin' does not exist on type 'HeadersResponse'.\nProperty 'origin' does not exist on type 'HeadersResponse'.\n}\nTry\nClass Types\nImplementing an interface\n\nOne of the most common uses of interfaces in languages like C# and Java, that of explicitly enforcing that a class meets a particular contract, is also possible in TypeScript.\n\ninterface ClockInterface {\n  currentTime: Date;\n}\n \nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  constructor(h: number, m: number) {}\n}\nTry\n\nYou can also describe methods in an interface that are implemented in the class, as we do with setTime in the below example:\n\ninterface ClockInterface {\n  currentTime: Date;\n  setTime(d: Date): void;\n}\n \nclass Clock implements ClockInterface {\n  currentTime: Date = new Date();\n  setTime(d: Date) {\n    this.currentTime = d;\n  }\n  constructor(h: number, m: number) {}\n}\nTry\n\nInterfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.\n\nDifference between the static and instance sides of classes\n\nWhen working with classes and interfaces, it helps to keep in mind that a class has two types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:\n\ninterface ClockConstructor {\n  new (hour: number, minute: number);\n}\n \nclass Clock implements ClockConstructor {\nClass 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.\nClass 'Clock' incorrectly implements interface 'ClockConstructor'.\n  Type 'Clock' provides no match for the signature 'new (hour: number, minute: number): any'.\n  currentTime: Date;\n  constructor(h: number, m: number) {}\n}\nTry\n\nThis is because when a class implements an interface, only the instance side of the class is checked. Since the constructor sits in the static side, it is not included in this check.\n\nInstead, you would need to work with the static side of the class directly. In this example, we define two interfaces, ClockConstructor for the constructor and ClockInterface for the instance methods. Then, for convenience, we define a constructor function createClock that creates instances of the type that is passed to it:\n\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n \ninterface ClockInterface {\n  tick(): void;\n}\n \nfunction createClock(\n  ctor: ClockConstructor,\n  hour: number,\n  minute: number\n): ClockInterface {\n  return new ctor(hour, minute);\n}\n \nclass DigitalClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"beep beep\");\n  }\n}\n \nclass AnalogClock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"tick tock\");\n  }\n}\n \nlet digital = createClock(DigitalClock, 12, 17);\nlet analog = createClock(AnalogClock, 7, 32);\nTry\n\nBecause createClock’s first parameter is of type ClockConstructor, in createClock(AnalogClock, 7, 32), it checks that AnalogClock has the correct constructor signature.\n\nAnother simple way is to use class expressions:\n\ninterface ClockConstructor {\n  new (hour: number, minute: number): ClockInterface;\n}\n \ninterface ClockInterface {\n  tick(): void;\n}\n \nconst Clock: ClockConstructor = class Clock implements ClockInterface {\n  constructor(h: number, m: number) {}\n  tick() {\n    console.log(\"beep beep\");\n  }\n};\n \nlet clock = new Clock(12, 17);\nclock.tick();\nTry\nExtending Interfaces\n\nLike classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.\n\ninterface Shape {\n  color: string;\n}\n \ninterface Square extends Shape {\n  sideLength: number;\n}\n \nlet square = {} as Square;\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nTry\n\nAn interface can extend multiple interfaces, creating a combination of all of the interfaces.\n\ninterface Shape {\n  color: string;\n}\n \ninterface PenStroke {\n  penWidth: number;\n}\n \ninterface Square extends Shape, PenStroke {\n  sideLength: number;\n}\n \nlet square = {} as Square;\nsquare.color = \"blue\";\nsquare.sideLength = 10;\nsquare.penWidth = 5.0;\nTry\nHybrid Types\n\nAs we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript’s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.\n\nOne such example is an object that acts as both a function and an object, with additional properties:\n\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n \nfunction getCounter(): Counter {\n  let counter = function (start: number) {} as Counter;\n  counter.interval = 123;\n  counter.reset = function () {};\n  return counter;\n}\n \nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\nTry\n\nWhen interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.\n\nInterfaces Extending Classes\n\nWhen an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.\n\nThis is useful when you have a large inheritance hierarchy, but want to specify that your code works with only subclasses that have certain properties. The subclasses don’t have to be related besides inheriting from the base class. For example:\n\nclass Control {\n  private state: any;\n}\n \ninterface SelectableControl extends Control {\n  select(): void;\n}\n \nclass Button extends Control implements SelectableControl {\n  select() {}\n}\n \nclass TextBox extends Control {\n  select() {}\n}\n \nclass ImageControl implements SelectableControl {\nClass 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'.\nClass 'ImageControl' incorrectly implements interface 'SelectableControl'.\n  Types have separate declarations of a private property 'state'.\n  private state: any;\n  select() {}\n}\nTry\n\nIn the above example, SelectableControl contains all of the members of Control, including the private state property. Since state is a private member it is only possible for descendants of Control to implement SelectableControl. This is because only descendants of Control will have a state private member that originates in the same declaration, which is a requirement for private members to be compatible.\n\nWithin the Control class it is possible to access the state private member through an instance of SelectableControl. Effectively, a SelectableControl acts like a Control that is known to have a select method. The Button and TextBox classes are subtypes of SelectableControl (because they both inherit from Control and have a select method). The ImageControl class has its own state private member rather than extending Control, so it cannot implement SelectableControl.\n\nOn this page\nOur First Interface\nOptional Properties\nReadonly properties\nreadonly vs const\nExcess Property Checks\nFunction Types\nIndexable Types\nIndexable Types with Template Strings\nClass Types\nImplementing an interface\nDifference between the static and instance sides of classes\nExtending Interfaces\nHybrid Types\nInterfaces Extending Classes\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nRC\nDR\nOT\nJ\nMH\n44+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.954 seconds."
  },
  {
    "title": "TypeScript: Documentation - Modules - Introduction",
    "url": "https://www.typescriptlang.org/docs/handbook/modules/introduction.html",
    "html": "Modules - Introduction\n\nThis document is divided into four sections:\n\nThe first section develops the theory behind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.\nThe guides show how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.\nThe reference section provides a more detailed look at the syntaxes and configurations presented in previous sections.\nThe appendices cover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow.\nOn this page\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 2.105 seconds."
  },
  {
    "title": "TypeScript: Handbook - Basic Types",
    "url": "https://www.typescriptlang.org/docs/handbook/basic-types.html#a-note-about-let",
    "html": "This page has been deprecated\n\nThis handbook page has been replaced, go to the new page\n\nGo to new page\nBasic Types\n\nFor programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support the same types as you would expect in JavaScript, with an extra enumeration type thrown in to help things along.\n\nBoolean\n\nThe most basic datatype is the simple true/false value, which JavaScript and TypeScript call a boolean value.\n\nlet isDone: boolean = false;\nTry\nNumber\n\nAs in JavaScript, all numbers in TypeScript are either floating point values or BigIntegers. These floating point numbers get the type number, while BigIntegers get the type bigint. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.\n\nlet decimal: number = 6;\nlet hex: number = 0xf00d;\nlet binary: number = 0b1010;\nlet octal: number = 0o744;\nlet big: bigint = 100n;\nTry\nString\n\nAnother fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type string to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (\") or single quotes (') to surround string data.\n\nlet color: string = \"blue\";\ncolor = 'red';\nTry\n\nYou can also use template strings, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (`) character, and embedded expressions are of the form ${ expr }.\n\nlet fullName: string = `Bob Bobbington`;\nlet age: number = 37;\nlet sentence: string = `Hello, my name is ${fullName}.\n \nI'll be ${age + 1} years old next month.`;\nTry\n\nThis is equivalent to declaring sentence like so:\n\nlet sentence: string =\n  \"Hello, my name is \" +\n  fullName +\n  \".\\n\\n\" +\n  \"I'll be \" +\n  (age + 1) +\n  \" years old next month.\";\nTry\nArray\n\nTypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by [] to denote an array of that element type:\n\nlet list: number[] = [1, 2, 3];\nTry\n\nThe second way uses a generic array type, Array<elemType>:\n\nlet list: Array<number> = [1, 2, 3];\nTry\nTuple\n\nTuple types allow you to express an array with a fixed number of elements whose types are known, but need not be the same. For example, you may want to represent a value as a pair of a string and a number:\n\n// Declare a tuple type\nlet x: [string, number];\n// Initialize it\nx = [\"hello\", 10]; // OK\n// Initialize it incorrectly\nx = [10, \"hello\"]; // Error\nType 'number' is not assignable to type 'string'.\nType 'string' is not assignable to type 'number'.\nType 'number' is not assignable to type 'string'.\nType 'string' is not assignable to type 'number'.\nTry\n\nWhen accessing an element with a known index, the correct type is retrieved:\n\n// OK\nconsole.log(x[0].substring(1));\n \nconsole.log(x[1].substring(1));\nProperty 'substring' does not exist on type 'number'.\nProperty 'substring' does not exist on type 'number'.\nTry\n\nAccessing an element outside the set of known indices fails with an error:\n\nx[3] = \"world\";\nTuple type '[string, number]' of length '2' has no element at index '3'.\nTuple type '[string, number]' of length '2' has no element at index '3'.\n \nconsole.log(x[5].toString());\nObject is possibly 'undefined'.\nTuple type '[string, number]' of length '2' has no element at index '5'.\nObject is possibly 'undefined'.\nTuple type '[string, number]' of length '2' has no element at index '5'.\nTry\nEnum\n\nA helpful addition to the standard set of datatypes from JavaScript is the enum. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.\n\nenum Color {\n  Red,\n  Green,\n  Blue,\n}\nlet c: Color = Color.Green;\nTry\n\nBy default, enums begin numbering their members starting at 0. You can change this by manually setting the value of one of its members. For example, we can start the previous example at 1 instead of 0:\n\nenum Color {\n  Red = 1,\n  Green,\n  Blue,\n}\nlet c: Color = Color.Green;\nTry\n\nOr, even manually set all the values in the enum:\n\nenum Color {\n  Red = 1,\n  Green = 2,\n  Blue = 4,\n}\nlet c: Color = Color.Green;\nTry\n\nA handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value 2 but weren’t sure what that mapped to in the Color enum above, we could look up the corresponding name:\n\nenum Color {\n  Red = 1,\n  Green,\n  Blue,\n}\nlet colorName: string = Color[2];\n \n// Displays 'Green'\nconsole.log(colorName);\nTry\nUnknown\n\nWe may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content – e.g. from the user – or we may want to intentionally accept all values in our API. In these cases, we want to provide a type that tells the compiler and future readers that this variable could be anything, so we give it the unknown type.\n\nlet notSure: unknown = 4;\nnotSure = \"maybe a string instead\";\n \n// OK, definitely a boolean\nnotSure = false;\nTry\n\nIf you have a variable with an unknown type, you can narrow it to something more specific by doing typeof checks, comparison checks, or more advanced type guards that will be discussed in a later chapter:\n\ndeclare const maybe: unknown;\n// 'maybe' could be a string, object, boolean, undefined, or other types\nconst aNumber: number = maybe;\nType 'unknown' is not assignable to type 'number'.\nType 'unknown' is not assignable to type 'number'.\n \nif (maybe === true) {\n  // TypeScript knows that maybe is a boolean now\n  const aBoolean: boolean = maybe;\n  // So, it cannot be a string\n  const aString: string = maybe;\nType 'boolean' is not assignable to type 'string'.\nType 'boolean' is not assignable to type 'string'.\n}\n \nif (typeof maybe === \"string\") {\n  // TypeScript knows that maybe is a string\n  const aString: string = maybe;\n  // So, it cannot be a boolean\n  const aBoolean: boolean = maybe;\nType 'string' is not assignable to type 'boolean'.\nType 'string' is not assignable to type 'boolean'.\n}\nTry\nAny\n\nIn some situations, not all type information is available or its declaration would take an inappropriate amount of effort. These may occur for values from code that has been written without TypeScript or a 3rd party library. In these cases, we might want to opt-out of type checking. To do so, we label these values with the any type:\n\ndeclare function getValue(key: string): any;\n// OK, return value of 'getValue' is not checked\nconst str: string = getValue(\"myString\");\nTry\n\nThe any type is a powerful way to work with existing JavaScript, allowing you to gradually opt-in and opt-out of type checking during compilation.\n\nUnlike unknown, variables of type any allow you to access arbitrary properties, even ones that don’t exist. These properties include functions and TypeScript will not check their existence or type:\n\nlet looselyTyped: any = 4;\n// OK, ifItExists might exist at runtime\nlooselyTyped.ifItExists();\n// OK, toFixed exists (but the compiler doesn't check)\nlooselyTyped.toFixed();\n \nlet strictlyTyped: unknown = 4;\nstrictlyTyped.toFixed();\n'strictlyTyped' is of type 'unknown'.\n'strictlyTyped' is of type 'unknown'.\nTry\n\nThe any will continue to propagate through your objects:\n\nlet looselyTyped: any = {};\nlet d = looselyTyped.a.b.c.d;\n   \nlet d: any\nTry\n\nAfter all, remember that all the convenience of any comes at the cost of losing type safety. Type safety is one of the main motivations for using TypeScript and you should try to avoid using any when not necessary.\n\nVoid\n\nvoid is a little like the opposite of any: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:\n\nfunction warnUser(): void {\n  console.log(\"This is my warning message\");\n}\nTry\n\nDeclaring variables of type void is not useful because you can only assign null (only if strictNullChecks is not specified, see next section) or undefined to them:\n\nlet unusable: void = undefined;\n// OK if `--strictNullChecks` is not given\nunusable = null;\nTry\nNull and Undefined\n\nIn TypeScript, both undefined and null actually have their types named undefined and null respectively. Much like void, they’re not extremely useful on their own:\n\n// Not much else we can assign to these variables!\nlet u: undefined = undefined;\nlet n: null = null;\nTry\n\nBy default null and undefined are subtypes of all other types. That means you can assign null and undefined to something like number.\n\nHowever, when using the strictNullChecks flag, null and undefined are only assignable to unknown, any and their respective types (the one exception being that undefined is also assignable to void). This helps avoid many common errors. In cases where you want to pass in either a string or null or undefined, you can use the union type string | null | undefined.\n\nUnion types are an advanced topic that we’ll cover in a later chapter.\n\nAs a note: we encourage the use of strictNullChecks when possible, but for the purposes of this handbook, we will assume it is turned off.\n\nNever\n\nThe never type represents the type of values that never occur. For instance, never is the return type for a function expression or an arrow function expression that always throws an exception or one that never returns. Variables also acquire the type never when narrowed by any type guards that can never be true.\n\nThe never type is a subtype of, and assignable to, every type; however, no type is a subtype of, or assignable to, never (except never itself). Even any isn’t assignable to never.\n\nSome examples of functions returning never:\n\n// Function returning never must not have a reachable end point\nfunction error(message: string): never {\n  throw new Error(message);\n}\n \n// Inferred return type is never\nfunction fail() {\n  return error(\"Something failed\");\n}\n \n// Function returning never must not have a reachable end point\nfunction infiniteLoop(): never {\n  while (true) {}\n}\nTry\nObject\n\nobject is a type that represents the non-primitive type, i.e. anything that is not number, string, boolean, bigint, symbol, null, or undefined.\n\nWith object type, APIs like Object.create can be better represented. For example:\n\ndeclare function create(o: object | null): void;\n \n// OK\ncreate({ prop: 0 });\ncreate(null);\ncreate(undefined); // with `--strictNullChecks` flag enabled, undefined is not a subtype of null\nArgument of type 'undefined' is not assignable to parameter of type 'object | null'.\nArgument of type 'undefined' is not assignable to parameter of type 'object | null'.\n \ncreate(42);\nArgument of type 'number' is not assignable to parameter of type 'object'.\nArgument of type 'number' is not assignable to parameter of type 'object'.\ncreate(\"string\");\nArgument of type 'string' is not assignable to parameter of type 'object'.\nArgument of type 'string' is not assignable to parameter of type 'object'.\ncreate(false);\nArgument of type 'boolean' is not assignable to parameter of type 'object'.\nArgument of type 'boolean' is not assignable to parameter of type 'object'.\nTry\n\nGenerally, you won’t need to use this.\n\nType assertions\n\nSometimes you’ll end up in a situation where you’ll know more about a value than TypeScript does. Usually, this will happen when you know the type of some entity could be more specific than its current type.\n\nType assertions are a way to tell the compiler “trust me, I know what I’m doing.” A type assertion is like a type cast in other languages, but it performs no special checking or restructuring of data. It has no runtime impact and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.\n\nType assertions have two forms.\n\nOne is the as-syntax:\n\nlet someValue: unknown = \"this is a string\";\n \nlet strLength: number = (someValue as string).length;\nTry\n\nThe other version is the “angle-bracket” syntax:\n\nlet someValue: unknown = \"this is a string\";\n \nlet strLength: number = (<string>someValue).length;\nTry\n\nThe two samples are equivalent. Using one over the other is mostly a choice of preference; however, when using TypeScript with JSX, only as-style assertions are allowed.\n\nA note about \nlet\n\nYou may have noticed that so far, we’ve been using the let keyword instead of JavaScript’s var keyword which you might be more familiar with. The let keyword is actually a newer JavaScript construct that TypeScript makes available. You can read in the Handbook Reference on Variable Declarations more about how let and const fix a lot of the problems with var.\n\nAbout \nNumber\n, \nString\n, \nBoolean\n, \nSymbol\n and \nObject\n\nIt can be tempting to think that the types Number, String, Boolean, Symbol, or Object are the same as the lowercase versions recommended above. These types do not refer to the language primitives however, and almost never should be used as a type.\n\nfunction reverse(s: String): String {\n  return s.split(\"\").reverse().join(\"\");\n}\n \nreverse(\"hello world\");\nTry\n\nInstead, use the types number, string, boolean, object and symbol.\n\nfunction reverse(s: string): string {\n  return s.split(\"\").reverse().join(\"\");\n}\n \nreverse(\"hello world\");\nTry\nOn this page\nBoolean\nNumber\nString\nArray\nTuple\nEnum\nUnknown\nAny\nVoid\nNull and Undefined\nNever\nObject\nType assertions\nA note about let\nAbout Number, String, Boolean, Symbol and Object\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nRC\nOT\nDR\nNS\nMZ\n47+\n\nLast updated: Nov 27, 2023\n\n "
  },
  {
    "title": "TypeScript: Handbook - Functions",
    "url": "https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters",
    "html": "This page has been deprecated\n\nThis handbook page has been replaced, go to the new page\n\nGo to new page\nFunctions\n\nFunctions are the fundamental building block of any application in JavaScript. They’re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to do things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.\n\nFunctions\n\nTo begin, just as in JavaScript, TypeScript functions can be created both as a named function or as an anonymous function. This allows you to choose the most appropriate approach for your application, whether you’re building a list of functions in an API or a one-off function to hand off to another function.\n\nTo quickly recap what these two approaches look like in JavaScript:\n\n// Named function\nfunction add(x, y) {\n  return x + y;\n}\n \n// Anonymous function\nlet myAdd = function (x, y) {\n  return x + y;\n};\nTry\n\nJust as in JavaScript, functions can refer to variables outside of the function body. When they do so, they’re said to capture these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.\n\nlet z = 100;\n \nfunction addToZ(x, y) {\n  return x + y + z;\n}\nTry\nFunction Types\nTyping the function\n\nLet’s add types to our simple examples from earlier:\n\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n \nlet myAdd = function (x: number, y: number): number {\n  return x + y;\n};\nTry\n\nWe can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.\n\nWriting the function type\n\nNow that we’ve typed the function, let’s write the full type of the function out by looking at each piece of the function type.\n\nlet myAdd: (x: number, y: number) => number = function (\n  x: number,\n  y: number\n): number {\n  return x + y;\n};\nTry\n\nA function’s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:\n\nlet myAdd: (baseValue: number, increment: number) => number = function (\n  x: number,\n  y: number\n): number {\n  return x + y;\n};\nTry\n\nAs long as the parameter types line up, it’s considered a valid type for the function, regardless of the names you give the parameters in the function type.\n\nThe second part is the return type. We make it clear which is the return type by using an arrow (=>) between the parameters and the return type. As mentioned before, this is a required part of the function type, so if the function doesn’t return a value, you would use void instead of leaving it off.\n\nOf note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the “hidden state” of any function and do not make up its API.\n\nInferring the types\n\nIn playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:\n\n// The parameters 'x' and 'y' have the type number\nlet myAdd = function (x: number, y: number): number {\n  return x + y;\n};\n \n// myAdd has the full function type\nlet myAdd2: (baseValue: number, increment: number) => number = function (x, y) {\n  return x + y;\n};\nTry\n\nThis is called “contextual typing”, a form of type inference. This helps cut down on the amount of effort to keep your program typed.\n\nOptional and Default Parameters\n\nIn TypeScript, every parameter is assumed to be required by the function. This doesn’t mean that it can’t be given null or undefined, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.\n\nfunction buildName(firstName: string, lastName: string) {\n  return firstName + \" \" + lastName;\n}\n \nlet result1 = buildName(\"Bob\"); // error, too few parameters\nExpected 2 arguments, but got 1.\nExpected 2 arguments, but got 1.\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nExpected 2 arguments, but got 3.\nExpected 2 arguments, but got 3.\nlet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right\nTry\n\nIn JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is undefined. We can get this functionality in TypeScript by adding a ? to the end of parameters we want to be optional. For example, let’s say we want the last name parameter from above to be optional:\n\nfunction buildName(firstName: string, lastName?: string) {\n  if (lastName) return firstName + \" \" + lastName;\n  else return firstName;\n}\n \nlet result1 = buildName(\"Bob\"); // works correctly now\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nExpected 1-2 arguments, but got 3.\nExpected 1-2 arguments, but got 3.\nlet result3 = buildName(\"Bob\", \"Adams\"); // ah, just right\nTry\n\nAny optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.\n\nIn TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes undefined in its place. These are called default-initialized parameters. Let’s take the previous example and default the last name to \"Smith\".\n\nfunction buildName(firstName: string, lastName = \"Smith\") {\n  return firstName + \" \" + lastName;\n}\n \nlet result1 = buildName(\"Bob\"); // works correctly now, returns \"Bob Smith\"\nlet result2 = buildName(\"Bob\", undefined); // still works, also returns \"Bob Smith\"\nlet result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nExpected 1-2 arguments, but got 3.\nExpected 1-2 arguments, but got 3.\nlet result4 = buildName(\"Bob\", \"Adams\"); // ah, just right\nTry\n\nDefault-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both\n\nfunction buildName(firstName: string, lastName?: string) {\n  // ...\n}\n\nand\n\nfunction buildName(firstName: string, lastName = \"Smith\") {\n  // ...\n}\n\nshare the same type (firstName: string, lastName?: string) => string. The default value of lastName disappears in the type, only leaving behind the fact that the parameter is optional.\n\nUnlike plain optional parameters, default-initialized parameters don’t need to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass undefined to get the default initialized value. For example, we could write our last example with only a default initializer on firstName:\n\nfunction buildName(firstName = \"Will\", lastName: string) {\n  return firstName + \" \" + lastName;\n}\n \nlet result1 = buildName(\"Bob\"); // error, too few parameters\nExpected 2 arguments, but got 1.\nExpected 2 arguments, but got 1.\nlet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, too many parameters\nExpected 2 arguments, but got 3.\nExpected 2 arguments, but got 3.\nlet result3 = buildName(\"Bob\", \"Adams\"); // okay and returns \"Bob Adams\"\nlet result4 = buildName(undefined, \"Adams\"); // okay and returns \"Will Adams\"\nTry\nRest Parameters\n\nRequired, optional, and default parameters all have one thing in common: they talk about one parameter at a time. Sometimes, you want to work with multiple parameters as a group, or you may not know how many parameters a function will ultimately take. In JavaScript, you can work with the arguments directly using the arguments variable that is visible inside every function body.\n\nIn TypeScript, you can gather these arguments together into a variable:\n\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n \n// employeeName will be \"Joseph Samuel Lucas MacKinzie\"\nlet employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\");\nTry\n\nRest parameters are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (...), allowing you to use it in your function.\n\nThe ellipsis is also used in the type of the function with rest parameters:\n\nfunction buildName(firstName: string, ...restOfName: string[]) {\n  return firstName + \" \" + restOfName.join(\" \");\n}\n \nlet buildNameFun: (fname: string, ...rest: string[]) => string = buildName;\nTry\nthis\n\nLearning how to use this in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use this and how to spot when it’s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of this with a couple of techniques. If you need to learn how this works in JavaScript, though, first read Yehuda Katz’s Understanding JavaScript Function Invocation and “this”. Yehuda’s article explains the inner workings of this very well, so we’ll just cover the basics here.\n\nthis\n and arrow functions\n\nIn JavaScript, this is a variable that’s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.\n\nLet’s look at an example:\n\nlet deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  createCardPicker: function () {\n    return function () {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n \n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  },\n};\n \nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n \nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\nTry\n\nNotice that createCardPicker is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the this being used in the function created by createCardPicker will be set to window instead of our deck object. That’s because we call cardPicker() on its own. A top-level non-method syntax call like this will use window for this. (Note: under strict mode, this will be undefined rather than window).\n\nWe can fix this by making sure the function is bound to the correct this before we return the function to be used later. This way, regardless of how it’s later used, it will still be able to see the original deck object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the this where the function is created rather than where it is invoked:\n\nlet deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  createCardPicker: function () {\n    // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n \n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  },\n};\n \nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n \nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\nTry\n\nEven better, TypeScript will warn you when you make this mistake if you pass the noImplicitThis flag to the compiler. It will point out that this in this.suits[pickedSuit] is of type any.\n\nthis\n parameters\n\nUnfortunately, the type of this.suits[pickedSuit] is still any. That’s because this comes from the function expression inside the object literal. To fix this, you can provide an explicit this parameter. this parameters are fake parameters that come first in the parameter list of a function:\n\nfunction f(this: void) {\n  // make sure `this` is unusable in this standalone function\n}\n\nLet’s add a couple of interfaces to our example above, Card and Deck, to make the types clearer and easier to reuse:\n\ninterface Card {\n  suit: string;\n  card: number;\n}\n \ninterface Deck {\n  suits: string[];\n  cards: number[];\n  createCardPicker(this: Deck): () => Card;\n}\n \nlet deck: Deck = {\n  suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],\n  cards: Array(52),\n  // NOTE: The function now explicitly specifies that its callee must be of type Deck\n  createCardPicker: function (this: Deck) {\n    return () => {\n      let pickedCard = Math.floor(Math.random() * 52);\n      let pickedSuit = Math.floor(pickedCard / 13);\n \n      return { suit: this.suits[pickedSuit], card: pickedCard % 13 };\n    };\n  },\n};\n \nlet cardPicker = deck.createCardPicker();\nlet pickedCard = cardPicker();\n \nalert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);\nTry\n\nNow TypeScript knows that createCardPicker expects to be called on a Deck object. That means that this is of type Deck now, not any, so noImplicitThis will not cause any errors.\n\nthis parameters in callbacks\n\nYou can also run into errors with this in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, this will be undefined. With some work you can use this parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with this:\n\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void;\n}\nTry\n\nthis: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this:\n\nclass Handler {\n  info: string;\n  onClickBad(this: Handler, e: Event) {\n    // oops, used `this` here. using this callback would crash at runtime\n    this.info = e.message;\n  }\n}\n \nlet h = new Handler();\nuiElement.addClickListener(h.onClickBad); // error!\nArgument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.\n  The 'this' types of each signature are incompatible.\n    Type 'void' is not assignable to type 'Handler'.\nArgument of type '(this: Handler, e: Event) => void' is not assignable to parameter of type '(this: void, e: Event) => void'.\n  The 'this' types of each signature are incompatible.\n    Type 'void' is not assignable to type 'Handler'.\nTry\n\nWith this annotated, you make it explicit that onClickBad must be called on an instance of Handler. Then TypeScript will detect that addClickListener requires a function that has this: void. To fix the error, change the type of this:\n\nclass Handler {\n  info: string;\n  onClickGood(this: void, e: Event) {\n    // can't use `this` here because it's of type void!\n    console.log(\"clicked!\");\n  }\n}\n \nlet h = new Handler();\nuiElement.addClickListener(h.onClickGood);\nTry\n\nBecause onClickGood specifies its this type as void, it is legal to pass to addClickListener. Of course, this also means that it can’t use this.info. If you want both then you’ll have to use an arrow function:\n\nclass Handler {\n  info: string;\n  onClickGood = (e: Event) => {\n    this.info = e.message;\n  };\n}\nTry\n\nThis works because arrow functions use the outer this, so you can always pass them to something that expects this: void. The downside is that one arrow function is created per object of type Handler. Methods, on the other hand, are only created once and attached to Handler’s prototype. They are shared between all objects of type Handler.\n\nOverloads\n\nJavaScript is inherently a very dynamic language. It’s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.\n\nlet suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\n \nfunction pickCard(x: any): any {\n  // Check to see if we're working with an object/array\n  // if so, they gave us the deck and we'll pick the card\n  if (typeof x == \"object\") {\n    let pickedCard = Math.floor(Math.random() * x.length);\n    return pickedCard;\n  }\n  // Otherwise just let them pick the card\n  else if (typeof x == \"number\") {\n    let pickedSuit = Math.floor(x / 13);\n    return { suit: suits[pickedSuit], card: x % 13 };\n  }\n}\n \nlet myDeck = [\n  { suit: \"diamonds\", card: 2 },\n  { suit: \"spades\", card: 10 },\n  { suit: \"hearts\", card: 4 },\n];\n \nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\n \nlet pickedCard2 = pickCard(15);\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\nTry\n\nHere, the pickCard function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they’ve picked. But how do we describe this to the type system?\n\nThe answer is to supply multiple function types for the same function as a list of overloads. This list is what the compiler will use to resolve function calls. Let’s create a list of overloads that describe what our pickCard accepts and what it returns.\n\nlet suits = [\"hearts\", \"spades\", \"clubs\", \"diamonds\"];\n \nfunction pickCard(x: { suit: string; card: number }[]): number;\nfunction pickCard(x: number): { suit: string; card: number };\nfunction pickCard(x: any): any {\n  // Check to see if we're working with an object/array\n  // if so, they gave us the deck and we'll pick the card\n  if (typeof x == \"object\") {\n    let pickedCard = Math.floor(Math.random() * x.length);\n    return pickedCard;\n  }\n  // Otherwise just let them pick the card\n  else if (typeof x == \"number\") {\n    let pickedSuit = Math.floor(x / 13);\n    return { suit: suits[pickedSuit], card: x % 13 };\n  }\n}\n \nlet myDeck = [\n  { suit: \"diamonds\", card: 2 },\n  { suit: \"spades\", card: 10 },\n  { suit: \"hearts\", card: 4 },\n];\n \nlet pickedCard1 = myDeck[pickCard(myDeck)];\nalert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);\n \nlet pickedCard2 = pickCard(15);\nalert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit);\nTry\n\nWith this change, the overloads now give us type checked calls to the pickCard function.\n\nIn order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it’s customary to order overloads from most specific to least specific.\n\nNote that the function pickCard(x): any piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling pickCard with any other parameter types would cause an error.\n\nOn this page\nFunctions\nFunction Types\nTyping the function\nWriting the function type\nInferring the types\nOptional and Default Parameters\nRest Parameters\nthis\nthis and arrow functions\nthis parameters\nOverloads\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nRC\nDR\nOT\nNS\nMF\n24+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.87 seconds."
  },
  {
    "title": "TypeScript: Documentation - Nightly Builds",
    "url": "https://www.typescriptlang.org/docs/handbook/nightly-builds.html",
    "html": "Nightly Builds\n\nA nightly build from the TypeScript’s main branch is published by midnight PST to npm. Here is how you can get it and use it with your tools.\n\nUsing npm\nnpm install -D typescript@next\nUpdating your IDE to use the nightly builds\n\nYou can also update your editor/IDE to use the nightly drop. You will typically need to install the package through npm. The rest of this section mostly assumes typescript@next is already installed.\n\nVisual Studio Code\n\nThe VS Code website has documentation on selecting a workspace version of TypeScript. After installing a nightly version of TypeScript in your workspace, you can follow directions there, or simply update your workspace settings in the JSON view. A direct way to do this is to open or create your workspace’s .vscode/settings.json and add the following property:\n\n\"typescript.tsdk\": \"<path to your folder>/node_modules/typescript/lib\"\n\nAlternatively, if you simply want to run the nightly editing experience for JavaScript and TypeScript in Visual Studio Code without changing your workspace version, you can run the JavaScript and TypeScript Nightly Extension\n\nSublime Text\n\nUpdate the Settings - User file with the following:\n\n\"typescript_tsdk\": \"<path to your folder>/node_modules/typescript/lib\"\n\nMore information is available at the TypeScript Plugin for Sublime Text installation documentation.\n\nVisual Studio 2013 and 2015\n\nNote: Most changes do not require you to install a new version of the VS TypeScript plugin.\n\nThe nightly build currently does not include the full plugin setup, but we are working on publishing an installer on a nightly basis as well.\n\nDownload the VSDevMode.ps1 script.\n\nAlso see our wiki page on using a custom language service file.\n\nFrom a PowerShell command window, run:\n\nFor VS 2015:\n\nVSDevMode.ps1 14 -tsScript <path to your folder>/node_modules/typescript/lib\n\nFor VS 2013:\n\nVSDevMode.ps1 12 -tsScript <path to your folder>/node_modules/typescript/lib\nIntelliJ IDEA (Mac)\n\nGo to Preferences > Languages & Frameworks > TypeScript:\n\nTypeScript Version: If you installed with npm: /usr/local/lib/node_modules/typescript/lib\n\nIntelliJ IDEA (Windows)\n\nGo to File > Settings > Languages & Frameworks > TypeScript:\n\nTypeScript Version: If you installed with npm: C:\\Users\\USERNAME\\AppData\\Roaming\\npm\\node_modules\\typescript\\lib\n\nOn this page\nUsing npm\nUpdating your IDE to use the nightly builds\nVisual Studio Code\nSublime Text\nVisual Studio 2013 and 2015\nIntelliJ IDEA (Mac)\nIntelliJ IDEA (Windows)\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nS\nDR\nNS\n4+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.377 seconds."
  },
  {
    "title": "TypeScript: Documentation - Integrating with Build Tools",
    "url": "https://www.typescriptlang.org/docs/handbook/integrating-with-build-tools.html",
    "html": "Integrating with Build Tools\nBabel\nInstall\nnpm install @babel/cli @babel/core @babel/preset-typescript --save-dev\n.babelrc\n{\n  \"presets\": [\"@babel/preset-typescript\"]\n}\nUsing Command Line Interface\n./node_modules/.bin/babel --out-file bundle.js src/index.ts\npackage.json\n{\n  \"scripts\": {\n    \"build\": \"babel --out-file bundle.js main.ts\"\n  },\n}\nExecute Babel from the command line\nnpm run build\nBrowserify\nInstall\nnpm install tsify\nUsing Command Line Interface\nbrowserify main.ts -p [ tsify --noImplicitAny ] > bundle.js\nUsing API\nvar browserify = require(\"browserify\");\nvar tsify = require(\"tsify\");\nbrowserify()\n  .add(\"main.ts\")\n  .plugin(\"tsify\", { noImplicitAny: true })\n  .bundle()\n  .pipe(process.stdout);\n\nMore details: smrq/tsify\n\nGrunt\nUsing \ngrunt-ts\n (no longer maintained)\nInstall\nnpm install grunt-ts --save-dev\nBasic Gruntfile.js\nmodule.exports = function (grunt) {\n  grunt.initConfig({\n    ts: {\n      default: {\n        src: [\"**/*.ts\", \"!node_modules/**/*.ts\"],\n      },\n    },\n  });\n  grunt.loadNpmTasks(\"grunt-ts\");\n  grunt.registerTask(\"default\", [\"ts\"]);\n};\n\nMore details: TypeStrong/grunt-ts\n\nUsing \ngrunt-browserify\n combined with \ntsify\nInstall\nnpm install grunt-browserify tsify --save-dev\nBasic Gruntfile.js\nmodule.exports = function (grunt) {\n  grunt.initConfig({\n    browserify: {\n      all: {\n        src: \"src/main.ts\",\n        dest: \"dist/main.js\",\n        options: {\n          plugin: [\"tsify\"],\n        },\n      },\n    },\n  });\n  grunt.loadNpmTasks(\"grunt-browserify\");\n  grunt.registerTask(\"default\", [\"browserify\"]);\n};\n\nMore details: jmreidy/grunt-browserify, TypeStrong/tsify\n\nGulp\nInstall\nnpm install gulp-typescript\nBasic gulpfile.js\nvar gulp = require(\"gulp\");\nvar ts = require(\"gulp-typescript\");\ngulp.task(\"default\", function () {\n  var tsResult = gulp.src(\"src/*.ts\").pipe(\n    ts({\n      noImplicitAny: true,\n      out: \"output.js\",\n    })\n  );\n  return tsResult.js.pipe(gulp.dest(\"built/local\"));\n});\n\nMore details: ivogabe/gulp-typescript\n\nJspm\nInstall\nnpm install -g jspm@beta\n\nNote: Currently TypeScript support in jspm is in 0.16beta\n\nMore details: TypeScriptSamples/jspm\n\nMSBuild\n\nUpdate project file to include locally installed Microsoft.TypeScript.Default.props (at the top) and Microsoft.TypeScript.targets (at the bottom) files:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"4.0\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <!-- Include default props at the top -->\n  <Import\n      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props\"\n      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.Default.props')\" />\n  <!-- TypeScript configurations go here -->\n  <PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">\n    <TypeScriptRemoveComments>false</TypeScriptRemoveComments>\n    <TypeScriptSourceMap>true</TypeScriptSourceMap>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">\n    <TypeScriptRemoveComments>true</TypeScriptRemoveComments>\n    <TypeScriptSourceMap>false</TypeScriptSourceMap>\n  </PropertyGroup>\n  <!-- Include default targets at the bottom -->\n  <Import\n      Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\n      Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />\n</Project>\n\nMore details about defining MSBuild compiler options: Setting Compiler Options in MSBuild projects\n\nNuGet\nRight-Click -> Manage NuGet Packages\nSearch for Microsoft.TypeScript.MSBuild\nHit Install\nWhen install is complete, rebuild!\n\nMore details can be found at Package Manager Dialog and using nightly builds with NuGet\n\nRollup\nInstall\nnpm install @rollup/plugin-typescript --save-dev\n\nNote that both typescript and tslib are peer dependencies of this plugin that need to be installed separately.\n\nUsage\n\nCreate a rollup.config.js configuration file and import the plugin:\n\n// rollup.config.js\nimport typescript from '@rollup/plugin-typescript';\nexport default {\n  input: 'src/index.ts',\n  output: {\n    dir: 'output',\n    format: 'cjs'\n  },\n  plugins: [typescript()]\n};\nSvelte Compiler\nInstall\nnpm install --save-dev svelte-preprocess\n\nNote that typescript is an optional peer dependencies of this plugin and needs to be installed separately. tslib is not provided either.\n\nYou may also consider svelte-check for CLI type checking.\n\nUsage\n\nCreate a svelte.config.js configuration file and import the plugin:\n\n// svelte.config.js\nimport preprocess from 'svelte-preprocess';\nconst config = {\n  // Consult https://github.com/sveltejs/svelte-preprocess\n  // for more information about preprocessors\n  preprocess: preprocess()\n};\nexport default config;\n\nYou can now specify that script blocks are written in TypeScript:\n\n<script lang=\"ts\">\nVite\n\nVite supports importing .ts files out-of-the-box. It only performs transpilation and not type checking. It also requires that some compilerOptions have certain values. See the Vite docs for more details.\n\nWebpack\nInstall\nnpm install ts-loader --save-dev\nBasic webpack.config.js when using Webpack 5 or 4\nconst path = require('path');\nmodule.exports = {\n  entry: './src/index.ts',\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n  },\n  output: {\n    filename: 'bundle.js',\n    path: path.resolve(__dirname, 'dist'),\n  },\n};\n\nSee more details on ts-loader here.\n\nAlternatives:\n\nawesome-typescript-loader\nOn this page\nBabel\nInstall\n.babelrc\nUsing Command Line Interface\npackage.json\nExecute Babel from the command line\nBrowserify\nInstall\nUsing Command Line Interface\nUsing API\nGrunt\nUsing grunt-ts (no longer maintained)\nUsing grunt-browserify combined with tsify\nGulp\nInstall\nBasic gulpfile.js\nJspm\nInstall\nMSBuild\nNuGet\nRollup\nInstall\nUsage\nSvelte Compiler\nInstall\nUsage\nVite\nWebpack\nInstall\nBasic webpack.config.js when using Webpack 5 or 4\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nMDB\nRC\nDR\n15+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.904 seconds."
  },
  {
    "title": "TypeScript: Documentation - Configuring Watch",
    "url": "https://www.typescriptlang.org/docs/handbook/configuring-watch.html",
    "html": "Configuring Watch\n\nAs of TypeScript 3.8 and onward, the Typescript compiler exposes configuration which controls how it watches files and directories. Prior to this version, configuration required the use of environment variables which are still available.\n\nBackground\n\nThe --watch implementation of the compiler relies on Node’s fs.watch and fs.watchFile. Each of these methods has pros and cons.\n\nfs.watch relies on file system events to broadcast changes in the watched files and directories. The implementation of this command is OS dependent and unreliable - on many operating systems, it does not work as expected. Additionally, some operating systems limit the number of watches which can exist simultaneously (e.g. some flavors of Linux). Heavy use of fs.watch in large codebases has the potential to exceed these limits and result in undesirable behavior. However, because this implementation relies on an events-based model, CPU use is comparatively light. The compiler typically uses fs.watch to watch directories (e.g. source directories included by compiler configuration files and directories in which module resolution failed, among others). TypeScript uses these to augment potential failures in individual file watchers. However, there is a key limitation of this strategy: recursive watching of directories is supported on Windows and macOS, but not on Linux. This suggested a need for additional strategies for file and directory watching.\n\nfs.watchFile uses polling and thus costs CPU cycles. However, fs.watchFile is by far the most reliable mechanism available to subscribe to the events from files and directories of interest. Under this strategy, the TypeScript compiler typically uses fs.watchFile to watch source files, config files, and files which appear missing based on reference statements. This means that the degree to which CPU usage will be higher when using fs.watchFile depends directly on number of files watched in the codebase.\n\nConfiguring file watching using a \ntsconfig.json\n\nThe suggested method of configuring watch behavior is through the new watchOptions section of tsconfig.json. We provide an example configuration below. See the following section for detailed descriptions of the settings available.\n\n{\n  // Some typical compiler options\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"moduleResolution\": \"node\"\n    // ...\n  },\n  // NEW: Options for file/directory watching\n  \"watchOptions\": {\n    // Use native file system events for files and directories\n    \"watchFile\": \"useFsEvents\",\n    \"watchDirectory\": \"useFsEvents\",\n    // Poll files for updates more frequently\n    // when they're updated a lot.\n    \"fallbackPolling\": \"dynamicPriority\",\n    // Don't coalesce watch notification\n    \"synchronousWatchDirectory\": true,\n    // Finally, two additional settings for reducing the amount of possible\n    // files to track  work from these directories\n    \"excludeDirectories\": [\"**/node_modules\", \"_build\"],\n    \"excludeFiles\": [\"build/fileWhichChangesOften.ts\"]\n  }\n}\n\nFor further details, see the release notes for Typescript 3.8.\n\nConfiguring file watching using environment variable \nTSC_WATCHFILE\nOption\tDescription\nPriorityPollingInterval\tUse fs.watchFile, but use different polling intervals for source files, config files and missing files\nDynamicPriorityPolling\tUse a dynamic queue where frequently modified files are polled at shorter intervals, and unchanged files are polled less frequently\nUseFsEvents\tUse fs.watch. On operating systems that limit the number of active watches, fall back to fs.watchFile when a watcher fails to be created.\nUseFsEventsWithFallbackDynamicPolling\tUse fs.watch. On operating systems that limit the number of active watches, fall back to dynamic polling queues (as explained in DynamicPriorityPolling)\nUseFsEventsOnParentDirectory\tUse fs.watch on the parent directories of included files (yielding a compromise that results in lower CPU usage than pure fs.watchFile but potentially lower accuracy).\ndefault (no value specified)\tIf environment variable TSC_NONPOLLING_WATCHER is set to true, use UseFsEventsOnParentDirectory. Otherwise, watch files using fs.watchFile with 250ms as the timeout for any file.\nConfiguring directory watching using environment variable \nTSC_WATCHDIRECTORY\n\nFor directory watches on platforms which don’t natively allow recursive directory watching (i.e. non macOS and Windows operating systems) is supported through recursively creating directory watchers for each child directory using different options selected by TSC_WATCHDIRECTORY.\n\nNOTE: On platforms which support native recursive directory watching, the value of TSC_WATCHDIRECTORY is ignored.\n\nOption\tDescription\nRecursiveDirectoryUsingFsWatchFile\tUse fs.watchFile to watch included directories and child directories.\nRecursiveDirectoryUsingDynamicPriorityPolling\tUse a dynamic polling queue to poll changes to included directories and child directories.\ndefault (no value specified)\tUse fs.watch to watch included directories and child directories.\nOn this page\nBackground\nConfiguring file watching using a tsconfig.json\nConfiguring file watching using environment variable TSC_WATCHFILE\nConfiguring directory watching using environment variable TSC_WATCHDIRECTORY\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nSN\nOT\nBS\nJM\nIO\n8+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.537 seconds."
  },
  {
    "title": "TypeScript: Documentation - tsc CLI Options",
    "url": "https://www.typescriptlang.org/docs/handbook/compiler-options.html",
    "html": "tsc CLI Options\nUsing the CLI\n\nRunning tsc locally will compile the closest project defined by a tsconfig.json, or you can compile a set of TypeScript files by passing in a glob of files you want. When input files are specified on the command line, tsconfig.json files are ignored.\n\n# Run a compile based on a backwards look through the fs for a tsconfig.json\ntsc\n# Emit JS for just the index.ts with the compiler defaults\ntsc index.ts\n# Emit JS for any .ts files in the folder src, with the default settings\ntsc src/*.ts\n# Emit files referenced in with the compiler settings from tsconfig.production.json\ntsc --project tsconfig.production.json\n# Emit d.ts files for a js file with showing compiler options which are booleans\ntsc index.js --declaration --emitDeclarationOnly\n# Emit a single .js file from two files via compiler options which take string arguments\ntsc app.ts util.ts --target esnext --outfile index.js\nCompiler Options\n\nIf you’re looking for more information about the compiler options in a tsconfig, check out the TSConfig Reference\n\nCLI Commands\nFlag\tType\n--all\t\n\nboolean\n\n\n\n\nShow all compiler options.\n\n\n--generateTrace\t\n\nstring\n\n\n\n\nGenerates an event trace and a list of types.\n\n\n--help\t\n\nboolean\n\n\n\n\nGives local information for help on the CLI.\n\n\n--init\t\n\nboolean\n\n\n\n\nInitializes a TypeScript project and creates a tsconfig.json file.\n\n\n--listFilesOnly\t\n\nboolean\n\n\n\n\nPrint names of files that are part of the compilation and then stop processing.\n\n\n--locale\t\n\nstring\n\n\n\n\nSet the language of the messaging from TypeScript. This does not affect emit.\n\n\n--project\t\n\nstring\n\n\n\n\nCompile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'.\n\n\n--showConfig\t\n\nboolean\n\n\n\n\nPrint the final configuration instead of building.\n\n\n--version\t\n\nboolean\n\n\n\n\nPrint the compiler's version.\n\nBuild Options\nFlag\tType\n--build\t\n\nboolean\n\n\n\n\nBuild one or more projects and their dependencies, if out of date\n\n\n--clean\t\n\nboolean\n\n\n\n\nDelete the outputs of all projects.\n\n\n--dry\t\n\nboolean\n\n\n\n\nShow what would be built (or deleted, if specified with '--clean')\n\n\n--force\t\n\nboolean\n\n\n\n\nBuild all projects, including those that appear to be up to date.\n\n\n--verbose\t\n\nboolean\n\n\n\n\nEnable verbose logging.\n\nWatch Options\nFlag\tType\n--excludeDirectories\t\n\nlist\n\n\n\n\nRemove a list of directories from the watch process.\n\n\n--excludeFiles\t\n\nlist\n\n\n\n\nRemove a list of files from the watch mode's processing.\n\n\n--fallbackPolling\t\n\nfixedinterval, priorityinterval, dynamicpriority, or fixedchunksize\n\n\n\n\nSpecify what approach the watcher should use if the system runs out of native file watchers.\n\n\n--synchronousWatchDirectory\t\n\nboolean\n\n\n\n\nSynchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively.\n\n\n--watch\t\n\nboolean\n\n\n\n\nWatch input files.\n\n\n--watchDirectory\t\n\nusefsevents, fixedpollinginterval, dynamicprioritypolling, or fixedchunksizepolling\n\n\n\n\nSpecify how directories are watched on systems that lack recursive file-watching functionality.\n\n\n--watchFile\t\n\nfixedpollinginterval, prioritypollinginterval, dynamicprioritypolling, fixedchunksizepolling, usefsevents, or usefseventsonparentdirectory\n\n\n\n\nSpecify how the TypeScript watch mode works.\n\nCompiler Flags\nFlag\tType\tDefault\n--allowArbitraryExtensions\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable importing files with any extension, provided a declaration file is present.\n\n\n--allowImportingTsExtensions\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nAllow imports to include TypeScript file extensions.\n\n\n--allowJs\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nAllow JavaScript files to be a part of your program. Use the checkJS option to get errors from these files.\n\n\n--allowSyntheticDefaultImports\t\n\nboolean\n\n\t\n\ntrue if esModuleInterop is enabled, module is system, or moduleResolution is bundler; false otherwise.\n\n\n\n\nAllow 'import x from y' when a module doesn't have a default export.\n\n\n--allowUmdGlobalAccess\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nAllow accessing UMD globals from modules.\n\n\n--allowUnreachableCode\t\n\nboolean\n\n\t\n\n\nDisable error reporting for unreachable code.\n\n\n--allowUnusedLabels\t\n\nboolean\n\n\t\n\n\nDisable error reporting for unused labels.\n\n\n--alwaysStrict\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nEnsure 'use strict' is always emitted.\n\n\n--assumeChangesOnlyAffectDirectDependencies\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nHave recompiles in projects that use incremental and watch mode assume that changes within a file will only affect files directly depending on it.\n\n\n--baseUrl\t\n\nstring\n\n\t\n\n\nSpecify the base directory to resolve bare specifier module names.\n\n\n--charset\t\n\nstring\n\n\t\n\nutf8\n\n\n\n\nNo longer supported. In early versions, manually set the text encoding for reading files.\n\n\n--checkJs\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable error reporting in type-checked JavaScript files.\n\n\n--composite\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable constraints that allow a TypeScript project to be used with project references.\n\n\n--customConditions\t\n\nlist\n\n\t\n\n\nConditions to set in addition to the resolver-specific defaults when resolving imports.\n\n\n--declaration\t\n\nboolean\n\n\t\n\ntrue if composite; false otherwise.\n\n\n\n\nGenerate .d.ts files from TypeScript and JavaScript files in your project.\n\n\n--declarationDir\t\n\nstring\n\n\t\n\n\nSpecify the output directory for generated declaration files.\n\n\n--declarationMap\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nCreate sourcemaps for d.ts files.\n\n\n--diagnostics\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nOutput compiler performance information after building.\n\n\n--disableReferencedProjectLoad\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nReduce the number of projects loaded automatically by TypeScript.\n\n\n--disableSizeLimit\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nRemove the 20mb cap on total source code size for JavaScript files in the TypeScript language server.\n\n\n--disableSolutionSearching\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nOpt a project out of multi-project reference checking when editing.\n\n\n--disableSourceOfProjectReferenceRedirect\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable preferring source files instead of declaration files when referencing composite projects.\n\n\n--downlevelIteration\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEmit more compliant, but verbose and less performant JavaScript for iteration.\n\n\n--emitBOM\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEmit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.\n\n\n--emitDeclarationOnly\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nOnly output d.ts files and not JavaScript files.\n\n\n--emitDecoratorMetadata\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEmit design-type metadata for decorated declarations in source files.\n\n\n--esModuleInterop\t\n\nboolean\n\n\t\n\ntrue if module is node16 or nodenext; false otherwise.\n\n\n\n\nEmit additional JavaScript to ease support for importing CommonJS modules. This enables allowSyntheticDefaultImports for type compatibility.\n\n\n--exactOptionalPropertyTypes\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nInterpret optional property types as written, rather than adding undefined.\n\n\n--experimentalDecorators\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable experimental support for TC39 stage 2 draft decorators.\n\n\n--explainFiles\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nPrint files read during the compilation including why it was included.\n\n\n--extendedDiagnostics\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nOutput more detailed compiler performance information after building.\n\n\n--forceConsistentCasingInFileNames\t\n\nboolean\n\n\t\n\ntrue\n\n\n\n\nEnsure that casing is correct in imports.\n\n\n--generateCpuProfile\t\n\nstring\n\n\t\n\nprofile.cpuprofile\n\n\n\n\nEmit a v8 CPU profile of the compiler run for debugging.\n\n\n--importHelpers\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nAllow importing helper functions from tslib once per project, instead of including them per-file.\n\n\n--importsNotUsedAsValues\t\n\nremove, preserve, or error\n\n\t\n\nremove\n\n\n\n\nSpecify emit/checking behavior for imports that are only used for types.\n\n\n--incremental\t\n\nboolean\n\n\t\n\ntrue if composite; false otherwise.\n\n\n\n\nSave .tsbuildinfo files to allow for incremental compilation of projects.\n\n\n--inlineSourceMap\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nInclude sourcemap files inside the emitted JavaScript.\n\n\n--inlineSources\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nInclude source code in the sourcemaps inside the emitted JavaScript.\n\n\n--isolatedModules\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnsure that each file can be safely transpiled without relying on other imports.\n\n\n--jsx\t\n\npreserve, react, react-native, react-jsx, or react-jsxdev\n\n\t\n\n\nSpecify what JSX code is generated.\n\n\n--jsxFactory\t\n\nstring\n\n\t\n\nReact.createElement\n\n\n\n\nSpecify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'.\n\n\n--jsxFragmentFactory\t\n\nstring\n\n\t\n\nReact.Fragment\n\n\n\n\nSpecify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'.\n\n\n--jsxImportSource\t\n\nstring\n\n\t\n\nreact\n\n\n\n\nSpecify module specifier used to import the JSX factory functions when using jsx: react-jsx*.\n\n\n--keyofStringsOnly\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nMake keyof only return strings instead of string, numbers or symbols. Legacy option.\n\n\n--lib\t\n\nlist\n\n\t\n\n\nSpecify a set of bundled library declaration files that describe the target runtime environment.\n\n\n--listEmittedFiles\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nPrint the names of emitted files after a compilation.\n\n\n--listFiles\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nPrint all of the files read during the compilation.\n\n\n--mapRoot\t\n\nstring\n\n\t\n\n\nSpecify the location where debugger should locate map files instead of generated locations.\n\n\n--maxNodeModuleJsDepth\t\n\nnumber\n\n\t\n\n0\n\n\n\n\nSpecify the maximum folder depth used for checking JavaScript files from node_modules. Only applicable with allowJs.\n\n\n--module\t\n\nnone, commonjs, amd, umd, system, es6/es2015, es2020, es2022, esnext, node16, or nodenext\n\n\t\n\nCommonJS if target is ES3 or ES5; ES6/ES2015 otherwise.\n\n\n\n\nSpecify what module code is generated.\n\n\n--moduleDetection\t\n\nlegacy, auto, or force\n\n\t\n\n\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.\n\n\n\n\nSpecify what method is used to detect whether a file is a script or a module.\n\n\n--moduleResolution\t\n\nclassic, node10/node, node16, nodenext, or bundler\n\n\t\n\nClassic if module is AMD, UMD, System, or ES6/ES2015; Matches if module is node16 or nodenext; Node otherwise.\n\n\n\n\nSpecify how TypeScript looks up a file from a given module specifier.\n\n\n--moduleSuffixes\t\n\nlist\n\n\t\n\n\nList of file name suffixes to search when resolving a module.\n\n\n--newLine\t\n\ncrlf or lf\n\n\t\n\nPlatform specific.\n\n\n\n\nSet the newline character for emitting files.\n\n\n--noEmit\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable emitting files from a compilation.\n\n\n--noEmitHelpers\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable generating custom helper functions like __extends in compiled output.\n\n\n--noEmitOnError\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable emitting files if any type checking errors are reported.\n\n\n--noErrorTruncation\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable truncating types in error messages.\n\n\n--noFallthroughCasesInSwitch\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable error reporting for fallthrough cases in switch statements.\n\n\n--noImplicitAny\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nEnable error reporting for expressions and declarations with an implied any type.\n\n\n--noImplicitOverride\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnsure overriding members in derived classes are marked with an override modifier.\n\n\n--noImplicitReturns\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable error reporting for codepaths that do not explicitly return in a function.\n\n\n--noImplicitThis\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nEnable error reporting when this is given the type any.\n\n\n--noImplicitUseStrict\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable adding 'use strict' directives in emitted JavaScript files.\n\n\n--noLib\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable including any library files, including the default lib.d.ts.\n\n\n--noPropertyAccessFromIndexSignature\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnforces using indexed accessors for keys declared using an indexed type.\n\n\n--noResolve\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisallow imports, requires or <reference>s from expanding the number of files TypeScript should add to a project.\n\n\n--noStrictGenericChecks\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable strict checking of generic signatures in function types.\n\n\n--noUncheckedIndexedAccess\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nAdd undefined to a type when accessed using an index.\n\n\n--noUnusedLocals\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable error reporting when local variables aren't read.\n\n\n--noUnusedParameters\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nRaise an error when a function parameter isn't read.\n\n\n--out\t\n\nstring\n\n\t\n\n\nDeprecated setting. Use outFile instead.\n\n\n--outDir\t\n\nstring\n\n\t\n\n\nSpecify an output folder for all emitted files.\n\n\n--outFile\t\n\nstring\n\n\t\n\n\nSpecify a file that bundles all outputs into one JavaScript file. If declaration is true, also designates a file that bundles all .d.ts output.\n\n\n--paths\t\n\nobject\n\n\t\n\n\nSpecify a set of entries that re-map imports to additional lookup locations.\n\n\n--plugins\t\n\nlist\n\n\t\n\n\nSpecify a list of language service plugins to include.\n\n\n--preserveConstEnums\t\n\nboolean\n\n\t\n\ntrue if isolatedModules; false otherwise.\n\n\n\n\nDisable erasing const enum declarations in generated code.\n\n\n--preserveSymlinks\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable resolving symlinks to their realpath. This correlates to the same flag in node.\n\n\n--preserveValueImports\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nPreserve unused imported values in the JavaScript output that would otherwise be removed.\n\n\n--preserveWatchOutput\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable wiping the console in watch mode.\n\n\n--pretty\t\n\nboolean\n\n\t\n\ntrue\n\n\n\n\nEnable color and formatting in TypeScript's output to make compiler errors easier to read.\n\n\n--reactNamespace\t\n\nstring\n\n\t\n\nReact\n\n\n\n\nSpecify the object invoked for createElement. This only applies when targeting react JSX emit.\n\n\n--removeComments\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable emitting comments.\n\n\n--resolveJsonModule\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable importing .json files.\n\n\n--resolvePackageJsonExports\t\n\nboolean\n\n\t\n\ntrue when moduleResolution is node16, nodenext, or bundler; otherwise false\n\n\n\n\nUse the package.json 'exports' field when resolving package imports.\n\n\n--resolvePackageJsonImports\t\n\nboolean\n\n\t\n\ntrue when moduleResolution is node16, nodenext, or bundler; otherwise false\n\n\n\n\nUse the package.json 'imports' field when resolving imports.\n\n\n--rootDir\t\n\nstring\n\n\t\n\nComputed from the list of input files.\n\n\n\n\nSpecify the root folder within your source files.\n\n\n--rootDirs\t\n\nlist\n\n\t\n\nComputed from the list of input files.\n\n\n\n\nAllow multiple folders to be treated as one when resolving modules.\n\n\n--skipDefaultLibCheck\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nSkip type checking .d.ts files that are included with TypeScript.\n\n\n--skipLibCheck\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nSkip type checking all .d.ts files.\n\n\n--sourceMap\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nCreate source map files for emitted JavaScript files.\n\n\n--sourceRoot\t\n\nstring\n\n\t\n\n\nSpecify the root path for debuggers to find the reference source code.\n\n\n--strict\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nEnable all strict type-checking options.\n\n\n--strictBindCallApply\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nCheck that the arguments for bind, call, and apply methods match the original function.\n\n\n--strictFunctionTypes\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nWhen assigning functions, check to ensure parameters and the return values are subtype-compatible.\n\n\n--strictNullChecks\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nWhen type checking, take into account null and undefined.\n\n\n--strictPropertyInitialization\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nCheck for class properties that are declared but not set in the constructor.\n\n\n--stripInternal\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable emitting declarations that have @internal in their JSDoc comments.\n\n\n--suppressExcessPropertyErrors\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDisable reporting of excess property errors during the creation of object literals.\n\n\n--suppressImplicitAnyIndexErrors\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nSuppress noImplicitAny errors when indexing objects that lack index signatures.\n\n\n--target\t\n\nes3, es5, es6/es2015, es2016, es2017, es2018, es2019, es2020, es2021, es2022, or esnext\n\n\t\n\nES3\n\n\n\n\nSet the JavaScript language version for emitted JavaScript and include compatible library declarations.\n\n\n--traceResolution\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nLog paths used during the moduleResolution process.\n\n\n--tsBuildInfoFile\t\n\nstring\n\n\t\n\n.tsbuildinfo\n\n\n\n\nThe file to store .tsbuildinfo incremental build information in.\n\n\n--typeRoots\t\n\nlist\n\n\t\n\n\nSpecify multiple folders that act like ./node_modules/@types.\n\n\n--types\t\n\nlist\n\n\t\n\n\nSpecify type package names to be included without being referenced in a source file.\n\n\n--useDefineForClassFields\t\n\nboolean\n\n\t\n\ntrue if target is ES2022 or higher, including ESNext; false otherwise.\n\n\n\n\nEmit ECMAScript-standard-compliant class fields.\n\n\n--useUnknownInCatchVariables\t\n\nboolean\n\n\t\n\ntrue if strict; false otherwise.\n\n\n\n\nDefault catch clause variables as unknown instead of any.\n\n\n--verbatimModuleSyntax\t\n\nboolean\n\n\t\n\nfalse\n\n\n\n\nDo not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting.\n\nRelated\nEvery option is fully explained in the TSConfig Reference.\nLearn how to use a tsconfig.json file.\nLearn how to work in an MSBuild project.\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nDR\nAD\nAG\n60+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.553 seconds."
  },
  {
    "title": "TypeScript: Documentation - Project References",
    "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
    "html": "Project References\n\nProject references are a new feature in TypeScript 3.0 that allow you to structure your TypeScript programs into smaller pieces.\n\nBy doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.\n\nWe’re also introducing a new mode for tsc, the --build flag, that works hand in hand with project references to enable faster TypeScript builds.\n\nAn Example Project\n\nLet’s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, converter and units, and a corresponding test file for each:\n\n/\n├── src/\n│   ├── converter.ts\n│   └── units.ts\n├── test/\n│   ├── converter-tests.ts\n│   └── units-tests.ts\n└── tsconfig.json\n\nThe test files import the implementation files and do some testing:\n\n// converter-tests.ts\nimport * as converter from \"../src/converter\";\nassert.areEqual(converter.celsiusToFahrenheit(0), 32);\n\nPreviously, this structure was rather awkward to work with if you used a single tsconfig file:\n\nIt was possible for the implementation files to import the test files\nIt wasn’t possible to build test and src at the same time without having src appear in the output folder name, which you probably don’t want\nChanging just the internals in the implementation files required typechecking the tests again, even though this wouldn’t ever cause new errors\nChanging just the tests required typechecking the implementation again, even if nothing changed\n\nYou could use multiple tsconfig files to solve some of those problems, but new ones would appear:\n\nThere’s no built-in up-to-date checking, so you end up always running tsc twice\nInvoking tsc twice incurs more startup time overhead\ntsc -w can’t run on multiple config files at once\n\nProject references can solve all of these problems and more.\n\nWhat is a Project Reference?\n\ntsconfig.json files have a new top-level property, references. It’s an array of objects that specifies projects to reference:\n\n{\n    \"compilerOptions\": {\n        // The usual\n    },\n    \"references\": [\n        { \"path\": \"../src\" }\n    ]\n}\n\nThe path property of each reference can point to a directory containing a tsconfig.json file, or to the config file itself (which may have any name).\n\nWhen you reference a project, new things happen:\n\nImporting modules from a referenced project will instead load its output declaration file (.d.ts)\nIf the referenced project produces an outFile, the output file .d.ts file’s declarations will be visible in this project\nBuild mode (see below) will automatically build the referenced project if needed\n\nBy separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.\n\ncomposite\n\nReferenced projects must have the new composite setting enabled. This setting is needed to ensure TypeScript can quickly determine where to find the outputs of the referenced project. Enabling the composite flag changes a few things:\n\nThe rootDir setting, if not explicitly set, defaults to the directory containing the tsconfig file\nAll implementation files must be matched by an include pattern or listed in the files array. If this constraint is violated, tsc will inform you which files weren’t specified\ndeclaration must be turned on\ndeclarationMap\n\nWe’ve also added support for declaration source maps. If you enable declarationMap, you’ll be able to use editor features like “Go to Definition” and Rename to transparently navigate and edit code across project boundaries in supported editors.\n\nprepend\n with \noutFile\n\nYou can also enable prepending the output of a dependency using the prepend option in a reference:\n\n   \"references\": [\n       { \"path\": \"../utils\", \"prepend\": true }\n   ]\n\nPrepending a project will include the project’s output above the output of the current project. All output files (.js, .d.ts, .js.map, .d.ts.map) will be emitted correctly.\n\ntsc will only ever use existing files on disk to do this process, so it’s possible to create a project where a correct output file can’t be generated because some project’s output would be present more than once in the resulting file. For example:\n\n   A\n  ^ ^\n /   \\\nB     C\n ^   ^\n  \\ /\n   D\n\nIt’s important in this situation to not prepend at each reference, because you’ll end up with two copies of A in the output of D - this can lead to unexpected results.\n\nCaveats for Project References\n\nProject references have a few trade-offs you should be aware of.\n\nBecause dependent projects make use of .d.ts files that are built from their dependencies, you’ll either have to check in certain build outputs or build a project after cloning it before you can navigate the project in an editor without seeing spurious errors.\n\nWhen using VS Code (since TS 3.7) we have a behind-the-scenes in-memory .d.ts generation process that should be able to mitigate this, but it has some perf implications. For very large composite projects you might want to disable this using disableSourceOfProjectReferenceRedirect option.\n\nAdditionally, to preserve compatibility with existing build workflows, tsc will not automatically build dependencies unless invoked with the --build switch. Let’s learn more about --build.\n\nBuild Mode for TypeScript\n\nA long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the --build flag with tsc. This is effectively a new entry point for tsc that behaves more like a build orchestrator than a simple compiler.\n\nRunning tsc --build (tsc -b for short) will do the following:\n\nFind all referenced projects\nDetect if they are up-to-date\nBuild out-of-date projects in the correct order\n\nYou can provide tsc -b with multiple config file paths (e.g. tsc -b src test). Just like tsc -p, specifying the config file name itself is unnecessary if it’s named tsconfig.json.\n\ntsc -b\n Commandline\n\nYou can specify any number of config files:\n\n > tsc -b                            # Use the tsconfig.json in the current directory\n > tsc -b src                        # Use src/tsconfig.json\n > tsc -b foo/prd.tsconfig.json bar  # Use foo/prd.tsconfig.json and bar/tsconfig.json\n\nDon’t worry about ordering the files you pass on the commandline - tsc will re-order them if needed so that dependencies are always built first.\n\nThere are also some flags specific to tsc -b:\n\n--verbose: Prints out verbose logging to explain what’s going on (may be combined with any other flag)\n--dry: Shows what would be done but doesn’t actually build anything\n--clean: Deletes the outputs of the specified projects (may be combined with --dry)\n--force: Act as if all projects are out of date\n--watch: Watch mode (may not be combined with any flag except --verbose)\nCaveats\n\nNormally, tsc will produce outputs (.js and .d.ts) in the presence of syntax or type errors, unless noEmitOnError is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you’d only see it once because a subsequent build would skip building the now up-to-date project. For this reason, tsc -b effectively acts as if noEmitOnError is enabled for all projects.\n\nIf you check in any build outputs (.js, .d.ts, .d.ts.map, etc.), you may need to run a --force build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.\n\nMSBuild\n\nIf you have an msbuild project, you can enable build mode by adding\n\n    <TypeScriptBuildMode>true</TypeScriptBuildMode>\n\nto your proj file. This will enable automatic incremental build as well as cleaning.\n\nNote that as with tsconfig.json / -p, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.\n\nSome teams have set up msbuild-based workflows wherein tsconfig files have the same implicit graph ordering as the managed projects they are paired with. If your solution is like this, you can continue to use msbuild with tsc -p along with project references; these are fully interoperable.\n\nGuidance\nOverall Structure\n\nWith more tsconfig.json files, you’ll usually want to use Configuration file inheritance to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.\n\nAnother good practice is to have a “solution” tsconfig.json file that simply has references to all of your leaf-node projects and sets files to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty files array if you have at least one reference in a tsconfig.json file.\n\nThis presents a simple entry point; e.g. in the TypeScript repo we simply run tsc -b src to build all endpoints because we list all the subprojects in src/tsconfig.json\n\nYou can see these patterns in the TypeScript repo - see src/tsconfig_base.json, src/tsconfig.json, and src/tsc/tsconfig.json as key examples.\n\nStructuring for relative modules\n\nIn general, not much is needed to transition a repo using relative modules. Simply place a tsconfig.json file in each subdirectory of a given parent folder, and add references to these config files to match the intended layering of the program. You will need to either set the outDir to an explicit subfolder of the output folder, or set the rootDir to the common root of all project folders.\n\nStructuring for outFiles\n\nLayout for compilations using outFile is more flexible because relative paths don’t matter as much. One thing to keep in mind is that you’ll generally want to not use prepend until the “last” project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some “library” projects and some “endpoint” projects; “endpoint” projects are kept as small as possible and pull in only the libraries they need.\n\nOn this page\nAn Example Project\nWhat is a Project Reference?\ncomposite\ndeclarationMap\nprepend with outFile\nCaveats for Project References\nBuild Mode for TypeScript\ntsc -b Commandline\nCaveats\nMSBuild\nGuidance\nOverall Structure\nStructuring for relative modules\nStructuring for outFiles\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nRC\nG\nMF\n20+\n\nLast updated: Nov 27, 2023\n\n "
  },
  {
    "title": "TypeScript: Documentation - Compiler Options in MSBuild",
    "url": "https://www.typescriptlang.org/docs/handbook/compiler-options-in-msbuild.html",
    "html": "Compiler Options in MSBuild\nOverview\n\nWhen you have an MSBuild based project which utilizes TypeScript such as an ASP.NET Core project, you can configure TypeScript in two ways. Either via a tsconfig.json or via the project settings.\n\nUsing a \ntsconfig.json\n\nWe recommend using a tsconfig.json for your project when possible. To add one to an existing project, add a new item to your project which is called a “TypeScript JSON Configuration File” in modern versions of Visual Studio.\n\nThe new tsconfig.json will then be used as the source of truth for TypeScript-specific build information like files and configuration. You can learn about how TSConfigs works here and there is a comprehensive reference here.\n\nUsing Project Settings\n\nYou can also define the configuration for TypeScript inside you project’s settings. This is done by editing the XML in your .csproj to define PropertyGroups which describe how the build can work:\n\n<PropertyGroup>\n  <TypeScriptNoEmitOnError>true</TypeScriptNoEmitOnError>\n  <TypeScriptNoImplicitReturns>true</TypeScriptNoImplicitReturns>\n</PropertyGroup>\n\nThere is a series of mappings for common TypeScript settings, these are settings which map directly to TypeScript cli options and are used to help you write a more understandable project file. You can use the TSConfig reference to get more information on what values and defaults are for each mapping.\n\nCLI Mappings\nMSBuild Config Name\tTSC Flag\n<TypeScriptAllowJS>\t--allowJs\n\n\nAllow JavaScript files to be a part of your program. Use the checkJS option to get errors from these files.\n\n\n<TypeScriptRemoveComments>\t--removeComments\n\n\nDisable emitting comments.\n\n\n<TypeScriptNoImplicitAny>\t--noImplicitAny\n\n\nEnable error reporting for expressions and declarations with an implied any type..\n\n\n<TypeScriptGeneratesDeclarations>\t--declaration\n\n\nGenerate .d.ts files from TypeScript and JavaScript files in your project.\n\n\n<TypeScriptModuleKind>\t--module\n\n\nSpecify what module code is generated.\n\n\n<TypeScriptJSXEmit>\t--jsx\n\n\nSpecify what JSX code is generated.\n\n\n<TypeScriptOutDir>\t--outDir\n\n\nSpecify an output folder for all emitted files.\n\n\n<TypeScriptSourceMap>\t--sourcemap\n\n\nCreate source map files for emitted JavaScript files.\n\n\n<TypeScriptTarget>\t--target\n\n\nSet the JavaScript language version for emitted JavaScript and include compatible library declarations.\n\n\n<TypeScriptNoResolve>\t--noResolve\n\n\nDisallow imports, requires or <reference>s from expanding the number of files TypeScript should add to a project.\n\n\n<TypeScriptMapRoot>\t--mapRoot\n\n\nSpecify the location where debugger should locate map files instead of generated locations.\n\n\n<TypeScriptSourceRoot>\t--sourceRoot\n\n\nSpecify the root path for debuggers to find the reference source code.\n\n\n<TypeScriptCharset>\t--charset\n\n\nNo longer supported. In early versions, manually set the text encoding for reading files.\n\n\n<TypeScriptEmitBOM>\t--emitBOM\n\n\nEmit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.\n\n\n<TypeScriptNoLib>\t--noLib\n\n\nDisable including any library files, including the default lib.d.ts.\n\n\n<TypeScriptPreserveConstEnums>\t--preserveConstEnums\n\n\nDisable erasing const enum declarations in generated code.\n\n\n<TypeScriptSuppressImplicitAnyIndexErrors>\t--suppressImplicitAnyIndexErrors\n\n\nSuppress noImplicitAny errors when indexing objects that lack index signatures.\n\n\n<TypeScriptNoEmitHelpers>\t--noEmitHelpers\n\n\nDisable generating custom helper functions like __extends in compiled output.\n\n\n<TypeScriptInlineSourceMap>\t--inlineSourceMap\n\n\nInclude sourcemap files inside the emitted JavaScript.\n\n\n<TypeScriptInlineSources>\t--inlineSources\n\n\nInclude source code in the sourcemaps inside the emitted JavaScript.\n\n\n<TypeScriptNewLine>\t--newLine\n\n\nSet the newline character for emitting files.\n\n\n<TypeScriptIsolatedModules>\t--isolatedModules\n\n\nEnsure that each file can be safely transpiled without relying on other imports.\n\n\n<TypeScriptEmitDecoratorMetadata>\t--emitDecoratorMetadata\n\n\nEmit design-type metadata for decorated declarations in source files.\n\n\n<TypeScriptRootDir>\t--rootDir\n\n\nSpecify the root folder within your source files.\n\n\n<TypeScriptExperimentalDecorators>\t--experimentalDecorators\n\n\nEnable experimental support for TC39 stage 2 draft decorators.\n\n\n<TypeScriptModuleResolution>\t--moduleResolution\n\n\nSpecify how TypeScript looks up a file from a given module specifier.\n\n\n<TypeScriptSuppressExcessPropertyErrors>\t--suppressExcessPropertyErrors\n\n\nDisable reporting of excess property errors during the creation of object literals.\n\n\n<TypeScriptReactNamespace>\t--reactNamespace\n\n\nSpecify the object invoked for createElement. This only applies when targeting react JSX emit.\n\n\n<TypeScriptSkipDefaultLibCheck>\t--skipDefaultLibCheck\n\n\nSkip type checking .d.ts files that are included with TypeScript.\n\n\n<TypeScriptAllowUnusedLabels>\t--allowUnusedLabels\n\n\nDisable error reporting for unused labels.\n\n\n<TypeScriptNoImplicitReturns>\t--noImplicitReturns\n\n\nEnable error reporting for codepaths that do not explicitly return in a function.\n\n\n<TypeScriptNoFallthroughCasesInSwitch>\t--noFallthroughCasesInSwitch\n\n\nEnable error reporting for fallthrough cases in switch statements.\n\n\n<TypeScriptAllowUnreachableCode>\t--allowUnreachableCode\n\n\nDisable error reporting for unreachable code.\n\n\n<TypeScriptForceConsistentCasingInFileNames>\t--forceConsistentCasingInFileNames\n\n\nEnsure that casing is correct in imports.\n\n\n<TypeScriptAllowSyntheticDefaultImports>\t--allowSyntheticDefaultImports\n\n\nAllow 'import x from y' when a module doesn't have a default export.\n\n\n<TypeScriptNoImplicitUseStrict>\t--noImplicitUseStrict\n\n\nDisable adding 'use strict' directives in emitted JavaScript files.\n\n\n<TypeScriptLib>\t--lib\n\n\nSpecify a set of bundled library declaration files that describe the target runtime environment.\n\n\n<TypeScriptBaseUrl>\t--baseUrl\n\n\nSpecify the base directory to resolve bare specifier module names.\n\n\n<TypeScriptDeclarationDir>\t--declarationDir\n\n\nSpecify the output directory for generated declaration files.\n\n\n<TypeScriptNoImplicitThis>\t--noImplicitThis\n\n\nEnable error reporting when this is given the type any.\n\n\n<TypeScriptSkipLibCheck>\t--skipLibCheck\n\n\nSkip type checking all .d.ts files.\n\n\n<TypeScriptStrictNullChecks>\t--strictNullChecks\n\n\nWhen type checking, take into account null and undefined.\n\n\n<TypeScriptNoUnusedLocals>\t--noUnusedLocals\n\n\nEnable error reporting when a local variables aren't read.\n\n\n<TypeScriptNoUnusedParameters>\t--noUnusedParameters\n\n\nRaise an error when a function parameter isn't read\n\n\n<TypeScriptAlwaysStrict>\t--alwaysStrict\n\n\nEnsure 'use strict' is always emitted.\n\n\n<TypeScriptImportHelpers>\t--importHelpers\n\n\nAllow importing helper functions from tslib once per project, instead of including them per-file.\n\n\n<TypeScriptJSXFactory>\t--jsxFactory\n\n\nSpecify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'\n\n\n<TypeScriptStripInternal>\t--stripInternal\n\n\nDisable emitting declarations that have @internal in their JSDoc comments.\n\n\n<TypeScriptCheckJs>\t--checkJs\n\n\nEnable error reporting in type-checked JavaScript files.\n\n\n<TypeScriptDownlevelIteration>\t--downlevelIteration\n\n\nEmit more compliant, but verbose and less performant JavaScript for iteration.\n\n\n<TypeScriptStrict>\t--strict\n\n\nEnable all strict type checking options.\n\n\n<TypeScriptNoStrictGenericChecks>\t--noStrictGenericChecks\n\n\nDisable strict checking of generic signatures in function types.\n\n\n<TypeScriptPreserveSymlinks>\t--preserveSymlinks\n\n\nDisable resolving symlinks to their realpath. This correlates to the same flag in node.\n\n\n<TypeScriptStrictFunctionTypes>\t--strictFunctionTypes\n\n\nWhen assigning functions, check to ensure parameters and the return values are subtype-compatible.\n\n\n<TypeScriptStrictPropertyInitialization>\t--strictPropertyInitialization\n\n\nCheck for class properties that are declared but not set in the constructor.\n\n\n<TypeScriptESModuleInterop>\t--esModuleInterop\n\n\nEmit additional JavaScript to ease support for importing CommonJS modules. This enables allowSyntheticDefaultImports for type compatibility.\n\n\n<TypeScriptEmitDeclarationOnly>\t--emitDeclarationOnly\n\n\nOnly output d.ts files and not JavaScript files.\n\n\n<TypeScriptKeyofStringsOnly>\t--keyofStringsOnly\n\n\nMake keyof only return strings instead of string, numbers or symbols. Legacy option.\n\n\n<TypeScriptUseDefineForClassFields>\t--useDefineForClassFields\n\n\nEmit ECMAScript-standard-compliant class fields.\n\n\n<TypeScriptDeclarationMap>\t--declarationMap\n\n\nCreate sourcemaps for d.ts files.\n\n\n<TypeScriptResolveJsonModule>\t--resolveJsonModule\n\n\nEnable importing .json files\n\n\n<TypeScriptStrictBindCallApply>\t--strictBindCallApply\n\n\nCheck that the arguments for bind, call, and apply methods match the original function.\n\n\n<TypeScriptNoEmitOnError>\t--noEmitOnError\n\n\nDisable emitting files if any type checking errors are reported.\n\nAdditional Flags\n\nBecause the MSBuild system passes arguments directly to the TypeScript CLI, you can use the option TypeScriptAdditionalFlags to provide specific flags which don’t have a mapping above.\n\nFor example, this would turn on noPropertyAccessFromIndexSignature:\n\n<TypeScriptAdditionalFlags> $(TypeScriptAdditionalFlags) --noPropertyAccessFromIndexSignature</TypeScriptAdditionalFlags>\nDebug and Release Builds\n\nYou can use PropertyGroup conditions to define different sets of configurations. For example, a common task is stripping comments and sourcemaps in production. In this example, we define a debug and release property group which have different TypeScript configurations:\n\n<PropertyGroup Condition=\"'$(Configuration)' == 'Debug'\">\n  <TypeScriptRemoveComments>false</TypeScriptRemoveComments>\n  <TypeScriptSourceMap>true</TypeScriptSourceMap>\n</PropertyGroup>\n<PropertyGroup Condition=\"'$(Configuration)' == 'Release'\">\n  <TypeScriptRemoveComments>true</TypeScriptRemoveComments>\n  <TypeScriptSourceMap>false</TypeScriptSourceMap>\n</PropertyGroup>\n<Import\n    Project=\"$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets\"\n    Condition=\"Exists('$(MSBuildExtensionsPath32)\\Microsoft\\VisualStudio\\v$(VisualStudioVersion)\\TypeScript\\Microsoft.TypeScript.targets')\" />\nToolsVersion\n\nThe value of <TypeScriptToolsVersion>1.7</TypeScriptToolsVersion> property in the project file identifies the compiler version to use to build (1.7 in this example). This allows a project to build against the same versions of the compiler on different machines.\n\nIf TypeScriptToolsVersion is not specified, the latest compiler version installed on the machine will be used to build.\n\nUsers using newer versions of TS, will see a prompt to upgrade their project on first load.\n\nTypeScriptCompileBlocked\n\nIf you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set <TypeScriptCompileBlocked>true</TypeScriptCompileBlocked> in your project. This should give you all the editing support, but not the build when you hit F5.\n\nTypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)\n\nBy default, MSBuild will attempt to only run the TypeScript compiler when the project’s source files have been updated since the last compilation. However, if this behavior is causing issues, such as when TypeScript’s incremental option is enabled, set <TypeScriptEnableIncrementalMSBuild>false</TypeScriptEnableIncrementalMSBuild> to ensure the TypeScript compiler is invoked with every run of MSBuild.\n\nOn this page\nOverview\nUsing a tsconfig.json\nUsing Project Settings\nAdditional Flags\nDebug and Release Builds\nToolsVersion\nTypeScriptCompileBlocked\nTypeScriptEnableIncrementalMSBuild (TypeScript 4.2 Beta and later)\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nY\nDR\nBL\n13+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.384 seconds."
  },
  {
    "title": "TypeScript: Documentation - Creating .d.ts Files from .js files",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/dts-from-js.html",
    "html": "Creating .d.ts Files from .js files\n\nWith TypeScript 3.7, TypeScript added support for generating .d.ts files from JavaScript using JSDoc syntax.\n\nThis set up means you can own the editor experience of TypeScript-powered editors without porting your project to TypeScript, or having to maintain .d.ts files in your codebase. TypeScript supports most JSDoc tags, you can find the reference here.\n\nSetting up your Project to emit .d.ts files\n\nTo add creation of .d.ts files in your project, you will need to do up-to four steps:\n\nAdd TypeScript to your dev dependencies\nAdd a tsconfig.json to configure TypeScript\nRun the TypeScript compiler to generate the corresponding d.ts files for JS files\n(optional) Edit your package.json to reference the types\nAdding TypeScript\n\nYou can learn how to do this in our installation page.\n\nTSConfig\n\nThe TSConfig is a jsonc file which configures both your compiler flags, and declare where to find files. In this case, you will want a file like the following:\n\n{\n  // Change this to match your project\n  \"include\": [\"src/**/*\"],\n  \"compilerOptions\": {\n    // Tells TypeScript to read JS files, as\n    // normally they are ignored as source files\n    \"allowJs\": true,\n    // Generate d.ts files\n    \"declaration\": true,\n    // This compiler run should\n    // only output d.ts files\n    \"emitDeclarationOnly\": true,\n    // Types should go into this directory.\n    // Removing this would place the .d.ts files\n    // next to the .js files\n    \"outDir\": \"dist\",\n    // go to js file when using IDE functions like\n    // \"Go to Definition\" in VSCode\n    \"declarationMap\": true\n  }\n}\n\nYou can learn more about the options in the tsconfig reference. An alternative to using a TSConfig file is the CLI, this is the same behavior as a CLI command.\n\nnpx -p typescript tsc src/**/*.js --declaration --allowJs --emitDeclarationOnly --outDir types\nRun the compiler\n\nYou can learn how to do this in our installation page. You want to make sure these files are included in your package if you have the files in your project’s .gitignore.\n\nEditing the package.json\n\nTypeScript replicates the node resolution for modules in a package.json, with an additional step for finding .d.ts files. Roughly, the resolution will first check the optional types field, then the \"main\" field, and finally will try index.d.ts in the root.\n\nPackage.json\tLocation of default .d.ts\nNo “types” field\tchecks “main”, then index.d.ts\n“types”: “main.d.ts”\tmain.d.ts\n“types”: “./dist/main.js”\t./dist/main.d.ts\n\nIf absent, then “main” is used\n\nPackage.json\tLocation of default .d.ts\nNo “main” field\tindex.d.ts\n“main”:“index.js”\tindex.d.ts\n“main”:“./dist/index.js”\t./dist/index.d.ts\nTips\n\nIf you’d like to write tests for your .d.ts files, try tsd.\n\nOn this page\nSetting up your Project to emit .d.ts files\nAdding TypeScript\nTSConfig\nRun the compiler\nEditing the package.json\nTips\nIs this page helpful?\nYes\nNo\nPrevious\nJSDoc Reference\n\nWhat JSDoc does TypeScript-powered JavaScript support?\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nSG\nJB\nSW\nJS\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.542 seconds."
  },
  {
    "title": "TypeScript: Documentation - What is a tsconfig.json",
    "url": "https://www.typescriptlang.org/docs/handbook/tsconfig-json.html",
    "html": "What is a tsconfig.json\nOverview\n\nThe presence of a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project.\n\nJavaScript projects can use a jsconfig.json file instead, which acts almost the same but has some JavaScript-related compiler flags enabled by default.\n\nA project is compiled in one of the following ways:\n\nUsing \ntsconfig.json\n or \njsconfig.json\nBy invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.\nBy invoking tsc with no input files and a --project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file, or a path to a valid .json file containing the configurations.\n\nWhen input files are specified on the command line, tsconfig.json files are ignored.\n\nExamples\n\nExample tsconfig.json files:\n\nUsing the files property\n\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"noImplicitAny\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"sourceMap\": true\n  },\n  \"files\": [\n    \"core.ts\",\n    \"sys.ts\",\n    \"types.ts\",\n    \"scanner.ts\",\n    \"parser.ts\",\n    \"utilities.ts\",\n    \"binder.ts\",\n    \"checker.ts\",\n    \"emitter.ts\",\n    \"program.ts\",\n    \"commandLineParser.ts\",\n    \"tsc.ts\",\n    \"diagnosticInformationMap.generated.ts\"\n  ]\n}\n\nUsing the include and exclude properties\n\n{\n  \"compilerOptions\": {\n    \"module\": \"system\",\n    \"noImplicitAny\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"outFile\": \"../../built/local/tsc.js\",\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"**/*.spec.ts\"]\n}\nTSConfig Bases\n\nDepending on the JavaScript runtime environment which you intend to run your code in, there may be a base configuration which you can use at github.com/tsconfig/bases. These are tsconfig.json files which your project extends from which simplifies your tsconfig.json by handling the runtime support.\n\nFor example, if you were writing a project which uses Node.js version 12 and above, then you could use the npm module @tsconfig/node12:\n\n{\n  \"extends\": \"@tsconfig/node12/tsconfig.json\",\n  \"compilerOptions\": {\n    \"preserveConstEnums\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"**/*.spec.ts\"]\n}\n\nThis lets your tsconfig.json focus on the unique choices for your project, and not all of the runtime mechanics. There are a few tsconfig bases already, and we’re hoping the community can add more for different environments.\n\nDetails\n\nThe \"compilerOptions\" property can be omitted, in which case the compiler’s defaults are used. See our full list of supported Compiler Options.\n\nTSConfig Reference\n\nTo learn more about the hundreds of configuration options in the TSConfig Reference.\n\nSchema\n\nThe tsconfig.json Schema can be found at the JSON Schema Store.\n\nOn this page\nOverview\nUsing tsconfig.json or jsconfig.json\nExamples\nTSConfig Bases\nDetails\nTSConfig Reference\nSchema\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nJB\nL☺\nAG\nCB\n3+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.504 seconds."
  },
  {
    "title": "TypeScript: Documentation - JSDoc Reference",
    "url": "https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html",
    "html": "JSDoc Reference\n\nThe list below outlines which constructs are currently supported when using JSDoc annotations to provide type information in JavaScript files.\n\nNote any tags which are not explicitly listed below (such as @async) are not yet supported.\n\nTypes\n@type\n@param (or @arg or @argument)\n@returns (or @return)\n@typedef\n@callback\n@template\n@satisfies\nClasses\nProperty Modifiers @public, @private, @protected, @readonly\n@override\n@extends (or @augments)\n@implements\n@class (or @constructor)\n@this\nDocumentation\n\nDocumentation tags work in both TypeScript and JavaScript.\n\n@deprecated\n@see\n@link\nOther\n@enum\n@author\nOther supported patterns\nUnsupported patterns\nUnsupported tags\n\nThe meaning is usually the same, or a superset, of the meaning of the tag given at jsdoc.app. The code below describes the differences and gives some example usage of each tag.\n\nNote: You can use the playground to explore JSDoc support.\n\nTypes\n@type\n\nYou can reference types with the “@type” tag. The type can be:\n\nPrimitive, like string or number.\nDeclared in a TypeScript declaration, either global or imported.\nDeclared in a JSDoc @typedef tag.\n\nYou can use most JSDoc type syntax and any TypeScript syntax, from the most basic like string to the most advanced, like conditional types.\n\n/**\n * @type {string}\n */\nvar s;\n \n/** @type {Window} */\nvar win;\n \n/** @type {PromiseLike<string>} */\nvar promisedString;\n \n// You can specify an HTML Element with DOM properties\n/** @type {HTMLElement} */\nvar myElement = document.querySelector(selector);\nelement.dataset.myData = \"\";\nTry\n\n@type can specify a union type — for example, something can be either a string or a boolean.\n\n/**\n * @type {string | boolean}\n */\nvar sb;\nTry\n\nYou can specify array types using a variety of syntaxes:\n\n/** @type {number[]} */\nvar ns;\n/** @type {Array.<number>} */\nvar jsdoc;\n/** @type {Array<number>} */\nvar nas;\nTry\n\nYou can also specify object literal types. For example, an object with properties ‘a’ (string) and ‘b’ (number) uses the following syntax:\n\n/** @type {{ a: string, b: number }} */\nvar var9;\nTry\n\nYou can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or TypeScript syntax.\n\n/**\n * A map-like object that maps arbitrary `string` properties to `number`s.\n *\n * @type {Object.<string, number>}\n */\nvar stringToNumber;\n \n/** @type {Object.<number, object>} */\nvar arrayLike;\nTry\n\nThe preceding two types are equivalent to the TypeScript types { [x: string]: number } and { [x: number]: any }. The compiler understands both syntaxes.\n\nYou can specify function types using either TypeScript or Google Closure syntax:\n\n/** @type {function(string, boolean): number} Closure syntax */\nvar sbn;\n/** @type {(s: string, b: boolean) => number} TypeScript syntax */\nvar sbn2;\nTry\n\nOr you can just use the unspecified Function type:\n\n/** @type {Function} */\nvar fn7;\n/** @type {function} */\nvar fn6;\nTry\n\nOther types from Closure also work:\n\n/**\n * @type {*} - can be 'any' type\n */\nvar star;\n/**\n * @type {?} - unknown type (same as 'any')\n */\nvar question;\nTry\nCasts\n\nTypeScript borrows cast syntax from Google Closure. This lets you cast types to other types by adding a @type tag before any parenthesized expression.\n\n/**\n * @type {number | string}\n */\nvar numberOrString = Math.random() < 0.5 ? \"hello\" : 100;\nvar typeAssertedNumber = /** @type {number} */ (numberOrString);\nTry\n\nYou can even cast to const just like TypeScript:\n\nlet one = /** @type {const} */(1);\nTry\nImport types\n\nYou can import declarations from other files using import types. This syntax is TypeScript-specific and differs from the JSDoc standard:\n\n// @filename: types.d.ts\nexport type Pet = {\n  name: string,\n};\n \n// @filename: main.js\n/**\n * @param {import(\"./types\").Pet} p\n */\nfunction walk(p) {\n  console.log(`Walking ${p.name}...`);\n}\nTry\n\nimport types can be used in type alias declarations:\n\n/**\n * @typedef {import(\"./types\").Pet} Pet\n */\n \n/**\n * @type {Pet}\n */\nvar myPet;\nmyPet.name;\nTry\n\nimport types can be used to get the type of a value from a module if you don’t know the type, or if it has a large type that is annoying to type:\n\n/**\n * @type {typeof import(\"./accounts\").userAccount}\n */\nvar x = require(\"./accounts\").userAccount;\nTry\n@param\n and \n@returns\n\n@param uses the same type syntax as @type, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:\n\n// Parameters may be declared in a variety of syntactic forms\n/**\n * @param {string}  p1 - A string param.\n * @param {string=} p2 - An optional param (Google Closure syntax)\n * @param {string} [p3] - Another optional param (JSDoc syntax).\n * @param {string} [p4=\"test\"] - An optional param with a default value\n * @returns {string} This is the result\n */\nfunction stringsStringStrings(p1, p2, p3, p4) {\n  // TODO\n}\nTry\n\nLikewise, for the return type of a function:\n\n/**\n * @return {PromiseLike<string>}\n */\nfunction ps() {}\n \n/**\n * @returns {{ a: string, b: number }} - May use '@returns' as well as '@return'\n */\nfunction ab() {}\nTry\n@typedef\n, \n@callback\n, and \n@param\n\nYou can define complex types with @typedef. Similar syntax works with @param.\n\n/**\n * @typedef {Object} SpecialType - creates a new type named 'SpecialType'\n * @property {string} prop1 - a string property of SpecialType\n * @property {number} prop2 - a number property of SpecialType\n * @property {number=} prop3 - an optional number property of SpecialType\n * @prop {number} [prop4] - an optional number property of SpecialType\n * @prop {number} [prop5=42] - an optional number property of SpecialType with default\n */\n \n/** @type {SpecialType} */\nvar specialTypeObject;\nspecialTypeObject.prop3;\nTry\n\nYou can use either object or Object on the first line.\n\n/**\n * @typedef {object} SpecialType1 - creates a new type named 'SpecialType1'\n * @property {string} prop1 - a string property of SpecialType1\n * @property {number} prop2 - a number property of SpecialType1\n * @property {number=} prop3 - an optional number property of SpecialType1\n */\n \n/** @type {SpecialType1} */\nvar specialTypeObject1;\nTry\n\n@param allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:\n\n/**\n * @param {Object} options - The shape is the same as SpecialType above\n * @param {string} options.prop1\n * @param {number} options.prop2\n * @param {number=} options.prop3\n * @param {number} [options.prop4]\n * @param {number} [options.prop5=42]\n */\nfunction special(options) {\n  return (options.prop4 || 1001) + options.prop5;\n}\nTry\n\n@callback is similar to @typedef, but it specifies a function type instead of an object type:\n\n/**\n * @callback Predicate\n * @param {string} data\n * @param {number} [index]\n * @returns {boolean}\n */\n \n/** @type {Predicate} */\nconst ok = (s) => !(s.length % 2);\nTry\n\nOf course, any of these types can be declared using TypeScript syntax in a single-line @typedef:\n\n/** @typedef {{ prop1: string, prop2: string, prop3?: number }} SpecialType */\n/** @typedef {(data: string, index?: number) => boolean} Predicate */\n@template\n\nYou can declare type parameters with the @template tag. This lets you make functions, classes, or types that are generic:\n\n/**\n * @template T\n * @param {T} x - A generic parameter that flows through to the return type\n * @returns {T}\n */\nfunction id(x) {\n  return x;\n}\n \nconst a = id(\"string\");\nconst b = id(123);\nconst c = id({});\nTry\n\nUse comma or multiple tags to declare multiple type parameters:\n\n/**\n * @template T,U,V\n * @template W,X\n */\n\nYou can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:\n\n/**\n * @template {string} K - K must be a string or string literal\n * @template {{ serious(): string }} Seriousalizable - must have a serious method\n * @param {K} key\n * @param {Seriousalizable} object\n */\nfunction seriousalize(key, object) {\n  // ????\n}\nTry\n\nFinally, you can specify a default for a type parameter:\n\n/** @template [T=object] */\nclass Cache {\n    /** @param {T} initial */\n    constructor(initial) {\n    }\n}\nlet c = new Cache()\nTry\n@satisfies\n\n@satisfies provides access to the postfix operator satisfies in TypeScript. Satisfies is used to declare that a value implements a type but does not affect the type of the value.\n\n// @ts-check\n/**\n * @typedef {\"hello world\" | \"Hello, world\"} WelcomeMessage\n */\n \n/** @satisfies {WelcomeMessage} */\nconst message = \"hello world\"\n        \nconst message: \"hello world\"\n \n/** @satisfies {WelcomeMessage} */\nType '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.\nType '\"Hello world!\"' does not satisfy the expected type 'WelcomeMessage'.\nconst failingMessage = \"Hello world!\"\n \n/** @type {WelcomeMessage} */\nconst messageUsingType = \"hello world\"\n             \nconst messageUsingType: WelcomeMessage\nTry\nClasses\n\nClasses can be declared as ES6 classes.\n\nclass C {\n  /**\n   * @param {number} data\n   */\n  constructor(data) {\n    // property types can be inferred\n    this.name = \"foo\";\n \n    // or set explicitly\n    /** @type {string | null} */\n    this.title = null;\n \n    // or simply annotated, if they're set elsewhere\n    /** @type {number} */\n    this.size;\n \n    this.initialize(data); // Should error, initializer expects a string\n  }\n  /**\n   * @param {string} s\n   */\n  initialize = function (s) {\n    this.size = s.length;\n  };\n}\n \nvar c = new C(0);\n \n// C should only be called with new, but\n// because it is JavaScript, this is allowed and\n// considered an 'any'.\nvar result = C(1);\nTry\n\nThey can also be declared as constructor functions; use @constructor along with @this for this.\n\nProperty Modifiers\n\n@public, @private, and @protected work exactly like public, private, and protected in TypeScript:\n\n// @ts-check\n \nclass Car {\n  constructor() {\n    /** @private */\n    this.identifier = 100;\n  }\n \n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n \nconst c = new Car();\nconsole.log(c.identifier);\nProperty 'identifier' is private and only accessible within class 'Car'.\nProperty 'identifier' is private and only accessible within class 'Car'.\nTry\n@public is always implied and can be left off, but means that a property can be reached from anywhere.\n@private means that a property can only be used within the containing class.\n@protected means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.\n\n@public, @private, and @protected do not work in constructor functions.\n\n@readonly\n\nThe @readonly modifier ensures that a property is only ever written to during initialization.\n\n// @ts-check\n \nclass Car {\n  constructor() {\n    /** @readonly */\n    this.identifier = 100;\n  }\n \n  printIdentifier() {\n    console.log(this.identifier);\n  }\n}\n \nconst c = new Car();\nconsole.log(c.identifier);\nTry\n@override\n\n@override works the same way as in TypeScript; use it on methods that override a method from a base class:\n\nexport class C {\n  m() { }\n}\nclass D extends C {\n  /** @override */\n  m() { }\n}\nTry\n\nSet noImplicitOverride: true in tsconfig to check overrides.\n\n@extends\n\nWhen JavaScript classes extend a generic base class, there is no JavaScript syntax for passing a type argument. The @extends tag allows this:\n\n/**\n * @template T\n * @extends {Set<T>}\n */\nclass SortableSet extends Set {\n  // ...\n}\nTry\n\nNote that @extends only works with classes. Currently, there is no way for a constructor function to extend a class.\n\n@implements\n\nIn the same way, there is no JavaScript syntax for implementing a TypeScript interface. The @implements tag works just like in TypeScript:\n\n/** @implements {Print} */\nclass TextBook {\n  print() {\n    // TODO\n  }\n}\nTry\n@constructor\n\nThe compiler infers constructor functions based on this-property assignments, but you can make checking stricter and suggestions better if you add a @constructor tag:\n\n/**\n * @constructor\n * @param {number} data\n */\nfunction C(data) {\n  // property types can be inferred\n  this.name = \"foo\";\n \n  // or set explicitly\n  /** @type {string | null} */\n  this.title = null;\n \n  // or simply annotated, if they're set elsewhere\n  /** @type {number} */\n  this.size;\n \n  this.initialize(data);\nArgument of type 'number' is not assignable to parameter of type 'string'.\nArgument of type 'number' is not assignable to parameter of type 'string'.\n}\n/**\n * @param {string} s\n */\nC.prototype.initialize = function (s) {\n  this.size = s.length;\n};\n \nvar c = new C(0);\nc.size;\n \nvar result = C(1);\nValue of type 'typeof C' is not callable. Did you mean to include 'new'?\nValue of type 'typeof C' is not callable. Did you mean to include 'new'?\nTry\n\nNote: Error messages only show up in JS codebases with a JSConfig and checkJs enabled.\n\nWith @constructor, this is checked inside the constructor function C, so you will get suggestions for the initialize method and an error if you pass it a number. Your editor may also show warnings if you call C instead of constructing it.\n\nUnfortunately, this means that constructor functions that are also callable cannot use @constructor.\n\n@this\n\nThe compiler can usually figure out the type of this when it has some context to work with. When it doesn’t, you can explicitly specify the type of this with @this:\n\n/**\n * @this {HTMLElement}\n * @param {*} e\n */\nfunction callbackForLater(e) {\n  this.clientHeight = parseInt(e); // should be fine!\n}\nTry\nDocumentation\n@deprecated\n\nWhen a function, method, or property is deprecated you can let users know by marking it with a /** @deprecated */ JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed in a strike-through style like this.\n\n/** @deprecated */\nconst apiV1 = {};\nconst apiV2 = {};\n \napiV;\n   \napiV1\napiV2\n \n \nTry\n@see\n\n@see lets you link to other names in your program:\n\ntype Box<T> = { t: T }\n/** @see Box for implementation details */\ntype Boxify<T> = { [K in keyof T]: Box<T> };\nTry\n\nSome editors will turn Box into a link to make it easy to jump there and back.\n\n@link\n\n@link is like @see, except that it can be used inside other tags:\n\ntype Box<T> = { t: T }\n/** @returns A {@link Box} containing the parameter. */\nfunction box<U>(u: U): Box<U> {\n  return { t: u };\n}\nTry\nOther\n@enum\n\nThe @enum tag allows you to create an object literal whose members are all of a specified type. Unlike most object literals in JavaScript, it does not allow other members. @enum is intended for compatibility with Google Closure’s @enum tag.\n\n/** @enum {number} */\nconst JSDocState = {\n  BeginningOfLine: 0,\n  SawAsterisk: 1,\n  SavingComments: 2,\n};\n \nJSDocState.SawAsterisk;\nTry\n\nNote that @enum is quite different from, and much simpler than, TypeScript’s enum. However, unlike TypeScript’s enums, @enum can have any type:\n\n/** @enum {function(number): number} */\nconst MathFuncs = {\n  add1: (n) => n + 1,\n  id: (n) => -n,\n  sub1: (n) => n - 1,\n};\n \nMathFuncs.add1;\nTry\n@author\n\nYou can specify the author of an item with @author:\n\n/**\n * Welcome to awesome.ts\n * @author Ian Awesome <i.am.awesome@example.com>\n */\nTry\n\nRemember to surround the email address with angle brackets. Otherwise, @example will be parsed as a new tag.\n\nOther supported patterns\nvar someObj = {\n  /**\n   * @param {string} param1 - JSDocs on property assignments work\n   */\n  x: function (param1) {},\n};\n \n/**\n * As do jsdocs on variable assignments\n * @return {Window}\n */\nlet someFunc = function () {};\n \n/**\n * And class methods\n * @param {string} greeting The greeting to use\n */\nFoo.prototype.sayHi = (greeting) => console.log(\"Hi!\");\n \n/**\n * And arrow function expressions\n * @param {number} x - A multiplier\n */\nlet myArrow = (x) => x * x;\n \n/**\n * Which means it works for function components in JSX too\n * @param {{a: string, b: number}} props - Some param\n */\nvar fc = (props) => <div>{props.a.charAt(0)}</div>;\n \n/**\n * A parameter can be a class constructor, using Google Closure syntax.\n *\n * @param {{new(...args: any[]): object}} C - The class to register\n */\nfunction registerClass(C) {}\n \n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn10(p1) {}\n \n/**\n * @param {...string} p1 - A 'rest' arg (array) of strings. (treated as 'any')\n */\nfunction fn9(p1) {\n  return p1.join();\n}\nTry\nUnsupported patterns\n\nPostfix equals on a property type in an object literal type doesn’t specify an optional property:\n\n/**\n * @type {{ a: string, b: number= }}\n */\nvar wrong;\n/**\n * Use postfix question on the property name instead:\n * @type {{ a: string, b?: number }}\n */\nvar right;\nTry\n\nNullable types only have meaning if strictNullChecks is on:\n\n/**\n * @type {?number}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar nullable;\nTry\n\nThe TypeScript-native syntax is a union type:\n\n/**\n * @type {number | null}\n * With strictNullChecks: true  -- number | null\n * With strictNullChecks: false -- number\n */\nvar unionNullable;\nTry\n\nNon-nullable types have no meaning and are treated just as their original type:\n\n/**\n * @type {!number}\n * Just has type number\n */\nvar normal;\nTry\n\nUnlike JSDoc’s type system, TypeScript only allows you to mark types as containing null or not. There is no explicit non-nullability — if strictNullChecks is on, then number is not nullable. If it is off, then number is nullable.\n\nUnsupported tags\n\nTypeScript ignores any unsupported JSDoc tags.\n\nThe following tags have open issues to support them:\n\n@const (issue #19672)\n@inheritdoc (issue #23215)\n@memberof (issue #7237)\n@yields (issue #23857)\nOn this page\nTypes\n@type\n@param and @returns\n@typedef, @callback, and @param\n@template\n@satisfies\nClasses\nProperty Modifiers\n@readonly\n@override\n@extends\n@implements\n@constructor\n@this\nDocumentation\n@deprecated\n@see\n@link\nOther\n@enum\n@author\nOther supported patterns\nUnsupported patterns\nUnsupported tags\nIs this page helpful?\nYes\nNo\nPrevious\nType Checking JavaScript Files\n\nHow to add type checking to JavaScript files using TypeScript\n\nNext\nCreating .d.ts Files from .js files\n\nHow to add d.ts generation to JavaScript projects\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nNS\nRG\nGU\nD(K\n6+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.722 seconds."
  },
  {
    "title": "TypeScript: Documentation - Type Checking JavaScript Files",
    "url": "https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html",
    "html": "Type Checking JavaScript Files\n\nHere are some notable differences on how checking works in .js files compared to .ts files.\n\nProperties are inferred from assignments in class bodies\n\nES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.\n\nIn a .js file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it’s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.\n\nclass C {\n  constructor() {\n    this.constructorOnly = 0;\n    this.constructorUnknown = undefined;\n  }\n  method() {\n    this.constructorOnly = false;\nType 'boolean' is not assignable to type 'number'.\nType 'boolean' is not assignable to type 'number'.\n    this.constructorUnknown = \"plunkbat\"; // ok, constructorUnknown is string | undefined\n    this.methodOnly = \"ok\"; // ok, but methodOnly could also be undefined\n  }\n  method2() {\n    this.methodOnly = true; // also, ok, methodOnly's type is string | boolean | undefined\n  }\n}\nTry\n\nIf properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don’t even have to give a value if it will be initialized later:\n\nclass C {\n  constructor() {\n    /** @type {number | undefined} */\n    this.prop = undefined;\n    /** @type {number | undefined} */\n    this.count;\n  }\n}\n \nlet c = new C();\nc.prop = 0; // OK\nc.count = \"string\";\nType 'string' is not assignable to type 'number'.\nType 'string' is not assignable to type 'number'.\nTry\nConstructor functions are equivalent to classes\n\nBefore ES2015, JavaScript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.\n\nfunction C() {\n  this.constructorOnly = 0;\n  this.constructorUnknown = undefined;\n}\nC.prototype.method = function () {\n  this.constructorOnly = false;\nType 'boolean' is not assignable to type 'number'.\nType 'boolean' is not assignable to type 'number'.\n  this.constructorUnknown = \"plunkbat\"; // OK, the type is string | undefined\n};\nTry\nCommonJS modules are supported\n\nIn a .js file, TypeScript understands the CommonJS module format. Assignments to exports and module.exports are recognized as export declarations. Similarly, require function calls are recognized as module imports. For example:\n\n// same as `import module \"fs\"`\nconst fs = require(\"fs\");\n// same as `export function readFile`\nmodule.exports.readFile = function (f) {\n  return fs.readFileSync(f);\n};\n\nThe module support in JavaScript is much more syntactically forgiving than TypeScript’s module support. Most combinations of assignments and declarations are supported.\n\nClasses, functions, and object literals are namespaces\n\nClasses are namespaces in .js files. This can be used to nest classes, for example:\n\nclass C {}\nC.D = class {};\nTry\n\nAnd, for pre-ES2015 code, it can be used to simulate static methods:\n\nfunction Outer() {\n  this.y = 2;\n}\n \nOuter.Inner = function () {\n  this.yy = 2;\n};\n \nOuter.Inner();\nTry\n\nIt can also be used to create simple namespaces:\n\nvar ns = {};\nns.C = class {};\nns.func = function () {};\n \nns;\nTry\n\nOther variants are allowed as well:\n\n// IIFE\nvar ns = (function (n) {\n  return n || {};\n})();\nns.CONST = 1;\n \n// defaulting to global\nvar assign =\n  assign ||\n  function () {\n    // code goes here\n  };\nassign.extra = 1;\nTry\nObject literals are open-ended\n\nIn a .ts file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a .js file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:\n\nvar obj = { a: 1 };\nobj.b = 2; // Allowed\nTry\n\nObject literals behave as if they have an index signature [x:string]: any that allows them to be treated as open maps instead of closed objects.\n\nLike other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:\n\n/** @type {{a: number}} */\nvar obj = { a: 1 };\nobj.b = 2;\nProperty 'b' does not exist on type '{ a: number; }'.\nProperty 'b' does not exist on type '{ a: number; }'.\nTry\nnull, undefined, and empty array initializers are of type any or any[]\n\nAny variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.\n\nfunction Foo(i = null) {\n  if (!i) i = 1;\n  var j = undefined;\n  j = 2;\n  this.l = [];\n}\n \nvar foo = new Foo();\nfoo.l.push(foo.i);\nfoo.l.push(\"end\");\nTry\nFunction parameters are optional by default\n\nSince there is no way to specify optionality on parameters in pre-ES2015 JavaScript, all function parameters in .js file are considered optional. Calls with fewer arguments than the declared number of parameters are allowed.\n\nIt is important to note that it is an error to call a function with too many arguments.\n\nFor instance:\n\nfunction bar(a, b) {\n  console.log(a + \" \" + b);\n}\n \nbar(1); // OK, second argument considered optional\nbar(1, 2);\nbar(1, 2, 3); // Error, too many arguments\nExpected 0-2 arguments, but got 3.\nExpected 0-2 arguments, but got 3.\nTry\n\nJSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax ([ ]) to express optionality. e.g.:\n\n/**\n * @param {string} [somebody] - Somebody's name.\n */\nfunction sayHello(somebody) {\n  if (!somebody) {\n    somebody = \"John Doe\";\n  }\n  console.log(\"Hello \" + somebody);\n}\n \nsayHello();\nTry\nVar-args parameter declaration inferred from use of \narguments\n\nA function whose body has a reference to the arguments reference is implicitly considered to have a var-arg parameter (i.e. (...arg: any[]) => any). Use JSDoc var-arg syntax to specify the type of the arguments.\n\n/** @param {...number} args */\nfunction sum(/* numbers */) {\n  var total = 0;\n  for (var i = 0; i < arguments.length; i++) {\n    total += arguments[i];\n  }\n  return total;\n}\nTry\nUnspecified type parameters default to \nany\n\nSince there is no natural syntax for specifying generic type parameters in JavaScript, an unspecified type parameter defaults to any.\n\nIn extends clause\n\nFor instance, React.Component is defined to have two type parameters, Props and State. In a .js file, there is no legal way to specify these in the extends clause. By default the type arguments will be any:\n\nimport { Component } from \"react\";\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Allowed, since this.props is of type any\n  }\n}\n\nUse JSDoc @augments to specify the types explicitly. for instance:\n\nimport { Component } from \"react\";\n/**\n * @augments {Component<{a: number}, State>}\n */\nclass MyComponent extends Component {\n  render() {\n    this.props.b; // Error: b does not exist on {a:number}\n  }\n}\nIn JSDoc references\n\nAn unspecified type argument in JSDoc defaults to any:\n\n/** @type{Array} */\nvar x = [];\n \nx.push(1); // OK\nx.push(\"string\"); // OK, x is of type Array<any>\n \n/** @type{Array.<number>} */\nvar y = [];\n \ny.push(1); // OK\ny.push(\"string\"); // Error, string is not assignable to number\nTry\nIn function calls\n\nA call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to any. For example:\n\nvar p = new Promise((resolve, reject) => {\n  reject();\n});\np; // Promise<any>;\n\nTo learn all of the features available in JSDoc, see the reference.\n\nOn this page\nProperties are inferred from assignments in class bodies\nConstructor functions are equivalent to classes\nCommonJS modules are supported\nClasses, functions, and object literals are namespaces\nObject literals are open-ended\nnull, undefined, and empty array initializers are of type any or any[]\nFunction parameters are optional by default\nVar-args parameter declaration inferred from use of arguments\nUnspecified type parameters default to any\nIn extends clause\nIn JSDoc references\nIn function calls\nIs this page helpful?\nYes\nNo\nPrevious\nJS Projects Utilizing TypeScript\n\nHow to add type checking to JavaScript files using TypeScript\n\nNext\nJSDoc Reference\n\nWhat JSDoc does TypeScript-powered JavaScript support?\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nHN\nOT\nRC\nNS\nMH\n15+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.743 seconds."
  },
  {
    "title": "TypeScript: Documentation - Consumption",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/consumption.html",
    "html": "Consumption\nDownloading\n\nGetting type declarations requires no tools apart from npm.\n\nAs an example, getting the declarations for a library like lodash takes nothing more than the following command\n\nnpm install --save-dev @types/lodash\n\nIt is worth noting that if the npm package already includes its declaration file as described in Publishing, downloading the corresponding @types package is not needed.\n\nConsuming\n\nFrom there you’ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.\n\nFor example, once you’ve npm install-ed your type declarations, you can use imports and write\n\nimport * as _ from \"lodash\";\n_.padStart(\"Hello TypeScript!\", 20, \" \");\n\nor if you’re not using modules, you can just use the global variable _.\n\n_.padStart(\"Hello TypeScript!\", 20, \" \");\nSearching\n\nFor the most part, type declaration packages should always have the same name as the package name on npm, but prefixed with @types/, but if you need, you can use the Yarn package search to find the package for your favorite library.\n\nNote: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped contribution guidelines page for details.\n\nOn this page\nDownloading\nConsuming\nSearching\nIs this page helpful?\nYes\nNo\nPrevious\nPublishing\n\nHow to get your d.ts files to users\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nIO\nKO\nEB\n5+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.475 seconds."
  },
  {
    "title": "TypeScript: Documentation - Publishing",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html",
    "html": "Publishing\n\nNow that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:\n\nbundling with your npm package\npublishing to the @types organization on npm.\n\nIf your types are generated by your source code, publish the types with your source code. Both TypeScript and JavaScript projects can generate types via declaration.\n\nOtherwise, we recommend submitting the types to DefinitelyTyped, which will publish them to the @types organization on npm.\n\nIncluding declarations in your npm package\n\nIf your package has a main .js file, you will need to indicate the main declaration file in your package.json file as well. Set the types property to point to your bundled declaration file. For example:\n\n{\n  \"name\": \"awesome\",\n  \"author\": \"Vandelay Industries\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./lib/main.js\",\n  \"types\": \"./lib/main.d.ts\"\n}\n\nNote that the \"typings\" field is synonymous with types, and could be used as well.\n\nDependencies\n\nAll dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the \"dependencies\" section in your package.json. For example, imagine we authored a package that used Browserify and TypeScript.\n\n{\n  \"name\": \"browserify-typescript-extension\",\n  \"author\": \"Vandelay Industries\",\n  \"version\": \"1.0.0\",\n  \"main\": \"./lib/main.js\",\n  \"types\": \"./lib/main.d.ts\",\n  \"dependencies\": {\n    \"browserify\": \"latest\",\n    \"@types/browserify\": \"latest\",\n    \"typescript\": \"next\"\n  }\n}\n\nHere, our package depends on the browserify and typescript packages. browserify does not bundle its declaration files with its npm packages, so we needed to depend on @types/browserify for its declarations. typescript, on the other hand, packages its declaration files, so there was no need for any additional dependencies.\n\nOur package exposes declarations from each of those, so any user of our browserify-typescript-extension package needs to have these dependencies as well. For that reason, we used \"dependencies\" and not \"devDependencies\", because otherwise our consumers would have needed to manually install those packages. If we had just written a command line application and not expected our package to be used as a library, we might have used devDependencies.\n\nRed flags\n/// <reference path=\"...\" />\n\nDon’t use /// <reference path=\"...\" /> in your declaration files.\n\n/// <reference path=\"../typescript/lib/typescriptServices.d.ts\" />\n....\n\nDo use /// <reference types=\"...\" /> instead.\n\n/// <reference types=\"typescript\" />\n....\n\nMake sure to revisit the Consuming dependencies section for more information.\n\nPackaging dependent declarations\n\nIf your type definitions depend on another package:\n\nDon’t combine it with yours, keep each in their own file.\nDon’t copy the declarations in your package either.\nDo depend on the npm type declaration package if it doesn’t package its declaration files.\nVersion selection with \ntypesVersions\n\nWhen TypeScript opens a package.json file to figure out which files it needs to read, it first looks at a field called typesVersions.\n\nFolder redirects (using *)\n\nA package.json with a typesVersions field might look like this:\n\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \">=3.1\": { \"*\": [\"ts3.1/*\"] }\n  }\n}\n\nThis package.json tells TypeScript to first check the current version of TypeScript. If it’s 3.1 or later, TypeScript figures out the path you’ve imported relative to the package, and reads from the package’s ts3.1 folder.\n\nThat’s what that { \"*\": [\"ts3.1/*\"] } means - if you’re familiar with path mapping, it works exactly like that.\n\nIn the above example, if we’re importing from \"package-name\", TypeScript will try to resolve from [...]/node_modules/package-name/ts3.1/index.d.ts (and other relevant paths) when running in TypeScript 3.1. If we import from package-name/foo, we’ll try to look for [...]/node_modules/package-name/ts3.1/foo.d.ts and [...]/node_modules/package-name/ts3.1/foo/index.d.ts.\n\nWhat if we’re not running in TypeScript 3.1 in this example? Well, if none of the fields in typesVersions get matched, TypeScript falls back to the types field, so here TypeScript 3.0 and earlier will be redirected to [...]/node_modules/package-name/index.d.ts.\n\nFile redirects\n\nWhen you want to only change the resolution for a single file at a time, you can tell TypeScript the file to resolve differently by passing in the exact filenames:\n\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }\n  }\n}\n\nOn TypeScript 4.0 and above, an import for \"package-name\" would resolve to ./index.d.ts and for 3.9 and below \"./index.v3.d.ts.\n\nNote that redirections only affect the external API of a package; import resolution within a project is not affected by typesVersions. For example, a d.ts file in the previous example containing import * as foo from \"./index\" will still map to index.d.ts, not index.v3.d.ts, whereas another package importing import * as foo from \"package-name\" will get index.v3.d.ts.\n\nMatching behavior\n\nThe way that TypeScript decides on whether a version of the compiler & language matches is by using Node’s semver ranges.\n\nMultiple fields\n\ntypesVersions can support multiple fields where each field name is specified by the range to match on.\n\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \">=3.2\": { \"*\": [\"ts3.2/*\"] },\n    \">=3.1\": { \"*\": [\"ts3.1/*\"] }\n  }\n}\n\nSince ranges have the potential to overlap, determining which redirect applies is order-specific. That means in the above example, even though both the >=3.2 and the >=3.1 matchers support TypeScript 3.2 and above, reversing the order could have different behavior, so the above sample would not be equivalent to the following.\n\n{\n  \"name\": \"package-name\",\n  \"version\": \"1.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    // NOTE: this doesn't work!\n    \">=3.1\": { \"*\": [\"ts3.1/*\"] },\n    \">=3.2\": { \"*\": [\"ts3.2/*\"] }\n  }\n}\nPublish to \n@types\n\nPackages under the @types organization are published automatically from DefinitelyTyped using the types-publisher tool. To get your declarations published as an @types package, please submit a pull request to DefinitelyTyped. You can find more details in the contribution guidelines page.\n\nOn this page\nIncluding declarations in your npm package\nDependencies\nRed flags\n/// <reference path=\"...\" />\nPackaging dependent declarations\nVersion selection with typesVersions\nMatching behavior\nMultiple fields\nPublish to @types\nIs this page helpful?\nYes\nNo\nPrevious\nDeep Dive\n\nHow do d.ts files work, a deep dive\n\nNext\nConsumption\n\nHow to download d.ts files for your project\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nMB\nRV\nRC\n19+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.636 seconds."
  },
  {
    "title": "TypeScript: Documentation - JS Projects Utilizing TypeScript",
    "url": "https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html",
    "html": "JS Projects Utilizing TypeScript\n\nThe type system in TypeScript has different levels of strictness when working with a codebase:\n\nA type-system based only on inference with JavaScript code\nIncremental typing in JavaScript via JSDoc\nUsing // @ts-check in a JavaScript file\nTypeScript code\nTypeScript with strict enabled\n\nEach step represents a move towards a safer type-system, but not every project needs that level of verification.\n\nTypeScript with JavaScript\n\nThis is when you use an editor which uses TypeScript to provide tooling like auto-complete, jump to symbol and refactoring tools like rename. The homepage has a list of editors which have TypeScript plugins.\n\nProviding Type Hints in JS via JSDoc\n\nIn a .js file, types can often be inferred. When types can’t be inferred, they can be specified using JSDoc syntax.\n\nJSDoc annotations come before a declaration will be used to set the type of that declaration. For example:\n\n/** @type {number} */\nvar x;\n \nx = 0; // OK\nx = false; // OK?!\nTry\n\nYou can find the full list of supported JSDoc patterns in JSDoc Supported Types.\n\n@ts-check\n\nThe last line of the previous code sample would raise an error in TypeScript, but it doesn’t by default in a JS project. To enable errors in your JavaScript files add: // @ts-check to the first line in your .js files to have TypeScript raise it as an error.\n\n// @ts-check\n/** @type {number} */\nvar x;\n \nx = 0; // OK\nx = false; // Not OK\nType 'boolean' is not assignable to type 'number'.\nType 'boolean' is not assignable to type 'number'.\nTry\n\nIf you have a lot of JavaScript files you want to add errors to then you can switch to using a jsconfig.json. You can skip checking some files by adding a // @ts-nocheck comment to files.\n\nTypeScript may offer you errors which you disagree with, in those cases you can ignore errors on specific lines by adding // @ts-ignore or // @ts-expect-error on the preceding line.\n\n// @ts-check\n/** @type {number} */\nvar x;\n \nx = 0; // OK\n// @ts-expect-error\nx = false; // Not OK\nTry\n\nTo learn more about how JavaScript is interpreted by TypeScript read How TS Type Checks JS\n\nOn this page\nTypeScript with JavaScript\nProviding Type Hints in JS via JSDoc\n@ts-check\nIs this page helpful?\nYes\nNo\nNext\nType Checking JavaScript Files\n\nHow to add type checking to JavaScript files using TypeScript\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\n\nLast updated: Nov 27, 2023\n\n "
  },
  {
    "title": "TypeScript: Documentation - Deep Dive",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/deep-dive.html",
    "html": "Deep Dive\nDeclaration File Theory: A Deep Dive\n\nStructuring modules to give the exact API shape you want can be tricky. For example, we might want a module that can be invoked with or without new to produce different types, has a variety of named types exposed in a hierarchy, and has some properties on the module object as well.\n\nBy reading this guide, you’ll have the tools to write complex declaration files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.\n\nKey Concepts\n\nYou can fully understand how to make any shape of declaration by understanding some key concepts of how TypeScript works.\n\nTypes\n\nIf you’re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a type is introduced with:\n\nA type alias declaration (type sn = number | string;)\nAn interface declaration (interface I { x: number[]; })\nA class declaration (class C { })\nAn enum declaration (enum E { A, B, C })\nAn import declaration which refers to a type\n\nEach of these declaration forms creates a new type name.\n\nValues\n\nAs with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example let x = 5; creates a value called x.\n\nAgain, being explicit, the following things create values:\n\nlet, const, and var declarations\nA namespace or module declaration which contains a value\nAn enum declaration\nA class declaration\nAn import declaration which refers to a value\nA function declaration\nNamespaces\n\nTypes can exist in namespaces. For example, if we have the declaration let x: A.B.C, we say that the type C comes from the A.B namespace.\n\nThis distinction is subtle and important — here, A.B is not necessarily a type or a value.\n\nSimple Combinations: One name, multiple meanings\n\nGiven a name A, we might find up to three different meanings for A: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration let m: A.A = A;, A is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!\n\nThis may seem confusing, but it’s actually very convenient as long as we don’t excessively overload things. Let’s look at some useful aspects of this combining behavior.\n\nBuilt-in Combinations\n\nAstute readers will notice that, for example, class appeared in both the type and value lists. The declaration class C { } creates two things: a type C which refers to the instance shape of the class, and a value C which refers to the constructor function of the class. Enum declarations behave similarly.\n\nUser Combinations\n\nLet’s say we wrote a module file foo.d.ts:\n\nexport var SomeVar: { a: SomeType };\nexport interface SomeType {\n  count: number;\n}\n\nThen consumed it:\n\nimport * as foo from \"./foo\";\nlet x: foo.SomeType = foo.SomeVar.a;\nconsole.log(x.count);\n\nThis works well enough, but we might imagine that SomeType and SomeVar were very closely related such that you’d like them to have the same name. We can use combining to present these two different objects (the value and the type) under the same name Bar:\n\nexport var Bar: { a: Bar };\nexport interface Bar {\n  count: number;\n}\n\nThis presents a very good opportunity for destructuring in the consuming code:\n\nimport { Bar } from \"./foo\";\nlet x: Bar = Bar.a;\nconsole.log(x.count);\n\nAgain, we’ve used Bar as both a type and a value here. Note that we didn’t have to declare the Bar value as being of the Bar type — they’re independent.\n\nAdvanced Combinations\n\nSome kinds of declarations can be combined across multiple declarations. For example, class C { } and interface C { } can co-exist and both contribute properties to the C types.\n\nThis is legal as long as it does not create a conflict. A general rule of thumb is that values always conflict with other values of the same name unless they are declared as namespaces, types will conflict if they are declared with a type alias declaration (type s = string), and namespaces never conflict.\n\nLet’s see how this can be used.\n\nAdding using an \ninterface\n\nWe can add additional members to an interface with another interface declaration:\n\ninterface Foo {\n  x: number;\n}\n// ... elsewhere ...\ninterface Foo {\n  y: number;\n}\nlet a: Foo = ...;\nconsole.log(a.x + a.y); // OK\n\nThis also works with classes:\n\nclass Foo {\n  x: number;\n}\n// ... elsewhere ...\ninterface Foo {\n  y: number;\n}\nlet a: Foo = ...;\nconsole.log(a.x + a.y); // OK\n\nNote that we cannot add to type aliases (type s = string;) using an interface.\n\nAdding using a \nnamespace\n\nA namespace declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.\n\nFor example, we can add a static member to a class:\n\nclass C {}\n// ... elsewhere ...\nnamespace C {\n  export let x: number;\n}\nlet y = C.x; // OK\n\nNote that in this example, we added a value to the static side of C (its constructor function). This is because we added a value, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).\n\nWe could also add a namespaced type to a class:\n\nclass C {}\n// ... elsewhere ...\nnamespace C {\n  export interface D {}\n}\nlet y: C.D; // OK\n\nIn this example, there wasn’t a namespace C until we wrote the namespace declaration for it. The meaning C as a namespace doesn’t conflict with the value or type meanings of C created by the class.\n\nFinally, we could perform many different merges using namespace declarations. This isn’t a particularly realistic example, but shows all sorts of interesting behavior:\n\nnamespace X {\n  export interface Y {}\n  export class Z {}\n}\n// ... elsewhere ...\nnamespace X {\n  export var Y: number;\n  export namespace Z {\n    export class C {}\n  }\n}\ntype X = string;\n\nIn this example, the first block creates the following name meanings:\n\nA value X (because the namespace declaration contains a value, Z)\nA namespace X (because the namespace declaration contains a type, Y)\nA type Y in the X namespace\nA type Z in the X namespace (the instance shape of the class)\nA value Z that is a property of the X value (the constructor function of the class)\n\nThe second block creates the following name meanings:\n\nA value Y (of type number) that is a property of the X value\nA namespace Z\nA value Z that is a property of the X value\nA type C in the X.Z namespace\nA value C that is a property of the X.Z value\nA type X\nOn this page\nDeclaration File Theory: A Deep Dive\nKey Concepts\nTypes\nValues\nNamespaces\nSimple Combinations: One name, multiple meanings\nBuilt-in Combinations\nUser Combinations\nAdvanced Combinations\nAdding using an interface\nAdding using a namespace\nIs this page helpful?\nYes\nNo\nPrevious\nDo's and Don'ts\n\nRecommendations for writing d.ts files\n\nNext\nPublishing\n\nHow to get your d.ts files to users\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\n1+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.529 seconds."
  },
  {
    "title": "TypeScript: Documentation - Module: Class",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-class-d-ts.html",
    "html": "Module: Class\n\nFor example, when you want to work with JavaScript code which looks like:\n\nconst Greeter = require(\"super-greeter\");\nconst greeter = new Greeter();\ngreeter.greet();\n\nTo handle both importing via UMD and modules:\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n/*~ This is the module template file for class modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n/*~ If this module is a UMD module that exposes a global variable 'myClassLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace \"super-greeter\";\n/*~ This declaration specifies that the class constructor function\n *~ is the exported object from the file\n */\nexport = Greeter;\n/*~ Write your module's methods and properties in this class */\ndeclare class Greeter {\n  constructor(customGreeting?: string);\n  greet: void;\n  myMethod(opts: MyClass.MyClassMethodOptions): number;\n}\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace MyClass {\n  export interface MyClassMethodOptions {\n    width?: number;\n    height?: number;\n  }\n}\nOn this page\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nAC\nDR\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.315 seconds."
  },
  {
    "title": "TypeScript: Documentation - Do's and Don'ts",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/do-s-and-don-ts.html",
    "html": "Do's and Don'ts\nGeneral Types\nNumber\n, \nString\n, \nBoolean\n, \nSymbol\n and \nObject\n\n❌ Don’t ever use the types Number, String, Boolean, Symbol, or Object These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.\n\n/* WRONG */\nfunction reverse(s: String): String;\n\n✅ Do use the types number, string, boolean, and symbol.\n\n/* OK */\nfunction reverse(s: string): string;\n\nInstead of Object, use the non-primitive object type (added in TypeScript 2.2).\n\nGenerics\n\n❌ Don’t ever have a generic type which doesn’t use its type parameter. See more details in TypeScript FAQ page.\n\nany\n\n❌ Don’t use any as a type unless you are in the process of migrating a JavaScript project to TypeScript. The compiler effectively treats any as “please turn off type checking for this thing”. It is similar to putting an @ts-ignore comment around every usage of the variable. This can be very helpful when you are first migrating a JavaScript project to TypeScript as you can set the type for stuff you haven’t migrated yet as any, but in a full TypeScript project you are disabling type checking for any parts of your program that use it.\n\nIn cases where you don’t know what type you want to accept, or when you want to accept anything because you will be blindly passing it through without interacting with it, you can use unknown.\n\nCallback Types\nReturn Types of Callbacks\n\n❌ Don’t use the return type any for callbacks whose value will be ignored:\n\n/* WRONG */\nfunction fn(x: () => any) {\n  x();\n}\n\n✅ Do use the return type void for callbacks whose value will be ignored:\n\n/* OK */\nfunction fn(x: () => void) {\n  x();\n}\n\n❔ Why: Using void is safer because it prevents you from accidentally using the return value of x in an unchecked way:\n\nfunction fn(x: () => void) {\n  var k = x(); // oops! meant to do something else\n  k.doSomething(); // error, but would be OK if the return type had been 'any'\n}\nOptional Parameters in Callbacks\n\n❌ Don’t use optional parameters in callbacks unless you really mean it:\n\n/* WRONG */\ninterface Fetcher {\n  getObject(done: (data: unknown, elapsedTime?: number) => void): void;\n}\n\nThis has a very specific meaning: the done callback might be invoked with 1 argument or might be invoked with 2 arguments. The author probably intended to say that the callback might not care about the elapsedTime parameter, but there’s no need to make the parameter optional to accomplish this — it’s always legal to provide a callback that accepts fewer arguments.\n\n✅ Do write callback parameters as non-optional:\n\n/* OK */\ninterface Fetcher {\n  getObject(done: (data: unknown, elapsedTime: number) => void): void;\n}\nOverloads and Callbacks\n\n❌ Don’t write separate overloads that differ only on callback arity:\n\n/* WRONG */\ndeclare function beforeAll(action: () => void, timeout?: number): void;\ndeclare function beforeAll(\n  action: (done: DoneFn) => void,\n  timeout?: number\n): void;\n\n✅ Do write a single overload using the maximum arity:\n\n/* OK */\ndeclare function beforeAll(\n  action: (done: DoneFn) => void,\n  timeout?: number\n): void;\n\n❔ Why: It’s always legal for a callback to disregard a parameter, so there’s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.\n\nFunction Overloads\nOrdering\n\n❌ Don’t put more general overloads before more specific overloads:\n\n/* WRONG */\ndeclare function fn(x: unknown): unknown;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: HTMLDivElement): string;\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: unknown, wat?\n\n✅ Do sort overloads by putting the more general signatures after more specific signatures:\n\n/* OK */\ndeclare function fn(x: HTMLDivElement): string;\ndeclare function fn(x: HTMLElement): number;\ndeclare function fn(x: unknown): unknown;\nvar myElem: HTMLDivElement;\nvar x = fn(myElem); // x: string, :)\n\n❔ Why: TypeScript chooses the first matching overload when resolving function calls. When an earlier overload is “more general” than a later one, the later one is effectively hidden and cannot be called.\n\nUse Optional Parameters\n\n❌ Don’t write several overloads that differ only in trailing parameters:\n\n/* WRONG */\ninterface Example {\n  diff(one: string): number;\n  diff(one: string, two: string): number;\n  diff(one: string, two: string, three: boolean): number;\n}\n\n✅ Do use optional parameters whenever possible:\n\n/* OK */\ninterface Example {\n  diff(one: string, two?: string, three?: boolean): number;\n}\n\nNote that this collapsing should only occur when all overloads have the same return type.\n\n❔ Why: This is important for two reasons.\n\nTypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, and extraneous arguments are allowed. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:\n\nfunction fn(x: (a: string, b: number, c: number) => void) {}\nvar x: Example;\n// When written with overloads, OK -- used first overload\n// When written with optionals, correctly an error\nfn(x.diff);\n\nThe second reason is when a consumer uses the “strict null checking” feature of TypeScript. Because unspecified parameters appear as undefined in JavaScript, it’s usually fine to pass an explicit undefined to a function with optional arguments. This code, for example, should be OK under strict nulls:\n\nvar x: Example;\n// When written with overloads, incorrectly an error because of passing 'undefined' to 'string'\n// When written with optionals, correctly OK\nx.diff(\"something\", true ? undefined : \"hour\");\nUse Union Types\n\n❌ Don’t write overloads that differ by type in only one argument position:\n\n/* WRONG */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number): Moment;\n  utcOffset(b: string): Moment;\n}\n\n✅ Do use union types whenever possible:\n\n/* OK */\ninterface Moment {\n  utcOffset(): number;\n  utcOffset(b: number | string): Moment;\n}\n\nNote that we didn’t make b optional here because the return types of the signatures differ.\n\n❔ Why: This is important for people who are “passing through” a value to your function:\n\nfunction fn(x: string): Moment;\nfunction fn(x: number): Moment;\nfunction fn(x: number | string) {\n  // When written with separate overloads, incorrectly an error\n  // When written with union types, correctly OK\n  return moment().utcOffset(x);\n}\nOn this page\nGeneral Types\nNumber, String, Boolean, Symbol and Object\nGenerics\nany\nCallback Types\nReturn Types of Callbacks\nOptional Parameters in Callbacks\nOverloads and Callbacks\nFunction Overloads\nOrdering\nUse Optional Parameters\nUse Union Types\nIs this page helpful?\nYes\nNo\nNext\nDeep Dive\n\nHow do d.ts files work, a deep dive\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nMZ\nMF\nJ\n15+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.092 seconds."
  },
  {
    "title": "TypeScript: Documentation - Global: Modifying Module",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html",
    "html": "Global: Modifying Module\nGlobal-modifying Modules\n\nA global-modifying module alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to String.prototype when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.\n\nIdentifying global-modifying modules\n\nGlobal-modifying modules are generally easy to identify from their documentation. In general, they’re similar to global plugins, but need a require call to activate their effects.\n\nYou might see documentation like this:\n\n// 'require' call that doesn't use its return value\nvar unused = require(\"magic-string-time\");\n/* or */\nrequire(\"magic-string-time\");\nvar x = \"hello, world\";\n// Creates new methods on built-in types\nconsole.log(x.startsWithHello());\nvar y = [1, 2, 3];\n// Creates new methods on built-in types\nconsole.log(y.reverseAndSort());\n\nHere is an example\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n/*~ This is the global-modifying module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n/*~ Note: If your global-modifying module is callable or constructable, you'll\n *~ need to combine the patterns here with those in the module-class or module-function\n *~ template files\n */\ndeclare global {\n  /*~ Here, declare things that go in the global namespace, or augment\n   *~ existing declarations in the global namespace\n   */\n  interface String {\n    fancyFormat(opts: StringFormatOptions): string;\n  }\n}\n/*~ If your module exports types or values, write them as usual */\nexport interface StringFormatOptions {\n  fancinessLevel: number;\n}\n/*~ For example, declaring a method on the module (in addition to its global side effects) */\nexport function doSomething(): void;\n/*~ If your module exports nothing, you'll need this line. Otherwise, delete it */\nexport {};\nOn this page\nGlobal-modifying Modules\nIdentifying global-modifying modules\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\n1+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.208 seconds."
  },
  {
    "title": "TypeScript: Documentation - Module: Plugin",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-plugin-d-ts.html",
    "html": "Module: Plugin\n\nFor example, when you want to work with JavaScript code which extends another library.\n\nimport { greeter } from \"super-greeter\";\n// Normal Greeter API\ngreeter(2);\ngreeter(\"Hello world\");\n// Now we extend the object with a new function at runtime\nimport \"hyper-super-greeter\";\ngreeter.hyperGreet();\n\nThe definition for “super-greeter”:\n\n/*~ This example shows how to have multiple overloads for your function */\nexport interface GreeterFunction {\n  (name: string): void\n  (time: number): void\n}\n/*~ This example shows how to export a function specified by an interface */\nexport const greeter: GreeterFunction;\n\nWe can extend the existing module like the following:\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n/*~ This is the module plugin template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n/*~ On this line, import the module which this module adds to */\nimport { greeter } from \"super-greeter\";\n/*~ Here, declare the same module as the one you imported above\n *~ then we expand the existing declaration of the greeter function\n */\nexport module \"super-greeter\" {\n  export interface GreeterFunction {\n    /** Greets even better! */\n    hyperGreet(): void;\n  }\n}\n\nThis uses declaration merging\n\nThe Impact of ES6 on Module Plugins\n\nSome plugins add or modify top-level exports on existing modules. While this is legal in CommonJS and other loaders, ES6 modules are considered immutable and this pattern will not be possible. Because TypeScript is loader-agnostic, there is no compile-time enforcement of this policy, but developers intending to transition to an ES6 module loader should be aware of this.\n\nOn this page\nThe Impact of ES6 on Module Plugins\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nB\n1+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.462 seconds."
  },
  {
    "title": "TypeScript: Documentation - Global .d.ts",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-d-ts.html",
    "html": "Global .d.ts\nGlobal Libraries\n\nA global library is one that can be accessed from the global scope (i.e. without using any form of import). Many libraries simply expose one or more global variables for use. For example, if you were using jQuery, the $ variable can be used by simply referring to it:\n\n$(() => {\n  console.log(\"hello!\");\n});\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\n<script src=\"http://a.great.cdn.for/someLib.js\"></script>\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\nIdentifying a Global Library from Code\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\nfunction createGreeting(s) {\n  return \"Hello, \" + s;\n}\n\nor like this:\n\nwindow.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n\nWhen looking at the code of a global library, you’ll usually see:\n\nTop-level var statements or function declarations\nOne or more assignments to window.someName\nAssumptions that DOM primitives like document or window exist\n\nYou won’t see:\n\nChecks for, or usage of, module loaders like require or define\nCommonJS/Node.js-style imports of the form var fs = require(\"fs\");\nCalls to define(...)\nDocumentation describing how to require or import the library\nExamples of Global Libraries\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have no dependencies) may still be global.\n\nGlobal Library Template\n\nYou can see an example DTS below:\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n/*~ If this library is callable (e.g. can be invoked as myLib(3)),\n *~ include those call signatures here.\n *~ Otherwise, delete this section.\n */\ndeclare function myLib(a: string): string;\ndeclare function myLib(a: number): number;\n/*~ If you want the name of this library to be a valid type name,\n *~ you can do so here.\n *~\n *~ For example, this allows us to write 'var x: myLib';\n *~ Be sure this actually makes sense! If it doesn't, just\n *~ delete this declaration and add types inside the namespace below.\n */\ninterface myLib {\n  name: string;\n  length: number;\n  extras?: string[];\n}\n/*~ If your library has properties exposed on a global variable,\n *~ place them here.\n *~ You should also place types (interfaces and type alias) here.\n */\ndeclare namespace myLib {\n  //~ We can write 'myLib.timeout = 50;'\n  let timeout: number;\n  //~ We can access 'myLib.version', but not change it\n  const version: string;\n  //~ There's some class we can create via 'let c = new myLib.Cat(42)'\n  //~ Or reference e.g. 'function f(c: myLib.Cat) { ... }\n  class Cat {\n    constructor(n: number);\n    //~ We can read 'c.age' from a 'Cat' instance\n    readonly age: number;\n    //~ We can invoke 'c.purr()' from a 'Cat' instance\n    purr(): void;\n  }\n  //~ We can declare a variable as\n  //~   'var s: myLib.CatSettings = { weight: 5, name: \"Maru\" };'\n  interface CatSettings {\n    weight: number;\n    name: string;\n    tailLength?: number;\n  }\n  //~ We can write 'const v: myLib.VetID = 42;'\n  //~  or 'const v: myLib.VetID = \"bob\";'\n  type VetID = string | number;\n  //~ We can invoke 'myLib.checkCat(c)' or 'myLib.checkCat(c, v);'\n  function checkCat(c: Cat, s?: VetID);\n}\nOn this page\nGlobal Libraries\nIdentifying a Global Library from Code\nExamples of Global Libraries\nGlobal Library Template\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\n1+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.988 seconds."
  },
  {
    "title": "TypeScript: Documentation - Module: Function",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-function-d-ts.html",
    "html": "Module: Function\n\nFor example, when you want to work with JavaScript code which looks like:\n\nimport greeter from \"super-greeter\";\ngreeter(2);\ngreeter(\"Hello world\");\n\nTo handle both importing via UMD and modules:\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n/*~ This is the module template file for function modules.\n *~ You should rename it to index.d.ts and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n// Note that ES6 modules cannot directly export class objects.\n// This file should be imported using the CommonJS-style:\n//   import x = require('[~THE MODULE~]');\n//\n// Alternatively, if --allowSyntheticDefaultImports or\n// --esModuleInterop is turned on, this file can also be\n// imported as a default import:\n//   import x from '[~THE MODULE~]';\n//\n// Refer to the TypeScript documentation at\n// https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require\n// to understand common workarounds for this limitation of ES6 modules.\n/*~ If this module is a UMD module that exposes a global variable 'myFuncLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myFuncLib;\n/*~ This declaration specifies that the function\n *~ is the exported object from the file\n */\nexport = Greeter;\n/*~ This example shows how to have multiple overloads for your function */\ndeclare function Greeter(name: string): Greeter.NamedReturnType;\ndeclare function Greeter(length: number): Greeter.LengthReturnType;\n/*~ If you want to expose types from your module as well, you can\n *~ place them in this block. Often you will want to describe the\n *~ shape of the return type of the function; that type should\n *~ be declared in here, as this example shows.\n *~\n *~ Note that if you decide to include this namespace, the module can be\n *~ incorrectly imported as a namespace object, unless\n *~ --esModuleInterop is turned on:\n *~   import * as x from '[~THE MODULE~]'; // WRONG! DO NOT DO THIS!\n */\ndeclare namespace Greeter {\n  export interface LengthReturnType {\n    width: number;\n    height: number;\n  }\n  export interface NamedReturnType {\n    firstName: string;\n    lastName: string;\n  }\n  /*~ If the module also has properties, declare them here. For example,\n   *~ this declaration says that this code is legal:\n   *~   import f = require('super-greeter');\n   *~   console.log(f.defaultName);\n   */\n  export const defaultName: string;\n  export let defaultLength: number;\n}\nOn this page\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nDR\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.916 seconds."
  },
  {
    "title": "TypeScript: Documentation - Library Structures",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/library-structures.html",
    "html": "Library Structures\n\nBroadly speaking, the way you structure your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you’ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.\n\nEach type of major library structuring pattern has a corresponding file in the Templates section. You can start with these templates to help you get going faster.\n\nIdentifying Kinds of Libraries\n\nFirst, we’ll review the kinds of libraries TypeScript declaration files can represent. We’ll briefly show how each kind of library is used, how it is written, and list some example libraries from the real world.\n\nIdentifying the structure of a library is the first step in writing its declaration file. We’ll give hints on how to identify structure both based on its usage and its code. Depending on the library’s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.\n\nWhat should you look for?\n\nQuestion to ask yourself while looking at a library you are trying to type.\n\nHow do you obtain the library?\n\nFor example, can you only get it through npm or only from a CDN?\n\nHow would you import it?\n\nDoes it add a global object? Does it use require or import/export statements?\n\nSmaller samples for different types of libraries\nModular Libraries\n\nAlmost every modern Node.js library falls into the module family. These type of libraries only work in a JS environment with a module loader. For example, express only works in Node.js and must be loaded using the CommonJS require function.\n\nECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of importing a module. In JavaScript CommonJS (Node.js), for example, you would write\n\nvar fs = require(\"fs\");\n\nIn TypeScript or ES6, the import keyword serves the same purpose:\n\nimport * as fs from \"fs\";\n\nYou’ll typically see modular libraries include one of these lines in their documentation:\n\nvar someLib = require(\"someLib\");\n\nor\n\ndefine(..., ['someLib'], function(someLib) {\n});\n\nAs with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.\n\nIdentifying a Module Library from Code\n\nModular libraries will typically have at least some of the following:\n\nUnconditional calls to require or define\nDeclarations like import * as a from 'b'; or export c;\nAssignments to exports or module.exports\n\nThey will rarely have:\n\nAssignments to properties of window or global\nTemplates For Modules\n\nThere are four templates available for modules, module.d.ts, module-class.d.ts, module-function.d.ts and module-plugin.d.ts.\n\nYou should first read module.d.ts for an overview on the way they all work.\n\nThen use the template module-function.d.ts if your module can be called like a function:\n\nconst x = require(\"foo\");\n// Note: calling 'x' as a function\nconst y = x(42);\n\nUse the template module-class.d.ts if your module can be constructed using new:\n\nconst x = require(\"bar\");\n// Note: using 'new' operator on the imported variable\nconst y = new x(\"hello\");\n\nIf you have a module which when imported, makes changes to other modules use template module-plugin.d.ts:\n\nconst jest = require(\"jest\");\nrequire(\"jest-matchers-files\");\nGlobal Libraries\n\nA global library is one that can be accessed from the global scope (i.e. without using any form of import). Many libraries simply expose one or more global variables for use. For example, if you were using jQuery, the $ variable can be used by simply referring to it:\n\n$(() => {\n  console.log(\"hello!\");\n});\n\nYou’ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:\n\n<script src=\"http://a.great.cdn.for/someLib.js\"></script>\n\nToday, most popular globally-accessible libraries are actually written as UMD libraries (see below). UMD library documentation is hard to distinguish from global library documentation. Before writing a global declaration file, make sure the library isn’t actually UMD.\n\nIdentifying a Global Library from Code\n\nGlobal library code is usually extremely simple. A global “Hello, world” library might look like this:\n\nfunction createGreeting(s) {\n  return \"Hello, \" + s;\n}\n\nor like this:\n\n// Web\nwindow.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n// Node\nglobal.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n// Potentially any runtime\nglobalThis.createGreeting = function (s) {\n  return \"Hello, \" + s;\n};\n\nWhen looking at the code of a global library, you’ll usually see:\n\nTop-level var statements or function declarations\nOne or more assignments to window.someName\nAssumptions that DOM primitives like document or window exist\n\nYou won’t see:\n\nChecks for, or usage of, module loaders like require or define\nCommonJS/Node.js-style imports of the form var fs = require(\"fs\");\nCalls to define(...)\nDocumentation describing how to require or import the library\nExamples of Global Libraries\n\nBecause it’s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have no dependencies) may still be global.\n\nGlobal Library Template\n\nThe template file global.d.ts defines an example library myLib. Be sure to read the “Preventing Name Conflicts” footnote.\n\nUMD\n\nA UMD module is one that can either be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as Moment.js, are written this way. For example, in Node.js or using RequireJS, you would write:\n\nimport moment = require(\"moment\");\nconsole.log(moment.format());\n\nwhereas in a vanilla browser environment you would write:\n\nconsole.log(moment.format());\nIdentifying a UMD library\n\nUMD modules check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:\n\n(function (root, factory) {\n    if (typeof define === \"function\" && define.amd) {\n        define([\"libName\"], factory);\n    } else if (typeof module === \"object\" && module.exports) {\n        module.exports = factory(require(\"libName\"));\n    } else {\n        root.returnExports = factory(root.libName);\n    }\n}(this, function (b) {\n\nIf you see tests for typeof define, typeof window, or typeof module in the code of a library, especially at the top of the file, it’s almost always a UMD library.\n\nDocumentation for UMD libraries will also often demonstrate a “Using in Node.js” example showing require, and a “Using in the browser” example showing using a <script> tag to load the script.\n\nExamples of UMD libraries\n\nMost popular libraries are now available as UMD packages. Examples include jQuery, Moment.js, lodash, and many more.\n\nTemplate\n\nUse the module-plugin.d.ts template.\n\nConsuming Dependencies\n\nThere are several kinds of dependencies your library might have. This section shows how to import them into the declaration file.\n\nDependencies on Global Libraries\n\nIf your library depends on a global library, use a /// <reference types=\"...\" /> directive:\n\n/// <reference types=\"someLib\" />\nfunction getThing(): someLib.thing;\nDependencies on Modules\n\nIf your library depends on a module, use an import statement:\n\nimport * as moment from \"moment\";\nfunction getThing(): moment;\nDependencies on UMD libraries\nFrom a Global Library\n\nIf your global library depends on a UMD module, use a /// <reference types directive:\n\n/// <reference types=\"moment\" />\nfunction getThing(): moment;\nFrom a Module or UMD Library\n\nIf your module or UMD library depends on a UMD library, use an import statement:\n\nimport * as someLib from \"someLib\";\n\nDo not use a /// <reference directive to declare a dependency to a UMD library!\n\nFootnotes\nPreventing Name Conflicts\n\nNote that it’s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.\n\nA simple rule to follow is to only declare types namespaced by whatever global variable the library defines. For example, if the library defines the global value ‘cats’, you should write\n\ndeclare namespace cats {\n  interface KittySettings {}\n}\n\nBut not\n\n// at top-level\ninterface CatsKittySettings {}\n\nThis guidance also ensures that the library can be transitioned to UMD without breaking declaration file users.\n\nThe Impact of ES6 on Module Call Signatures\n\nMany popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:\n\nimport exp = require(\"express\");\nvar app = exp();\n\nIn ES6-compliant module loaders, the top-level object (here imported as exp) can only have properties; the top-level module object can never be callable.\n\nThe most common solution here is to define a default export for a callable/constructable object; module loaders commonly detect this situation automatically and replace the top-level object with the default export. TypeScript can handle this for you, if you have \"esModuleInterop\": true in your tsconfig.json.\n\nOn this page\nIdentifying Kinds of Libraries\nWhat should you look for?\nSmaller samples for different types of libraries\nModular Libraries\nGlobal Libraries\nUMD\nConsuming Dependencies\nDependencies on Global Libraries\nDependencies on Modules\nDependencies on UMD libraries\nFootnotes\nPreventing Name Conflicts\nThe Impact of ES6 on Module Call Signatures\nIs this page helpful?\nYes\nNo\nPrevious\nDeclaration Reference\n\nHow to create a d.ts file for a module\n\nNext\nModules .d.ts\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nDR\nL\nMF\n12+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.118 seconds."
  },
  {
    "title": "TypeScript: Documentation - Declaration Reference",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/by-example.html",
    "html": "Declaration Reference\n\nThe purpose of this guide is to teach you how to write a high-quality definition file. This guide is structured by showing documentation for some API, along with sample usage of that API, and explaining how to write the corresponding declaration.\n\nThese examples are ordered in approximately increasing order of complexity.\n\nObjects with Properties\n\nDocumentation\n\nThe global variable myLib has a function makeGreeting for creating greetings, and a property numberOfGreetings indicating the number of greetings made so far.\n\nCode\n\nlet result = myLib.makeGreeting(\"hello, world\");\nconsole.log(\"The computed greeting is:\" + result);\nlet count = myLib.numberOfGreetings;\n\nDeclaration\n\nUse declare namespace to describe types or values accessed by dotted notation.\n\ndeclare namespace myLib {\n  function makeGreeting(s: string): string;\n  let numberOfGreetings: number;\n}\nOverloaded Functions\n\nDocumentation\n\nThe getWidget function accepts a number and returns a Widget, or accepts a string and returns a Widget array.\n\nCode\n\nlet x: Widget = getWidget(43);\nlet arr: Widget[] = getWidget(\"all of them\");\n\nDeclaration\n\ndeclare function getWidget(n: number): Widget;\ndeclare function getWidget(s: string): Widget[];\nReusable Types (Interfaces)\n\nDocumentation\n\nWhen specifying a greeting, you must pass a GreetingSettings object. This object has the following properties:\n\n1 - greeting: Mandatory string\n\n2 - duration: Optional length of time (in milliseconds)\n\n3 - color: Optional string, e.g. ‘#ff00ff’\n\nCode\n\ngreet({\n  greeting: \"hello world\",\n  duration: 4000\n});\n\nDeclaration\n\nUse an interface to define a type with properties.\n\ninterface GreetingSettings {\n  greeting: string;\n  duration?: number;\n  color?: string;\n}\ndeclare function greet(setting: GreetingSettings): void;\nReusable Types (Type Aliases)\n\nDocumentation\n\nAnywhere a greeting is expected, you can provide a string, a function returning a string, or a Greeter instance.\n\nCode\n\nfunction getGreeting() {\n  return \"howdy\";\n}\nclass MyGreeter extends Greeter {}\ngreet(\"hello\");\ngreet(getGreeting);\ngreet(new MyGreeter());\n\nDeclaration\n\nYou can use a type alias to make a shorthand for a type:\n\ntype GreetingLike = string | (() => string) | MyGreeter;\ndeclare function greet(g: GreetingLike): void;\nOrganizing Types\n\nDocumentation\n\nThe greeter object can log to a file or display an alert. You can provide LogOptions to .log(...) and alert options to .alert(...)\n\nCode\n\nconst g = new Greeter(\"Hello\");\ng.log({ verbose: true });\ng.alert({ modal: false, title: \"Current Greeting\" });\n\nDeclaration\n\nUse namespaces to organize types.\n\ndeclare namespace GreetingLib {\n  interface LogOptions {\n    verbose?: boolean;\n  }\n  interface AlertOptions {\n    modal: boolean;\n    title?: string;\n    color?: string;\n  }\n}\n\nYou can also create nested namespaces in one declaration:\n\ndeclare namespace GreetingLib.Options {\n  // Refer to via GreetingLib.Options.Log\n  interface Log {\n    verbose?: boolean;\n  }\n  interface Alert {\n    modal: boolean;\n    title?: string;\n    color?: string;\n  }\n}\nClasses\n\nDocumentation\n\nYou can create a greeter by instantiating the Greeter object, or create a customized greeter by extending from it.\n\nCode\n\nconst myGreeter = new Greeter(\"hello, world\");\nmyGreeter.greeting = \"howdy\";\nmyGreeter.showGreeting();\nclass SpecialGreeter extends Greeter {\n  constructor() {\n    super(\"Very special greetings\");\n  }\n}\n\nDeclaration\n\nUse declare class to describe a class or class-like object. Classes can have properties and methods as well as a constructor.\n\ndeclare class Greeter {\n  constructor(greeting: string);\n  greeting: string;\n  showGreeting(): void;\n}\nGlobal Variables\n\nDocumentation\n\nThe global variable foo contains the number of widgets present.\n\nCode\n\nconsole.log(\"Half the number of widgets is \" + foo / 2);\n\nDeclaration\n\nUse declare var to declare variables. If the variable is read-only, you can use declare const. You can also use declare let if the variable is block-scoped.\n\n/** The number of widgets present */\ndeclare var foo: number;\nGlobal Functions\n\nDocumentation\n\nYou can call the function greet with a string to show a greeting to the user.\n\nCode\n\ngreet(\"hello, world\");\n\nDeclaration\n\nUse declare function to declare functions.\n\ndeclare function greet(greeting: string): void;\nOn this page\nObjects with Properties\nOverloaded Functions\nReusable Types (Interfaces)\nReusable Types (Type Aliases)\nOrganizing Types\nClasses\nGlobal Variables\nGlobal Functions\nIs this page helpful?\nYes\nNo\nPrevious\nIntroduction\n\nHow to write a high-quality TypeScript Declaration (d.ts) file\n\nNext\nLibrary Structures\n\nHow to structure your d.ts files\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nY\nPB\nRK\n7+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.888 seconds."
  },
  {
    "title": "TypeScript: Documentation - Modules .d.ts",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/templates/module-d-ts.html",
    "html": "Modules .d.ts\nComparing JavaScript to an example DTS\nCommon CommonJS Patterns\n\nA module using CommonJS patterns uses module.exports to describe the exported values. For example, here is a module which exports a function and a numerical constant:\n\nconst maxInterval = 12;\nfunction getArrayLength(arr) {\n  return arr.length;\n}\nmodule.exports = {\n  getArrayLength,\n  maxInterval,\n};\n\nThis can be described by the following .d.ts:\n\nexport function getArrayLength(arr: any[]): number;\nexport const maxInterval: 12;\n\nThe TypeScript playground can show you the .d.ts equivalent for JavaScript code. You can try it yourself here.\n\nThe .d.ts syntax intentionally looks like ES Modules syntax. ES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules:\n\nexport function getArrayLength(arr) {\n  return arr.length;\n}\n\nThis would have the following .d.ts equivalent:\n\nexport function getArrayLength(arr: any[]): number;\nDefault Exports\n\nIn CommonJS you can export any value as the default export, for example here is a regular expression module:\n\nmodule.exports = /hello( world)?/;\n\nWhich can be described by the following .d.ts:\n\ndeclare const helloWorld: RegExp;\nexport default helloWorld;\n\nOr a number:\n\nmodule.exports = 3.142;\ndeclare const pi: number;\nexport default pi;\n\nOne style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added and are included in the export.\n\nfunction getArrayLength(arr) {\n  return arr.length;\n}\ngetArrayLength.maxInterval = 12;\nmodule.exports = getArrayLength;\n\nWhich can be described with:\n\nexport default function getArrayLength(arr: any[]): number;\nexport const maxInterval: 12;\n\nNote that using export default in your .d.ts files requires esModuleInterop: true to work. If you can’t have esModuleInterop: true in your project, such as when you’re submitting a PR to Definitely Typed, you’ll have to use the export= syntax instead. This older syntax is harder to use but works everywhere. Here’s how the above example would have to be written using export=:\n\ndeclare function getArrayLength(arr: any[]): number;\ndeclare namespace getArrayLength {\n  declare const maxInterval: 12;\n}\nexport = getArrayLength;\n\nSee Module: Functions for details of how that works, and the Modules reference page.\n\nHandling Many Consuming Import\n\nThere are many ways to import a module in modern consuming code:\n\nconst fastify = require(\"fastify\");\nconst { fastify } = require(\"fastify\");\nimport fastify = require(\"fastify\");\nimport * as Fastify from \"fastify\";\nimport { fastify, FastifyInstance } from \"fastify\";\nimport fastify from \"fastify\";\nimport fastify, { FastifyInstance } from \"fastify\";\n\nCovering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like:\n\nclass FastifyInstance {}\nfunction fastify() {\n  return new FastifyInstance();\n}\nfastify.FastifyInstance = FastifyInstance;\n// Allows for { fastify }\nfastify.fastify = fastify;\n// Allows for strict ES Module support\nfastify.default = fastify;\n// Sets the default export\nmodule.exports = fastify;\nTypes in Modules\n\nYou may want to provide a type for JavaScript code which does not exist\n\nfunction getArrayMetadata(arr) {\n  return {\n    length: getArrayLength(arr),\n    firstObject: arr[0],\n  };\n}\nmodule.exports = {\n  getArrayMetadata,\n};\n\nThis can be described with:\n\nexport type ArrayMetadata = {\n  length: number;\n  firstObject: any | undefined;\n};\nexport function getArrayMetadata(arr: any[]): ArrayMetadata;\n\nThis example is a good case for using generics to provide richer type information:\n\nexport type ArrayMetadata<ArrType> = {\n  length: number;\n  firstObject: ArrType | undefined;\n};\nexport function getArrayMetadata<ArrType>(\n  arr: ArrType[]\n): ArrayMetadata<ArrType>;\n\nNow the type of the array propagates into the ArrayMetadata type.\n\nThe types which are exported can then be re-used by consumers of the modules using either import or import type in TypeScript code or JSDoc imports.\n\nNamespaces in Module Code\n\nTrying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can use namespaces.\n\nFor example, you may have complex enough types to describe that you choose to namespace them inside your .d.ts:\n\n// This represents the JavaScript class which would be available at runtime\nexport class API {\n  constructor(baseURL: string);\n  getInfo(opts: API.InfoRequest): API.InfoResponse;\n}\n// This namespace is merged with the API class and allows for consumers, and this file\n// to have types which are nested away in their own sections.\ndeclare namespace API {\n  export interface InfoRequest {\n    id: string;\n  }\n  export interface InfoResponse {\n    width: number;\n    height: number;\n  }\n}\n\nTo understand how namespaces work in .d.ts files read the .d.ts deep dive.\n\nOptional Global Usage\n\nYou can use export as namespace to declare that your module will be available in the global scope in UMD contexts:\n\nexport as namespace moduleName;\nReference Example\n\nTo give you an idea of how all these pieces can come together, here is a reference .d.ts to start with when making a new module\n\n// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]\n// Project: [~THE PROJECT NAME~]\n// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>\n/*~ This is the module template file. You should rename it to index.d.ts\n *~ and place it in a folder with the same name as the module.\n *~ For example, if you were writing a file for \"super-greeter\", this\n *~ file should be 'super-greeter/index.d.ts'\n */\n/*~ If this module is a UMD module that exposes a global variable 'myLib' when\n *~ loaded outside a module loader environment, declare that global here.\n *~ Otherwise, delete this declaration.\n */\nexport as namespace myLib;\n/*~ If this module exports functions, declare them like so.\n */\nexport function myFunction(a: string): string;\nexport function myOtherFunction(a: number): number;\n/*~ You can declare types that are available via importing the module */\nexport interface SomeType {\n  name: string;\n  length: number;\n  extras?: string[];\n}\n/*~ You can declare properties of the module using const, let, or var */\nexport const myField: number;\nLibrary file layout\n\nThe layout of your declaration files should mirror the layout of the library.\n\nA library can consist of multiple modules, such as\n\nmyLib\n  +---- index.js\n  +---- foo.js\n  +---- bar\n         +---- index.js\n         +---- baz.js\n\nThese could be imported as\n\nvar a = require(\"myLib\");\nvar b = require(\"myLib/foo\");\nvar c = require(\"myLib/bar\");\nvar d = require(\"myLib/bar/baz\");\n\nYour declaration files should thus be\n\n@types/myLib\n  +---- index.d.ts\n  +---- foo.d.ts\n  +---- bar\n         +---- index.d.ts\n         +---- baz.d.ts\nTesting your types\n\nIf you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you:\n\nCreate a new folder in node_modules/@types/[libname]\nCreate an index.d.ts in that folder, and copy the example in\nSee where your usage of the module breaks, and start to fill out the index.d.ts\nWhen you’re happy, clone DefinitelyTyped/DefinitelyTyped and follow the instructions in the README.\n\nOtherwise\n\nCreate a new file in the root of your source tree: [libname].d.ts\nAdd declare module \"[libname]\" { }\nAdd the template inside the braces of the declare module, and see where your usage breaks\nOn this page\nComparing JavaScript to an example DTS\nCommon CommonJS Patterns\nDefault Exports\nHandling Many Consuming Import\nTypes in Modules\nNamespaces in Module Code\nOptional Global Usage\nReference Example\nLibrary file layout\nTesting your types\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nMF\nH\nGS\n4+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 1.129 seconds."
  },
  {
    "title": "TypeScript: Documentation - Introduction",
    "url": "https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html",
    "html": "Introduction\n\nThe Declaration Files section is designed to teach you how to write a high-quality TypeScript Declaration File. We need to assume basic familiarity with the TypeScript language in order to get started.\n\nIf you haven’t already, you should read the TypeScript Handbook to familiarize yourself with basic concepts, especially types and modules.\n\nThe most common case for learning how .d.ts files work is that you’re typing an npm package with no types. In that case, you can jump straight to Modules .d.ts.\n\nThe Declaration Files section is broken down into the following sections.\n\nDeclaration Reference\n\nWe are often faced with writing a declaration file when we only have examples of the underlying library to guide us. The Declaration Reference section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.\n\nLibrary Structures\n\nThe Library Structures guide helps you understand common library formats and how to write a proper declaration file for each format. If you’re editing an existing file, you probably don’t need to read this section. Authors of new declaration files are strongly encouraged to read this section to properly understand how the format of the library influences the writing of the declaration file.\n\nIn the Template section you’ll find a number of declaration files that serve as a useful starting point when writing a new file. If you already know what your structure is, see the d.ts Template section in the sidebar.\n\nDo’s and Don’ts\n\nMany common mistakes in declaration files can be easily avoided. The Do’s and Don’ts section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.\n\nDeep Dive\n\nFor seasoned authors interested in the underlying mechanics of how declaration files work, the Deep Dive section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.\n\nPublish to npm\n\nThe Publishing section explains how to publish your declaration files to an npm package, and shows how to manage your dependent packages.\n\nFind and Install Declaration Files\n\nFor JavaScript library users, the Consumption section offers a few simple steps to locate and install corresponding declaration files.\n\nOn this page\nDeclaration Reference\nLibrary Structures\nDo’s and Don’ts\nDeep Dive\nPublish to npm\nFind and Install Declaration Files\nIs this page helpful?\nYes\nNo\nNext\nDeclaration Reference\n\nHow to create a d.ts file for a module\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nJW\nNR\nDK\n11+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 3.344 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 1.3",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-3.html",
    "html": "TypeScript 1.3\nProtected\n\nThe new protected modifier in classes works like it does in familiar languages like C++, C#, and Java. A protected member of a class is visible only inside subclasses of the class in which it is declared:\n\nclass Thing {\n  protected doSomething() {\n    /* ... */\n  }\n}\nclass MyThing extends Thing {\n  public myMethod() {\n    // OK, can access protected member from subclass\n    this.doSomething();\n  }\n}\nvar t = new MyThing();\nt.doSomething(); // Error, cannot call protected member from outside class\nTuple types\n\nTuple types express an array where the type of certain elements is known, but need not be the same. For example, you may want to represent an array with a string at position 0 and a number at position 1:\n\n// Declare a tuple type\nvar x: [string, number];\n// Initialize it\nx = [\"hello\", 10]; // OK\n// Initialize it incorrectly\nx = [10, \"hello\"]; // Error\n\nWhen accessing an element with a known index, the correct type is retrieved:\n\nconsole.log(x[0].substr(1)); // OK\nconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr'\n\nNote that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:\n\nx[3] = \"world\"; // OK\nconsole.log(x[5].toString()); // OK, 'string' and 'number' both have toString\nx[6] = true; // Error, boolean isn't number or string\nOn this page\nProtected\nTuple types\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 3.901 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 1.1",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-1.html",
    "html": "TypeScript 1.1\nPerformance Improvements\n\nThe 1.1 compiler is typically around 4x faster than any previous release. See this blog post for some impressive charts.\n\nBetter Module Visibility Rules\n\nTypeScript now only strictly enforces the visibility of types in modules if the declaration flag is provided. This is very useful for Angular scenarios, for example:\n\nmodule MyControllers {\n  interface ZooScope extends ng.IScope {\n    animals: Animal[];\n  }\n  export class ZooController {\n    // Used to be an error (cannot expose ZooScope), but now is only\n    // an error when trying to generate .d.ts files\n    constructor(public $scope: ZooScope) {}\n    /* more code */\n  }\n}\nOn this page\nPerformance Improvements\nBetter Module Visibility Rules\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nMHK\nJB\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 3.489 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.0",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html",
    "html": "TypeScript 4.0\nVariadic Tuple Types\n\nConsider a function in JavaScript called concat that takes two array or tuple types and concatenates them together to make a new array.\n\nfunction concat(arr1, arr2) {\n  return [...arr1, ...arr2];\n}\n\nAlso consider tail, that takes an array or tuple, and returns all elements but the first.\n\nfunction tail(arg) {\n  const [_, ...result] = arg;\n  return result;\n}\n\nHow would we type either of these in TypeScript?\n\nFor concat, the only valid thing we could do in older versions of the language was to try and write some overloads.\n\nfunction concat(arr1: [], arr2: []): [];\nfunction concat<A>(arr1: [A], arr2: []): [A];\nfunction concat<A, B>(arr1: [A, B], arr2: []): [A, B];\nfunction concat<A, B, C>(arr1: [A, B, C], arr2: []): [A, B, C];\nfunction concat<A, B, C, D>(arr1: [A, B, C, D], arr2: []): [A, B, C, D];\nfunction concat<A, B, C, D, E>(arr1: [A, B, C, D, E], arr2: []): [A, B, C, D, E];\nfunction concat<A, B, C, D, E, F>(arr1: [A, B, C, D, E, F], arr2: []): [A, B, C, D, E, F];\n\nUh…okay, that’s…seven overloads for when the second array is always empty. Let’s add some for when arr2 has one argument.\n\nfunction concat<A2>(arr1: [], arr2: [A2]): [A2];\nfunction concat<A1, A2>(arr1: [A1], arr2: [A2]): [A1, A2];\nfunction concat<A1, B1, A2>(arr1: [A1, B1], arr2: [A2]): [A1, B1, A2];\nfunction concat<A1, B1, C1, A2>(arr1: [A1, B1, C1], arr2: [A2]): [A1, B1, C1, A2];\nfunction concat<A1, B1, C1, D1, A2>(arr1: [A1, B1, C1, D1], arr2: [A2]): [A1, B1, C1, D1, A2];\nfunction concat<A1, B1, C1, D1, E1, A2>(arr1: [A1, B1, C1, D1, E1], arr2: [A2]): [A1, B1, C1, D1, E1, A2];\nfunction concat<A1, B1, C1, D1, E1, F1, A2>(arr1: [A1, B1, C1, D1, E1, F1], arr2: [A2]): [A1, B1, C1, D1, E1, F1, A2];\n\nWe hope it’s clear that this is getting unreasonable. Unfortunately, you’d also end up with the same sorts of issues typing a function like tail.\n\nThis is another case of what we like to call “death by a thousand overloads”, and it doesn’t even solve the problem generally. It only gives correct types for as many overloads as we care to write. If we wanted to make a catch-all case, we’d need an overload like the following:\n\nfunction concat<T, U>(arr1: T[], arr2: U[]): Array<T | U>;\n\nBut that signature doesn’t encode anything about the lengths of the input, or the order of the elements, when using tuples.\n\nTypeScript 4.0 brings two fundamental changes, along with inference improvements, to make typing these possible.\n\nThe first change is that spreads in tuple type syntax can now be generic. This means that we can represent higher-order operations on tuples and arrays even when we don’t know the actual types we’re operating over. When generic spreads are instantiated (or, replaced with a real type) in these tuple types, they can produce other sets of array and tuple types.\n\nFor example, that means we can type function like tail, without our “death by a thousand overloads” issue.\n\nfunction tail<T extends any[]>(arr: readonly [any, ...T]) {\n  const [_ignored, ...rest] = arr;\n  return rest;\n}\n \nconst myTuple = [1, 2, 3, 4] as const;\nconst myArray = [\"hello\", \"world\"];\n \nconst r1 = tail(myTuple);\n      \nconst r1: [2, 3, 4]\n \nconst r2 = tail([...myTuple, ...myArray] as const);\n      \nconst r2: [2, 3, 4, ...string[]]\nTry\n\nThe second change is that rest elements can occur anywhere in a tuple - not just at the end!\n\ntype Strings = [string, string];\ntype Numbers = [number, number];\ntype StrStrNumNumBool = [...Strings, ...Numbers, boolean];\n\nPreviously, TypeScript would issue an error like the following:\n\nA rest element must be last in a tuple type.\n\nBut with TypeScript 4.0, this restriction is relaxed.\n\nNote that in cases when we spread in a type without a known length, the resulting type becomes unbounded as well, and all the following elements factor into the resulting rest element type.\n\ntype Strings = [string, string];\ntype Numbers = number[];\ntype Unbounded = [...Strings, ...Numbers, boolean];\n\nBy combining both of these behaviors together, we can write a single well-typed signature for concat:\n\ntype Arr = readonly any[];\n \nfunction concat<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U] {\n  return [...arr1, ...arr2];\n}\nTry\n\nWhile that one signature is still a bit lengthy, it’s just one signature that doesn’t have to be repeated, and it gives predictable behavior on all arrays and tuples.\n\nThis functionality on its own is great, but it shines in more sophisticated scenarios too. For example, consider a function to partially apply arguments called partialCall. partialCall takes a function - let’s call it f - along with the initial few arguments that f expects. It then returns a new function that takes any other arguments that f still needs, and calls f when it receives them.\n\nfunction partialCall(f, ...headArgs) {\n  return (...tailArgs) => f(...headArgs, ...tailArgs);\n}\n\nTypeScript 4.0 improves the inference process for rest parameters and rest tuple elements so that we can type this and have it “just work”.\n\ntype Arr = readonly unknown[];\n \nfunction partialCall<T extends Arr, U extends Arr, R>(\n  f: (...args: [...T, ...U]) => R,\n  ...headArgs: T\n) {\n  return (...tailArgs: U) => f(...headArgs, ...tailArgs);\n}\nTry\n\nIn this case, partialCall understands which parameters it can and can’t initially take, and returns functions that appropriately accept and reject anything left over.\n\nconst foo = (x: string, y: number, z: boolean) => {};\n \nconst f1 = partialCall(foo, 100);\nArgument of type 'number' is not assignable to parameter of type 'string'.\nArgument of type 'number' is not assignable to parameter of type 'string'.\n \nconst f2 = partialCall(foo, \"hello\", 100, true, \"oops\");\nExpected 4 arguments, but got 5.\nExpected 4 arguments, but got 5.\n \n// This works!\nconst f3 = partialCall(foo, \"hello\");\n      \nconst f3: (y: number, z: boolean) => void\n \n// What can we do with f3 now?\n \n// Works!\nf3(123, true);\n \nf3();\nExpected 2 arguments, but got 0.\nExpected 2 arguments, but got 0.\n \nf3(123, \"hello\");\nArgument of type 'string' is not assignable to parameter of type 'boolean'.\nArgument of type 'string' is not assignable to parameter of type 'boolean'.\nTry\n\nVariadic tuple types enable a lot of new exciting patterns, especially around function composition. We expect we may be able to leverage it to do a better job type-checking JavaScript’s built-in bind method. A handful of other inference improvements and patterns also went into this, and if you’re interested in learning more, you can take a look at the pull request for variadic tuples.\n\nLabeled Tuple Elements\n\nImproving the experience around tuple types and parameter lists is important because it allows us to get strongly typed validation around common JavaScript idioms - really just slicing and dicing argument lists and passing them to other functions. The idea that we can use tuple types for rest parameters is one place where this is crucial.\n\nFor example, the following function that uses a tuple type as a rest parameter…\n\nfunction foo(...args: [string, number]): void {\n  // ...\n}\n\n…should appear no different from the following function…\n\nfunction foo(arg0: string, arg1: number): void {\n  // ...\n}\n\n…for any caller of foo.\n\nfoo(\"hello\", 42);\n \nfoo(\"hello\", 42, true);\nExpected 2 arguments, but got 3.\nExpected 2 arguments, but got 3.\nfoo(\"hello\");\nExpected 2 arguments, but got 1.\nExpected 2 arguments, but got 1.\nTry\n\nThere is one place where the differences begin to become observable though: readability. In the first example, we have no parameter names for the first and second elements. While these have no impact on type-checking, the lack of labels on tuple positions can make them harder to use - harder to communicate our intent.\n\nThat’s why in TypeScript 4.0, tuples types can now provide labels.\n\ntype Range = [start: number, end: number];\n\nTo deepen the connection between parameter lists and tuple types, the syntax for rest elements and optional elements mirrors the syntax for parameter lists.\n\ntype Foo = [first: number, second?: string, ...rest: any[]];\n\nThere are a few rules when using labeled tuples. For one, when labeling a tuple element, all other elements in the tuple must also be labeled.\n\ntype Bar = [first: string, number];\nTuple members must all have names or all not have names.\nTuple members must all have names or all not have names.\nTry\n\nIt’s worth noting - labels don’t require us to name our variables differently when destructuring. They’re purely there for documentation and tooling.\n\nfunction foo(x: [first: string, second: number]) {\n    // ...\n \n    // note: we didn't need to name these 'first' and 'second'\n    const [a, b] = x;\n    a\n   \nconst a: string\n    b\n   \nconst b: number\n}\nTry\n\nOverall, labeled tuples are handy when taking advantage of patterns around tuples and argument lists, along with implementing overloads in a type-safe way. In fact, TypeScript’s editor support will try to display them as overloads when possible.\n\nTo learn more, check out the pull request for labeled tuple elements.\n\nClass Property Inference from Constructors\n\nTypeScript 4.0 can now use control flow analysis to determine the types of properties in classes when noImplicitAny is enabled.\n\nclass Square {\n  // Previously both of these were any\n  area;\n   \n(property) Square.area: number\n  sideLength;\n      \n(property) Square.sideLength: number\n  constructor(sideLength: number) {\n    this.sideLength = sideLength;\n    this.area = sideLength ** 2;\n  }\n}\nTry\n\nIn cases where not all paths of a constructor assign to an instance member, the property is considered to potentially be undefined.\n\nclass Square {\n  sideLength;\n      \n(property) Square.sideLength: number | undefined\n \n  constructor(sideLength: number) {\n    if (Math.random()) {\n      this.sideLength = sideLength;\n    }\n  }\n \n  get area() {\n    return this.sideLength ** 2;\nObject is possibly 'undefined'.\nObject is possibly 'undefined'.\n  }\n}\nTry\n\nIn cases where you know better (e.g. you have an initialize method of some sort), you’ll still need an explicit type annotation along with a definite assignment assertion (!) if you’re in strictPropertyInitialization.\n\nclass Square {\n  // definite assignment assertion\n  //        v\n  sideLength!: number;\n  // type annotation\n \n  constructor(sideLength: number) {\n    this.initialize(sideLength);\n  }\n \n  initialize(sideLength: number) {\n    this.sideLength = sideLength;\n  }\n \n  get area() {\n    return this.sideLength ** 2;\n  }\n}\nTry\n\nFor more details, see the implementing pull request.\n\nShort-Circuiting Assignment Operators\n\nJavaScript, and a lot of other languages, support a set of operators called compound assignment operators. Compound assignment operators apply an operator to two arguments, and then assign the result to the left side. You may have seen these before:\n\n// Addition\n// a = a + b\na += b;\n// Subtraction\n// a = a - b\na -= b;\n// Multiplication\n// a = a * b\na *= b;\n// Division\n// a = a / b\na /= b;\n// Exponentiation\n// a = a ** b\na **= b;\n// Left Bit Shift\n// a = a << b\na <<= b;\n\nSo many operators in JavaScript have a corresponding assignment operator! Up until recently, however, there were three notable exceptions: logical and (&&), logical or (||), and nullish coalescing (??).\n\nThat’s why TypeScript 4.0 supports a new ECMAScript feature to add three new assignment operators: &&=, ||=, and ??=.\n\nThese operators are great for substituting any example where a user might write code like the following:\n\na = a && b;\na = a || b;\na = a ?? b;\n\nOr a similar if block like\n\n// could be 'a ||= b'\nif (!a) {\n  a = b;\n}\n\nThere are even some patterns we’ve seen (or, uh, written ourselves) to lazily initialize values, only if they’ll be needed.\n\nlet values: string[];\n(values ?? (values = [])).push(\"hello\");\n// After\n(values ??= []).push(\"hello\");\n\n(look, we’re not proud of all the code we write…)\n\nOn the rare case that you use getters or setters with side-effects, it’s worth noting that these operators only perform assignments if necessary. In that sense, not only is the right side of the operator “short-circuited” - the assignment itself is too.\n\nobj.prop ||= foo();\n// roughly equivalent to either of the following\nobj.prop || (obj.prop = foo());\nif (!obj.prop) {\n    obj.prop = foo();\n}\n\nTry running the following example to see how that differs from always performing the assignment.\n\nconst obj = {\n    get prop() {\n        console.log(\"getter has run\");\n \n        // Replace me!\n        return Math.random() < 0.5;\n    },\n    set prop(_val: boolean) {\n        console.log(\"setter has run\");\n    }\n};\n \nfunction foo() {\n    console.log(\"right side evaluated\");\n    return true;\n}\n \nconsole.log(\"This one always runs the setter\");\nobj.prop = obj.prop || foo();\n \nconsole.log(\"This one *sometimes* runs the setter\");\nobj.prop ||= foo();\nTry\n\nWe’d like to extend a big thanks to community member Wenlu Wang for this contribution!\n\nFor more details, you can take a look at the pull request here. You can also check out TC39’s proposal repository for this feature.\n\nunknown\n on \ncatch\n Clause Bindings\n\nSince the beginning days of TypeScript, catch clause variables have always been typed as any. This meant that TypeScript allowed you to do anything you wanted with them.\n\ntry {\n  // Do some work\n} catch (x) {\n  // x has type 'any' - have fun!\n  console.log(x.message);\n  console.log(x.toUpperCase());\n  x++;\n  x.yadda.yadda.yadda();\n}\nTry\n\nThe above has some undesirable behavior if we’re trying to prevent more errors from happening in our error-handling code! Because these variables have the type any by default, they lack any type-safety which could have errored on invalid operations.\n\nThat’s why TypeScript 4.0 now lets you specify the type of catch clause variables as unknown instead. unknown is safer than any because it reminds us that we need to perform some sorts of type-checks before operating on our values.\n\ntry {\n  // ...\n} catch (e: unknown) {\n  // Can't access values on unknowns\n  console.log(e.toUpperCase());\n'e' is of type 'unknown'.\n'e' is of type 'unknown'.\n \n  if (typeof e === \"string\") {\n    // We've narrowed 'e' down to the type 'string'.\n    console.log(e.toUpperCase());\n  }\n}\nTry\n\nWhile the types of catch variables won’t change by default, we might consider a new strict mode flag in the future so that users can opt in to this behavior. In the meantime, it should be possible to write a lint rule to force catch variables to have an explicit annotation of either : any or : unknown.\n\nFor more details you can peek at the changes for this feature.\n\nCustom JSX Factories\n\nWhen using JSX, a fragment is a type of JSX element that allows us to return multiple child elements. When we first implemented fragments in TypeScript, we didn’t have a great idea about how other libraries would utilize them. Nowadays most other libraries that encourage using JSX and support fragments have a similar API shape.\n\nIn TypeScript 4.0, users can customize the fragment factory through the new jsxFragmentFactory option.\n\nAs an example, the following tsconfig.json file tells TypeScript to transform JSX in a way compatible with React, but switches each factory invocation to h instead of React.createElement, and uses Fragment instead of React.Fragment.\n\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"commonjs\",\n    \"jsx\": \"react\",\n    \"jsxFactory\": \"h\",\n    \"jsxFragmentFactory\": \"Fragment\"\n  }\n}\n\nIn cases where you need to have a different JSX factory on a per-file basis, you can take advantage of the new /** @jsxFrag */ pragma comment. For example, the following…\n\n// Note: these pragma comments need to be written\n// with a JSDoc-style multiline syntax to take effect.\n \n/** @jsx h */\n/** @jsxFrag Fragment */\n \nimport { h, Fragment } from \"preact\";\n \nexport const Header = (\n  <>\n    <h1>Welcome</h1>\n  </>\n);\nTry\n\n…will get transformed to this output JavaScript…\n\nimport React from 'react';\nexport const Header = (React.createElement(React.Fragment, null,\n    React.createElement(\"h1\", null, \"Welcome\")));\n \nTry\n\nWe’d like to extend a big thanks to community member Noj Vek for sending this pull request and patiently working with our team on it.\n\nYou can see that the pull request for more details!\n\nSpeed Improvements in \nbuild\n mode with \n--noEmitOnError\n\nPreviously, compiling a program after a previous compile with errors under incremental would be extremely slow when using the noEmitOnError flag. This is because none of the information from the last compilation would be cached in a .tsbuildinfo file based on the noEmitOnError flag.\n\nTypeScript 4.0 changes this which gives a great speed boost in these scenarios, and in turn improves --build mode scenarios (which imply both incremental and noEmitOnError).\n\nFor details, read up more on the pull request.\n\n--incremental\n with \n--noEmit\n\nTypeScript 4.0 allows us to use the noEmit flag when while still leveraging incremental compiles. This was previously not allowed, as incremental needs to emit a .tsbuildinfo files; however, the use-case to enable faster incremental builds is important enough to enable for all users.\n\nFor more details, you can see the implementing pull request.\n\nEditor Improvements\n\nThe TypeScript compiler doesn’t only power the editing experience for TypeScript itself in most major editors - it also powers the JavaScript experience in the Visual Studio family of editors and more. For that reason, much of our work focuses on improving editor scenarios - the place you spend most of your time as a developer.\n\nUsing new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but\n\nVisual Studio Code supports selecting different versions of TypeScript. Alternatively, there’s the JavaScript/TypeScript Nightly Extension to stay on the bleeding edge (which is typically very stable).\nVisual Studio 2017/2019 have [the SDK installers above] and MSBuild installs.\nSublime Text 3 supports selecting different versions of TypeScript\n\nYou can check out a partial list of editors that have support for TypeScript to learn more about whether your favorite editor has support to use new versions.\n\nConvert to Optional Chaining\n\nOptional chaining is a recent feature that’s received a lot of love. That’s why TypeScript 4.0 brings a new refactoring to convert common patterns to take advantage of optional chaining and nullish coalescing!\n\nKeep in mind that while this refactoring doesn’t perfectly capture the same behavior due to subtleties with truthiness/falsiness in JavaScript, we believe it should capture the intent for most use-cases, especially when TypeScript has more precise knowledge of your types.\n\nFor more details, check out the pull request for this feature.\n\n/** @deprecated */\n Support\n\nTypeScript’s editing support now recognizes when a declaration has been marked with a /** @deprecated */ JSDoc comment. That information is surfaced in completion lists and as a suggestion diagnostic that editors can handle specially. In an editor like VS Code, deprecated values are typically displayed a strike-though style like this.\n\nThis new functionality is available thanks to Wenlu Wang. See the pull request for more details.\n\nPartial Semantic Mode at Startup\n\nWe’ve heard a lot from users suffering from long startup times, especially on bigger projects. The culprit is usually a process called program construction. This is the process of starting with an initial set of root files, parsing them, finding their dependencies, parsing those dependencies, finding those dependencies’ dependencies, and so on. The bigger your project is, the longer you’ll have to wait before you can get basic editor operations like go-to-definition or quick info.\n\nThat’s why we’ve been working on a new mode for editors to provide a partial experience until the full language service experience has loaded up. The core idea is that editors can run a lightweight partial server that only looks at the current files that the editor has open.\n\nIt’s hard to say precisely what sorts of improvements you’ll see, but anecdotally, it used to take anywhere between 20 seconds to a minute before TypeScript would become fully responsive on the Visual Studio Code codebase. In contrast, our new partial semantic mode seems to bring that delay down to just a few seconds. As an example, in the following video, you can see two side-by-side editors with TypeScript 3.9 running on the left and TypeScript 4.0 running on the right.\n\nWhen restarting both editors on a particularly large codebase, the one with TypeScript 3.9 can’t provide completions or quick info at all. On the other hand, the editor with TypeScript 4.0 can immediately give us a rich experience in the current file we’re editing, despite loading the full project in the background.\n\nCurrently the only editor that supports this mode is Visual Studio Code which has some UX improvements coming up in Visual Studio Code Insiders. We recognize that this experience may still have room for polish in UX and functionality, and we have a list of improvements in mind. We’re looking for more feedback on what you think might be useful.\n\nFor more information, you can see the original proposal, the implementing pull request, along with the follow-up meta issue.\n\nSmarter Auto-Imports\n\nAuto-import is a fantastic feature that makes coding a lot easier; however, every time auto-import doesn’t seem to work, it can throw users off a lot. One specific issue that we heard from users was that auto-imports didn’t work on dependencies that were written in TypeScript - that is, until they wrote at least one explicit import somewhere else in their project.\n\nWhy would auto-imports work for @types packages, but not for packages that ship their own types? It turns out that auto-imports only work on packages your project already includes. Because TypeScript has some quirky defaults that automatically add packages in node_modules/@types to your project, those packages would be auto-imported. On the other hand, other packages were excluded because crawling through all your node_modules packages can be really expensive.\n\nAll of this leads to a pretty lousy getting started experience for when you’re trying to auto-import something that you’ve just installed but haven’t used yet.\n\nTypeScript 4.0 now does a little extra work in editor scenarios to include the packages you’ve listed in your package.json’s dependencies (and peerDependencies) fields. The information from these packages is only used to improve auto-imports, and doesn’t change anything else like type-checking. This allows us to provide auto-imports for all of your dependencies that have types, without incurring the cost of a complete node_modules search.\n\nIn the rare cases when your package.json lists more than ten typed dependencies that haven’t been imported yet, this feature automatically disables itself to prevent slow project loading. To force the feature to work, or to disable it entirely, you should be able to configure your editor. For Visual Studio Code, this is the “Include Package JSON Auto Imports” (or typescript.preferences.includePackageJsonAutoImports) setting.\n\n For more details, you can see the proposal issue along with the implementing pull request.\n\nOur New Website!\n\nThe TypeScript website has recently been rewritten from the ground up and rolled out!\n\nWe already wrote a bit about our new site, so you can read up more there; but it’s worth mentioning that we’re still looking to hear what you think! If you have questions, comments, or suggestions, you can file them over on the website’s issue tracker.\n\nBreaking Changes\nlib.d.ts\n Changes\n\nOur lib.d.ts declarations have changed - most specifically, types for the DOM have changed. The most notable change may be the removal of document.origin which only worked in old versions of IE and Safari MDN recommends moving to self.origin.\n\nProperties Overriding Accessors (and vice versa) is an Error\n\nPreviously, it was only an error for properties to override accessors, or accessors to override properties, when using useDefineForClassFields; however, TypeScript now always issues an error when declaring a property in a derived class that would override a getter or setter in the base class.\n\nclass Base {\n  get foo() {\n    return 100;\n  }\n  set foo(value) {\n    // ...\n  }\n}\n \nclass Derived extends Base {\n  foo = 10;\n'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.\n'foo' is defined as an accessor in class 'Base', but is overridden here in 'Derived' as an instance property.\n}\nTry\nclass Base {\n  prop = 10;\n}\n \nclass Derived extends Base {\n  get prop() {\n'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.\n'prop' is defined as a property in class 'Base', but is overridden here in 'Derived' as an accessor.\n    return 100;\n  }\n}\nTry\n\nSee more details on the implementing pull request.\n\nOperands for \ndelete\n must be optional.\n\nWhen using the delete operator in strictNullChecks, the operand must now be any, unknown, never, or be optional (in that it contains undefined in the type). Otherwise, use of the delete operator is an error.\n\ninterface Thing {\n  prop: string;\n}\n \nfunction f(x: Thing) {\n  delete x.prop;\nThe operand of a 'delete' operator must be optional.\nThe operand of a 'delete' operator must be optional.\n}\nTry\n\nSee more details on the implementing pull request.\n\nUsage of TypeScript’s Node Factory is Deprecated\n\nToday TypeScript provides a set of “factory” functions for producing AST Nodes; however, TypeScript 4.0 provides a new node factory API. As a result, for TypeScript 4.0 we’ve made the decision to deprecate these older functions in favor of the new ones.\n\nFor more details, read up on the relevant pull request for this change.\n\nOn this page\nVariadic Tuple Types\nLabeled Tuple Elements\nClass Property Inference from Constructors\nShort-Circuiting Assignment Operators\nunknown on catch Clause Bindings\nCustom JSX Factories\nSpeed Improvements in build mode with --noEmitOnError\n--incremental with --noEmit\nEditor Improvements\nConvert to Optional Chaining\n/** @deprecated */ Support\nPartial Semantic Mode at Startup\nSmarter Auto-Imports\nOur New Website!\nBreaking Changes\nlib.d.ts Changes\nProperties Overriding Accessors (and vice versa) is an Error\nOperands for delete must be optional.\nUsage of TypeScript’s Node Factory is Deprecated\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nAB\nA\nJB\nAH\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.297 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 1.8",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-8.html",
    "html": "TypeScript 1.8\nType parameters as constraints\n\nWith TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as F-Bounded Polymorphism.\n\nExample\nfunction assign<T extends U, U>(target: T, source: U): T {\n  for (let id in source) {\n    target[id] = source[id];\n  }\n  return target;\n}\nlet x = { a: 1, b: 2, c: 3, d: 4 };\nassign(x, { b: 10, d: 20 });\nassign(x, { e: 0 }); // Error\nControl flow analysis errors\n\nTypeScript 1.8 introduces control flow analysis to help catch common errors that users tend to run into. Read on to get more details, and check out these errors in action:\n\nUnreachable code\n\nStatements guaranteed to not be executed at run time are now correctly flagged as unreachable code errors. For instance, statements following unconditional return, throw, break or continue statements are considered unreachable. Use allowUnreachableCode to disable unreachable code detection and reporting.\n\nExample\n\nHere’s a simple example of an unreachable code error:\n\nfunction f(x) {\n  if (x) {\n    return true;\n  } else {\n    return false;\n  }\n  x = 0; // Error: Unreachable code detected.\n}\n\nA more common error that this feature catches is adding a newline after a return statement:\n\nfunction f() {\n  return; // Automatic Semicolon Insertion triggered at newline\n  {\n    x: \"string\"; // Error: Unreachable code detected.\n  }\n}\n\nSince JavaScript automatically terminates the return statement at the end of the line, the object literal becomes a block.\n\nUnused labels\n\nUnused labels are also flagged. Just like unreachable code checks, these are turned on by default; use allowUnusedLabels to stop reporting these errors.\n\nExample\nloop: while (x > 0) {\n  // Error: Unused label.\n  x++;\n}\nImplicit returns\n\nFunctions with code paths that do not return a value in JS implicitly return undefined. These can now be flagged by the compiler as implicit returns. The check is turned off by default; use noImplicitReturns to turn it on.\n\nExample\nfunction f(x) {\n  // Error: Not all code paths return a value.\n  if (x) {\n    return false;\n  }\n  // implicitly returns `undefined`\n}\nCase clause fall-throughs\n\nTypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned off by default, and can be enabled using noFallthroughCasesInSwitch.\n\nExample\n\nWith noFallthroughCasesInSwitch, this example will trigger an error:\n\nswitch (x % 2) {\n  case 0: // Error: Fallthrough case in switch.\n    console.log(\"even\");\n  case 1:\n    console.log(\"odd\");\n    break;\n}\n\nHowever, in the following example, no error will be reported because the fall-through case is empty:\n\nswitch (x % 3) {\n  case 0:\n  case 1:\n    console.log(\"Acceptable\");\n    break;\n  case 2:\n    console.log(\"This is *two much*!\");\n    break;\n}\nFunction Components in React\n\nTypeScript now supports Function components. These are lightweight components that easily compose other components:\n\n// Use parameter destructuring and defaults for easy definition of 'props' type\nconst Greeter = ({ name = \"world\" }) => <div>Hello, {name}!</div>;\n// Properties get validated\nlet example = <Greeter name=\"TypeScript 1.8\" />;\n\nFor this feature and simplified props, be sure to be use the latest version of react.d.ts.\n\nSimplified \nprops\n type management in React\n\nIn TypeScript 1.8 with the latest version of react.d.ts (see above), we’ve also greatly simplified the declaration of props types.\n\nSpecifically:\n\nYou no longer need to either explicitly declare ref and key or extend React.Props\nThe ref and key properties will appear with correct types on all components\nThe ref property is correctly disallowed on instances of Stateless Function components\nAugmenting global/module scope from modules\n\nUsers can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the declare module \"foo\" { } syntax), and are directly nested either your own modules, or in another top level ambient external module.\n\nFurthermore, TypeScript also has the notion of global augmentations of the form declare global { }. This allows modules to augment global types such as Array if necessary.\n\nThe name of a module augmentation is resolved using the same set of rules as module specifiers in import and export declarations. The declarations in a module augmentation are merged with any existing declarations the same way they would if they were declared in the same file.\n\nNeither module augmentations nor global augmentations can add new items to the top level scope - they can only “patch” existing declarations.\n\nExample\n\nHere map.ts can declare that it will internally patch the Observable type from observable.ts and add the map method to it.\n\n// observable.ts\nexport class Observable<T> {\n  // ...\n}\n// map.ts\nimport { Observable } from \"./observable\";\n// Create an augmentation for \"./observable\"\ndeclare module \"./observable\" {\n    // Augment the 'Observable' class definition with interface merging\n    interface Observable<T> {\n        map<U>(proj: (el: T) => U): Observable<U>;\n    }\n}\nObservable.prototype.map = /*...*/;\n// consumer.ts\nimport { Observable } from \"./observable\";\nimport \"./map\";\nlet o: Observable<number>;\no.map((x) => x.toFixed());\n\nSimilarly, the global scope can be augmented from modules using a declare global declarations:\n\nExample\n// Ensure this is treated as a module.\nexport {};\ndeclare global {\n  interface Array<T> {\n    mapToNumbers(): number[];\n  }\n}\nArray.prototype.mapToNumbers = function () {\n  /* ... */\n};\nString literal types\n\nIt’s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the “easing” of the animation.\n\ndeclare class UIElement {\n  animate(options: AnimationOptions): void;\n}\ninterface AnimationOptions {\n  deltaX: number;\n  deltaY: number;\n  easing: string; // Can be \"ease-in\", \"ease-out\", \"ease-in-out\"\n}\n\nHowever, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:\n\n// No errors\nnew UIElement().animate({ deltaX: 100, deltaY: 100, easing: \"ease-inout\" });\n\nWith TypeScript 1.8, we’ve introduced string literal types. These types are written the same way string literals are, but in type positions.\n\nUsers can now ensure that the type system will catch such errors. Here’s our new AnimationOptions using string literal types:\n\ninterface AnimationOptions {\n  deltaX: number;\n  deltaY: number;\n  easing: \"ease-in\" | \"ease-out\" | \"ease-in-out\";\n}\n// Error: Type '\"ease-inout\"' is not assignable to type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"'\nnew UIElement().animate({ deltaX: 100, deltaY: 100, easing: \"ease-inout\" });\nImproved union/intersection type inference\n\nTypeScript 1.8 improves type inference involving source and target sides that are both union or intersection types. For example, when inferring from string | string[] to string | T, we reduce the types to string[] and T, thus inferring string[] for T.\n\nExample\ntype Maybe<T> = T | void;\nfunction isDefined<T>(x: Maybe<T>): x is T {\n  return x !== undefined && x !== null;\n}\nfunction isUndefined<T>(x: Maybe<T>): x is void {\n  return x === undefined || x === null;\n}\nfunction getOrElse<T>(x: Maybe<T>, defaultValue: T): T {\n  return isDefined(x) ? x : defaultValue;\n}\nfunction test1(x: Maybe<string>) {\n  let x1 = getOrElse(x, \"Undefined\"); // string\n  let x2 = isDefined(x) ? x : \"Undefined\"; // string\n  let x3 = isUndefined(x) ? \"Undefined\" : x; // string\n}\nfunction test2(x: Maybe<number>) {\n  let x1 = getOrElse(x, -1); // number\n  let x2 = isDefined(x) ? x : -1; // number\n  let x3 = isUndefined(x) ? -1 : x; // number\n}\nConcatenate \nAMD\n and \nSystem\n modules with \n--outFile\n\nSpecifying outFile in conjunction with --module amd or --module system will concatenate all modules in the compilation into a single output file containing multiple module closures.\n\nA module name will be computed for each module based on its relative location to rootDir.\n\nExample\n// file src/a.ts\nimport * as B from \"./lib/b\";\nexport function createA() {\n  return B.createB();\n}\n// file src/lib/b.ts\nexport function createB() {\n  return {};\n}\n\nResults in:\n\ndefine(\"lib/b\", [\"require\", \"exports\"], function (require, exports) {\n  \"use strict\";\n  function createB() {\n    return {};\n  }\n  exports.createB = createB;\n});\ndefine(\"a\", [\"require\", \"exports\", \"lib/b\"], function (require, exports, B) {\n  \"use strict\";\n  function createA() {\n    return B.createB();\n  }\n  exports.createA = createA;\n});\nSupport for \ndefault\n import interop with SystemJS\n\nModule loaders like SystemJS wrap CommonJS modules and expose then as a default ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.\n\nSetting the new compiler flag allowSyntheticDefaultImports indicates that the module loader performs some kind of synthetic default import member creation not indicated in the imported .ts or .d.ts. The compiler will infer the existence of a default export that has the shape of the entire module itself.\n\nSystem modules have this flag on by default.\n\nAllow captured \nlet\n/\nconst\n in loops\n\nPreviously an error, now supported in TypeScript 1.8. let/const declarations within loops and captured in functions are now emitted to correctly match let/const freshness semantics.\n\nExample\nlet list = [];\nfor (let i = 0; i < 5; i++) {\n  list.push(() => i);\n}\nlist.forEach((f) => console.log(f()));\n\nis compiled to:\n\nvar list = [];\nvar _loop_1 = function (i) {\n  list.push(function () {\n    return i;\n  });\n};\nfor (var i = 0; i < 5; i++) {\n  _loop_1(i);\n}\nlist.forEach(function (f) {\n  return console.log(f());\n});\n\nAnd results in\n\n0\n1\n2\n3\n4\nImproved checking for \nfor..in\n statements\n\nPreviously the type of a for..in variable is inferred to any; that allowed the compiler to ignore invalid uses within the for..in body.\n\nStarting with TypeScript 1.8:\n\nThe type of a variable declared in a for..in statement is implicitly string.\nWhen an object with a numeric index signature of type T (such as an array) is indexed by a for..in variable of a containing for..in statement for an object with a numeric index signature and without a string index signature (again such as an array), the value produced is of type T.\nExample\nvar a: MyObject[];\nfor (var x in a) {\n  // Type of x is implicitly string\n  var obj = a[x]; // Type of obj is MyObject\n}\nModules are now emitted with a \n\"use strict\";\n prologue\n\nModules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn’t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to NaN, will now loudly fail. You can reference the MDN Article on strict mode for a detailed list of the differences between strict mode and non-strict mode.\n\nIncluding \n.js\n files with \n--allowJs\n\nOften there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.\n\n.js files are now allowed as input to tsc. The TypeScript compiler checks the input .js files for syntax errors, and emits valid output based on the target and module flags. The output can be combined with other .ts files as well. Source maps are still generated for .js files just like with .ts files.\n\nCustom JSX factories using \n--reactNamespace\n\nPassing --reactNamespace <JSX factory Name> along with --jsx react allows for using a different JSX factory from the default React.\n\nThe new factory name will be used to call createElement and __spread functions.\n\nExample\nimport { jsxFactory } from \"jsxFactory\";\nvar div = <div>Hello JSX!</div>;\n\nCompiled with:\n\ntsc --jsx react --reactNamespace jsxFactory --m commonJS\n\nResults in:\n\n\"use strict\";\nvar jsxFactory_1 = require(\"jsxFactory\");\nvar div = jsxFactory_1.jsxFactory.createElement(\"div\", null, \"Hello JSX!\");\nthis\n-based type guards\n\nTypeScript 1.8 extends user-defined type guard functions to class and interface methods.\n\nthis is T is now valid return type annotation for methods in classes and interfaces. When used in a type narrowing position (e.g. if statement), the type of the call expression target object would be narrowed to T.\n\nExample\nclass FileSystemObject {\n  isFile(): this is File {\n    return this instanceof File;\n  }\n  isDirectory(): this is Directory {\n    return this instanceof Directory;\n  }\n  isNetworked(): this is Networked & this {\n    return this.networked;\n  }\n  constructor(public path: string, private networked: boolean) {}\n}\nclass File extends FileSystemObject {\n  constructor(path: string, public content: string) {\n    super(path, false);\n  }\n}\nclass Directory extends FileSystemObject {\n  children: FileSystemObject[];\n}\ninterface Networked {\n  host: string;\n}\nlet fso: FileSystemObject = new File(\"foo/bar.txt\", \"foo\");\nif (fso.isFile()) {\n  fso.content; // fso is File\n} else if (fso.isDirectory()) {\n  fso.children; // fso is Directory\n} else if (fso.isNetworked()) {\n  fso.host; // fso is networked\n}\nOfficial TypeScript NuGet package\n\nStarting with TypeScript 1.8, official NuGet packages are available for the TypeScript Compiler (tsc.exe) as well as the MSBuild integration (Microsoft.TypeScript.targets and Microsoft.TypeScript.Tasks.dll).\n\nStable packages are available here:\n\nMicrosoft.TypeScript.Compiler\nMicrosoft.TypeScript.MSBuild\n\nAlso, a nightly NuGet package to match the nightly npm package is available on myget:\n\nTypeScript-Preview\nPrettier error messages from \ntsc\n\nWe understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.\n\nBy just passing the pretty command line option, TypeScript gives more colorful output with context about where things are going wrong.\n\nColorization of JSX code in VS 2015\n\nWith TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.\n\nThe classification can be further customized by changing the font and color settings for the VB XML color and font settings through Tools->Options->Environment->Fonts and Colors page.\n\nThe \n--project\n (\n-p\n) flag can now take any file path\n\nThe --project command line option originally could only take paths to a folder containing a tsconfig.json. Given the different scenarios for build configurations, it made sense to allow --project to point to any other compatible JSON file. For instance, a user might want to target ES2015 with CommonJS modules for Node 5, but ES5 with AMD modules for the browser. With this new work, users can easily manage two separate build targets using tsc alone without having to perform hacky workarounds like placing tsconfig.json files in separate directories.\n\nThe old behavior still remains the same if given a directory - the compiler will try to find a file in the directory named tsconfig.json.\n\nAllow comments in tsconfig.json\n\nIt’s always nice to be able to document your configuration! tsconfig.json now accepts single and multi-line comments.\n\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2015\", // running on node v5, yaay!\n    \"sourceMap\": true // makes debugging easier\n  },\n  /*\n   * Excluded files\n   */\n  \"exclude\": [\"file.d.ts\"]\n}\nSupport output to IPC-driven files\n\nTypeScript 1.8 allows users to use the outFile argument with special file system entities like named pipes, devices, etc.\n\nAs an example, on many Unix-like systems, the standard output stream is accessible by the file /dev/stdout.\n\ntsc foo.ts --outFile /dev/stdout\n\nThis can be used to pipe output between commands as well.\n\nAs an example, we can pipe our emitted JavaScript into a pretty printer like pretty-js:\n\ntsc foo.ts --outFile /dev/stdout | pretty-js\nImproved support for \ntsconfig.json\n in Visual Studio 2015\n\nTypeScript 1.8 allows tsconfig.json files in all project types. This includes ASP.NET v4 projects, Console Application, and the Html Application with TypeScript project types. Further, you are no longer limited to a single tsconfig.json file but can add multiple, and each will be built as part of the project. This allows you to separate the configuration for different parts of your application without having to use multiple different projects.\n\nWe also disable the project properties page when you add a tsconfig.json file. This means that all configuration changes have to be made in the tsconfig.json file itself.\n\nA couple of limitations\nIf you add a tsconfig.json file, TypeScript files that are not considered part of that context are not compiled.\nApache Cordova Apps still have the existing limitation of a single tsconfig.json file, which must be in either the root or the scripts folder.\nThere is no template for tsconfig.json in most project types.\nOn this page\nType parameters as constraints\nControl flow analysis errors\nUnreachable code\nUnused labels\nImplicit returns\nCase clause fall-throughs\nFunction Components in React\nSimplified props type management in React\nAugmenting global/module scope from modules\nString literal types\nImproved union/intersection type inference\nConcatenate AMD and System modules with --outFile\nSupport for default import interop with SystemJS\nAllow captured let/const in loops\nImproved checking for for..in statements\nModules are now emitted with a \"use strict\"; prologue\nIncluding .js files with --allowJs\nCustom JSX factories using --reactNamespace\nthis-based type guards\nOfficial TypeScript NuGet package\nPrettier error messages from tsc\nColorization of JSX code in VS 2015\nThe --project (-p) flag can now take any file path\nAllow comments in tsconfig.json\nSupport output to IPC-driven files\nImproved support for tsconfig.json in Visual Studio 2015\nA couple of limitations\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nNS\nJB\nM\n7+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.99 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 1.4",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-4.html",
    "html": "TypeScript 1.4\nUnion types\nOverview\n\nUnion types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a string, a string[] or a function that returns a string. You can now write:\n\ninterface RunOptions {\n  program: string;\n  commandline: string[] | string | (() => string);\n}\n\nAssignment to union types works very intuitively — anything you could assign to one of the union type’s members is assignable to the union:\n\nvar opts: RunOptions = /* ... */;\nopts.commandline = '-hello world'; // OK\nopts.commandline = ['-hello', 'world']; // OK\nopts.commandline = [42]; // Error, number is not string or string[]\n\nWhen reading from a union type, you can see any properties that are shared by them:\n\nif (opts.commandline.length === 0) {\n  // OK, string and string[] both have 'length' property\n  console.log(\"it's empty\");\n}\n\nUsing Type Guards, you can easily work with a variable of a union type:\n\nfunction formatCommandline(c: string | string[]) {\n  if (typeof c === \"string\") {\n    return c.trim();\n  } else {\n    return c.join(\" \");\n  }\n}\nStricter Generics\n\nWith union types able to represent a wide range of type scenarios, we’ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:\n\nfunction equal<T>(lhs: T, rhs: T): boolean {\n  return lhs === rhs;\n}\n// Previously: No error\n// New behavior: Error, no best common type between 'string' and 'number'\nvar e = equal(42, \"hello\");\n\nWith union types, you can now specify the desired behavior at both the function declaration site and the call site:\n\n// 'choose' function where types must match\nfunction choose1<T>(a: T, b: T): T {\n  return Math.random() > 0.5 ? a : b;\n}\nvar a = choose1(\"hello\", 42); // Error\nvar b = choose1<string | number>(\"hello\", 42); // OK\n// 'choose' function where types need not match\nfunction choose2<T, U>(a: T, b: U): T | U {\n  return Math.random() > 0.5 ? a : b;\n}\nvar c = choose2(\"bar\", \"foo\"); // OK, c: string\nvar d = choose2(\"hello\", 42); // OK, d: string|number\nBetter Type Inference\n\nUnion types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:\n\nvar x = [1, \"hello\"]; // x: Array<string|number>\nx[0] = \"world\"; // OK\nx[0] = false; // Error, boolean is not string or number\nlet\n declarations\n\nIn JavaScript, var declarations are “hoisted” to the top of their enclosing scope. This can result in confusing bugs:\n\nconsole.log(x); // meant to write 'y' here\n/* later in the same block */\nvar x = \"hello\";\n\nThe new ES6 keyword let, now supported in TypeScript, declares a variable with more intuitive “block” semantics. A let variable can only be referred to after its declaration, and is scoped to the syntactic block where it is defined:\n\nif (foo) {\n  console.log(x); // Error, cannot refer to x before its declaration\n  let x = \"hello\";\n} else {\n  console.log(x); // Error, x is not declared in this block\n}\n\nlet is only available when targeting ECMAScript 6 (--target ES6).\n\nconst\n declarations\n\nThe other new ES6 declaration type supported in TypeScript is const. A const variable may not be assigned to, and must be initialized where it is declared. This is useful for declarations where you don’t want to change the value after its initialization:\n\nconst halfPi = Math.PI / 2;\nhalfPi = 2; // Error, can't assign to a `const`\n\nconst is only available when targeting ECMAScript 6 (--target ES6).\n\nTemplate strings\n\nTypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:\n\nvar name = \"TypeScript\";\nvar greeting = `Hello, ${name}! Your name has ${name.length} characters`;\n\nWhen compiling to pre-ES6 targets, the string is decomposed:\n\nvar name = \"TypeScript!\";\nvar greeting =\n  \"Hello, \" + name + \"! Your name has \" + name.length + \" characters\";\nType Guards\n\nA common pattern in JavaScript is to use typeof or instanceof to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an if block.\n\nUsing typeof to test a variable:\n\nvar x: any = /* ... */;\nif(typeof x === 'string') {\n    console.log(x.subtr(1)); // Error, 'subtr' does not exist on 'string'\n}\n// x is still any here\nx.unknown(); // OK\n\nUsing typeof with union types and else:\n\nvar x: string | HTMLElement = /* ... */;\nif(typeof x === 'string') {\n    // x is string here, as shown above\n}\nelse {\n    // x is HTMLElement here\n    console.log(x.innerHTML);\n}\n\nUsing instanceof with classes and union types:\n\nclass Dog { woof() { } }\nclass Cat { meow() { } }\nvar pet: Dog|Cat = /* ... */;\nif (pet instanceof Dog) {\n    pet.woof(); // OK\n}\nelse {\n    pet.woof(); // Error\n}\nType Aliases\n\nYou can now define an alias for a type using the type keyword:\n\ntype PrimitiveArray = Array<string | number | boolean>;\ntype MyNumber = number;\ntype NgScope = ng.IScope;\ntype Callback = () => void;\n\nType aliases are exactly the same as their original types; they are simply alternative names.\n\nconst enum\n (completely inlined enums)\n\nEnums are very useful, but some programs don’t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new const enum declaration works just like a regular enum for type safety, but erases completely at compile time.\n\nconst enum Suit {\n  Clubs,\n  Diamonds,\n  Hearts,\n  Spades\n}\nvar d = Suit.Diamonds;\n\nCompiles to exactly:\n\nvar d = 1;\n\nTypeScript will also now compute enum values when possible:\n\nenum MyFlags {\n  None = 0,\n  Neat = 1,\n  Cool = 2,\n  Awesome = 4,\n  Best = Neat | Cool | Awesome\n}\nvar b = MyFlags.Best; // emits var b = 7;\n-noEmitOnError\n commandline option\n\nThe default behavior for the TypeScript compiler is to still emit .js files if there were type errors (for example, an attempt to assign a string to a number). This can be undesirable on build servers or other scenarios where only output from a “clean” build is desired. The new flag noEmitOnError prevents the compiler from emitting .js code if there were any errors.\n\nThis is now the default for MSBuild projects; this allows MSBuild incremental build to work as expected, as outputs are only generated on clean builds.\n\nAMD Module names\n\nBy default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. r.js).\n\nThe new amd-module name tag allows passing an optional module name to the compiler:\n\n//// [amdModule.ts]\n///<amd-module name='NamedModule'/>\nexport class C {}\n\nWill result in assigning the name NamedModule to the module as part of calling the AMD define:\n\n//// [amdModule.js]\ndefine(\"NamedModule\", [\"require\", \"exports\"], function(require, exports) {\n  var C = (function() {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\nOn this page\nUnion types\nOverview\nStricter Generics\nBetter Type Inference\nlet declarations\nconst declarations\nTemplate strings\nType Guards\nType Aliases\nconst enum (completely inlined enums)\n-noEmitOnError commandline option\nAMD Module names\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nJB\nYY\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.524 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 1.5",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-5.html",
    "html": "TypeScript 1.5\nES6 Modules\n\nTypeScript 1.5 supports ECMAScript 6 (ES6) modules. ES6 modules are effectively TypeScript external modules with a new syntax: ES6 modules are separately loaded source files that possibly import other modules and provide a number of externally accessible exports. ES6 modules feature several new export and import declarations. It is recommended that TypeScript libraries and applications be updated to use the new syntax, but this is not a requirement. The new ES6 module syntax coexists with TypeScript’s original internal and external module constructs and the constructs can be mixed and matched at will.\n\nExport Declarations\n\nIn addition to the existing TypeScript support for decorating declarations with export, module members can also be exported using separate export declarations, optionally specifying different names for exports using as clauses.\n\ninterface Stream { ... }\nfunction writeToStream(stream: Stream, data: string) { ... }\nexport { Stream, writeToStream as write };  // writeToStream exported as write\n\nImport declarations, as well, can optionally use as clauses to specify different local names for the imports. For example:\n\nimport { read, write, standardOutput as stdout } from \"./inout\";\nvar s = read(stdout);\nwrite(stdout, s);\n\nAs an alternative to individual imports, a namespace import can be used to import an entire module:\n\nimport * as io from \"./inout\";\nvar s = io.read(io.standardOutput);\nio.write(io.standardOutput, s);\nRe-exporting\n\nUsing from clause a module can copy the exports of a given module to the current module without introducing local names.\n\nexport { read, write, standardOutput as stdout } from \"./inout\";\n\nexport * can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.\n\nexport function transform(s: string): string { ... }\nexport * from \"./mod1\";\nexport * from \"./mod2\";\nDefault Export\n\nAn export default declaration specifies an expression that becomes the default export of a module:\n\nexport default class Greeter {\n  sayHello() {\n    console.log(\"Greetings!\");\n  }\n}\n\nWhich in turn can be imported using default imports:\n\nimport Greeter from \"./greeter\";\nvar g = new Greeter();\ng.sayHello();\nBare Import\n\nA “bare import” can be used to import a module only for its side-effects.\n\nimport \"./polyfills\";\n\nFor more information about module, please see the ES6 module support spec.\n\nDestructuring in declarations and assignments\n\nTypeScript 1.5 adds support to ES6 destructuring declarations and assignments.\n\nDeclarations\n\nA destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.\n\nFor example, the following sample declares variables x, y, and z, and initializes them to getSomeObject().x, getSomeObject().y and getSomeObject().z respectively:\n\nvar { x, y, z } = getSomeObject();\n\nDestructuring declarations also works for extracting values from arrays:\n\nvar [x, y, z = 10] = getSomeArray();\n\nSimilarly, destructuring can be used in function parameter declarations:\n\nfunction drawText({ text = \"\", location: [x, y] = [0, 0], bold = false }) {\n  // Draw text\n}\n// Call drawText with an object literal\nvar item = { text: \"someText\", location: [1, 2, 3], style: \"italics\" };\ndrawText(item);\nAssignments\n\nDestructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:\n\nvar x = 1;\nvar y = 2;\n[x, y] = [y, x];\nnamespace\n keyword\n\nTypeScript used the module keyword to define both “internal modules” and “external modules”; this has been a bit of confusion for developers new to TypeScript. “Internal modules” are closer to what most people would call a namespace; likewise, “external modules” in JS speak really just are modules now.\n\nNote: Previous syntax defining internal modules are still supported.\n\nBefore:\n\nmodule Math {\n    export function add(x, y) { ... }\n}\n\nAfter:\n\nnamespace Math {\n    export function add(x, y) { ... }\n}\nlet\n and \nconst\n support\n\nES6 let and const declarations are now supported when targeting ES3 and ES5.\n\nConst\nconst MAX = 100;\n++MAX; // Error: The operand of an increment or decrement\n//        operator cannot be a constant.\nBlock scoped\nif (true) {\n  let a = 4;\n  // use a\n} else {\n  let a = \"string\";\n  // use a\n}\nalert(a); // Error: a is not defined in this scope.\nfor..of support\n\nTypeScript 1.5 adds support to ES6 for..of loops on arrays for ES3/ES5 as well as full support for Iterator interfaces when targeting ES6.\n\nExample\n\nThe TypeScript compiler will transpile for..of arrays to idiomatic ES3/ES5 JavaScript when targeting those versions:\n\nfor (var v of expr) {\n}\n\nwill be emitted as:\n\nfor (var _i = 0, _a = expr; _i < _a.length; _i++) {\n  var v = _a[_i];\n}\nDecorators\n\nTypeScript decorators are based on the ES7 decorator proposal.\n\nA decorator is:\n\nan expression\nthat evaluates to a function\nthat takes the target, name, and property descriptor as arguments\nand optionally returns a property descriptor to install on the target object\n\nFor more information, please see the Decorators proposal.\n\nExample\n\nDecorators readonly and enumerable(false) will be applied to the property method before it is installed on class C. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.\n\nclass C {\n  @readonly\n  @enumerable(false)\n  method() { ... }\n}\nfunction readonly(target, key, descriptor) {\n    descriptor.writable = false;\n}\nfunction enumerable(value) {\n    return function (target, key, descriptor) {\n        descriptor.enumerable = value;\n    };\n}\nComputed properties\n\nInitializing an object with dynamic properties can be a bit of a burden. Take the following example:\n\ntype NeighborMap = { [name: string]: Node };\ntype Node = { name: string; neighbors: NeighborMap };\nfunction makeNode(name: string, initialNeighbor: Node): Node {\n  var neighbors: NeighborMap = {};\n  neighbors[initialNeighbor.name] = initialNeighbor;\n  return { name: name, neighbors: neighbors };\n}\n\nHere we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:\n\nfunction makeNode(name: string, initialNeighbor: Node): Node {\n  return {\n    name: name,\n    neighbors: {\n      [initialNeighbor.name]: initialNeighbor,\n    },\n  };\n}\nSupport for \nUMD\n and \nSystem\n module output\n\nIn addition to AMD and CommonJS module loaders, TypeScript now supports emitting modules UMD (Universal Module Definition) and System module formats.\n\nUsage:\n\ntsc —module umd\n\nand\n\ntsc —module system\n\nUnicode codepoint escapes in strings\n\nES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.\n\nAs an example, consider the need to escape a string that contains the character ’𠮷‘. In UTF-16/UCS2, ’𠮷’ is represented as a surrogate pair, meaning that it’s encoded using a pair of 16-bit code units of values, specifically 0xD842 and 0xDFB7. Previously this meant that you’d have to escape the codepoint as \"\\uD842\\uDFB7\". This has the major downside that it’s difficult to discern two independent characters from a surrogate pair.\n\nWith ES6’s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: \"\\u{20bb7}\". TypeScript will emit the string in ES3/ES5 as \"\\uD842\\uDFB7\".\n\nTagged template strings in ES3/ES5\n\nIn TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by @ivogabe, we bridged the gap for for tagged templates in ES3 and ES5.\n\nWhen targeting ES3/ES5, the following code\n\nfunction oddRawStrings(strs: TemplateStringsArray, n1, n2) {\n  return strs.raw.filter((raw, index) => index % 2 === 1);\n}\noddRawStrings`Hello \\n${123} \\t ${456}\\n world`;\n\nwill be emitted as\n\nfunction oddRawStrings(strs, n1, n2) {\n  return strs.raw.filter(function (raw, index) {\n    return index % 2 === 1;\n  });\n}\n(_a = [\"Hello \\n\", \" \\t \", \"\\n world\"]),\n  (_a.raw = [\"Hello \\\\n\", \" \\\\t \", \"\\\\n world\"]),\n  oddRawStrings(_a, 123, 456);\nvar _a;\nAMD-dependency optional names\n\n/// <amd-dependency path=\"x\" /> informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call; however, there was no way to consume this module in the TS code.\n\nThe new amd-dependency name property allows passing an optional name for an amd-dependency:\n\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n\nGenerated JS code:\n\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (\n  require,\n  exports,\n  moduleA\n) {\n  moduleA.callStuff();\n});\nProject support through \ntsconfig.json\n\nAdding a tsconfig.json file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:\n\nBy invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.\nBy invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.\nExample\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"noImplicitAny\": true,\n    \"sourceMap\": true\n  }\n}\n\nSee the tsconfig.json wiki page for more details.\n\n--rootDir\n command line option\n\nOption outDir duplicates the input hierarchy in the output. The compiler computes the root of the input files as the longest common path of all input files; and then uses that to replicate all its substructure in the output.\n\nSometimes this is not desirable, for instance inputs FolderA\\FolderB\\1.ts and FolderA\\FolderB\\2.ts would result in output structure mirroring FolderA\\FolderB\\. Now if a new file FolderA\\3.ts is added to the input, the output structure will pop out to mirror FolderA\\.\n\nrootDir specifies the input directory to be mirrored in output instead of computing it.\n\n--noEmitHelpers\n command line option\n\nThe TypeScript compiler emits a few helpers like __extends when needed. The helpers are emitted in every file they are referenced in. If you want to consolidate all helpers in one place, or override the default behavior, use noEmitHelpers to instructs the compiler not to emit them.\n\n--newLine\n command line option\n\nBy default the output new line character is \\r\\n on Windows based systems and \\n on *nix based systems. newLine command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.\n\n--inlineSourceMap\n and \ninlineSources\n command line options\n\ninlineSourceMap causes source map files to be written inline in the generated .js files instead of in a independent .js.map file. inlineSources allows for additionally inlining the source .ts file into the .js file.\n\nOn this page\nES6 Modules\nDestructuring in declarations and assignments\nnamespace keyword\nlet and const support\nfor..of support\nDecorators\nComputed properties\nSupport for UMD and System module output\nUnicode codepoint escapes in strings\nTagged template strings in ES3/ES5\nAMD-dependency optional names\nProject support through tsconfig.json\n--rootDir command line option\n--noEmitHelpers command line option\n--newLine command line option\n--inlineSourceMap and inlineSources command line options\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nSC\nJB\nSC\n8+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.689 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 1.7",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-7.html",
    "html": "TypeScript 1.7\nasync\n/\nawait\n support in ES6 targets (Node v4+)\n\nTypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the async keyword; await suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the Promise returned.\n\nExample\n\nIn the following example, each input element will be printed out one at a time with a 400ms delay:\n\n\"use strict\";\n// printDelayed is a 'Promise<void>'\nasync function printDelayed(elements: string[]) {\n  for (const element of elements) {\n    await delay(400);\n    console.log(element);\n  }\n}\nasync function delay(milliseconds: number) {\n  return new Promise<void>((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n}\nprintDelayed([\"Hello\", \"beautiful\", \"asynchronous\", \"world\"]).then(() => {\n  console.log();\n  console.log(\"Printed every element!\");\n});\n\nFor more information see async function reference reference.\n\nSupport for \n--target ES6\n with \n--module\n\nTypeScript 1.7 adds ES6 to the list of options available for the module option and allows you to specify the module output when targeting ES6. This provides more flexibility to target exactly the features you want in specific runtimes.\n\nExample\n{\n  \"compilerOptions\": {\n    \"module\": \"amd\",\n    \"target\": \"es6\"\n  }\n}\nthis\n-typing\n\nIt is a common pattern to return the current object (i.e. this) from a method to create fluent-style APIs. For instance, consider the following BasicCalculator module:\n\nexport default class BasicCalculator {\n  public constructor(protected value: number = 0) {}\n  public currentValue(): number {\n    return this.value;\n  }\n  public add(operand: number) {\n    this.value += operand;\n    return this;\n  }\n  public subtract(operand: number) {\n    this.value -= operand;\n    return this;\n  }\n  public multiply(operand: number) {\n    this.value *= operand;\n    return this;\n  }\n  public divide(operand: number) {\n    this.value /= operand;\n    return this;\n  }\n}\n\nA user could express 2 * 5 + 1 as\n\nimport calc from \"./BasicCalculator\";\nlet v = new calc(2).multiply(5).add(1).currentValue();\n\nThis often opens up very elegant ways of writing code; however, there was a problem for classes that wanted to extend from BasicCalculator. Imagine a user wanted to start writing a ScientificCalculator:\n\nimport BasicCalculator from \"./BasicCalculator\";\nexport default class ScientificCalculator extends BasicCalculator {\n  public constructor(value = 0) {\n    super(value);\n  }\n  public square() {\n    this.value = this.value ** 2;\n    return this;\n  }\n  public sin() {\n    this.value = Math.sin(this.value);\n    return this;\n  }\n}\n\nBecause TypeScript used to infer the type BasicCalculator for each method in BasicCalculator that returned this, the type system would forget that it had ScientificCalculator whenever using a BasicCalculator method.\n\nFor instance:\n\nimport calc from \"./ScientificCalculator\";\nlet v = new calc(0.5)\n  .square()\n  .divide(2)\n  .sin() // Error: 'BasicCalculator' has no 'sin' method.\n  .currentValue();\n\nThis is no longer the case - TypeScript now infers this to have a special type called this whenever inside an instance method of a class. The this type is written as so, and basically means “the type of the left side of the dot in a method call”.\n\nThe this type is also useful with intersection types in describing libraries (e.g. Ember.js) that use mixin-style patterns to describe inheritance:\n\ninterface MyType {\n  extend<T>(other: T): this & T;\n}\nES7 exponentiation operator\n\nTypeScript 1.7 supports upcoming ES7/ES2016 exponentiation operators: ** and **=. The operators will be transformed in the output to ES3/ES5 using Math.pow.\n\nExample\nvar x = 2 ** 3;\nvar y = 10;\ny **= 2;\nvar z = -(4 ** 3);\n\nWill generate the following JavaScript output:\n\nvar x = Math.pow(2, 3);\nvar y = 10;\ny = Math.pow(y, 2);\nvar z = -Math.pow(4, 3);\nImproved checking for destructuring object literal\n\nTypeScript 1.7 makes checking of destructuring patterns with an object literal or array literal initializers less rigid and more intuitive.\n\nWhen an object literal is contextually typed by the implied type of an object binding pattern:\n\nProperties with default values in the object binding pattern become optional in the object literal.\nProperties in the object binding pattern that have no match in the object literal are required to have a default value in the object binding pattern and are automatically added to the object literal type.\nProperties in the object literal that have no match in the object binding pattern are an error.\n\nWhen an array literal is contextually typed by the implied type of an array binding pattern:\n\nElements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.\nExample\n// Type of f1 is (arg?: { x?: number, y?: number }) => void\nfunction f1({ x = 0, y = 0 } = {}) {}\n// And can be called as:\nf1();\nf1({});\nf1({ x: 1 });\nf1({ y: 1 });\nf1({ x: 1, y: 1 });\n// Type of f2 is (arg?: (x: number, y?: number) => void\nfunction f2({ x, y = 0 } = { x: 0 }) {}\nf2();\nf2({}); // Error, x not optional\nf2({ x: 1 });\nf2({ y: 1 }); // Error, x not optional\nf2({ x: 1, y: 1 });\nSupport for decorators when targeting ES3\n\nDecorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of reduceRight from the __decorate helper. The changes also inline calls Object.getOwnPropertyDescriptor and Object.defineProperty in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned Object methods.\n\nOn this page\nasync/await support in ES6 targets (Node v4+)\nSupport for --target ES6 with --module\nthis-typing\nES7 exponentiation operator\nImproved checking for destructuring object literal\nSupport for decorators when targeting ES3\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nJB\nEB\nTG\n4+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.878 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 1.6",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-1-6.html",
    "html": "TypeScript 1.6\nJSX support\n\nJSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.\n\nNew .tsx file extension and as operator\n\nTypeScript 1.6 introduces a new .tsx file extension. This extension does two things: it enables JSX inside of TypeScript files, and it makes the new as operator the default way to cast (removing any ambiguity between JSX expressions and the TypeScript prefix cast operator). For example:\n\nvar x = <any>foo;\n// is equivalent to:\nvar x = foo as any;\nUsing React\n\nTo use JSX-support with React you should use the React typings. These typings define the JSX namespace so that TypeScript can correctly check JSX expressions for React. For example:\n\n/// <reference path=\"react.d.ts\" />\ninterface Props {\n  name: string;\n}\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.name}</span>;\n  }\n}\n<MyComponent name=\"bar\" />; // OK\n<MyComponent name={0} />; // error, `name` is not a number\nUsing other JSX frameworks\n\nJSX element names and properties are validated against the JSX namespace. Please see the [[JSX]] wiki page for defining the JSX namespace for your framework.\n\nOutput generation\n\nTypeScript ships with two JSX modes: preserve and react.\n\nThe preserve mode will keep JSX expressions as part of the output to be further consumed by another transform step. Additionally the output will have a .jsx file extension.\nThe react mode will emit React.createElement, does not need to go through a JSX transformation before use, and the output will have a .js file extension.\n\nSee the [[JSX]] wiki page for more information on using JSX in TypeScript.\n\nIntersection types\n\nTypeScript 1.6 introduces intersection types, the logical complement of union types. A union type A | B represents an entity that is either of type A or type B, whereas an intersection type A & B represents an entity that is both of type A and type B.\n\nExample\nfunction extend<T, U>(first: T, second: U): T & U {\n  let result = <T & U>{};\n  for (let id in first) {\n    result[id] = first[id];\n  }\n  for (let id in second) {\n    if (!result.hasOwnProperty(id)) {\n      result[id] = second[id];\n    }\n  }\n  return result;\n}\nvar x = extend({ a: \"hello\" }, { b: 42 });\nvar s = x.a;\nvar n = x.b;\ntype LinkedList<T> = T & { next: LinkedList<T> };\ninterface Person {\n  name: string;\n}\nvar people: LinkedList<Person>;\nvar s = people.name;\nvar s = people.next.name;\nvar s = people.next.next.name;\nvar s = people.next.next.next.name;\ninterface A {\n  a: string;\n}\ninterface B {\n  b: string;\n}\ninterface C {\n  c: string;\n}\nvar abc: A & B & C;\nabc.a = \"hello\";\nabc.b = \"hello\";\nabc.c = \"hello\";\n\nSee issue #1256 for more information.\n\nLocal type declarations\n\nLocal class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with let and const. For example:\n\nfunction f() {\n  if (true) {\n    interface T {\n      x: number;\n    }\n    let v: T;\n    v.x = 5;\n  } else {\n    interface T {\n      x: string;\n    }\n    let v: T;\n    v.x = \"hello\";\n  }\n}\n\nThe inferred return type of a function may be a type declared locally within the function. It is not possible for callers of the function to reference such a local type, but it can of course be matched structurally. For example:\n\ninterface Point {\n  x: number;\n  y: number;\n}\nfunction getPointFactory(x: number, y: number) {\n  class P {\n    x = x;\n    y = y;\n  }\n  return P;\n}\nvar PointZero = getPointFactory(0, 0);\nvar PointOne = getPointFactory(1, 1);\nvar p1 = new PointZero();\nvar p2 = new PointZero();\nvar p3 = new PointOne();\n\nLocal types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:\n\nfunction f3() {\n  function f<X, Y>(x: X, y: Y) {\n    class C {\n      public x = x;\n      public y = y;\n    }\n    return C;\n  }\n  let C = f(10, \"hello\");\n  let v = new C();\n  let x = v.x; // number\n  let y = v.y; // string\n}\nClass expressions\n\nTypeScript 1.6 adds support for ES6 class expressions. In a class expression, the class name is optional and, if specified, is only in scope in the class expression itself. This is similar to the optional name of a function expression. It is not possible to refer to the class instance type of a class expression outside the class expression, but the type can of course be matched structurally. For example:\n\nlet Point = class {\n  constructor(public x: number, public y: number) {}\n  public length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n};\nvar p = new Point(3, 4); // p has anonymous class type\nconsole.log(p.length());\nExtending expressions\n\nTypeScript 1.6 adds support for classes extending arbitrary expression that computes a constructor function. This means that built-in types can now be extended in class declarations.\n\nThe extends clause of a class previously required a type reference to be specified. It now accepts an expression optionally followed by a type argument list. The type of the expression must be a constructor function type with at least one construct signature that has the same number of type parameters as the number of type arguments specified in the extends clause. The return type of the matching construct signature(s) is the base type from which the class instance type inherits. Effectively, this allows both real classes and “class-like” expressions to be specified in the extends clause.\n\nSome examples:\n\n// Extend built-in types\nclass MyArray extends Array<number> {}\nclass MyError extends Error {}\n// Extend computed base class\nclass ThingA {\n  getGreeting() {\n    return \"Hello from A\";\n  }\n}\nclass ThingB {\n  getGreeting() {\n    return \"Hello from B\";\n  }\n}\ninterface Greeter {\n  getGreeting(): string;\n}\ninterface GreeterConstructor {\n  new (): Greeter;\n}\nfunction getGreeterBase(): GreeterConstructor {\n  return Math.random() >= 0.5 ? ThingA : ThingB;\n}\nclass Test extends getGreeterBase() {\n  sayHello() {\n    console.log(this.getGreeting());\n  }\n}\nabstract\n classes and methods\n\nTypeScript 1.6 adds support for abstract keyword for classes and their methods. An abstract class is allowed to have methods with no implementation, and cannot be constructed.\n\nExamples\nabstract class Base {\n  abstract getThing(): string;\n  getOtherThing() {\n    return \"hello\";\n  }\n}\nlet x = new Base(); // Error, 'Base' is abstract\n// Error, must either be 'abstract' or implement concrete 'getThing'\nclass Derived1 extends Base {}\nclass Derived2 extends Base {\n  getThing() {\n    return \"hello\";\n  }\n  foo() {\n    super.getThing(); // Error: cannot invoke abstract members through 'super'\n  }\n}\nvar x = new Derived2(); // OK\nvar y: Base = new Derived2(); // Also OK\ny.getThing(); // OK\ny.getOtherThing(); // OK\nGeneric type aliases\n\nWith TypeScript 1.6, type aliases can be generic. For example:\n\ntype Lazy<T> = T | (() => T);\nvar s: Lazy<string>;\ns = \"eager\";\ns = () => \"lazy\";\ninterface Tuple<A, B> {\n  a: A;\n  b: B;\n}\ntype Pair<T> = Tuple<T, T>;\nStricter object literal assignment checks\n\nTypeScript 1.6 enforces stricter object literal assignment checks for the purpose of catching excess or misspelled properties. Specifically, when a fresh object literal is assigned to a variable or passed as an argument for a non-empty target type, it is an error for the object literal to specify properties that don’t exist in the target type.\n\nExamples\nvar x: { foo: number };\nx = { foo: 1, baz: 2 }; // Error, excess property `baz`\nvar y: { foo: number; bar?: number };\ny = { foo: 1, baz: 2 }; // Error, excess or misspelled property `baz`\n\nA type can include an index signature to explicitly indicate that excess properties are permitted:\n\nvar x: { foo: number; [x: string]: any };\nx = { foo: 1, baz: 2 }; // Ok, `baz` matched by index signature\nES6 generators\n\nTypeScript 1.6 adds support for generators when targeting ES6.\n\nA generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:\n\nfunction* g(): Iterable<string> {\n  for (var i = 0; i < 100; i++) {\n    yield \"\"; // string is assignable to string\n  }\n  yield* otherStringGenerator(); // otherStringGenerator must be iterable and element type assignable to string\n}\n\nA generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:\n\nfunction* g() {\n  for (var i = 0; i < 100; i++) {\n    yield \"\"; // infer string\n  }\n  yield* otherStringGenerator(); // infer element type of otherStringGenerator\n}\nExperimental support for \nasync\n functions\n\nTypeScript 1.6 introduces experimental support of async functions when targeting ES6. Async functions are expected to invoke an asynchronous operation and await its result without blocking normal execution of the program. This accomplished through the use of an ES6-compatible Promise implementation, and transposition of the function body into a compatible form to resume execution when the awaited asynchronous operation completes.\n\nAn async function is a function or method that has been prefixed with the async modifier. This modifier informs the compiler that function body transposition is required, and that the keyword await should be treated as a unary expression instead of an identifier. An Async Function must provide a return type annotation that points to a compatible Promise type. Return type inference can only be used if there is a globally defined, compatible Promise type.\n\nExample\nvar p: Promise<number> = /* ... */;\nasync function fn(): Promise<number> {\n  var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\n  return 1 + i;\n}\nvar a = async (): Promise<number> => 1 + await p; // suspends execution.\nvar a = async () => 1 + await p; // suspends execution. return type is inferred as \"Promise<number>\" when compiling with --target ES6\nvar fe = async function(): Promise<number> {\n  var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\n  return 1 + i;\n}\nclass C {\n  async m(): Promise<number> {\n    var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\n    return 1 + i;\n  }\n  async get p(): Promise<number> {\n    var i = await p; // suspend execution until 'p' is settled. 'i' has type \"number\"\n    return 1 + i;\n  }\n}\nNightly builds\n\nWhile not strictly a language change, nightly builds are now available by installing with the following command:\n\nnpm install -g typescript@next\nAdjustments in module resolution logic\n\nStarting from release 1.6 TypeScript compiler will use different set of rules to resolve module names when targeting ‘commonjs’. These rules attempted to model module lookup procedure used by Node. This effectively mean that node modules can include information about its typings and TypeScript compiler will be able to find it. User however can override module resolution rules picked by the compiler by using moduleResolution command line option. Possible values are:\n\n‘classic’ - module resolution rules used by pre 1.6 TypeScript compiler\n‘node’ - node-like module resolution\nMerging ambient class and interface declaration\n\nThe instance side of an ambient class declaration can be extended using an interface declaration The class constructor object is unmodified. For example:\n\ndeclare class Foo {\n  public x: number;\n}\ninterface Foo {\n  y: string;\n}\nfunction bar(foo: Foo) {\n  foo.x = 1; // OK, declared in the class Foo\n  foo.y = \"1\"; // OK, declared in the interface Foo\n}\nUser-defined type guard functions\n\nTypeScript 1.6 adds a new way to narrow a variable type inside an if block, in addition to typeof and instanceof. A user-defined type guard functions is one with a return type annotation of the form x is T, where x is a declared parameter in the signature, and T is any type. When a user-defined type guard function is invoked on a variable in an if block, the type of the variable will be narrowed to T.\n\nExamples\nfunction isCat(a: any): a is Cat {\n  return a.name === \"kitty\";\n}\nvar x: Cat | Dog;\nif (isCat(x)) {\n  x.meow(); // OK, x is Cat in this block\n}\nexclude\n property support in tsconfig.json\n\nA tsconfig.json file that doesn’t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:\n\n{\n  \"compilerOptions\": {\n    \"out\": \"test.js\"\n  },\n  \"exclude\": [\"node_modules\", \"test.ts\", \"utils/t2.ts\"]\n}\n\nThe exclude list does not support wildcards. It must simply be a list of files and/or directories.\n\n--init\n command line option\n\nRun tsc --init in a directory to create an initial tsconfig.json in this directory with preset defaults. Optionally pass command line arguments along with --init to be stored in your initial tsconfig.json on creation.\n\nOn this page\nJSX support\nIntersection types\nLocal type declarations\nClass expressions\nExtending expressions\nabstract classes and methods\nGeneric type aliases\nStricter object literal assignment checks\nES6 generators\nExperimental support for async functions\nNightly builds\nAdjustments in module resolution logic\nMerging ambient class and interface declaration\nUser-defined type guard functions\nexclude property support in tsconfig.json\n--init command line option\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nNS\nAG\nJB\n5+\n\nLast updated: Nov 27, 2023\n\n "
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.0",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html",
    "html": "TypeScript 2.0\nNull- and undefined-aware types\n\nTypeScript has two special types, Null and Undefined, that have the values null and undefined respectively. Previously it was not possible to explicitly name these types, but null and undefined may now be used as type names regardless of type checking mode.\n\nThe type checker previously considered null and undefined assignable to anything. Effectively, null and undefined were valid values of every type and it wasn’t possible to specifically exclude them (and therefore not possible to detect erroneous use of them).\n\n--strictNullChecks\n\nstrictNullChecks switches to a new strict null checking mode.\n\nIn strict null checking mode, the null and undefined values are not in the domain of every type and are only assignable to themselves and any (the one exception being that undefined is also assignable to void). So, whereas T and T | undefined are considered synonymous in regular type checking mode (because undefined is considered a subtype of any T), they are different types in strict type checking mode, and only T | undefined permits undefined values. The same is true for the relationship of T to T | null.\n\nExample\n// Compiled with --strictNullChecks\nlet x: number;\nlet y: number | undefined;\nlet z: number | null | undefined;\nx = 1; // Ok\ny = 1; // Ok\nz = 1; // Ok\nx = undefined; // Error\ny = undefined; // Ok\nz = undefined; // Ok\nx = null; // Error\ny = null; // Error\nz = null; // Ok\nx = y; // Error\nx = z; // Error\ny = x; // Ok\ny = z; // Error\nz = x; // Ok\nz = y; // Ok\nAssigned-before-use checking\n\nIn strict null checking mode the compiler requires every reference to a local variable of a type that doesn’t include undefined to be preceded by an assignment to that variable in every possible preceding code path.\n\nExample\n// Compiled with --strictNullChecks\nlet x: number;\nlet y: number | null;\nlet z: number | undefined;\nx; // Error, reference not preceded by assignment\ny; // Error, reference not preceded by assignment\nz; // Ok\nx = 1;\ny = null;\nx; // Ok\ny; // Ok\n\nThe compiler checks that variables are definitely assigned by performing control flow based type analysis. See later for further details on this topic.\n\nOptional parameters and properties\n\nOptional parameters and properties automatically have undefined added to their types, even when their type annotations don’t specifically include undefined. For example, the following two types are identical:\n\n// Compiled with --strictNullChecks\ntype T1 = (x?: number) => string; // x has type number | undefined\ntype T2 = (x?: number | undefined) => string; // x has type number | undefined\nNon-null and non-undefined type guards\n\nA property access or a function call produces a compile-time error if the object or function is of a type that includes null or undefined. However, type guards are extended to support non-null and non-undefined checks.\n\nExample\n// Compiled with --strictNullChecks\ndeclare function f(x: number): string;\nlet x: number | null | undefined;\nif (x) {\n  f(x); // Ok, type of x is number here\n} else {\n  f(x); // Error, type of x is number? here\n}\nlet a = x != null ? f(x) : \"\"; // Type of a is string\nlet b = x && f(x); // Type of b is string | 0 | null | undefined\n\nNon-null and non-undefined type guards may use the ==, !=, ===, or !== operator to compare to null or undefined, as in x != null or x === undefined. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).\n\nDotted names in type guards\n\nType guards previously only supported checking local variables and parameters. Type guards now support checking “dotted names” consisting of a variable or parameter name followed one or more property accesses.\n\nExample\ninterface Options {\n  location?: {\n    x?: number;\n    y?: number;\n  };\n}\nfunction foo(options?: Options) {\n  if (options && options.location && options.location.x) {\n    const x = options.location.x; // Type of x is number\n  }\n}\n\nType guards for dotted names also work with user defined type guard functions and the typeof and instanceof operators and do not depend on the strictNullChecks compiler option.\n\nA type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for x.y.z will have no effect following an assignment to x, x.y, or x.y.z.\n\nExpression operators\n\nExpression operators permit operand types to include null and/or undefined but always produce values of non-null and non-undefined types.\n\n// Compiled with --strictNullChecks\nfunction sum(a: number | null, b: number | null) {\n  return a + b; // Produces value of type number\n}\n\nThe && operator adds null and/or undefined to the type of the right operand depending on which are present in the type of the left operand, and the || operator removes both null and undefined from the type of the left operand in the resulting union type.\n\n// Compiled with --strictNullChecks\ninterface Entity {\n  name: string;\n}\nlet x: Entity | null;\nlet s = x && x.name; // s is of type string | null\nlet y = x || { name: \"test\" }; // y is of type Entity\nType widening\n\nThe null and undefined types are not widened to any in strict null checking mode.\n\nlet z = null; // Type of z is null\n\nIn regular type checking mode the inferred type of z is any because of widening, but in strict null checking mode the inferred type of z is null (and therefore, absent a type annotation, null is the only possible value for z).\n\nNon-null assertion operator\n\nA new ! post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation x! produces a value of the type of x with null and undefined excluded. Similar to type assertions of the forms <T>x and x as T, the ! non-null assertion operator is simply removed in the emitted JavaScript code.\n\n// Compiled with --strictNullChecks\nfunction validateEntity(e?: Entity) {\n  // Throw exception if e is null or invalid entity\n}\nfunction processEntity(e?: Entity) {\n  validateEntity(e);\n  let s = e!.name; // Assert that e is non-null and access name\n}\nCompatibility\n\nThe new features are designed such that they can be used in both strict null checking mode and regular type checking mode. In particular, the null and undefined types are automatically erased from union types in regular type checking mode (because they are subtypes of all other types), and the ! non-null assertion expression operator is permitted but has no effect in regular type checking mode. Thus, declaration files that are updated to use null- and undefined-aware types can still be used in regular type checking mode for backwards compatibility.\n\nIn practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.\n\nControl flow based type analysis\n\nTypeScript 2.0 implements a control flow-based type analysis for local variables and parameters. Previously, the type analysis performed for type guards was limited to if statements and ?: conditional expressions and didn’t include effects of assignments and control flow constructs such as return and break statements. With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the narrowed type) at any given location for a local variable or parameter that is declared to have a union type.\n\nExample\nfunction foo(x: string | number | boolean) {\n  if (typeof x === \"string\") {\n    x; // type of x is string here\n    x = 1;\n    x; // type of x is number here\n  }\n  x; // type of x is number | boolean here\n}\nfunction bar(x: string | number) {\n  if (typeof x === \"number\") {\n    return;\n  }\n  x; // type of x is string here\n}\n\nControl flow based type analysis is particularly relevant in strictNullChecks mode because nullable types are represented using union types:\n\nfunction test(x: string | null) {\n  if (x === null) {\n    return;\n  }\n  x; // type of x is string in remainder of function\n}\n\nFurthermore, in strictNullChecks mode, control flow based type analysis includes definite assignment analysis for local variables of types that don’t permit the value undefined.\n\nfunction mumble(check: boolean) {\n  let x: number; // Type doesn't permit undefined\n  x; // Error, x is undefined\n  if (check) {\n    x = 1;\n    x; // Ok\n  }\n  x; // Error, x is possibly undefined\n  x = 2;\n  x; // Ok\n}\nTagged union types\n\nTypeScript 2.0 implements support for tagged (or discriminated) union types. Specifically, the TS compiler now support type guards that narrow union types based on tests of a discriminant property and furthermore extend that capability to switch statements.\n\nExample\ninterface Square {\n  kind: \"square\";\n  size: number;\n}\ninterface Rectangle {\n  kind: \"rectangle\";\n  width: number;\n  height: number;\n}\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\ntype Shape = Square | Rectangle | Circle;\nfunction area(s: Shape) {\n  // In the following switch statement, the type of s is narrowed in each case clause\n  // according to the value of the discriminant property, thus allowing the other properties\n  // of that variant to be accessed without a type assertion.\n  switch (s.kind) {\n    case \"square\":\n      return s.size * s.size;\n    case \"rectangle\":\n      return s.width * s.height;\n    case \"circle\":\n      return Math.PI * s.radius * s.radius;\n  }\n}\nfunction test1(s: Shape) {\n  if (s.kind === \"square\") {\n    s; // Square\n  } else {\n    s; // Rectangle | Circle\n  }\n}\nfunction test2(s: Shape) {\n  if (s.kind === \"square\" || s.kind === \"rectangle\") {\n    return;\n  }\n  s; // Circle\n}\n\nA discriminant property type guard is an expression of the form x.p == v, x.p === v, x.p != v, or x.p !== v, where p and v are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of x to those constituent types of x that have a discriminant property p with one of the possible values of v.\n\nNote that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.\n\nThe \nnever\n type\n\nTypeScript 2.0 introduces a new primitive type never. The never type represents the type of values that never occur. Specifically, never is the return type for functions that never return and never is the type of variables under type guards that are never true.\n\nThe never type has the following characteristics:\n\nnever is a subtype of and assignable to every type.\nNo type is a subtype of or assignable to never (except never itself).\nIn a function expression or arrow function with no return type annotation, if the function has no return statements, or only return statements with expressions of type never, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is never.\nIn a function with an explicit never return type annotation, all return statements (if any) must have expressions of type never and the end point of the function must not be reachable.\n\nBecause never is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.\n\nSome examples of functions returning never:\n\n// Function returning never must have unreachable end point\nfunction error(message: string): never {\n  throw new Error(message);\n}\n// Inferred return type is never\nfunction fail() {\n  return error(\"Something failed\");\n}\n// Function returning never must have unreachable end point\nfunction infiniteLoop(): never {\n  while (true) {}\n}\n\nSome examples of use of functions returning never:\n\n// Inferred return type is number\nfunction move1(direction: \"up\" | \"down\") {\n  switch (direction) {\n    case \"up\":\n      return 1;\n    case \"down\":\n      return -1;\n  }\n  return error(\"Should never get here\");\n}\n// Inferred return type is number\nfunction move2(direction: \"up\" | \"down\") {\n  return direction === \"up\"\n    ? 1\n    : direction === \"down\"\n    ? -1\n    : error(\"Should never get here\");\n}\n// Inferred return type is T\nfunction check<T>(x: T | undefined) {\n  return x || error(\"Undefined value\");\n}\n\nBecause never is assignable to every type, a function returning never can be used when a callback returning a more specific type is required:\n\nfunction test(cb: () => string) {\n  let s = cb();\n  return s;\n}\ntest(() => \"hello\");\ntest(() => fail());\ntest(() => {\n  throw new Error();\n});\nRead-only properties and index signatures\n\nA property or index signature can now be declared with the readonly modifier.\n\nRead-only properties may have initializers and may be assigned to in constructors within the same class declaration, but otherwise assignments to read-only properties are disallowed.\n\nIn addition, entities are implicitly read-only in several situations:\n\nA property declared with a get accessor and no set accessor is considered read-only.\nIn the type of an enum object, enum members are considered read-only properties.\nIn the type of a module object, exported const variables are considered read-only properties.\nAn entity declared in an import statement is considered read-only.\nAn entity accessed through an ES2015 namespace import is considered read-only (e.g. foo.x is read-only when foo is declared as import * as foo from \"foo\").\nExample\ninterface Point {\n  readonly x: number;\n  readonly y: number;\n}\nvar p1: Point = { x: 10, y: 20 };\np1.x = 5; // Error, p1.x is read-only\nvar p2 = { x: 1, y: 1 };\nvar p3: Point = p2; // Ok, read-only alias for p2\np3.x = 5; // Error, p3.x is read-only\np2.x = 5; // Ok, but also changes p3.x because of aliasing\nclass Foo {\n  readonly a = 1;\n  readonly b: string;\n  constructor() {\n    this.b = \"hello\"; // Assignment permitted in constructor\n  }\n}\nlet a: Array<number> = [0, 1, 2, 3, 4];\nlet b: ReadonlyArray<number> = a;\nb[5] = 5; // Error, elements are read-only\nb.push(5); // Error, no push method (because it mutates array)\nb.length = 3; // Error, length is read-only\na = b; // Error, mutating methods are missing\nSpecifying the type of \nthis\n for functions\n\nFollowing up on specifying the type of this in a class or an interface, functions and methods can now declare the type of this they expect.\n\nBy default the type of this inside a function is any. Starting with TypeScript 2.0, you can provide an explicit this parameter. this parameters are fake parameters that come first in the parameter list of a function:\n\nfunction f(this: void) {\n  // make sure `this` is unusable in this standalone function\n}\nthis\n parameters in callbacks\n\nLibraries can also use this parameters to declare how callbacks will be invoked.\n\nExample\ninterface UIElement {\n  addClickListener(onclick: (this: void, e: Event) => void): void;\n}\n\nthis: void means that addClickListener expects onclick to be a function that does not require a this type.\n\nNow if you annotate calling code with this:\n\nclass Handler {\n  info: string;\n  onClickBad(this: Handler, e: Event) {\n    // oops, used this here. using this callback would crash at runtime\n    this.info = e.message;\n  }\n}\nlet h = new Handler();\nuiElement.addClickListener(h.onClickBad); // error!\n--noImplicitThis\n\nA new flag is also added in TypeScript 2.0 to flag all uses of this in functions without an explicit type annotation.\n\nGlob support in \ntsconfig.json\n\nGlob support is here!! Glob support has been one of the most requested features.\n\nGlob-like file patterns are supported two properties include and exclude.\n\nExample\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"noImplicitAny\": true,\n    \"removeComments\": true,\n    \"preserveConstEnums\": true,\n    \"outFile\": \"../../built/local/tsc.js\",\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"**/*.spec.ts\"]\n}\n\nThe supported glob wildcards are:\n\n* matches zero or more characters (excluding directory separators)\n? matches any one character (excluding directory separators)\n**/ recursively matches any subdirectory\n\nIf a segment of a glob pattern includes only * or .*, then only files with supported extensions are included (e.g. .ts, .tsx, and .d.ts by default with .js and .jsx if allowJs is set to true).\n\nIf the files and include are both left unspecified, the compiler defaults to including all TypeScript (.ts, .d.ts and .tsx) files in the containing directory and subdirectories except those excluded using the exclude property. JS files (.js and .jsx) are also included if allowJs is set to true.\n\nIf the files or include properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the outDir compiler option are always excluded unless explicitly included via the files property (even when the exclude property is specified).\n\nFiles included using include can be filtered using the exclude property. However, files included explicitly using the files property are always included regardless of exclude. The exclude property defaults to excluding the node_modules, bower_components, and jspm_packages directories when not specified.\n\nModule resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing\n\nTypeScript 2.0 provides a set of additional module resolution knops to inform the compiler where to find declarations for a given module.\n\nSee Module Resolution documentation for more details.\n\nBase URL\n\nUsing a baseUrl is a common practice in applications using AMD module loaders where modules are “deployed” to a single folder at run-time. All module imports with bare specifier names are assumed to be relative to the baseUrl.\n\nExample\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./modules\"\n  }\n}\n\nNow imports to \"moduleA\" would be looked up in ./modules/moduleA\n\nimport A from \"moduleA\";\nPath mapping\n\nSometimes modules are not directly located under baseUrl. Loaders use a mapping configuration to map module names to files at run-time, see RequireJs documentation and SystemJS documentation.\n\nThe TypeScript compiler supports the declaration of such mappings using paths property in tsconfig.json files.\n\nExample\n\nFor instance, an import to a module \"jquery\" would be translated at runtime to \"node_modules/jquery/dist/jquery.slim.min.js\".\n\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./node_modules\",\n    \"paths\": {\n      \"jquery\": [\"jquery/dist/jquery.slim.min\"]\n    }\n}\n\nUsing paths also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.\n\nVirtual Directories with \nrootDirs\n\nUsing ‘rootDirs’, you can inform the compiler of the roots making up this “virtual” directory; and thus the compiler can resolve relative modules imports within these “virtual” directories as if they were merged together in one directory.\n\nExample\n\nGiven this project structure:\n\n src\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')\n\nA build step will copy the files in /src/views and /generated/templates/views to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as \"./template\".\n\nrootDirs specify a list of roots whose contents are expected to merge at run-time. So following our example, the tsconfig.json file should look like:\n\n{\n  \"compilerOptions\": {\n    \"rootDirs\": [\"src/views\", \"generated/templates/views\"]\n  }\n}\nTracing module resolution\n\ntraceResolution offers a handy way to understand how modules have been resolved by the compiler.\n\ntsc --traceResolution\nShorthand ambient module declarations\n\nIf you don’t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.\n\ndeclarations.d.ts\ndeclare module \"hot-new-module\";\n\nAll imports from a shorthand module will have the any type.\n\nimport x, { y } from \"hot-new-module\";\nx(y);\nWildcard character in module names\n\nImporting none-code resources using module loaders extension (e.g. AMD or SystemJS) has not been easy before; previously an ambient module declaration had to be defined for each resource.\n\nTypeScript 2.0 supports the use of the wildcard character (*) to declare a “family” of module names; this way, a declaration is only required once for an extension, and not for every resource.\n\nExample\ndeclare module \"*!text\" {\n  const content: string;\n  export default content;\n}\n// Some do it the other way around.\ndeclare module \"json!*\" {\n  const value: any;\n  export default value;\n}\n\nNow you can import things that match \"*!text\" or \"json!*\".\n\nimport fileContent from \"./xyz.txt!text\";\nimport data from \"json!http://example.com/data.json\";\nconsole.log(data, fileContent);\n\nWildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as any.\n\nExample\ndeclare module \"myLibrary/*\";\n\nAll imports to any module under myLibrary would be considered to have the type any by the compiler; thus, shutting down any checking on the shapes or types of these modules.\n\nimport { readFile } from \"myLibrary/fileSystem/readFile`;\nreadFile(); // readFile is 'any'\nSupport for UMD module definitions\n\nSome libraries are designed to be used in many module loaders, or with no module loading (global variables). These are known as UMD or Isomorphic modules. These libraries can be accessed through either an import or a global variable.\n\nFor example:\n\nmath-lib.d.ts\nexport const isPrime(x: number): boolean;\nexport as namespace mathLib;\n\nThe library can then be used as an import within modules:\n\nimport { isPrime } from \"math-lib\";\nisPrime(2);\nmathLib.isPrime(2); // ERROR: can't use the global definition from inside a module\n\nIt can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)\n\nmathLib.isPrime(2);\nOptional class properties\n\nOptional properties and methods can now be declared in classes, similar to what is already permitted in interfaces.\n\nExample\nclass Bar {\n  a: number;\n  b?: number;\n  f() {\n    return 1;\n  }\n  g?(): number; // Body of optional method can be omitted\n  h?() {\n    return 2;\n  }\n}\n\nWhen compiled in strictNullChecks mode, optional properties and methods automatically have undefined included in their type. Thus, the b property above is of type number | undefined and the g method above is of type (() => number) | undefined. Type guards can be used to strip away the undefined part of the type:\n\nfunction test(x: Bar) {\n  x.a; // number\n  x.b; // number | undefined\n  x.f; // () => number\n  x.g; // (() => number) | undefined\n  let f1 = x.f(); // number\n  let g1 = x.g && x.g(); // number | undefined\n  let g2 = x.g ? x.g() : 0; // number\n}\nPrivate and Protected Constructors\n\nA class constructor may be marked private or protected. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.\n\nExample\nclass Singleton {\n  private static instance: Singleton;\n  private constructor() {}\n  static getInstance() {\n    if (!Singleton.instance) {\n      Singleton.instance = new Singleton();\n    }\n    return Singleton.instance;\n  }\n}\nlet e = new Singleton(); // Error: constructor of 'Singleton' is private.\nlet v = Singleton.getInstance();\nAbstract properties and accessors\n\nAn abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.\n\nExample\nabstract class Base {\n  abstract name: string;\n  abstract get value();\n  abstract set value(v: number);\n}\nclass Derived extends Base {\n  name = \"derived\";\n  value = 1;\n}\nImplicit index signatures\n\nAn object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:\n\nfunction httpService(path: string, headers: { [x: string]: string }) {}\nconst headers = {\n  \"Content-Type\": \"application/x-www-form-urlencoded\",\n};\nhttpService(\"\", { \"Content-Type\": \"application/x-www-form-urlencoded\" }); // Ok\nhttpService(\"\", headers); // Now ok, previously wasn't\nIncluding built-in type declarations with \n--lib\n\nGetting to ES6/ES2015 built-in API declarations were only limited to target: ES6. Enter lib; with lib you can specify a list of built-in API declaration groups that you can choose to include in your project. For instance, if you expect your runtime to have support for Map, Set and Promise (e.g. most evergreen browsers today), just include --lib es2015.collection,es2015.promise. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using --lib es5,es6.\n\nHere is a list of available API groups:\n\ndom\nwebworker\nes5\nes6 / es2015\nes2015.core\nes2015.collection\nes2015.iterable\nes2015.promise\nes2015.proxy\nes2015.reflect\nes2015.generator\nes2015.symbol\nes2015.symbol.wellknown\nes2016\nes2016.array.include\nes2017\nes2017.object\nes2017.sharedmemory\nscripthost\nExample\ntsc --target es5 --lib es5,es2015.promise\n\"compilerOptions\": {\n    \"lib\": [\"es5\", \"es2015.promise\"]\n}\nFlag unused declarations with \n--noUnusedParameters\n and \n--noUnusedLocals\n\nTypeScript 2.0 has two new flags to help you maintain a clean code base. noUnusedParameters flags any unused function or method parameters errors. noUnusedLocals flags any unused local (un-exported) declaration like variables, functions, classes, imports, etc… Also, unused private members of a class would be flagged as errors under noUnusedLocals.\n\nExample\nimport B, { readFile } from \"./b\";\n//     ^ Error: `B` declared but never used\nreadFile();\nexport function write(message: string, args: string[]) {\n  //                                 ^^^^  Error: 'arg' declared but never used.\n  console.log(message);\n}\n\nParameters declaration with names starting with _ are exempt from the unused parameter checking. e.g.:\n\nfunction returnNull(_a) {\n  // OK\n  return null;\n}\nModule identifiers allow for \n.js\n extension\n\nBefore TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as import d from \"./moduleA.js\", the compiler looked up the definition of \"moduleA.js\" in ./moduleA.js.ts or ./moduleA.js.d.ts. This made it hard to use bundling/loading tools like SystemJS that expect URI’s in their module identifier.\n\nWith TypeScript 2.0, the compiler will look up definition of \"moduleA.js\" in ./moduleA.ts or ./moduleA.d.t.\n\nSupport ‘target : es5’ with ‘module: es6’\n\nPreviously flagged as an invalid flag combination, target: es5 and ‘module: es6’ is now supported. This should facilitate using ES2015-based tree shakers like rollup.\n\nTrailing commas in function parameter and argument lists\n\nTrailing comma in function parameter and argument lists are now allowed. This is an implementation for a Stage-3 ECMAScript proposal that emits down to valid ES3/ES5/ES6.\n\nExample\nfunction foo(\n  bar: Bar,\n  baz: Baz // trailing commas are OK in parameter lists\n) {\n  // Implementation...\n}\nfoo(\n  bar,\n  baz // and in argument lists\n);\nNew \n--skipLibCheck\n\nTypeScript 2.0 adds a new skipLibCheck compiler option that causes type checking of declaration files (files with extension .d.ts) to be skipped. When a program includes large declaration files, the compiler spends a lot of time type checking declarations that are already known to not contain errors, and compile times may be significantly shortened by skipping declaration file type checks.\n\nSince declarations in one file can affect type checking in other files, some errors may not be detected when skipLibCheck is specified. For example, if a non-declaration file augments a type declared in a declaration file, errors may result that are only reported when the declaration file is checked. However, in practice such situations are rare.\n\nAllow duplicate identifiers across declarations\n\nThis has been one common source of duplicate definition errors. Multiple declaration files defining the same members on interfaces.\n\nTypeScript 2.0 relaxes this constraint and allows duplicate identifiers across blocks, as long as they have identical types.\n\nWithin the same block duplicate definitions are still disallowed.\n\nExample\ninterface Error {\n  stack?: string;\n}\ninterface Error {\n  code?: string;\n  path?: string;\n  stack?: string; // OK\n}\nNew \n--declarationDir\n\ndeclarationDir allows for generating declaration files in a different location than JavaScript files.\n\nOn this page\nNull- and undefined-aware types\n--strictNullChecks\nAssigned-before-use checking\nOptional parameters and properties\nNon-null and non-undefined type guards\nDotted names in type guards\nExpression operators\nType widening\nNon-null assertion operator\nCompatibility\nControl flow based type analysis\nTagged union types\nThe never type\nRead-only properties and index signatures\nSpecifying the type of this for functions\nthis parameters in callbacks\n--noImplicitThis\nGlob support in tsconfig.json\nModule resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing\nBase URL\nPath mapping\nVirtual Directories with rootDirs\nTracing module resolution\nShorthand ambient module declarations\nWildcard character in module names\nSupport for UMD module definitions\nOptional class properties\nPrivate and Protected Constructors\nAbstract properties and accessors\nImplicit index signatures\nIncluding built-in type declarations with --lib\nFlag unused declarations with --noUnusedParameters and --noUnusedLocals\nModule identifiers allow for .js extension\nSupport ‘target : es5’ with ‘module: es6’\nTrailing commas in function parameter and argument lists\nNew --skipLibCheck\nAllow duplicate identifiers across declarations\nNew --declarationDir\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nAB\nEC\nK\n9+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.572 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.1",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html",
    "html": "TypeScript 2.1\nkeyof\n and Lookup Types\n\nIn JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn’t been possible to express the type relationships that occur in those APIs.\n\nEnter Index Type Query or keyof; An indexed type query keyof T yields the type of permitted property names for T. A keyof T type is considered a subtype of string.\n\nExample\ninterface Person {\n  name: string;\n  age: number;\n  location: string;\n}\ntype K1 = keyof Person; // \"name\" | \"age\" | \"location\"\ntype K2 = keyof Person[]; // \"length\" | \"push\" | \"pop\" | \"concat\" | ...\ntype K3 = keyof { [x: string]: Person }; // string\n\nThe dual of this is indexed access types, also called lookup types. Syntactically, they look exactly like an element access, but are written as types:\n\nExample\ntype P1 = Person[\"name\"]; // string\ntype P2 = Person[\"name\" | \"age\"]; // string | number\ntype P3 = string[\"charAt\"]; // (pos: number) => string\ntype P4 = string[][\"push\"]; // (...items: string[]) => number\ntype P5 = string[][0]; // string\n\nYou can use this pattern with other parts of the type system to get type-safe lookups.\n\nfunction getProperty<T, K extends keyof T>(obj: T, key: K) {\n  return obj[key]; // Inferred type is T[K]\n}\nfunction setProperty<T, K extends keyof T>(obj: T, key: K, value: T[K]) {\n  obj[key] = value;\n}\nlet x = { foo: 10, bar: \"hello!\" };\nlet foo = getProperty(x, \"foo\"); // number\nlet bar = getProperty(x, \"bar\"); // string\nlet oops = getProperty(x, \"wargarbl\"); // Error! \"wargarbl\" is not \"foo\" | \"bar\"\nsetProperty(x, \"foo\", \"string\"); // Error!, string expected number\nMapped Types\n\nOne common task is to take an existing type and make each of its properties entirely optional. Let’s say we have a Person:\n\ninterface Person {\n  name: string;\n  age: number;\n  location: string;\n}\n\nA partial version of it would be:\n\ninterface PartialPerson {\n  name?: string;\n  age?: number;\n  location?: string;\n}\n\nwith Mapped types, PartialPerson can be written as a generalized transformation on the type Person as:\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\ntype PartialPerson = Partial<Person>;\n\nMapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They’re like list comprehensions in Python, but instead of producing new elements in a list, they produce new properties in a type.\n\nIn addition to Partial, Mapped Types can express many useful transformations on types:\n\n// Keep types the same, but make each property to be read-only.\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n// Same property names, but make the value a promise instead of a concrete one\ntype Deferred<T> = {\n  [P in keyof T]: Promise<T[P]>;\n};\n// Wrap proxies around properties of T\ntype Proxify<T> = {\n  [P in keyof T]: { get(): T[P]; set(v: T[P]): void };\n};\nPartial\n, \nReadonly\n, \nRecord\n, and \nPick\n\nPartial and Readonly, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:\n\nfunction assign<T>(obj: T, props: Partial<T>): void;\nfunction freeze<T>(obj: T): Readonly<T>;\n\nBecause of that, they are now included by default in the standard library.\n\nWe’re also including two other utility types as well: Record and Pick.\n\n// From T pick a set of properties K\ndeclare function pick<T, K extends keyof T>(obj: T, ...keys: K[]): Pick<T, K>;\nconst nameAndAgeOnly = pick(person, \"name\", \"age\"); // { name: string, age: number }\n// For every properties K of type T, transform it to U\nfunction mapObject<K extends string, T, U>(\n  obj: Record<K, T>,\n  f: (x: T) => U\n): Record<K, U>;\nconst names = { foo: \"hello\", bar: \"world\", baz: \"bye\" };\nconst lengths = mapObject(names, s => s.length); // { foo: number, bar: number, baz: number }\nObject Spread and Rest\n\nTypeScript 2.1 brings support for ESnext Spread and Rest.\n\nSimilar to array spread, spreading an object can be handy to get a shallow copy:\n\nlet copy = { ...original };\n\nSimilarly, you can merge several different objects. In the following example, merged will have properties from foo, bar, and baz.\n\nlet merged = { ...foo, ...bar, ...baz };\n\nYou can also override existing properties and add new ones:\n\nlet obj = { x: 1, y: \"string\" };\nvar newObj = { ...obj, z: 3, y: 4 }; // { x: number, y: number, z: number }\n\nThe order of specifying spread operations determines what properties end up in the resulting object; properties in later spreads “win out” over previously created properties.\n\nObject rests are the dual of object spreads, in that they can extract any extra properties that don’t get picked up when destructuring an element:\n\nlet obj = { x: 1, y: 1, z: 1 };\nlet { z, ...obj1 } = obj;\nobj1; // {x: number, y:number};\nDownlevel Async Functions\n\nThis feature was supported before TypeScript 2.1, but only when targeting ES6/ES2015. TypeScript 2.1 brings the capability to ES3 and ES5 run-times, meaning you’ll be free to take advantage of it no matter what environment you’re using.\n\nNote: first, we need to make sure our run-time has an ECMAScript-compliant Promise available globally. That might involve grabbing a polyfill for Promise, or relying on one that you might have in the run-time that you’re targeting. We also need to make sure that TypeScript knows Promise exists by setting your lib option to something like \"dom\", \"es2015\" or \"dom\", \"es2015.promise\", \"es5\"\n\nExample\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"es2015.promise\", \"es5\"]\n  }\n}\ndramaticWelcome.ts\nfunction delay(milliseconds: number) {\n  return new Promise<void>(resolve => {\n    setTimeout(resolve, milliseconds);\n  });\n}\nasync function dramaticWelcome() {\n  console.log(\"Hello\");\n  for (let i = 0; i < 3; i++) {\n    await delay(500);\n    console.log(\".\");\n  }\n  console.log(\"World!\");\n}\ndramaticWelcome();\n\nCompiling and running the output should result in the correct behavior on an ES3/ES5 engine.\n\nSupport for external helpers library (\ntslib\n)\n\nTypeScript injects a handful of helper functions such as __extends for inheritance, __assign for spread operator in object literals and JSX elements, and __awaiter for async functions.\n\nPreviously there were two options:\n\ninject helpers in every file that needs them, or\nno helpers at all with noEmitHelpers.\n\nThe two options left more to be desired; bundling the helpers in every file was a pain point for customers trying to keep their package size small. And not including helpers, meant customers had to maintain their own helpers library.\n\nTypeScript 2.1 allows for including these files in your project once in a separate module, and the compiler will emit imports to them as needed.\n\nFirst, install the tslib utility library:\n\nnpm install tslib\n\nSecond, compile your files using importHelpers:\n\ntsc --module commonjs --importHelpers a.ts\n\nSo given the following input, the resulting .js file will include an import to tslib and use the __assign helper from it instead of inlining it.\n\nexport const o = { a: 1, name: \"o\" };\nexport const copy = { ...o };\n\"use strict\";\nvar tslib_1 = require(\"tslib\");\nexports.o = { a: 1, name: \"o\" };\nexports.copy = tslib_1.__assign({}, exports.o);\nUntyped imports\n\nTypeScript has traditionally been overly strict about how you can import modules. This was to avoid typos and prevent users from using modules incorrectly.\n\nHowever, a lot of the time, you might just want to import an existing module that may not have its own .d.ts file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.\n\nWith TypeScript 2.1, you can import a JavaScript module without needing a type declaration. A type declaration (such as declare module \"foo\" { ... } or node_modules/@types/foo) still takes priority if it exists.\n\nAn import to a module with no declaration file will still be flagged as an error under noImplicitAny.\n\nExample\n// Succeeds if `node_modules/asdf/index.js` exists\nimport { x } from \"asdf\";\nSupport for \n--target ES2016\n, \n--target ES2017\n and \n--target ESNext\n\nTypeScript 2.1 supports three new target values --target ES2016, --target ES2017 and --target ESNext.\n\nUsing target --target ES2016 will instruct the compiler not to transform ES2016-specific features, e.g. ** operator.\n\nSimilarly, --target ES2017 will instruct the compiler not to transform ES2017-specific features like async/await.\n\n--target ESNext targets latest supported ES proposed features.\n\nImproved \nany\n Inference\n\nPreviously, if TypeScript couldn’t figure out the type of a variable, it would choose the any type.\n\nlet x; // implicitly 'any'\nlet y = []; // implicitly 'any[]'\nlet z: any; // explicitly 'any'.\n\nWith TypeScript 2.1, instead of just choosing any, TypeScript will infer types based on what you end up assigning later on.\n\nThis is only enabled if noImplicitAny is set.\n\nExample\nlet x;\n// You can still assign anything you want to 'x'.\nx = () => 42;\n// After that last assignment, TypeScript 2.1 knows that 'x' has type '() => number'.\nlet y = x();\n// Thanks to that, it will now tell you that you can't add a number to a function!\nconsole.log(x + y);\n//          ~~~~~\n// Error! Operator '+' cannot be applied to types '() => number' and 'number'.\n// TypeScript still allows you to assign anything you want to 'x'.\nx = \"Hello world!\";\n// But now it also knows that 'x' is a 'string'!\nx.toLowerCase();\n\nThe same sort of tracking is now also done for empty arrays.\n\nA variable declared with no type annotation and an initial value of [] is considered an implicit any[] variable. However, each subsequent x.push(value), x.unshift(value) or x[n] = value operation evolves the type of the variable in accordance with what elements are added to it.\n\nfunction f1() {\n  let x = [];\n  x.push(5);\n  x[1] = \"hello\";\n  x.unshift(true);\n  return x; // (string | number | boolean)[]\n}\nfunction f2() {\n  let x = null;\n  if (cond()) {\n    x = [];\n    while (cond()) {\n      x.push(\"hello\");\n    }\n  }\n  return x; // string[] | null\n}\nImplicit any errors\n\nOne great benefit of this is that you’ll see way fewer implicit any errors when running with noImplicitAny. Implicit any errors are only reported when the compiler is unable to know the type of a variable without a type annotation.\n\nExample\nfunction f3() {\n  let x = []; // Error: Variable 'x' implicitly has type 'any[]' in some locations where its type cannot be determined.\n  x.push(5);\n  function g() {\n    x; // Error: Variable 'x' implicitly has an 'any[]' type.\n  }\n}\nBetter inference for literal types\n\nString, numeric and boolean literal types (e.g. \"abc\", 1, and true) were previously inferred only in the presence of an explicit type annotation. Starting with TypeScript 2.1, literal types are always inferred for const variables and readonly properties.\n\nThe type inferred for a const variable or readonly property without a type annotation is the type of the literal initializer. The type inferred for a let variable, var variable, parameter, or non-readonly property with an initializer and no type annotation is the widened literal type of the initializer. Where the widened type for a string literal type is string, number for numeric literal types, boolean for true or false and the containing enum for enum literal types.\n\nExample\nconst c1 = 1; // Type 1\nconst c2 = c1; // Type 1\nconst c3 = \"abc\"; // Type \"abc\"\nconst c4 = true; // Type true\nconst c5 = cond ? 1 : \"abc\"; // Type 1 | \"abc\"\nlet v1 = 1; // Type number\nlet v2 = c2; // Type number\nlet v3 = c3; // Type string\nlet v4 = c4; // Type boolean\nlet v5 = c5; // Type number | string\n\nLiteral type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that const variable gets a widening literal type inferred. But when a const location has an explicit literal type annotation, the const variable gets a non-widening literal type.\n\nExample\nconst c1 = \"hello\"; // Widening type \"hello\"\nlet v1 = c1; // Type string\nconst c2: \"hello\" = \"hello\"; // Type \"hello\"\nlet v2 = c2; // Type \"hello\"\nUse returned values from super calls as ‘this’\n\nIn ES2015, constructors which return an object implicitly substitute the value of this for any callers of super(). As a result, it is necessary to capture any potential return value of super() and replace it with this. This change enables working with Custom Elements, which takes advantage of this to initialize browser-allocated elements with user-written constructors.\n\nExample\nclass Base {\n  x: number;\n  constructor() {\n    // return a new object other than `this`\n    return {\n      x: 1\n    };\n  }\n}\nclass Derived extends Base {\n  constructor() {\n    super();\n    this.x = 2;\n  }\n}\n\nGenerates:\n\nvar Derived = (function(_super) {\n  __extends(Derived, _super);\n  function Derived() {\n    var _this = _super.call(this) || this;\n    _this.x = 2;\n    return _this;\n  }\n  return Derived;\n})(Base);\n\nThis change entails a break in the behavior of extending built-in classes like Error, Array, Map, etc.. Please see the extending built-ins breaking change documentation for more details.\n\nConfiguration inheritance\n\nOften a project has multiple output targets, e.g. ES5 and ES2015, debug and production or CommonJS and System; Just a few configuration options change between these two targets, and maintaining multiple tsconfig.json files can be a hassle.\n\nTypeScript 2.1 supports inheriting configuration using extends, where:\n\nextends is a new top-level property in tsconfig.json (alongside compilerOptions, files, include, and exclude).\nThe value of extends must be a string containing a path to another configuration file to inherit from.\nThe configuration from the base file are loaded first, then overridden by those in the inheriting config file.\nCircularity between configuration files is not allowed.\nfiles, include, and exclude from the inheriting config file overwrite those from the base config file.\nAll relative paths found in the configuration file will be resolved relative to the configuration file they originated in.\nExample\n\nconfigs/base.json:\n\n{\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true\n  }\n}\n\ntsconfig.json:\n\n{\n  \"extends\": \"./configs/base\",\n  \"files\": [\"main.ts\", \"supplemental.ts\"]\n}\n\ntsconfig.nostrictnull.json:\n\n{\n  \"extends\": \"./tsconfig\",\n  \"compilerOptions\": {\n    \"strictNullChecks\": false\n  }\n}\nNew \n--alwaysStrict\n\nInvoking the compiler with alwaysStrict causes:\n\nParses all the code in strict mode.\nWrites \"use strict\"; directive atop every generated file.\n\nModules are parsed automatically in strict mode. The new flag is recommended for non-module code.\n\nOn this page\nkeyof and Lookup Types\nMapped Types\nPartial, Readonly, Record, and Pick\nObject Spread and Rest\nDownlevel Async Functions\nSupport for external helpers library (tslib)\nUntyped imports\nSupport for --target ES2016, --target ES2017 and --target ESNext\nImproved any Inference\nImplicit any errors\nBetter inference for literal types\nUse returned values from super calls as ‘this’\nConfiguration inheritance\nNew --alwaysStrict\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nAG\nJB\nM\n9+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.414 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.2",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-2.html",
    "html": "TypeScript 2.2\nSupport for Mix-in classes\n\nTypeScript 2.2 adds support for the ECMAScript 2015 mixin class pattern (see MDN Mixin description and “Real” Mixins with JavaScript Classes for more details) as well as rules for combining mixin construct signatures with regular construct signatures in intersection types.\n\nFirst some terminology\n\nA mixin constructor type refers to a type that has a single construct signature with a single rest argument of type any[] and an object-like return type. For example, given an object-like type X, new (...args: any[]) => X is a mixin constructor type with an instance type X.\n\nA mixin class is a class declaration or expression that extends an expression of a type parameter type. The following rules apply to mixin class declarations:\n\nThe type parameter type of the extends expression must be constrained to a mixin constructor type.\nThe constructor of a mixin class (if any) must have a single rest parameter of type any[] and must use the spread operator to pass those parameters as arguments in a super(...args) call.\n\nGiven an expression Base of a parametric type T with a constraint X, a mixin class class C extends Base {...} is processed as if Base had type X and the resulting type is the intersection typeof C & T. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.\n\nWhen obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type { new(...args: any[]) => A } & { new(s: string) => B } has a single construct signature new(s: string) => A & B.\n\nPutting all of the above rules together in an example\nclass Point {\n  constructor(public x: number, public y: number) {}\n}\nclass Person {\n  constructor(public name: string) {}\n}\ntype Constructor<T> = new (...args: any[]) => T;\nfunction Tagged<T extends Constructor<{}>>(Base: T) {\n  return class extends Base {\n    _tag: string;\n    constructor(...args: any[]) {\n      super(...args);\n      this._tag = \"\";\n    }\n  };\n}\nconst TaggedPoint = Tagged(Point);\nlet point = new TaggedPoint(10, 20);\npoint._tag = \"hello\";\nclass Customer extends Tagged(Person) {\n  accountBalance: number;\n}\nlet customer = new Customer(\"Joe\");\ncustomer._tag = \"test\";\ncustomer.accountBalance = 0;\n\nMixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following WithLocation function implements a subclass factory that adds a getLocation method to any class that satisfies the Point interface (i.e. that has x and y properties of type number).\n\ninterface Point {\n  x: number;\n  y: number;\n}\nconst WithLocation = <T extends Constructor<Point>>(Base: T) =>\n  class extends Base {\n    getLocation(): [number, number] {\n      return [this.x, this.y];\n    }\n  };\nobject\n type\n\nTypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not number, string, boolean, symbol, null, or undefined. Enter the new object type.\n\nWith object type, APIs like Object.create can be better represented. For example:\n\ndeclare function create(o: object | null): void;\ncreate({ prop: 0 }); // OK\ncreate(null); // OK\ncreate(42); // Error\ncreate(\"string\"); // Error\ncreate(false); // Error\ncreate(undefined); // Error\nSupport for \nnew.target\n\nThe new.target meta-property is new syntax introduced in ES2015. When an instance of a constructor is created via new, the value of new.target is set to be a reference to the constructor function initially used to allocate the instance. If a function is called rather than constructed via new, new.target is set to undefined.\n\nnew.target comes in handy when Object.setPrototypeOf or __proto__ needs to be set in a class constructor. One such use case is inheriting from Error in NodeJS v4 and higher.\n\nExample\nclass CustomError extends Error {\n  constructor(message?: string) {\n    super(message); // 'Error' breaks prototype chain here\n    Object.setPrototypeOf(this, new.target.prototype); // restore prototype chain\n  }\n}\n\nThis results in the generated JS\n\nvar CustomError = (function(_super) {\n  __extends(CustomError, _super);\n  function CustomError() {\n    var _newTarget = this.constructor;\n    var _this = _super.apply(this, arguments); // 'Error' breaks prototype chain here\n    _this.__proto__ = _newTarget.prototype; // restore prototype chain\n    return _this;\n  }\n  return CustomError;\n})(Error);\n\nnew.target also comes in handy for writing constructable functions, for example:\n\nfunction f() {\n  if (new.target) {\n    /* called via 'new' */\n  }\n}\n\nWhich translates to:\n\nfunction f() {\n  var _newTarget = this && this instanceof f ? this.constructor : void 0;\n  if (_newTarget) {\n    /* called via 'new' */\n  }\n}\nBetter checking for \nnull\n/\nundefined\n in operands of expressions\n\nTypeScript 2.2 improves checking of nullable operands in expressions. Specifically, these are now flagged as errors:\n\nIf either operand of a + operator is nullable, and neither operand is of type any or string.\nIf either operand of a -, *, **, /, %, <<, >>, >>>, &, |, or ^ operator is nullable.\nIf either operand of a <, >, <=, >=, or in operator is nullable.\nIf the right operand of an instanceof operator is nullable.\nIf the operand of a +, -, ~, ++, or -- unary operator is nullable.\n\nAn operand is considered nullable if the type of the operand is null or undefined or a union type that includes null or undefined. Note that the union type case only only occurs in strictNullChecks mode because null and undefined disappear from unions in classic type checking mode.\n\nDotted property for types with string index signatures\n\nTypes with a string index signature can be indexed using the [] notation, but were not allowed to use the .. Starting with TypeScript 2.2 using either should be allowed.\n\ninterface StringMap<T> {\n  [x: string]: T;\n}\nconst map: StringMap<number>;\nmap[\"prop1\"] = 1;\nmap.prop2 = 2;\n\nThis only apply to types with an explicit string index signature. It is still an error to access unknown properties on a type using . notation.\n\nSupport for spread operator on JSX element children\n\nTypeScript 2.2 adds support for using spread on a JSX element children. Please see facebook/jsx#57 for more details.\n\nExample\nfunction Todo(prop: { key: number; todo: string }) {\n  return <div>{prop.key.toString() + prop.todo}</div>;\n}\nfunction TodoList({ todos }: TodoListProps) {\n  return (\n    <div>{...todos.map(todo => <Todo key={todo.id} todo={todo.todo} />)}</div>\n  );\n}\nlet x: TodoListProps;\n<TodoList {...x} />;\nNew \njsx: react-native\n\nReact-native build pipeline expects all files to have a .js extensions even if the file contains JSX syntax. The new jsx value react-native will persevere the JSX syntax in the output file, but give it a .js extension.\n\nOn this page\nSupport for Mix-in classes\nobject type\nSupport for new.target\nBetter checking for null/undefined in operands of expressions\nDotted property for types with string index signatures\nSupport for spread operator on JSX element children\nNew jsx: react-native\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nJB\nEB\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.402 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.3",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-3.html",
    "html": "TypeScript 2.3\nGenerators and Iteration for ES5/ES3\n\nFirst some ES2016 terminology:\n\nIterators\n\nES2015 introduced Iterator, which is an object that exposes three methods, next, return, and throw, as per the following interface:\n\ninterface Iterator<T> {\n  next(value?: any): IteratorResult<T>;\n  return?(value?: any): IteratorResult<T>;\n  throw?(e?: any): IteratorResult<T>;\n}\n\nThis kind of iterator is useful for iterating over synchronously available values, such as the elements of an Array or the keys of a Map. An object that supports iteration is said to be “iterable” if it has a Symbol.iterator method that returns an Iterator object.\n\nThe Iterator protocol also defines the target of some of the ES2015 features like for..of and spread operator and the array rest in destructuring assignments.\n\nGenerators\n\nES2015 also introduced “Generators”, which are functions that can be used to yield partial computation results via the Iterator interface and the yield keyword. Generators can also internally delegate calls to another iterable through yield *. For example:\n\nfunction* f() {\n  yield 1;\n  yield* [2, 3];\n}\nNew --downlevelIteration\n\nPreviously generators were only supported if the target is ES6/ES2015 or later. Moreover, constructs that operate on the Iterator protocol, e.g. for..of were only supported if they operate on arrays for targets below ES6/ES2015.\n\nTypeScript 2.3 adds full support for generators and the Iterator protocol for ES3 and ES5 targets with downlevelIteration flag.\n\nWith downlevelIteration, the compiler uses new type check and emit behavior that attempts to call a [Symbol.iterator]() method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.\n\nPlease note that this requires a native Symbol.iterator or Symbol.iterator shim at runtime for any non-array values.\n\nfor..of statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support Symbol.iterator in ES5/E3 if available when using downlevelIteration, but can be used on an Array even if it does not define Symbol.iterator at run time or design time.\n\nAsync Iteration\n\nTypeScript 2.3 adds support for the async iterators and generators as described by the current TC39 proposal.\n\nAsync iterators\n\nThe Async Iteration introduces an AsyncIterator, which is similar to Iterator. The difference lies in the fact that the next, return, and throw methods of an AsyncIterator return a Promise for the iteration result, rather than the result itself. This allows the caller to enlist in an asynchronous notification for the time at which the AsyncIterator has advanced to the point of yielding a value. An AsyncIterator has the following shape:\n\ninterface AsyncIterator<T> {\n  next(value?: any): Promise<IteratorResult<T>>;\n  return?(value?: any): Promise<IteratorResult<T>>;\n  throw?(e?: any): Promise<IteratorResult<T>>;\n}\n\nAn object that supports async iteration is said to be “iterable” if it has a Symbol.asyncIterator method that returns an AsyncIterator object.\n\nAsync Generators\n\nThe Async Iteration proposal introduces “Async Generators”, which are async functions that also can be used to yield partial computation results. Async Generators can also delegate calls via yield* to either an iterable or async iterable:\n\nasync function* g() {\n  yield 1;\n  await sleep(100);\n  yield* [2, 3];\n  yield* (async function*() {\n    await sleep(100);\n    yield 4;\n  })();\n}\n\nAs with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global Promise implementation (either native or an ES2015-compatible polyfill), in addition to a valid Symbol.asyncIterator reference (either a native symbol or a shim).\n\nThe for-await-of Statement\n\nFinally, ES2015 introduced the for..of statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the for..await..of statement to iterate over an async iterable:\n\nasync function f() {\n  for await (const x of g()) {\n    console.log(x);\n  }\n}\n\nThe for..await..of statement is only legal within an Async Function or Async Generator.\n\nCaveats\nKeep in mind that our support for async iterators relies on support for Symbol.asyncIterator to exist at runtime. You may need to polyfill Symbol.asyncIterator, which for simple purposes can be as simple as: (Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(\"Symbol.asyncIterator\");\nYou also need to include esnext in your lib option, to get the AsyncIterator declaration if you do not already have it.\nFinally, if your target is ES5 or ES3, you’ll also need to set the --downlevelIterators flag.\nGeneric parameter defaults\n\nTypeScript 2.3 adds support for declaring defaults for generic type parameters.\n\nExample\n\nConsider a function that creates a new HTMLElement, calling it with no arguments generates a Div; you can optionally pass a list of children as well. Previously you would have to define it as:\n\ndeclare function create(): Container<HTMLDivElement, HTMLDivElement[]>;\ndeclare function create<T extends HTMLElement>(element: T): Container<T, T[]>;\ndeclare function create<T extends HTMLElement, U extends HTMLElement>(\n  element: T,\n  children: U[]\n): Container<T, U[]>;\n\nWith generic parameter defaults we can reduce it to:\n\ndeclare function create<T extends HTMLElement = HTMLDivElement, U = T[]>(\n  element?: T,\n  children?: U\n): Container<T, U>;\n\nA generic parameter default follows the following rules:\n\nA type parameter is deemed optional if it has a default.\nRequired type parameters must not follow optional type parameters.\nDefault types for a type parameter must satisfy the constraint for the type parameter, if it exists.\nWhen specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.\nIf a default type is specified and inference cannot choose a candidate, the default type is inferred.\nA class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.\nA class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.\nNew \n--strict\n master option\n\nNew checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the strict option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.\n\nThe new strict compiler option represents the recommended setting of a number of type checking options. Specifically, specifying strict corresponds to specifying all of the following options (and may in the future include more options):\n\nstrictNullChecks\nnoImplicitAny\nnoImplicitThis\nalwaysStrict\n\nIn exact terms, the strict option sets the default value for the compiler options listed above. This means it is still possible to individually control the options. For example,\n\n--strict --noImplicitThis false\n\nhas the effect of turning on all strict options except the noImplicitThis option. Using this scheme it is possible to express configurations consisting of all strict options except some explicitly listed options. In other words, it is now possible to default to the highest level of type safety but opt out of certain checks.\n\nStarting with TypeScript 2.3, the default tsconfig.json generated by tsc --init includes a \"strict\": true setting in the \"compilerOptions\" section. Thus, new projects started with tsc --init will by default have the highest level of type safety enabled.\n\nEnhanced \n--init\n output\n\nAlong with setting strict on by default, tsc --init has an enhanced output. Default tsconfig.json files generated by tsc --init now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.\n\nErrors in .js files with \n--checkJs\n\nBy default the TypeScript compiler does not report any errors in .js files including using allowJs. With TypeScript 2.3 type-checking errors can also be reported in .js files with checkJs.\n\nYou can skip checking some files by adding // @ts-nocheck comment to them; conversely you can choose to check only a few .js files by adding // @ts-check comment to them without setting checkJs. You can also ignore errors on specific lines by adding // @ts-ignore on the preceding line.\n\n.js files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in .ts files and are flagged as errors in .js files. JSDoc comments can be used to add some type information to your JavaScript code, see JSDoc Support documentation for more details about the supported JSDoc constructs.\n\nSee Type checking JavaScript Files documentation for more details.\n\nOn this page\nGenerators and Iteration for ES5/ES3\nAsync Iteration\nGeneric parameter defaults\nNew --strict master option\nEnhanced --init output\nErrors in .js files with --checkJs\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nNS\nJB\nLR\n7+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.374 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.4",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html",
    "html": "TypeScript 2.4\nDynamic Import Expressions\n\nDynamic import expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.\n\nThis means that you can conditionally and lazily import other modules and libraries. For example, here’s an async function that only imports a utility library when it’s needed:\n\nasync function getZipFile(name: string, files: File[]): Promise<File> {\n  const zipUtil = await import(\"./utils/create-zip-file\");\n  const zipContents = await zipUtil.getContentAsBlob(files);\n  return new File(zipContents, name);\n}\n\nMany bundlers have support for automatically splitting output bundles based on these import expressions, so consider using this new feature with the esnext module target.\n\nString Enums\n\nTypeScript 2.4 now allows enum members to contain string initializers.\n\nenum Colors {\n  Red = \"RED\",\n  Green = \"GREEN\",\n  Blue = \"BLUE\"\n}\n\nThe caveat is that string-initialized enums can’t be reverse-mapped to get the original enum member name. In other words, you can’t write Colors[\"RED\"] to get the string \"Red\".\n\nImproved inference for generics\n\nTypeScript 2.4 introduces a few wonderful changes around the way generics are inferred.\n\nReturn types as inference targets\n\nFor one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:\n\nfunction arrayMap<T, U>(f: (x: T) => U): (a: T[]) => U[] {\n  return a => a.map(f);\n}\nconst lengths: (a: string[]) => number[] = arrayMap(s => s.length);\n\nAs an example of new errors you might spot as a result:\n\nlet x: Promise<string> = new Promise(resolve => {\n  resolve(10);\n  //      ~~ Error!\n});\nType parameter inference from contextual types\n\nPrior to TypeScript 2.4, in the following example\n\nlet f: <T>(x: T) => T = y => y;\n\ny would have the type any. This meant the program would type-check, but you could technically do anything with y, such as the following:\n\nlet f: <T>(x: T) => T = y => y() + y.foo.bar;\n\nThat last example isn’t actually type-safe.\n\nIn TypeScript 2.4, the function on the right side implicitly gains type parameters, and y is inferred to have the type of that type-parameter.\n\nIf you use y in a way that the type parameter’s constraint doesn’t support, you’ll correctly get an error. In this case, the constraint of T was (implicitly) {}, so the last example will appropriately fail.\n\nStricter checking for generic functions\n\nTypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you’ll get stricter checks when relating two generic signatures, and may catch some bugs.\n\ntype A = <T, U>(x: T, y: U) => [T, U];\ntype B = <S>(x: S, y: S) => [S, S];\nfunction f(a: A, b: B) {\n  a = b; // Error\n  b = a; // Ok\n}\nStrict contravariance for callback parameters\n\nTypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with Promises and Observables.\n\nTypeScript 2.4 introduces tightens this up when relating two callback types. For example:\n\ninterface Mappable<T> {\n  map<U>(f: (x: T) => U): Mappable<U>;\n}\ndeclare let a: Mappable<number>;\ndeclare let b: Mappable<string | number>;\na = b;\nb = a;\n\nPrior to TypeScript 2.4, this example would succeed. When relating the types of map, TypeScript would bidirectionally relate their parameters (i.e. the type of f). When relating each f, TypeScript would also bidirectionally relate the type of those parameters.\n\nWhen relating the type of map in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.\n\nIn other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.\n\nWeak Type Detection\n\nTypeScript 2.4 introduces the concept of “weak types”. Any type that contains nothing but a set of all-optional properties is considered to be weak. For example, this Options type is a weak type:\n\ninterface Options {\n  data?: string;\n  timeout?: number;\n  maxRetries?: number;\n}\n\nIn TypeScript 2.4, it’s now an error to assign anything to a weak type when there’s no overlap in properties. For example:\n\nfunction sendMessage(options: Options) {\n  // ...\n}\nconst opts = {\n  payload: \"hello world!\",\n  retryOnFail: true\n};\n// Error!\nsendMessage(opts);\n// No overlap between the type of 'opts' and 'Options' itself.\n// Maybe we meant to use 'data'/'maxRetries' instead of 'payload'/'retryOnFail'.\n\nYou can think of this as TypeScript “toughening up” the weak guarantees of these types to catch what would otherwise be silent bugs.\n\nSince this is a breaking change, you may need to know about the workarounds which are the same as those for strict object literal checks:\n\nDeclare the properties if they really do exist.\nAdd an index signature to the weak type (i.e. [propName: string]: {}).\nUse a type assertion (i.e. opts as Options).\nOn this page\nDynamic Import Expressions\nString Enums\nImproved inference for generics\nReturn types as inference targets\nType parameter inference from contextual types\nStricter checking for generic functions\nStrict contravariance for callback parameters\nWeak Type Detection\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.319 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.6",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html",
    "html": "TypeScript 2.6\nStrict function types\n\nTypeScript 2.6 introduces a new strict checking flag, strictFunctionTypes. The strictFunctionTypes switch is part of the strict family of switches, meaning that it defaults to on in strict mode. You can opt-out by setting --strictFunctionTypes false on your command line or in your tsconfig.json.\n\nUnder strictFunctionTypes function type parameter positions are checked contravariantly instead of bivariantly. For some background on what variance means for function types check out What are covariance and contravariance?.\n\nThe stricter checking applies to all function types, except those originating in method or constructor declarations. Methods are excluded specifically to ensure generic classes and interfaces (such as Array<T>) continue to mostly relate covariantly.\n\nConsider the following example in which Animal is the supertype of Dog and Cat:\n\ndeclare let f1: (x: Animal) => void;\ndeclare let f2: (x: Dog) => void;\ndeclare let f3: (x: Cat) => void;\nf1 = f2; // Error with --strictFunctionTypes\nf2 = f1; // Ok\nf2 = f3; // Error\n\nThe first assignment is permitted in default type checking mode, but flagged as an error in strict function types mode. Intuitively, the default mode permits the assignment because it is possibly sound, whereas strict function types mode makes it an error because it isn’t provably sound. In either mode the third assignment is an error because it is never sound.\n\nAnother way to describe the example is that the type (x: T) => void is bivariant (i.e. covariant or contravariant) for T in default type checking mode, but contravariant for T in strict function types mode.\n\nExample\ninterface Comparer<T> {\n  compare: (a: T, b: T) => number;\n}\ndeclare let animalComparer: Comparer<Animal>;\ndeclare let dogComparer: Comparer<Dog>;\nanimalComparer = dogComparer; // Error\ndogComparer = animalComparer; // Ok\n\nThe first assignment is now an error. Effectively, T is contravariant in Comparer<T> because it is used only in function type parameter positions.\n\nBy the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (out/in or +/-), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript’s structural type system.\n\nNote\n\nUnder strictFunctionTypes the first assignment is still permitted if compare was declared as a method. Effectively, T is bivariant in Comparer<T> because it is used only in method parameter positions.\n\ninterface Comparer<T> {\n  compare(a: T, b: T): number;\n}\ndeclare let animalComparer: Comparer<Animal>;\ndeclare let dogComparer: Comparer<Dog>;\nanimalComparer = dogComparer; // Ok because of bivariance\ndogComparer = animalComparer; // Ok\n\nTypeScript 2.6 also improves type inference involving contravariant positions:\n\nfunction combine<T>(...funcs: ((x: T) => void)[]): (x: T) => void {\n  return x => {\n    for (const f of funcs) f(x);\n  };\n}\nfunction animalFunc(x: Animal) {}\nfunction dogFunc(x: Dog) {}\nlet combined = combine(animalFunc, dogFunc); // (x: Dog) => void\n\nAbove, all inferences for T originate in contravariant positions, and we therefore infer the best common subtype for T. This contrasts with inferences from covariant positions, where we infer the best common supertype.\n\nCache tagged template objects in modules\n\nTypeScript 2.6 fixes the tagged string template emit to align better with the ECMAScript spec. As per the ECMAScript spec, every time a template tag is evaluated, the same template strings object (the same TemplateStringsArray) should be passed as the first argument. Before TypeScript 2.6, the generated output was a completely new template object each time. Though the string contents are the same, this emit affects libraries that use the identity of the string for cache invalidation purposes, e.g. lit-html.\n\nExample\nexport function id(x: TemplateStringsArray) {\n  return x;\n}\nexport function templateObjectFactory() {\n  return id`hello world`;\n}\nlet result = templateObjectFactory() === templateObjectFactory(); // true in TS 2.6\n\nResults in the following generated code:\n\n\"use strict\";\nvar __makeTemplateObject =\n  (this && this.__makeTemplateObject) ||\n  function(cooked, raw) {\n    if (Object.defineProperty) {\n      Object.defineProperty(cooked, \"raw\", { value: raw });\n    } else {\n      cooked.raw = raw;\n    }\n    return cooked;\n  };\nfunction id(x) {\n  return x;\n}\nvar _a;\nfunction templateObjectFactory() {\n  return id(\n    _a || (_a = __makeTemplateObject([\"hello world\"], [\"hello world\"]))\n  );\n}\nvar result = templateObjectFactory() === templateObjectFactory();\n\nNote: This change brings a new emit helper, __makeTemplateObject; if you are using importHelpers with tslib, an updated to version 1.8 or later.\n\nLocalized diagnostics on the command line\n\nTypeScript 2.6 npm package ships with localized versions of diagnostic messages for 13 languages. The localized messages are available when using --locale flag on the command line.\n\nExample\n\nError messages in Russian:\n\nc:\\ts>tsc --v\nVersion 2.6.0-dev.20171003\nc:\\ts>tsc --locale ru --pretty c:\\test\\a.ts\n../test/a.ts(1,5): error TS2322: Тип \"\"string\"\" не может быть назначен для типа \"number\".\n1 var x: number = \"string\";\n      ~\n\nAnd help in Japanese:\n\nPS C:\\ts> tsc --v\nVersion 2.6.0-dev.20171003\nPS C:\\ts> tsc --locale ja-jp\nバージョン 2.6.0-dev.20171003\n構文: tsc [オプション] [ファイル ...]\n例:  tsc hello.ts\n    tsc --outFile file.js file.ts\n    tsc @args.txt\nオプション:\n -h, --help                                 このメッセージを表示します。\n --all                                      コンパイラ オプションをすべて表示します。\n -v, --version                              コンパイラのバージョンを表示します。\n --init                                     TypeScript プロジェクトを初期化して、tsconfig.json ファイルを作成します。\n -p ファイルまたはディレクトリ, --project ファイルまたはディレクトリ  構成ファイルか、'tsconfig.json' を含むフォルダーにパスが指定されたプロジェクトをコ\nンパイルします。\n --pretty                                   色とコンテキストを使用してエラーとメッセージにスタイルを適用します (試験的)。\n -w, --watch                                入力ファイルを監視します。\n -t バージョン, --target バージョン                   ECMAScript のターゲット バージョンを指定します: 'ES3' (既定)、'ES5'、'ES2015'、'ES2016'、'ES2017'、'ES\nNEXT'。\n -m 種類, --module 種類                         モジュール コード生成を指定します: 'none'、'commonjs'、'amd'、'system'、'umd'、'es2015'、'ESNext'。\n --lib                                      コンパイルに含めるライブラリ ファイルを指定します:\n                                              'es5' 'es6' 'es2015' 'es7' 'es2016' 'es2017' 'esnext' 'dom' 'dom.iterable' 'webworker' 'scripthost' 'es201\n5.core' 'es2015.collection' 'es2015.generator' 'es2015.iterable' 'es2015.promise' 'es2015.proxy' 'es2015.reflect' 'es2015.symbol' 'es2015.symbol.wellkno\nwn' 'es2016.array.include' 'es2017.object' 'es2017.sharedmemory' 'es2017.string' 'es2017.intl' 'esnext.asynciterable'\n --allowJs                                  javascript ファイルのコンパイルを許可します。\n --jsx 種類                                   JSX コード生成を指定します: 'preserve'、'react-native'、'react'。\n -d, --declaration                          対応する '.d.ts' ファイルを生成します。\n --sourceMap                                対応する '.map' ファイルを生成します。\n --outFile ファイル                             出力を連結して 1 つのファイルを生成します。\n --outDir ディレクトリ                            ディレクトリへ出力構造をリダイレクトします。\n --removeComments                           コメントを出力しないでください。\n --noEmit                                   出力しないでください。\n --strict                                   strict 型チェックのオプションをすべて有効にします。\n --noImplicitAny                            暗黙的な 'any' 型を含む式と宣言に関するエラーを発生させます。\n --strictNullChecks                         厳格な null チェックを有効にします。\n --noImplicitThis                           暗黙的な 'any' 型を持つ 'this' 式でエラーが発生します。\n --alwaysStrict                             厳格モードで解析してソース ファイルごとに \"use strict\" を生成します。\n --noUnusedLocals                           使用されていないローカルに関するエラーを報告します。\n --noUnusedParameters                       使用されていないパラメーターに関するエラーを報告します。\n --noImplicitReturns                        関数の一部のコード パスが値を返さない場合にエラーを報告します。\n --noFallthroughCasesInSwitch               switch ステートメントに case のフォールスルーがある場合にエラーを報告します。\n --types                                    コンパイルに含む型宣言ファイル。\n @<ファイル>\nSuppress errors in .ts files using ’// @ts-ignore’ comments\n\nTypeScript 2.6 support suppressing errors in .ts files using // @ts-ignore comments placed above the offending lines.\n\nExample\nif (false) {\n  // @ts-ignore: Unreachable code error\n  console.log(\"hello\");\n}\n\nA // @ts-ignore comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following @ts-ignore explain which error is being suppressed.\n\nPlease note that this comment only suppresses the error reporting, and we recommend you use this comments very sparingly.\n\nFaster \ntsc --watch\n\nTypeScript 2.6 brings a faster --watch implementation. The new version optimizes code generation and checking for code bases using ES modules. Changes detected in a module file will result in only regenerating the changed module, and files that depend on it, instead of the whole project. Projects with large number of files should reap the most benefit from this change.\n\nThe new implementation also brings performance enhancements to watching in tsserver. The watcher logic has been completely rewritten to respond faster to change events.\n\nWrite-only references now flagged as unused\n\nTypeScript 2.6 adds revised implementation the noUnusedLocals and noUnusedParameters compiler options. Declarations are only written to but never read from are now flagged as unused.\n\nExample\n\nBellow both n and m will be marked as unused, because their values are never read. Previously TypeScript would only check whether their values were referenced.\n\nfunction f(n: number) {\n  n = 0;\n}\nclass C {\n  private m: number;\n  constructor() {\n    this.m = 0;\n  }\n}\n\nAlso functions that are only called within their own bodies are considered unused.\n\nExample\nfunction f() {\n  f(); // Error: 'f' is declared but its value is never read\n}\nOn this page\nStrict function types\nCache tagged template objects in modules\nLocalized diagnostics on the command line\nSuppress errors in .ts files using ’// @ts-ignore’ comments\nFaster tsc --watch\nWrite-only references now flagged as unused\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nTS\nMC\nMZ\n4+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.347 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.7",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html",
    "html": "TypeScript 2.7\nConstant-named properties\n\nTypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.\n\nExample\n// Lib\nexport const SERIALIZE = Symbol(\"serialize-method-key\");\nexport interface Serializable {\n  [SERIALIZE](obj: {}): string;\n}\n// consumer\nimport { SERIALIZE, Serializable } from \"lib\";\nclass JSONSerializableItem implements Serializable {\n  [SERIALIZE](obj: {}) {\n    return JSON.stringify(obj);\n  }\n}\n\nThis also applies to numeric and string literals.\n\nExample\nconst Foo = \"Foo\";\nconst Bar = \"Bar\";\nlet x = {\n  [Foo]: 100,\n  [Bar]: \"hello\"\n};\nlet a = x[Foo]; // has type 'number'\nlet b = x[Bar]; // has type 'string'\nunique symbol\n\nTo enable treating symbols as unique literals a new type unique symbol is available. unique symbol is a subtype of symbol, and are produced only from calling Symbol() or Symbol.for(), or from explicit type annotations. The new type is only allowed on const declarations and readonly static properties, and in order to reference a specific unique symbol, you’ll have to use the typeof operator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration.\n\nExample\n// Works\ndeclare const Foo: unique symbol;\n// Error! 'Bar' isn't a constant.\nlet Bar: unique symbol = Symbol();\n// Works - refers to a unique symbol, but its identity is tied to 'Foo'.\nlet Baz: typeof Foo = Foo;\n// Also works.\nclass C {\n  static readonly StaticSymbol: unique symbol = Symbol();\n}\n\nBecause each unique symbol has a completely separate identity, no two unique symbol types are assignable or comparable to each other.\n\nExample\nconst Foo = Symbol();\nconst Bar = Symbol();\n// Error: can't compare two unique symbols.\nif (Foo === Bar) {\n  // ...\n}\nStrict Class Initialization\n\nTypeScript 2.7 introduces a new flag called strictPropertyInitialization. This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example\n\nclass C {\n  foo: number;\n  bar = \"hello\";\n  baz: boolean;\n  //  ~~~\n  //  Error! Property 'baz' has no initializer and is not definitely assigned in the\n  //         constructor.\n  constructor() {\n    this.foo = 42;\n  }\n}\n\nIn the above, if we truly meant for baz to potentially be undefined, we should have declared it with the type boolean | undefined.\n\nThere are certain scenarios where properties can be initialized indirectly (perhaps by a helper method or dependency injection library), in which case you can use the new definite assignment assertion modifiers for your properties (discussed below).\n\nclass C {\n  foo!: number;\n  // ^\n  // Notice this '!' modifier.\n  // This is the \"definite assignment assertion\"\n  constructor() {\n    this.initialize();\n  }\n  initialize() {\n    this.foo = 0;\n  }\n}\n\nKeep in mind that strictPropertyInitialization will be turned on along with other strict mode flags, which can impact your project. You can set the strictPropertyInitialization setting to false in your tsconfig.json’s compilerOptions, or --strictPropertyInitialization false on the command line to turn off this checking.\n\nDefinite Assignment Assertions\n\nThe definite assignment assertion is a feature that allows a ! to be placed after instance property and variable declarations to relay to TypeScript that a variable is indeed assigned for all intents and purposes, even if TypeScript’s analyses cannot detect so.\n\nExample\nlet x: number;\ninitialize();\nconsole.log(x + x);\n//          ~   ~\n// Error! Variable 'x' is used before being assigned.\nfunction initialize() {\n  x = 10;\n}\n\nWith definite assignment assertions, we can assert that x is really assigned by appending an ! to its declaration:\n\n// Notice the '!'\nlet x!: number;\ninitialize();\n// No error!\nconsole.log(x + x);\nfunction initialize() {\n  x = 10;\n}\n\nIn a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which expressions are post-fixed with a !), which we could also have used in the example.\n\nlet x: number;\ninitialize();\n// No error!\nconsole.log(x! + x!);\nfunction initialize() {\n    x = 10;\n}\n\nIn our example, we knew that all uses of x would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.\n\nFixed Length Tuples\n\nIn TypeScript 2.6 and earlier, [number, string, string] was considered a subtype of [number, string]. This was motivated by TypeScript’s structural nature; the first and second elements of a [number, string, string] are respectively subtypes of the first and second elements of [number, string]. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.\n\nIn TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from Kiara Grouwstra, tuple types now encode their arity into the type of their respective length property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.\n\nConceptually, you might consider the type [number, string] to be equivalent to the following declaration of NumStrTuple:\n\ninterface NumStrTuple extends Array<number | string> {\n  0: number;\n  1: string;\n  length: 2; // using the numeric literal type '2'\n}\n\nNote that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a length property, falling back to number.\n\ninterface MinimumNumStrTuple extends Array<number | string> {\n  0: number;\n  1: string;\n}\n\nNote that this does not imply tuples represent immutable arrays, but it is an implied convention.\n\nImproved type inference for object literals\n\nTypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now normalize the object literal types such that all properties are present in each constituent of the union type.\n\nConsider:\n\nconst obj = test ? { text: \"hello\" } : {}; // { text: string } | { text?: undefined }\nconst s = obj.text; // string | undefined\n\nPreviously type {} was inferred for obj and the second line subsequently caused an error because obj would appear to have no properties. That obviously wasn’t ideal.\n\nExample\n// let obj: { a: number, b: number } |\n//     { a: string, b?: undefined } |\n//     { a?: undefined, b?: undefined }\nlet obj = [{ a: 1, b: 2 }, { a: \"abc\" }, {}][0];\nobj.a; // string | number | undefined\nobj.b; // number | undefined\n\nMultiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:\n\ndeclare function f<T>(...items: T[]): T;\n// let obj: { a: number, b: number } |\n//     { a: string, b?: undefined } |\n//     { a?: undefined, b?: undefined }\nlet obj = f({ a: 1, b: 2 }, { a: \"abc\" }, {});\nobj.a; // string | number | undefined\nobj.b; // number | undefined\nImproved handling of structurally identical classes and \ninstanceof\n expressions\n\nTypeScript 2.7 improves the handling of structurally identical classes in union types and instanceof expressions:\n\nStructurally identical, but distinct, class types are now preserved in union types (instead of eliminating all but one).\nUnion type subtype reduction only removes a class type if it is a subclass of and derives from another class type in the union.\nType checking of the instanceof operator is now based on whether the type of the left operand derives from the type indicated by the right operand (as opposed to a structural subtype check).\n\nThis means that union types and instanceof properly distinguish between structurally identical classes.\n\nExample\nclass A {}\nclass B extends A {}\nclass C extends A {}\nclass D extends A {\n  c: string;\n}\nclass E extends D {}\nlet x1 = !true ? new A() : new B(); // A\nlet x2 = !true ? new B() : new C(); // B | C (previously B)\nlet x3 = !true ? new C() : new D(); // C | D (previously C)\nlet a1 = [new A(), new B(), new C(), new D(), new E()]; // A[]\nlet a2 = [new B(), new C(), new D(), new E()]; // (B | C | D)[] (previously B[])\nfunction f1(x: B | C | D) {\n  if (x instanceof B) {\n    x; // B (previously B | D)\n  } else if (x instanceof C) {\n    x; // C\n  } else {\n    x; // D (previously never)\n  }\n}\nType guards inferred from \nin\n operator\n\nThe in operator now acts as a narrowing expression for types.\n\nFor a n in x expression, where n is a string literal or string literal type and x is a union type, the “true” branch narrows to types which have an optional or required property n, and the “false” branch narrows to types which have an optional or missing property n.\n\nExample\ninterface A {\n  a: number;\n}\ninterface B {\n  b: string;\n}\nfunction foo(x: A | B) {\n  if (\"a\" in x) {\n    return x.a;\n  }\n  return x.b;\n}\nSupport for \nimport d from \"cjs\"\n from CommonJS modules with \n--esModuleInterop\n\nTypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an __esModule indicator under esModuleInterop. The change brings the generated output from TypeScript closer to that generated by Babel.\n\nPreviously CommonJS/AMD/UMD modules were treated in the same way as ES6 modules, resulting in a couple of problems. Namely:\n\nTypeScript treats a namespace import (i.e. import * as foo from \"foo\") for a CommonJS/AMD/UMD module as equivalent to const foo = require(\"foo\").Things are simple here, but they don’t work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (foo in the example above) is not callable, though allowed by TypeScript\nSimilarly a default import (i.e. import d from \"foo\") for a CommonJS/AMD/UMD module as equivalent to const d = require(\"foo\").default.Most of the CommonJS/AMD/UMD modules available today do not have a default export, making this import pattern practically unusable to import non-ES modules (i.e. CommonJS/AMD/UMD). For instance import fs from \"fs\" or import express from \"express\" are not allowed.\n\nUnder the new esModuleInterop these two issues should be addressed:\n\nA namespace import (i.e. import * as foo from \"foo\") is now correctly flagged as uncallable. Calling it will result in an error.\nDefault imports to CommonJS/AMD/UMD are now allowed (e.g. import fs from \"fs\"), and should work as expected.\n\nNote: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. We highly recommend applying it both to new and existing projects. For existing projects, namespace imports (import * as express from \"express\"; express();) will need to be converted to default imports (import express from \"express\"; express();).\n\nExample\n\nWith esModuleInterop two new helpers are generated __importStar and __importDefault for import * and import default respectively. For instance input like:\n\nimport * as foo from \"foo\";\nimport b from \"bar\";\n\nWill generate:\n\n\"use strict\";\nvar __importStar =\n  (this && this.__importStar) ||\n  function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null)\n      for (var k in mod)\n        if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n  };\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function(mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nexports.__esModule = true;\nvar foo = __importStar(require(\"foo\"));\nvar bar_1 = __importDefault(require(\"bar\"));\nNumeric separators\n\nTypeScript 2.7 brings support for ES Numeric Separators. Numeric literals can now be separated into segments using _.\n\nExample\nconst million = 1_000_000;\nconst phone = 555_734_2231;\nconst bytes = 0xff_0c_00_ff;\nconst word = 0b1100_0011_1101_0001;\nCleaner output in \n--watch\n mode\n\nTypeScript’s --watch mode now clears the screen after a re-compilation is requested.\n\nPrettier \n--pretty\n output\n\nTypeScript’s pretty flag can make error messages easier to read and manage. pretty now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).\n\nOn this page\nConstant-named properties\nunique symbol\nStrict Class Initialization\nDefinite Assignment Assertions\nFixed Length Tuples\nImproved type inference for object literals\nImproved handling of structurally identical classes and instanceof expressions\nType guards inferred from in operator\nSupport for import d from \"cjs\" from CommonJS modules with --esModuleInterop\nNumeric separators\nCleaner output in --watch mode\nPrettier --pretty output\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nS\nJB\nCT\n9+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.267 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.5",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-5.html",
    "html": "TypeScript 2.5\nOptional \ncatch\n clause variables\n\nThanks to work done by @tinganho, TypeScript 2.5 implements a new ECMAScript feature that allows users to omit the variable in catch clauses. For example, when using JSON.parse you may need to wrap calls to the function with a try/catch, but you may not end up using the SyntaxError that gets thrown when input is erroneous.\n\nlet input = \"...\";\ntry {\n  JSON.parse(input);\n} catch {\n  // ^ Notice that our `catch` clause doesn't declare a variable.\n  console.log(\"Invalid JSON given\\n\\n\" + input);\n}\nType assertion/cast syntax in \ncheckJs\n/\n@ts-check\n mode\n\nTypeScript 2.5 introduces the ability to assert the type of expressions when using plain JavaScript in your projects. The syntax is an /** @type {...} */ annotation comment followed by a parenthesized expression whose type needs to be re-evaluated. For example:\n\nvar x = /** @type {SomeType} */ AnyParenthesizedExpression;\nDeduplicated and redirected packages\n\nWhen importing using the Node module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from “identical” packages. If a file originates from a package with a package.json containing the same name and version fields as a previously encountered package, then TypeScript will redirect itself to the top-most package. This helps resolve problems where two packages might contain identical declarations of classes, but which contain private members that cause them to be structurally incompatible.\n\nAs a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading .d.ts files from duplicate packages.\n\nThe \n--preserveSymlinks\n compiler flag\n\nTypeScript 2.5 brings the preserveSymlinks flag, which parallels the behavior of the --preserve-symlinks flag in Node.js. This flag also exhibits the opposite behavior to Webpack’s resolve.symlinks option (i.e. setting TypeScript’s preserveSymlinks to true parallels setting Webpack’s resolve.symlinks to false, and vice-versa).\n\nIn this mode, references to modules and packages (e.g. imports and /// <reference type=\"...\" /> directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we’ll defer to the documentation on the Node.js website.\n\nOn this page\nOptional catch clause variables\nType assertion/cast syntax in checkJs/@ts-check mode\nDeduplicated and redirected packages\nThe --preserveSymlinks compiler flag\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nJB\n2+\n\nLast updated: Nov 27, 2023\n\n "
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.8",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html",
    "html": "TypeScript 2.8\nConditional Types\n\nTypeScript 2.8 introduces conditional types which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:\n\nT extends U ? X : Y\n\nThe type above means when T is assignable to U the type is X, otherwise the type is Y.\n\nA conditional type T extends U ? X : Y is either resolved to X or Y, or deferred because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:\n\nFirst, given types T' and U' that are instantiations of T and U where all occurrences of type parameters are replaced with any, if T' is not assignable to U', the conditional type is resolved to Y. Intuitively, if the most permissive instantiation of T is not assignable to the most permissive instantiation of U, we know that no instantiation will be and we can just resolve to Y.\nNext, for each type variable introduced by an infer (more later) declaration within U collect a set of candidate types by inferring from T to U (using the same inference algorithm as type inference for generic functions). For a given infer type variable V, if any candidates were inferred from co-variant positions, the type inferred for V is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for V is an intersection of those candidates. Otherwise, the type inferred for V is never.\nThen, given a type T'' that is an instantiation of T where all infer type variables are replaced with the types inferred in the previous step, if T'' is definitely assignable to U, the conditional type is resolved to X. The definitely assignable relation is the same as the regular assignable relation, except that type variable constraints are not considered. Intuitively, when a type is definitely assignable to another type, we know that it will be assignable for all instantiations of those types.\nOtherwise, the condition depends on one or more type variables and the conditional type is deferred.\nExample\ntype TypeName<T> = T extends string\n  ? \"string\"\n  : T extends number\n  ? \"number\"\n  : T extends boolean\n  ? \"boolean\"\n  : T extends undefined\n  ? \"undefined\"\n  : T extends Function\n  ? \"function\"\n  : \"object\";\ntype T0 = TypeName<string>; // \"string\"\ntype T1 = TypeName<\"a\">; // \"string\"\ntype T2 = TypeName<true>; // \"boolean\"\ntype T3 = TypeName<() => void>; // \"function\"\ntype T4 = TypeName<string[]>; // \"object\"\nDistributive conditional types\n\nConditional types in which the checked type is a naked type parameter are called distributive conditional types. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of T extends U ? X : Y with the type argument A | B | C for T is resolved as (A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y).\n\nExample\ntype T10 = TypeName<string | (() => void)>; // \"string\" | \"function\"\ntype T12 = TypeName<string | string[] | undefined>; // \"string\" | \"object\" | \"undefined\"\ntype T11 = TypeName<string[] | number[]>; // \"object\"\n\nIn instantiations of a distributive conditional type T extends U ? X : Y, references to T within the conditional type are resolved to individual constituents of the union type (i.e. T refers to the individual constituents after the conditional type is distributed over the union type). Furthermore, references to T within X have an additional type parameter constraint U (i.e. T is considered assignable to U within X).\n\nExample\ntype BoxedValue<T> = { value: T };\ntype BoxedArray<T> = { array: T[] };\ntype Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;\ntype T20 = Boxed<string>; // BoxedValue<string>;\ntype T21 = Boxed<number[]>; // BoxedArray<number>;\ntype T22 = Boxed<string | number[]>; // BoxedValue<string> | BoxedArray<number>;\n\nNotice that T has the additional constraint any[] within the true branch of Boxed<T> and it is therefore possible to refer to the element type of the array as T[number]. Also, notice how the conditional type is distributed over the union type in the last example.\n\nThe distributive property of conditional types can conveniently be used to filter union types:\n\ntype Diff<T, U> = T extends U ? never : T; // Remove types from T that are assignable to U\ntype Filter<T, U> = T extends U ? T : never; // Remove types from T that are not assignable to U\ntype T30 = Diff<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"\ntype T31 = Filter<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"\ntype T32 = Diff<string | number | (() => void), Function>; // string | number\ntype T33 = Filter<string | number | (() => void), Function>; // () => void\ntype NonNullable<T> = Diff<T, null | undefined>; // Remove null and undefined from T\ntype T34 = NonNullable<string | number | undefined>; // string | number\ntype T35 = NonNullable<string | string[] | null | undefined>; // string | string[]\nfunction f1<T>(x: T, y: NonNullable<T>) {\n  x = y; // Ok\n  y = x; // Error\n}\nfunction f2<T extends string | undefined>(x: T, y: NonNullable<T>) {\n  x = y; // Ok\n  y = x; // Error\n  let s1: string = x; // Error\n  let s2: string = y; // Ok\n}\n\nConditional types are particularly useful when combined with mapped types:\n\ntype FunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T];\ntype FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;\ntype NonFunctionPropertyNames<T> = {\n  [K in keyof T]: T[K] extends Function ? never : K;\n}[keyof T];\ntype NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;\ninterface Part {\n  id: number;\n  name: string;\n  subparts: Part[];\n  updatePart(newName: string): void;\n}\ntype T40 = FunctionPropertyNames<Part>; // \"updatePart\"\ntype T41 = NonFunctionPropertyNames<Part>; // \"id\" | \"name\" | \"subparts\"\ntype T42 = FunctionProperties<Part>; // { updatePart(newName: string): void }\ntype T43 = NonFunctionProperties<Part>; // { id: number, name: string, subparts: Part[] }\n\nSimilar to union and intersection types, conditional types are not permitted to reference themselves recursively. For example the following is an error.\n\nExample\ntype ElementType<T> = T extends any[] ? ElementType<T[number]> : T; // Error\nType inference in conditional types\n\nWithin the extends clause of a conditional type, it is now possible to have infer declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple infer locations for the same type variable.\n\nFor example, the following extracts the return type of a function type:\n\ntype ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;\n\nConditional types can be nested to form a sequence of pattern matches that are evaluated in order:\n\ntype Unpacked<T> = T extends (infer U)[]\n  ? U\n  : T extends (...args: any[]) => infer U\n  ? U\n  : T extends Promise<infer U>\n  ? U\n  : T;\ntype T0 = Unpacked<string>; // string\ntype T1 = Unpacked<string[]>; // string\ntype T2 = Unpacked<() => string>; // string\ntype T3 = Unpacked<Promise<string>>; // string\ntype T4 = Unpacked<Promise<string>[]>; // Promise<string>\ntype T5 = Unpacked<Unpacked<Promise<string>[]>>; // string\n\nThe following example demonstrates how multiple candidates for the same type variable in co-variant positions causes a union type to be inferred:\n\ntype Foo<T> = T extends { a: infer U; b: infer U } ? U : never;\ntype T10 = Foo<{ a: string; b: string }>; // string\ntype T11 = Foo<{ a: string; b: number }>; // string | number\n\nLikewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:\n\ntype Bar<T> = T extends { a: (x: infer U) => void; b: (x: infer U) => void }\n  ? U\n  : never;\ntype T20 = Bar<{ a: (x: string) => void; b: (x: string) => void }>; // string\ntype T21 = Bar<{ a: (x: string) => void; b: (x: number) => void }>; // string & number\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.\n\ndeclare function foo(x: string): number;\ndeclare function foo(x: number): string;\ndeclare function foo(x: string | number): string | number;\ntype T30 = ReturnType<typeof foo>; // string | number\n\nIt is not possible to use infer declarations in constraint clauses for regular type parameters:\n\ntype ReturnType<T extends (...args: any[]) => infer R> = R; // Error, not supported\n\nHowever, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:\n\ntype AnyFunction = (...args: any[]) => any;\ntype ReturnType<T extends AnyFunction> = T extends (...args: any[]) => infer R\n  ? R\n  : any;\nPredefined conditional types\n\nTypeScript 2.8 adds several predefined conditional types to lib.d.ts:\n\nExclude<T, U> — Exclude from T those types that are assignable to U.\nExtract<T, U> — Extract from T those types that are assignable to U.\nNonNullable<T> — Exclude null and undefined from T.\nReturnType<T> — Obtain the return type of a function type.\nInstanceType<T> — Obtain the instance type of a constructor function type.\nExample\ntype T00 = Exclude<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"b\" | \"d\"\ntype T01 = Extract<\"a\" | \"b\" | \"c\" | \"d\", \"a\" | \"c\" | \"f\">; // \"a\" | \"c\"\ntype T02 = Exclude<string | number | (() => void), Function>; // string | number\ntype T03 = Extract<string | number | (() => void), Function>; // () => void\ntype T04 = NonNullable<string | number | undefined>; // string | number\ntype T05 = NonNullable<(() => string) | string[] | null | undefined>; // (() => string) | string[]\nfunction f1(s: string) {\n  return { a: 1, b: s };\n}\nclass C {\n  x = 0;\n  y = 0;\n}\ntype T10 = ReturnType<() => string>; // string\ntype T11 = ReturnType<(s: string) => void>; // void\ntype T12 = ReturnType<<T>() => T>; // {}\ntype T13 = ReturnType<<T extends U, U extends number[]>() => T>; // number[]\ntype T14 = ReturnType<typeof f1>; // { a: number, b: string }\ntype T15 = ReturnType<any>; // any\ntype T16 = ReturnType<never>; // any\ntype T17 = ReturnType<string>; // Error\ntype T18 = ReturnType<Function>; // Error\ntype T20 = InstanceType<typeof C>; // C\ntype T21 = InstanceType<any>; // any\ntype T22 = InstanceType<never>; // any\ntype T23 = InstanceType<string>; // Error\ntype T24 = InstanceType<Function>; // Error\n\nNote: The Exclude type is a proper implementation of the Diff type suggested here. We’ve used the name Exclude to avoid breaking existing code that defines a Diff, plus we feel that name better conveys the semantics of the type. We did not include the Omit<T, K> type because it is trivially written as Pick<T, Exclude<keyof T, K>>.\n\nImproved control over mapped type modifiers\n\nMapped types support adding a readonly or ? modifier to a mapped property, but they did not provide support the ability to remove modifiers. This matters in homomorphic mapped types which by default preserve the modifiers of the underlying type.\n\nTypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a readonly or ? property modifier in a mapped type can now be prefixed with either + or - to indicate that the modifier should be added or removed.\n\nExample\ntype MutableRequired<T> = { -readonly [P in keyof T]-?: T[P] }; // Remove readonly and ?\ntype ReadonlyPartial<T> = { +readonly [P in keyof T]+?: T[P] }; // Add readonly and ?\n\nA modifier with no + or - prefix is the same as a modifier with a + prefix. So, the ReadonlyPartial<T> type above corresponds to\n\ntype ReadonlyPartial<T> = { readonly [P in keyof T]?: T[P] }; // Add readonly and ?\n\nUsing this ability, lib.d.ts now has a new Required<T> type. This type strips ? modifiers from all properties of T, thus making all properties required.\n\nExample\ntype Required<T> = { [P in keyof T]-?: T[P] };\n\nNote that in strictNullChecks mode, when a homomorphic mapped type removes a ? modifier from a property in the underlying type it also removes undefined from the type of that property:\n\nExample\ntype Foo = { a?: string }; // Same as { a?: string | undefined }\ntype Bar = Required<Foo>; // Same as { a: string }\nImproved \nkeyof\n with intersection types\n\nWith TypeScript 2.8 keyof applied to an intersection type is transformed to a union of keyof applied to each intersection constituent. In other words, types of the form keyof (A & B) are transformed to be keyof A | keyof B. This change should address inconsistencies with inference from keyof expressions.\n\nExample\ntype A = { a: string };\ntype B = { b: string };\ntype T1 = keyof (A & B); // \"a\" | \"b\"\ntype T2<T> = keyof (T & B); // keyof T | \"b\"\ntype T3<U> = keyof (A & U); // \"a\" | keyof U\ntype T4<T, U> = keyof (T & U); // keyof T | keyof U\ntype T5 = T2<A>; // \"a\" | \"b\"\ntype T6 = T3<B>; // \"a\" | \"b\"\ntype T7 = T4<A, B>; // \"a\" | \"b\"\nBetter handling for namespace patterns in \n.js\n files\n\nTypeScript 2.8 adds support for understanding more namespace patterns in .js files. Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.\n\nvar ns = {}; // recognized as a declaration for a namespace `ns`\nns.constant = 1; // recognized as a declaration for var `constant`\n\nAssignments at the top-level should behave the same way; in other words, a var or const declaration is not required.\n\napp = {}; // does NOT need to be `var app = {}`\napp.C = class {};\napp.f = function() {};\napp.prop = 1;\nIIFEs as namespace declarations\n\nAn IIFE returning a function, class or empty object literal, is also recognized as a namespace:\n\nvar C = (function() {\n  function C(n) {\n    this.p = n;\n  }\n  return C;\n})();\nC.staticProperty = 1;\nDefaulted declarations\n\n“Defaulted declarations” allow initializers that reference the declared name in the left side of a logical or:\n\nmy = window.my || {};\nmy.app = my.app || {};\nPrototype assignment\n\nYou can assign an object literal directly to the prototype property. Individual prototype assignments still work too:\n\nvar C = function(p) {\n  this.p = p;\n};\nC.prototype = {\n  m() {\n    console.log(this.p);\n  }\n};\nC.prototype.q = function(r) {\n  return this.p === r;\n};\nNested and merged declarations\n\nNesting works to any level now, and merges correctly across files. Previously neither was the case.\n\nvar app = window.app || {};\napp.C = class {};\nPer-file JSX factories\n\nTypeScript 2.8 adds support for a per-file configurable JSX factory name using @jsx dom pragma. JSX factory can be configured for a compilation using jsxFactory (default is React.createElement). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.\n\nExample\n/** @jsx dom */\nimport { dom } from \"./renderer\";\n<h></h>;\n\nGenerates:\n\nvar renderer_1 = require(\"./renderer\");\nrenderer_1.dom(\"h\", null);\nLocally scoped JSX namespaces\n\nJSX type checking is driven by definitions in a JSX namespace, for instance JSX.Element for the type of a JSX element, and JSX.IntrinsicElements for built-in elements. Before TypeScript 2.8 the JSX namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the JSX namespace will be looked under the jsxNamespace (e.g. React) allowing for multiple jsx factories in one compilation. For backward compatibility the global JSX namespace is used as a fallback if none was defined on the factory function. Combined with the per-file @jsx pragma, each file can have a different JSX factory.\n\nNew \n--emitDeclarationOnly\n\nemitDeclarationOnly allows for only generating declaration files; .js/.jsx output generation will be skipped with this flag. The flag is useful when the .js output generation is handled by a different transpiler like Babel.\n\nOn this page\nConditional Types\nDistributive conditional types\nType inference in conditional types\nPredefined conditional types\nImproved control over mapped type modifiers\nImproved keyof with intersection types\nBetter handling for namespace patterns in .js files\nIIFEs as namespace declarations\nDefaulted declarations\nPrototype assignment\nNested and merged declarations\nPer-file JSX factories\nLocally scoped JSX namespaces\nNew --emitDeclarationOnly\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nJB\nDR\nWW\n4+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.289 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 2.9",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-9.html",
    "html": "TypeScript 2.9\nSupport \nnumber\n and \nsymbol\n named properties with \nkeyof\n and mapped types\n\nTypeScript 2.9 adds support for number and symbol named properties in index types and mapped types. Previously, the keyof operator and mapped types only supported string named properties.\n\nChanges include:\n\nAn index type keyof T for some type T is a subtype of string | number | symbol.\nA mapped type { [P in K]: XXX } permits any K assignable to string | number | symbol.\nIn a for...in statement for an object of a generic type T, the inferred type of the iteration variable was previously keyof T but is now Extract<keyof T, string>. (In other words, the subset of keyof T that includes only string-like values.)\n\nGiven an object type X, keyof X is resolved as follows:\n\nIf X contains a string index signature, keyof X is a union of string, number, and the literal types representing symbol-like properties, otherwise\nIf X contains a numeric index signature, keyof X is a union of number and the literal types representing string-like and symbol-like properties, otherwise\nkeyof X is a union of the literal types representing string-like, number-like, and symbol-like properties.\n\nWhere:\n\nString-like properties of an object type are those declared using an identifier, a string literal, or a computed property name of a string literal type.\nNumber-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.\nSymbol-like properties of an object type are those declared using a computed property name of a unique symbol type.\n\nIn a mapped type { [P in K]: XXX }, each string literal type in K introduces a property with a string name, each numeric literal type in K introduces a property with a numeric name, and each unique symbol type in K introduces a property with a unique symbol name. Furthermore, if K includes type string, a string index signature is introduced, and if K includes type number, a numeric index signature is introduced.\n\nExample\nconst c = \"c\";\nconst d = 10;\nconst e = Symbol();\nconst enum E1 {\n  A,\n  B,\n  C,\n}\nconst enum E2 {\n  A = \"A\",\n  B = \"B\",\n  C = \"C\",\n}\ntype Foo = {\n  a: string; // String-like name\n  5: string; // Number-like name\n  [c]: string; // String-like name\n  [d]: string; // Number-like name\n  [e]: string; // Symbol-like name\n  [E1.A]: string; // Number-like name\n  [E2.A]: string; // String-like name\n};\ntype K1 = keyof Foo; // \"a\" | 5 | \"c\" | 10 | typeof e | E1.A | E2.A\ntype K2 = Extract<keyof Foo, string>; // \"a\" | \"c\" | E2.A\ntype K3 = Extract<keyof Foo, number>; // 5 | 10 | E1.A\ntype K4 = Extract<keyof Foo, symbol>; // typeof e\n\nSince keyof now reflects the presence of a numeric index signature by including type number in the key type, mapped types such as Partial<T> and Readonly<T> work correctly when applied to object types with numeric index signatures:\n\ntype Arrayish<T> = {\n  length: number;\n  [x: number]: T;\n};\ntype ReadonlyArrayish<T> = Readonly<Arrayish<T>>;\ndeclare const map: ReadonlyArrayish<string>;\nlet n = map.length;\nlet x = map[123]; // Previously of type any (or an error with --noImplicitAny)\n\nFurthermore, with the keyof operator’s support for number and symbol named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.\n\nconst enum Enum {\n  A,\n  B,\n  C,\n}\nconst enumToStringMap = {\n  [Enum.A]: \"Name A\",\n  [Enum.B]: \"Name B\",\n  [Enum.C]: \"Name C\",\n};\nconst sym1 = Symbol();\nconst sym2 = Symbol();\nconst sym3 = Symbol();\nconst symbolToNumberMap = {\n  [sym1]: 1,\n  [sym2]: 2,\n  [sym3]: 3,\n};\ntype KE = keyof typeof enumToStringMap; // Enum (i.e. Enum.A | Enum.B | Enum.C)\ntype KS = keyof typeof symbolToNumberMap; // typeof sym1 | typeof sym2 | typeof sym3\nfunction getValue<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\nlet x1 = getValue(enumToStringMap, Enum.C); // Returns \"Name C\"\nlet x2 = getValue(symbolToNumberMap, sym3); // Returns 3\n\nThis is a breaking change; previously, the keyof operator and mapped types only supported string named properties. Code that assumed values typed with keyof T were always strings, will now be flagged as error.\n\nExample\nfunction useKey<T, K extends keyof T>(o: T, k: K) {\n  var name: string = k; // Error: keyof T is not assignable to string\n}\nRecommendations\n\nIf your functions are only able to handle string named property keys, use Extract<keyof T, string> in the declaration:\n\nfunction useKey<T, K extends Extract<keyof T, string>>(o: T, k: K) {\n  var name: string = k; // OK\n}\n\nIf your functions are open to handling all property keys, then the changes should be done down-stream:\n\nfunction useKey<T, K extends keyof T>(o: T, k: K) {\n  var name: string | number | symbol = k;\n}\n\nOtherwise use keyofStringsOnly compiler option to disable the new behavior.\n\nGeneric type arguments in JSX elements\n\nJSX elements now allow passing type arguments to generic components.\n\nExample\nclass GenericComponent<P> extends React.Component<P> {\n  internalProp: P;\n}\ntype Props = { a: number; b: string };\nconst x = <GenericComponent<Props> a={10} b=\"hi\" />; // OK\nconst y = <GenericComponent<Props> a={10} b={20} />; // Error\nGeneric type arguments in generic tagged templates\n\nTagged templates are a form of invocation introduced in ECMAScript 2015. Like call expressions, generic functions may be used in a tagged template and TypeScript will infer the type arguments utilized.\n\nTypeScript 2.9 allows passing generic type arguments to tagged template strings.\n\nExample\ndeclare function styledComponent<Props>(\n  strs: TemplateStringsArray\n): Component<Props>;\ninterface MyProps {\n  name: string;\n  age: number;\n}\nstyledComponent<MyProps>`\n  font-size: 1.5em;\n  text-align: center;\n  color: palevioletred;\n`;\ndeclare function tag<T>(strs: TemplateStringsArray, ...args: T[]): T;\n// inference fails because 'number' and 'string' are both candidates that conflict\nlet a = tag<string | number>`${100} ${\"hello\"}`;\nimport\n types\n\nModules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter import types.\n\nUsing import(\"mod\") in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.\n\nExample\n\nGiven a declaration of a class Pet in a module file:\n\n// module.d.ts\nexport declare class Pet {\n  name: string;\n}\n\nCan be used in a non-module file global-script.ts:\n\n// global-script.ts\nfunction adopt(p: import(\"./module\").Pet) {\n  console.log(`Adopting ${p.name}...`);\n}\n\nThis also works in JSDoc comments to refer to types from other modules in .js:\n\n// a.js\n/**\n * @param p { import(\"./module\").Pet }\n */\nfunction walk(p) {\n  console.log(`Walking ${p.name}...`);\n}\nRelaxing declaration emit visibility rules\n\nWith import types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.\n\nFor instance:\n\nimport { createHash } from \"crypto\";\nexport const hash = createHash(\"sha256\");\n//           ^^^^\n// Exported variable 'hash' has or is using name 'Hash' from external module \"crypto\" but cannot be named.\n\nWith TypeScript 2.9, no errors are reported, and now the generated file looks like:\n\nexport declare const hash: import(\"crypto\").Hash;\nSupport for \nimport.meta\n\nTypeScript 2.9 introduces support for import.meta, a new meta-property as described by the current TC39 proposal.\n\nThe type of import.meta is the global ImportMeta type which is defined in lib.es5.d.ts. This interface is extremely limited. Adding well-known properties for Node or browsers requires interface merging and possibly a global augmentation depending on the context.\n\nExample\n\nAssuming that __dirname is always available on import.meta, the declaration would be done through reopening ImportMeta interface:\n\n// node.d.ts\ninterface ImportMeta {\n  __dirname: string;\n}\n\nAnd usage would be:\n\nimport.meta.__dirname; // Has type 'string'\n\nimport.meta is only allowed when targeting ESNext modules and ECMAScript targets.\n\nNew \n--resolveJsonModule\n\nOften in Node.js applications a .json is needed. With TypeScript 2.9, resolveJsonModule allows for importing, extracting types from and generating .json files.\n\nExample\n// settings.json\n{\n    \"repo\": \"TypeScript\",\n    \"dry\": false,\n    \"debug\": false\n}\n// a.ts\nimport settings from \"./settings.json\";\nsettings.debug === true; // OK\nsettings.dry === 2; // Error: Operator '===' cannot be applied boolean and number\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"module\": \"commonjs\",\n    \"resolveJsonModule\": true,\n    \"esModuleInterop\": true\n  }\n}\n--pretty\n output by default\n\nStarting TypeScript 2.9 errors are displayed under pretty by default if the output device is applicable for colorful text. TypeScript will check if the output stream has isTty property set.\n\nUse --pretty false on the command line or set \"pretty\": false in your tsconfig.json to disable pretty output.\n\nNew \n--declarationMap\n\nEnabling declarationMap alongside declaration causes the compiler to emit .d.ts.map files alongside the output .d.ts files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.\n\nIn other words, hitting go-to-definition on a declaration from a .d.ts file generated with declarationMap will take you to the source file (.ts) location where that declaration was defined, and not to the .d.ts.\n\nOn this page\nSupport number and symbol named properties with keyof and mapped types\nGeneric type arguments in JSX elements\nGeneric type arguments in generic tagged templates\nimport types\nRelaxing declaration emit visibility rules\nSupport for import.meta\nNew --resolveJsonModule\n--pretty output by default\nNew --declarationMap\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nNS\nJB\nBH\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.336 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.0",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html",
    "html": "TypeScript 3.0\nProject References\n\nTypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing tsconfig.json files to reference other tsconfig.json files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.\n\nTypeScript 3.0 also introduces a new mode for tsc, the --build flag, that works hand-in-hand with project references to enable faster TypeScript builds.\n\nSee Project References handbook page for more documentation.\n\nTuples in rest parameters and spread expressions\n\nTypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:\n\nExpansion of rest parameters with tuple types into discrete parameters.\nExpansion of spread expressions with tuple types into discrete arguments.\nGeneric rest parameters and corresponding inference of tuple types.\nOptional elements in tuple types.\nRest elements in tuple types.\n\nWith these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.\n\nRest parameters with tuple types\n\nWhen a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:\n\ndeclare function foo(...args: [number, string, boolean]): void;\ndeclare function foo(args_0: number, args_1: string, args_2: boolean): void;\nSpread expressions with tuple types\n\nWhen a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.\n\nThus, the following calls are equivalent:\n\nconst args: [number, string, boolean] = [42, \"hello\", true];\nfoo(42, \"hello\", true);\nfoo(args[0], args[1], args[2]);\nfoo(...args);\nGeneric rest parameters\n\nA rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:\n\nExample\ndeclare function bind<T, U extends any[], V>(\n  f: (x: T, ...args: U) => V,\n  x: T\n): (...args: U) => V;\ndeclare function f3(x: number, y: string, z: boolean): void;\nconst f2 = bind(f3, 42); // (y: string, z: boolean) => void\nconst f1 = bind(f2, \"hello\"); // (z: boolean) => void\nconst f0 = bind(f1, true); // () => void\nf3(42, \"hello\", true);\nf2(\"hello\", true);\nf1(true);\nf0();\n\nIn the declaration of f2 above, type inference infers types number, [string, boolean] and void for T, U and V respectively.\n\nNote that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for U, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).\n\nOptional elements in tuple types\n\nTuple types now permit a ? postfix on element types to indicate that the element is optional:\n\nExample\nlet t: [number, string?, boolean?];\nt = [42, \"hello\", true];\nt = [42, \"hello\"];\nt = [42];\n\nIn strictNullChecks mode, a ? modifier automatically includes undefined in the element type, similar to optional parameters.\n\nA tuple type permits an element to be omitted if it has a postfix ? modifier on its type and all elements to the right of it also have ? modifiers.\n\nWhen tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.\n\nThe length property of a tuple type with optional elements is a union of numeric literal types representing the possible lengths. For example, the type of the length property in the tuple type [number, string?, boolean?] is 1 | 2 | 3.\n\nRest elements in tuple types\n\nThe last element of a tuple type can be a rest element of the form ...X, where X is an array type. A rest element indicates that the tuple type is open-ended and may have zero or more additional elements of the array element type. For example, [number, ...string[]] means tuples with a number element followed by any number of string elements.\n\nExample\nfunction tuple<T extends any[]>(...args: T): T {\n  return args;\n}\nconst numbers: number[] = getArrayOfNumbers();\nconst t1 = tuple(\"foo\", 1, true); // [string, number, boolean]\nconst t2 = tuple(\"bar\", ...numbers); // [string, ...number[]]\n\nThe type of the length property of a tuple type with a rest element is number.\n\nNew \nunknown\n top type\n\nTypeScript 3.0 introduces a new top type unknown. unknown is the type-safe counterpart of any. Anything is assignable to unknown, but unknown isn’t assignable to anything but itself and any without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an unknown without first asserting or narrowing to a more specific type.\n\nExample\n// In an intersection everything absorbs unknown\ntype T00 = unknown & null; // null\ntype T01 = unknown & undefined; // undefined\ntype T02 = unknown & null & undefined; // null & undefined (which becomes never)\ntype T03 = unknown & string; // string\ntype T04 = unknown & string[]; // string[]\ntype T05 = unknown & unknown; // unknown\ntype T06 = unknown & any; // any\n// In a union an unknown absorbs everything\ntype T10 = unknown | null; // unknown\ntype T11 = unknown | undefined; // unknown\ntype T12 = unknown | null | undefined; // unknown\ntype T13 = unknown | string; // unknown\ntype T14 = unknown | string[]; // unknown\ntype T15 = unknown | unknown; // unknown\ntype T16 = unknown | any; // any\n// Type variable and unknown in union and intersection\ntype T20<T> = T & {}; // T & {}\ntype T21<T> = T | {}; // T | {}\ntype T22<T> = T & unknown; // T\ntype T23<T> = T | unknown; // unknown\n// unknown in conditional types\ntype T30<T> = unknown extends T ? true : false; // Deferred\ntype T31<T> = T extends unknown ? true : false; // Deferred (so it distributes)\ntype T32<T> = never extends T ? true : false; // true\ntype T33<T> = T extends never ? true : false; // Deferred\n// keyof unknown\ntype T40 = keyof any; // string | number | symbol\ntype T41 = keyof unknown; // never\n// Only equality operators are allowed with unknown\nfunction f10(x: unknown) {\n  x == 5;\n  x !== 10;\n  x >= 0; // Error\n  x + 1; // Error\n  x * 2; // Error\n  -x; // Error\n  +x; // Error\n}\n// No property accesses, element accesses, or function calls\nfunction f11(x: unknown) {\n  x.foo; // Error\n  x[5]; // Error\n  x(); // Error\n  new x(); // Error\n}\n// typeof, instanceof, and user defined type predicates\ndeclare function isFunction(x: unknown): x is Function;\nfunction f20(x: unknown) {\n  if (typeof x === \"string\" || typeof x === \"number\") {\n    x; // string | number\n  }\n  if (x instanceof Error) {\n    x; // Error\n  }\n  if (isFunction(x)) {\n    x; // Function\n  }\n}\n// Homomorphic mapped type over unknown\ntype T50<T> = { [P in keyof T]: number };\ntype T51 = T50<any>; // { [x: string]: number }\ntype T52 = T50<unknown>; // {}\n// Anything is assignable to unknown\nfunction f21<T>(pAny: any, pNever: never, pT: T) {\n  let x: unknown;\n  x = 123;\n  x = \"hello\";\n  x = [1, 2, 3];\n  x = new Error();\n  x = x;\n  x = pAny;\n  x = pNever;\n  x = pT;\n}\n// unknown assignable only to itself and any\nfunction f22(x: unknown) {\n  let v1: any = x;\n  let v2: unknown = x;\n  let v3: object = x; // Error\n  let v4: string = x; // Error\n  let v5: string[] = x; // Error\n  let v6: {} = x; // Error\n  let v7: {} | null | undefined = x; // Error\n}\n// Type parameter 'T extends unknown' not related to object\nfunction f23<T extends unknown>(x: T) {\n  let y: object = x; // Error\n}\n// Anything but primitive assignable to { [x: string]: unknown }\nfunction f24(x: { [x: string]: unknown }) {\n  x = {};\n  x = { a: 5 };\n  x = [1, 2, 3];\n  x = 123; // Error\n}\n// Locals of type unknown always considered initialized\nfunction f25() {\n  let x: unknown;\n  let y = x;\n}\n// Spread of unknown causes result to be unknown\nfunction f26(x: {}, y: unknown, z: any) {\n  let o1 = { a: 42, ...x }; // { a: number }\n  let o2 = { a: 42, ...x, ...y }; // unknown\n  let o3 = { a: 42, ...x, ...y, ...z }; // any\n}\n// Functions with unknown return type don't need return expressions\nfunction f27(): unknown {}\n// Rest type cannot be created from unknown\nfunction f28(x: unknown) {\n  let { ...a } = x; // Error\n}\n// Class properties of type unknown don't need definite assignment\nclass C1 {\n  a: string; // Error\n  b: unknown;\n  c: any;\n}\nSupport for \ndefaultProps\n in JSX\n\nTypeScript 2.9 and earlier didn’t leverage React defaultProps declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of render, or they’d use type-assertions to fix up the type of the component before exporting it.\n\nTypeScript 3.0 adds support for a new type alias in the JSX namespace called LibraryManagedAttributes. This helper type defines a transformation on the component’s Props type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.\n\nIn short using this general type, we can model React’s specific behavior for things like defaultProps and, to some extent, propTypes.\n\nexport interface Props {\n  name: string;\n}\nexport class Greet extends React.Component<Props> {\n  render() {\n    const { name } = this.props;\n    return <div>Hello {name.toUpperCase()}!</div>;\n  }\n  static defaultProps = { name: \"world\" };\n}\n// Type-checks! No type assertions needed!\nlet el = <Greet />;\nCaveats\nExplicit types on \ndefaultProps\n\nThe default-ed properties are inferred from the defaultProps property type. If an explicit type annotation is added, e.g. static defaultProps: Partial<Props>; the compiler will not be able to identify which properties have defaults (since the type of defaultProps include all properties of Props).\n\nUse static defaultProps: Pick<Props, \"name\">; as an explicit type annotation instead, or do not add a type annotation as done in the example above.\n\nFor function components (formerly known as SFCs) use ES2015 default initializers:\n\nfunction Greet({ name = \"world\" }: Props) {\n  return <div>Hello {name.toUpperCase()}!</div>;\n}\nChanges to @types/React\n\nCorresponding changes to add LibraryManagedAttributes definition to the JSX namespace in @types/React are still needed. Keep in mind that there are some limitations.\n\n/// <reference lib=\"...\" />\n reference directives\n\nTypeScript adds a new triple-slash-reference directive (/// <reference lib=\"name\" />), allowing a file to explicitly include an existing built-in lib file.\n\nBuilt-in lib files are referenced in the same fashion as the lib compiler option in tsconfig.json (e.g. use lib=\"es2015\" and not lib=\"lib.es2015.d.ts\", etc.).\n\nFor declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like Symbol or Iterable, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.\n\nExample\n\nUsing /// <reference lib=\"es2017.string\" /> to one of the files in a compilation is equivalent to compiling with --lib es2017.string.\n\n/// <reference lib=\"es2017.string\" />\n\"foo\".padStart(4);\nOn this page\nProject References\nTuples in rest parameters and spread expressions\nRest parameters with tuple types\nSpread expressions with tuple types\nGeneric rest parameters\nOptional elements in tuple types\nRest elements in tuple types\nNew unknown top type\nSupport for defaultProps in JSX\nCaveats\nExplicit types on defaultProps\n/// <reference lib=\"...\" /> reference directives\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nRC\nRI\nJB\n10+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.541 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.1",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-1.html",
    "html": "TypeScript 3.1\nMapped types on tuples and arrays\n\nIn TypeScript 3.1, mapped object types[1] over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like push(), pop(), and length are converted. For example:\n\ntype MapToPromise<T> = { [K in keyof T]: Promise<T[K]> };\ntype Coordinate = [number, number];\ntype PromiseCoordinate = MapToPromise<Coordinate>; // [Promise<number>, Promise<number>]\n\nMapToPromise takes a type T, and when that type is a tuple like Coordinate, only the numeric properties are converted. In [number, number], there are two numerically named properties: 0 and 1. When given a tuple like that, MapToPromise will create a new tuple where the 0 and 1 properties are Promises of the original type. So the resulting type PromiseCoordinate ends up with the type [Promise<number>, Promise<number>].\n\nProperties declarations on functions\n\nTypeScript 3.1 brings the ability to define properties on function declarations and const-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to namespace hacks. For example:\n\nfunction readImage(path: string, callback: (err: any, image: Image) => void) {\n  // ...\n}\nreadImage.sync = (path: string) => {\n  const contents = fs.readFileSync(path);\n  return decodeImageSync(contents);\n};\n\nHere, we have a function readImage which reads an image in a non-blocking asynchronous way. In addition to readImage, we’ve provided a convenience function on readImage itself called readImage.sync.\n\nWhile ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to “just work” in TypeScript. Additionally, this approach for property declarations allows us to express common patterns like defaultProps and propTypes on React function components (formerly known as SFCs).\n\nexport const FooComponent = ({ name }) => <div>Hello! I am {name}</div>;\nFooComponent.defaultProps = {\n  name: \"(anonymous)\",\n};\n\n[1] More specifically, homomorphic mapped types like in the above form.\n\nVersion selection with \ntypesVersions\n\nFeedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called typesVersions to help accommodate these scenarios.\n\nYou can read about it in the Publishing section of the declaration files section\n\nOn this page\nMapped types on tuples and arrays\nProperties declarations on functions\nVersion selection with typesVersions\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nCF\nMU\nSS\n10+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.279 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.3",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-3.html",
    "html": "TypeScript 3.3\nImproved behavior for calling union types\n\nIn prior versions of TypeScript, unions of callable types could only be invoked if they had identical parameter lists.\n\ntype Fruit = \"apple\" | \"orange\";\ntype Color = \"red\" | \"orange\";\ntype FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit\ntype ColorConsumer = (color: Color) => string; // consumes and describes the colors\ndeclare let f: FruitEater | ColorConsumer;\n// Cannot invoke an expression whose type lacks a call signature.\n//   Type 'FruitEater | ColorConsumer' has no compatible call signatures.ts(2349)\nf(\"orange\");\n\nHowever, in the above example, both FruitEaters and ColorConsumers should be able to take the string \"orange\", and return either a number or a string.\n\nIn TypeScript 3.3, this is no longer an error.\n\ntype Fruit = \"apple\" | \"orange\";\ntype Color = \"red\" | \"orange\";\ntype FruitEater = (fruit: Fruit) => number; // eats and ranks the fruit\ntype ColorConsumer = (color: Color) => string; // consumes and describes the colors\ndeclare let f: FruitEater | ColorConsumer;\nf(\"orange\"); // It works! Returns a 'number | string'.\nf(\"apple\"); // error - Argument of type '\"apple\"' is not assignable to parameter of type '\"orange\"'.\nf(\"red\"); // error - Argument of type '\"red\"' is not assignable to parameter of type '\"orange\"'.\n\nIn TypeScript 3.3, the parameters of these signatures are intersected together to create a new signature.\n\nIn the example above, the parameters fruit and color are intersected together to a new parameter of type Fruit & Color. Fruit & Color is really the same as (\"apple\" | \"orange\") & (\"red\" | \"orange\") which is equivalent to (\"apple\" & \"red\") | (\"apple\" & \"orange\") | (\"orange\" & \"red\") | (\"orange\" & \"orange\"). Each of those impossible intersections reduces to never, and we’re left with \"orange\" & \"orange\" which is just \"orange\".\n\nCaveats\n\nThis new behavior only kicks in when at most one type in the union has multiple overloads, and at most one type in the union has a generic signature. That means methods on number[] | string[] like map (which is generic) still won’t be callable.\n\nOn the other hand, methods like forEach will now be callable, but under noImplicitAny there may be some issues.\n\ninterface Dog {\n  kind: \"dog\";\n  dogProp: any;\n}\ninterface Cat {\n  kind: \"cat\";\n  catProp: any;\n}\nconst catOrDogArray: Dog[] | Cat[] = [];\ncatOrDogArray.forEach(animal => {\n  //                ~~~~~~ error!\n  // Parameter 'animal' implicitly has an 'any' type.\n});\n\nThis is still strictly more capable in TypeScript 3.3, and adding an explicit type annotation will work.\n\ninterface Dog {\n  kind: \"dog\";\n  dogProp: any;\n}\ninterface Cat {\n  kind: \"cat\";\n  catProp: any;\n}\nconst catOrDogArray: Dog[] | Cat[] = [];\ncatOrDogArray.forEach((animal: Dog | Cat) => {\n  if (animal.kind === \"dog\") {\n    animal.dogProp;\n    // ...\n  } else if (animal.kind === \"cat\") {\n    animal.catProp;\n    // ...\n  }\n});\nIncremental file watching for composite projects in \n--build --watch\n\nTypeScript 3.0 introduced a new feature for structuring builds called “composite projects”. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use --build mode to recompile only the set of projects and dependencies. You can think of this as optimizing inter-project builds.\n\nTypeScript 2.7 also introduced --watch mode builds via a new incremental “builder” API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing intra-project builds.\n\nPrior to 3.3, building composite projects using --build --watch actually didn’t use this incremental file watching infrastructure. An update in one project under --build --watch mode would force a full build of that project, rather than determining which files within that project were affected.\n\nIn TypeScript 3.3, --build mode’s --watch flag does leverage incremental file watching as well. That can mean significantly faster builds under --build --watch. In our testing, this functionality has resulted in a reduction of 50% to 75% in build times of the original --build --watch times. You can read more on the original pull request for the change to see specific numbers, but we believe most composite project users will see significant wins here.\n\nOn this page\nImproved behavior for calling union types\nCaveats\nIncremental file watching for composite projects in --build --watch\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nNS\nJB\nRA\n3+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.268 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.2",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html",
    "html": "TypeScript 3.2\nstrictBindCallApply\n\nTypeScript 3.2 introduces a new strictBindCallApply compiler option (in the strict family of options) with which the bind, call, and apply methods on function objects are strongly typed and strictly checked.\n\nfunction foo(a: number, b: string): string {\n  return a + b;\n}\nlet a = foo.apply(undefined, [10]); // error: too few arguments\nlet b = foo.apply(undefined, [10, 20]); // error: 2nd argument is a number\nlet c = foo.apply(undefined, [10, \"hello\", 30]); // error: too many arguments\nlet d = foo.apply(undefined, [10, \"hello\"]); // okay! returns a string\n\nThis is achieved by introducing two new types, CallableFunction and NewableFunction, in lib.d.ts. These types contain specialized generic method declarations for bind, call, and apply for regular functions and constructor functions, respectively. The declarations use generic rest parameters (see #24897) to capture and reflect parameter lists in a strongly typed manner. In strictBindCallApply mode these declarations are used in place of the (very permissive) declarations provided by type Function.\n\nCaveats\n\nSince the stricter checks may uncover previously unreported errors, this is a breaking change in strict mode.\n\nAdditionally, another caveat of this new functionality is that due to certain limitations, bind, call, and apply can’t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type ({}), and when used on a function with overloads, only the last overload will ever be modeled.\n\nGeneric spread expressions in object literals\n\nIn TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the Object.assign function and JSX literals. For example:\n\nfunction taggedObject<T, U extends string>(obj: T, tag: U) {\n  return { ...obj, tag }; // T & { tag: U }\n}\nlet x = taggedObject({ x: 10, y: 20 }, \"point\"); // { x: number, y: number } & { tag: \"point\" }\n\nProperty assignments and non-generic spread expressions are merged to the greatest extent possible on either side of a generic spread expression. For example:\n\nfunction foo1<T>(t: T, obj1: { a: string }, obj2: { b: string }) {\n  return { ...obj1, x: 1, ...t, ...obj2, y: 2 }; // { a: string, x: number } & T & { b: string, y: number }\n}\n\nNon-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:\n\nfunction spread<T, U>(t: T, u: U) {\n  return { ...t, ...u }; // T & U\n}\ndeclare let x: { a: string; b: number };\ndeclare let y: { b: string; c: boolean };\nlet s1 = { ...x, ...y }; // { a: string, b: string, c: boolean }\nlet s2 = spread(x, y); // { a: string, b: number } & { b: string, c: boolean }\nlet b1 = s1.b; // string\nlet b2 = s2.b; // number & string\nGeneric object rest variables and parameters\n\nTypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined Pick and Exclude helper types from lib.d.ts, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.\n\nfunction excludeTag<T extends { tag: string }>(obj: T) {\n  let { tag, ...rest } = obj;\n  return rest; // Pick<T, Exclude<keyof T, \"tag\">>\n}\nconst taggedPoint = { x: 10, y: 20, tag: \"point\" };\nconst point = excludeTag(taggedPoint); // { x: number, y: number }\nBigInt\n\nBigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting esnext.\n\nBigInt support in TypeScript introduces a new primitive type called the bigint (all lowercase). You can get a bigint by calling the BigInt() function or by writing out a BigInt literal by adding an n to the end of any integer numeric literal:\n\nlet foo: bigint = BigInt(100); // the BigInt function\nlet bar: bigint = 100n; // a BigInt literal\n// *Slaps roof of fibonacci function*\n// This bad boy returns ints that can get *so* big!\nfunction fibonacci(n: bigint) {\n  let result = 1n;\n  for (let last = 0n, i = 0n; i < n; i++) {\n    const current = result;\n    result += last;\n    last = current;\n  }\n  return result;\n}\nfibonacci(10000n);\n\nWhile you might imagine close interaction between number and bigint, the two are separate domains.\n\ndeclare let foo: number;\ndeclare let bar: bigint;\nfoo = bar; // error: Type 'bigint' is not assignable to type 'number'.\nbar = foo; // error: Type 'number' is not assignable to type 'bigint'.\n\nAs specified in ECMAScript, mixing numbers and bigints in arithmetic operations is an error. You’ll have to explicitly convert values to BigInts.\n\nconsole.log(3.141592 * 10000n); // error\nconsole.log(3145 * 10n); // error\nconsole.log(BigInt(3145) * 10n); // okay!\n\nAlso important to note is that bigints produce a new string when using the typeof operator: the string \"bigint\". Thus, TypeScript correctly narrows using typeof as you’d expect.\n\nfunction whatKindOfNumberIsIt(x: number | bigint) {\n  if (typeof x === \"bigint\") {\n    console.log(\"'x' is a bigint!\");\n  } else {\n    console.log(\"'x' is a floating-point number\");\n  }\n}\n\nWe’d like to extend a huge thanks to Caleb Sander for all the work on this feature. We’re grateful for the contribution, and we’re sure our users are too!\n\nCaveats\n\nAs we mentioned, BigInt support is only available for the esnext target. It may not be obvious, but because BigInts have different behavior for mathematical operators like +, -, *, etc., providing functionality for older targets where the feature doesn’t exist (like es2017 and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.\n\nFor that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you’ll be able to use BigInts there when targeting esnext.\n\nCertain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add esnext.bigint to the lib setting in your compiler options.\n\nNon-unit types as union discriminants\n\nTypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain some singleton type (e.g. a string literal, null, or undefined), and they contain no generics.\n\nAs a result, TypeScript 3.2 considers the error property in the following example to be a discriminant, whereas before it wouldn’t since Error isn’t a singleton type. Thanks to this, narrowing works correctly in the body of the unwrap function.\n\ntype Result<T> = { error: Error; data: null } | { error: null; data: T };\nfunction unwrap<T>(result: Result<T>) {\n  if (result.error) {\n    // Here 'error' is non-null\n    throw result.error;\n  }\n  // Now 'data' is non-null\n  return result.data;\n}\ntsconfig.json\n inheritance via Node.js packages\n\nTypeScript 3.2 now resolves tsconfig.jsons from node_modules. When using a bare path for the extends field in tsconfig.json, TypeScript will dive into node_modules packages for us.\n\n{\n  \"extends\": \"@my-team/tsconfig-base\",\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    // Override certain options on a project-by-project basis.\n    \"strictBindCallApply\": false\n  }\n}\n\nHere, TypeScript will climb up node_modules folders looking for a @my-team/tsconfig-base package. For each of those packages, TypeScript will first check whether package.json contains a \"tsconfig\" field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a tsconfig.json at the root. This is similar to the lookup process for .js files in packages that Node uses, and the .d.ts lookup process that TypeScript already uses.\n\nThis feature can be extremely useful for bigger organizations, or projects with lots of distributed dependencies.\n\nThe new \n--showConfig\n flag\n\ntsc, the TypeScript compiler, supports a new flag called --showConfig. When running tsc --showConfig, TypeScript will calculate the effective tsconfig.json (after calculating options inherited from the extends field) and print that out. This can be useful for diagnosing configuration issues in general.\n\nObject.defineProperty\n declarations in JavaScript\n\nWhen writing in JavaScript files (using allowJs), TypeScript now recognizes declarations that use Object.defineProperty. This means you’ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the checkJs option or adding a // @ts-check comment to the top of your file).\n\n// @ts-check\nlet obj = {};\nObject.defineProperty(obj, \"x\", { value: \"hello\", writable: false });\nobj.x.toLowercase();\n//    ~~~~~~~~~~~\n//    error:\n//     Property 'toLowercase' does not exist on type 'string'.\n//     Did you mean 'toLowerCase'?\nobj.x = \"world\";\n//  ~\n//  error:\n//   Cannot assign to 'x' because it is a read-only property.\nOn this page\nstrictBindCallApply\nCaveats\nGeneric spread expressions in object literals\nGeneric object rest variables and parameters\nBigInt\nCaveats\nNon-unit types as union discriminants\ntsconfig.json inheritance via Node.js packages\nThe new --showConfig flag\nObject.defineProperty declarations in JavaScript\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nNS\nJB\nMU\n2+\n\nLast updated: Nov 27, 2023\n\n "
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.9",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-9.html",
    "html": "TypeScript 3.9\nImprovements in Inference and \nPromise.all\n\nRecent versions of TypeScript (around 3.7) have had updates to the declarations of functions like Promise.all and Promise.race. Unfortunately, that introduced a few regressions, especially when mixing in values with null or undefined.\n\ninterface Lion {\n  roar(): void;\n}\ninterface Seal {\n  singKissFromARose(): void;\n}\nasync function visitZoo(\n  lionExhibit: Promise<Lion>,\n  sealExhibit: Promise<Seal | undefined>\n) {\n  let [lion, seal] = await Promise.all([lionExhibit, sealExhibit]);\n  lion.roar(); // uh oh\n  //  ~~~~\n  // Object is possibly 'undefined'.\n}\n\nThis is strange behavior! The fact that sealExhibit contained an undefined somehow poisoned type of lion to include undefined.\n\nThanks to a pull request from Jack Bates, this has been fixed with improvements in our inference process in TypeScript 3.9. The above no longer errors. If you’ve been stuck on older versions of TypeScript due to issues around Promises, we encourage you to give 3.9 a shot!\n\nWhat About the \nawaited\n Type?\n\nIf you’ve been following our issue tracker and design meeting notes, you might be aware of some work around a new type operator called awaited. This goal of this type operator is to accurately model the way that Promise unwrapping works in JavaScript.\n\nWe initially anticipated shipping awaited in TypeScript 3.9, but as we’ve run early TypeScript builds with existing codebases, we’ve realized that the feature needs more design work before we can roll it out to everyone smoothly. As a result, we’ve decided to pull the feature out of our main branch until we feel more confident. We’ll be experimenting more with the feature, but we won’t be shipping it as part of this release.\n\nSpeed Improvements\n\nTypeScript 3.9 ships with many new speed improvements. Our team has been focusing on performance after observing extremely poor editing/compilation speed with packages like material-ui and styled-components. We’ve dived deep here, with a series of different pull requests that optimize certain pathological cases involving large unions, intersections, conditional types, and mapped types.\n\nhttps://github.com/microsoft/TypeScript/pull/36576\nhttps://github.com/microsoft/TypeScript/pull/36590\nhttps://github.com/microsoft/TypeScript/pull/36607\nhttps://github.com/microsoft/TypeScript/pull/36622\nhttps://github.com/microsoft/TypeScript/pull/36754\nhttps://github.com/microsoft/TypeScript/pull/36696\n\nEach of these pull requests gains about a 5-10% reduction in compile times on certain codebases. In total, we believe we’ve achieved around a 40% reduction in material-ui’s compile time!\n\nWe also have some changes to file renaming functionality in editor scenarios. We heard from the Visual Studio Code team that when renaming a file, just figuring out which import statements needed to be updated could take between 5 to 10 seconds. TypeScript 3.9 addresses this issue by changing the internals of how the compiler and language service caches file lookups.\n\nWhile there’s still room for improvement, we hope this work translates to a snappier experience for everyone!\n\n// @ts-expect-error\n Comments\n\nImagine that we’re writing a library in TypeScript and we’re exporting some function called doStuff as part of our public API. The function’s types declare that it takes two strings so that other TypeScript users can get type-checking errors, but it also does a runtime check (maybe only in development builds) to give JavaScript users a helpful error.\n\nfunction doStuff(abc: string, xyz: string) {\n  assert(typeof abc === \"string\");\n  assert(typeof xyz === \"string\");\n  // do some stuff\n}\n\nSo TypeScript users will get a helpful red squiggle and an error message when they misuse this function, and JavaScript users will get an assertion error. We’d like to test this behavior, so we’ll write a unit test.\n\nexpect(() => {\n  doStuff(123, 456);\n}).toThrow();\n\nUnfortunately if our tests are written in TypeScript, TypeScript will give us an error!\n\ndoStuff(123, 456);\n//          ~~~\n// error: Type 'number' is not assignable to type 'string'.\n\nThat’s why TypeScript 3.9 brings a new feature: // @ts-expect-error comments. When a line is preceded by a // @ts-expect-error comment, TypeScript will suppress that error from being reported; but if there’s no error, TypeScript will report that // @ts-expect-error wasn’t necessary.\n\nAs a quick example, the following code is okay\n\n// @ts-expect-error\nconsole.log(47 * \"octopus\");\n\nwhile the following code\n\n// @ts-expect-error\nconsole.log(1 + 1);\n\nresults in the error\n\nUnused '@ts-expect-error' directive.\n\nWe’d like to extend a big thanks to Josh Goldberg, the contributor who implemented this feature. For more information, you can take a look at the ts-expect-error pull request.\n\nts-ignore\n or \nts-expect-error\n?\n\nIn some ways // @ts-expect-error can act as a suppression comment, similar to // @ts-ignore. The difference is that // @ts-ignore will do nothing if the following line is error-free.\n\nYou might be tempted to switch existing // @ts-ignore comments over to // @ts-expect-error, and you might be wondering which is appropriate for future code. While it’s entirely up to you and your team, we have some ideas of which to pick in certain situations.\n\nPick ts-expect-error if:\n\nyou’re writing test code where you actually want the type system to error on an operation\nyou expect a fix to be coming in fairly quickly and you just need a quick workaround\nyou’re in a reasonably-sized project with a proactive team that wants to remove suppression comments as soon affected code is valid again\n\nPick ts-ignore if:\n\nyou have a larger project and new errors have appeared in code with no clear owner\nyou are in the middle of an upgrade between two different versions of TypeScript, and a line of code errors in one version but not another.\nyou honestly don’t have the time to decide which of these options is better.\nUncalled Function Checks in Conditional Expressions\n\nIn TypeScript 3.7 we introduced uncalled function checks to report an error when you’ve forgotten to call a function.\n\nfunction hasImportantPermissions(): boolean {\n  // ...\n}\n// Oops!\nif (hasImportantPermissions) {\n  //  ~~~~~~~~~~~~~~~~~~~~~~~\n  // This condition will always return true since the function is always defined.\n  // Did you mean to call it instead?\n  deleteAllTheImportantFiles();\n}\n\nHowever, this error only applied to conditions in if statements. Thanks to a pull request from Alexander Tarasyuk, this feature is also now supported in ternary conditionals (i.e. the cond ? trueExpr : falseExpr syntax).\n\ndeclare function listFilesOfDirectory(dirPath: string): string[];\ndeclare function isDirectory(): boolean;\nfunction getAllFiles(startFileName: string) {\n  const result: string[] = [];\n  traverse(startFileName);\n  return result;\n  function traverse(currentPath: string) {\n    return isDirectory\n      ? //     ~~~~~~~~~~~\n        // This condition will always return true\n        // since the function is always defined.\n        // Did you mean to call it instead?\n        listFilesOfDirectory(currentPath).forEach(traverse)\n      : result.push(currentPath);\n  }\n}\n\nhttps://github.com/microsoft/TypeScript/issues/36048\n\nEditor Improvements\n\nThe TypeScript compiler not only powers the TypeScript editing experience in most major editors, it also powers the JavaScript experience in the Visual Studio family of editors and more. Using new TypeScript/JavaScript functionality in your editor will differ depending on your editor, but\n\nVisual Studio Code supports selecting different versions of TypeScript. Alternatively, there’s the JavaScript/TypeScript Nightly Extension to stay on the bleeding edge (which is typically very stable).\nVisual Studio 2017/2019 have [the SDK installers above] and MSBuild installs.\nSublime Text 3 supports selecting different versions of TypeScript\nCommonJS Auto-Imports in JavaScript\n\nOne great new improvement is in auto-imports in JavaScript files using CommonJS modules.\n\nIn older versions, TypeScript always assumed that regardless of your file, you wanted an ECMAScript-style import like\n\nimport * as fs from \"fs\";\n\nHowever, not everyone is targeting ECMAScript-style modules when writing JavaScript files. Plenty of users still use CommonJS-style require(...) imports like so\n\nconst fs = require(\"fs\");\n\nTypeScript now automatically detects the types of imports you’re using to keep your file’s style clean and consistent.\n\nFor more details on the change, see the corresponding pull request.\n\nCode Actions Preserve Newlines\n\nTypeScript’s refactorings and quick fixes often didn’t do a great job of preserving newlines. As a really basic example, take the following code.\n\nconst maxValue = 100;\n/*start*/\nfor (let i = 0; i <= maxValue; i++) {\n  // First get the squared value.\n  let square = i ** 2;\n  // Now print the squared value.\n  console.log(square);\n}\n/*end*/\n\nIf we highlighted the range from /*start*/ to /*end*/ in our editor to extract to a new function, we’d end up with code like the following.\n\nconst maxValue = 100;\nprintSquares();\nfunction printSquares() {\n  for (let i = 0; i <= maxValue; i++) {\n    // First get the squared value.\n    let square = i ** 2;\n    // Now print the squared value.\n    console.log(square);\n  }\n}\n\nThat’s not ideal - we had a blank line between each statement in our for loop, but the refactoring got rid of it! TypeScript 3.9 does a little more work to preserve what we write.\n\nconst maxValue = 100;\nprintSquares();\nfunction printSquares() {\n  for (let i = 0; i <= maxValue; i++) {\n    // First get the squared value.\n    let square = i ** 2;\n    // Now print the squared value.\n    console.log(square);\n  }\n}\n\nYou can see more about the implementation in this pull request\n\nQuick Fixes for Missing Return Expressions\n\nThere are occasions where we might forget to return the value of the last statement in a function, especially when adding curly braces to arrow functions.\n\n// before\nlet f1 = () => 42;\n// oops - not the same!\nlet f2 = () => {\n  42;\n};\n\nThanks to a pull request from community member Wenlu Wang, TypeScript can provide a quick-fix to add missing return statements, remove curly braces, or add parentheses to arrow function bodies that look suspiciously like object literals.\n\nSupport for “Solution Style” \ntsconfig.json\n Files\n\nEditors need to figure out which configuration file a file belongs to so that it can apply the appropriate options and figure out which other files are included in the current “project”. By default, editors powered by TypeScript’s language server do this by walking up each parent directory to find a tsconfig.json.\n\nOne case where this slightly fell over is when a tsconfig.json simply existed to reference other tsconfig.json files.\n\n// tsconfig.json\n{\n  \"files\": [],\n  \"references\": [\n    { \"path\": \"./tsconfig.shared.json\" },\n    { \"path\": \"./tsconfig.frontend.json\" },\n    { \"path\": \"./tsconfig.backend.json\" }\n  ]\n}\n\nThis file that really does nothing but manage other project files is often called a “solution” in some environments. Here, none of these tsconfig.*.json files get picked up by the server, but we’d really like the language server to understand that the current .ts file probably belongs to one of the mentioned projects in this root tsconfig.json.\n\nTypeScript 3.9 adds support to editing scenarios for this configuration. For more details, take a look at the pull request that added this functionality.\n\nBreaking Changes\nParsing Differences in Optional Chaining and Non-Null Assertions\n\nTypeScript recently implemented the optional chaining operator, but we’ve received user feedback that the behavior of optional chaining (?.) with the non-null assertion operator (!) is extremely counter-intuitive.\n\nSpecifically, in previous versions, the code\n\nfoo?.bar!.baz;\n\nwas interpreted to be equivalent to the following JavaScript.\n\n(foo?.bar).baz;\n\nIn the above code the parentheses stop the “short-circuiting” behavior of optional chaining, so if foo is undefined, accessing baz will cause a runtime error.\n\nThe Babel team who pointed this behavior out, and most users who provided feedback to us, believe that this behavior is wrong. We do too! The thing we heard the most was that the ! operator should just “disappear” since the intent was to remove null and undefined from the type of bar.\n\nIn other words, most people felt that the original snippet should be interpreted as\n\nfoo?.bar.baz;\n\nwhich just evaluates to undefined when foo is undefined.\n\nThis is a breaking change, but we believe most code was written with the new interpretation in mind. Users who want to revert to the old behavior can add explicit parentheses around the left side of the ! operator.\n\nfoo?.bar!.baz;\n}\n and \n>\n are Now Invalid JSX Text Characters\n\nThe JSX Specification forbids the use of the } and > characters in text positions. TypeScript and Babel have both decided to enforce this rule to be more conformant. The new way to insert these characters is to use an HTML escape code (e.g. <span> 2 &gt 1 </span>) or insert an expression with a string literal (e.g. <span> 2 {\">\"} 1 </span>).\n\nLuckily, thanks to the pull request enforcing this from Brad Zacher, you’ll get an error message along the lines of\n\nUnexpected token. Did you mean `{'>'}` or `>`?\nUnexpected token. Did you mean `{'}'}` or `}`?\n\nFor example:\n\nlet directions = <span>Navigate to: Menu Bar > Tools > Options</span>;\n//                                           ~       ~\n// Unexpected token. Did you mean `{'>'}` or `>`?\n\nThat error message came with a handy quick fix, and thanks to Alexander Tarasyuk, you can apply these changes in bulk if you have a lot of errors.\n\nStricter Checks on Intersections and Optional Properties\n\nGenerally, an intersection type like A & B is assignable to C if either A or B is assignable to C; however, sometimes that has problems with optional properties. For example, take the following:\n\ninterface A {\n  a: number; // notice this is 'number'\n}\ninterface B {\n  b: string;\n}\ninterface C {\n  a?: boolean; // notice this is 'boolean'\n  b: string;\n}\ndeclare let x: A & B;\ndeclare let y: C;\ny = x;\n\nIn previous versions of TypeScript, this was allowed because while A was totally incompatible with C, B was compatible with C.\n\nIn TypeScript 3.9, so long as every type in an intersection is a concrete object type, the type system will consider all of the properties at once. As a result, TypeScript will see that the a property of A & B is incompatible with that of C:\n\nType 'A & B' is not assignable to type 'C'.\n  Types of property 'a' are incompatible.\n    Type 'number' is not assignable to type 'boolean | undefined'.\n\nFor more information on this change, see the corresponding pull request.\n\nIntersections Reduced By Discriminant Properties\n\nThere are a few cases where you might end up with types that describe values that just don’t exist. For example\n\ndeclare function smushObjects<T, U>(x: T, y: U): T & U;\ninterface Circle {\n  kind: \"circle\";\n  radius: number;\n}\ninterface Square {\n  kind: \"square\";\n  sideLength: number;\n}\ndeclare let x: Circle;\ndeclare let y: Square;\nlet z = smushObjects(x, y);\nconsole.log(z.kind);\n\nThis code is slightly weird because there’s really no way to create an intersection of a Circle and a Square - they have two incompatible kind fields. In previous versions of TypeScript, this code was allowed and the type of kind itself was never because \"circle\" & \"square\" described a set of values that could never exist.\n\nIn TypeScript 3.9, the type system is more aggressive here - it notices that it’s impossible to intersect Circle and Square because of their kind properties. So instead of collapsing the type of z.kind to never, it collapses the type of z itself (Circle & Square) to never. That means the above code now errors with:\n\nProperty 'kind' does not exist on type 'never'.\n\nMost of the breaks we observed seem to correspond with slightly incorrect type declarations. For more details, see the original pull request.\n\nGetters/Setters are No Longer Enumerable\n\nIn older versions of TypeScript, get and set accessors in classes were emitted in a way that made them enumerable; however, this wasn’t compliant with the ECMAScript specification which states that they must be non-enumerable. As a result, TypeScript code that targeted ES5 and ES2015 could differ in behavior.\n\nThanks to a pull request from GitHub user pathurs, TypeScript 3.9 now conforms more closely with ECMAScript in this regard.\n\nType Parameters That Extend \nany\n No Longer Act as \nany\n\nIn previous versions of TypeScript, a type parameter constrained to any could be treated as any.\n\nfunction foo<T extends any>(arg: T) {\n  arg.spfjgerijghoied; // no error!\n}\n\nThis was an oversight, so TypeScript 3.9 takes a more conservative approach and issues an error on these questionable operations.\n\nfunction foo<T extends any>(arg: T) {\n  arg.spfjgerijghoied;\n  //  ~~~~~~~~~~~~~~~\n  // Property 'spfjgerijghoied' does not exist on type 'T'.\n}\nexport *\n is Always Retained\n\nIn previous TypeScript versions, declarations like export * from \"foo\" would be dropped in our JavaScript output if foo didn’t export any values. This sort of emit is problematic because it’s type-directed and can’t be emulated by Babel. TypeScript 3.9 will always emit these export * declarations. In practice, we don’t expect this to break much existing code.\n\nMore libdom.d.ts refinements\n\nWe are continuing to move more of TypeScript’s built-in .d.ts library (lib.d.ts and family) to be generated from Web IDL files directly from the DOM specification. As a result some vendor-specific types related to media access have been removed.\n\nAdding this file to an ambient *.d.ts to your project will bring them back:\n\ninterface AudioTrackList {\n     [Symbol.iterator](): IterableIterator<AudioTrack>;\n }\ninterface HTMLVideoElement {\n  readonly audioTracks: AudioTrackList\n  msFrameStep(forward: boolean): void;\n  msInsertVideoEffect(activatableClassId: string, effectRequired: boolean, config?: any): void;\n  msSetVideoRectangle(left: number, top: number, right: number, bottom: number): void;\n  webkitEnterFullScreen(): void;\n  webkitEnterFullscreen(): void;\n  webkitExitFullScreen(): void;\n  webkitExitFullscreen(): void;\n  msHorizontalMirror: boolean;\n  readonly msIsLayoutOptimalForPlayback: boolean;\n  readonly msIsStereo3D: boolean;\n  msStereo3DPackingMode: string;\n  msStereo3DRenderMode: string;\n  msZoom: boolean;\n  onMSVideoFormatChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;\n  onMSVideoFrameStepCompleted: ((this: HTMLVideoElement, ev: Event) => any) | null;\n  onMSVideoOptimalLayoutChanged: ((this: HTMLVideoElement, ev: Event) => any) | null;\n  webkitDisplayingFullscreen: boolean;\n  webkitSupportsFullscreen: boolean;\n}\ninterface MediaError {\n  readonly msExtendedCode: number;\n  readonly MS_MEDIA_ERR_ENCRYPTED: number;\n}\nOn this page\nImprovements in Inference and Promise.all\nWhat About the awaited Type?\nSpeed Improvements\n// @ts-expect-error Comments\nts-ignore or ts-expect-error?\nUncalled Function Checks in Conditional Expressions\nEditor Improvements\nCommonJS Auto-Imports in JavaScript\nCode Actions Preserve Newlines\nQuick Fixes for Missing Return Expressions\nSupport for “Solution Style” tsconfig.json Files\nBreaking Changes\nParsing Differences in Optional Chaining and Non-Null Assertions\n} and > are Now Invalid JSX Text Characters\nStricter Checks on Intersections and Optional Properties\nIntersections Reduced By Discriminant Properties\nGetters/Setters are No Longer Enumerable\nType Parameters That Extend any No Longer Act as any\nexport * is Always Retained\nMore libdom.d.ts refinements\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nNS\nMU\nHK\nJV\n1+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.281 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.7",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html",
    "html": "TypeScript 3.7\nOptional Chaining\n\nPlayground\n\nOptional chaining is issue #16 on our issue tracker. For context, there have been over 23,000 issues on the TypeScript issue tracker since then.\n\nAt its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a null or undefined. The star of the show in optional chaining is the new ?. operator for optional property accesses. When we write code like\n\nlet x = foo?.bar.baz();\n\nthis is a way of saying that when foo is defined, foo.bar.baz() will be computed; but when foo is null or undefined, stop what we’re doing and just return undefined.”\n\nMore plainly, that code snippet is the same as writing the following.\n\nlet x = foo === null || foo === undefined ? undefined : foo.bar.baz();\n\nNote that if bar is null or undefined, our code will still hit an error accessing baz. Likewise, if baz is null or undefined, we’ll hit an error at the call site. ?. only checks for whether the value on the left of it is null or undefined - not any of the subsequent properties.\n\nYou might find yourself using ?. to replace a lot of code that performs repetitive nullish checks using the && operator.\n\n// Before\nif (foo && foo.bar && foo.bar.baz) {\n  // ...\n}\n// After-ish\nif (foo?.bar?.baz) {\n  // ...\n}\n\nKeep in mind that ?. acts differently than those && operations since && will act specially on “falsy” values (e.g. the empty string, 0, NaN, and, well, false), but this is an intentional feature of the construct. It doesn’t short-circuit on valid data like 0 or empty strings.\n\nOptional chaining also includes two other operations. First there’s the optional element access which acts similarly to optional property accesses, but allows us to access non-identifier properties (e.g. arbitrary strings, numbers, and symbols):\n\n/**\n * Get the first element of the array if we have an array.\n * Otherwise return undefined.\n */\nfunction tryGetFirstElement<T>(arr?: T[]) {\n  return arr?.[0];\n  // equivalent to\n  //   return (arr === null || arr === undefined) ?\n  //       undefined :\n  //       arr[0];\n}\n\nThere’s also optional call, which allows us to conditionally call expressions if they’re not null or undefined.\n\nasync function makeRequest(url: string, log?: (msg: string) => void) {\n  log?.(`Request started at ${new Date().toISOString()}`);\n  // roughly equivalent to\n  //   if (log != null) {\n  //       log(`Request started at ${new Date().toISOString()}`);\n  //   }\n  const result = (await fetch(url)).json();\n  log?.(`Request finished at ${new Date().toISOString()}`);\n  return result;\n}\n\nThe “short-circuiting” behavior that optional chains have is limited property accesses, calls, element accesses - it doesn’t expand any further out from these expressions. In other words,\n\nlet result = foo?.bar / someComputation();\n\ndoesn’t stop the division or someComputation() call from occurring. It’s equivalent to\n\nlet temp = foo === null || foo === undefined ? undefined : foo.bar;\nlet result = temp / someComputation();\n\nThat might result in dividing undefined, which is why in strictNullChecks, the following is an error.\n\nfunction barPercentage(foo?: { bar: number }) {\n  return foo?.bar / 100;\n  //     ~~~~~~~~\n  // Error: Object is possibly undefined.\n}\n\nMore more details, you can read up on the proposal and view the original pull request.\n\nNullish Coalescing\n\nPlayground\n\nThe nullish coalescing operator is another upcoming ECMAScript feature that goes hand-in-hand with optional chaining, and which our team has been involved with championing in TC39.\n\nYou can think of this feature - the ?? operator - as a way to “fall back” to a default value when dealing with null or undefined. When we write code like\n\nlet x = foo ?? bar();\n\nthis is a new way to say that the value foo will be used when it’s “present”; but when it’s null or undefined, calculate bar() in its place.\n\nAgain, the above code is equivalent to the following.\n\nlet x = foo !== null && foo !== undefined ? foo : bar();\n\nThe ?? operator can replace uses of || when trying to use a default value. For example, the following code snippet tries to fetch the volume that was last saved in localStorage (if it ever was); however, it has a bug because it uses ||.\n\nfunction initializeAudio() {\n  let volume = localStorage.volume || 0.5;\n  // ...\n}\n\nWhen localStorage.volume is set to 0, the page will set the volume to 0.5 which is unintended. ?? avoids some unintended behavior from 0, NaN and \"\" being treated as falsy values.\n\nWe owe a large thanks to community members Wenlu Wang and Titian Cernicova Dragomir for implementing this feature! For more details, check out their pull request and the nullish coalescing proposal repository.\n\nAssertion Functions\n\nPlayground\n\nThere’s a specific set of functions that throw an error if something unexpected happened. They’re called “assertion” functions. As an example, Node.js has a dedicated function for this called assert.\n\nassert(someValue === 42);\n\nIn this example if someValue isn’t equal to 42, then assert will throw an AssertionError.\n\nAssertions in JavaScript are often used to guard against improper types being passed in. For example,\n\nfunction multiply(x, y) {\n  assert(typeof x === \"number\");\n  assert(typeof y === \"number\");\n  return x * y;\n}\n\nUnfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.\n\nfunction yell(str) {\n  assert(typeof str === \"string\");\n  return str.toUppercase();\n  // Oops! We misspelled 'toUpperCase'.\n  // Would be great if TypeScript still caught this!\n}\n\nThe alternative was to instead rewrite the code so that the language could analyze it, but this isn’t convenient.\n\nfunction yell(str) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"str should have been a string.\");\n  }\n  // Error caught!\n  return str.toUppercase();\n}\n\nUltimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called “assertion signatures” which model these assertion functions.\n\nThe first type of assertion signature models the way that Node’s assert function works. It ensures that whatever condition is being checked must be true for the remainder of the containing scope.\n\nfunction assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new AssertionError(msg);\n  }\n}\n\nasserts condition says that whatever gets passed into the condition parameter must be true if the assert returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we do catch our original yell example.\n\nfunction yell(str) {\n  assert(typeof str === \"string\");\n  return str.toUppercase();\n  //         ~~~~~~~~~~~\n  // error: Property 'toUppercase' does not exist on type 'string'.\n  //        Did you mean 'toUpperCase'?\n}\nfunction assert(condition: any, msg?: string): asserts condition {\n  if (!condition) {\n    throw new AssertionError(msg);\n  }\n}\n\nThe other type of assertion signature doesn’t check for a condition, but instead tells TypeScript that a specific variable or property has a different type.\n\nfunction assertIsString(val: any): asserts val is string {\n  if (typeof val !== \"string\") {\n    throw new AssertionError(\"Not a string!\");\n  }\n}\n\nHere asserts val is string ensures that after any call to assertIsString, any variable passed in will be known to be a string.\n\nfunction yell(str: any) {\n  assertIsString(str);\n  // Now TypeScript knows that 'str' is a 'string'.\n  return str.toUppercase();\n  //         ~~~~~~~~~~~\n  // error: Property 'toUppercase' does not exist on type 'string'.\n  //        Did you mean 'toUpperCase'?\n}\n\nThese assertion signatures are very similar to writing type predicate signatures:\n\nfunction isString(val: any): val is string {\n  return typeof val === \"string\";\n}\nfunction yell(str: any) {\n  if (isString(str)) {\n    return str.toUppercase();\n  }\n  throw \"Oops!\";\n}\n\nAnd just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.\n\nfunction assertIsDefined<T>(val: T): asserts val is NonNullable<T> {\n  if (val === undefined || val === null) {\n    throw new AssertionError(\n      `Expected 'val' to be defined, but received ${val}`\n    );\n  }\n}\n\nTo read up more about assertion signatures, check out the original pull request.\n\nBetter Support for \nnever\n-Returning Functions\n\nAs part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return never.\n\nThe intent of any function that returns never is that it never returns. It indicates that an exception was thrown, a halting error condition occurred, or that the program exited. For example, process.exit(...) in @types/node is specified to return never.\n\nIn order to ensure that a function never potentially returned undefined or effectively returned from all code paths, TypeScript needed some syntactic signal - either a return or throw at the end of a function. So users found themselves return-ing their failure functions.\n\nfunction dispatch(x: string | number): SomeType {\n  if (typeof x === \"string\") {\n    return doThingWithString(x);\n  } else if (typeof x === \"number\") {\n    return doThingWithNumber(x);\n  }\n  return process.exit(1);\n}\n\nNow when these never-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.\n\nfunction dispatch(x: string | number): SomeType {\n  if (typeof x === \"string\") {\n    return doThingWithString(x);\n  } else if (typeof x === \"number\") {\n    return doThingWithNumber(x);\n  }\n  process.exit(1);\n}\n\nAs with assertion functions, you can read up more at the same pull request.\n\n(More) Recursive Type Aliases\n\nPlayground\n\nType aliases have always had a limitation in how they could be “recursively” referenced. The reason is that any use of a type alias needs to be able to substitute itself with whatever it aliases. In some cases, that’s not possible, so the compiler rejects certain recursive aliases like the following:\n\ntype Foo = Foo;\n\nThis is a reasonable restriction because any use of Foo would need to be replaced with Foo which would need to be replaced with Foo which would need to be replaced with Foo which… well, hopefully you get the idea! In the end, there isn’t a type that makes sense in place of Foo.\n\nThis is fairly consistent with how other languages treat type aliases, but it does give rise to some slightly surprising scenarios for how users leverage the feature. For example, in TypeScript 3.6 and prior, the following causes an error.\n\ntype ValueOrArray<T> = T | Array<ValueOrArray<T>>;\n//   ~~~~~~~~~~~~\n// error: Type alias 'ValueOrArray' circularly references itself.\n\nThis is strange because there is technically nothing wrong with any use users could always write what was effectively the same code by introducing an interface.\n\ntype ValueOrArray<T> = T | ArrayOfValueOrArray<T>;\ninterface ArrayOfValueOrArray<T> extends Array<ValueOrArray<T>> {}\n\nBecause interfaces (and other object types) introduce a level of indirection and their full structure doesn’t need to be eagerly built out, TypeScript has no problem working with this structure.\n\nBut workaround of introducing the interface wasn’t intuitive for users. And in principle there really wasn’t anything wrong with the original version of ValueOrArray that used Array directly. If the compiler was a little bit “lazier” and only calculated the type arguments to Array when necessary, then TypeScript could express these correctly.\n\nThat’s exactly what TypeScript 3.7 introduces. At the “top level” of a type alias, TypeScript will defer resolving type arguments to permit these patterns.\n\nThis means that code like the following that was trying to represent JSON…\n\ntype Json = string | number | boolean | null | JsonObject | JsonArray;\ninterface JsonObject {\n  [property: string]: Json;\n}\ninterface JsonArray extends Array<Json> {}\n\ncan finally be rewritten without helper interfaces.\n\ntype Json =\n  | string\n  | number\n  | boolean\n  | null\n  | { [property: string]: Json }\n  | Json[];\n\nThis new relaxation also lets us recursively reference type aliases in tuples as well. The following code which used to error is now valid TypeScript code.\n\ntype VirtualNode = string | [string, { [key: string]: any }, ...VirtualNode[]];\nconst myNode: VirtualNode = [\n  \"div\",\n  { id: \"parent\" },\n  [\"div\", { id: \"first-child\" }, \"I'm the first child\"],\n  [\"div\", { id: \"second-child\" }, \"I'm the second child\"],\n];\n\nFor more information, you can read up on the original pull request.\n\n--declaration\n and \n--allowJs\n\nThe declaration flag in TypeScript allows us to generate .d.ts files (declaration files) from TypeScript source files (i.e. .ts and .tsx files). These .d.ts files are important for a couple of reasons.\n\nFirst of all, they’re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They’re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren’t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript and JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.\n\nUnfortunately, declaration didn’t work with the allowJs flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn’t use the declaration flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!\n\nThe most impactful outcome of this feature might a bit subtle: with TypeScript 3.7, users can write libraries in JSDoc annotated JavaScript and support TypeScript users.\n\nThe way that this works is that when using allowJs, TypeScript has some best-effort analyses to understand common JavaScript patterns; however, the way that some patterns are expressed in JavaScript don’t necessarily look like their equivalents in TypeScript. When declaration emit is turned on, TypeScript figures out the best way to transform JSDoc comments and CommonJS exports into valid type declarations and the like in the output .d.ts files.\n\nAs an example, the following code snippet\n\nconst assert = require(\"assert\");\nmodule.exports.blurImage = blurImage;\n/**\n * Produces a blurred image from an input buffer.\n *\n * @param input {Uint8Array}\n * @param width {number}\n * @param height {number}\n */\nfunction blurImage(input, width, height) {\n  const numPixels = width * height * 4;\n  assert(input.length === numPixels);\n  const result = new Uint8Array(numPixels);\n  // TODO\n  return result;\n}\n\nWill produce a .d.ts file like\n\n/**\n * Produces a blurred image from an input buffer.\n *\n * @param input {Uint8Array}\n * @param width {number}\n * @param height {number}\n */\nexport function blurImage(\n  input: Uint8Array,\n  width: number,\n  height: number\n): Uint8Array;\n\nThis can go beyond basic functions with @param tags too, where the following example:\n\n/**\n * @callback Job\n * @returns {void}\n */\n/** Queues work */\nexport class Worker {\n  constructor(maxDepth = 10) {\n    this.started = false;\n    this.depthLimit = maxDepth;\n    /**\n     * NOTE: queued jobs may add more items to queue\n     * @type {Job[]}\n     */\n    this.queue = [];\n  }\n  /**\n   * Adds a work item to the queue\n   * @param {Job} work\n   */\n  push(work) {\n    if (this.queue.length + 1 > this.depthLimit) throw new Error(\"Queue full!\");\n    this.queue.push(work);\n  }\n  /**\n   * Starts the queue if it has not yet started\n   */\n  start() {\n    if (this.started) return false;\n    this.started = true;\n    while (this.queue.length) {\n      /** @type {Job} */ (this.queue.shift())();\n    }\n    return true;\n  }\n}\n\nwill be transformed into the following .d.ts file:\n\n/**\n * @callback Job\n * @returns {void}\n */\n/** Queues work */\nexport class Worker {\n  constructor(maxDepth?: number);\n  started: boolean;\n  depthLimit: number;\n  /**\n   * NOTE: queued jobs may add more items to queue\n   * @type {Job[]}\n   */\n  queue: Job[];\n  /**\n   * Adds a work item to the queue\n   * @param {Job} work\n   */\n  push(work: Job): void;\n  /**\n   * Starts the queue if it has not yet started\n   */\n  start(): boolean;\n}\nexport type Job = () => void;\n\nNote that when using these flags together, TypeScript doesn’t necessarily have to downlevel .js files. If you simply want TypeScript to create .d.ts files, you can use the emitDeclarationOnly compiler option.\n\nFor more details, you can check out the original pull request.\n\nThe \nuseDefineForClassFields\n Flag and The \ndeclare\n Property Modifier\n\nBack when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code\n\nclass C {\n  foo = 100;\n  bar: string;\n}\n\nwould be equivalent to a similar assignment within a constructor body.\n\nclass C {\n  constructor() {\n    this.foo = 100;\n  }\n}\n\nUnfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:\n\nclass C {\n  constructor() {\n    Object.defineProperty(this, \"foo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 100,\n    });\n    Object.defineProperty(this, \"bar\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0,\n    });\n  }\n}\n\nWhile TypeScript 3.7 isn’t changing any existing emit by default, we’ve been rolling out changes incrementally to help users mitigate potential future breakage. We’ve provided a new flag called useDefineForClassFields to enable this emit mode with some new checking logic.\n\nThe two biggest changes are the following:\n\nDeclarations are initialized with Object.defineProperty.\nDeclarations are always initialized to undefined, even if they have no initializer.\n\nThis can cause quite a bit of fallout for existing code that use inheritance. First of all, set accessors from base classes won’t get triggered - they’ll be completely overwritten.\n\nclass Base {\n  set data(value: string) {\n    console.log(\"data changed to \" + value);\n  }\n}\nclass Derived extends Base {\n  // No longer triggers a 'console.log'\n  // when using 'useDefineForClassFields'.\n  data = 10;\n}\n\nSecondly, using class fields to specialize properties from base classes also won’t work.\n\ninterface Animal {\n  animalStuff: any;\n}\ninterface Dog extends Animal {\n  dogStuff: any;\n}\nclass AnimalHouse {\n  resident: Animal;\n  constructor(animal: Animal) {\n    this.resident = animal;\n  }\n}\nclass DogHouse extends AnimalHouse {\n  // Initializes 'resident' to 'undefined'\n  // after the call to 'super()' when\n  // using 'useDefineForClassFields'!\n  resident: Dog;\n  constructor(dog: Dog) {\n    super(dog);\n  }\n}\n\nWhat these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.\n\nTo detect the issue around accessors, TypeScript 3.7 will now emit get/set accessors in .d.ts files so that in TypeScript can check for overridden accessors.\n\nCode that’s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.\n\nclass Base {\n  set data(value: string) {\n    console.log(\"data changed to \" + value);\n  }\n}\nclass Derived extends Base {\n  constructor() {\n    this.data = 10;\n  }\n}\n\nTo help mitigate the second issue, you can either add an explicit initializer or add a declare modifier to indicate that a property should have no emit.\n\ninterface Animal {\n  animalStuff: any;\n}\ninterface Dog extends Animal {\n  dogStuff: any;\n}\nclass AnimalHouse {\n  resident: Animal;\n  constructor(animal: Animal) {\n    this.resident = animal;\n  }\n}\nclass DogHouse extends AnimalHouse {\n  declare resident: Dog;\n  //  ^^^^^^^\n  // 'resident' now has a 'declare' modifier,\n  // and won't produce any output code.\n  constructor(dog: Dog) {\n    super(dog);\n  }\n}\n\nCurrently useDefineForClassFields is only available when targeting ES5 and upwards, since Object.defineProperty doesn’t exist in ES3. To achieve similar checking for issues, you can create a separate project that targets ES5 and uses noEmit to avoid a full build.\n\nFor more information, you can take a look at the original pull request for these changes.\n\nWe strongly encourage users to try the useDefineForClassFields flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.\n\nBuild-Free Editing with Project References\n\nTypeScript’s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn’t been built (or whose output was out of date) meant that the editing experience wouldn’t work well.\n\nIn TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source .ts/.tsx files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and “just work”. You can disable this behavior with the compiler option disableSourceOfProjectReferenceRedirect which may be appropriate when working in very large projects where this change may impact editing performance.\n\nYou can read up more about this change by reading up on its pull request.\n\nUncalled Function Checks\n\nA common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.\n\ninterface User {\n  isAdministrator(): boolean;\n  notify(): void;\n  doNotDisturb?(): boolean;\n}\n// later...\n// Broken code, do not use!\nfunction doAdminThing(user: User) {\n  // oops!\n  if (user.isAdministrator) {\n    sudo();\n    editTheConfiguration();\n  } else {\n    throw new AccessDeniedError(\"User is not an admin\");\n  }\n}\n\nHere, we forgot to call isAdministrator, and the code incorrectly allows non-administrator users to edit the configuration!\n\nIn TypeScript 3.7, this is identified as a likely error:\n\nfunction doAdminThing(user: User) {\n    if (user.isAdministrator) {\n    //  ~~~~~~~~~~~~~~~~~~~~\n    // error! This condition will always return true since the function is always defined.\n    //        Did you mean to call it instead?\n\nThis check is a breaking change, but for that reason the checks are very conservative. This error is only issued in if conditions, and it is not issued on optional properties, if strictNullChecks is off, or if the function is later called within the body of the if:\n\ninterface User {\n  isAdministrator(): boolean;\n  notify(): void;\n  doNotDisturb?(): boolean;\n}\nfunction issueNotification(user: User) {\n  if (user.doNotDisturb) {\n    // OK, property is optional\n  }\n  if (user.notify) {\n    // OK, called the function\n    user.notify();\n  }\n}\n\nIf you intended to test the function without calling it, you can correct the definition of it to include undefined/null, or use !! to write something like if (!!user.isAdministrator) to indicate that the coercion is intentional.\n\nWe owe a big thanks to GitHub user @jwbay who took the initiative to create a proof-of-concept and iterated to provide us with the current version.\n\n// @ts-nocheck\n in TypeScript Files\n\nTypeScript 3.7 allows us to add // @ts-nocheck comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of checkJs, but we’ve expanded support to TypeScript files to make migrations easier for all users.\n\nSemicolon Formatter Option\n\nTypeScript’s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript’s automatic semicolon insertion (ASI) rules. The setting is available now in Visual Studio Code Insiders, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.\n\nChoosing a value of “insert” or “remove” also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of “ignore” makes generated code match the semicolon preference detected in the current file.\n\n3.7 Breaking Changes\nDOM Changes\n\nTypes in lib.dom.d.ts have been updated. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.\n\nClass Field Mitigations\n\nAs mentioned above, TypeScript 3.7 emits get/set accessors in .d.ts files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.\n\nWhile not a breakage per se, opting in to the useDefineForClassFields flag can cause breakage when:\n\noverriding an accessor in a derived class with a property declaration\nre-declaring a property declaration with no initializer\n\nTo understand the full impact, read the section above on the useDefineForClassFields flag.\n\nFunction Truthy Checks\n\nAs mentioned above, TypeScript now errors when functions appear to be uncalled within if statement conditions. An error is issued when a function type is checked in if conditions unless any of the following apply:\n\nthe checked value comes from an optional property\nstrictNullChecks is disabled\nthe function is later called within the body of the if\nLocal and Imported Type Declarations Now Conflict\n\nDue to a bug, the following construct was previously allowed in TypeScript:\n\n// ./someOtherModule.ts\ninterface SomeType {\n  y: string;\n}\n// ./myModule.ts\nimport { SomeType } from \"./someOtherModule\";\nexport interface SomeType {\n  x: number;\n}\nfunction fn(arg: SomeType) {\n  console.log(arg.x); // Error! 'x' doesn't exist on 'SomeType'\n}\n\nHere, SomeType appears to originate in both the import declaration and the local interface declaration. Perhaps surprisingly, inside the module, SomeType refers exclusively to the imported definition, and the local declaration SomeType is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.\n\nIn TypeScript 3.7, this is now correctly identified as a duplicate identifier error. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.\n\n3.7 API Changes\n\nTo enable the recursive type alias patterns described above, the typeArguments property has been removed from the TypeReference interface. Users should instead use the getTypeArguments function on TypeChecker instances.\n\nOn this page\nOptional Chaining\nNullish Coalescing\nAssertion Functions\nBetter Support for never-Returning Functions\n(More) Recursive Type Aliases\n--declaration and --allowJs\nThe useDefineForClassFields Flag and The declare Property Modifier\nBuild-Free Editing with Project References\nUncalled Function Checks\n// @ts-nocheck in TypeScript Files\nSemicolon Formatter Option\n3.7 Breaking Changes\nDOM Changes\nClass Field Mitigations\nFunction Truthy Checks\nLocal and Imported Type Declarations Now Conflict\n3.7 API Changes\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nJ\nNS\nJB\nGL\n12+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.442 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.4",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html",
    "html": "TypeScript 3.4\nFaster subsequent builds with the \n--incremental\n flag\n\nTypeScript 3.4 introduces a new flag called incremental which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with incremental, it will use that information to detect the least costly way to type-check and emit changes to your project.\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": true,\n    \"outDir\": \"./lib\"\n  },\n  \"include\": [\"./src\"]\n}\n\nBy default with these settings, when we run tsc, TypeScript will look for a file called .tsbuildinfo in the output directory (./lib). If ./lib/.tsbuildinfo doesn’t exist, it’ll be generated. But if it does, tsc will try to use that file to incrementally type-check and update our output files.\n\nThese .tsbuildinfo files can be safely deleted and don’t have any impact on our code at runtime - they’re purely used to make compilations faster. We can also name them anything that we want, and place them anywhere we want using the tsBuildInfoFile option.\n\n// front-end.tsconfig.json\n{\n  \"compilerOptions\": {\n    \"incremental\": true,\n    \"tsBuildInfoFile\": \"./buildcache/front-end\",\n    \"outDir\": \"./lib\"\n  },\n  \"include\": [\"./src\"]\n}\nComposite projects\n\nPart of the intent with composite projects (tsconfig.jsons with composite set to true) is that references between different projects can be built incrementally. As such, composite projects will always produce .tsbuildinfo files.\n\noutFile\n\nWhen outFile is used, the build information file’s name will be based on the output file’s name. As an example, if our output JavaScript file is ./output/foo.js, then under the incremental flag, TypeScript will generate the file ./output/foo.tsbuildinfo. As above, this can be controlled with the tsBuildInfoFile option.\n\nHigher order type inference from generic functions\n\nTypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.\n\nTo get more specific, let’s build up some motivation and consider the following compose function:\n\nfunction compose<A, B, C>(f: (arg: A) => B, g: (arg: B) => C): (arg: A) => C {\n  return (x) => g(f(x));\n}\n\ncompose takes two other functions:\n\nf which takes some argument (of type A) and returns a value of type B\ng which takes an argument of type B (the type f returned), and returns a value of type C\n\ncompose then returns a function which feeds its argument through f and then g.\n\nWhen calling this function, TypeScript will try to figure out the types of A, B, and C through a process called type argument inference. This inference process usually works pretty well:\n\ninterface Person {\n  name: string;\n  age: number;\n}\nfunction getDisplayName(p: Person) {\n  return p.name.toLowerCase();\n}\nfunction getLength(s: string) {\n  return s.length;\n}\n// has type '(p: Person) => number'\nconst getDisplayNameLength = compose(getDisplayName, getLength);\n// works and returns the type 'number'\ngetDisplayNameLength({ name: \"Person McPersonface\", age: 42 });\n\nThe inference process is fairly straightforward here because getDisplayName and getLength use types that can easily be referenced. However, in TypeScript 3.3 and earlier, generic functions like compose didn’t work so well when passed other generic functions.\n\ninterface Box<T> {\n  value: T;\n}\nfunction makeArray<T>(x: T): T[] {\n  return [x];\n}\nfunction makeBox<U>(value: U): Box<U> {\n  return { value };\n}\n// has type '(arg: {}) => Box<{}[]>'\nconst makeBoxedArray = compose(makeArray, makeBox);\nmakeBoxedArray(\"hello!\").value[0].toUpperCase();\n//                                ~~~~~~~~~~~\n// error: Property 'toUpperCase' does not exist on type '{}'.\n\nIn older versions, TypeScript would infer the empty object type ({}) when inferring from other type variables like T and U.\n\nDuring type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript will, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.\n\nIn other words, instead of producing the type\n\n(arg: {}) => Box<{}[]>\n\nTypeScript 3.4 produces the type\n\n<T>(arg: T) => Box<T[]>\n\nNotice that T has been propagated from makeArray into the resulting type’s type parameter list. This means that genericity from compose’s arguments has been preserved and our makeBoxedArray sample will just work!\n\ninterface Box<T> {\n  value: T;\n}\nfunction makeArray<T>(x: T): T[] {\n  return [x];\n}\nfunction makeBox<U>(value: U): Box<U> {\n  return { value };\n}\n// has type '<T>(arg: T) => Box<T[]>'\nconst makeBoxedArray = compose(makeArray, makeBox);\n// works with no problem!\nmakeBoxedArray(\"hello!\").value[0].toUpperCase();\n\nFor more details, you can read more at the original change.\n\nImprovements for \nReadonlyArray\n and \nreadonly\n tuples\n\nTypeScript 3.4 makes it a little bit easier to use read-only array-like types.\n\nA new syntax for \nReadonlyArray\n\nThe ReadonlyArray type describes Arrays that can only be read from. Any variable with a reference to a ReadonlyArray can’t add, remove, or replace any elements of the array.\n\nfunction foo(arr: ReadonlyArray<string>) {\n  arr.slice(); // okay\n  arr.push(\"hello!\"); // error!\n}\n\nWhile it’s good practice to use ReadonlyArray over Array when no mutation is intended, it’s often been a pain given that arrays have a nicer syntax. Specifically, number[] is a shorthand version of Array<number>, just as Date[] is a shorthand for Array<Date>.\n\nTypeScript 3.4 introduces a new syntax for ReadonlyArray using a new readonly modifier for array types.\n\nfunction foo(arr: readonly string[]) {\n  arr.slice(); // okay\n  arr.push(\"hello!\"); // error!\n}\nreadonly\n tuples\n\nTypeScript 3.4 also introduces new support for readonly tuples. We can prefix any tuple type with the readonly keyword to make it a readonly tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, readonly tuples only permit reading from those positions.\n\nfunction foo(pair: readonly [string, string]) {\n  console.log(pair[0]); // okay\n  pair[1] = \"hello!\"; // error\n}\n\nThe same way that ordinary tuples are types that extend from Array - a tuple with elements of type T1, T2, … Tn extends from Array< T1 | T2 | … Tn > - readonly tuples are types that extend from ReadonlyArray. So a readonly tuple with elements T1, T2, … Tn extends from ReadonlyArray< T1 | T2 | … Tn.\n\nreadonly\n mapped type modifiers and \nreadonly\n arrays\n\nIn earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like Boxify could work on arrays and tuples alike.\n\ninterface Box<T> {\n  value: T;\n}\ntype Boxify<T> = {\n  [K in keyof T]: Box<T[K]>;\n};\n// { a: Box<string>, b: Box<number> }\ntype A = Boxify<{ a: string; b: number }>;\n// Array<Box<number>>\ntype B = Boxify<number[]>;\n// [Box<string>, Box<number>]\ntype C = Boxify<[string, boolean]>;\n\nUnfortunately, mapped types like the Readonly utility type were effectively no-ops on array and tuple types.\n\n// lib.d.ts\ntype Readonly<T> = {\n  readonly [K in keyof T]: T[K];\n};\n// How code acted *before* TypeScript 3.4\n// { readonly a: string, readonly b: number }\ntype A = Readonly<{ a: string; b: number }>;\n// number[]\ntype B = Readonly<number[]>;\n// [string, boolean]\ntype C = Readonly<[string, boolean]>;\n\nIn TypeScript 3.4, the readonly modifier in a mapped type will automatically convert array-like types to their corresponding readonly counterparts.\n\n// How code acts now *with* TypeScript 3.4\n// { readonly a: string, readonly b: number }\ntype A = Readonly<{ a: string; b: number }>;\n// readonly number[]\ntype B = Readonly<number[]>;\n// readonly [string, boolean]\ntype C = Readonly<[string, boolean]>;\n\nSimilarly, you could write a utility type like Writable mapped type that strips away readonly-ness, and that would convert readonly array containers back to their mutable equivalents.\n\ntype Writable<T> = {\n  -readonly [K in keyof T]: T[K];\n};\n// { a: string, b: number }\ntype A = Writable<{\n  readonly a: string;\n  readonly b: number;\n}>;\n// number[]\ntype B = Writable<readonly number[]>;\n// [string, boolean]\ntype C = Writable<readonly [string, boolean]>;\nCaveats\n\nDespite its appearance, the readonly type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.\n\nlet err1: readonly Set<number>; // error!\nlet err2: readonly Array<boolean>; // error!\nlet okay: readonly boolean[]; // works fine\n\nYou can see more details in the pull request.\n\nconst\n assertions\n\nTypeScript 3.4 introduces a new construct for literal values called const assertions. Its syntax is a type assertion with const in place of the type name (e.g. 123 as const). When we construct new literal expressions with const assertions, we can signal to the language that\n\nno literal types in that expression should be widened (e.g. no going from \"hello\" to string)\nobject literals get readonly properties\narray literals become readonly tuples\n// Type '\"hello\"'\nlet x = \"hello\" as const;\n// Type 'readonly [10, 20]'\nlet y = [10, 20] as const;\n// Type '{ readonly text: \"hello\" }'\nlet z = { text: \"hello\" } as const;\n\nOutside of .tsx files, the angle bracket assertion syntax can also be used.\n\n// Type '\"hello\"'\nlet x = <const>\"hello\";\n// Type 'readonly [10, 20]'\nlet y = <const>[10, 20];\n// Type '{ readonly text: \"hello\" }'\nlet z = <const>{ text: \"hello\" };\n\nThis feature means that types that would otherwise be used just to hint immutability to the compiler can often be omitted.\n\n// Works with no types referenced or declared.\n// We only needed a single const assertion.\nfunction getShapes() {\n  let result = [\n    { kind: \"circle\", radius: 100 },\n    { kind: \"square\", sideLength: 50 },\n  ] as const;\n  return result;\n}\nfor (const shape of getShapes()) {\n  // Narrows perfectly!\n  if (shape.kind === \"circle\") {\n    console.log(\"Circle radius\", shape.radius);\n  } else {\n    console.log(\"Square side length\", shape.sideLength);\n  }\n}\n\nNotice the above needed no type annotations. The const assertion allowed TypeScript to take the most specific type of the expression.\n\nThis can even be used to enable enum-like patterns in plain JavaScript code if you choose not to use TypeScript’s enum construct.\n\nexport const Colors = {\n  red: \"RED\",\n  blue: \"BLUE\",\n  green: \"GREEN\",\n} as const;\n// or use an 'export default'\nexport default {\n  red: \"RED\",\n  blue: \"BLUE\",\n  green: \"GREEN\",\n} as const;\nCaveats\n\nOne thing to note is that const assertions can only be applied immediately on simple literal expressions.\n\n// Error! A 'const' assertion can only be applied to a\n// to a string, number, boolean, array, or object literal.\nlet a = (Math.random() < 0.5 ? 0 : 1) as const;\nlet b = (60 * 60 * 1000) as const;\n// Works!\nlet c = Math.random() < 0.5 ? (0 as const) : (1 as const);\nlet d = 3_600_000 as const;\n\nAnother thing to keep in mind is that const contexts don’t immediately convert an expression to be fully immutable.\n\nlet arr = [1, 2, 3, 4];\nlet foo = {\n  name: \"foo\",\n  contents: arr,\n} as const;\nfoo.name = \"bar\"; // error!\nfoo.contents = []; // error!\nfoo.contents.push(5); // ...works!\n\nFor more details, you can check out the respective pull request.\n\nType-checking for \nglobalThis\n\nTypeScript 3.4 introduces support for type-checking ECMAScript’s new globalThis - a global variable that, well, refers to the global scope. Unlike the above solutions, globalThis provides a standard way for accessing the global scope which can be used across different environments.\n\n// in a global file:\nvar abc = 100;\n// Refers to 'abc' from above.\nglobalThis.abc = 200;\n\nNote that global variables declared with let and const don’t show up on globalThis.\n\nlet answer = 42;\n// error! Property 'answer' does not exist on 'typeof globalThis'.\nglobalThis.answer = 333333;\n\nIt’s also important to note that TypeScript doesn’t transform references to globalThis when compiling to older versions of ECMAScript. As such, unless you’re targeting evergreen browsers (which already support globalThis), you may want to use an appropriate polyfill instead.\n\nFor more details on the implementation, see the feature’s pull request.\n\nOn this page\nFaster subsequent builds with the --incremental flag\nComposite projects\noutFile\nHigher order type inference from generic functions\nImprovements for ReadonlyArray and readonly tuples\nA new syntax for ReadonlyArray\nreadonly tuples\nreadonly mapped type modifiers and readonly arrays\nCaveats\nconst assertions\nCaveats\nType-checking for globalThis\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nJB\nMU\nMC\n3+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.492 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.5",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-5.html",
    "html": "TypeScript 3.5\nSpeed improvements\n\nTypeScript 3.5 introduces several optimizations around type-checking and incremental builds.\n\nType-checking speed-ups\n\nTypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.\n\n--incremental\n improvements\n\nTypeScript 3.5 improves on 3.4’s incremental build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript’s project references in --build mode, we’ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4!\n\nFor more details, you can see the pull requests to\n\ncache module resolution\ncache settings calculated from tsconfig.json\nThe \nOmit\n helper type\n\nTypeScript 3.5 introduces the new Omit helper type, which creates a new type with some properties dropped from the original.\n\ntype Person = {\n  name: string;\n  age: number;\n  location: string;\n};\ntype QuantumPerson = Omit<Person, \"location\">;\n// equivalent to\ntype QuantumPerson = {\n  name: string;\n  age: number;\n};\n\nHere we were able to copy over all the properties of Person except for location using the Omit helper.\n\nFor more details, see the pull request on GitHub to add Omit, as well as the change to use Omit for object rest.\n\nImproved excess property checks in union types\n\nIn TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn’t have been. For instance, TypeScript 3.4 permitted the incorrect name property in the object literal even though its types don’t match between Point and Label.\n\ntype Point = {\n  x: number;\n  y: number;\n};\ntype Label = {\n  name: string;\n};\nconst thing: Point | Label = {\n  x: 0,\n  y: 0,\n  name: true // uh-oh!\n};\n\nPreviously, a non-disciminated union wouldn’t have any excess property checking done on its members, and as a result, the incorrectly typed name property slipped by.\n\nIn TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to some union member and have the appropriate type, meaning that the sample above correctly issues an error.\n\nNote that partial overlap is still permitted as long as the property types are valid.\n\nconst pl: Point | Label = {\n  x: 0,\n  y: 0,\n  name: \"origin\" // okay\n};\nThe \n--allowUmdGlobalAccess\n flag\n\nIn TypeScript 3.5, you can now reference UMD global declarations like\n\nexport as namespace foo;\n\nfrom anywhere - even modules - using the new allowUmdGlobalAccess flag.\n\nThis mode adds flexibility for mixing and matching the way 3rd party libraries, where globals that libraries declare can always be consumed, even from within modules.\n\nFor more details, see the pull request on GitHub.\n\nSmarter union type checking\n\nIn TypeScript 3.4 and prior, the following example would fail:\n\ntype S = { done: boolean; value: number };\ntype T = { done: false; value: number } | { done: true; value: number };\ndeclare let source: S;\ndeclare let target: T;\ntarget = source;\n\nThat’s because S isn’t assignable to { done: false, value: number } nor { done: true, value: number }. Why? Because the done property in S isn’t specific enough - it’s boolean whereas each constituent of T has a done property that’s specifically true or false. That’s what we meant by each constituent type being checked in isolation: TypeScript doesn’t just union each property together and see if S is assignable to that. If it did, some bad code could get through like the following:\n\ninterface Foo {\n  kind: \"foo\";\n  value: string;\n}\ninterface Bar {\n  kind: \"bar\";\n  value: number;\n}\nfunction doSomething(x: Foo | Bar) {\n  if (x.kind === \"foo\") {\n    x.value.toLowerCase();\n  }\n}\n// uh-oh - luckily TypeScript errors here!\ndoSomething({\n  kind: \"foo\",\n  value: 123\n});\n\nHowever, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of S, you can actually see that it matches the types in T exactly.\n\nIn TypeScript 3.5, when assigning to types with discriminant properties like in T, the language actually will go further and decompose types like S into a union of every possible inhabitant type. In this case, since boolean is a union of true and false, S will be viewed as a union of { done: false, value: number } and { done: true, value: number }.\n\nFor more details, you can see the original pull request on GitHub.\n\nHigher order type inference from generic constructors\n\nIn TypeScript 3.4, we improved inference for when generic functions that return functions like so:\n\nfunction compose<T, U, V>(f: (x: T) => U, g: (y: U) => V): (x: T) => V {\n  return x => g(f(x));\n}\n\ntook other generic functions as arguments, like so:\n\nfunction arrayify<T>(x: T): T[] {\n  return [x];\n}\ntype Box<U> = { value: U };\nfunction boxify<U>(y: U): Box<U> {\n  return { value: y };\n}\nlet newFn = compose(arrayify, boxify);\n\nInstead of a relatively useless type like (x: {}) => Box<{}[]>, which older versions of the language would infer, TypeScript 3.4’s inference allows newFn to be generic. Its new type is <T>(x: T) => Box<T[]>.\n\nTypeScript 3.5 generalizes this behavior to work on constructor functions as well.\n\nclass Box<T> {\n  kind: \"box\";\n  value: T;\n  constructor(value: T) {\n    this.value = value;\n  }\n}\nclass Bag<U> {\n  kind: \"bag\";\n  value: U;\n  constructor(value: U) {\n    this.value = value;\n  }\n}\nfunction composeCtor<T, U, V>(\n  F: new (x: T) => U,\n  G: new (y: U) => V\n): (x: T) => V {\n  return x => new G(new F(x));\n}\nlet f = composeCtor(Box, Bag); // has type '<T>(x: T) => Bag<Box<T>>'\nlet a = f(1024); // has type 'Bag<Box<number>>'\n\nIn addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.\n\ntype ComponentClass<P> = new (props: P) => Component<P>;\ndeclare class Component<P> {\n  props: P;\n  constructor(props: P);\n}\ndeclare function myHoc<P>(C: ComponentClass<P>): ComponentClass<P>;\ntype NestedProps<T> = { foo: number; stuff: T };\ndeclare class GenericComponent<T> extends Component<NestedProps<T>> {}\n// type is 'new <T>(props: NestedProps<T>) => Component<NestedProps<T>>'\nconst GenericComponent2 = myHoc(GenericComponent);\n\nTo learn more, check out the original pull request on GitHub.\n\nOn this page\nSpeed improvements\nType-checking speed-ups\n--incremental improvements\nThe Omit helper type\nImproved excess property checks in union types\nThe --allowUmdGlobalAccess flag\nSmarter union type checking\nHigher order type inference from generic constructors\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nJB\n1+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.233 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.6",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-6.html",
    "html": "TypeScript 3.6\nStricter Generators\n\nTypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.\n\nfunction* foo() {\n  if (Math.random() < 0.5) yield 100;\n  return \"Finished!\";\n}\nlet iter = foo();\nlet curr = iter.next();\nif (curr.done) {\n  // TypeScript 3.5 and prior thought this was a 'string | number'.\n  // It should know it's 'string' since 'done' was 'true'!\n  curr.value;\n}\n\nAdditionally, generators just assumed the type of yield was always any.\n\nfunction* bar() {\n  let x: { hello(): void } = yield;\n  x.hello();\n}\nlet iter = bar();\niter.next();\niter.next(123); // oops! runtime error!\n\nIn TypeScript 3.6, the checker now knows that the correct type for curr.value should be string in our first example, and will correctly error on our call to next() in our last example. This is thanks to some changes in the Iterator and IteratorResult type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the Generator type.\n\nThe Iterator type now allows users to specify the yielded type, the returned type, and the type that next can accept.\n\ninterface Iterator<T, TReturn = any, TNext = undefined> {\n  // Takes either 0 or 1 arguments - doesn't accept 'undefined'\n  next(...args: [] | [TNext]): IteratorResult<T, TReturn>;\n  return?(value?: TReturn): IteratorResult<T, TReturn>;\n  throw?(e?: any): IteratorResult<T, TReturn>;\n}\n\nBuilding on that work, the new Generator type is an Iterator that always has both the return and throw methods present, and is also iterable.\n\ninterface Generator<T = unknown, TReturn = any, TNext = unknown>\n  extends Iterator<T, TReturn, TNext> {\n  next(...args: [] | [TNext]): IteratorResult<T, TReturn>;\n  return(value: TReturn): IteratorResult<T, TReturn>;\n  throw(e: any): IteratorResult<T, TReturn>;\n  [Symbol.iterator](): Generator<T, TReturn, TNext>;\n}\n\nTo allow differentiation between returned values and yielded values, TypeScript 3.6 converts the IteratorResult type to a discriminated union type:\n\ntype IteratorResult<T, TReturn = any> =\n  | IteratorYieldResult<T>\n  | IteratorReturnResult<TReturn>;\ninterface IteratorYieldResult<TYield> {\n  done?: false;\n  value: TYield;\n}\ninterface IteratorReturnResult<TReturn> {\n  done: true;\n  value: TReturn;\n}\n\nIn short, what this means is that you’ll be able to appropriately narrow down values from iterators when dealing with them directly.\n\nTo correctly represent the types that can be passed in to a generator from calls to next(), TypeScript 3.6 also infers certain uses of yield within the body of a generator function.\n\nfunction* foo() {\n  let x: string = yield;\n  console.log(x.toUpperCase());\n}\nlet x = foo();\nx.next(); // first call to 'next' is always ignored\nx.next(42); // error! 'number' is not assignable to 'string'\n\nIf you’d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from yield expressions using an explicit return type. Below, next() can only be called with booleans, and depending on the value of done, value is either a string or a number.\n\n/**\n * - yields numbers\n * - returns strings\n * - can be passed in booleans\n */\nfunction* counter(): Generator<number, string, boolean> {\n  let i = 0;\n  while (true) {\n    if (yield i++) {\n      break;\n    }\n  }\n  return \"done!\";\n}\nvar iter = counter();\nvar curr = iter.next();\nwhile (!curr.done) {\n  console.log(curr.value);\n  curr = iter.next(curr.value === 5);\n}\nconsole.log(curr.value.toUpperCase());\n// prints:\n//\n// 0\n// 1\n// 2\n// 3\n// 4\n// 5\n// DONE!\n\nFor more details on the change, see the pull request here.\n\nMore Accurate Array Spread\n\nIn pre-ES2015 targets, the most faithful emit for constructs like for/of loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the downlevelIteration flag. The looser default without downlevelIteration works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread\n\n[...Array(5)];\n\ncan be rewritten as the following array literal\n\n[undefined, undefined, undefined, undefined, undefined];\n\nHowever, TypeScript would instead transform the original code into this code:\n\nArray(5).slice();\n\nwhich is slightly different. Array(5) produces an array with a length of 5, but with no defined property slots.\n\nTypeScript 3.6 introduces a new __spreadArrays helper to accurately model what happens in ECMAScript 2015 in older targets outside of downlevelIteration. __spreadArrays is also available in tslib.\n\nFor more information, see the relevant pull request.\n\nImproved UX Around Promises\n\nTypeScript 3.6 introduces some improvements for when Promises are mis-handled.\n\nFor example, it’s often very common to forget to .then() or await the contents of a Promise before passing it to another function. TypeScript’s error messages are now specialized, and inform the user that perhaps they should consider using the await keyword.\n\ninterface User {\n  name: string;\n  age: number;\n  location: string;\n}\ndeclare function getUserData(): Promise<User>;\ndeclare function displayUser(user: User): void;\nasync function f() {\n  displayUser(getUserData());\n  //              ~~~~~~~~~~~~~\n  // Argument of type 'Promise<User>' is not assignable to parameter of type 'User'.\n  //   ...\n  // Did you forget to use 'await'?\n}\n\nIt’s also common to try to access a method before await-ing or .then()-ing a Promise. This is another example, among many others, where we’re able to do better.\n\nasync function getCuteAnimals() {\n  fetch(\"https://reddit.com/r/aww.json\").json();\n  //   ~~~~\n  // Property 'json' does not exist on type 'Promise<Response>'.\n  //\n  // Did you forget to use 'await'?\n}\n\nFor more details, see the originating issue, as well as the pull requests that link back to it.\n\nBetter Unicode Support for Identifiers\n\nTypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.\n\nconst 𝓱𝓮𝓵𝓵𝓸 = \"world\"; // previously disallowed, now allowed in '--target es2015'\nimport.meta\n Support in SystemJS\n\nTypeScript 3.6 supports transforming import.meta to context.meta when your module target is set to system.\n\n// This module:\nconsole.log(import.meta.url);\n// gets turned into the following:\nSystem.register([], function (exports, context) {\n  return {\n    setters: [],\n    execute: function () {\n      console.log(context.meta.url);\n    },\n  };\n});\nget\n and \nset\n Accessors Are Allowed in Ambient Contexts\n\nIn previous versions of TypeScript, the language didn’t allow get and set accessors in ambient contexts (like in declare-d classes, or in .d.ts files in general). The rationale was that accessors weren’t distinct from properties as far as writing and reading to these properties; however, because ECMAScript’s class fields proposal may have differing behavior from in existing versions of TypeScript, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.\n\nAs a result, users can write getters and setters in ambient contexts in TypeScript 3.6.\n\ndeclare class Foo {\n  // Allowed in 3.6+.\n  get x(): number;\n  set x(val: number);\n}\n\nIn TypeScript 3.7, the compiler itself will take advantage of this feature so that generated .d.ts files will also emit get/set accessors.\n\nAmbient Classes and Functions Can Merge\n\nIn previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the declare modifier, or in .d.ts files) can merge. This means that now you can write the following:\n\nexport declare function Point2D(x: number, y: number): Point2D;\nexport declare class Point2D {\n  x: number;\n  y: number;\n  constructor(x: number, y: number);\n}\n\ninstead of needing to use\n\nexport interface Point2D {\n  x: number;\n  y: number;\n}\nexport declare var Point2D: {\n  (x: number, y: number): Point2D;\n  new (x: number, y: number): Point2D;\n};\n\nOne advantage of this is that the callable constructor pattern can be easily expressed while also allowing namespaces to merge with these declarations (since var declarations can’t merge with namespaces).\n\nIn TypeScript 3.7, the compiler will take advantage of this feature so that .d.ts files generated from .js files can appropriately capture both the callability and constructability of a class-like function.\n\nFor more details, see the original PR on GitHub.\n\nAPIs to Support \n--build\n and \n--incremental\n\nTypeScript 3.0 introduced support for referencing other projects and building them incrementally using the --build flag. Additionally, TypeScript 3.4 introduced the incremental flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn’t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.\n\nFor creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs. Users can also re-hydrate old program instances from .tsbuildinfo files generated by this API using the newly exposed readBuilderProgram function, which is only meant to be used as for creating new programs (i.e. you can’t modify the returned instance - it’s only meant to be used for the oldProgram parameter in other create*Program functions).\n\nFor leveraging project references, a new createSolutionBuilder function has been exposed, which returns an instance of the new type SolutionBuilder.\n\nFor more details on these APIs, you can see the original pull request.\n\nSemicolon-Aware Code Edits\n\nEditors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users’ style guidelines, and many users were displeased with the editor inserting semicolons.\n\nTypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won’t add one.\n\nFor more details, see the corresponding pull request.\n\nSmarter Auto-Import Syntax\n\nJavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and require calls.\n\nTypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can see more details in the original pull request here.\n\nNew TypeScript Playground\n\nThe TypeScript playground has received a much-needed refresh with handy new functionality! The new playground is largely a fork of Artem Tyurin’s TypeScript playground which community members have been using more and more. We owe Artem a big thanks for helping out here!\n\nThe new playground now supports many new options including:\n\nThe target option (allowing users to switch out of es5 to es3, es2015, esnext, etc.)\nAll the strictness flags (including just strict)\nSupport for plain JavaScript files (using allowJS and optionally checkJs)\n\nThese options also persist when sharing links to playground samples, allowing users to more reliably share examples without having to tell the recipient “oh, don’t forget to turn on the noImplicitAny option!“.\n\nIn the near future, we’re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you’ll be able to see the same experience on the playground as you’d get in your personal editor.\n\nAs we improve the playground and the website, we welcome feedback and pull requests on GitHub!\n\nOn this page\nStricter Generators\nMore Accurate Array Spread\nImproved UX Around Promises\nBetter Unicode Support for Identifiers\nimport.meta Support in SystemJS\nget and set Accessors Are Allowed in Ambient Contexts\nAmbient Classes and Functions Can Merge\nAPIs to Support --build and --incremental\nSemicolon-Aware Code Edits\nSmarter Auto-Import Syntax\nNew TypeScript Playground\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nEL\nJB\nJRU\n3+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.221 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 3.8",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html",
    "html": "TypeScript 3.8\nType-Only Imports and Export\n\nThis feature is something most users may never have to think about; however, if you’ve hit issues under isolatedModules, TypeScript’s transpileModule API, or Babel, this feature might be relevant.\n\nTypeScript 3.8 adds a new syntax for type-only imports and exports.\n\nimport type { SomeThing } from \"./some-module.js\";\nexport type { SomeThing };\n\nimport type only imports declarations to be used for type annotations and declarations. It always gets fully erased, so there’s no remnant of it at runtime. Similarly, export type only provides an export that can be used for type contexts, and is also erased from TypeScript’s output.\n\nIt’s important to note that classes have a value at runtime and a type at design-time, and the use is context-sensitive. When using import type to import a class, you can’t do things like extend from it.\n\nimport type { Component } from \"react\";\ninterface ButtonProps {\n  // ...\n}\nclass Button extends Component<ButtonProps> {\n  //               ~~~~~~~~~\n  // error! 'Component' only refers to a type, but is being used as a value here.\n  // ...\n}\n\nIf you’ve used Flow before, the syntax is fairly similar. One difference is that we’ve added a few restrictions to avoid code that might appear ambiguous.\n\n// Is only 'Foo' a type? Or every declaration in the import?\n// We just give an error because it's not clear.\nimport type Foo, { Bar, Baz } from \"some-module\";\n//     ~~~~~~~~~~~~~~~~~~~~~~\n// error! A type-only import can specify a default import or named bindings, but not both.\n\nIn conjunction with import type, TypeScript 3.8 also adds a new compiler flag to control what happens with imports that won’t be utilized at runtime: importsNotUsedAsValues. This flag takes 3 different values:\n\nremove: this is today’s behavior of dropping these imports. It’s going to continue to be the default, and is a non-breaking change.\npreserve: this preserves all imports whose values are never used. This can cause imports/side-effects to be preserved.\nerror: this preserves all imports (the same as the preserve option), but will error when a value import is only used as a type. This might be useful if you want to ensure no values are being accidentally imported, but still make side-effect imports explicit.\n\nFor more information about the feature, you can take a look at the pull request, and relevant changes around broadening where imports from an import type declaration can be used.\n\nECMAScript Private Fields\n\nTypeScript 3.8 brings support for ECMAScript’s private fields, part of the stage-3 class fields proposal.\n\nclass Person {\n  #name: string;\n  constructor(name: string) {\n    this.#name = name;\n  }\n  greet() {\n    console.log(`Hello, my name is ${this.#name}!`);\n  }\n}\nlet jeremy = new Person(\"Jeremy Bearimy\");\njeremy.#name;\n//     ~~~~~\n// Property '#name' is not accessible outside class 'Person'\n// because it has a private identifier.\n\nUnlike regular properties (even ones declared with the private modifier), private fields have a few rules to keep in mind. Some of them are:\n\nPrivate fields start with a # character. Sometimes we call these private names.\nEvery private field name is uniquely scoped to its containing class.\nTypeScript accessibility modifiers like public or private can’t be used on private fields.\nPrivate fields can’t be accessed or even detected outside of the containing class - even by JS users! Sometimes we call this hard privacy.\n\nApart from “hard” privacy, another benefit of private fields is that uniqueness we just mentioned. For example, regular property declarations are prone to being overwritten in subclasses.\n\nclass C {\n  foo = 10;\n  cHelper() {\n    return this.foo;\n  }\n}\nclass D extends C {\n  foo = 20;\n  dHelper() {\n    return this.foo;\n  }\n}\nlet instance = new D();\n// 'this.foo' refers to the same property on each instance.\nconsole.log(instance.cHelper()); // prints '20'\nconsole.log(instance.dHelper()); // prints '20'\n\nWith private fields, you’ll never have to worry about this, since each field name is unique to the containing class.\n\nclass C {\n  #foo = 10;\n  cHelper() {\n    return this.#foo;\n  }\n}\nclass D extends C {\n  #foo = 20;\n  dHelper() {\n    return this.#foo;\n  }\n}\nlet instance = new D();\n// 'this.#foo' refers to a different field within each class.\nconsole.log(instance.cHelper()); // prints '10'\nconsole.log(instance.dHelper()); // prints '20'\n\nAnother thing worth noting is that accessing a private field on any other type will result in a TypeError!\n\nclass Square {\n  #sideLength: number;\n  constructor(sideLength: number) {\n    this.#sideLength = sideLength;\n  }\n  equals(other: any) {\n    return this.#sideLength === other.#sideLength;\n  }\n}\nconst a = new Square(100);\nconst b = { sideLength: 100 };\n// Boom!\n// TypeError: attempted to get private field on non-instance\n// This fails because 'b' is not an instance of 'Square'.\nconsole.log(a.equals(b));\n\nFinally, for any plain .js file users, private fields always have to be declared before they’re assigned to.\n\nclass C {\n  // No declaration for '#foo'\n  // :(\n  constructor(foo: number) {\n    // SyntaxError!\n    // '#foo' needs to be declared before writing to it.\n    this.#foo = foo;\n  }\n}\n\nJavaScript has always allowed users to access undeclared properties, whereas TypeScript has always required declarations for class properties. With private fields, declarations are always needed regardless of whether we’re working in .js or .ts files.\n\nclass C {\n  /** @type {number} */\n  #foo;\n  constructor(foo: number) {\n    // This works.\n    this.#foo = foo;\n  }\n}\n\nFor more information about the implementation, you can check out the original pull request\n\nWhich should I use?\n\nWe’ve already received many questions on which type of privates you should use as a TypeScript user: most commonly, “should I use the private keyword, or ECMAScript’s hash/pound (#) private fields?” It depends!\n\nWhen it comes to properties, TypeScript’s private modifiers are fully erased - that means that at runtime, it acts entirely like a normal property and there’s no way to tell that it was declared with a private modifier. When using the private keyword, privacy is only enforced at compile-time/design-time, and for JavaScript consumers it’s entirely intent-based.\n\nclass C {\n  private foo = 10;\n}\n// This is an error at compile time,\n// but when TypeScript outputs .js files,\n// it'll run fine and print '10'.\nconsole.log(new C().foo); // prints '10'\n//                  ~~~\n// error! Property 'foo' is private and only accessible within class 'C'.\n// TypeScript allows this at compile-time\n// as a \"work-around\" to avoid the error.\nconsole.log(new C()[\"foo\"]); // prints '10'\n\nThe upside is that this sort of “soft privacy” can help your consumers temporarily work around not having access to some API, and also works in any runtime.\n\nOn the other hand, ECMAScript’s # privates are completely inaccessible outside of the class.\n\nclass C {\n  #foo = 10;\n}\nconsole.log(new C().#foo); // SyntaxError\n//                  ~~~~\n// TypeScript reports an error *and*\n// this won't work at runtime!\nconsole.log(new C()[\"#foo\"]); // prints undefined\n//          ~~~~~~~~~~~~~~~\n// TypeScript reports an error under 'noImplicitAny',\n// and this prints 'undefined'.\n\nThis hard privacy is really useful for strictly ensuring that nobody can take use of any of your internals. If you’re a library author, removing or renaming a private field should never cause a breaking change.\n\nAs we mentioned, another benefit is that subclassing can be easier with ECMAScript’s # privates because they really are private. When using ECMAScript # private fields, no subclass ever has to worry about collisions in field naming. When it comes to TypeScript’s private property declarations, users still have to be careful not to trample over properties declared in superclasses.\n\nOne more thing to think about is where you intend for your code to run. TypeScript currently can’t support this feature unless targeting ECMAScript 2015 (ES6) targets or higher. This is because our downleveled implementation uses WeakMaps to enforce privacy, and WeakMaps can’t be polyfilled in a way that doesn’t cause memory leaks. In contrast, TypeScript’s private-declared properties work with all targets - even ECMAScript 3!\n\nA final consideration might be speed: private properties are no different from any other property, so accessing them is as fast as any other property access no matter which runtime you target. In contrast, because # private fields are downleveled using WeakMaps, they may be slower to use. While some runtimes might optimize their actual implementations of # private fields, and even have speedy WeakMap implementations, that might not be the case in all runtimes.\n\nexport * as ns\n Syntax\n\nIt’s often common to have a single entry-point that exposes all the members of another module as a single member.\n\nimport * as utilities from \"./utilities.js\";\nexport { utilities };\n\nThis is so common that ECMAScript 2020 recently added a new syntax to support this pattern!\n\nexport * as utilities from \"./utilities.js\";\n\nThis is a nice quality-of-life improvement to JavaScript, and TypeScript 3.8 implements this syntax. When your module target is earlier than es2020, TypeScript will output something along the lines of the first code snippet.\n\nTop-Level \nawait\n\nTypeScript 3.8 provides support for a handy upcoming ECMAScript feature called “top-level await“.\n\nJavaScript users often introduce an async function in order to use await, and then immediately called the function after defining it.\n\nasync function main() {\n  const response = await fetch(\"...\");\n  const greeting = await response.text();\n  console.log(greeting);\n}\nmain().catch((e) => console.error(e));\n\nThis is because previously in JavaScript (along with most other languages with a similar feature), await was only allowed within the body of an async function. However, with top-level await, we can use await at the top level of a module.\n\nconst response = await fetch(\"...\");\nconst greeting = await response.text();\nconsole.log(greeting);\n// Make sure we're a module\nexport {};\n\nNote there’s a subtlety: top-level await only works at the top level of a module, and files are only considered modules when TypeScript finds an import or an export. In some basic cases, you might need to write out export {} as some boilerplate to make sure of this.\n\nTop level await may not work in all environments where you might expect at this point. Currently, you can only use top level await when the target compiler option is es2017 or above, and module is esnext or system. Support within several environments and bundlers may be limited or may require enabling experimental support.\n\nFor more information on our implementation, you can check out the original pull request.\n\nes2020\n for \ntarget\n and \nmodule\n\nTypeScript 3.8 supports es2020 as an option for module and target. This will preserve newer ECMAScript 2020 features like optional chaining, nullish coalescing, export * as ns, and dynamic import(...) syntax. It also means bigint literals now have a stable target below esnext.\n\nJSDoc Property Modifiers\n\nTypeScript 3.8 supports JavaScript files by turning on the allowJs flag, and also supports type-checking those JavaScript files via the checkJs option or by adding a // @ts-check comment to the top of your .js files.\n\nBecause JavaScript files don’t have dedicated syntax for type-checking, TypeScript leverages JSDoc. TypeScript 3.8 understands a few new JSDoc tags for properties.\n\nFirst are the accessibility modifiers: @public, @private, and @protected. These tags work exactly like public, private, and protected respectively work in TypeScript.\n\n// @ts-check\nclass Foo {\n  constructor() {\n    /** @private */\n    this.stuff = 100;\n  }\n  printStuff() {\n    console.log(this.stuff);\n  }\n}\nnew Foo().stuff;\n//        ~~~~~\n// error! Property 'stuff' is private and only accessible within class 'Foo'.\n@public is always implied and can be left off, but means that a property can be reached from anywhere.\n@private means that a property can only be used within the containing class.\n@protected means that a property can only be used within the containing class, and all derived subclasses, but not on dissimilar instances of the containing class.\n\nNext, we’ve also added the @readonly modifier to ensure that a property is only ever written to during initialization.\n\n// @ts-check\nclass Foo {\n  constructor() {\n    /** @readonly */\n    this.stuff = 100;\n  }\n  writeToStuff() {\n    this.stuff = 200;\n    //   ~~~~~\n    // Cannot assign to 'stuff' because it is a read-only property.\n  }\n}\nnew Foo().stuff++;\n//        ~~~~~\n// Cannot assign to 'stuff' because it is a read-only property.\nBetter Directory Watching on Linux and \nwatchOptions\n\nTypeScript 3.8 ships a new strategy for watching directories, which is crucial for efficiently picking up changes to node_modules.\n\nFor some context, on operating systems like Linux, TypeScript installs directory watchers (as opposed to file watchers) on node_modules and many of its subdirectories to detect changes in dependencies. This is because the number of available file watchers is often eclipsed by the number of files in node_modules, whereas there are way fewer directories to track.\n\nOlder versions of TypeScript would immediately install directory watchers on folders, and at startup that would be fine; however, during an npm install, a lot of activity will take place within node_modules and that can overwhelm TypeScript, often slowing editor sessions to a crawl. To prevent this, TypeScript 3.8 waits slightly before installing directory watchers to give these highly volatile directories some time to stabilize.\n\nBecause every project might work better under different strategies, and this new approach might not work well for your workflows, TypeScript 3.8 introduces a new watchOptions field in tsconfig.json and jsconfig.json which allows users to tell the compiler/language service which watching strategies should be used to keep track of files and directories.\n\n{\n  // Some typical compiler options\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"moduleResolution\": \"node\"\n    // ...\n  },\n  // NEW: Options for file/directory watching\n  \"watchOptions\": {\n    // Use native file system events for files and directories\n    \"watchFile\": \"useFsEvents\",\n    \"watchDirectory\": \"useFsEvents\",\n    // Poll files for updates more frequently\n    // when they're updated a lot.\n    \"fallbackPolling\": \"dynamicPriority\"\n  }\n}\n\nwatchOptions contains 4 new options that can be configured:\n\nwatchFile: the strategy for how individual files are watched. This can be set to\n\nfixedPollingInterval: Check every file for changes several times a second at a fixed interval.\npriorityPollingInterval: Check every file for changes several times a second, but use heuristics to check certain types of files less frequently than others.\ndynamicPriorityPolling: Use a dynamic queue where less-frequently modified files will be checked less often.\nuseFsEvents (the default): Attempt to use the operating system/file system’s native events for file changes.\nuseFsEventsOnParentDirectory: Attempt to use the operating system/file system’s native events to listen for changes on a file’s containing directories. This can use fewer file watchers, but might be less accurate.\n\nwatchDirectory: the strategy for how entire directory trees are watched under systems that lack recursive file-watching functionality. This can be set to:\n\nfixedPollingInterval: Check every directory for changes several times a second at a fixed interval.\ndynamicPriorityPolling: Use a dynamic queue where less-frequently modified directories will be checked less often.\nuseFsEvents (the default): Attempt to use the operating system/file system’s native events for directory changes.\n\nfallbackPolling: when using file system events, this option specifies the polling strategy that gets used when the system runs out of native file watchers and/or doesn’t support native file watchers. This can be set to\n\nfixedPollingInterval: (See above.)\npriorityPollingInterval: (See above.)\ndynamicPriorityPolling: (See above.)\nsynchronousWatchDirectory: Disable deferred watching on directories. Deferred watching is useful when lots of file changes might occur at once (e.g. a change in node_modules from running npm install), but you might want to disable it with this flag for some less-common setups.\n\nFor more information on these changes, head over to GitHub to see the pull request to read more.\n\n“Fast and Loose” Incremental Checking\n\nTypeScript 3.8 introduces a new compiler option called assumeChangesOnlyAffectDirectDependencies. When this option is enabled, TypeScript will avoid rechecking/rebuilding all truly possibly-affected files, and only recheck/rebuild files that have changed as well as files that directly import them.\n\nFor example, consider a file fileD.ts that imports fileC.ts that imports fileB.ts that imports fileA.ts as follows:\n\nfileA.ts <- fileB.ts <- fileC.ts <- fileD.ts\n\nIn --watch mode, a change in fileA.ts would typically mean that TypeScript would need to at least re-check fileB.ts, fileC.ts, and fileD.ts. Under assumeChangesOnlyAffectDirectDependencies, a change in fileA.ts means that only fileA.ts and fileB.ts need to be re-checked.\n\nIn a codebase like Visual Studio Code, this reduced rebuild times for changes in certain files from about 14 seconds to about 1 second. While we don’t necessarily recommend this option for all codebases, you might be interested if you have an extremely large codebase and are willing to defer full project errors until later (e.g. a dedicated build via a tsconfig.fullbuild.json or in CI).\n\nFor more details, you can see the original pull request.\n\nOn this page\nType-Only Imports and Export\nECMAScript Private Fields\nWhich should I use?\nexport * as ns Syntax\nTop-Level await\nes2020 for target and module\nJSDoc Property Modifiers\nBetter Directory Watching on Linux and watchOptions\n“Fast and Loose” Incremental Checking\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nAB\nJB\nMU\n2+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.361 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.5",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-5.html",
    "html": "TypeScript 4.5\nSupporting \nlib\n from \nnode_modules\n\nTo ensure that TypeScript and JavaScript support works well out of the box, TypeScript bundles a series of declaration files (.d.ts files). These declaration files represent the available APIs in the JavaScript language, and the standard browser DOM APIs. While there are some reasonable defaults based on your target, you can pick and choose which declaration files your program uses by configuring the lib setting in the tsconfig.json.\n\nThere are two occasional downsides to including these declaration files with TypeScript though:\n\nWhen you upgrade TypeScript, you’re also forced to handle changes to TypeScript’s built-in declaration files, and this can be a challenge when the DOM APIs change as frequently as they do.\nIt is hard to customize these files to match your needs with the needs of your project’s dependencies (e.g. if your dependencies declare that they use the DOM APIs, you might also be forced into using the DOM APIs).\n\nTypeScript 4.5 introduces a way to override a specific built-in lib in a manner similar to how @types/ support works. When deciding which lib files TypeScript should include, it will first look for a scoped @typescript/lib-* package in node_modules. For example, when including dom as an option in lib, TypeScript will use the types in node_modules/@typescript/lib-dom if available.\n\nYou can then use your package manager to install a specific package to take over for a given lib For example, today TypeScript publishes versions of the DOM APIs on @types/web. If you wanted to lock your project to a specific version of the DOM APIs, you could add this to your package.json:\n\n{\n  \"dependencies\": {\n    \"@typescript/lib-dom\": \"npm:@types/web\"\n  }\n}\n\nThen from 4.5 onwards, you can update TypeScript and your dependency manager’s lockfile will ensure that it uses the exact same version of the DOM types. That means you get to update your types on your own terms.\n\nWe’d like to give a shout-out to saschanaz who has been extremely helpful and patient as we’ve been building out and experimenting with this feature.\n\nFor more information, you can see the implementation of this change.\n\nThe \nAwaited\n Type and \nPromise\n Improvements\n\nTypeScript 4.5 introduces a new utility type called the Awaited type. This type is meant to model operations like await in async functions, or the .then() method on Promises - specifically, the way that they recursively unwrap Promises.\n\n// A = string\ntype A = Awaited<Promise<string>>;\n// B = number\ntype B = Awaited<Promise<Promise<number>>>;\n// C = boolean | number\ntype C = Awaited<boolean | Promise<number>>;\n\nThe Awaited type can be helpful for modeling existing APIs, including JavaScript built-ins like Promise.all, Promise.race, etc. In fact, some of the problems around inference with Promise.all served as motivations for Awaited. Here’s an example that fails in TypeScript 4.4 and earlier.\n\ndeclare function MaybePromise<T>(value: T): T | Promise<T> | PromiseLike<T>;\nasync function doSomething(): Promise<[number, number]> {\n  const result = await Promise.all([MaybePromise(100), MaybePromise(200)]);\n  // Error!\n  //\n  //    [number | Promise<100>, number | Promise<200>]\n  //\n  // is not assignable to type\n  //\n  //    [number, number]\n  return result;\n}\n\nNow Promise.all leverages the combination of certain features with Awaited to give much better inference results, and the above example works.\n\nFor more information, you can read about this change on GitHub.\n\nTemplate String Types as Discriminants\n\nTypeScript 4.5 now can narrow values that have template string types, and also recognizes template string types as discriminants.\n\nAs an example, the following used to fail, but now successfully type-checks in TypeScript 4.5.\n\nexport interface Success {\n    type: `${string}Success`;\n    body: string;\n}\n \nexport interface Error {\n    type: `${string}Error`;\n    message: string\n}\n \nexport function handler(r: Success | Error) {\n    if (r.type === \"HttpSuccess\") {\n        const token = r.body;\n                     \n(parameter) r: Success\n    }\n}\nTry\n\nFor more information, see the change that enables this feature.\n\nmodule es2022\n\nThanks to Kagami S. Rosylight, TypeScript now supports a new module setting: es2022. The main feature in module es2022 is top-level await, meaning you can use await outside of async functions. This was already supported in --module esnext (and now --module nodenext), but es2022 is the first stable target for this feature.\n\nYou can read up more on this change here.\n\nTail-Recursion Elimination on Conditional Types\n\nTypeScript often needs to gracefully fail when it detects possibly infinite recursion, or any type expansions that can take a long time and affect your editor experience. As a result, TypeScript has heuristics to make sure it doesn’t go off the rails when trying to pick apart an infinitely-deep type, or working with types that generate a lot of intermediate results.\n\ntype InfiniteBox<T> = { item: InfiniteBox<T> };\ntype Unpack<T> = T extends { item: infer U } ? Unpack<U> : T;\n// error: Type instantiation is excessively deep and possibly infinite.\ntype Test = Unpack<InfiniteBox<number>>;\n\nThe above example is intentionally simple and useless, but there are plenty of types that are actually useful, and unfortunately trigger our heuristics. As an example, the following TrimLeft type removes spaces from the beginning of a string-like type. If given a string type that has a space at the beginning, it immediately feeds the remainder of the string back into TrimLeft.\n\ntype TrimLeft<T extends string> =\n    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;\n// Test = \"hello\" | \"world\"\ntype Test = TrimLeft<\"   hello\" | \" world\">;\n\nThis type can be useful, but if a string has 50 leading spaces, you’ll get an error.\n\ntype TrimLeft<T extends string> =\n    T extends ` ${infer Rest}` ? TrimLeft<Rest> : T;\n// error: Type instantiation is excessively deep and possibly infinite.\ntype Test = TrimLeft<\"                                                oops\">;\n\nThat’s unfortunate, because these kinds of types tend to be extremely useful in modeling operations on strings - for example, parsers for URL routers. To make matters worse, a more useful type typically creates more type instantiations, and in turn has even more limitations on input length.\n\nBut there’s a saving grace: TrimLeft is written in a way that is tail-recursive in one branch. When it calls itself again, it immediately returns the result and doesn’t do anything with it. Because these types don’t need to create any intermediate results, they can be implemented more quickly and in a way that avoids triggering many of type recursion heuristics that are built into TypeScript.\n\nThat’s why TypeScript 4.5 performs some tail-recursion elimination on conditional types. As long as one branch of a conditional type is simply another conditional type, TypeScript can avoid intermediate instantiations. There are still heuristics to ensure that these types don’t go off the rails, but they are much more generous.\n\nKeep in mind, the following type won’t be optimized, since it uses the result of a conditional type by adding it to a union.\n\ntype GetChars<S> =\n    S extends `${infer Char}${infer Rest}` ? Char | GetChars<Rest> : never;\n\nIf you would like to make it tail-recursive, you can introduce a helper that takes an “accumulator” type parameter, just like with tail-recursive functions.\n\ntype GetChars<S> = GetCharsHelper<S, never>;\ntype GetCharsHelper<S, Acc> =\n    S extends `${infer Char}${infer Rest}` ? GetCharsHelper<Rest, Char | Acc> : Acc;\n\nYou can read up more on the implementation here.\n\nDisabling Import Elision\n\nThere are some cases where TypeScript can’t detect that you’re using an import. For example, take the following code:\n\nimport { Animal } from \"./animal.js\";\neval(\"console.log(new Animal().isDangerous())\");\n\nBy default, TypeScript always removes this import because it appears to be unused. In TypeScript 4.5, you can enable a new flag called preserveValueImports to prevent TypeScript from stripping out any imported values from your JavaScript outputs. Good reasons to use eval are few and far between, but something very similar to this happens in Svelte:\n\n<!-- A .svelte File -->\n<script>\n  import { someFunc } from \"./some-module.js\";\n</script>\n<button on:click=\"{someFunc}\">Click me!</button>\n\nalong with in Vue.js, using its <script setup> feature:\n\n<!-- A .vue File -->\n<script setup>\n  import { someFunc } from \"./some-module.js\";\n</script>\n<button @click=\"someFunc\">Click me!</button>\n\nThese frameworks generate some code based on markup outside of their <script> tags, but TypeScript only sees code within the <script> tags. That means TypeScript will automatically drop the import of someFunc, and the above code won’t be runnable! With TypeScript 4.5, you can use preserveValueImports to avoid these situations.\n\nNote that this flag has a special requirement when combined with —isolatedModules`: imported types must be marked as type-only because compilers that process single files at a time have no way of knowing whether imports are values that appear unused, or a type that must be removed in order to avoid a runtime crash.\n\n// Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,\n// ts-loader, esbuild, etc. don't, so `isolatedModules` gives an error.\nimport { someFunc, BaseType } from \"./some-module.js\";\n//                 ^^^^^^^^\n// Error: 'BaseType' is a type and must be imported using a type-only import\n// when 'preserveValueImports' and 'isolatedModules' are both enabled.\n\nThat makes another TypeScript 4.5 feature, type modifiers on import names, especially important.\n\nFor more information, see the pull request here.\n\ntype\n Modifiers on Import Names\n\nAs mentioned above, preserveValueImports and isolatedModules have special requirements so that there’s no ambiguity for build tools whether it’s safe to drop type imports.\n\n// Which of these is a value that should be preserved? tsc knows, but `ts.transpileModule`,\n// ts-loader, esbuild, etc. don't, so `isolatedModules` issues an error.\nimport { someFunc, BaseType } from \"./some-module.js\";\n//                 ^^^^^^^^\n// Error: 'BaseType' is a type and must be imported using a type-only import\n// when 'preserveValueImports' and 'isolatedModules' are both enabled.\n\nWhen these options are combined, we need a way to signal when an import can be legitimately dropped. TypeScript already has something for this with import type:\n\nimport type { BaseType } from \"./some-module.js\";\nimport { someFunc } from \"./some-module.js\";\nexport class Thing implements BaseType {\n  // ...\n}\n\nThis works, but it would be nice to avoid two import statements for the same module. That’s part of why TypeScript 4.5 allows a type modifier on individual named imports, so that you can mix and match as needed.\n\nimport { someFunc, type BaseType } from \"./some-module.js\";\nexport class Thing implements BaseType {\n    someMethod() {\n        someFunc();\n    }\n}\n\nIn the above example, BaseType is always guaranteed to be erased and someFunc will be preserved under preserveValueImports, leaving us with the following code:\n\nimport { someFunc } from \"./some-module.js\";\nexport class Thing {\n  someMethod() {\n    someFunc();\n  }\n}\n\nFor more information, see the changes on GitHub.\n\nPrivate Field Presence Checks\n\nTypeScript 4.5 supports an ECMAScript proposal for checking whether an object has a private field on it. You can now write a class with a #private field member and see whether another object has the same field by using the in operator.\n\nclass Person {\n    #name: string;\n    constructor(name: string) {\n        this.#name = name;\n    }\n    equals(other: unknown) {\n        return other &&\n            typeof other === \"object\" &&\n            #name in other && // <- this is new!\n            this.#name === other.#name;\n    }\n}\n\nOne interesting aspect of this feature is that the check #name in other implies that other must have been constructed as a Person, since there’s no other way that field could be present. This is actually one of the key features of the proposal, and it’s why the proposal is named “ergonomic brand checks” - because private fields often act as a “brand” to guard against objects that aren’t instances of their class. As such, TypeScript is able to appropriately narrow the type of other on each check, until it ends up with the type Person.\n\nWe’d like to extend a big thanks to our friends at Bloomberg who contributed this pull request: Ashley Claymore, Titian Cernicova-Dragomir, Kubilay Kahveci, and Rob Palmer!\n\nImport Assertions\n\nTypeScript 4.5 supports an ECMAScript proposal for import assertions. This is a syntax used by runtimes to make sure that an import has an expected format.\n\nimport obj from \"./something.json\" assert { type: \"json\" };\n\nThe contents of these assertions are not checked by TypeScript since they’re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error).\n\n// TypeScript is fine with this.\n// But your browser? Probably not.\nimport obj from \"./something.json\" assert {\n    type: \"fluffy bunny\"\n};\n\nDynamic import() calls can also use import assertions through a second argument.\n\nconst obj = await import(\"./something.json\", {\n  assert: { type: \"json\" },\n});\n\nThe expected type of that second argument is defined by a new type called ImportCallOptions, and currently only accepts an assert property.\n\nWe’d like to thank Wenlu Wang for implementing this feature!\n\nConst Assertions and Default Type Arguments in JSDoc\n\nTypeScript 4.5 brings some extra expressivity to our JSDoc support.\n\nOne example of this is with const assertions. In TypeScript, you can get a more precise and immutable type by writing as const after a literal.\n\n// type is { prop: string }\nlet a = { prop: \"hello\" };\n// type is { readonly prop: \"hello\" }\nlet b = { prop: \"hello\" } as const;\n\nIn JavaScript files, you can now use JSDoc type assertions to achieve the same thing.\n\n// type is { prop: string }\nlet a = { prop: \"hello\" };\n// type is { readonly prop: \"hello\" }\nlet b = /** @type {const} */ ({ prop: \"hello\" });\n\nAs a reminder, JSDoc type assertions comments start with /** @type {TheTypeWeWant} */ and are followed by a parenthesized expression:\n\n/** @type {TheTypeWeWant} */` (someExpression)\n\nTypeScript 4.5 also adds default type arguments to JSDoc, which means the following type declaration in TypeScript:\n\ntype Foo<T extends string | number = number> = { prop: T };\n\ncan be rewritten as the following @typedef declaration in JavaScript:\n\n/**\n * @template {string | number} [T=number]\n * @typedef Foo\n * @property prop {T}\n */\n// or\n/**\n * @template {string | number} [T=number]\n * @typedef {{ prop: T }} Foo\n */\n\nFor more information, see the pull request for const assertions along with the changes for type argument defaults.\n\nFaster Load Time with \nrealPathSync.native\n\nTypeScript now leverages a system-native implementation of the Node.js realPathSync function on all operating systems.\n\nPreviously this function was only used on Linux, but in TypeScript 4.5 it has been adopted to operating systems that are typically case-insensitive, like Windows and MacOS. On certain codebases, this change sped up project loading by 5-13% (depending on the host operating system).\n\nFor more information, see the original change here, along with the 4.5-specific changes here.\n\nSnippet Completions for JSX Attributes\n\nTypeScript 4.5 brings snippet completions for JSX attributes. When writing out an attribute in a JSX tag, TypeScript will already provide suggestions for those attributes; but with snippet completions, they can remove a little bit of extra typing by adding an initializer and putting your cursor in the right place.\n\nTypeScript will typically use the type of an attribute to figure out what kind of initializer to insert, but you can customize this behavior in Visual Studio Code.\n\nKeep in mind, this feature will only work in newer versions of Visual Studio Code, so you might have to use an Insiders build to get this working. For more information, read up on the original pull request\n\nBetter Editor Support for Unresolved Types\n\nIn some cases, editors will leverage a lightweight “partial” semantic mode - either while the editor is waiting for the full project to load, or in contexts like GitHub’s web-based editor.\n\nIn older versions of TypeScript, if the language service couldn’t find a type, it would just print any.\n\nIn the above example, Buffer wasn’t found, so TypeScript replaced it with any in quick info. In TypeScript 4.5, TypeScript will try its best to preserve what you wrote.\n\nHowever, if you hover over Buffer itself, you’ll get a hint that TypeScript couldn’t find Buffer.\n\nAltogether, this provides a smoother experience when TypeScript doesn’t have the full program available. Keep in mind, you’ll always get an error in regular scenarios to tell you when a type isn’t found.\n\nFor more information, see the implementation here.\n\nBreaking Changes\nlib.d.ts Changes\n\nTypeScript 4.5 contains changes to its built-in declaration files which may affect your compilation; however, these changes were fairly minimal, and we expect most code will be unaffected.\n\nInference Changes from Awaited\n\nBecause Awaited is now used in lib.d.ts and as a result of await, you may see certain generic types change that might cause incompatibilities; however, given many intentional design decisions around Awaited to avoid breakage, we expect most code will be unaffected.\n\nCompiler Options Checking at the Root of tsconfig.json\n\nIt’s an easy mistake to accidentally forget about the compilerOptions section in a tsconfig.json. To help catch this mistake, in TypeScript 4.5, it is an error to add a top-level field which matches any of the available options in compilerOptions without having also defined compilerOptions in that tsconfig.json.\n\nOn this page\nSupporting lib from node_modules\nThe Awaited Type and Promise Improvements\nTemplate String Types as Discriminants\nmodule es2022\nTail-Recursion Elimination on Conditional Types\nDisabling Import Elision\ntype Modifiers on Import Names\nPrivate Field Presence Checks\nImport Assertions\nConst Assertions and Default Type Arguments in JSDoc\nFaster Load Time with realPathSync.native\nSnippet Completions for JSX Attributes\nBetter Editor Support for Unresolved Types\nBreaking Changes\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nR\nN\nHG\nAB\n3+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.53 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.2",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html",
    "html": "TypeScript 4.2\nSmarter Type Alias Preservation\n\nTypeScript has a way to declare new names for types called type aliases. If you’re writing a set of functions that all work on string | number | boolean, you can write a type alias to avoid repeating yourself over and over again.\n\ntype BasicPrimitive = number | string | boolean;\n\nTypeScript has always used a set of rules and guesses for when to reuse type aliases when printing out types. For example, take the following code snippet.\n\nexport type BasicPrimitive = number | string | boolean;\nexport function doStuff(value: BasicPrimitive) {\n  let x = value;\n  return x;\n}\n\nIf we hover our mouse over x in an editor like Visual Studio, Visual Studio Code, or the TypeScript Playground, we’ll get a quick info panel that shows the type BasicPrimitive. Likewise, if we get the declaration file output (.d.ts output) for this file, TypeScript will say that doStuff returns BasicPrimitive.\n\nHowever, what happens if we return a BasicPrimitive or undefined?\n\nexport type BasicPrimitive = number | string | boolean;\nexport function doStuff(value: BasicPrimitive) {\n  if (Math.random() < 0.5) {\n    return undefined;\n  }\n  return value;\n}\n\nWe can see what happens in the TypeScript 4.1 playground. While we might want TypeScript to display the return type of doStuff as BasicPrimitive | undefined, it instead displays string | number | boolean | undefined! What gives?\n\nWell this has to do with how TypeScript represents types internally. When creating a union type out of one or more union types, it will always normalize those types into a new flattened union type - but doing that loses information. The type-checker would have to find every combination of types from string | number | boolean | undefined to see what type aliases could have been used, and even then, there might be multiple type aliases to string | number | boolean.\n\nIn TypeScript 4.2, our internals are a little smarter. We keep track of how types were constructed by keeping around parts of how they were originally written and constructed over time. We also keep track of, and differentiate, type aliases to instances of other aliases!\n\nBeing able to print back the types based on how you used them in your code means that as a TypeScript user, you can avoid some unfortunately humongous types getting displayed, and that often translates to getting better .d.ts file output, error messages, and in-editor type displays in quick info and signature help. This can help TypeScript feel a little bit more approachable for newcomers.\n\nFor more information, check out the first pull request that improves various cases around preserving union type aliases, along with a second pull request that preserves indirect aliases.\n\nLeading/Middle Rest Elements in Tuple Types\n\nIn TypeScript, tuple types are meant to model arrays with specific lengths and element types.\n\n// A tuple that stores a pair of numbers\nlet a: [number, number] = [1, 2];\n// A tuple that stores a string, a number, and a boolean\nlet b: [string, number, boolean] = [\"hello\", 42, true];\n\nOver time, TypeScript’s tuple types have become more and more sophisticated, since they’re also used to model things like parameter lists in JavaScript. As a result, they can have optional elements and rest elements, and can even have labels for tooling and readability.\n\n// A tuple that has either one or two strings.\nlet c: [string, string?] = [\"hello\"];\nc = [\"hello\", \"world\"];\n \n// A labeled tuple that has either one or two strings.\nlet d: [first: string, second?: string] = [\"hello\"];\nd = [\"hello\", \"world\"];\n \n// A tuple with a *rest element* - holds at least 2 strings at the front,\n// and any number of booleans at the back.\nlet e: [string, string, ...boolean[]];\n \ne = [\"hello\", \"world\"];\ne = [\"hello\", \"world\", false];\ne = [\"hello\", \"world\", true, false, true];\nTry\n\nIn TypeScript 4.2, rest elements specifically been expanded in how they can be used. In prior versions, TypeScript only allowed ...rest elements at the very last position of a tuple type.\n\nHowever, now rest elements can occur anywhere within a tuple - with only a few restrictions.\n\nlet foo: [...string[], number];\n \nfoo = [123];\nfoo = [\"hello\", 123];\nfoo = [\"hello!\", \"hello!\", \"hello!\", 123];\n \nlet bar: [boolean, ...string[], boolean];\n \nbar = [true, false];\nbar = [true, \"some text\", false];\nbar = [true, \"some\", \"separated\", \"text\", false];\nTry\n\nThe only restriction is that a rest element can be placed anywhere in a tuple, so long as it’s not followed by another optional element or rest element. In other words, only one rest element per tuple, and no optional elements after rest elements.\n\ninterface Clown {\n  /*...*/\n}\ninterface Joker {\n  /*...*/\n}\n \nlet StealersWheel: [...Clown[], \"me\", ...Joker[]];\nA rest element cannot follow another rest element.\nA rest element cannot follow another rest element.\n \nlet StringsAndMaybeBoolean: [...string[], boolean?];\nAn optional element cannot follow a rest element.\nAn optional element cannot follow a rest element.\nTry\n\nThese non-trailing rest elements can be used to model functions that take any number of leading arguments, followed by a few fixed ones.\n\ndeclare function doStuff(...args: [...names: string[], shouldCapitalize: boolean]): void;\n \ndoStuff(/*shouldCapitalize:*/ false)\ndoStuff(\"fee\", \"fi\", \"fo\", \"fum\", /*shouldCapitalize:*/ true);\nTry\n\nEven though JavaScript doesn’t have any syntax to model leading rest parameters, we were still able to declare doStuff as a function that takes leading arguments by declaring the ...args rest parameter with a tuple type that uses a leading rest element. This can help model lots of existing JavaScript out there!\n\nFor more details, see the original pull request.\n\nStricter Checks For The \nin\n Operator\n\nIn JavaScript, it is a runtime error to use a non-object type on the right side of the in operator. TypeScript 4.2 ensures this can be caught at design-time.\n\n\"foo\" in 42;\nType 'number' is not assignable to type 'object'.\nType 'number' is not assignable to type 'object'.\nTry\n\nThis check is fairly conservative for the most part, so if you have received an error about this, it is likely an issue in the code.\n\nA big thanks to our external contributor Jonas Hübotter for their pull request!\n\n--noPropertyAccessFromIndexSignature\n\nBack when TypeScript first introduced index signatures, you could only get properties declared by them with “bracketed” element access syntax like person[\"name\"].\n\ninterface SomeType {\n  /** This is an index signature. */\n  [propName: string]: any;\n}\n \nfunction doStuff(value: SomeType) {\n  let x = value[\"someProperty\"];\n}\nTry\n\nThis ended up being cumbersome in situations where we need to work with objects that have arbitrary properties. For example, imagine an API where it’s common to misspell a property name by adding an extra s character at the end.\n\ninterface Options {\n  /** File patterns to be excluded. */\n  exclude?: string[];\n \n  /**\n   * It handles any extra properties that we haven't declared as type 'any'.\n   */\n  [x: string]: any;\n}\n \nfunction processOptions(opts: Options) {\n  // Notice we're *intentionally* accessing `excludes`, not `exclude`\n  if (opts.excludes) {\n    console.error(\n      \"The option `excludes` is not valid. Did you mean `exclude`?\"\n    );\n  }\n}\nTry\n\nTo make these types of situations easier, a while back, TypeScript made it possible to use “dotted” property access syntax like person.name when a type had a string index signature. This also made it easier to transition existing JavaScript code over to TypeScript.\n\nHowever, loosening the restriction also meant that misspelling an explicitly declared property became much easier.\n\nfunction processOptions(opts: Options) {\n  // ...\n \n  // Notice we're *accidentally* accessing `excludes` this time.\n  // Oops! Totally valid.\n  for (const excludePattern of opts.excludes) {\n    // ...\n  }\n}\nTry\n\nIn some cases, users would prefer to explicitly opt into the index signature - they would prefer to get an error message when a dotted property access doesn’t correspond to a specific property declaration.\n\nThat’s why TypeScript introduces a new flag called noPropertyAccessFromIndexSignature. Under this mode, you’ll be opted in to TypeScript’s older behavior that issues an error. This new setting is not under the strict family of flags, since we believe users will find it more useful on certain codebases than others.\n\nYou can understand this feature in more detail by reading up on the corresponding pull request. We’d also like to extend a big thanks to Wenlu Wang who sent us this pull request!\n\nabstract\n Construct Signatures\n\nTypeScript allows us to mark a class as abstract. This tells TypeScript that the class is only meant to be extended from, and that certain members need to be filled in by any subclass to actually create an instance.\n\nabstract class Shape {\n  abstract getArea(): number;\n}\n \nnew Shape();\nCannot create an instance of an abstract class.\nCannot create an instance of an abstract class.\n \nclass Square extends Shape {\n  #sideLength: number;\n \n  constructor(sideLength: number) {\n    super();\n    this.#sideLength = sideLength;\n  }\n \n  getArea() {\n    return this.#sideLength ** 2;\n  }\n}\n \n// Works fine.\nnew Square(42);\nTry\n\nTo make sure this restriction in new-ing up abstract classes is consistently applied, you can’t assign an abstract class to anything that expects a construct signature.\n\ninterface HasArea {\n  getArea(): number;\n}\n \nlet Ctor: new () => HasArea = Shape;\nType 'typeof Shape' is not assignable to type 'new () => HasArea'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.\nType 'typeof Shape' is not assignable to type 'new () => HasArea'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.\nTry\n\nThis does the right thing in case we intend to run code like new Ctor, but it’s overly-restrictive in case we want to write a subclass of Ctor.\n\nabstract class Shape {\n  abstract getArea(): number;\n}\n \ninterface HasArea {\n  getArea(): number;\n}\n \nfunction makeSubclassWithArea(Ctor: new () => HasArea) {\n  return class extends Ctor {\n    getArea() {\n      return 42\n    }\n  };\n}\n \nlet MyShape = makeSubclassWithArea(Shape);\nArgument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.\nArgument of type 'typeof Shape' is not assignable to parameter of type 'new () => HasArea'.\n  Cannot assign an abstract constructor type to a non-abstract constructor type.\nTry\n\nIt also doesn’t work well with built-in helper types like InstanceType.\n\ntype MyInstance = InstanceType<typeof Shape>;\nTry\n\nThat’s why TypeScript 4.2 allows you to specify an abstract modifier on constructor signatures.\n\ninterface HasArea {\n    getArea(): number;\n}\n \n// Works!\nlet Ctor: abstract new () => HasArea = Shape;\nTry\n\nAdding the abstract modifier to a construct signature signals that you can pass in abstract constructors. It doesn’t stop you from passing in other classes/constructor functions that are “concrete” - it really just signals that there’s no intent to run the constructor directly, so it’s safe to pass in either class type.\n\nThis feature allows us to write mixin factories in a way that supports abstract classes. For example, in the following code snippet, we’re able to use the mixin function withStyles with the abstract class SuperClass.\n\nabstract class SuperClass {\n    abstract someMethod(): void;\n    badda() {}\n}\n \ntype AbstractConstructor<T> = abstract new (...args: any[]) => T\n \nfunction withStyles<T extends AbstractConstructor<object>>(Ctor: T) {\n    abstract class StyledClass extends Ctor {\n        getStyles() {\n            // ...\n        }\n    }\n    return StyledClass;\n}\n \nclass SubClass extends withStyles(SuperClass) {\n    someMethod() {\n        this.someMethod()\n    }\n}\nTry\n\nNote that withStyles is demonstrating a specific rule, where a class (like StyledClass) that extends a value that’s generic and bounded by an abstract constructor (like Ctor) has to also be declared abstract. This is because there’s no way to know if a class with more abstract members was passed in, and so it’s impossible to know whether the subclass implements all the abstract members.\n\nYou can read up more on abstract construct signatures on its pull request.\n\nUnderstanding Your Project Structure With \n--explainFiles\n\nA surprisingly common scenario for TypeScript users is to ask “why is TypeScript including this file?“. Inferring the files of your program turns out to be a complicated process, and so there are lots of reasons why a specific combination of lib.d.ts got used, why certain files in node_modules are getting included, and why certain files are being included even though we thought specifying exclude would keep them out.\n\nThat’s why TypeScript now provides an explainFiles flag.\n\ntsc --explainFiles\n\nWhen using this option, the TypeScript compiler will give some very verbose output about why a file ended up in your program. To read it more easily, you can forward the output to a file, or pipe it to a program that can easily view it.\n\n# Forward output to a text file\ntsc --explainFiles > explanation.txt\n# Pipe output to a utility program like `less`, or an editor like VS Code\ntsc --explainFiles | less\ntsc --explainFiles | code -\n\nTypically, the output will start out by listing out reasons for including lib.d.ts files, then for local files, and then node_modules files.\n\nTS_Compiler_Directory/4.2.2/lib/lib.es5.d.ts\n  Library referenced via 'es5' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2015.d.ts\n  Library referenced via 'es2015' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2016.d.ts\n  Library referenced via 'es2016' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2017.d.ts\n  Library referenced via 'es2017' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2018.d.ts\n  Library referenced via 'es2018' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2019.d.ts\n  Library referenced via 'es2019' from file 'TS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.es2020.d.ts\n  Library referenced via 'es2020' from file 'TS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts'\nTS_Compiler_Directory/4.2.2/lib/lib.esnext.d.ts\n  Library 'lib.esnext.d.ts' specified in compilerOptions\n\n... More Library References...\n\nfoo.ts\n  Matched by include pattern '**/*' in 'tsconfig.json'\n\nRight now, we make no guarantees about the output format - it might change over time. On that note, we’re interested in improving this format if you have any suggestions!\n\nFor more information, check out the original pull request!\n\nImproved Uncalled Function Checks in Logical Expressions\n\nThanks to further improvements from Alex Tarasyuk, TypeScript’s uncalled function checks now apply within && and || expressions.\n\nUnder strictNullChecks, the following code will now error.\n\nfunction shouldDisplayElement(element: Element) {\n  // ...\n  return true;\n}\nfunction getVisibleItems(elements: Element[]) {\n  return elements.filter((e) => shouldDisplayElement && e.children.length);\n  //                          ~~~~~~~~~~~~~~~~~~~~\n  // This condition will always return true since the function is always defined.\n  // Did you mean to call it instead.\n}\n\nFor more details, check out the pull request here.\n\nDestructured Variables Can Be Explicitly Marked as Unused\n\nThanks to another pull request from Alex Tarasyuk, you can now mark destructured variables as unused by prefixing them with an underscore (the _ character).\n\nlet [_first, second] = getValues();\n\nPreviously, if _first was never used later on, TypeScript would issue an error under noUnusedLocals. Now, TypeScript will recognize that _first was intentionally named with an underscore because there was no intent to use it.\n\nFor more details, take a look at the full change.\n\nRelaxed Rules Between Optional Properties and String Index Signatures\n\nString index signatures are a way of typing dictionary-like objects, where you want to allow access with arbitrary keys:\n\nconst movieWatchCount: { [key: string]: number } = {};\n \nfunction watchMovie(title: string) {\n  movieWatchCount[title] = (movieWatchCount[title] ?? 0) + 1;\n}\nTry\n\nOf course, for any movie title not yet in the dictionary, movieWatchCount[title] will be undefined (TypeScript 4.1 added the option noUncheckedIndexedAccess to include undefined when reading from an index signature like this). Even though it’s clear that there must be some strings not present in movieWatchCount, previous versions of TypeScript treated optional object properties as unassignable to otherwise compatible index signatures, due to the presence of undefined.\n\ntype WesAndersonWatchCount = {\n  \"Fantastic Mr. Fox\"?: number;\n  \"The Royal Tenenbaums\"?: number;\n  \"Moonrise Kingdom\"?: number;\n  \"The Grand Budapest Hotel\"?: number;\n};\n \ndeclare const wesAndersonWatchCount: WesAndersonWatchCount;\nconst movieWatchCount: { [key: string]: number } = wesAndersonWatchCount;\n//    ~~~~~~~~~~~~~~~ error!\n// Type 'WesAndersonWatchCount' is not assignable to type '{ [key: string]: number; }'.\n//    Property '\"Fantastic Mr. Fox\"' is incompatible with index signature.\n//      Type 'number | undefined' is not assignable to type 'number'.\n//        Type 'undefined' is not assignable to type 'number'. (2322)\nTry\n\nTypeScript 4.2 allows this assignment. However, it does not allow the assignment of non-optional properties with undefined in their types, nor does it allow writing undefined to a specific key:\n\ntype BatmanWatchCount = {\n  \"Batman Begins\": number | undefined;\n  \"The Dark Knight\": number | undefined;\n  \"The Dark Knight Rises\": number | undefined;\n};\n \ndeclare const batmanWatchCount: BatmanWatchCount;\n \n// Still an error in TypeScript 4.2.\nconst movieWatchCount: { [key: string]: number } = batmanWatchCount;\nType 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.\n  Property '\"Batman Begins\"' is incompatible with index signature.\n    Type 'number | undefined' is not assignable to type 'number'.\n      Type 'undefined' is not assignable to type 'number'.\nType 'BatmanWatchCount' is not assignable to type '{ [key: string]: number; }'.\n  Property '\"Batman Begins\"' is incompatible with index signature.\n    Type 'number | undefined' is not assignable to type 'number'.\n      Type 'undefined' is not assignable to type 'number'.\n \n// Still an error in TypeScript 4.2.\n// Index signatures don't implicitly allow explicit `undefined`.\nmovieWatchCount[\"It's the Great Pumpkin, Charlie Brown\"] = undefined;\nType 'undefined' is not assignable to type 'number'.\nType 'undefined' is not assignable to type 'number'.\nTry\n\nThe new rule also does not apply to number index signatures, since they are assumed to be array-like and dense:\n\ndeclare let sortOfArrayish: { [key: number]: string };\ndeclare let numberKeys: { 42?: string };\n \nsortOfArrayish = numberKeys;\nType '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.\n  Property '42' is incompatible with index signature.\n    Type 'string | undefined' is not assignable to type 'string'.\n      Type 'undefined' is not assignable to type 'string'.\nType '{ 42?: string | undefined; }' is not assignable to type '{ [key: number]: string; }'.\n  Property '42' is incompatible with index signature.\n    Type 'string | undefined' is not assignable to type 'string'.\n      Type 'undefined' is not assignable to type 'string'.\nTry\n\nYou can get a better sense of this change by reading up on the original PR.\n\nDeclare Missing Helper Function\n\nThanks to a community pull request from Alexander Tarasyuk, we now have a quick fix for declaring new functions and methods based on the call-site!\n\nBreaking Changes\n\nWe always strive to minimize breaking changes in a release. TypeScript 4.2 contains some breaking changes, but we believe they should be manageable in an upgrade.\n\nlib.d.ts\n Updates\n\nAs with every TypeScript version, declarations for lib.d.ts (especially the declarations generated for web contexts), have changed. There are various changes, though Intl and ResizeObserver’s may end up being the most disruptive.\n\nnoImplicitAny\n Errors Apply to Loose \nyield\n Expressions\n\nWhen the value of a yield expression is captured, but TypeScript can’t immediately figure out what type you intend for it to receive (i.e. the yield expression isn’t contextually typed), TypeScript will now issue an implicit any error.\n\nfunction* g1() {\n  const value = yield 1;\n'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.\n'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.\n}\n \nfunction* g2() {\n  // No error.\n  // The result of `yield 1` is unused.\n  yield 1;\n}\n \nfunction* g3() {\n  // No error.\n  // `yield 1` is contextually typed by 'string'.\n  const value: string = yield 1;\n}\n \nfunction* g4(): Generator<number, void, string> {\n  // No error.\n  // TypeScript can figure out the type of `yield 1`\n  // from the explicit return type of `g4`.\n  const value = yield 1;\n}\nTry\n\nSee more details in the corresponding changes.\n\nExpanded Uncalled Function Checks\n\nAs described above, uncalled function checks will now operate consistently within && and || expressions when using strictNullChecks. This can be a source of new breaks, but is typically an indication of a logic error in existing code.\n\nType Arguments in JavaScript Are Not Parsed as Type Arguments\n\nType arguments were already not allowed in JavaScript, but in TypeScript 4.2, the parser will parse them in a more spec-compliant way. So when writing the following code in a JavaScript file:\n\nf<T>(100);\n\nTypeScript will parse it as the following JavaScript:\n\nf < T > 100;\n\nThis may impact you if you were leveraging TypeScript’s API to parse type constructs in JavaScript files, which may have occurred when trying to parse Flow files.\n\nSee the pull request for more details on what’s checked.\n\nTuple size limits for spreads\n\nTuple types can be made by using any sort of spread syntax (...) in TypeScript.\n\n// Tuple types with spread elements\ntype NumStr = [number, string];\ntype NumStrNumStr = [...NumStr, ...NumStr];\n// Array spread expressions\nconst numStr = [123, \"hello\"] as const;\nconst numStrNumStr = [...numStr, ...numStr] as const;\n\nSometimes these tuple types can accidentally grow to be huge, and that can make type-checking take a long time. Instead of letting the type-checking process hang (which is especially bad in editor scenarios), TypeScript has a limiter in place to avoid doing all that work.\n\nYou can see this pull request for more details.\n\n.d.ts\n Extensions Cannot Be Used In Import Paths\n\nIn TypeScript 4.2, it is now an error for your import paths to contain .d.ts in the extension.\n\n// must be changed to something like\n//   - \"./foo\"\n//   - \"./foo.js\"\nimport { Foo } from \"./foo.d.ts\";\n\nInstead, your import paths should reflect whatever your loader will do at runtime. Any of the following imports might be usable instead.\n\nimport { Foo } from \"./foo\";\nimport { Foo } from \"./foo.js\";\nimport { Foo } from \"./foo/index.js\";\nReverting Template Literal Inference\n\nThis change removed a feature from TypeScript 4.2 beta. If you haven’t yet upgraded past our last stable release, you won’t be affected, but you may still be interested in the change.\n\nThe beta version of TypeScript 4.2 included a change in inference to template strings. In this change, template string literals would either be given template string types or simplify to multiple string literal types. These types would then widen to string when assigning to mutable variables.\n\ndeclare const yourName: string;\n// 'bar' is constant.\n// It has type '`hello ${string}`'.\nconst bar = `hello ${yourName}`;\n// 'baz' is mutable.\n// It has type 'string'.\nlet baz = `hello ${yourName}`;\n\nThis is similar to how string literal inference works.\n\n// 'bar' has type '\"hello\"'.\nconst bar = \"hello\";\n// 'baz' has type 'string'.\nlet baz = \"hello\";\n\nFor that reason, we believed that making template string expressions have template string types would be “consistent”; however, from what we’ve seen and heard, that isn’t always desirable.\n\nIn response, we’ve reverted this feature (and potential breaking change). If you do want a template string expression to be given a literal-like type, you can always add as const to the end of it.\n\ndeclare const yourName: string;\n// 'bar' has type '`hello ${string}`'.\nconst bar = `hello ${yourName}` as const;\n//                              ^^^^^^^^\n// 'baz' has type 'string'.\nconst baz = `hello ${yourName}`;\nTypeScript’s \nlift\n Callback in \nvisitNode\n Uses a Different Type\n\nTypeScript has a visitNode function that takes a lift function. lift now expects a readonly Node[] instead of a NodeArray<Node>. This is technically an API breaking change which you can read more on here.\n\nOn this page\nSmarter Type Alias Preservation\nLeading/Middle Rest Elements in Tuple Types\nStricter Checks For The in Operator\n--noPropertyAccessFromIndexSignature\nabstract Construct Signatures\nUnderstanding Your Project Structure With --explainFiles\nImproved Uncalled Function Checks in Logical Expressions\nDestructured Variables Can Be Explicitly Marked as Unused\nRelaxed Rules Between Optional Properties and String Index Signatures\nDeclare Missing Helper Function\nBreaking Changes\nlib.d.ts Updates\nnoImplicitAny Errors Apply to Loose yield Expressions\nExpanded Uncalled Function Checks\nType Arguments in JavaScript Are Not Parsed as Type Arguments\nTuple size limits for spreads\n.d.ts Extensions Cannot Be Used In Import Paths\nReverting Template Literal Inference\nTypeScript’s lift Callback in visitNode Uses a Different Type\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nEL\nAG\nAB\nJB\nGG\n3+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.715 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.1",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-1.html",
    "html": "TypeScript 4.1\nTemplate Literal Types\n\nString literal types in TypeScript allow us to model functions and APIs that expect a set of specific strings.\n\nfunction setVerticalAlignment(location: \"top\" | \"middle\" | \"bottom\") {\n  // ...\n}\n \nsetVerticalAlignment(\"middel\");\nArgument of type '\"middel\"' is not assignable to parameter of type '\"top\" | \"middle\" | \"bottom\"'.\nArgument of type '\"middel\"' is not assignable to parameter of type '\"top\" | \"middle\" | \"bottom\"'.\nTry\n\nThis is pretty nice because string literal types can basically spell-check our string values.\n\nWe also like that string literals can be used as property names in mapped types. In this sense, they’re also usable as building blocks:\n\ntype Options = {\n  [K in \"noImplicitAny\" | \"strictNullChecks\" | \"strictFunctionTypes\"]?: boolean;\n};\n// same as\n//   type Options = {\n//       noImplicitAny?: boolean,\n//       strictNullChecks?: boolean,\n//       strictFunctionTypes?: boolean\n//   };\n\nBut there’s another place that that string literal types could be used as building blocks: building other string literal types.\n\nThat’s why TypeScript 4.1 brings the template literal string type. It has the same syntax as template literal strings in JavaScript, but is used in type positions. When you use it with concrete literal types, it produces a new string literal type by concatenating the contents.\n\ntype World = \"world\";\n \ntype Greeting = `hello ${World}`;\n        \ntype Greeting = \"hello world\"\nTry\n\nWhat happens when you have unions in substitution positions? It produces the set of every possible string literal that could be represented by each union member.\n\ntype Color = \"red\" | \"blue\";\ntype Quantity = \"one\" | \"two\";\n \ntype SeussFish = `${Quantity | Color} fish`;\ntype SeussFish = \"one fish\" | \"two fish\" | \"red fish\" | \"blue fish\"\nTry\n\nThis can be used beyond cute examples in release notes. For example, several libraries for UI components have a way to specify both vertical and horizontal alignment in their APIs, often with both at once using a single string like \"bottom-right\". Between vertically aligning with \"top\", \"middle\", and \"bottom\", and horizontally aligning with \"left\", \"center\", and \"right\", there are 9 possible strings where each of the former strings is connected with each of the latter strings using a dash.\n\ntype VerticalAlignment = \"top\" | \"middle\" | \"bottom\";\ntype HorizontalAlignment = \"left\" | \"center\" | \"right\";\n \n// Takes\n//   | \"top-left\"    | \"top-center\"    | \"top-right\"\n//   | \"middle-left\" | \"middle-center\" | \"middle-right\"\n//   | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"\n \ndeclare function setAlignment(value: `${VerticalAlignment}-${HorizontalAlignment}`): void;\n \nsetAlignment(\"top-left\");   // works!\nsetAlignment(\"top-middel\"); // error!\nArgument of type '\"top-middel\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.\nArgument of type '\"top-middel\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.\nsetAlignment(\"top-pot\");    // error! but good doughnuts if you're ever in Seattle\nArgument of type '\"top-pot\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.\nArgument of type '\"top-pot\"' is not assignable to parameter of type '\"top-left\" | \"top-center\" | \"top-right\" | \"middle-left\" | \"middle-center\" | \"middle-right\" | \"bottom-left\" | \"bottom-center\" | \"bottom-right\"'.\nTry\n\nWhile there are lots of examples of this sort of API in the wild, this is still a bit of a toy example since we could write these out manually. In fact, for 9 strings, this is likely fine; but when you need a ton of strings, you should consider automatically generating them ahead of time to save work on every type-check (or just use string, which will be much simpler to comprehend).\n\nSome of the real value comes from dynamically creating new string literals. For example, imagine a makeWatchedObject API that takes an object and produces a mostly identical object, but with a new on method to detect for changes to the properties.\n\nlet person = makeWatchedObject({\n  firstName: \"Homer\",\n  age: 42, // give-or-take\n  location: \"Springfield\",\n});\nperson.on(\"firstNameChanged\", () => {\n  console.log(`firstName was changed!`);\n});\n\nNotice that on listens on the event \"firstNameChanged\", not just \"firstName\". How would we type this?\n\ntype PropEventSource<T> = {\n    on(eventName: `${string & keyof T}Changed`, callback: () => void): void;\n};\n/// Create a \"watched object\" with an 'on' method\n/// so that you can watch for changes to properties.\ndeclare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;\n\nWith this, we can build something that errors when we give the wrong property!\n\n// error!\nperson.on(\"firstName\", () => {});\nArgument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.\nArgument of type '\"firstName\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.\n \n// error!\nperson.on(\"frstNameChanged\", () => {});\nArgument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.\nArgument of type '\"frstNameChanged\"' is not assignable to parameter of type '\"firstNameChanged\" | \"ageChanged\" | \"locationChanged\"'.\nTry\n\nWe can also do something special in template literal types: we can infer from substitution positions. We can make our last example generic to infer from parts of the eventName string to figure out the associated property.\n\ntype PropEventSource<T> = {\n    on<K extends string & keyof T>\n        (eventName: `${K}Changed`, callback: (newValue: T[K]) => void ): void;\n};\n \ndeclare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;\n \nlet person = makeWatchedObject({\n    firstName: \"Homer\",\n    age: 42,\n    location: \"Springfield\",\n});\n \n// works! 'newName' is typed as 'string'\nperson.on(\"firstNameChanged\", newName => {\n    // 'newName' has the type of 'firstName'\n    console.log(`new name is ${newName.toUpperCase()}`);\n});\n \n// works! 'newAge' is typed as 'number'\nperson.on(\"ageChanged\", newAge => {\n    if (newAge < 0) {\n        console.log(\"warning! negative age\");\n    }\n})\nTry\n\nHere we made on into a generic method. When a user calls with the string \"firstNameChanged', TypeScript will try to infer the right type for K. To do that, it will match K against the content prior to \"Changed\" and infer the string \"firstName\". Once TypeScript figures that out, the on method can fetch the type of firstName on the original object, which is string in this case. Similarly, when we call with \"ageChanged\", it finds the type for the property age which is number).\n\nInference can be combined in different ways, often to deconstruct strings, and reconstruct them in different ways. In fact, to help with modifying these string literal types, we’ve added a few new utility type aliases for modifying casing in letters (i.e. converting to lowercase and uppercase characters).\n\ntype EnthusiasticGreeting<T extends string> = `${Uppercase<T>}`\n \ntype HELLO = EnthusiasticGreeting<\"hello\">;\n      \ntype HELLO = \"HELLO\"\nTry\n\nThe new type aliases are Uppercase, Lowercase, Capitalize and Uncapitalize. The first two transform every character in a string, and the latter two transform only the first character in a string.\n\nFor more details, see the original pull request and the in-progress pull request to switch to type alias helpers.\n\nKey Remapping in Mapped Types\n\nJust as a refresher, a mapped type can create new object types based on arbitrary keys\n\ntype Options = {\n  [K in \"noImplicitAny\" | \"strictNullChecks\" | \"strictFunctionTypes\"]?: boolean;\n};\n// same as\n//   type Options = {\n//       noImplicitAny?: boolean,\n//       strictNullChecks?: boolean,\n//       strictFunctionTypes?: boolean\n//   };\n\nor new object types based on other object types.\n\n/// 'Partial<T>' is the same as 'T', but with each property marked optional.\ntype Partial<T> = {\n  [K in keyof T]?: T[K];\n};\n\nUntil now, mapped types could only produce new object types with keys that you provided them; however, lots of the time you want to be able to create new keys, or filter out keys, based on the inputs.\n\nThat’s why TypeScript 4.1 allows you to re-map keys in mapped types with a new as clause.\n\ntype MappedTypeWithNewKeys<T> = {\n    [K in keyof T as NewKeyType]: T[K]\n    //            ^^^^^^^^^^^^^\n    //            This is the new syntax!\n}\n\nWith this new as clause, you can leverage features like template literal types to easily create property names based off of old ones.\n\ntype Getters<T> = {\n    [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]\n};\n \ninterface Person {\n    name: string;\n    age: number;\n    location: string;\n}\n \ntype LazyPerson = Getters<Person>;\n         \ntype LazyPerson = {\n    getName: () => string;\n    getAge: () => number;\n    getLocation: () => string;\n}\nTry\n\nand you can even filter out keys by producing never. That means you don’t have to use an extra Omit helper type in some cases.\n\n// Remove the 'kind' property\ntype RemoveKindField<T> = {\n    [K in keyof T as Exclude<K, \"kind\">]: T[K]\n};\n \ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n \ntype KindlessCircle = RemoveKindField<Circle>;\n           \ntype KindlessCircle = {\n    radius: number;\n}\nTry\n\nFor more information, take a look at the original pull request over on GitHub.\n\nRecursive Conditional Types\n\nIn JavaScript it’s fairly common to see functions that can flatten and build up container types at arbitrary levels. For example, consider the .then() method on instances of Promise. .then(...) unwraps each promise until it finds a value that’s not “promise-like”, and passes that value to a callback. There’s also a relatively new flat method on Arrays that can take a depth of how deep to flatten.\n\nExpressing this in TypeScript’s type system was, for all practical intents and purposes, not possible. While there were hacks to achieve this, the types ended up looking very unreasonable.\n\nThat’s why TypeScript 4.1 eases some restrictions on conditional types - so that they can model these patterns. In TypeScript 4.1, conditional types can now immediately reference themselves within their branches, making it easier to write recursive type aliases.\n\nFor example, if we wanted to write a type to get the element types of nested arrays, we could write the following deepFlatten type.\n\ntype ElementType<T> = T extends ReadonlyArray<infer U> ? ElementType<U> : T;\nfunction deepFlatten<T extends readonly unknown[]>(x: T): ElementType<T>[] {\n  throw \"not implemented\";\n}\n// All of these return the type 'number[]':\ndeepFlatten([1, 2, 3]);\ndeepFlatten([[1], [2, 3]]);\ndeepFlatten([[1], [[2]], [[[3]]]]);\n\nSimilarly, in TypeScript 4.1 we can write an Awaited type to deeply unwrap Promises.\n\ntype Awaited<T> = T extends PromiseLike<infer U> ? Awaited<U> : T;\n/// Like `promise.then(...)`, but more accurate in types.\ndeclare function customThen<T, U>(\n  p: Promise<T>,\n  onFulfilled: (value: Awaited<T>) => U\n): Promise<Awaited<U>>;\n\nKeep in mind that while these recursive types are powerful, but they should be used responsibly and sparingly.\n\nFirst off, these types can do a lot of work which means that they can increase type-checking time. Trying to model numbers in the Collatz conjecture or Fibonacci sequence might be fun, but don’t ship that in .d.ts files on npm.\n\nBut apart from being computationally intensive, these types can hit an internal recursion depth limit on sufficiently-complex inputs. When that recursion limit is hit, that results in a compile-time error. In general, it’s better not to use these types at all than to write something that fails on more realistic examples.\n\nSee more at the implementation.\n\nChecked Indexed Accesses (\n--noUncheckedIndexedAccess\n)\n\nTypeScript has a feature called index signatures. These signatures are a way to signal to the type system that users can access arbitrarily-named properties.\n\ninterface Options {\n  path: string;\n  permissions: number;\n \n  // Extra properties are caught by this index signature.\n  [propName: string]: string | number;\n}\n \nfunction checkOptions(opts: Options) {\n  opts.path; // string\n  opts.permissions; // number\n \n  // These are all allowed too!\n  // They have the type 'string | number'.\n  opts.yadda.toString();\n  opts[\"foo bar baz\"].toString();\n  opts[Math.random()].toString();\n}\nTry\n\nIn the above example, Options has an index signature that says any accessed property that’s not already listed should have the type string | number. This is often convenient for optimistic code that assumes you know what you’re doing, but the truth is that most values in JavaScript do not support every potential property name. Most types will not, for example, have a value for a property key created by Math.random() like in the previous example. For many users, this behavior was undesirable, and felt like it wasn’t leveraging the full strict-checking of strictNullChecks.\n\nThat’s why TypeScript 4.1 ships with a new flag called noUncheckedIndexedAccess. Under this new mode, every property access (like foo.bar) or indexed access (like foo[\"bar\"]) is considered potentially undefined. That means that in our last example, opts.yadda will have the type string | number | undefined as opposed to just string | number. If you need to access that property, you’ll either have to check for its existence first or use a non-null assertion operator (the postfix ! character).\n\nfunction checkOptions(opts: Options) {\n  opts.path; // string\n  opts.permissions; // number\n \n  // These are not allowed with noUncheckedIndexedAccess\n  opts.yadda.toString();\n'opts.yadda' is possibly 'undefined'.\n'opts.yadda' is possibly 'undefined'.\n  opts[\"foo bar baz\"].toString();\nObject is possibly 'undefined'.\nObject is possibly 'undefined'.\n  opts[Math.random()].toString();\nObject is possibly 'undefined'.\nObject is possibly 'undefined'.\n \n  // Checking if it's really there first.\n  if (opts.yadda) {\n    console.log(opts.yadda.toString());\n  }\n \n  // Basically saying \"trust me I know what I'm doing\"\n  // with the '!' non-null assertion operator.\n  opts.yadda!.toString();\n}\nTry\n\nOne consequence of using noUncheckedIndexedAccess is that indexing into an array is also more strictly checked, even in a bounds-checked loop.\n\nfunction screamLines(strs: string[]) {\n  // This will have issues\n  for (let i = 0; i < strs.length; i++) {\n    console.log(strs[i].toUpperCase());\nObject is possibly 'undefined'.\nObject is possibly 'undefined'.\n  }\n}\nTry\n\nIf you don’t need the indexes, you can iterate over individual elements by using a for-of loop or a forEach call.\n\nfunction screamLines(strs: string[]) {\n  // This works fine\n  for (const str of strs) {\n    console.log(str.toUpperCase());\n  }\n \n  // This works fine\n  strs.forEach((str) => {\n    console.log(str.toUpperCase());\n  });\n}\nTry\n\nThis flag can be handy for catching out-of-bounds errors, but it might be noisy for a lot of code, so it is not automatically enabled by the strict flag; however, if this feature is interesting to you, you should feel free to try it and determine whether it makes sense for your team’s codebase!\n\nYou can learn more at the implementing pull request.\n\npaths\n without \nbaseUrl\n\nUsing path-mapping is fairly common - often it’s to have nicer imports, often it’s to simulate monorepo linking behavior.\n\nUnfortunately, specifying paths to enable path-mapping required also specifying an option called baseUrl, which allows bare specifier paths to be reached relative to the baseUrl too. This also often caused poor paths to be used by auto-imports.\n\nIn TypeScript 4.1, the paths option can be used without baseUrl. This helps avoid some of these issues.\n\ncheckJs\n Implies \nallowJs\n\nPreviously if you were starting a checked JavaScript project, you had to set both allowJs and checkJs. This was a slightly annoying bit of friction in the experience, so checkJs now implies allowJs by default.\n\nSee more details at the pull request.\n\nReact 17 JSX Factories\n\nTypeScript 4.1 supports React 17’s upcoming jsx and jsxs factory functions through two new options for the jsx compiler option:\n\nreact-jsx\nreact-jsxdev\n\nThese options are intended for production and development compiles respectively. Often, the options from one can extend from the other. For example, a tsconfig.json for production builds might look like the following:\n\n// ./src/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"module\": \"esnext\",\n    \"target\": \"es2015\",\n    \"jsx\": \"react-jsx\",\n    \"strict\": true\n  },\n  \"include\": [\"./**/*\"]\n}\n\nand one for development builds might look like the following:\n\n// ./src/tsconfig.dev.json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"jsx\": \"react-jsxdev\"\n  }\n}\n\nFor more information, check out the corresponding PR.\n\nEditor Support for the JSDoc \n@see\n Tag\n\nThe JSDoc tag @see tag now has better support in editors for TypeScript and JavaScript. This allows you to use functionality like go-to-definition in a dotted name following the tag. For example, going to definition on first or C in the JSDoc comment just works in the following example:\n\n// @filename: first.ts\nexport class C {}\n// @filename: main.ts\nimport * as first from \"./first\";\n/**\n * @see first.C\n */\nfunction related() {}\n\nThanks to frequent contributor Wenlu Wang for implementing this!\n\nBreaking Changes\nlib.d.ts\n Changes\n\nlib.d.ts may have a set of changed APIs, potentially in part due to how the DOM types are automatically generated. One specific change is that Reflect.enumerate has been removed, as it was removed from ES2016.\n\nabstract\n Members Can’t Be Marked \nasync\n\nMembers marked as abstract can no longer be marked as async. The fix here is to remove the async keyword, since callers are only concerned with the return type.\n\nany\n/\nunknown\n Are Propagated in Falsy Positions\n\nPreviously, for an expression like foo && somethingElse, the type of foo was any or unknown, the type of the whole that expression would be the type of somethingElse.\n\nFor example, previously the type for x here was { someProp: string }.\n\ndeclare let foo: unknown;\ndeclare let somethingElse: { someProp: string };\nlet x = foo && somethingElse;\n\nHowever, in TypeScript 4.1, we are more careful about how we determine this type. Since nothing is known about the type on the left side of the &&, we propagate any and unknown outward instead of the type on the right side.\n\nThe most common pattern we saw of this tended to be when checking compatibility with booleans, especially in predicate functions.\n\nfunction isThing(x: any): boolean {\n  return x && typeof x === \"object\" && x.blah === \"foo\";\n}\n\nOften the appropriate fix is to switch from foo && someExpression to !!foo && someExpression.\n\nresolve\n’s Parameters Are No Longer Optional in \nPromise\ns\n\nWhen writing code like the following\n\nnew Promise((resolve) => {\n  doSomethingAsync(() => {\n    doSomething();\n    resolve();\n  });\n});\n\nYou may get an error like the following:\n\n  resolve()\n  ~~~~~~~~~\nerror TS2554: Expected 1 arguments, but got 0.\n  An argument for 'value' was not provided.\n\nThis is because resolve no longer has an optional parameter, so by default, it must now be passed a value. Often this catches legitimate bugs with using Promises. The typical fix is to pass it the correct argument, and sometimes to add an explicit type argument.\n\nnew Promise<number>((resolve) => {\n  //     ^^^^^^^^\n  doSomethingAsync((value) => {\n    doSomething();\n    resolve(value);\n    //      ^^^^^\n  });\n});\n\nHowever, sometimes resolve() really does need to be called without an argument. In these cases, we can give Promise an explicit void generic type argument (i.e. write it out as Promise<void>). This leverages new functionality in TypeScript 4.1 where a potentially-void trailing parameter can become optional.\n\nnew Promise<void>((resolve) => {\n  //     ^^^^^^\n  doSomethingAsync(() => {\n    doSomething();\n    resolve();\n  });\n});\n\nTypeScript 4.1 ships with a quick fix to help fix this break.\n\nConditional Spreads Create Optional Properties\n\nIn JavaScript, object spreads (like { ...foo }) don’t operate over falsy values. So in code like { ...foo }, foo will be skipped over if it’s null or undefined.\n\nMany users take advantage of this to spread in properties “conditionally”.\n\ninterface Person {\n  name: string;\n  age: number;\n  location: string;\n}\ninterface Animal {\n  name: string;\n  owner: Person;\n}\nfunction copyOwner(pet?: Animal) {\n  return {\n    ...(pet && pet.owner),\n    otherStuff: 123,\n  };\n}\n// We could also use optional chaining here:\nfunction copyOwner(pet?: Animal) {\n  return {\n    ...pet?.owner,\n    otherStuff: 123,\n  };\n}\n\nHere, if pet is defined, the properties of pet.owner will be spread in - otherwise, no properties will be spread into the returned object.\n\nThe return type of copyOwner was previously a union type based on each spread:\n\n{ x: number } | { x: number, name: string, age: number, location: string }\n\nThis modeled exactly how the operation would occur: if pet was defined, all the properties from Person would be present; otherwise, none of them would be defined on the result. It was an all-or-nothing operation.\n\nHowever, we’ve seen this pattern taken to the extreme, with hundreds of spreads in a single object, each spread potentially adding in hundreds or thousands of properties. It turns out that for various reasons, this ends up being extremely expensive, and usually for not much benefit.\n\nIn TypeScript 4.1, the returned type sometimes uses all-optional properties.\n\n{\n    x: number;\n    name?: string;\n    age?: number;\n    location?: string;\n}\n\nThis ends up performing better and generally displaying better too.\n\nFor more details, see the original change. While this behavior is not entirely consistent right now, we expect a future release will produce cleaner and more predictable results.\n\nUnmatched parameters are no longer related\n\nTypeScript would previously relate parameters that didn’t correspond to each other by relating them to the type any. With changes in TypeScript 4.1, the language now skips this process entirely. This means that some cases of assignability will now fail, but it also means that some cases of overload resolution can fail as well. For example, overload resolution on util.promisify in Node.js may select a different overload in TypeScript 4.1, sometimes causing new or different errors downstream.\n\nAs a workaround, you may be best using a type assertion to squelch errors.\n\nOn this page\nTemplate Literal Types\nKey Remapping in Mapped Types\nRecursive Conditional Types\nChecked Indexed Accesses (--noUncheckedIndexedAccess)\npaths without baseUrl\ncheckJs Implies allowJs\nReact 17 JSX Factories\nEditor Support for the JSDoc @see Tag\nBreaking Changes\nlib.d.ts Changes\nabstract Members Can’t Be Marked async\nany/unknown Are Propagated in Falsy Positions\nresolve’s Parameters Are No Longer Optional in Promises\nConditional Spreads Create Optional Properties\nUnmatched parameters are no longer related\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\nJB\nH\nOT\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.154 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.4",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html",
    "html": "TypeScript 4.4\nControl Flow Analysis of Aliased Conditions and Discriminants\n\nIn JavaScript, we often have to probe a value in different ways, and do something different once we know more about its type. TypeScript understands these checks and calls them type guards. Instead of having to convince TypeScript of a variable’s type whenever we use it, the type-checker leverages something called control flow analysis to see if we’ve used a type guard before a given piece of code.\n\nFor example, we can write something like\n\nfunction foo(arg: unknown) {\n  if (typeof arg === \"string\") {\n    console.log(arg.toUpperCase());\n                \n(parameter) arg: string\n  }\n}\nTry\n\nIn this example, we checked whether arg was a string. TypeScript recognized the typeof arg === \"string\" check, which it considered a type guard, and knew that arg was a string inside the body of the if block. That let us access string methods like toUpperCase() without getting an error.\n\nHowever, what would happen if we moved the condition out to a constant called argIsString?\n\n// In TS 4.3 and below\nfunction foo(arg: unknown) {\n  const argIsString = typeof arg === \"string\";\n  if (argIsString) {\n    console.log(arg.toUpperCase());\n    //              ~~~~~~~~~~~\n    // Error! Property 'toUpperCase' does not exist on type 'unknown'.\n  }\n}\n\nIn previous versions of TypeScript, this would be an error - even though argIsString was assigned the value of a type guard, TypeScript simply lost that information. That’s unfortunate since we might want to re-use the same check in several places. To get around that, users often have to repeat themselves or use type assertions (a.k.a. casts).\n\nIn TypeScript 4.4, that is no longer the case. The above example works with no errors! When TypeScript sees that we are testing a constant value, it will do a little bit of extra work to see if it contains a type guard. If that type guard operates on a const, a readonly property, or an un-modified parameter, then TypeScript is able to narrow that value appropriately.\n\nDifferent sorts of type guard conditions are preserved - not just typeof checks. For example, checks on discriminated unions work like a charm.\n\ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; sideLength: number };\n \nfunction area(shape: Shape): number {\n  const isCircle = shape.kind === \"circle\";\n  if (isCircle) {\n    // We know we have a circle here!\n    return Math.PI * shape.radius ** 2;\n  } else {\n    // We know we're left with a square here!\n    return shape.sideLength ** 2;\n  }\n}\nTry\n\nAnalysis on discriminants in 4.4 also goes a little bit deeper - we can now extract out discriminants and TypeScript can narrow the original object.\n\ntype Shape =\n  | { kind: \"circle\"; radius: number }\n  | { kind: \"square\"; sideLength: number };\n \nfunction area(shape: Shape): number {\n  // Extract out the 'kind' field first.\n  const { kind } = shape;\n \n  if (kind === \"circle\") {\n    // We know we have a circle here!\n    return Math.PI * shape.radius ** 2;\n  } else {\n    // We know we're left with a square here!\n    return shape.sideLength ** 2;\n  }\n}\nTry\n\nAs another example, here’s a function that checks whether two of its inputs have contents.\n\nfunction doSomeChecks(\n  inputA: string | undefined,\n  inputB: string | undefined,\n  shouldDoExtraWork: boolean\n) {\n  const mustDoWork = inputA && inputB && shouldDoExtraWork;\n  if (mustDoWork) {\n    // We can access 'string' properties on both 'inputA' and 'inputB'!\n    const upperA = inputA.toUpperCase();\n    const upperB = inputB.toUpperCase();\n    // ...\n  }\n}\nTry\n\nTypeScript can understand that both inputA and inputB are both present if mustDoWork is true. That means we don’t have to write a non-null assertion like inputA! to convince TypeScript that inputA isn’t undefined.\n\nOne neat feature here is that this analysis works transitively. TypeScript will hop through constants to understand what sorts of checks you’ve already performed.\n\nfunction f(x: string | number | boolean) {\n  const isString = typeof x === \"string\";\n  const isNumber = typeof x === \"number\";\n  const isStringOrNumber = isString || isNumber;\n  if (isStringOrNumber) {\n    x;\n   \n(parameter) x: string | number\n  } else {\n    x;\n   \n(parameter) x: boolean\n  }\n}\nTry\n\nNote that there’s a cutoff - TypeScript doesn’t go arbitrarily deep when checking these conditions, but its analysis is deep enough for most checks.\n\nThis feature should make a lot of intuitive JavaScript code “just work” in TypeScript without it getting in your way. For more details, check out the implementation on GitHub!\n\nSymbol and Template String Pattern Index Signatures\n\nTypeScript lets us describe objects where every property has to have a certain type using index signatures. This allows us to use these objects as dictionary-like types, where we can use string keys to index into them with square brackets.\n\nFor example, we can write a type with an index signature that takes string keys and maps to boolean values. If we try to assign anything other than a boolean value, we’ll get an error.\n\ninterface BooleanDictionary {\n  [key: string]: boolean;\n}\n \ndeclare let myDict: BooleanDictionary;\n \n// Valid to assign boolean values\nmyDict[\"foo\"] = true;\nmyDict[\"bar\"] = false;\n \n// Error, \"oops\" isn't a boolean\nmyDict[\"baz\"] = \"oops\";\nType 'string' is not assignable to type 'boolean'.\nType 'string' is not assignable to type 'boolean'.\nTry\n\nWhile a Map might be a better data structure here (specifically, a Map<string, boolean>), JavaScript objects are often more convenient to use or just happen to be what we’re given to work with.\n\nSimilarly, Array<T> already defines a number index signature that lets us insert/retrieve values of type T.\n\n// @errors: 2322 2375\n// This is part of TypeScript's definition of the built-in Array type.\ninterface Array<T> {\n  [index: number]: T;\n  // ...\n}\nlet arr = new Array<string>();\n// Valid\narr[0] = \"hello!\";\n// Error, expecting a 'string' value here\narr[1] = 123;\n\nIndex signatures are very useful to express lots of code out in the wild; however, until now they’ve been limited to string and number keys (and string index signatures have an intentional quirk where they can accept number keys since they’ll be coerced to strings anyway). That means that TypeScript didn’t allow indexing objects with symbol keys. TypeScript also couldn’t model an index signature of some subset of string keys - for example, an index signature which describes just properties whose names start with the text data-.\n\nTypeScript 4.4 addresses these limitations, and allows index signatures for symbols and template string patterns.\n\nFor example, TypeScript now allows us to declare a type that can be keyed on arbitrary symbols.\n\ninterface Colors {\n  [sym: symbol]: number;\n}\n \nconst red = Symbol(\"red\");\nconst green = Symbol(\"green\");\nconst blue = Symbol(\"blue\");\n \nlet colors: Colors = {};\n \n// Assignment of a number is allowed\ncolors[red] = 255;\nlet redVal = colors[red];\n      \nlet redVal: number\n \ncolors[blue] = \"da ba dee\";\nType 'string' is not assignable to type 'number'.\nType 'string' is not assignable to type 'number'.\nTry\n\nSimilarly, we can write an index signature with template string pattern type. One use of this might be to exempt properties starting with data- from TypeScript’s excess property checking. When we pass an object literal to something with an expected type, TypeScript will look for excess properties that weren’t declared in the expected type.\n\n// @errors: 2322 2375\ninterface Options {\n    width?: number;\n    height?: number;\n}\nlet a: Options = {\n    width: 100,\n    height: 100,\n    \"data-blah\": true,\n};\ninterface OptionsWithDataProps extends Options {\n    // Permit any property starting with 'data-'.\n    [optName: `data-${string}`]: unknown;\n}\nlet b: OptionsWithDataProps = {\n    width: 100,\n    height: 100,\n    \"data-blah\": true,\n    // Fails for a property which is not known, nor\n    // starts with 'data-'\n    \"unknown-property\": true,\n};\n\nA final note on index signatures is that they now permit union types, as long as they’re a union of infinite-domain primitive types - specifically:\n\nstring\nnumber\nsymbol\ntemplate string patterns (e.g. `hello-${string}`)\n\nAn index signature whose argument is a union of these types will de-sugar into several different index signatures.\n\ninterface Data {\n  [optName: string | symbol]: any;\n}\n// Equivalent to\ninterface Data {\n  [optName: string]: any;\n  [optName: symbol]: any;\n}\n\nFor more details, read up on the pull request\n\nDefaulting to the \nunknown\n Type in Catch Variables (\n--useUnknownInCatchVariables\n)\n\nIn JavaScript, any type of value can be thrown with throw and caught in a catch clause. Because of this, TypeScript historically typed catch clause variables as any, and would not allow any other type annotation:\n\ntry {\n  // Who knows what this might throw...\n  executeSomeThirdPartyCode();\n} catch (err) {\n  // err: any\n  console.error(err.message); // Allowed, because 'any'\n  err.thisWillProbablyFail(); // Allowed, because 'any' :(\n}\n\nOnce TypeScript added the unknown type, it became clear that unknown was a better choice than any in catch clause variables for users who want the highest degree of correctness and type-safety, since it narrows better and forces us to test against arbitrary values. Eventually TypeScript 4.0 allowed users to specify an explicit type annotation of unknown (or any) on each catch clause variable so that we could opt into stricter types on a case-by-case basis; however, for some, manually specifying : unknown on every catch clause was a chore.\n\nThat’s why TypeScript 4.4 introduces a new flag called useUnknownInCatchVariables. This flag changes the default type of catch clause variables from any to unknown.\n\ntry {\n  executeSomeThirdPartyCode();\n} catch (err) {\n  // err: unknown\n \n  // Error! Property 'message' does not exist on type 'unknown'.\n  console.error(err.message);\n'err' is of type 'unknown'.\n'err' is of type 'unknown'.\n \n  // Works! We can narrow 'err' from 'unknown' to 'Error'.\n  if (err instanceof Error) {\n    console.error(err.message);\n  }\n}\nTry\n\nThis flag is enabled under the strict family of options. That means that if you check your code using strict, this option will automatically be turned on. You may end up with errors in TypeScript 4.4 such as\n\nProperty 'message' does not exist on type 'unknown'.\nProperty 'name' does not exist on type 'unknown'.\nProperty 'stack' does not exist on type 'unknown'.\n\nIn cases where we don’t want to deal with an unknown variable in a catch clause, we can always add an explicit : any annotation so that we can opt out of stricter types.\n\ntry {\n  executeSomeThirdPartyCode();\n} catch (err: any) {\n  console.error(err.message); // Works again!\n}\nTry\n\nFor more information, take a look at the implementing pull request.\n\nExact Optional Property Types (\n--exactOptionalPropertyTypes\n)\n\nIn JavaScript, reading a missing property on an object produces the value undefined. It’s also possible to have an actual property with the value undefined. A lot of code in JavaScript tends to treat these situations the same way, and so initially TypeScript just interpreted every optional property as if a user had written undefined in the type. For example,\n\ninterface Person {\n  name: string;\n  age?: number;\n}\n\nwas considered equivalent to\n\ninterface Person {\n  name: string;\n  age?: number | undefined;\n}\n\nWhat this meant is that a user could explicitly write undefined in place of age.\n\nconst p: Person = {\n  name: \"Daniel\",\n  age: undefined, // This is okay by default.\n};\n\nSo by default, TypeScript doesn’t distinguish between a present property with the value undefined and a missing property. While this works most of the time, not all code in JavaScript makes the same assumptions. Functions and operators like Object.assign, Object.keys, object spread ({ ...obj }), and for-in loops behave differently depending on whether or not a property actually exists on an object. In the case of our Person example, this could potentially lead to runtime errors if the age property was observed in a context where its presence was important.\n\nIn TypeScript 4.4, the new flag exactOptionalPropertyTypes specifies that optional property types should be interpreted exactly as written, meaning that | undefined is not added to the type:\n\n// With 'exactOptionalPropertyTypes' on:\nconst p: Person = {\nType '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.\n  Types of property 'age' are incompatible.\n    Type 'undefined' is not assignable to type 'number'.\nType '{ name: string; age: undefined; }' is not assignable to type 'Person' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.\n  Types of property 'age' are incompatible.\n    Type 'undefined' is not assignable to type 'number'.\n  name: \"Daniel\",\n  age: undefined, // Error! undefined isn't a number\n};\nTry\n\nThis flag is not part of the strict family and needs to be turned on explicitly if you’d like this behavior. It also requires strictNullChecks to be enabled as well. We’ve been making updates to DefinitelyTyped and other definitions to try to make the transition as straightforward as possible, but you may encounter some friction with this depending on how your code is structured.\n\nFor more information, you can take a look at the implementing pull request here.\n\nstatic\n Blocks in Classes\n\nTypeScript 4.4 brings support for static blocks in classes, an upcoming ECMAScript feature that can help you write more-complex initialization code for static members.\n\nclass Foo {\n    static count = 0;\n \n    // This is a static block:\n    static {\n        if (someCondition()) {\n            Foo.count++;\n        }\n    }\n}\nTry\n\nThese static blocks allow you to write a sequence of statements with their own scope that can access private fields within the containing class. That means that we can write initialization code with all the capabilities of writing statements, no leakage of variables, and full access to our class’s internals.\n\nclass Foo {\n    static #count = 0;\n \n    get count() {\n        return Foo.#count;\n    }\n \n    static {\n        try {\n            const lastInstances = loadLastInstances();\n            Foo.#count += lastInstances.length;\n        }\n        catch {}\n    }\n}\nTry\n\nWithout static blocks, writing the code above was possible, but often involved several different types of hacks that had to compromise in some way.\n\nNote that a class can have multiple static blocks, and they’re run in the same order in which they’re written.\n\n// Prints:\n//    1\n//    2\n//    3\nclass Foo {\n    static prop = 1\n    static {\n        console.log(Foo.prop++);\n    }\n    static {\n        console.log(Foo.prop++);\n    }\n    static {\n        console.log(Foo.prop++);\n    }\n}\nTry\n\nWe’d like to extend our thanks to Wenlu Wang for TypeScript’s implementation of this feature. For more details, you can see that pull request here.\n\ntsc --help\n Updates and Improvements\n\nTypeScript’s --help option has gotten a refresh! Thanks to work in part by Song Gao, we’ve brought in changes to update the descriptions of our compiler options and restyle the --help menu with colors and other visual separation.\n\nYou can read more on the original proposal thread.\n\nPerformance Improvements\nFaster Declaration Emit\n\nTypeScript now caches whether internal symbols are accessible in different contexts, along with how specific types should be printed. These changes can improve TypeScript’s general performance in code with fairly complex types, and is especially observed when emitting .d.ts files under the declaration flag.\n\nSee more details here.\n\nFaster Path Normalization\n\nTypeScript often has to do several types of “normalization” on file paths to get them into a consistent format that the compiler can use everywhere. This involves things like replacing backslashes with slashes, or removing intermediate /./ and /../ segments of paths. When TypeScript has to operate over millions of these paths, these operations end up being a bit slow. In TypeScript 4.4, paths first undergo quick checks to see whether they need any normalization in the first place. These improvements together reduce project load time by 5-10% on bigger projects, and significantly more in massive projects that we’ve tested internally.\n\nFor more details, you can view the PR for path segment normalization along with the PR for slash normalization.\n\nFaster Path Mapping\n\nTypeScript now caches the way it constructs path-mappings (using the paths option in tsconfig.json). For projects with several hundred mappings, the reduction is significant. You can see more on the change itself.\n\nFaster Incremental Builds with \n--strict\n\nIn what was effectively a bug, TypeScript would end up redoing type-checking work under incremental compilations if strict was on. This led to many builds being just as slow as if incremental was turned off. TypeScript 4.4 fixes this, though the change has also been back-ported to TypeScript 4.3.\n\nSee more here.\n\nFaster Source Map Generation for Big Outputs\n\nTypeScript 4.4 adds an optimization for source map generation on extremely large output files. When building an older version of the TypeScript compiler, this results in around an 8% reduction in emit time.\n\nWe’d like to extend our thanks to David Michon who provided a simple and clean change to enable this performance win.\n\nFaster \n--force\n Builds\n\nWhen using --build mode on project references, TypeScript has to perform up-to-date checks to determine which files need to be rebuilt. When performing a --force build, however, that information is irrelevant since every project dependency will be rebuilt from scratch. In TypeScript 4.4, --force builds avoid those unnecessary steps and start a full build. See more about the change here.\n\nSpelling Suggestions for JavaScript\n\nTypeScript powers the JavaScript editing experience in editors like Visual Studio and Visual Studio Code. Most of the time, TypeScript tries to stay out of the way in JavaScript files; however, TypeScript often has a lot of information to make confident suggestions, and ways of surfacing suggestions that aren’t too invasive.\n\nThat’s why TypeScript now issues spelling suggestions in plain JavaScript files - ones without // @ts-check or in a project with checkJs turned off. These are the same “Did you mean…?” suggestions that TypeScript files already have, and now they’re available in all JavaScript files in some form.\n\nThese spelling suggestions can provide a subtle clue that your code is wrong. We managed to find a few bugs in existing code while testing this feature!\n\nFor more details on this new feature, take a look at the pull request!\n\nInlay Hints\n\nTypeScript 4.4 provides support for inlay hints which can help display useful information like parameter names and return types in your code. You can think of it as a sort of friendly “ghost text”.\n\nThis feature was built by Wenlu Wang whose pull request has more details.\n\nWenlu also contributed the integration for inlay hints in Visual Studio Code which has shipped as part of the July 2021 (1.59) release. If you’d like to try inlay hints out, make sure you’re using a recent stable or insiders version of the editor. You can also modify when and where inlay hints get displayed in Visual Studio Code’s settings.\n\nAuto-Imports Show True Paths in Completion Lists\n\nWhen editors like Visual Studio Code show a completion list, completions which include auto-imports are displayed with a path to the given module; however, this path usually isn’t what TypeScript ends up placing in a module specifier. The path is usually something relative to the workspace, meaning that if you’re importing from a package like moment, you’ll often see a path like node_modules/moment.\n\nThese paths end up being unwieldy and often misleading, especially given that the path that actually gets inserted into your file needs to consider Node’s node_modules resolution, path mappings, symlinks, and re-exports.\n\nThat’s why with TypeScript 4.4, the completion item label now shows the actual module path that will be used for the import!\n\nSince this calculation can be expensive, completion lists containing many auto-imports may fill in the final module specifiers in batches as you type more characters. It’s possible that you’ll still sometimes see the old workspace-relative path labels; however, as your editing experience “warms up”, they should get replaced with the actual path after another keystroke or two.\n\nBreaking Changes\nlib.d.ts\n Changes for TypeScript 4.4\n\nAs with every TypeScript version, declarations for lib.d.ts (especially the declarations generated for web contexts), have changed. You can consult our list of known lib.dom.d.ts changes to understand what is impacted.\n\nMore-Compliant Indirect Calls for Imported Functions\n\nIn earlier versions of TypeScript, calling an import from CommonJS, AMD, and other non-ES module systems would set the this value of the called function. Specifically, in the following example, when calling fooModule.foo(), the foo() method will have fooModule set as the value of this.\n\n// Imagine this is our imported module, and it has an export named 'foo'.\nlet fooModule = {\n  foo() {\n    console.log(this);\n  },\n};\nfooModule.foo();\n\nThis is not the way exported functions in ECMAScript are supposed to work when we call them. That’s why TypeScript 4.4 intentionally discards the this value when calling imported functions, by using the following emit.\n\n// Imagine this is our imported module, and it has an export named 'foo'.\nlet fooModule = {\n  foo() {\n    console.log(this);\n  },\n};\n// Notice we're actually calling '(0, fooModule.foo)' now, which is subtly different.\n(0, fooModule.foo)();\n\nYou can read up more about the changes here.\n\nUsing \nunknown\n in Catch Variables\n\nUsers running with the strict flag may see new errors around catch variables being unknown, especially if the existing code assumes only Error values have been caught. This often results in error messages such as:\n\nProperty 'message' does not exist on type 'unknown'.\nProperty 'name' does not exist on type 'unknown'.\nProperty 'stack' does not exist on type 'unknown'.\n\nTo get around this, you can specifically add runtime checks to ensure that the thrown type matches your expected type. Otherwise, you can just use a type assertion, add an explicit : any to your catch variable, or turn off useUnknownInCatchVariables.\n\nBroader Always-Truthy Promise Checks\n\nIn prior versions, TypeScript introduced “Always Truthy Promise checks” to catch code where an await may have been forgotten; however, the checks only applied to named declarations. That meant that while this code would correctly receive an error…\n\nasync function foo(): Promise<boolean> {\n  return false;\n}\nasync function bar(): Promise<string> {\n  const fooResult = foo();\n  if (fooResult) {\n    // <- error! :D\n    return \"true\";\n  }\n  return \"false\";\n}\n\n…the following code would not.\n\nasync function foo(): Promise<boolean> {\n  return false;\n}\nasync function bar(): Promise<string> {\n  if (foo()) {\n    // <- no error :(\n    return \"true\";\n  }\n  return \"false\";\n}\n\nTypeScript 4.4 now flags both. For more information, read up on the original change.\n\nAbstract Properties Do Not Allow Initializers\n\nThe following code is now an error because abstract properties may not have initializers:\n\nabstract class C {\n  abstract prop = 1;\n  //       ~~~~\n  // Property 'prop' cannot have an initializer because it is marked abstract.\n}\n\nInstead, you may only specify a type for the property:\n\nabstract class C {\n  abstract prop: number;\n}\nOn this page\nControl Flow Analysis of Aliased Conditions and Discriminants\nSymbol and Template String Pattern Index Signatures\nDefaulting to the unknown Type in Catch Variables (--useUnknownInCatchVariables)\nExact Optional Property Types (--exactOptionalPropertyTypes)\nstatic Blocks in Classes\ntsc --help Updates and Improvements\nPerformance Improvements\nFaster Declaration Emit\nFaster Path Normalization\nFaster Path Mapping\nFaster Incremental Builds with --strict\nFaster Source Map Generation for Big Outputs\nFaster --force Builds\nSpelling Suggestions for JavaScript\nInlay Hints\nAuto-Imports Show True Paths in Completion Lists\nBreaking Changes\nlib.d.ts Changes for TypeScript 4.4\nMore-Compliant Indirect Calls for Imported Functions\nUsing unknown in Catch Variables\nBroader Always-Truthy Promise Checks\nAbstract Properties Do Not Allow Initializers\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nEL\nAB\nJB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 3.726 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.7",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html",
    "html": "TypeScript 4.7\nECMAScript Module Support in Node.js\n\nFor the last few years, Node.js has been working to support ECMAScript modules (ESM). This has been a very difficult feature, since the Node.js ecosystem is built on a different module system called CommonJS (CJS). Interoperating between the two brings large challenges, with many new features to juggle; however, support for ESM in Node.js was largely implemented in Node.js 12 and later. Around TypeScript 4.5 we rolled out nightly-only support for ESM in Node.js to get some feedback from users and let library authors ready themselves for broader support.\n\nTypeScript 4.7 adds this functionality with two new module settings: node16 and nodenext.\n\n{\n    \"compilerOptions\": {\n        \"module\": \"node16\",\n    }\n}\n\nThese new modes bring a few high-level features which we’ll explore here.\n\ntype\n in \npackage.json\n and New Extensions\n\nNode.js supports a new setting in package.json called type. \"type\" can be set to either \"module\" or \"commonjs\".\n\n{\n    \"name\": \"my-package\",\n    \"type\": \"module\",\n    \"//\": \"...\",\n    \"dependencies\": {\n    }\n}\n\nThis setting controls whether .js and .d.ts files are interpreted as ES modules or CommonJS modules, and defaults to CommonJS when not set. When a file is considered an ES module, a few different rules come into play compared to CommonJS:\n\nimport/export statements can be used.\nTop-level await can be used\nRelative import paths need full extensions (we have to write import \"./foo.js\" instead of import \"./foo\").\nImports might resolve differently from dependencies in node_modules.\nCertain global-like values like require and module cannot be used directly.\nCommonJS modules get imported under certain special rules.\n\nWe’ll come back to some of these.\n\nTo overlay the way TypeScript works in this system, .ts and .tsx files now work the same way. When TypeScript finds a .ts, .tsx, .js, or .jsx file, it will walk up looking for a package.json to see whether that file is an ES module, and use that to determine:\n\nhow to find other modules which that file imports\nand how to transform that file if producing outputs\n\nWhen a .ts file is compiled as an ES module, ECMAScript import/export statements are left alone in the .js output; when it’s compiled as a CommonJS module, it will produce the same output you get today under --module commonjs.\n\nThis also means paths resolve differently between .ts files that are ES modules and ones that are CJS modules. For example, let’s say you have the following code today:\n\n// ./foo.ts\nexport function helper() {\n    // ...\n}\n// ./bar.ts\nimport { helper } from \"./foo\"; // only works in CJS\nhelper();\n\nThis code works in CommonJS modules, but will fail in ES modules because relative import paths need to use extensions. As a result, it will have to be rewritten to use the extension of the output of foo.ts - so bar.ts will instead have to import from ./foo.js.\n\n// ./bar.ts\nimport { helper } from \"./foo.js\"; // works in ESM & CJS\nhelper();\n\nThis might feel a bit cumbersome at first, but TypeScript tooling like auto-imports and path completion will typically just do this for you.\n\nOne other thing to mention is the fact that this applies to .d.ts files too. When TypeScript finds a .d.ts file in a package, it is interpreted based on the containing package.\n\nNew File Extensions\n\nThe type field in package.json is nice because it allows us to continue using the .ts and .js file extensions which can be convenient; however, you will occasionally need to write a file that differs from what type specifies. You might also just prefer to always be explicit.\n\nNode.js supports two extensions to help with this: .mjs and .cjs. .mjs files are always ES modules, and .cjs files are always CommonJS modules, and there’s no way to override these.\n\nIn turn, TypeScript supports two new source file extensions: .mts and .cts. When TypeScript emits these to JavaScript files, it will emit them to .mjs and .cjs respectively.\n\nFurthermore, TypeScript also supports two new declaration file extensions: .d.mts and .d.cts. When TypeScript generates declaration files for .mts and .cts, their corresponding extensions will be .d.mts and .d.cts.\n\nUsing these extensions is entirely optional, but will often be useful even if you choose not to use them as part of your primary workflow.\n\nCommonJS Interoperability\n\nNode.js allows ES modules to import CommonJS modules as if they were ES modules with a default export.\n\n// ./foo.cts\nexport function helper() {\n    console.log(\"hello world!\");\n}\n// ./bar.mts\nimport foo from \"./foo.cjs\";\n// prints \"hello world!\"\nfoo.helper();\n\nIn some cases, Node.js also synthesizes named exports from CommonJS modules, which can be more convenient. In these cases, ES modules can use a “namespace-style” import (i.e. import * as foo from \"...\"), or named imports (i.e. import { helper } from \"...\").\n\n// ./foo.cts\nexport function helper() {\n    console.log(\"hello world!\");\n}\n// ./bar.mts\nimport { helper } from \"./foo.cjs\";\n// prints \"hello world!\"\nhelper();\n\nThere isn’t always a way for TypeScript to know whether these named imports will be synthesized, but TypeScript will err on being permissive and use some heuristics when importing from a file that is definitely a CommonJS module.\n\nOne TypeScript-specific note about interop is the following syntax:\n\nimport foo = require(\"foo\");\n\nIn a CommonJS module, this just boils down to a require() call, and in an ES module, this imports createRequire to achieve the same thing. This will make code less portable on runtimes like the browser (which don’t support require()), but will often be useful for interoperability. In turn, you can write the above example using this syntax as follows:\n\n// ./foo.cts\nexport function helper() {\n    console.log(\"hello world!\");\n}\n// ./bar.mts\nimport foo = require(\"./foo.cjs\");\nfoo.helper()\n\nFinally, it’s worth noting that the only way to import ESM files from a CJS module is using dynamic import() calls. This can present challenges, but is the behavior in Node.js today.\n\nYou can read more about ESM/CommonJS interop in Node.js here.\n\npackage.json\n Exports, Imports, and Self-Referencing\n\nNode.js supports a new field for defining entry points in package.json called \"exports\". This field is a more powerful alternative to defining \"main\" in package.json, and can control what parts of your package are exposed to consumers.\n\nHere’s a package.json that supports separate entry-points for CommonJS and ESM:\n\n// package.json\n{\n    \"name\": \"my-package\",\n    \"type\": \"module\",\n    \"exports\": {\n        \".\": {\n            // Entry-point for `import \"my-package\"` in ESM\n            \"import\": \"./esm/index.js\",\n            // Entry-point for `require(\"my-package\") in CJS\n            \"require\": \"./commonjs/index.cjs\",\n        },\n    },\n    // CJS fall-back for older versions of Node.js\n    \"main\": \"./commonjs/index.cjs\",\n}\n\nThere’s a lot to this feature, which you can read more about on the Node.js documentation. Here we’ll try to focus on how TypeScript supports it.\n\nWith TypeScript’s original Node support, it would look for a \"main\" field, and then look for declaration files that corresponded to that entry. For example, if \"main\" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts. A package author could override this by specifying a separate field called \"types\" (e.g. \"types\": \"./types/index.d.ts\").\n\nThe new support works similarly with import conditions. By default, TypeScript overlays the same rules with import conditions - if you write an import from an ES module, it will look up the import field, and from a CommonJS module, it will look at the require field. If it finds them, it will look for a corresponding declaration file. If you need to point to a different location for your type declarations, you can add a \"types\" import condition.\n\n// package.json\n{\n    \"name\": \"my-package\",\n    \"type\": \"module\",\n    \"exports\": {\n        \".\": {\n            // Entry-point for `import \"my-package\"` in ESM\n            \"import\": {\n                // Where TypeScript will look.\n                \"types\": \"./types/esm/index.d.ts\",\n                // Where Node.js will look.\n                \"default\": \"./esm/index.js\"\n            },\n            // Entry-point for `require(\"my-package\") in CJS\n            \"require\": {\n                // Where TypeScript will look.\n                \"types\": \"./types/commonjs/index.d.cts\",\n                // Where Node.js will look.\n                \"default\": \"./commonjs/index.cjs\"\n            },\n        }\n    },\n    // Fall-back for older versions of TypeScript\n    \"types\": \"./types/index.d.ts\",\n    // CJS fall-back for older versions of Node.js\n    \"main\": \"./commonjs/index.cjs\"\n}\n\nThe \"types\" condition should always come first in \"exports\".\n\nIt’s important to note that the CommonJS entrypoint and the ES module entrypoint each needs its own declaration file, even if the contents are the same between them. Every declaration file is interpreted either as a CommonJS module or as an ES module, based on its file extension and the \"type\" field of the package.json, and this detected module kind must match the module kind that Node will detect for the corresponding JavaScript file for type checking to be correct. Attempting to use a single .d.ts file to type both an ES module entrypoint and a CommonJS entrypoint will cause TypeScript to think only one of those entrypoints exists, causing compiler errors for users of the package.\n\nTypeScript also supports the \"imports\" field of package.json in a similar manner by looking for declaration files alongside corresponding files, and supports packages self-referencing themselves. These features are generally not as involved to set up, but are supported.\n\nYour Feedback Wanted!\n\nAs we continue working on TypeScript 4.7, we expect to see more documentation and polish go into this functionality. Supporting these new features has been an ambitious under-taking, and that’s why we’re looking for early feedback on it! Please try it out and let us know how it works for you.\n\nFor more information, you can see the implementing PR here.\n\nControl over Module Detection\n\nOne issue with the introduction of modules to JavaScript was the ambiguity between existing “script” code and the new module code. JavaScript code in a module runs slightly differently, and has different scoping rules, so tools have to make decisions as to how each file runs. For example, Node.js requires module entry-points to be written in a .mjs, or have a nearby package.json with \"type\": \"module\". TypeScript treats a file as a module whenever it finds any import or export statement in a file, but otherwise, will assume a .ts or .js file is a script file acting on the global scope.\n\nThis doesn’t quite match up with the behavior of Node.js where the package.json can change the format of a file, or the --jsx setting react-jsx, where any JSX file contains an implicit import to a JSX factory. It also doesn’t match modern expectations where most new TypeScript code is written with modules in mind.\n\nThat’s why TypeScript 4.7 introduces a new option called moduleDetection. moduleDetection can take on 3 values: \"auto\" (the default), \"legacy\" (the same behavior as 4.6 and prior), and \"force\".\n\nUnder the mode \"auto\", TypeScript will not only look for import and export statements, but it will also check whether\n\nthe \"type\" field in package.json is set to \"module\" when running under --module nodenext/--module node16, and\ncheck whether the current file is a JSX file when running under --jsx react-jsx\n\nIn cases where you want every file to be treated as a module, the \"force\" setting ensures that every non-declaration file is treated as a module. This will be true regardless of how module, moduleResolution, and jsx are configured.\n\nMeanwhile, the \"legacy\" option simply goes back to the old behavior of only seeking out import and export statements to determine whether a file is a module.\n\nYou can read up more about this change on the pull request.\n\nControl-Flow Analysis for Bracketed Element Access\n\nTypeScript 4.7 now narrows the types of element accesses when the indexed keys are literal types and unique symbols. For example, take the following code:\n\nconst key = Symbol();\nconst numberOrString = Math.random() < 0.5 ? 42 : \"hello\";\nconst obj = {\n    [key]: numberOrString,\n};\nif (typeof obj[key] === \"string\") {\n    let str = obj[key].toUpperCase();\n}\n\nPreviously, TypeScript would not consider any type guards on obj[key], and would have no idea that obj[key] was really a string. Instead, it would think that obj[key] was still a string | number and accessing toUpperCase() would trigger an error.\n\nTypeScript 4.7 now knows that obj[key] is a string.\n\nThis also means that under --strictPropertyInitialization, TypeScript can correctly check that computed properties are initialized by the end of a constructor body.\n\n// 'key' has type 'unique symbol'\nconst key = Symbol();\nclass C {\n    [key]: string;\n    constructor(str: string) {\n        // oops, forgot to set 'this[key]'\n    }\n    screamString() {\n        return this[key].toUpperCase();\n    }\n}\n\nUnder TypeScript 4.7, --strictPropertyInitialization reports an error telling us that the [key] property wasn’t definitely assigned by the end of the constructor.\n\nWe’d like to extend our gratitude to Oleksandr Tarasiuk who provided this change!\n\nImproved Function Inference in Objects and Methods\n\nTypeScript 4.7 can now perform more granular inferences from functions within objects and arrays. This allows the types of these functions to consistently flow in a left-to-right manner just like for plain arguments.\n\ndeclare function f<T>(arg: {\n    produce: (n: string) => T,\n    consume: (x: T) => void }\n): void;\n// Works\nf({\n    produce: () => \"hello\",\n    consume: x => x.toLowerCase()\n});\n// Works\nf({\n    produce: (n: string) => n,\n    consume: x => x.toLowerCase(),\n});\n// Was an error, now works.\nf({\n    produce: n => n,\n    consume: x => x.toLowerCase(),\n});\n// Was an error, now works.\nf({\n    produce: function () { return \"hello\"; },\n    consume: x => x.toLowerCase(),\n});\n// Was an error, now works.\nf({\n    produce() { return \"hello\" },\n    consume: x => x.toLowerCase(),\n});\n\nInference failed in some of these examples because knowing the type of their produce functions would indirectly request the type of arg before finding a good type for T. TypeScript now gathers functions that could contribute to the inferred type of T and infers from them lazily.\n\nFor more information, you can take a look at the specific modifications to our inference process.\n\nInstantiation Expressions\n\nOccasionally functions can be a bit more general than we want. For example, let’s say we had a makeBox function.\n\ninterface Box<T> {\n    value: T;\n}\nfunction makeBox<T>(value: T) {\n    return { value };\n}\n\nMaybe we want to create a more specialized set of functions for making Boxes of Wrenches and Hammers. To do that today, we’d have to wrap makeBox in other functions, or use an explicit type for an alias of makeBox.\n\nfunction makeHammerBox(hammer: Hammer) {\n    return makeBox(hammer);\n}\n// or...\nconst makeWrenchBox: (wrench: Wrench) => Box<Wrench> = makeBox;\n\nThese work, but wrapping a call to makeBox is a bit wasteful, and writing the full signature of makeWrenchBox could get unwieldy. Ideally, we would be able to say that we just want to alias makeBox while replacing all of the generics in its signature.\n\nTypeScript 4.7 allows exactly that! We can now take functions and constructors and feed them type arguments directly.\n\nconst makeHammerBox = makeBox<Hammer>;\nconst makeWrenchBox = makeBox<Wrench>;\n\nSo with this, we can specialize makeBox to accept more specific types and reject anything else.\n\nconst makeStringBox = makeBox<string>;\n// TypeScript correctly rejects this.\nmakeStringBox(42);\n\nThis logic also works for constructor functions such as Array, Map, and Set.\n\n// Has type `new () => Map<string, Error>`\nconst ErrorMap = Map<string, Error>;\n// Has type `// Map<string, Error>`\nconst errorMap = new ErrorMap();\n\nWhen a function or constructor is given type arguments, it will produce a new type that keeps all signatures with compatible type parameter lists, and replaces the corresponding type parameters with the given type arguments. Any other signatures are dropped, as TypeScript will assume that they aren’t meant to be used.\n\nFor more information on this feature, check out the pull request.\n\nextends\n Constraints on \ninfer\n Type Variables\n\nConditional types are a bit of a power-user feature. They allow us to match and infer against the shape of types, and make decisions based on them. For example, we can write a conditional type that returns the first element of a tuple type if it’s a string-like type.\n\ntype FirstIfString<T> =\n    T extends [infer S, ...unknown[]]\n        ? S extends string ? S : never\n        : never;\n // string\ntype A = FirstIfString<[string, number, number]>;\n// \"hello\"\ntype B = FirstIfString<[\"hello\", number, number]>;\n// \"hello\" | \"world\"\ntype C = FirstIfString<[\"hello\" | \"world\", boolean]>;\n// never\ntype D = FirstIfString<[boolean, number, string]>;\n\nFirstIfString matches against any tuple with at least one element and grabs the type of the first element as S. Then it checks if S is compatible with string and returns that type if it is.\n\nNote that we had to use two conditional types to write this. We could have written FirstIfString as follows:\n\ntype FirstIfString<T> =\n    T extends [string, ...unknown[]]\n        // Grab the first type out of `T`\n        ? T[0]\n        : never;\n\nThis works, but it’s slightly more “manual” and less declarative. Instead of just pattern-matching on the type and giving the first element a name, we have to fetch out the 0th element of T with T[0]. If we were dealing with types more complex than tuples, this could get a lot trickier, so infer can simplify things.\n\nUsing nested conditionals to infer a type and then match against that inferred type is pretty common. To avoid that second level of nesting, TypeScript 4.7 now allows you to place a constraint on any infer type.\n\ntype FirstIfString<T> =\n    T extends [infer S extends string, ...unknown[]]\n        ? S\n        : never;\n\nThis way, when TypeScript matches against S, it also ensures that S has to be a string. If S isn’t a string, it takes the false path, which in these cases is never.\n\nFor more details, you can read up on the change on GitHub.\n\nOptional Variance Annotations for Type Parameters\n\nLet’s take the following types.\n\ninterface Animal {\n    animalStuff: any;\n}\ninterface Dog extends Animal {\n    dogStuff: any;\n}\n// ...\ntype Getter<T> = () => T;\ntype Setter<T> = (value: T) => void;\n\nImagine we had two different instances of Getters. Figuring out whether any two different Getters are substitutable for one another depends entirely on T. In the case of whether an assignment of Getter<Dog> → Getter<Animal> is valid, we have to check whether Dog → Animal is valid. Because each type for T just gets related in the same “direction”, we say that the Getter type is covariant on T. On the other hand, checking whether Setter<Dog> → Setter<Animal> is valid involves checking whether Animal → Dog is valid. That “flip” in direction is kind of like how in math, checking whether −x < −y is the same as checking whether y < x. When we have to flip directions like this to compare T, we say that Setter is contravariant on T.\n\nWith TypeScript 4.7, we’re now able to explicitly specify variance on type parameters.\n\nSo now, if we want to make it explicit that Getter is covariant on T, we can now give it an out modifier.\n\ntype Getter<out T> = () => T;\n\nAnd similarly, if we also want to make it explicit that Setter is contravariant on T, we can give it an in modifier.\n\ntype Setter<in T> = (value: T) => void;\n\nout and in are used here because a type parameter’s variance depends on whether it’s used in an output or an input. Instead of thinking about variance, you can just think about if T is used in output and input positions.\n\nThere are also cases for using both in and out.\n\ninterface State<in out T> {\n    get: () => T;\n    set: (value: T) => void;\n}\n\nWhen a T is used in both an output and input position, it becomes invariant. Two different State<T>s can’t be interchanged unless their Ts are the same. In other words, State<Dog> and State<Animal> aren’t substitutable for the other.\n\nNow technically speaking, in a purely structural type system, type parameters and their variance don’t really matter - you can just plug in types in place of each type parameter and check whether each matching member is structurally compatible. So if TypeScript uses a structural type system, why are we interested in the variance of type parameters? And why might we ever want to annotate them?\n\nOne reason is that it can be useful for a reader to explicitly see how a type parameter is used at a glance. For much more complex types, it can be difficult to tell whether a type is meant to be read, written, or both. TypeScript will also help us out if we forget to mention how that type parameter is used. As an example, if we forgot to specify both in and out on State, we’d get an error.\n\ninterface State<out T> {\n    //          ~~~~~\n    // error!\n    // Type 'State<sub-T>' is not assignable to type 'State<super-T>' as implied by variance annotation.\n    //   Types of property 'set' are incompatible.\n    //     Type '(value: sub-T) => void' is not assignable to type '(value: super-T) => void'.\n    //       Types of parameters 'value' and 'value' are incompatible.\n    //         Type 'super-T' is not assignable to type 'sub-T'.\n    get: () => T;\n    set: (value: T) => void;\n}\n\nAnother reason is precision and speed! TypeScript already tries to infer the variance of type parameters as an optimization. By doing this, it can type-check larger structural types in a reasonable amount of time. Calculating variance ahead of time allows the type-checker to skip deeper comparisons and just compare type arguments which can be much faster than comparing the full structure of a type over and over again. But often there are cases where this calculation is still fairly expensive, and the calculation may find circularities that can’t be accurately resolved, meaning there’s no clear answer for the variance of a type.\n\ntype Foo<T> = {\n    x: T;\n    f: Bar<T>;\n}\ntype Bar<U> = (x: Baz<U[]>) => void;\ntype Baz<V> = {\n    value: Foo<V[]>;\n}\ndeclare let foo1: Foo<unknown>;\ndeclare let foo2: Foo<string>;\nfoo1 = foo2;  // Should be an error but isn't ❌\nfoo2 = foo1;  // Error - correct ✅\n\nProviding an explicit annotation can speed up type-checking at these circularities and provide better accuracy. For instance, marking T as invariant in the above example can help stop the problematic assignment.\n\n- type Foo<T> = {\n+ type Foo<in out T> = {\n      x: T;\n      f: Bar<T>;\n  }\n\nWe don’t necessarily recommend annotating every type parameter with its variance; For example, it’s possible (but not recommended) to make variance a little stricter than is necessary, so TypeScript won’t stop you from marking something as invariant if it’s really just covariant, contravariant, or even independent. So if you do choose to add explicit variance markers, we would encourage thoughtful and precise use of them.\n\nBut if you’re working with deeply recursive types, especially if you’re a library author, you may be interested in using these annotations to the benefit of your users. Those annotations can provide wins in both accuracy and type-checking speed, which can even affect their code editing experience. Determining when variance calculation is a bottleneck on type-checking time can be done experimentally, and determined using tooling like our analyze-trace utility.\n\nFor more details on this feature, you can read up on the pull request.\n\nResolution Customization with \nmoduleSuffixes\n\nTypeScript 4.7 now supports a moduleSuffixes option to customize how module specifiers are looked up.\n\n{\n    \"compilerOptions\": {\n        \"moduleSuffixes\": [\".ios\", \".native\", \"\"]\n    }\n}\n\nGiven the above configuration, an import like the following…\n\nimport * as foo from \"./foo\";\n\nwill try to look at the relative files ./foo.ios.ts, ./foo.native.ts, and finally ./foo.ts.\n\nNote that the empty string \"\" in moduleSuffixes is necessary for TypeScript to also look-up ./foo.ts. In a sense, the default value for moduleSuffixes is [\"\"].\n\nThis feature can be useful for React Native projects where each target platform can use a separate tsconfig.json with differing moduleSuffixes.\n\nThe moduleSuffixes option was contributed thanks to Adam Foxman!\n\nresolution-mode\n\nWith Node’s ECMAScript resolution, the mode of the containing file and the syntax you use determines how imports are resolved; however it would be useful to reference the types of a CommonJS module from an ECMAScript module, or vice-versa.\n\nTypeScript now allows /// <reference types=\"...\" /> directives.\n\n/// <reference types=\"pkg\" resolution-mode=\"require\" />\n// or\n/// <reference types=\"pkg\" resolution-mode=\"import\" />\n\nAdditionally, in nightly versions of TypeScript, import type can specify an import assertion to achieve something similar.\n\n// Resolve `pkg` as if we were importing with a `require()`\nimport type { TypeFromRequire } from \"pkg\" assert {\n    \"resolution-mode\": \"require\"\n};\n// Resolve `pkg` as if we were importing with an `import`\nimport type { TypeFromImport } from \"pkg\" assert {\n    \"resolution-mode\": \"import\"\n};\nexport interface MergedType extends TypeFromRequire, TypeFromImport {}\n\nThese import assertions can also be used on import() types.\n\nexport type TypeFromRequire =\n    import(\"pkg\", { assert: { \"resolution-mode\": \"require\" } }).TypeFromRequire;\nexport type TypeFromImport =\n    import(\"pkg\", { assert: { \"resolution-mode\": \"import\" } }).TypeFromImport;\nexport interface MergedType extends TypeFromRequire, TypeFromImport {}\n\nThe import type and import() syntaxes only support resolution-mode in nightly builds of TypeScript. You’ll likely get an error like\n\nResolution mode assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'.\n\nIf you do find yourself using this feature in nightly versions of TypeScript, consider providing feedback on this issue.\n\nYou can see the respective changes for reference directives and for type import assertions.\n\nGo to Source Definition\n\nTypeScript 4.7 contains support for a new experimental editor command called Go To Source Definition. It’s similar to Go To Definition, but it never returns results inside declaration files. Instead, it tries to find corresponding implementation files (like .js or .ts files), and find definitions there — even if those files are normally shadowed by .d.ts files.\n\nThis comes in handy most often when you need to peek at the implementation of a function you’re importing from a library instead of its type declaration in a .d.ts file.\n\nYou can try this new command in the latest versions of Visual Studio Code. Note, though, that this functionality is still in preview, and there are some known limitations. In some cases TypeScript uses heuristics to guess which .js file corresponds to the given result of a definition, so these results might be inaccurate. Visual Studio Code also doesn’t yet indicate whether a result was a guess, but it’s something we’re collaborating on.\n\nYou can leave feedback about the feature, read about known limitations, or learn more at our dedicated feedback issue.\n\nGroup-Aware Organize Imports\n\nTypeScript has an Organize Imports editor feature for both JavaScript and TypeScript. Unfortunately, it could be a bit of a blunt instrument, and would often naively sort your import statements.\n\nFor instance, if you ran Organize Imports on the following file…\n\n// local code\nimport * as bbb from \"./bbb\";\nimport * as ccc from \"./ccc\";\nimport * as aaa from \"./aaa\";\n// built-ins\nimport * as path from \"path\";\nimport * as child_process from \"child_process\"\nimport * as fs from \"fs\";\n// some code...\n\nYou would get something like the following\n\n// local code\nimport * as child_process from \"child_process\";\nimport * as fs from \"fs\";\n// built-ins\nimport * as path from \"path\";\nimport * as aaa from \"./aaa\";\nimport * as bbb from \"./bbb\";\nimport * as ccc from \"./ccc\";\n// some code...\n\nThis is… not ideal. Sure, our imports are sorted by their paths, and our comments and newlines are preserved, but not in a way we expected. Much of the time, if we have our imports grouped in a specific way, then we want to keep them that way.\n\nTypeScript 4.7 performs Organize Imports in a group-aware manner. Running it on the above code looks a little bit more like what you’d expect:\n\n// local code\nimport * as aaa from \"./aaa\";\nimport * as bbb from \"./bbb\";\nimport * as ccc from \"./ccc\";\n// built-ins\nimport * as child_process from \"child_process\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\n// some code...\n\nWe’d like to extend our thanks to Minh Quy who provided this feature.\n\nObject Method Snippet Completions\n\nTypeScript now provides snippet completions for object literal methods. When completing members in an object, TypeScript will provide a typical completion entry for just the name of a method, along with a separate completion entry for the full method definition!\n\nFor more details, see the implementing pull request.\n\nBreaking Changes\nlib.d.ts\n Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and lib.d.ts updates, but there may be some small ones.\n\nStricter Spread Checks in JSX\n\nWhen writing a ...spread in JSX, TypeScript now enforces stricter checks that the given type is actually an object. As a result, values with the types unknown and never (and more rarely, just bare null and undefined) can no longer be spread into JSX elements.\n\nSo for the following example:\n\nimport * as React from \"react\";\ninterface Props {\n    stuff?: string;\n}\nfunction MyComponent(props: unknown) {\n    return <div {...props} />;\n}\n\nyou’ll now receive an error like the following:\n\nSpread types may only be created from object types.\n\nThis makes this behavior more consistent with spreads in object literals.\n\nFor more details, see the change on GitHub.\n\nStricter Checks with Template String Expressions\n\nWhen a symbol value is used in a template string, it will trigger a runtime error in JavaScript.\n\nlet str = `hello ${Symbol()}`;\n// TypeError: Cannot convert a Symbol value to a string\n\nAs a result, TypeScript will issue an error as well; however, TypeScript now also checks if a generic value that is constrained to a symbol in some way is used in a template string.\n\nfunction logKey<S extends string | symbol>(key: S): S {\n    // Now an error.\n    console.log(`${key} is the key`);\n    return key;\n}\nfunction get<T, K extends keyof T>(obj: T, key: K) {\n    // Now an error.\n    console.log(`Grabbing property '${key}'.`);\n    return obj[key];\n}\n\nTypeScript will now issue the following error:\n\nImplicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.\n\nIn some cases, you can get around this by wrapping the expression in a call to String, just like the error message suggests.\n\nfunction logKey<S extends string | symbol>(key: S): S {\n    // No longer an error.\n    console.log(`${String(key)} is the key`);\n    return key;\n}\n\nIn others, this error is too pedantic, and you might not ever care to even allow symbol keys when using keyof. In such cases, you can switch to string & keyof ...:\n\nfunction get<T, K extends string & keyof T>(obj: T, key: K) {\n    // No longer an error.\n    console.log(`Grabbing property '${key}'.`);\n    return obj[key];\n}\n\nFor more information, you can see the implementing pull request.\n\nreadFile\n Method is No Longer Optional on \nLanguageServiceHost\n\nIf you’re creating LanguageService instances, then provided LanguageServiceHosts will need to provide a readFile method. This change was necessary to support the new moduleDetection compiler option.\n\nYou can read more on the change here.\n\nreadonly\n Tuples Have a \nreadonly\nlength\n Property\n\nA readonly tuple will now treat its length property as readonly. This was almost never witnessable for fixed-length tuples, but was an oversight which could be observed for tuples with trailing optional and rest element types.\n\nAs a result, the following code will now fail:\n\nfunction overwriteLength(tuple: readonly [string, string, string]) {\n    // Now errors.\n    tuple.length = 7;\n}\n\nYou can read more on this change here.\n\nOn this page\nECMAScript Module Support in Node.js\ntype in package.json and New Extensions\nNew File Extensions\nCommonJS Interoperability\npackage.json Exports, Imports, and Self-Referencing\nYour Feedback Wanted!\nControl over Module Detection\nControl-Flow Analysis for Bracketed Element Access\nImproved Function Inference in Objects and Methods\nInstantiation Expressions\nextends Constraints on infer Type Variables\nOptional Variance Annotations for Type Parameters\nResolution Customization with moduleSuffixes\nresolution-mode\nGo to Source Definition\nGroup-Aware Organize Imports\nObject Method Snippet Completions\nBreaking Changes\nlib.d.ts Updates\nStricter Spread Checks in JSX\nStricter Checks with Template String Expressions\nreadFile Method is No Longer Optional on LanguageServiceHost\nreadonly Tuples Have a readonly length Property\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\nNT\nPADPB\nHC\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.642 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.6",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-6.html",
    "html": "TypeScript 4.6\nAllowing Code in Constructors Before \nsuper()\n\nIn JavaScript classes it’s mandatory to call super() before referring to this. TypeScript enforces this as well, though it was a bit too strict in how it ensured this. In TypeScript, it was previously an error to contain any code at the beginning of a constructor if its containing class had any property initializers.\n\nclass Base {\n  // ...\n}\nclass Derived extends Base {\n  someProperty = true;\n  constructor() {\n    // error!\n    // have to call 'super()' first because it needs to initialize 'someProperty'.\n    doSomeStuff();\n    super();\n  }\n}\n\nThis made it cheap to check that super() gets called before this is referenced, but it ended up rejecting a lot of valid code. TypeScript 4.6 is now much more lenient in that check and permits other code to run before super()., all while still ensuring that super() occurs at the top-level before any references to this.\n\nWe’d like to extend our thanks to Joshua Goldberg for patiently working with us to land this change!\n\nControl Flow Analysis for Destructured Discriminated Unions\n\nTypeScript is able to narrow types based on what’s called a discriminant property. For example, in the following code snippet, TypeScript is able to narrow the type of action based on every time we check against the value of kind.\n\ntype Action =\n  | { kind: \"NumberContents\"; payload: number }\n  | { kind: \"StringContents\"; payload: string };\nfunction processAction(action: Action) {\n  if (action.kind === \"NumberContents\") {\n    // `action.payload` is a number here.\n    let num = action.payload * 2;\n    // ...\n  } else if (action.kind === \"StringContents\") {\n    // `action.payload` is a string here.\n    const str = action.payload.trim();\n    // ...\n  }\n}\n\nThis lets us work with objects that can hold different data, but a common field tells us which data those objects have.\n\nThis is very common in TypeScript; however, depending on your preferences, you might have wanted to destructure kind and payload in the example above. Perhaps something like the following:\n\ntype Action =\n  | { kind: \"NumberContents\"; payload: number }\n  | { kind: \"StringContents\"; payload: string };\nfunction processAction(action: Action) {\n  const { kind, payload } = action;\n  if (kind === \"NumberContents\") {\n    let num = payload * 2;\n    // ...\n  } else if (kind === \"StringContents\") {\n    const str = payload.trim();\n    // ...\n  }\n}\n\nPreviously TypeScript would error on these - once kind and payload were extracted from the same object into variables, they were considered totally independent.\n\nIn TypeScript 4.6, this just works!\n\nWhen destructuring individual properties into a const declaration, or when destructuring a parameter into variables that are never assigned to, TypeScript will check for if the destructured type is a discriminated union. If it is, TypeScript can now narrow the types of variables depending on checks of other variables So in our example, a check on kind narrows the type of payload.\n\nFor more information, see the pull request that implemented this analysis.\n\nImproved Recursion Depth Checks\n\nTypeScript has some interesting challenges due to the fact that it’s built on a structural type system that also provides generics.\n\nIn a structural type system, object types are compatible based on the members they have.\n\ninterface Source {\n  prop: string;\n}\ninterface Target {\n  prop: number;\n}\nfunction check(source: Source, target: Target) {\n  target = source;\n  // error!\n  // Type 'Source' is not assignable to type 'Target'.\n  //   Types of property 'prop' are incompatible.\n  //     Type 'string' is not assignable to type 'number'.\n}\n\nNotice that whether or not Source is compatible with Target has to do with whether their properties are assignable. In this case, that’s just prop.\n\nWhen you introduce generics into this, there are some harder questions to answer. For instance, is a Source<string> assignable to a Target<number> in the following case?\n\ninterface Source<T> {\n  prop: Source<Source<T>>;\n}\ninterface Target<T> {\n  prop: Target<Target<T>>;\n}\nfunction check(source: Source<string>, target: Target<number>) {\n  target = source;\n}\n\nIn order to answer that, TypeScript needs to check whether the types of prop are compatible. That leads to the another question: is a Source<Source<string>> assignable to a Target<Target<number>>? To answer that, TypeScript checks whether prop is compatible for those types, and ends up checking whether Source<Source<Source<string>>> is assignable to Target<Target<Target<number>>>. Keep going for a bit, and you might notice that the type infinitely expands the more you dig in.\n\nTypeScript has a few heuristics here - if a type appears to be infinitely expanding after encountering a certain depth check, then it considers that the types could be compatible. This is usually enough, but embarrassingly there were some false-negatives that this wouldn’t catch.\n\ninterface Foo<T> {\n  prop: T;\n}\ndeclare let x: Foo<Foo<Foo<Foo<Foo<Foo<string>>>>>>;\ndeclare let y: Foo<Foo<Foo<Foo<Foo<string>>>>>;\nx = y;\n\nA human reader can see that x and y should be incompatible in the above example. While the types are deeply nested, that’s just a consequence of how they were declared. The heuristic was meant to capture cases where deeply-nested types were generated through exploring the types, not from when a developer wrote that type out themselves.\n\nTypeScript 4.6 is now able to distinguish these cases, and correctly errors on the last example. Additionally, because the language is no longer concerned with false-positives from explicitly-written types, TypeScript can conclude that a type is infinitely expanding much earlier, and save a bunch of work in checking for type compatibility. As a result, libraries on DefinitelyTyped like redux-immutable, react-lazylog, and yup saw a 50% reduction in check-time.\n\nYou may already have this change because it was cherry-picked into TypeScript 4.5.3, but it is a notable feature of TypeScript 4.6 which you can read up more about here.\n\nIndexed Access Inference Improvements\n\nTypeScript now can correctly infer to indexed access types which immediately index into a mapped object type.\n\ninterface TypeMap {\n  number: number;\n  string: string;\n  boolean: boolean;\n}\ntype UnionRecord<P extends keyof TypeMap> = {\n  [K in P]: {\n    kind: K;\n    v: TypeMap[K];\n    f: (p: TypeMap[K]) => void;\n  };\n}[P];\nfunction processRecord<K extends keyof TypeMap>(record: UnionRecord<K>) {\n  record.f(record.v);\n}\n// This call used to have issues - now works!\nprocessRecord({\n  kind: \"string\",\n  v: \"hello!\",\n  // 'val' used to implicitly have the type 'string | number | boolean',\n  // but now is correctly inferred to just 'string'.\n  f: (val) => {\n    console.log(val.toUpperCase());\n  },\n});\n\nThis pattern was already supported and allowed TypeScript to understand that the call to record.f(record.v) is valid, but previously the call to processRecord would give poor inference results for val\n\nTypeScript 4.6 improves this so that no type assertions are necessary within the call to processRecord.\n\nFor more information, you can read up on the pull request.\n\nControl Flow Analysis for Dependent Parameters\n\nA signature can be declared with a rest parameter whose type is a discriminated union of tuples.\n\nfunction func(...args: [\"str\", string] | [\"num\", number]) {\n  // ...\n}\n\nWhat this says is that the arguments to func depends entirely on the first argument. When the first argument is the string \"str\", then its second argument has to be a string. When its first argument is the string \"num\", its second argument has to be a number.\n\nIn cases where TypeScript infers the type of a function from a signature like this, TypeScript can now narrow parameters that depend on each other.\n\ntype Func = (...args: [\"a\", number] | [\"b\", string]) => void;\nconst f1: Func = (kind, payload) => {\n  if (kind === \"a\") {\n    payload.toFixed(); // 'payload' narrowed to 'number'\n  }\n  if (kind === \"b\") {\n    payload.toUpperCase(); // 'payload' narrowed to 'string'\n  }\n};\nf1(\"a\", 42);\nf1(\"b\", \"hello\");\n\nFor more information, see the change on GitHub.\n\n--target es2022\n\nTypeScript’s --target option now supports es2022. This means features like class fields now have a stable output target where they can be preserved. It also means that new built-in functionality like the at() method on Arrays, Object.hasOwn, or the cause option on new Error can be used either with this new --target setting, or with --lib es2022.\n\nThis functionality was implemented by Kagami Sascha Rosylight (saschanaz) over several PRs, and we’re grateful for that contribution!\n\nRemoved Unnecessary Arguments in \nreact-jsx\n\nPreviously, when compiling code like the following in --jsx react-jsx\n\nexport const el = <div>foo</div>;\n\nTypeScript would produce the following JavaScript code:\n\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const el = _jsx(\"div\", { children: \"foo\" }, void 0);\n\nThat last void 0 argument is unnecessary in this emit mode, and removing it can improve bundle sizes.\n\n- export const el = _jsx(\"div\", { children: \"foo\" }, void 0);\n+ export const el = _jsx(\"div\", { children: \"foo\" });\n\nThanks to a pull request from Alexander Tarasyuk, TypeScript 4.6 now drops the void 0 argument.\n\nJSDoc Name Suggestions\n\nIn JSDoc, you can document parameters using an @param tag.\n\n/**\n * @param x The first operand\n * @param y The second operand\n */\nfunction add(x, y) {\n  return x + y;\n}\n\nBut what happens when these comments fall out of date? What if we rename x and y to a and b?\n\n/**\n * @param x {number} The first operand\n * @param y {number} The second operand\n */\nfunction add(a, b) {\n  return a + b;\n}\n\nPreviously TypeScript would only tell you about this when performing type-checking on JavaScript files - when using either the checkJs option, or adding a // @ts-check comment to the top of your file.\n\nYou can now get similar information for TypeScript files in your editor! TypeScript now provides suggestions for when parameter names don’t match between your function and its JSDoc comment.\n\nThis change was provided courtesy of Alexander Tarasyuk!\n\nMore Syntax and Binding Errors in JavaScript\n\nTypeScript has expanded its set of syntax and binding errors in JavaScript files. You’ll see these new errors if you open JavaScript files in an editor like Visual Studio or Visual Studio Code, or if you run JavaScript code through the TypeScript compiler - even if you don’t turn on checkJs or add a // @ts-check comment to the top of your files.\n\nAs one example, if you have two declarations of a const in the same scope of a JavaScript file, TypeScript will now issue an error on those declarations.\n\nconst foo = 1234;\n//    ~~~\n// error: Cannot redeclare block-scoped variable 'foo'.\n// ...\nconst foo = 5678;\n//    ~~~\n// error: Cannot redeclare block-scoped variable 'foo'.\n\nAs another example, TypeScript will let you know if a modifier is being incorrectly used.\n\nfunction container() {\n    export function foo() {\n//  ~~~~~~\n// error: Modifiers cannot appear here.\n    }\n}\n\nThese errors can be disabled by adding a // @ts-nocheck at the top of your file, but we’re interested in hearing some early feedback about how it works for your JavaScript workflow. You can easily try it out for Visual Studio Code by installing the TypeScript and JavaScript Nightly Extension, and read up more on the first and second pull requests.\n\nTypeScript Trace Analyzer\n\nOccasionally, teams may encounter types that are computationally expensive to create and compare against other types. TypeScript has a --generateTrace flag to help identify some of those expensive types, or sometimes help diagnose issues in the TypeScript compiler. While the information generated by --generateTrace can be useful (especially with some information added in TypeScript 4.6), it can often be hard to read in existing trace visualizers.\n\nWe recently published a tool called @typescript/analyze-trace to get a more digestible view of this information. While we don’t expect everyone to need analyze-trace, we think it can come in handy for any team that is running into build performance issues with TypeScript.\n\nFor more information, see the analyze-trace tool’s repo.\n\nBreaking Changes\nObject Rests Drop Unspreadable Members from Generic Objects\n\nObject rest expressions now drop members that appear to be unspreadable on generic objects. In the following example…\n\nclass Thing {\n  someProperty = 42;\n  someMethod() {\n    // ...\n  }\n}\nfunction foo<T extends Thing>(x: T) {\n  let { someProperty, ...rest } = x;\n  // Used to work, is now an error!\n  // Property 'someMethod' does not exist on type 'Omit<T, \"someProperty\" | \"someMethod\">'.\n  rest.someMethod();\n}\n\nthe variable rest used to have the type Omit<T, \"someProperty\"> because TypeScript would strictly analyze which other properties were destructured. This doesn’t model how ...rest would work in a destructuring from a non-generic type because someMethod would typically be dropped as well. In TypeScript 4.6, the type of rest is Omit<T, \"someProperty\" | \"someMethod\">.\n\nThis can also come up in cases when destructuring from this. When destructuring this using a ...rest element, unspreadable and non-public members are now dropped, which is consistent with destructuring instances of a class in other places.\n\nclass Thing {\n  someProperty = 42;\n  someMethod() {\n    // ...\n  }\n  someOtherMethod() {\n    let { someProperty, ...rest } = this;\n    // Used to work, is now an error!\n    // Property 'someMethod' does not exist on type 'Omit<T, \"someProperty\" | \"someMethod\">'.\n    rest.someMethod();\n  }\n}\n\nFor more details, see the corresponding change here.\n\nJavaScript Files Always Receive Grammar and Binding Errors\n\nPreviously, TypeScript would ignore most grammar errors in JavaScript apart from accidentally using TypeScript syntax in a JavaScript file. TypeScript now shows JavaScript syntax and binding errors in your file, such as using incorrect modifiers, duplicate declarations, and more. These will typically be most apparent in Visual Studio Code or Visual Studio, but can also occur when running JavaScript code through the TypeScript compiler.\n\nYou can explicitly turn these errors off by inserting a // @ts-nocheck comment at the top of your file.\n\nFor more information, see the first and second implementing pull requests for these features.\n\nOn this page\nAllowing Code in Constructors Before super()\nControl Flow Analysis for Destructured Discriminated Unions\nImproved Recursion Depth Checks\nIndexed Access Inference Improvements\nControl Flow Analysis for Dependent Parameters\n--target es2022\nRemoved Unnecessary Arguments in react-jsx\nJSDoc Name Suggestions\nMore Syntax and Binding Errors in JavaScript\nTypeScript Trace Analyzer\nBreaking Changes\nObject Rests Drop Unspreadable Members from Generic Objects\nJavaScript Files Always Receive Grammar and Binding Errors\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nAB\nDP\nN\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.616 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 5.2",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html",
    "html": "TypeScript 5.2\nusing\n Declarations and Explicit Resource Management\n\nTypeScript 5.2 adds support for the upcoming Explicit Resource Management feature in ECMAScript. Let’s explore some of the motivations and understand what the feature brings us.\n\nIt’s common to need to do some sort of “clean-up” after creating an object. For example, you might need to close network connections, delete temporary files, or just free up some memory.\n\nLet’s imagine a function that creates a temporary file, reads and writes to it for various operations, and then closes and deletes it.\n\nimport * as fs from \"fs\";\nexport function doSomeWork() {\n    const path = \".some_temp_file\";\n    const file = fs.openSync(path, \"w+\");\n    // use file...\n    // Close the file and delete it.\n    fs.closeSync(file);\n    fs.unlinkSync(path);\n}\n\nThis is fine, but what happens if we need to perform an early exit?\n\nexport function doSomeWork() {\n    const path = \".some_temp_file\";\n    const file = fs.openSync(path, \"w+\");\n    // use file...\n    if (someCondition()) {\n        // do some more work...\n        // Close the file and delete it.\n        fs.closeSync(file);\n        fs.unlinkSync(path);\n        return;\n    }\n    // Close the file and delete it.\n    fs.closeSync(file);\n    fs.unlinkSync(path);\n}\n\nWe’re starting to see some duplication of clean-up which can be easy to forget. We’re also not guaranteed to close and delete the file if an error gets thrown. This could be solved by wrapping this all in a try/finally block.\n\nexport function doSomeWork() {\n    const path = \".some_temp_file\";\n    const file = fs.openSync(path, \"w+\");\n    try {\n        // use file...\n        if (someCondition()) {\n            // do some more work...\n            return;\n        }\n    }\n    finally {\n        // Close the file and delete it.\n        fs.closeSync(file);\n        fs.unlinkSync(path);\n    }\n}\n\nWhile this is more robust, it’s added quite a bit of “noise” to our code. There are also other foot-guns we can run into if we start adding more clean-up logic to our finally block — for example, exceptions preventing other resources from being disposed. This is what the explicit resource management proposal aims to solve. The key idea of the proposal is to support resource disposal — this clean-up work we’re trying to deal with — as a first class idea in JavaScript.\n\nThis starts by adding a new built-in symbol called Symbol.dispose, and we can create objects with methods named by Symbol.dispose. For convenience, TypeScript defines a new global type called Disposable which describes these.\n\nclass TempFile implements Disposable {\n    #path: string;\n    #handle: number;\n    constructor(path: string) {\n        this.#path = path;\n        this.#handle = fs.openSync(path, \"w+\");\n    }\n    // other methods\n    [Symbol.dispose]() {\n        // Close the file and delete it.\n        fs.closeSync(this.#handle);\n        fs.unlinkSync(this.#path);\n    }\n}\n\nLater on we can call those methods.\n\nexport function doSomeWork() {\n    const file = new TempFile(\".some_temp_file\");\n    try {\n        // ...\n    }\n    finally {\n        file[Symbol.dispose]();\n    }\n}\n\nMoving the clean-up logic to TempFile itself doesn’t buy us much; we’ve basically just moved all the clean-up work from the finally block into a method, and that’s always been possible. But having a well-known “name” for this method means that JavaScript can build other features on top of it.\n\nThat brings us to the first star of the feature: using declarations! using is a new keyword that lets us declare new fixed bindings, kind of like const. The key difference is that variables declared with using get their Symbol.dispose method called at the end of the scope!\n\nSo we could simply have written our code like this:\n\nexport function doSomeWork() {\n    using file = new TempFile(\".some_temp_file\");\n    // use file...\n    if (someCondition()) {\n        // do some more work...\n        return;\n    }\n}\n\nCheck it out — no try/finally blocks! At least, none that we see. Functionally, that’s exactly what using declarations will do for us, but we don’t have to deal with that.\n\nYou might be familiar with using declarations in C#, with statements in Python, or try-with-resource declarations in Java. These are all similar to JavaScript’s new using keyword, and provide a similar explicit way to perform a “tear-down” of an object at the end of a scope.\n\nusing declarations do this clean-up at the very end of their containing scope or right before an “early return” like a return or a thrown error. They also dispose in a first-in-last-out order like a stack.\n\nfunction loggy(id: string): Disposable {\n    console.log(`Creating ${id}`);\n    return {\n        [Symbol.dispose]() {\n            console.log(`Disposing ${id}`);\n        }\n    }\n}\nfunction func() {\n    using a = loggy(\"a\");\n    using b = loggy(\"b\");\n    {\n        using c = loggy(\"c\");\n        using d = loggy(\"d\");\n    }\n    using e = loggy(\"e\");\n    return;\n    // Unreachable.\n    // Never created, never disposed.\n    using f = loggy(\"f\");\n}\nfunc();\n// Creating a\n// Creating b\n// Creating c\n// Creating d\n// Disposing d\n// Disposing c\n// Creating e\n// Disposing e\n// Disposing b\n// Disposing a\n\nusing declarations are supposed to be resilient to exceptions; if an error is thrown, it’s rethrown after disposal. On the other hand, the body of your function might execute as expected, but the Symbol.dispose might throw. In that case, that exception is rethrown as well.\n\nBut what happens if both the logic before and during disposal throws an error? For those cases, SuppressedError has been introduced as a new subtype of Error. It features a suppressed property that holds the last-thrown error, and an error property for the most-recently thrown error.\n\nclass ErrorA extends Error {\n    name = \"ErrorA\";\n}\nclass ErrorB extends Error {\n    name = \"ErrorB\";\n}\nfunction throwy(id: string) {\n    return {\n        [Symbol.dispose]() {\n            throw new ErrorA(`Error from ${id}`);\n        }\n    };\n}\nfunction func() {\n    using a = throwy(\"a\");\n    throw new ErrorB(\"oops!\")\n}\ntry {\n    func();\n}\ncatch (e: any) {\n    console.log(e.name); // SuppressedError\n    console.log(e.message); // An error was suppressed during disposal.\n    console.log(e.error.name); // ErrorA\n    console.log(e.error.message); // Error from a\n    console.log(e.suppressed.name); // ErrorB\n    console.log(e.suppressed.message); // oops!\n}\n\nYou might have noticed that we’re using synchronous methods in these examples. However, lots of resource disposal involves asynchronous operations, and we need to wait for those to complete before we continue running any other code.\n\nThat’s why there is also a new Symbol.asyncDispose, and it brings us to the next star of the show — await using declarations. These are similar to using declarations, but the key is that they look up whose disposal must be awaited. They use a different method named by Symbol.asyncDispose, though they can operate on anything with a Symbol.dispose as well. For convenience, TypeScript also introduces a global type called AsyncDisposable that describes any object with an asynchronous dispose method.\n\nasync function doWork() {\n    // Do fake work for half a second.\n    await new Promise(resolve => setTimeout(resolve, 500));\n}\nfunction loggy(id: string): AsyncDisposable {\n    console.log(`Constructing ${id}`);\n    return {\n        async [Symbol.asyncDispose]() {\n            console.log(`Disposing (async) ${id}`);\n            await doWork();\n        },\n    }\n}\nasync function func() {\n    await using a = loggy(\"a\");\n    await using b = loggy(\"b\");\n    {\n        await using c = loggy(\"c\");\n        await using d = loggy(\"d\");\n    }\n    await using e = loggy(\"e\");\n    return;\n    // Unreachable.\n    // Never created, never disposed.\n    await using f = loggy(\"f\");\n}\nfunc();\n// Constructing a\n// Constructing b\n// Constructing c\n// Constructing d\n// Disposing (async) d\n// Disposing (async) c\n// Constructing e\n// Disposing (async) e\n// Disposing (async) b\n// Disposing (async) a\n\nDefining types in terms of Disposable and AsyncDisposable can make your code much easier to work with if you expect others to do tear-down logic consistently. In fact, lots of existing types exist in the wild which have a dispose() or close() method. For example, the Visual Studio Code APIs even define their own Disposable interface. APIs in the browser and in runtimes like Node.js, Deno, and Bun might also choose to use Symbol.dispose and Symbol.asyncDispose for objects which already have clean-up methods, like file handles, connections, and more.\n\nNow maybe this all sounds great for libraries, but a little bit heavy-weight for your scenarios. If you’re doing a lot of ad-hoc clean-up, creating a new type might introduce a lot of over-abstraction and questions about best-practices. For example, take our TempFile example again.\n\nclass TempFile implements Disposable {\n    #path: string;\n    #handle: number;\n    constructor(path: string) {\n        this.#path = path;\n        this.#handle = fs.openSync(path, \"w+\");\n    }\n    // other methods\n    [Symbol.dispose]() {\n        // Close the file and delete it.\n        fs.closeSync(this.#handle);\n        fs.unlinkSync(this.#path);\n    }\n}\nexport function doSomeWork() {\n    using file = new TempFile(\".some_temp_file\");\n    // use file...\n    if (someCondition()) {\n        // do some more work...\n        return;\n    }\n}\n\nAll we wanted was to remember to call two functions — but was this the best way to write it? Should we be calling openSync in the constructor, create an open() method, or pass in the handle ourselves? Should we expose a method for every possible operation we need to perform, or should we just make the properties public?\n\nThat brings us to the final stars of the feature: DisposableStack and AsyncDisposableStack. These objects are useful for doing both one-off clean-up, along with arbitrary amounts of cleanup. A DisposableStack is an object that has several methods for keeping track of Disposable objects, and can be given functions for doing arbitrary clean-up work. We can also assign them to using variables because — get this — they’re also Disposable! So here’s how we could’ve written the original example.\n\nfunction doSomeWork() {\n    const path = \".some_temp_file\";\n    const file = fs.openSync(path, \"w+\");\n    using cleanup = new DisposableStack();\n    cleanup.defer(() => {\n        fs.closeSync(file);\n        fs.unlinkSync(path);\n    });\n    // use file...\n    if (someCondition()) {\n        // do some more work...\n        return;\n    }\n    // ...\n}\n\nHere, the defer() method just takes a callback, and that callback will be run once cleanup is disposed of. Typically, defer (and other DisposableStack methods like use and adopt) should be called immediately after creating a resource. As the name suggests, DisposableStack disposes of everything it keeps track of like a stack, in a first-in-last-out order, so defering immediately after creating a value helps avoid odd dependency issues. AsyncDisposableStack works similarly, but can keep track of async functions and AsyncDisposables, and is itself an AsyncDisposable.\n\nThe defer method is similar in many ways to the defer keyword in Go, Swift, Zig, Odin, and others, where the conventions should be similar.\n\nBecause this feature is so recent, most runtimes will not support it natively. To use it, you will need runtime polyfills for the following:\n\nSymbol.dispose\nSymbol.asyncDispose\nDisposableStack\nAsyncDisposableStack\nSuppressedError\n\nHowever, if all you’re interested in is using and await using, you should be able to get away with only polyfilling the built-in symbols. Something as simple as the following should work for most cases:\n\nSymbol.dispose ??= Symbol(\"Symbol.dispose\");\nSymbol.asyncDispose ??= Symbol(\"Symbol.asyncDispose\");\n\nYou will also need to set your compilation target to es2022 or below, and configure your lib setting to either include \"esnext\" or \"esnext.disposable\".\n\n{\n    \"compilerOptions\": {\n        \"target\": \"es2022\",\n        \"lib\": [\"es2022\", \"esnext.disposable\", \"dom\"]\n    }\n}\n\nFor more information on this feature, take a look at the work on GitHub!\n\nDecorator Metadata\n\nTypeScript 5.2 implements an upcoming ECMAScript feature called decorator metadata.\n\nThe key idea of this feature is to make it easy for decorators to create and consume metadata on any class they’re used on or within.\n\nWhenever decorator functions are used, they now have access to a new metadata property on their context object. The metadata property just holds a simple object. Since JavaScript lets us add properties arbitrarily, it can be used as a dictionary that is updated by each decorator. Alternatively, since every metadata object will be identical for each decorated portion of a class, it can be used as a key into a Map. After all decorators on or in a class get run, that object can be accessed on the class via Symbol.metadata.\n\ninterface Context {\n    name: string;\n    metadata: Record<PropertyKey, unknown>;\n}\nfunction setMetadata(_target: any, context: Context) {\n    context.metadata[context.name] = true;\n}\nclass SomeClass {\n    @setMetadata\n    foo = 123;\n    @setMetadata\n    accessor bar = \"hello!\";\n    @setMetadata\n    baz() { }\n}\nconst ourMetadata = SomeClass[Symbol.metadata];\nconsole.log(JSON.stringify(ourMetadata));\n// { \"bar\": true, \"baz\": true, \"foo\": true }\n\nThis can be useful in a number of different scenarios. Metadata could possibly be attached for lots of uses like debugging, serialization, or performing dependency injection with decorators. Since metadata objects are created per decorated class, frameworks can either privately use them as keys into a Map or WeakMap, or tack properties on as necessary.\n\nFor example, let’s say we wanted to use decorators to keep track of which properties and accessors are serializable when using JSON.stringify like so:\n\nimport { serialize, jsonify } from \"./serializer\";\nclass Person {\n    firstName: string;\n    lastName: string;\n    @serialize\n    age: number\n    @serialize\n    get fullName() {\n        return `${this.firstName} ${this.lastName}`;\n    }\n    toJSON() {\n        return jsonify(this)\n    }\n    constructor(firstName: string, lastName: string, age: number) {\n        // ...\n    }\n}\n\nHere, the intent is that only age and fullName should be serialized because they are marked with the @serialize decorator. We define a toJSON method for this purpose, but it just calls out to jsonify which uses the metadata that @serialize created.\n\nHere’s an example of how the module ./serialize.ts might be defined:\n\nconst serializables = Symbol();\ntype Context =\n    | ClassAccessorDecoratorContext\n    | ClassGetterDecoratorContext\n    | ClassFieldDecoratorContext\n    ;\nexport function serialize(_target: any, context: Context): void {\n    if (context.static || context.private) {\n        throw new Error(\"Can only serialize public instance members.\")\n    }\n    if (typeof context.name === \"symbol\") {\n        throw new Error(\"Cannot serialize symbol-named properties.\");\n    }\n    const propNames =\n        (context.metadata[serializables] as string[] | undefined) ??= [];\n    propNames.push(context.name);\n}\nexport function jsonify(instance: object): string {\n    const metadata = instance.constructor[Symbol.metadata];\n    const propNames = metadata?.[serializables] as string[] | undefined;\n    if (!propNames) {\n        throw new Error(\"No members marked with @serialize.\");\n    }\n    const pairStrings = propNames.map(key => {\n        const strKey = JSON.stringify(key);\n        const strValue = JSON.stringify((instance as any)[key]);\n        return `${strKey}: ${strValue}`;\n    });\n    return `{ ${pairStrings.join(\", \")} }`;\n}\n\nThis module has a local symbol called serializables to store and retrieve the names of properties marked @serializable. It stores a list of these property names on the metadata on each invocation of @serializable. When jsonify is called, the list of properties is fetched off of the metadata and used to retrieve the actual values from the instance, eventually serializing those names and values.\n\nUsing a symbol technically makes this data accessible to others. An alternative might be to use a WeakMap using the metadata object as a key. This keeps data private and happens to use fewer type assertions in this case, but is otherwise similar.\n\nconst serializables = new WeakMap<object, string[]>();\ntype Context =\n    | ClassAccessorDecoratorContext\n    | ClassGetterDecoratorContext\n    | ClassFieldDecoratorContext\n    ;\nexport function serialize(_target: any, context: Context): void {\n    if (context.static || context.private) {\n        throw new Error(\"Can only serialize public instance members.\")\n    }\n    if (typeof context.name !== \"string\") {\n        throw new Error(\"Can only serialize string properties.\");\n    }\n    let propNames = serializables.get(context.metadata);\n    if (propNames === undefined) {\n        serializables.set(context.metadata, propNames = []);\n    }\n    propNames.push(context.name);\n}\nexport function jsonify(instance: object): string {\n    const metadata = instance.constructor[Symbol.metadata];\n    const propNames = metadata && serializables.get(metadata);\n    if (!propNames) {\n        throw new Error(\"No members marked with @serialize.\");\n    }\n    const pairStrings = propNames.map(key => {\n        const strKey = JSON.stringify(key);\n        const strValue = JSON.stringify((instance as any)[key]);\n        return `${strKey}: ${strValue}`;\n    });\n    return `{ ${pairStrings.join(\", \")} }`;\n}\n\nAs a note, these implementations don’t handle subclassing and inheritance. That’s left as an exercise to you (and you might find that it is easier in one version of the file than the other!).\n\nBecause this feature is still fresh, most runtimes will not support it natively. To use it, you will need a polyfill for Symbol.metadata. Something as simple as the following should work for most cases:\n\nSymbol.metadata ??= Symbol(\"Symbol.metadata\");\n\nYou will also need to set your compilation target to es2022 or below, and configure your lib setting to either include \"esnext\" or \"esnext.decorators\".\n\n{\n    \"compilerOptions\": {\n        \"target\": \"es2022\",\n        \"lib\": [\"es2022\", \"esnext.decorators\", \"dom\"]\n    }\n}\n\nWe’d like to thank Oleksandr Tarasiuk for contributing the implementation of decorator metadata for TypeScript 5.2!\n\nNamed and Anonymous Tuple Elements\n\nTuple types have supported optional labels or names for each element.\n\ntype Pair<T> = [first: T, second: T];\n\nThese labels don’t change what you’re allowed to do with them — they’re solely to help with readability and tooling.\n\nHowever, TypeScript previously had a rule that tuples could not mix and match between labeled and unlabeled elements. In other words, either no element could have a label in a tuple, or all elements needed one.\n\n// ✅ fine - no labels\ntype Pair1<T> = [T, T];\n// ✅ fine - all fully labeled\ntype Pair2<T> = [first: T, second: T];\n// ❌ previously an error\ntype Pair3<T> = [first: T, T];\n//                         ~\n// Tuple members must all have names\n// or all not have names.\n\nThis could be annoying for rest elements where we’d be forced to just add a label like rest or tail.\n\n// ❌ previously an error\ntype TwoOrMore_A<T> = [first: T, second: T, ...T[]];\n//                                          ~~~~~~\n// Tuple members must all have names\n// or all not have names.\n// ✅\ntype TwoOrMore_B<T> = [first: T, second: T, rest: ...T[]];\n\nIt also meant that this restriction had to be enforced internally in the type system, meaning TypeScript would lose labels.\n\ntype HasLabels = [a: string, b: string];\ntype HasNoLabels = [number, number];\ntype Merged = [...HasNoLabels, ...HasLabels];\n//   ^ [number, number, string, string]\n//\n//     'a' and 'b' were lost in 'Merged'\n\nIn TypeScript 5.2, the all-or-nothing restriction on tuple labels has been lifted. The language can now also preserve labels when spreading into an unlabeled tuple.\n\nWe’d like to extend our thanks to Josh Goldberg and Mateusz Burzyński who collaborated to lift this restriction.\n\nEasier Method Usage for Unions of Arrays\n\nIn previous versions on TypeScript, calling a method on a union of arrays could end in pain.\n\ndeclare let array: string[] | number[];\narray.filter(x => !!x);\n//    ~~~~~~ error!\n// This expression is not callable.\n//   Each member of the union type '...' has signatures,\n//   but none of those signatures are compatible\n//   with each other.\n\nIn this example, TypeScript would try to see if each version of filter is compatible across string[] and number[]. Without a coherent strategy, TypeScript threw its hands in the air and said “I can’t make it work”.\n\nIn TypeScript 5.2, before giving up in these cases, unions of arrays are treated as a special case. A new array type is constructed out of each member’s element type, and then the method is invoked on that.\n\nTaking the above example, string[] | number[] is transformed into (string | number)[] (or Array<string | number>), and filter is invoked on that type. There is a slight caveat which is that filter will produce an Array<string | number> instead of a string[] | number[]; but for a freshly produced value there is less risk of something “going wrong”.\n\nThis means lots of methods like filter, find, some, every, and reduce should all be invokable on unions of arrays in cases where they were not previously.\n\nYou can read up more details on the implementing pull request.\n\nType-Only Import Paths with TypeScript Implementation File Extensions\n\nTypeScript now allows both declaration and implementation file extensions to be included in type-only import paths, regardless of whether allowImportingTsExtensions is enabled.\n\nThis means that you can now write import type statements that use .ts, .mts, .cts, and .tsx file extensions.\n\nimport type { JustAType } from \"./justTypes.ts\";\nexport function f(param: JustAType) {\n    // ...\n}\n\nIt also means that import() types, which can be used in both TypeScript and JavaScript with JSDoc, can use those file extensions.\n\n/**\n * @param {import(\"./justTypes.ts\").JustAType} param\n */\nexport function f(param) {\n    // ...\n}\n\nFor more information, see the change here.\n\nComma Completions for Object Members\n\nIt can be easy to forget to add a comma when adding a new property to an object. Previously, if you forgot a comma and requested auto-completion, TypeScript would confusingly give poor unrelated completion results.\n\nTypeScript 5.2 now gracefully provides object member completions when you’re missing a comma. But to just skip past hitting you with a syntax error, it will also auto-insert the missing comma.\n\nFor more information, see the implementation here.\n\nInline Variable Refactoring\n\nTypeScript 5.2 now has a refactoring to inline the contents of a variable to all usage sites.\n\n.\n\nUsing the “inline variable” refactoring will eliminate the variable and replace all the variable’s usages with its initializer. Note that this may cause that initializer’s side-effects to run at a different time, and as many times as the variable has been used.\n\nFor more details, see the implementing pull request.\n\nOptimized Checks for Ongoing Type Compatibility\n\nBecause TypeScript is a structural type system, types occasionally need to be compared in a member-wise fashion; however, recursive types add some issues here. For example:\n\ninterface A {\n    value: A;\n    other: string;\n}\ninterface B {\n    value: B;\n    other: number;\n}\n\nWhen checking whether the type A is compatible with the type B, TypeScript will end up checking whether the types of value in A and B are respectively compatible. At this point, the type system needs to stop checking any further and proceed to check other members. To do this, the type system has to track when any two types are already being related.\n\nPreviously TypeScript already kept a stack of type pairs, and iterated through that to determine whether those types are being related. When this stack is shallow that’s not a problem; but when the stack isn’t shallow, that, uh, is a problem.\n\nIn TypeScript 5.3, a simple Set helps tracks this information. This reduced the time spent on a reported test case that used the drizzle library by over 33%!\n\nBenchmark 1: old\n  Time (mean ± σ):      3.115 s ±  0.067 s    [User: 4.403 s, System: 0.124 s]\n  Range (min … max):    3.018 s …  3.196 s    10 runs\n \nBenchmark 2: new\n  Time (mean ± σ):      2.072 s ±  0.050 s    [User: 3.355 s, System: 0.135 s]\n  Range (min … max):    1.985 s …  2.150 s    10 runs\n \nSummary\n  'new' ran\n    1.50 ± 0.05 times faster than 'old'\n\nRead more on the change here.\n\nBreaking Changes and Correctness Fixes\n\nTypeScript strives not to unnecessarily introduce breaks; however, occasionally we must make corrections and improvements so that code can be better-analyzed.\n\nlib.d.ts\n Changes\n\nTypes generated for the DOM may have an impact on your codebase. For more information, see the DOM updates for TypeScript 5.2.\n\nlabeledElementDeclarations\n May Hold \nundefined\n Elements\n\nIn order to support a mixture of labeled and unlabeled elements, TypeScript’s API has changed slightly. The labeledElementDeclarations property of TupleType may hold undefined for at each position where an element is unlabeled.\n\n  interface TupleType {\n-     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration)[];\n+     labeledElementDeclarations?: readonly (NamedTupleMember | ParameterDeclaration | undefined)[];\n  }\nmodule\n and \nmoduleResolution\n Must Match Under Recent Node.js settings\n\nThe --module and --moduleResolution options each support a node16 and nodenext setting. These are effectively “modern Node.js” settings that should be used on any recent Node.js project. What we’ve found is that when these two options don’t agree on whether they are using Node.js-related settings, projects are effectively misconfigured.\n\nIn TypeScript 5.2, when using node16 or nodenext for either of the --module and --moduleResolution options, TypeScript now requires the other to have a similar Node.js-related setting. In cases where the settings diverge, you’ll likely get an error message like either\n\nOption 'moduleResolution' must be set to 'NodeNext' (or left unspecified) when option 'module' is set to 'NodeNext'.\n\nor\n\nOption 'module' must be set to 'Node16' when option 'moduleResolution' is set to 'Node16'.\n\nSo for example --module esnext --moduleResolution node16 will be rejected — but you may be better off just using --module nodenext alone, or --module esnext --moduleResolution bundler.\n\nFor more information, see the change here.\n\nConsistent Export Checking for Merged Symbols\n\nWhen two declarations merge, they must agree in whether they are both exported. Due to a bug, TypeScript missed specific cases in ambient contexts, like in declaration files or declare module blocks. For example, it would not issue an error on a case like the following, where replaceInFile is declared once as an exported function, and one as an un-exported namespace.\n\ndeclare module 'replace-in-file' {\n    export function replaceInFile(config: unknown): Promise<unknown[]>;\n    export {};\n    namespace replaceInFile {\n        export function sync(config: unknown): unknown[];\n  }\n}\n\nIn an ambient module, adding an export { ... } or a similar construct like export default ... implicitly changes whether all declarations are automatically exported. TypeScript now recognizes these unfortunately confusing semantics more consistently, and issues an error on the fact that all declarations of replaceInFile need to agree in their modifiers, and will issue the following error:\n\nIndividual declarations in merged declaration 'replaceInFile' must be all exported or all local.\n\nFor more information, see the change here.\n\nOn this page\nusing Declarations and Explicit Resource Management\nDecorator Metadata\nNamed and Anonymous Tuple Elements\nEasier Method Usage for Unions of Arrays\nType-Only Import Paths with TypeScript Implementation File Extensions\nComma Completions for Object Members\nInline Variable Refactoring\nOptimized Checks for Ongoing Type Compatibility\nBreaking Changes and Correctness Fixes\nlib.d.ts Changes\nlabeledElementDeclarations May Hold undefined Elements\nmodule and moduleResolution Must Match Under Recent Node.js settings\nConsistent Export Checking for Merged Symbols\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.203 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 5.0",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-0.html",
    "html": "TypeScript 5.0\nDecorators\n\nDecorators are an upcoming ECMAScript feature that allow us to customize classes and their members in a reusable way.\n\nLet’s consider the following code:\n\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\nconst p = new Person(\"Ray\");\np.greet();\n\ngreet is pretty simple here, but let’s imagine it’s something way more complicated - maybe it does some async logic, it’s recursive, it has side effects, etc. Regardless of what kind of ball-of-mud you’re imagining, let’s say you throw in some console.log calls to help debug greet.\n\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    greet() {\n        console.log(\"LOG: Entering method.\");\n        console.log(`Hello, my name is ${this.name}.`);\n        console.log(\"LOG: Exiting method.\")\n    }\n}\n\nThis pattern is fairly common. It sure would be nice if there was a way we could do this for every method!\n\nThis is where decorators come in. We can write a function called loggedMethod that looks like the following:\n\nfunction loggedMethod(originalMethod: any, _context: any) {\n    function replacementMethod(this: any, ...args: any[]) {\n        console.log(\"LOG: Entering method.\")\n        const result = originalMethod.call(this, ...args);\n        console.log(\"LOG: Exiting method.\")\n        return result;\n    }\n    return replacementMethod;\n}\n\n“What’s the deal with all of these anys? What is this, anyScript!?”\n\nJust be patient - we’re keeping things simple for now so that we can focus on what this function is doing. Notice that loggedMethod takes the original method (originalMethod) and returns a function that\n\nlogs an “Entering…” message\npasses along this and all of its arguments to the original method\nlogs an “Exiting…” message, and\nreturns whatever the original method returned.\n\nNow we can use loggedMethod to decorate the method greet:\n\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    @loggedMethod\n    greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\nconst p = new Person(\"Ray\");\np.greet();\n// Output:\n//\n//   LOG: Entering method.\n//   Hello, my name is Ray.\n//   LOG: Exiting method.\n\nWe just used loggedMethod as a decorator above greet - and notice that we wrote it as @loggedMethod. When we did that, it got called with the method target and a context object. Because loggedMethod returned a new function, that function replaced the original definition of greet.\n\nWe didn’t mention it yet, but loggedMethod was defined with a second parameter. It’s called a “context object”, and it has some useful information about how the decorated method was declared - like whether it was a #private member, or static, or what the name of the method was. Let’s rewrite loggedMethod to take advantage of that and print out the name of the method that was decorated.\n\nfunction loggedMethod(originalMethod: any, context: ClassMethodDecoratorContext) {\n    const methodName = String(context.name);\n    function replacementMethod(this: any, ...args: any[]) {\n        console.log(`LOG: Entering method '${methodName}'.`)\n        const result = originalMethod.call(this, ...args);\n        console.log(`LOG: Exiting method '${methodName}'.`)\n        return result;\n    }\n    return replacementMethod;\n}\n\nWe’re now using the context parameter - and that it’s the first thing in loggedMethod that has a type stricter than any and any[]. TypeScript provides a type called ClassMethodDecoratorContext that models the context object that method decorators take.\n\nApart from metadata, the context object for methods also has a useful function called addInitializer. It’s a way to hook into the beginning of the constructor (or the initialization of the class itself if we’re working with statics).\n\nAs an example - in JavaScript, it’s common to write something like the following pattern:\n\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n        this.greet = this.greet.bind(this);\n    }\n    greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\n\nAlternatively, greet might be declared as a property initialized to an arrow function.\n\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    greet = () => {\n        console.log(`Hello, my name is ${this.name}.`);\n    };\n}\n\nThis code is written to ensure that this isn’t re-bound if greet is called as a stand-alone function or passed as a callback.\n\nconst greet = new Person(\"Ray\").greet;\n// We don't want this to fail!\ngreet();\n\nWe can write a decorator that uses addInitializer to call bind in the constructor for us.\n\nfunction bound(originalMethod: any, context: ClassMethodDecoratorContext) {\n    const methodName = context.name;\n    if (context.private) {\n        throw new Error(`'bound' cannot decorate private properties like ${methodName as string}.`);\n    }\n    context.addInitializer(function () {\n        this[methodName] = this[methodName].bind(this);\n    });\n}\n\nbound isn’t returning anything - so when it decorates a method, it leaves the original alone. Instead, it will add logic before any other fields are initialized.\n\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    @bound\n    @loggedMethod\n    greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\nconst p = new Person(\"Ray\");\nconst greet = p.greet;\n// Works!\ngreet();\n\nNotice that we stacked two decorators - @bound and @loggedMethod. These decorations run in “reverse order”. That is, @loggedMethod decorates the original method greet, and @bound decorates the result of @loggedMethod. In this example, it doesn’t matter - but it could if your decorators have side-effects or expect a certain order.\n\nAlso worth noting - if you’d prefer stylistically, you can put these decorators on the same line.\n\n    @bound @loggedMethod greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n\nSomething that might not be obvious is that we can even make functions that return decorator functions. That makes it possible to customize the final decorator just a little. If we wanted, we could have made loggedMethod return a decorator and customize how it logs its messages.\n\nfunction loggedMethod(headMessage = \"LOG:\") {\n    return function actualDecorator(originalMethod: any, context: ClassMethodDecoratorContext) {\n        const methodName = String(context.name);\n        function replacementMethod(this: any, ...args: any[]) {\n            console.log(`${headMessage} Entering method '${methodName}'.`)\n            const result = originalMethod.call(this, ...args);\n            console.log(`${headMessage} Exiting method '${methodName}'.`)\n            return result;\n        }\n        return replacementMethod;\n    }\n}\n\nIf we did that, we’d have to call loggedMethod before using it as a decorator. We could then pass in any string as the prefix for messages that get logged to the console.\n\nclass Person {\n    name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n    @loggedMethod(\"⚠️\")\n    greet() {\n        console.log(`Hello, my name is ${this.name}.`);\n    }\n}\nconst p = new Person(\"Ray\");\np.greet();\n// Output:\n//\n//   ⚠️ Entering method 'greet'.\n//   Hello, my name is Ray.\n//   ⚠️ Exiting method 'greet'.\n\nDecorators can be used on more than just methods! They can be used on properties/fields, getters, setters, and auto-accessors. Even classes themselves can be decorated for things like subclassing and registration.\n\nTo learn more about decorators in-depth, you can read up on Axel Rauschmayer’s extensive summary.\n\nFor more information about the changes involved, you can view the original pull request.\n\nDifferences with Experimental Legacy Decorators\n\nIf you’ve been using TypeScript for a while, you might be aware of the fact that it’s had support for “experimental” decorators for years. While these experimental decorators have been incredibly useful, they modeled a much older version of the decorators proposal, and always required an opt-in compiler flag called --experimentalDecorators. Any attempt to use decorators in TypeScript without this flag used to prompt an error message.\n\n--experimentalDecorators will continue to exist for the foreseeable future; however, without the flag, decorators will now be valid syntax for all new code. Outside of --experimentalDecorators, they will be type-checked and emitted differently. The type-checking rules and emit are sufficiently different that while decorators can be written to support both the old and new decorators behavior, any existing decorator functions are not likely to do so.\n\nThis new decorators proposal is not compatible with --emitDecoratorMetadata, and it does not allow decorating parameters. Future ECMAScript proposals may be able to help bridge that gap.\n\nOn a final note: in addition to allowing decorators to be placed before the export keyword, the proposal for decorators now provides the option of placing decorators after export or export default. The only exception is that mixing the two styles is not allowed.\n\n// ✅ allowed\n@register export default class Foo {\n    // ...\n}\n// ✅ also allowed\nexport default @register class Bar {\n    // ...\n}\n// ❌ error - before *and* after is not allowed\n@before export @after class Bar {\n    // ...\n}\nWriting Well-Typed Decorators\n\nThe loggedMethod and bound decorator examples above are intentionally simple and omit lots of details about types.\n\nTyping decorators can be fairly complex. For example, a well-typed version of loggedMethod from above might look something like this:\n\nfunction loggedMethod<This, Args extends any[], Return>(\n    target: (this: This, ...args: Args) => Return,\n    context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>\n) {\n    const methodName = String(context.name);\n    function replacementMethod(this: This, ...args: Args): Return {\n        console.log(`LOG: Entering method '${methodName}'.`)\n        const result = target.call(this, ...args);\n        console.log(`LOG: Exiting method '${methodName}'.`)\n        return result;\n    }\n    return replacementMethod;\n}\n\nWe had to separately model out the type of this, the parameters, and the return type of the original method, using the type parameters This, Args, and Return.\n\nExactly how complex your decorators functions are defined depends on what you want to guarantee. Just keep in mind, your decorators will be used more than they’re written, so a well-typed version will usually be preferable - but there’s clearly a trade-off with readability, so try to keep things simple.\n\nMore documentation on writing decorators will be available in the future - but this post should have a good amount of detail for the mechanics of decorators.\n\nconst\n Type Parameters\n\nWhen inferring the type of an object, TypeScript will usually choose a type that’s meant to be general. For example, in this case, the inferred type of names is string[]:\n\ntype HasNames = { names: readonly string[] };\nfunction getNamesExactly<T extends HasNames>(arg: T): T[\"names\"] {\n    return arg.names;\n}\n// Inferred type: string[]\nconst names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});\n\nUsually the intent of this is to enable mutation down the line.\n\nHowever, depending on what exactly getNamesExactly does and how it’s intended to be used, it can often be the case that a more-specific type is desired.\n\nUp until now, API authors have typically had to recommend adding as const in certain places to achieve the desired inference:\n\n// The type we wanted:\n//    readonly [\"Alice\", \"Bob\", \"Eve\"]\n// The type we got:\n//    string[]\nconst names1 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]});\n// Correctly gets what we wanted:\n//    readonly [\"Alice\", \"Bob\", \"Eve\"]\nconst names2 = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"]} as const);\n\nThis can be cumbersome and easy to forget. In TypeScript 5.0, you can now add a const modifier to a type parameter declaration to cause const-like inference to be the default:\n\ntype HasNames = { names: readonly string[] };\nfunction getNamesExactly<const T extends HasNames>(arg: T): T[\"names\"] {\n//                       ^^^^^\n    return arg.names;\n}\n// Inferred type: readonly [\"Alice\", \"Bob\", \"Eve\"]\n// Note: Didn't need to write 'as const' here\nconst names = getNamesExactly({ names: [\"Alice\", \"Bob\", \"Eve\"] });\n\nNote that the const modifier doesn’t reject mutable values, and doesn’t require immutable constraints. Using a mutable type constraint might give surprising results. For example:\n\ndeclare function fnBad<const T extends string[]>(args: T): void;\n// 'T' is still 'string[]' since 'readonly [\"a\", \"b\", \"c\"]' is not assignable to 'string[]'\nfnBad([\"a\", \"b\" ,\"c\"]);\n\nHere, the inferred candidate for T is readonly [\"a\", \"b\", \"c\"], and a readonly array can’t be used where a mutable one is needed. In this case, inference falls back to the constraint, the array is treated as string[], and the call still proceeds successfully.\n\nA better definition of this function should use readonly string[]:\n\ndeclare function fnGood<const T extends readonly string[]>(args: T): void;\n// T is readonly [\"a\", \"b\", \"c\"]\nfnGood([\"a\", \"b\" ,\"c\"]);\n\nSimilarly, remember to keep in mind that the const modifier only affects inference of object, array and primitive expressions that were written within the call, so arguments which wouldn’t (or couldn’t) be modified with as const won’t see any change in behavior:\n\ndeclare function fnGood<const T extends readonly string[]>(args: T): void;\nconst arr = [\"a\", \"b\" ,\"c\"];\n// 'T' is still 'string[]'-- the 'const' modifier has no effect here\nfnGood(arr);\n\nSee the pull request and the (first and second second) motivating issues for more details.\n\nSupporting Multiple Configuration Files in \nextends\n\nWhen managing multiple projects, it can be helpful to have a “base” configuration file that other tsconfig.json files can extend from. That’s why TypeScript supports an extends field for copying over fields from compilerOptions.\n\n// packages/front-end/src/tsconfig.json\n{\n    \"extends\": \"../../../tsconfig.base.json\",\n    \"compilerOptions\": {\n        \"outDir\": \"../lib\",\n        // ...\n    }\n}\n\nHowever, there are scenarios where you might want to extend from multiple configuration files. For example, imagine using a TypeScript base configuration file shipped to npm. If you want all your projects to also use the options from the @tsconfig/strictest package on npm, then there’s a simple solution: have tsconfig.base.json extend from @tsconfig/strictest:\n\n// tsconfig.base.json\n{\n    \"extends\": \"@tsconfig/strictest/tsconfig.json\",\n    \"compilerOptions\": {\n        // ...\n    }\n}\n\nThis works to a point. If you have any projects that don’t want to use @tsconfig/strictest, they have to either manually disable the options, or create a separate version of tsconfig.base.json that doesn’t extend from @tsconfig/strictest.\n\nTo give some more flexibility here, Typescript 5.0 now allows the extends field to take multiple entries. For example, in this configuration file:\n\n{\n    \"extends\": [\"a\", \"b\", \"c\"],\n    \"compilerOptions\": {\n        // ...\n    }\n}\n\nWriting this is kind of like extending c directly, where c extends b, and b extends a. If any fields “conflict”, the latter entry wins.\n\nSo in the following example, both strictNullChecks and noImplicitAny are enabled in the final tsconfig.json.\n\n// tsconfig1.json\n{\n    \"compilerOptions\": {\n        \"strictNullChecks\": true\n    }\n}\n// tsconfig2.json\n{\n    \"compilerOptions\": {\n        \"noImplicitAny\": true\n    }\n}\n// tsconfig.json\n{\n    \"extends\": [\"./tsconfig1.json\", \"./tsconfig2.json\"],\n    \"files\": [\"./index.ts\"]\n}\n\nAs another example, we can rewrite our original example in the following way.\n\n// packages/front-end/src/tsconfig.json\n{\n    \"extends\": [\"@tsconfig/strictest/tsconfig.json\", \"../../../tsconfig.base.json\"],\n    \"compilerOptions\": {\n        \"outDir\": \"../lib\",\n        // ...\n    }\n}\n\nFor more details, read more on the original pull request.\n\nAll \nenum\ns Are Union \nenum\ns\n\nWhen TypeScript originally introduced enums, they were nothing more than a set of numeric constants with the same type.\n\nenum E {\n    Foo = 10,\n    Bar = 20,\n}\n\nThe only thing special about E.Foo and E.Bar was that they were assignable to anything expecting the type E. Other than that, they were pretty much just numbers.\n\nfunction takeValue(e: E) {}\ntakeValue(E.Foo); // works\ntakeValue(123); // error!\n\nIt wasn’t until TypeScript 2.0 introduced enum literal types that enums got a bit more special. Enum literal types gave each enum member its own type, and turned the enum itself into a union of each member type. They also allowed us to refer to only a subset of the types of an enum, and to narrow away those types.\n\n// Color is like a union of Red | Orange | Yellow | Green | Blue | Violet\nenum Color {\n    Red, Orange, Yellow, Green, Blue, /* Indigo, */ Violet\n}\n// Each enum member has its own type that we can refer to!\ntype PrimaryColor = Color.Red | Color.Green | Color.Blue;\nfunction isPrimaryColor(c: Color): c is PrimaryColor {\n    // Narrowing literal types can catch bugs.\n    // TypeScript will error here because\n    // we'll end up comparing 'Color.Red' to 'Color.Green'.\n    // We meant to use ||, but accidentally wrote &&.\n    return c === Color.Red && c === Color.Green && c === Color.Blue;\n}\n\nOne issue with giving each enum member its own type was that those types were in some part associated with the actual value of the member. In some cases it’s not possible to compute that value - for instance, an enum member could be initialized by a function call.\n\nenum E {\n    Blah = Math.random()\n}\n\nWhenever TypeScript ran into these issues, it would quietly back out and use the old enum strategy. That meant giving up all the advantages of unions and literal types.\n\nTypeScript 5.0 manages to make all enums into union enums by creating a unique type for each computed member. That means that all enums can now be narrowed and have their members referenced as types as well.\n\nFor more details on this change, you can read the specifics on GitHub.\n\n--moduleResolution bundler\n\nTypeScript 4.7 introduced the node16 and nodenext options for its --module and --moduleResolution settings. The intent of these options was to better model the precise lookup rules for ECMAScript modules in Node.js; however, this mode has many restrictions that other tools don’t really enforce.\n\nFor example, in an ECMAScript module in Node.js, any relative import needs to include a file extension.\n\n// entry.mjs\nimport * as utils from \"./utils\";     // ❌ wrong - we need to include the file extension.\nimport * as utils from \"./utils.mjs\"; // ✅ works\n\nThere are certain reasons for this in Node.js and the browser - it makes file lookups faster and works better for naive file servers. But for many developers using tools like bundlers, the node16/nodenext settings were cumbersome because bundlers don’t have most of these restrictions. In some ways, the node resolution mode was better for anyone using a bundler.\n\nBut in some ways, the original node resolution mode was already out of date. Most modern bundlers use a fusion of the ECMAScript module and CommonJS lookup rules in Node.js. For example, extensionless imports work just fine just like in CommonJS, but when looking through the export conditions of a package, they’ll prefer an import condition just like in an ECMAScript file.\n\nTo model how bundlers work, TypeScript now introduces a new strategy: --moduleResolution bundler.\n\n{\n    \"compilerOptions\": {\n        \"target\": \"esnext\",\n        \"moduleResolution\": \"bundler\"\n    }\n}\n\nIf you are using a modern bundler like Vite, esbuild, swc, Webpack, Parcel, and others that implement a hybrid lookup strategy, the new bundler option should be a good fit for you.\n\nOn the other hand, if you’re writing a library that’s meant to be published on npm, using the bundler option can hide compatibility issues that may arise for your users who aren’t using a bundler. So in these cases, using the node16 or nodenext resolution options is likely to be a better path.\n\nTo read more on --moduleResolution bundler, take a look at the implementing pull request.\n\nResolution Customization Flags\n\nJavaScript tooling may now model “hybrid” resolution rules, like in the bundler mode we described above. Because tools may differ in their support slightly, TypeScript 5.0 provides ways to enable or disable a few features that may or may not work with your configuration.\n\nallowImportingTsExtensions\n\n--allowImportingTsExtensions allows TypeScript files to import each other with a TypeScript-specific extension like .ts, .mts, or .tsx.\n\nThis flag is only allowed when --noEmit or --emitDeclarationOnly is enabled, since these import paths would not be resolvable at runtime in JavaScript output files. The expectation here is that your resolver (e.g. your bundler, a runtime, or some other tool) is going to make these imports between .ts files work.\n\nresolvePackageJsonExports\n\n--resolvePackageJsonExports forces TypeScript to consult the exports field of package.json files if it ever reads from a package in node_modules.\n\nThis option defaults to true under the node16, nodenext, and bundler options for --moduleResolution.\n\nresolvePackageJsonImports\n\n--resolvePackageJsonImports forces TypeScript to consult the imports field of package.json files when performing a lookup that starts with # from a file whose ancestor directory contains a package.json.\n\nThis option defaults to true under the node16, nodenext, and bundler options for --moduleResolution.\n\nallowArbitraryExtensions\n\nIn TypeScript 5.0, when an import path ends in an extension that isn’t a known JavaScript or TypeScript file extension, the compiler will look for a declaration file for that path in the form of {file basename}.d.{extension}.ts. For example, if you are using a CSS loader in a bundler project, you might want to write (or generate) declaration files for those stylesheets:\n\n/* app.css */\n.cookie-banner {\n  display: none;\n}\n// app.d.css.ts\ndeclare const css: {\n  cookieBanner: string;\n};\nexport default css;\n// App.tsx\nimport styles from \"./app.css\";\nstyles.cookieBanner; // string\n\nBy default, this import will raise an error to let you know that TypeScript doesn’t understand this file type and your runtime might not support importing it. But if you’ve configured your runtime or bundler to handle it, you can suppress the error with the new --allowArbitraryExtensions compiler option.\n\nNote that historically, a similar effect has often been achievable by adding a declaration file named app.css.d.ts instead of app.d.css.ts - however, this just worked through Node’s require resolution rules for CommonJS. Strictly speaking, the former is interpreted as a declaration file for a JavaScript file named app.css.js. Because relative files imports need to include extensions in Node’s ESM support, TypeScript would error on our example in an ESM file under --moduleResolution node16 or nodenext.\n\nFor more information, read up the proposalfor this feature and its corresponding pull request.\n\ncustomConditions\n\n--customConditions takes a list of additional conditions that should succeed when TypeScript resolves from an exports or imports field of a package.json. These conditions are added to whatever existing conditions a resolver will use by default.\n\nFor example, when this field is set in a tsconfig.json as so:\n\n{\n    \"compilerOptions\": {\n        \"target\": \"es2022\",\n        \"moduleResolution\": \"bundler\",\n        \"customConditions\": [\"my-condition\"]\n    }\n}\n\nAny time an exports or imports field is referenced in package.json, TypeScript will consider conditions called my-condition.\n\nSo when importing from a package with the following package.json\n\n{\n    // ...\n    \"exports\": {\n        \".\": {\n            \"my-condition\": \"./foo.mjs\",\n            \"node\": \"./bar.mjs\",\n            \"import\": \"./baz.mjs\",\n            \"require\": \"./biz.mjs\"\n        }\n    }\n}\n\nTypeScript will try to look for files corresponding to foo.mjs.\n\nThis field is only valid under the node16, nodenext, and bundler options for --moduleResolution\n\n--verbatimModuleSyntax\n\nBy default, TypeScript does something called import elision. Basically, if you write something like\n\nimport { Car } from \"./car\";\nexport function drive(car: Car) {\n    // ...\n}\n\nTypeScript detects that you’re only using an import for types and drops the import entirely. Your output JavaScript might look something like this:\n\nexport function drive(car) {\n    // ...\n}\n\nMost of the time this is good, because if Car isn’t a value that’s exported from ./car, we’ll get a runtime error.\n\nBut it does add a layer of complexity for certain edge cases. For example, notice there’s no statement like import \"./car\"; - the import was dropped entirely. That actually makes a difference for modules that have side-effects or not.\n\nTypeScript’s emit strategy for JavaScript also has another few layers of complexity - import elision isn’t always just driven by how an import is used - it often consults how a value is declared as well. So it’s not always clear whether code like the following\n\nexport { Car } from \"./car\";\n\nshould be preserved or dropped. If Car is declared with something like a class, then it can be preserved in the resulting JavaScript file. But if Car is only declared as a type alias or interface, then the JavaScript file shouldn’t export Car at all.\n\nWhile TypeScript might be able to make these emit decisions based on information from across files, not every compiler can.\n\nThe type modifier on imports and exports helps with these situations a bit. We can make it explicit whether an import or export is only being used for type analysis, and can be dropped entirely in JavaScript files by using the type modifier.\n\n// This statement can be dropped entirely in JS output\nimport type * as car from \"./car\";\n// The named import/export 'Car' can be dropped in JS output\nimport { type Car } from \"./car\";\nexport { type Car } from \"./car\";\n\ntype modifiers are not quite useful on their own - by default, module elision will still drop imports, and nothing forces you to make the distinction between type and plain imports and exports. So TypeScript has the flag --importsNotUsedAsValues to make sure you use the type modifier, --preserveValueImports to prevent some module elision behavior, and --isolatedModules to make sure that your TypeScript code works across different compilers. Unfortunately, understanding the fine details of those 3 flags is hard, and there are still some edge cases with unexpected behavior.\n\nTypeScript 5.0 introduces a new option called --verbatimModuleSyntax to simplify the situation. The rules are much simpler - any imports or exports without a type modifier are left around. Anything that uses the type modifier is dropped entirely.\n\n// Erased away entirely.\nimport type { A } from \"a\";\n// Rewritten to 'import { b } from \"bcd\";'\nimport { b, type c, type d } from \"bcd\";\n// Rewritten to 'import {} from \"xyz\";'\nimport { type xyz } from \"xyz\";\n\nWith this new option, what you see is what you get.\n\nThat does have some implications when it comes to module interop though. Under this flag, ECMAScript imports and exports won’t be rewritten to require calls when your settings or file extension implied a different module system. Instead, you’ll get an error. If you need to emit code that uses require and module.exports, you’ll have to use TypeScript’s module syntax that predates ES2015:\n\nInput TypeScript\tOutput JavaScript\n\nimport foo = require(\"foo\");\n\t\nconst foo = require(\"foo\");\n\n\nfunction foo() {}\nfunction bar() {}\nfunction baz() {}\nexport = {\n    foo,\n    bar,\n    baz\n};\n\t\nfunction foo() {}\nfunction bar() {}\nfunction baz() {}\nmodule.exports = {\n    foo,\n    bar,\n    baz\n};\n\nWhile this is a limitation, it does help make some issues more obvious. For example, it’s very common to forget to set the type field in package.json under --module node16. As a result, developers would start writing CommonJS modules instead of an ES modules without realizing it, giving surprising lookup rules and JavaScript output. This new flag ensures that you’re intentional about the file type you’re using because the syntax is intentionally different.\n\nBecause --verbatimModuleSyntax provides a more consistent story than --importsNotUsedAsValues and --preserveValueImports, those two existing flags are being deprecated in its favor.\n\nFor more details, read up on [the original pull request]https://github.com/microsoft/TypeScript/pull/52203 and its proposal issue.\n\nSupport for \nexport type *\n\nWhen TypeScript 3.8 introduced type-only imports, the new syntax wasn’t allowed on export * from \"module\" or export * as ns from \"module\" re-exports. TypeScript 5.0 adds support for both of these forms:\n\n// models/vehicles.ts\nexport class Spaceship {\n  // ...\n}\n// models/index.ts\nexport type * as vehicles from \"./vehicles\";\n// main.ts\nimport { vehicles } from \"./models\";\nfunction takeASpaceship(s: vehicles.Spaceship) {\n  // ✅ ok - `vehicles` only used in a type position\n}\nfunction makeASpaceship() {\n  return new vehicles.Spaceship();\n  //         ^^^^^^^^\n  // 'vehicles' cannot be used as a value because it was exported using 'export type'.\n}\n\nYou can read more about the implementation here.\n\n@satisfies\n Support in JSDoc\n\nTypeScript 4.9 introduced the satisfies operator. It made sure that the type of an expression was compatible, without affecting the type itself. For example, let’s take the following code:\n\ninterface CompilerOptions {\n    strict?: boolean;\n    outDir?: string;\n    // ...\n}\ninterface ConfigSettings {\n    compilerOptions?: CompilerOptions;\n    extends?: string | string[];\n    // ...\n}\nlet myConfigSettings = {\n    compilerOptions: {\n        strict: true,\n        outDir: \"../lib\",\n        // ...\n    },\n    extends: [\n        \"@tsconfig/strictest/tsconfig.json\",\n        \"../../../tsconfig.base.json\"\n    ],\n} satisfies ConfigSettings;\n\nHere, TypeScript knows that myConfigSettings.extends was declared with an array - because while satisfies validated the type of our object, it didn’t bluntly change it to CompilerOptions and lose information. So if we want to map over extends, that’s fine.\n\ndeclare function resolveConfig(configPath: string): CompilerOptions;\nlet inheritedConfigs = myConfigSettings.extends.map(resolveConfig);\n\nThis was helpful for TypeScript users, but plenty of people use TypeScript to type-check their JavaScript code using JSDoc annotations. That’s why TypeScript 5.0 is supporting a new JSDoc tag called @satisfies that does exactly the same thing.\n\n/** @satisfies */ can catch type mismatches:\n\n// @ts-check\n/**\n * @typedef CompilerOptions\n * @prop {boolean} [strict]\n * @prop {string} [outDir]\n */\n/**\n * @satisfies {CompilerOptions}\n */\nlet myCompilerOptions = {\n    outdir: \"../lib\",\n//  ~~~~~~ oops! we meant outDir\n};\n\nBut it will preserve the original type of our expressions, allowing us to use our values more precisely later on in our code.\n\n// @ts-check\n/**\n * @typedef CompilerOptions\n * @prop {boolean} [strict]\n * @prop {string} [outDir]\n */\n/**\n * @typedef ConfigSettings\n * @prop {CompilerOptions} [compilerOptions]\n * @prop {string | string[]} [extends]\n */\n/**\n * @satisfies {ConfigSettings}\n */\nlet myConfigSettings = {\n    compilerOptions: {\n        strict: true,\n        outDir: \"../lib\",\n    },\n    extends: [\n        \"@tsconfig/strictest/tsconfig.json\",\n        \"../../../tsconfig.base.json\"\n    ],\n};\nlet inheritedConfigs = myConfigSettings.extends.map(resolveConfig);\n\n/** @satisfies */ can also be used inline on any parenthesized expression. We could have written myCompilerOptions like this:\n\nlet myConfigSettings = /** @satisfies {ConfigSettings} */ ({\n    compilerOptions: {\n        strict: true,\n        outDir: \"../lib\",\n    },\n    extends: [\n        \"@tsconfig/strictest/tsconfig.json\",\n        \"../../../tsconfig.base.json\"\n    ],\n});\n\nWhy? Well, it usually makes more sense when you’re deeper in some other code, like a function call.\n\ncompileCode(/** @satisfies {CompilerOptions} */ ({\n    // ...\n}));\n\nThis feature was provided thanks to Oleksandr Tarasiuk!\n\n@overload\n Support in JSDoc\n\nIn TypeScript, you can specify overloads for a function. Overloads give us a way to say that a function can be called with different arguments, and possibly return different results. They can restrict how callers can actually use our functions, and refine what results they’ll get back.\n\n// Our overloads:\nfunction printValue(str: string): void;\nfunction printValue(num: number, maxFractionDigits?: number): void;\n// Our implementation:\nfunction printValue(value: string | number, maximumFractionDigits?: number) {\n    if (typeof value === \"number\") {\n        const formatter = Intl.NumberFormat(\"en-US\", {\n            maximumFractionDigits,\n        });\n        value = formatter.format(value);\n    }\n    console.log(value);\n}\n\nHere, we’ve said that printValue takes either a string or a number as its first argument. If it takes a number, it can take a second argument to determine how many fractional digits we can print.\n\nTypeScript 5.0 now allows JSDoc to declare overloads with a new @overload tag. Each JSDoc comment with an @overload tag is treated as a distinct overload for the following function declaration.\n\n// @ts-check\n/**\n * @overload\n * @param {string} value\n * @return {void}\n */\n/**\n * @overload\n * @param {number} value\n * @param {number} [maximumFractionDigits]\n * @return {void}\n */\n/**\n * @param {string | number} value\n * @param {number} [maximumFractionDigits]\n */\nfunction printValue(value, maximumFractionDigits) {\n    if (typeof value === \"number\") {\n        const formatter = Intl.NumberFormat(\"en-US\", {\n            maximumFractionDigits,\n        });\n        value = formatter.format(value);\n    }\n    console.log(value);\n}\n\nNow regardless of whether we’re writing in a TypeScript or JavaScript file, TypeScript can let us know if we’ve called our functions incorrectly.\n\n// all allowed\nprintValue(\"hello!\");\nprintValue(123.45);\nprintValue(123.45, 2);\nprintValue(\"hello!\", 123); // error!\n\nThis new tag was implemented thanks to Tomasz Lenarcik.\n\nPassing Emit-Specific Flags Under \n--build\n\nTypeScript now allows the following flags to be passed under --build mode\n\n--declaration\n--emitDeclarationOnly\n--declarationMap\n--sourceMap\n--inlineSourceMap\n\nThis makes it way easier to customize certain parts of a build where you might have different development and production builds.\n\nFor example, a development build of a library might not need to produce declaration files, but a production build would. A project can configure declaration emit to be off by default and simply be built with\n\ntsc --build -p ./my-project-dir\n\nOnce you’re done iterating in the inner loop, a “production” build can just pass the --declaration flag.\n\ntsc --build -p ./my-project-dir --declaration\n\nMore information on this change is available here.\n\nCase-Insensitive Import Sorting in Editors\n\nIn editors like Visual Studio and VS Code, TypeScript powers the experience for organizing and sorting imports and exports. Often though, there can be different interpretations of when a list is “sorted”.\n\nFor example, is the following import list sorted?\n\nimport {\n    Toggle,\n    freeze,\n    toBoolean,\n} from \"./utils\";\n\nThe answer might surprisingly be “it depends”. If we don’t care about case-sensitivity, then this list is clearly not sorted. The letter f comes before both t and T.\n\nBut in most programming languages, sorting defaults to comparing the byte values of strings. The way JavaScript compares strings means that \"Toggle\" always comes before \"freeze\" because according to the ASCII character encoding, uppercase letters come before lowercase. So from that perspective, the import list is sorted.\n\nTypeScript previously considered the import list to be sorted because it was doing a basic case-sensitive sort. This could be a point of frustration for developers who preferred a case-insensitive ordering, or who used tools like ESLint which require to case-insensitive ordering by default.\n\nTypeScript now detects case sensitivity by default. This means that TypeScript and tools like ESLint typically won’t “fight” each other over how to best sort imports.\n\nOur team has also been experimenting with further sorting strategies which you can read about here. These options may eventually be configurable by editors. For now, they are still unstable and experimental, and you can opt into them in VS Code today by using the typescript.unstable entry in your JSON options. Below are all of the options you can try out (set to their defaults):\n\n{\n    \"typescript.unstable\": {\n        // Should sorting be case-sensitive? Can be:\n        // - true\n        // - false\n        // - \"auto\" (auto-detect)\n        \"organizeImportsIgnoreCase\": \"auto\",\n        // Should sorting be \"ordinal\" and use code points or consider Unicode rules? Can be:\n        // - \"ordinal\"\n        // - \"unicode\"\n        \"organizeImportsCollation\": \"ordinal\",\n        // Under `\"organizeImportsCollation\": \"unicode\"`,\n        // what is the current locale? Can be:\n        // - [any other locale code]\n        // - \"auto\" (use the editor's locale)\n        \"organizeImportsLocale\": \"en\",\n        // Under `\"organizeImportsCollation\": \"unicode\"`,\n        // should upper-case letters or lower-case letters come first? Can be:\n        // - false (locale-specific)\n        // - \"upper\"\n        // - \"lower\"\n        \"organizeImportsCaseFirst\": false,\n        // Under `\"organizeImportsCollation\": \"unicode\"`,\n        // do runs of numbers get compared numerically (i.e. \"a1\" < \"a2\" < \"a100\")? Can be:\n        // - true\n        // - false\n        \"organizeImportsNumericCollation\": true,\n        // Under `\"organizeImportsCollation\": \"unicode\"`,\n        // do letters with accent marks/diacritics get sorted distinctly\n        // from their \"base\" letter (i.e. is é different from e)? Can be\n        // - true\n        // - false\n        \"organizeImportsAccentCollation\": true\n    },\n    \"javascript.unstable\": {\n        // same options valid here...\n    },\n}\n\nYou can read more details on the original work for auto-detecting and specifying case-insensitivity, followed by the the broader set of options.\n\nExhaustive \nswitch\n/\ncase\n Completions\n\nWhen writing a switch statement, TypeScript now detects when the value being checked has a literal type. If so, it will offer a completion that scaffolds out each uncovered case.\n\nYou can see specifics of the implementation on GitHub.\n\nSpeed, Memory, and Package Size Optimizations\n\nTypeScript 5.0 contains lots of powerful changes across our code structure, our data structures, and algorithmic implementations. What these all mean is that your entire experience should be faster - not just running TypeScript, but even installing it.\n\nHere are a few interesting wins in speed and size that we’ve been able to capture relative to TypeScript 4.9.\n\nScenario\tTime or Size Relative to TS 4.9\nmaterial-ui build time\t89%\nTypeScript Compiler startup time\t89%\nPlaywright build time\t88%\nTypeScript Compiler self-build time\t87%\nOutlook Web build time\t82%\nVS Code build time\t80%\ntypescript npm Package Size\t59%\n\nHow? There are a few notable improvements we’d like give more details on in the future. But we won’t make you wait for that blog post.\n\nFirst off, we recently migrated TypeScript from namespaces to modules, allowing us to leverage modern build tooling that can perform optimizations like scope hoisting. Using this tooling, revisiting our packaging strategy, and removing some deprecated code has shaved off about 26.4 MB from TypeScript 4.9’s 63.8 MB package size. It also brought us a notable speed-up through direct function calls.\n\nTypeScript also added more uniformity to internal object types within the compiler, and also slimmed the data stored on some of these object types as well. This reduced polymorphic and megamorphic use sites, while offsetting most of the necessary memory consumption that was necessary for uniform shapes.\n\nWe’ve also performed some caching when serializing information to strings. Type display, which can happen as part of error reporting, declaration emit, code completions, and more, can end up being fairly expensive. TypeScript now caches some commonly used machinery to reuse across these operations.\n\nAnother notable change we made that improved our parser was leveraging var to occasionally side-step the cost of using let and const across closures. This improved some of our parsing performance.\n\nOverall, we expect most codebases should see speed improvements from TypeScript 5.0, and have consistently been able to reproduce wins between 10% to 20%. Of course this will depend on hardware and codebase characteristics, but we encourage you to try it out on your codebase today!\n\nFor more information, see some of our notable optimizations:\n\nMigrate to Modules\nNode Monomorphization\nSymbol Monomorphization\nIdentifier Size Reduction\nPrinter Caching\nLimited Usage of var\nBreaking Changes and Deprecations\nRuntime Requirements\n\nTypeScript now targets ECMAScript 2018. For Node users, that means a minimum version requirement of at least Node.js 10 and later.\n\nlib.d.ts\n Changes\n\nChanges to how types for the DOM are generated might have an impact on existing code. Notably, certain properties have been converted from number to numeric literal types, and properties and methods for cut, copy, and paste event handling have been moved across interfaces.\n\nAPI Breaking Changes\n\nIn TypeScript 5.0, we moved to modules, removed some unnecessary interfaces, and made some correctness improvements. For more details on what’s changed, see our API Breaking Changes page.\n\nForbidden Implicit Coercions in Relational Operators\n\nCertain operations in TypeScript will already warn you if you write code which may cause an implicit string-to-number coercion:\n\nfunction func(ns: number | string) {\n  return ns * 4; // Error, possible implicit coercion\n}\n\nIn 5.0, this will also be applied to the relational operators >, <, <=, and >=:\n\nfunction func(ns: number | string) {\n  return ns > 4; // Now also an error\n}\n\nTo allow this if desired, you can explicitly coerce the operand to a number using +:\n\nfunction func(ns: number | string) {\n  return +ns > 4; // OK\n}\n\nThis correctness improvement was contributed courtesy of Mateusz Burzyński.\n\nEnum Overhaul\n\nTypeScript has had some long-standing oddities around enums ever since its first release. In 5.0, we’re cleaning up some of these problems, as well as reducing the concept count needed to understand the various kinds of enums you can declare.\n\nThere are two main new errors you might see as part of this. The first is that assigning an out-of-domain literal to an enum type will now error as one might expect:\n\nenum SomeEvenDigit {\n    Zero = 0,\n    Two = 2,\n    Four = 4\n}\n// Now correctly an error\nlet m: SomeEvenDigit = 1;\n\nThe other is that declaration of certain kinds of indirected mixed string/number enum forms would, incorrectly, create an all-number enum:\n\nenum Letters {\n    A = \"a\"\n}\nenum Numbers {\n    one = 1,\n    two = Letters.A\n}\n// Now correctly an error\nconst t: number = Numbers.two;\n\nYou can see more details in relevant change.\n\nMore Accurate Type-Checking for Parameter Decorators in Constructors Under \n--experimentalDecorators\n\nTypeScript 5.0 makes type-checking more accurate for decorators under --experimentalDecorators. One place where this becomes apparent is when using a decorator on a constructor parameter.\n\nexport declare const inject:\n  (entity: any) =>\n    (target: object, key: string | symbol, index?: number) => void;\nexport class Foo {}\nexport class C {\n    constructor(@inject(Foo) private x: any) {\n    }\n}\n\nThis call will fail because key expects a string | symbol, but constructor parameters receive a key of undefined. The correct fix is to change the type of key within inject. A reasonable workaround if you’re using a library that can’t be upgraded is is to wrap inject in a more type-safe decorator function, and use a type-assertion on key.\n\nFor more details, see this issue.\n\nDeprecations and Default Changes\n\nIn TypeScript 5.0, we’ve deprecated the following settings and setting values:\n\n--target: ES3\n--out\n--noImplicitUseStrict\n--keyofStringsOnly\n--suppressExcessPropertyErrors\n--suppressImplicitAnyIndexErrors\n--noStrictGenericChecks\n--charset\n--importsNotUsedAsValues\n--preserveValueImports\nprepend in project references\n\nThese configurations will continue to be allowed until TypeScript 5.5, at which point they will be removed entirely, however, you will receive a warning if you are using these settings. In TypeScript 5.0, as well as future releases 5.1, 5.2, 5.3, and 5.4, you can specify \"ignoreDeprecations\": \"5.0\" to silence those warnings. We’ll also shortly be releasing a 4.9 patch to allow specifying ignoreDeprecations to allow for smoother upgrades. Aside from deprecations, we’ve changed some settings to better improve cross-platform behavior in TypeScript.\n\n--newLine, which controls the line endings emitted in JavaScript files, used to be inferred based on the current operating system if not specified. We think builds should be as deterministic as possible, and Windows Notepad supports line-feed line endings now, so the new default setting is LF. The old OS-specific inference behavior is no longer available.\n\n--forceConsistentCasingInFileNames, which ensured that all references to the same file name in a project agreed in casing, now defaults to true. This can help catch differences issues with code written on case-insensitive file systems.\n\nYou can leave feedback and view more information on the tracking issue for 5.0 deprecations\n\nOn this page\nDecorators\nDifferences with Experimental Legacy Decorators\nWriting Well-Typed Decorators\nconst Type Parameters\nSupporting Multiple Configuration Files in extends\nAll enums Are Union enums\n--moduleResolution bundler\nResolution Customization Flags\nallowImportingTsExtensions\nresolvePackageJsonExports\nresolvePackageJsonImports\nallowArbitraryExtensions\ncustomConditions\n--verbatimModuleSyntax\nSupport for export type *\n@satisfies Support in JSDoc\n@overload Support in JSDoc\nPassing Emit-Specific Flags Under --build\nCase-Insensitive Import Sorting in Editors\nExhaustive switch/case Completions\nSpeed, Memory, and Package Size Optimizations\nBreaking Changes and Deprecations\nRuntime Requirements\nlib.d.ts Changes\nAPI Breaking Changes\nForbidden Implicit Coercions in Relational Operators\nEnum Overhaul\nMore Accurate Type-Checking for Parameter Decorators in Constructors Under --experimentalDecorators\nDeprecations and Default Changes\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\nM\nM\nKM\nPL\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.336 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 5.1",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-1.html",
    "html": "TypeScript 5.1\nEasier Implicit Returns for \nundefined\n-Returning Functions\n\nIn JavaScript, if a function finishes running without hitting a return, it returns the value undefined.\n\nfunction foo() {\n    // no return\n}\n// x = undefined\nlet x = foo();\n\nHowever, in previous versions of TypeScript, the only functions that could have absolutely no return statements were void- and any-returning functions. That meant that even if you explicitly said “this function returns undefined” you were forced to have at least one return statement.\n\n// ✅ fine - we inferred that 'f1' returns 'void'\nfunction f1() {\n    // no returns\n}\n// ✅ fine - 'void' doesn't need a return statement\nfunction f2(): void {\n    // no returns\n}\n// ✅ fine - 'any' doesn't need a return statement\nfunction f3(): any {\n    // no returns\n}\n// ❌ error!\n// A function whose declared type is neither 'void' nor 'any' must return a value.\nfunction f4(): undefined {\n    // no returns\n}\n\nThis could be a pain if some API expected a function returning undefined - you would need to have either at least one explicit return of undefined or a return statement and an explicit annotation.\n\ndeclare function takesFunction(f: () => undefined): undefined;\n// ❌ error!\n// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.\ntakesFunction(() => {\n    // no returns\n});\n// ❌ error!\n// A function whose declared type is neither 'void' nor 'any' must return a value.\ntakesFunction((): undefined => {\n    // no returns\n});\n// ❌ error!\n// Argument of type '() => void' is not assignable to parameter of type '() => undefined'.\ntakesFunction(() => {\n    return;\n});\n// ✅ works\ntakesFunction(() => {\n    return undefined;\n});\n// ✅ works\ntakesFunction((): undefined => {\n    return;\n});\n\nThis behavior was frustrating and confusing, especially when calling functions outside of one’s control. Understanding the interplay between inferring void over undefined, whether an undefined-returning function needs a return statement, etc. seems like a distraction.\n\nFirst, TypeScript 5.1 now allows undefined-returning functions to have no return statement.\n\n// ✅ Works in TypeScript 5.1!\nfunction f4(): undefined {\n    // no returns\n}\n// ✅ Works in TypeScript 5.1!\ntakesFunction((): undefined => {\n    // no returns\n});\n\nSecond, if a function has no return expressions and is being passed to something expecting a function that returns undefined, TypeScript infers undefined for that function’s return type.\n\n// ✅ Works in TypeScript 5.1!\ntakesFunction(function f() {\n    //                 ^ return type is undefined\n    // no returns\n});\n// ✅ Works in TypeScript 5.1!\ntakesFunction(function f() {\n    //                 ^ return type is undefined\n    return;\n});\n\nTo address another similar pain-point, under TypeScript’s --noImplicitReturns option, functions returning only undefined now have a similar exception to void, in that not every single code path must end in an explicit return.\n\n// ✅ Works in TypeScript 5.1 under '--noImplicitReturns'!\nfunction f(): undefined {\n    if (Math.random()) {\n        // do some stuff...\n        return;\n    }\n}\n\nFor more information, you can read up on the original issue and the implementing pull request.\n\nUnrelated Types for Getters and Setters\n\nTypeScript 4.3 made it possible to say that a get and set accessor pair might specify two different types.\n\ninterface Serializer {\n    set value(v: string | number | boolean);\n    get value(): string;\n}\ndeclare let box: Serializer;\n// Allows writing a 'boolean'\nbox.value = true;\n// Comes out as a 'string'\nconsole.log(box.value.toUpperCase());\n\nInitially we required that the get type had to be a subtype of the set type. This meant that writing\n\nbox.value = box.value;\n\nwould always be valid.\n\nHowever, there are plenty of existing and proposed APIs that have completely unrelated types between their getters and setters. For example, consider one of the most common examples - the style property in the DOM and CSSStyleRule API. Every style rule has a style property that is a CSSStyleDeclaration; however, if you try to write to that property, it will only work correctly with a string!\n\nTypeScript 5.1 now allows completely unrelated types for get and set accessor properties, provided that they have explicit type annotations. And while this version of TypeScript does not yet change the types for these built-in interfaces, CSSStyleRule can now be defined in the following way:\n\ninterface CSSStyleRule {\n    // ...\n    /** Always reads as a `CSSStyleDeclaration` */\n    get style(): CSSStyleDeclaration;\n    /** Can only write a `string` here. */\n    set style(newValue: string);\n    // ...\n}\n\nThis also allows other patterns like requiring set accessors to accept only “valid” data, but specifying that get accessors may return undefined if some underlying state hasn’t been initialized yet.\n\nclass SafeBox {\n    #value: string | undefined;\n    // Only accepts strings!\n    set value(newValue: string) {\n    }\n    // Must check for 'undefined'!\n    get value(): string | undefined {\n        return this.#value;\n    }\n}\n\nIn fact, this is similar to how optional properties are checked under --exactOptionalProperties.\n\nYou can read up more on the implementing pull request.\n\nDecoupled Type-Checking Between JSX Elements and JSX Tag Types\n\nOne pain point TypeScript had with JSX was its requirements on the type of every JSX element’s tag.\n\nFor context, a JSX element is either of the following:\n\n// A self-closing JSX tag\n<Foo />\n// A regular element with an opening/closing tag\n<Bar></Bar>\n\nWhen type-checking <Foo /> or <Bar></Bar>, TypeScript always looks up a namespace called JSX and fetches a type out of it called Element - or more directly, it looks up JSX.Element.\n\nBut to check whether Foo or Bar themselves were valid to use as tag names, TypeScript would roughly just grab the types returned or constructed by Foo or Bar and check for compatibility with JSX.Element (or another type called JSX.ElementClass if the type is constructable).\n\nThe limitations here meant that components could not be used if they returned or “rendered” a more broad type than just JSX.Element. For example, a JSX library might be fine with a component returning strings or Promises.\n\nAs a more concrete example, React is considering adding limited support for components that return Promises, but existing versions of TypeScript cannot express that without someone drastically loosening the type of JSX.Element.\n\nimport * as React from \"react\";\nasync function Foo() {\n    return <div></div>;\n}\nlet element = <Foo />;\n//             ~~~\n// 'Foo' cannot be used as a JSX component.\n//   Its return type 'Promise<Element>' is not a valid JSX element.\n\nTo provide libraries with a way to express this, TypeScript 5.1 now looks up a type called JSX.ElementType. ElementType specifies precisely what is valid to use as a tag in a JSX element. So it might be typed today as something like\n\nnamespace JSX {\n    export type ElementType =\n        // All the valid lowercase tags\n        keyof IntrinsicAttributes\n        // Function components\n        (props: any) => Element\n        // Class components\n        new (props: any) => ElementClass;\n    export interface IntrinsicAttributes extends /*...*/ {}\n    export type Element = /*...*/;\n    export type ElementClass = /*...*/;\n}\n\nWe’d like to extend our thanks to Sebastian Silbermann who contributed this change!\n\nNamespaced JSX Attributes\n\nTypeScript now supports namespaced attribute names when using JSX.\n\nimport * as React from \"react\";\n// Both of these are equivalent:\nconst x = <Foo a:b=\"hello\" />;\nconst y = <Foo a : b=\"hello\" />;\ninterface FooProps {\n    \"a:b\": string;\n}\nfunction Foo(props: FooProps) {\n    return <div>{props[\"a:b\"]}</div>;\n}\n\nNamespaced tag names are looked up in a similar way on JSX.IntrinsicAttributes when the first segment of the name is a lowercase name.\n\n// In some library's code or in an augmentation of that library:\nnamespace JSX {\n    interface IntrinsicElements {\n        [\"a:b\"]: { prop: string };\n    }\n}\n// In our code:\nlet x = <a:b prop=\"hello!\" />;\n\nThis contribution was provided thanks to Oleksandr Tarasiuk.\n\ntypeRoots\n Are Consulted In Module Resolution\n\nWhen TypeScript’s specified module lookup strategy is unable to resolve a path, it will now resolve packages relative to the specified typeRoots.\n\nSee this pull request for more details.\n\nMove Declarations to Existing Files\n\nIn addition to moving declarations to new files, TypeScript now ships a preview feature for moving declarations to existing files as well. You can try this functionality out in a recent version of Visual Studio Code.\n\nKeep in mind that this feature is currently in preview, and we are seeking further feedback on it.\n\nhttps://github.com/microsoft/TypeScript/pull/53542\n\nLinked Cursors for JSX Tags\n\nTypeScript now supports linked editing for JSX tag names. Linked editing (occasionally called “mirrored cursors”) allows an editor to edit multiple locations at the same time automatically.\n\nThis new feature should work in both TypeScript and JavaScript files, and can be enabled in Visual Studio Code Insiders. In Visual Studio Code, you can either edit the Editor: Linked Editing option in the Settings UI:\n\nor configure editor.linkedEditing in your JSON settings file:\n\n{\n    // ...\n    \"editor.linkedEditing\": true,\n}\n\nThis feature will also be supported by Visual Studio 17.7 Preview 1.\n\nYou can take a look at our implementation of linked editing here!\n\nSnippet Completions for \n@param\n JSDoc Tags\n\nTypeScript now provides snippet completions when typing out a @param tag in both TypeScript and JavaScript files. This can help cut down on some typing and jumping around text as you document your code or add JSDoc types in JavaScript.\n\nYou can check out how this new feature was implemented on GitHub.\n\nOptimizations\nAvoiding Unnecessary Type Instantiation\n\nTypeScript 5.1 now avoids performing type instantiation within object types that are known not to contain references to outer type parameters. This has the potential to cut down on many unnecessary computations, and reduced the type-checking time of material-ui’s docs directory by over 50%.\n\nYou can see the changes involved for this change on GitHub.\n\nNegative Case Checks for Union Literals\n\nWhen checking if a source type is part of a union type, TypeScript will first do a fast look-up using an internal type identifier for that source. If that look-up fails, then TypeScript checks for compatibility against every type within the union.\n\nWhen relating a literal type to a union of purely literal types, TypeScript can now avoid that full walk against every other type in the union. This assumption is safe because TypeScript always interns/caches literal types - though there are some edge cases to handle relating to “fresh” literal types.\n\nThis optimization was able to reduce the type-checking time of the code in this issue from about 45 seconds to about 0.4 seconds.\n\nReduced Calls into Scanner for JSDoc Parsing\n\nWhen older versions of TypeScript parsed out a JSDoc comment, they would use the scanner/tokenizer to break the comment into fine-grained tokens and piece the contents back together. This could be helpful for normalizing comment text, so that multiple spaces would just collapse into one; but it was extremely “chatty” and meant the parser and scanner would jump back and forth very often, adding overhead to JSDoc parsing.\n\nTypeScript 5.1 has moved more logic around breaking down JSDoc comments into the scanner/tokenizer. The scanner now returns larger chunks of content directly to the parser to do as it needs.\n\nThese changes have brought down the parse time of several 10Mb mostly-prose-comment JavaScript files by about half. For a more realistic example, our performance suite’s snapshot of xstate dropped about 300ms of parse time, making it faster to load and analyze.\n\nBreaking Changes\nES2020 and Node.js 14.17 as Minimum Runtime Requirements\n\nTypeScript 5.1 now ships JavaScript functionality that was introduced in ECMAScript 2020. As a result, at minimum TypeScript must be run in a reasonably modern runtime. For most users, this means TypeScript now only runs on Node.js 14.17 and later.\n\nIf you try running TypeScript 5.1 under an older version of Node.js such as Node 10 or 12, you may see an error like the following from running either tsc.js or tsserver.js:\n\nnode_modules/typescript/lib/tsserver.js:2406\n  for (let i = startIndex ?? 0; i < array.length; i++) {\n                           ^\n \nSyntaxError: Unexpected token '?'\n    at wrapSafe (internal/modules/cjs/loader.js:915:16)\n    at Module._compile (internal/modules/cjs/loader.js:963:27)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1027:10)\n    at Module.load (internal/modules/cjs/loader.js:863:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:708:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:60:12)\n    at internal/main/run_main_module.js:17:47\n\nAdditionally, if you try installing TypeScript you’ll get something like the following error messages from npm:\n\nnpm WARN EBADENGINE Unsupported engine {\nnpm WARN EBADENGINE   package: 'typescript@5.1.1-rc',\nnpm WARN EBADENGINE   required: { node: '>=14.17' },\nnpm WARN EBADENGINE   current: { node: 'v12.22.12', npm: '8.19.2' }\nnpm WARN EBADENGINE }\n\nfrom Yarn:\n\nerror typescript@5.1.1-rc: The engine \"node\" is incompatible with this module. Expected version \">=14.17\". Got \"12.22.12\"\nerror Found incompatible module.\n\nSee more information around this change here.\n\nExplicit \ntypeRoots\n Disables Upward Walks for \nnode_modules/@types\n\nPreviously, when the typeRoots option was specified in a tsconfig.json but resolution to any typeRoots directories had failed, TypeScript would still continue walking up parent directories, trying to resolve packages within each parent’s node_modules/@types folder.\n\nThis behavior could prompt excessive look-ups and has been disabled in TypeScript 5.1. As a result, you may begin to see errors like the following based on entries in your tsconfig.json’s types option or /// <reference > directives\n\nerror TS2688: Cannot find type definition file for 'node'.\nerror TS2688: Cannot find type definition file for 'mocha'.\nerror TS2688: Cannot find type definition file for 'jasmine'.\nerror TS2688: Cannot find type definition file for 'chai-http'.\nerror TS2688: Cannot find type definition file for 'webpack-env\"'.\n\nThe solution is typically to add specific entries for node_modules/@types to your typeRoots:\n\n{\n    \"compilerOptions\": {\n        \"types\": [\n            \"node\",\n            \"mocha\"\n        ],\n        \"typeRoots\": [\n            // Keep whatever you had around before.\n            \"./some-custom-types/\",\n            // You might need your local 'node_modules/@types'.\n            \"./node_modules/@types\",\n            // You might also need to specify a shared 'node_modules/@types'\n            // if you're using a \"monorepo\" layout.\n            \"../../node_modules/@types\",\n        ]\n    }\n}\n\nMore information is available on the original change on our issue tracker.\n\nOn this page\nEasier Implicit Returns for undefined-Returning Functions\nUnrelated Types for Getters and Setters\nDecoupled Type-Checking Between JSX Elements and JSX Tag Types\nNamespaced JSX Attributes\ntypeRoots Are Consulted In Module Resolution\nMove Declarations to Existing Files\nLinked Cursors for JSX Tags\nSnippet Completions for @param JSDoc Tags\nOptimizations\nAvoiding Unnecessary Type Instantiation\nNegative Case Checks for Union Literals\nReduced Calls into Scanner for JSDoc Parsing\nBreaking Changes\nES2020 and Node.js 14.17 as Minimum Runtime Requirements\nExplicit typeRoots Disables Upward Walks for node_modules/@types\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nN\nBT\nLL\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.446 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.8",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-8.html",
    "html": "TypeScript 4.8\nImproved Intersection Reduction, Union Compatibility, and Narrowing\n\nTypeScript 4.8 brings a series of correctness and consistency improvements under --strictNullChecks. These changes affect how intersection and union types work, and are leveraged in how TypeScript narrows types.\n\nFor example, unknown is close in spirit to the union type {} | null | undefined because it accepts null, undefined, and any other type. TypeScript now recognizes this, and allows assignments from unknown to {} | null | undefined.\n\nfunction f(x: unknown, y: {} | null | undefined) {\n    x = y; // always worked\n    y = x; // used to error, now works\n}\n\nAnother change is that {} intersected with any other object type simplifies right down to that object type. That meant that we were able to rewrite NonNullable to just use an intersection with {}, because {} & null and {} & undefined just get tossed away.\n\n- type NonNullable<T> = T extends null | undefined ? never : T;\n+ type NonNullable<T> = T & {};\n\nThis is an improvement because intersection types like this can be reduced and assigned to, while conditional types currently cannot. So NonNullable<NonNullable<T>> now simplifies at least to NonNullable<T>, whereas it didn’t before.\n\nfunction foo<T>(x: NonNullable<T>, y: NonNullable<NonNullable<T>>) {\n    x = y; // always worked\n    y = x; // used to error, now works\n}\n\nThese changes also allowed us to bring in sensible improvements in control flow analysis and type narrowing. For example, unknown is now narrowed just like {} | null | undefined in truthy branches.\n\nfunction narrowUnknownishUnion(x: {} | null | undefined) {\n    if (x) {\n        x;  // {}\n    }\n    else {\n        x;  // {} | null | undefined\n    }\n}\nfunction narrowUnknown(x: unknown) {\n    if (x) {\n        x;  // used to be 'unknown', now '{}'\n    }\n    else {\n        x;  // unknown\n    }\n}\n\nGeneric values also get narrowed similarly. When checking that a value isn’t null or undefined, TypeScript now just intersects it with {} - which again, is the same as saying it’s NonNullable. Putting many of the changes here together, we can now define the following function without any type assertions.\n\nfunction throwIfNullable<T>(value: T): NonNullable<T> {\n    if (value === undefined || value === null) {\n        throw Error(\"Nullable value!\");\n    }\n    // Used to fail because 'T' was not assignable to 'NonNullable<T>'.\n    // Now narrows to 'T & {}' and succeeds because that's just 'NonNullable<T>'.\n    return value;\n}\n\nvalue now gets narrowed to T & {}, and is now identical with NonNullable<T> - so the body of the function just works with no TypeScript-specific syntax.\n\nOn their own, these changes may appear small - but they represent fixes for many many paper cuts that have been reported over several years.\n\nFor more specifics on these improvements, you can read more here.\n\nImproved Inference for \ninfer\n Types in Template String Types\n\nTypeScript recently introduced a way to add extends constraints to infer type variables in conditional types.\n\n// Grabs the first element of a tuple if it's assignable to 'number',\n// and returns 'never' if it can't find one.\ntype TryGetNumberIfFirst<T> =\n    T extends [infer U extends number, ...unknown[]] ? U : never;\n\nIf these infer types appear in a template string type and are constrained to a primitive type, TypeScript will now try to parse out a literal type.\n\n// SomeNum used to be 'number'; now it's '100'.\ntype SomeNum = \"100\" extends `${infer U extends number}` ? U : never;\n// SomeBigInt used to be 'bigint'; now it's '100n'.\ntype SomeBigInt = \"100\" extends `${infer U extends bigint}` ? U : never;\n// SomeBool used to be 'boolean'; now it's 'true'.\ntype SomeBool = \"true\" extends `${infer U extends boolean}` ? U : never;\n\nThis can now better convey what a library will do at runtime, and give more precise types.\n\nOne note on this is that when TypeScript parses these literal types out it will greedily try to parse out as much of what looks like of the appropriate primitive type; however it then checks to see if the print-back of that primitive matches up with the string contents. In other words, TypeScript checks whether the going from the string, to the primitive, and back matches. If it doesn’t see that the string can be “round-tripped”, then it will fall back to the base primitive type.\n\n// JustNumber is `number` here because TypeScript parses out `\"1.0\"`, but `String(Number(\"1.0\"))` is `\"1\"` and doesn't match.\ntype JustNumber = \"1.0\" extends `${infer T extends number}` ? T : never; \n\nYou can see more about this feature here.\n\n--build\n, \n--watch\n, and \n--incremental\n Performance Improvements\n\nTypeScript 4.8 introduces several optimizations that should speed up scenarios around --watch and --incremental, along with project references builds using --build. For example, TypeScript is now able to avoid spending time updating timestamps during no-op changes in --watch mode, which makes rebuilds faster and avoids messing with other build tools that might be watching for TypeScript’s output. Many other optimizations where we’re able to reuse information across --build, --watch, and --incremental have been introduced as well.\n\nHow big are these improvements? Well, on a fairly large internal codebase, we’ve seen time reductions on the order of 10%-25% on many simple common operations, with around 40% time reductions in no-change scenarios. We’ve seen similar results on the TypeScript codebase as well.\n\nYou can see the changes, along with the performance results on GitHub.\n\nErrors When Comparing Object and Array Literals\n\nIn many languages, operators like == perform what’s called “value” equality on objects. For example, in Python it’s valid to check whether a list is empty by checking whether a value is equal to the empty list using ==.\n\nif people_at_home == []:\n    print(\"here's where I lie, broken inside. </3\")\n    adopt_animals()\n\nThis is not the case in JavaScript, where == and === between objects (and therefore, arrays) check whether both references point to the same value. We believe that similar code in JavaScript is at best an early foot-gun for JavaScript developers, and at worst a bug in production code. That’s why TypeScript now disallows code like the following.\n\nif (peopleAtHome === []) {\n//  ~~~~~~~~~~~~~~~~~~~\n// This condition will always return 'false' since JavaScript compares objects by reference, not value.\n    console.log(\"here's where I lie, broken inside. </3\")\n    adoptAnimals();\n}\n\nWe’d like to extend our gratitude to Jack Works who contributed this check. You can view the changes involved here.\n\nImproved Inference from Binding Patterns\n\nIn some cases, TypeScript will pick up a type from a binding pattern to make better inferences.\n\ndeclare function chooseRandomly<T>(x: T, y: T): T;\nlet [a, b, c] = chooseRandomly([42, true, \"hi!\"], [0, false, \"bye!\"]);\n//   ^  ^  ^\n//   |  |  |\n//   |  |  string\n//   |  |\n//   |  boolean\n//   |\n//   number\n\nWhen chooseRandomly needs to figure out a type for T, it will primarily look at [42, true, \"hi!\"] and [0, false, \"bye!\"]; but TypeScript needs to figure out whether those two types should be Array<number | boolean | string> or the tuple type [number, boolean, string]. To do that, it will look for existing candidates as a hint to see whether there are any tuple types. When TypeScript sees the binding pattern [a, b, c], it creates the type [any, any, any], and that type gets picked up as a low-priority candidate for T which also gets used as a hint for the types of [42, true, \"hi!\"] and [0, false, \"bye!\"].\n\nYou can see how this was good for chooseRandomly, but it fell short in other cases. For example, take the following code\n\ndeclare function f<T>(x?: T): T;\nlet [x, y, z] = f();\n\nThe binding pattern [x, y, z] hinted that f should produce an [any, any, any] tuple; but f really shouldn’t change its type argument based on a binding pattern. It can’t suddenly conjure up a new array-like value based on what it’s being assigned to, so the binding pattern type has way too much influence on the produced type. On top of that, because the binding pattern type is full of anys, we’re left with x, y, and z being typed as any.\n\nIn TypeScript 4.8, these binding patterns are never used as candidates for type arguments. Instead, they’re just consulted in case a parameter needs a more specific type like in our chooseRandomly example. If you need to revert to the old behavior, you can always provide explicit type arguments.\n\nYou can look at the change on GitHub if you’re curious to learn more.\n\nFile-Watching Fixes (Especially Across \ngit checkout\ns)\n\nWe’ve had a long-standing bug where TypeScript has a very hard time with certain file changes in --watch mode and editor scenarios. Sometimes the symptoms are stale or inaccurate errors that might show up that require restarting tsc or VS Code. Frequently these occur on Unix systems, and you might have seen these after saving a file with vim or swapping branches in git.\n\nThis was caused by assumptions of how Node.js handles rename events across file systems. File systems used by Linux and macOS utilize inodes, and Node.js will attach file watchers to inodes rather than file paths. So when Node.js returns a watcher object, it might be watching a path or an inode depending on the platform and file system.\n\nTo be a bit more efficient, TypeScript tries to reuse the same watcher objects if it detects a path still exists on disk. This is where things went wrong, because even if a file still exists at that path, a distinct file might have been created, and that file will have a different inode. So TypeScript would end up reusing the watcher object instead of installing a new watcher at the original location, and watch for changes at what might be a totally irrelevant file. So TypeScript 4.8 now handles these cases on inode systems and properly installs a new watcher and fixes this.\n\nWe’d like to extend our thanks to Marc Celani and his team at Airtable who invested lots of time in investigating the issues they were experiencing and pointing out the root cause. You can view the specific fixes around file-watching here.\n\nFind-All-References Performance Improvements\n\nWhen running find-all-references in your editor, TypeScript is now able to act a little smarter as it aggregates references. This reduced the amount of time TypeScript took to search a widely-used identifier in its own codebase by about 20%.\n\nYou can read up more on the improvement here.\n\nExclude Specific Files from Auto-Imports\n\nTypeScript 4.8 introduces an editor preference for excluding files from auto-imports. In Visual Studio Code, file names or globs can be added under “Auto Import File Exclude Patterns” in the Settings UI, or in a .vscode/settings.json file:\n\n{\n    // Note that `javascript.preferences.autoImportFileExcludePatterns` can be specified for JavaScript too.\n    \"typescript.preferences.autoImportFileExcludePatterns\": [\n      \"**/node_modules/@types/node\"\n    ]\n}\n\nThis can be useful in cases where you can’t avoid having certain modules or libraries in your compilation but you rarely want to import from them. These modules might have lots of exports that can pollute the auto-imports list and make it harder to navigate, and this option can help in those situations.\n\nYou can see more specifics about the implementation here.\n\nCorrectness Fixes and Breaking Changes\n\nDue to the nature of type system changes, there are very few changes that can be made that don’t affect some code; however, there are a few changes that are more likely to require adapting existing code.\n\nlib.d.ts\n Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and lib.d.ts updates, but one notable change is that the cause property on Errors now has the type unknown instead of Error.\n\nUnconstrained Generics No Longer Assignable to \n{}\n\nIn TypeScript 4.8, for projects with strictNullChecks enabled, TypeScript will now correctly issue an error when an unconstrained type parameter is used in a position where null or undefined are not legal values. That will include any type that expects {}, object, or an object type with all-optional properties.\n\nA simple example can be seen in the following.\n\n// Accepts any non-null non-undefined value\nfunction bar(value: {}) {\n  Object.keys(value); // This call throws on null/undefined at runtime.\n}\n// Unconstrained type parameter T...\nfunction foo<T>(x: T) {\n    bar(x); // Used to be allowed, now is an error in 4.8.\n    //  ~\n    // error: Argument of type 'T' is not assignable to parameter of type '{}'.\n}\nfoo(undefined);\n\nAs demonstrated above, code like this has a potential bug - the values null and undefined can be indirectly passed through these unconstrained type parameters to code that is not supposed to observe those values.\n\nThis behavior will also be visible in type positions. One example would be:\n\ninterface Foo<T> {\n  x: Bar<T>;\n}\ninterface Bar<T extends {}> { }\n\nExisting code that didn’t want to handle null and undefined can be fixed by propagating the appropriate constraints through.\n\n- function foo<T>(x: T) {\n+ function foo<T extends {}>(x: T) {\n\nAnother work-around would be to check for null and undefined at runtime.\n\n  function foo<T>(x: T) {\n+     if (x !== null && x !== undefined) {\n          bar(x);\n+     }\n  }\n\nAnd if you know that for some reason, your generic value can’t be null or undefined, you can just use a non-null assertion.\n\n  function foo<T>(x: T) {\n-     bar(x);\n+     bar(x!);\n  }\n\nWhen it comes to types, you’ll often either need to propagate constraints, or intersect your types with {}.\n\nFor more information, you can see the change that introduced this along with the specific discussion issue regarding how unconstrained generics now work.\n\nDecorators are placed on \nmodifiers\n on TypeScript’s Syntax Trees\n\nThe current direction of decorators in TC39 means that TypeScript will have to handle a break in terms of placement of decorators. Previously, TypeScript assumed decorators would always be placed prior to all keywords/modifiers. For example\n\n@decorator\nexport class Foo {\n  // ...\n}\n\nDecorators as currently proposed do not support this syntax. Instead, the export keyword must precede the decorator.\n\nexport @decorator class Foo {\n  // ...\n}\n\nUnfortunately, TypeScript’s trees are concrete rather than abstract, and our architecture expects syntax tree node fields to be entirely ordered before or after each other. To support both legacy decorators and decorators as proposed, TypeScript will have to gracefully parse, and intersperse, modifiers and decorators.\n\nTo do this, it exposes a new type alias called ModifierLike which is a Modifier or a Decorator.\n\nexport type ModifierLike = Modifier | Decorator;\n\nDecorators are now placed in the same field as modifiers which is now a NodeArray<ModifierLike> when set, and the entire field is deprecated.\n\n- readonly modifiers?: NodeArray<Modifier> | undefined;\n+ /**\n+  * @deprecated ...\n+  * Use `ts.canHaveModifiers()` to test whether a `Node` can have modifiers.\n+  * Use `ts.getModifiers()` to get the modifiers of a `Node`.\n+  * ...\n+  */\n+ readonly modifiers?: NodeArray<ModifierLike> | undefined;\n\nAll existing decorators properties have been marked as deprecated and will always be undefined if read. The type has also been changed to undefined so that existing tools know to handle them correctly.\n\n- readonly decorators?: NodeArray<Decorator> | undefined;\n+ /**\n+  * @deprecated ...\n+  * Use `ts.canHaveDecorators()` to test whether a `Node` can have decorators.\n+  * Use `ts.getDecorators()` to get the decorators of a `Node`.\n+  * ...\n+  */\n+ readonly decorators?: undefined;\n\nTo avoid new deprecation warnings and other issues, TypeScript now exposes four new functions to use in place of the decorators and modifiers properties. There are individual predicates for testing whether a node has support modifiers and decorators, along with respective accessor functions for grabbing them.\n\nfunction canHaveModifiers(node: Node): node is HasModifiers;\nfunction getModifiers(node: HasModifiers): readonly Modifier[] | undefined;\nfunction canHaveDecorators(node: Node): node is HasDecorators;\nfunction getDecorators(node: HasDecorators): readonly Decorator[] | undefined;\n\nAs an example of how to access modifiers off of a node, you can write\n\nconst modifiers = canHaveModifiers(myNode) ? getModifiers(myNode) : undefined;\n\nWith the note that each call to getModifiers and getDecorators may allocate a new array.\n\nFor more information, see changes around\n\nthe restructuring of our tree nodes\nthe deprecations\nexposing the predicate functions\nTypes Cannot Be Imported/Exported in JavaScript Files\n\nTypeScript previously allowed JavaScript files to import and export entities declared with a type, but no value, in import and export statements. This behavior was incorrect, because named imports and exports for values that don’t exist will cause a runtime error under ECMAScript modules. When a JavaScript file is type-checked under --checkJs or through a // @ts-check comment, TypeScript will now issue an error.\n\n// @ts-check\n// Will fail at runtime because 'SomeType' is not a value.\nimport { someValue, SomeType } from \"some-module\";\n/**\n * @type {SomeType}\n */\nexport const myValue = someValue;\n/**\n * @typedef {string | number} MyType\n */\n// Will fail at runtime because 'MyType' is not a value.\nexport { MyType as MyExportedType };\n\nTo reference a type from another module, you can instead directly qualify the import.\n\n- import { someValue, SomeType } from \"some-module\";\n+ import { someValue } from \"some-module\";\n  \n  /**\n-  * @type {SomeType}\n+  * @type {import(\"some-module\").SomeType}\n   */\n  export const myValue = someValue;\n\nTo export a type, you can just use a /** @typedef */ comment in JSDoc. @typedef comments already automatically export types from their containing modules.\n\n  /**\n   * @typedef {string | number} MyType\n   */\n+ /**\n+  * @typedef {MyType} MyExportedType\n+  */\n- export { MyType as MyExportedType };\n\nYou can read more about the change here.\n\nBinding Patterns Do Not Directly Contribute to Inference Candidates\n\nAs mentioned above, binding patterns no longer change the type of inference results in function calls. You can read more about the original change here.\n\nUnused Renames in Binding Patterns are Now Errors in Type Signatures\n\nTypeScript’s type annotation syntax often looks like it can be used when destructuring values. For example, take the following function.\n\ndeclare function makePerson({ name: string, age: number }): Person;\n\nYou might read this signature and think that makePerson obviously takes an object with a name property with the type string and an age property with the type number; however, JavaScript’s destructuring syntax is actually taking precedence here. makePerson does say that it’s going to take an object with a name and an age property, but instead of specifying a type for them, it’s just saying that it renames name and age to string and number respectively.\n\nIn a pure type construct, writing code like this is useless, and typically a mistake since developers usually assume they’re writing a type annotation.\n\nTypeScript 4.8 makes these an error unless they’re referenced later in the signature. The correct way to write the above signature would be as follows:\n\ndeclare function makePerson(options: { name: string, age: number }): Person;\n// or\ndeclare function makePerson({ name, age }: { name: string, age: number }): Person;\n\nThis change can catch bugs in declarations, and has been helpful for improving existing code. We’d like to extend our thanks to GitHub user uhyo for providing this check. You can read up on the change here.\n\nOn this page\nImproved Intersection Reduction, Union Compatibility, and Narrowing\nImproved Inference for infer Types in Template String Types\n--build, --watch, and --incremental Performance Improvements\nErrors When Comparing Object and Array Literals\nImproved Inference from Binding Patterns\nFile-Watching Fixes (Especially Across git checkouts)\nFind-All-References Performance Improvements\nExclude Specific Files from Auto-Imports\nCorrectness Fixes and Breaking Changes\nlib.d.ts Updates\nUnconstrained Generics No Longer Assignable to {}\nDecorators are placed on modifiers on TypeScript’s Syntax Trees\nTypes Cannot Be Imported/Exported in JavaScript Files\nBinding Patterns Do Not Directly Contribute to Inference Candidates\nUnused Renames in Binding Patterns are Now Errors in Type Signatures\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.688 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 4.9",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-9.html",
    "html": "TypeScript 4.9\nThe \nsatisfies\n Operator\n\nTypeScript developers are often faced with a dilemma: we want to ensure that some expression matches some type, but also want to keep the most specific type of that expression for inference purposes.\n\nFor example:\n\n// Each property can be a string or an RGB tuple.\nconst palette = {\n    red: [255, 0, 0],\n    green: \"#00ff00\",\n    bleu: [0, 0, 255]\n//  ^^^^ sacrebleu - we've made a typo!\n};\n// We want to be able to use array methods on 'red'...\nconst redComponent = palette.red.at(0);\n// or string methods on 'green'...\nconst greenNormalized = palette.green.toUpperCase();\n\nNotice that we’ve written bleu, whereas we probably should have written blue. We could try to catch that bleu typo by using a type annotation on palette, but we’d lose the information about each property.\n\ntype Colors = \"red\" | \"green\" | \"blue\";\ntype RGB = [red: number, green: number, blue: number];\nconst palette: Record<Colors, string | RGB> = {\n    red: [255, 0, 0],\n    green: \"#00ff00\",\n    bleu: [0, 0, 255]\n//  ~~~~ The typo is now correctly detected\n};\n// But we now have an undesirable error here - 'palette.red' \"could\" be a string.\nconst redComponent = palette.red.at(0);\n\nThe new satisfies operator lets us validate that the type of an expression matches some type, without changing the resulting type of that expression. As an example, we could use satisfies to validate that all the properties of palette are compatible with string | number[]:\n\ntype Colors = \"red\" | \"green\" | \"blue\";\ntype RGB = [red: number, green: number, blue: number];\nconst palette = {\n    red: [255, 0, 0],\n    green: \"#00ff00\",\n    bleu: [0, 0, 255]\n//  ~~~~ The typo is now caught!\n} satisfies Record<Colors, string | RGB>;\n// Both of these methods are still accessible!\nconst redComponent = palette.red.at(0);\nconst greenNormalized = palette.green.toUpperCase();\n\nsatisfies can be used to catch lots of possible errors. For example, we could ensure that an object has all the keys of some type, but no more:\n\ntype Colors = \"red\" | \"green\" | \"blue\";\n// Ensure that we have exactly the keys from 'Colors'.\nconst favoriteColors = {\n    \"red\": \"yes\",\n    \"green\": false,\n    \"blue\": \"kinda\",\n    \"platypus\": false\n//  ~~~~~~~~~~ error - \"platypus\" was never listed in 'Colors'.\n} satisfies Record<Colors, unknown>;\n// All the information about the 'red', 'green', and 'blue' properties are retained.\nconst g: boolean = favoriteColors.green;\n\nMaybe we don’t care about if the property names match up somehow, but we do care about the types of each property. In that case, we can also ensure that all of an object’s property values conform to some type.\n\ntype RGB = [red: number, green: number, blue: number];\nconst palette = {\n    red: [255, 0, 0],\n    green: \"#00ff00\",\n    blue: [0, 0]\n    //    ~~~~~~ error!\n} satisfies Record<string, string | RGB>;\n// Information about each property is still maintained.\nconst redComponent = palette.red.at(0);\nconst greenNormalized = palette.green.toUpperCase();\n\nFor more examples, you can see the issue proposing this and the implementing pull request. We’d like to thank Oleksandr Tarasiuk who implemented and iterated on this feature with us.\n\nUnlisted Property Narrowing with the \nin\n Operator\n\nAs developers, we often need to deal with values that aren’t fully known at runtime. In fact, we often don’t know if properties exist, whether we’re getting a response from a server or reading a configuration file. JavaScript’s in operator can check whether a property exists on an object.\n\nPreviously, TypeScript allowed us to narrow away any types that don’t explicitly list a property.\n\ninterface RGB {\n    red: number;\n    green: number;\n    blue: number;\n}\ninterface HSV {\n    hue: number;\n    saturation: number;\n    value: number;\n}\nfunction setColor(color: RGB | HSV) {\n    if (\"hue\" in color) {\n        // 'color' now has the type HSV\n    }\n    // ...\n}\n\nHere, the type RGB didn’t list the hue and got narrowed away, and leaving us with the type HSV.\n\nBut what about examples where no type listed a given property? In those cases, the language didn’t help us much. Let’s take the following example in JavaScript:\n\nfunction tryGetPackageName(context) {\n    const packageJSON = context.packageJSON;\n    // Check to see if we have an object.\n    if (packageJSON && typeof packageJSON === \"object\") {\n        // Check to see if it has a string name property.\n        if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {\n            return packageJSON.name;\n        }\n    }\n    return undefined;\n}\n\nRewriting this to canonical TypeScript would just be a matter of defining and using a type for context; however, picking a safe type like unknown for the packageJSON property would cause issues in older versions of TypeScript.\n\ninterface Context {\n    packageJSON: unknown;\n}\nfunction tryGetPackageName(context: Context) {\n    const packageJSON = context.packageJSON;\n    // Check to see if we have an object.\n    if (packageJSON && typeof packageJSON === \"object\") {\n        // Check to see if it has a string name property.\n        if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {\n        //                                              ~~~~\n        // error! Property 'name' does not exist on type 'object.\n            return packageJSON.name;\n        //                     ~~~~\n        // error! Property 'name' does not exist on type 'object.\n        }\n    }\n    return undefined;\n}\n\nThis is because while the type of packageJSON was narrowed from unknown to object, the in operator strictly narrowed to types that actually defined the property being checked. As a result, the type of packageJSON remained object.\n\nTypeScript 4.9 makes the in operator a little bit more powerful when narrowing types that don’t list the property at all. Instead of leaving them as-is, the language will intersect their types with Record<\"property-key-being-checked\", unknown>.\n\nSo in our example, packageJSON will have its type narrowed from unknown to object to object & Record<\"name\", unknown> That allows us to access packageJSON.name directly and narrow that independently.\n\ninterface Context {\n    packageJSON: unknown;\n}\nfunction tryGetPackageName(context: Context): string | undefined {\n    const packageJSON = context.packageJSON;\n    // Check to see if we have an object.\n    if (packageJSON && typeof packageJSON === \"object\") {\n        // Check to see if it has a string name property.\n        if (\"name\" in packageJSON && typeof packageJSON.name === \"string\") {\n            // Just works!\n            return packageJSON.name;\n        }\n    }\n    return undefined;\n}\n\nTypeScript 4.9 also tightens up a few checks around how in is used, ensuring that the left side is assignable to the type string | number | symbol, and the right side is assignable to object. This helps check that we’re using valid property keys, and not accidentally checking primitives.\n\nFor more information, read the implementing pull request\n\nAuto-Accessors in Classes\n\nTypeScript 4.9 supports an upcoming feature in ECMAScript called auto-accessors. Auto-accessors are declared just like properties on classes, except that they’re declared with the accessor keyword.\n\nclass Person {\n    accessor name: string;\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n\nUnder the covers, these auto-accessors “de-sugar” to a get and set accessor with an unreachable private property.\n\nclass Person {\n    #__name: string;\n    get name() {\n        return this.#__name;\n    }\n    set name(value: string) {\n        this.#__name = value;\n    }\n    constructor(name: string) {\n        this.name = name;\n    }\n}\n\nYou can read up more about the auto-accessors pull request on the original PR.\n\nChecks For Equality on \nNaN\n\nA major gotcha for JavaScript developers is checking against the value NaN using the built-in equality operators.\n\nFor some background, NaN is a special numeric value that stands for “Not a Number”. Nothing is ever equal to NaN - even NaN!\n\nconsole.log(NaN == 0)  // false\nconsole.log(NaN === 0) // false\nconsole.log(NaN == NaN)  // false\nconsole.log(NaN === NaN) // false\n\nBut at least symmetrically everything is always not-equal to NaN.\n\nconsole.log(NaN != 0)  // true\nconsole.log(NaN !== 0) // true\nconsole.log(NaN != NaN)  // true\nconsole.log(NaN !== NaN) // true\n\nThis technically isn’t a JavaScript-specific problem, since any language that contains IEEE-754 floats has the same behavior; but JavaScript’s primary numeric type is a floating point number, and number parsing in JavaScript can often result in NaN. In turn, checking against NaN ends up being fairly common, and the correct way to do so is to use Number.isNaN - but as we mentioned, lots of people accidentally end up checking with someValue === NaN instead.\n\nTypeScript now errors on direct comparisons against NaN, and will suggest using some variation of Number.isNaN instead.\n\nfunction validate(someValue: number) {\n    return someValue !== NaN;\n    //     ~~~~~~~~~~~~~~~~~\n    // error: This condition will always return 'true'.\n    //        Did you mean '!Number.isNaN(someValue)'?\n}\n\nWe believe that this change should strictly help catch beginner errors, similar to how TypeScript currently issues errors on comparisons against object and array literals.\n\nWe’d like to extend our thanks to Oleksandr Tarasiuk who contributed this check.\n\nFile-Watching Now Uses File System Events\n\nIn earlier versions, TypeScript leaned heavily on polling for watching individual files. Using a polling strategy meant checking the state of a file periodically for updates. On Node.js, fs.watchFile is the built-in way to get a polling file-watcher. While polling tends to be more predictable across platforms and file systems, it means that your CPU has to periodically get interrupted and check for updates to the file, even when nothing’s changed. For a few dozen files, this might not be noticeable; but on a bigger project with lots of files - or lots of files in node_modules - this can become a resource hog.\n\nGenerally speaking, a better approach is to use file system events. Instead of polling, we can announce that we’re interested in updates of specific files and provide a callback for when those files actually do change. Most modern platforms in use provide facilities and APIs like CreateIoCompletionPort, kqueue, epoll, and inotify. Node.js mostly abstracts these away by providing fs.watch. File system events usually work great, but there are lots of caveats to using them, and in turn, to using the fs.watch API. A watcher needs to be careful to consider inode watching, unavailability on certain file systems (e.g.networked file systems), whether recursive file watching is available, whether directory renames trigger events, and even file watcher exhaustion! In other words, it’s not quite a free lunch, especially if you’re looking for something cross-platform.\n\nAs a result, our default was to pick the lowest common denominator: polling. Not always, but most of the time.\n\nOver time, we’ve provided the means to choose other file-watching strategies. This allowed us to get feedback and harden our file-watching implementation against most of these platform-specific gotchas. As TypeScript has needed to scale to larger codebases, and has improved in this area, we felt swapping to file system events as the default would be a worthwhile investment.\n\nIn TypeScript 4.9, file watching is powered by file system events by default, only falling back to polling if we fail to set up event-based watchers. For most developers, this should provide a much less resource-intensive experience when running in --watch mode, or running with a TypeScript-powered editor like Visual Studio or VS Code.\n\nThe way file-watching works can still be configured through environment variables and watchOptions - and some editors like VS Code can support watchOptions independently. Developers using more exotic set-ups where source code resides on a networked file systems (like NFS and SMB) may need to opt back into the older behavior; though if a server has reasonable processing power, it might just be better to enable SSH and run TypeScript remotely so that it has direct local file access. VS Code has plenty of remote extensions to make this easier.\n\nYou can read up more on this change on GitHub.\n\n“Remove Unused Imports” and “Sort Imports” Commands for Editors\n\nPreviously, TypeScript only supported two editor commands to manage imports. For our examples, take the following code:\n\nimport { Zebra, Moose, HoneyBadger } from \"./zoo\";\nimport { foo, bar } from \"./helper\";\nlet x: Moose | HoneyBadger = foo();\n\nThe first was called “Organize Imports” which would remove unused imports, and then sort the remaining ones. It would rewrite that file to look like this one:\n\nimport { foo } from \"./helper\";\nimport { HoneyBadger, Moose } from \"./zoo\";\nlet x: Moose | HoneyBadger = foo();\n\nIn TypeScript 4.3, we introduced a command called “Sort Imports” which would only sort imports in the file, but not remove them - and would rewrite the file like this.\n\nimport { bar, foo } from \"./helper\";\nimport { HoneyBadger, Moose, Zebra } from \"./zoo\";\nlet x: Moose | HoneyBadger = foo();\n\nThe caveat with “Sort Imports” was that in Visual Studio Code, this feature was only available as an on-save command - not as a manually triggerable command.\n\nTypeScript 4.9 adds the other half, and now provides “Remove Unused Imports”. TypeScript will now remove unused import names and statements, but will otherwise leave the relative ordering alone.\n\nimport { Moose, HoneyBadger } from \"./zoo\";\nimport { foo } from \"./helper\";\nlet x: Moose | HoneyBadger = foo();\n\nThis feature is available to all editors that wish to use either command; but notably, Visual Studio Code (1.73 and later) will have support built in and will surface these commands via its Command Palette. Users who prefer to use the more granular “Remove Unused Imports” or “Sort Imports” commands should be able to reassign the “Organize Imports” key combination to them if desired.\n\nYou can view specifics of the feature here.\n\nGo-to-Definition on \nreturn\n Keywords\n\nIn the editor, when running a go-to-definition on the return keyword, TypeScript will now jump you to the top of the corresponding function. This can be helpful to get a quick sense of which function a return belongs to.\n\nWe expect TypeScript will expand this functionality to more keywords such as await and yield or switch, case, and default.\n\nThis feature was implemented thanks to Oleksandr Tarasiuk.\n\nPerformance Improvements\n\nTypeScript has a few small, but notable, performance improvements.\n\nFirst, TypeScript’s forEachChild function has been rewritten to use a function table lookup instead of a switch statement across all syntax nodes. forEachChild is a workhorse for traversing syntax nodes in the compiler, and is used heavily in the binding stage of our compiler, along with parts of the language service. The refactoring of forEachChild yielded up to a 20% reduction of time spent in our binding phase and across language service operations.\n\nOnce we discovered this performance win for forEachChild, we tried it out on visitEachChild, a function we use for transforming nodes in the compiler and language service. The same refactoring yielded up to a 3% reduction in time spent in generating project output.\n\nThe initial exploration in forEachChild was inspired by a blog post by Artemis Everfree. While we have some reason to believe the root cause of our speed-up might have more to do with function size/complexity than the issues described in the blog post, we’re grateful that we were able to learn from the experience and try out a relatively quick refactoring that made TypeScript faster.\n\nFinally, the way TypeScript preserves the information about a type in the true branch of a conditional type has been optimized. In a type like\n\ninterface Zoo<T extends Animal> {\n    // ...\n}\ntype MakeZoo<A> = A extends Animal ? Zoo<A> : never;\n\nTypeScript has to “remember” that A must also be an Animal when checking if Zoo<A> is valid. This is basically done by creating a special type that used to hold the intersection of A with Animal; however, TypeScript previously did this eagerly which isn’t always necessary. Furthermore, some faulty code in our type-checker prevented these special types from being simplified. TypeScript now defers intersecting these types until it’s necessary. For codebases with heavy use of conditional types, you might witness significant speed-ups with TypeScript, but in our performance testing suite, we saw a more modest 3% reduction in type-checking time.\n\nYou can read up more on these optimizations on their respective pull requests:\n\nforEachChild as a jump-table\nvisitEachChild as a jump-table\nOptimize substitition types\nCorrectness Fixes and Breaking Changes\nlib.d.ts\n Updates\n\nWhile TypeScript strives to avoid major breaks, even small changes in the built-in libraries can cause issues. We don’t expect major breaks as a result of DOM and lib.d.ts updates, but there may be some small ones.\n\nBetter Types for \nPromise.resolve\n\nPromise.resolve now uses the Awaited type to unwrap Promise-like types passed to it. This means that it more often returns the right Promise type, but that improved type can break existing code if it was expecting any or unknown instead of a Promise. For more information, see the original change.\n\nJavaScript Emit No Longer Elides Imports\n\nWhen TypeScript first supported type-checking and compilation for JavaScript, it accidentally supported a feature called import elision. In short, if an import is not used as a value, or the compiler can detect that the import doesn’t refer to a value at runtime, the compiler will drop the import during emit.\n\nThis behavior was questionable, especially the detection of whether the import doesn’t refer to a value, since it means that TypeScript has to trust sometimes-inaccurate declaration files. In turn, TypeScript now preserves imports in JavaScript files.\n\n// Input:\nimport { someValue, SomeClass } from \"some-module\";\n/** @type {SomeClass} */\nlet val = someValue;\n// Previous Output:\nimport { someValue } from \"some-module\";\n/** @type {SomeClass} */\nlet val = someValue;\n// Current Output:\nimport { someValue, SomeClass } from \"some-module\";\n/** @type {SomeClass} */\nlet val = someValue;\n\nMore information is available at the implementing change.\n\nexports\n is Prioritized Over \ntypesVersions\n\nPreviously, TypeScript incorrectly prioritized the typesVersions field over the exports field when resolving through a package.json under --moduleResolution node16. If this change impacts your library, you may need to add types@ version selectors in your package.json’s exports field.\n\n  {\n      \"type\": \"module\",\n      \"main\": \"./dist/main.js\"\n      \"typesVersions\": {\n          \"<4.8\": { \".\": [\"4.8-types/main.d.ts\"] },\n          \"*\": { \".\": [\"modern-types/main.d.ts\"] }\n      },\n      \"exports\": {\n          \".\": {\n+             \"types@<4.8\": \"4.8-types/main.d.ts\",\n+             \"types\": \"modern-types/main.d.ts\",\n              \"import\": \"./dist/main.js\"\n          }\n      }\n  }\n\nFor more information, see this pull request.\n\nsubstitute\n Replaced With \nconstraint\n on \nSubstitutionType\ns\n\nAs part of an optimization on substitution types, SubstitutionType objects no longer contain the substitute property representing the effective substitution (usually an intersection of the base type and the implicit constraint) - instead, they just contain the constraint property.\n\nFor more details, read more on the original pull request.\n\nOn this page\nThe satisfies Operator\nUnlisted Property Narrowing with the in Operator\nAuto-Accessors in Classes\nChecks For Equality on NaN\nFile-Watching Now Uses File System Events\n“Remove Unused Imports” and “Sort Imports” Commands for Editors\nGo-to-Definition on return Keywords\nPerformance Improvements\nCorrectness Fixes and Breaking Changes\nlib.d.ts Updates\nBetter Types for Promise.resolve\nJavaScript Emit No Longer Elides Imports\nexports is Prioritized Over typesVersions\nsubstitute Replaced With constraint on SubstitutionTypes\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nN\n제\nN\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.476 seconds."
  },
  {
    "title": "TypeScript: Documentation - TypeScript 5.3",
    "url": "https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-3.html",
    "html": "TypeScript 5.3\nImport Attributes\n\nTypeScript 5.3 supports the latest updates to the import attributes proposal.\n\nOne use-case of import attributes is to provide information about the expected format of a module to the runtime.\n\n// We only want this to be interpreted as JSON,\n// not a runnable/malicious JavaScript file with a `.json` extension.\nimport obj from \"./something.json\" with { type: \"json\" };\n\nThe contents of these attributes are not checked by TypeScript since they’re host-specific, and are simply left alone so that browsers and runtimes can handle them (and possibly error).\n\n// TypeScript is fine with this.\n// But your browser? Probably not.\nimport * as foo from \"./foo.js\" with { type: \"fluffy bunny\" };\n\nDynamic import() calls can also use import attributes through a second argument.\n\nconst obj = await import(\"./something.json\", {\n    with: { type: \"json\" }\n});\n\nThe expected type of that second argument is defined by a type called ImportCallOptions, which by default just expects a property called with.\n\nNote that import attributes are an evolution of an earlier proposal called “import assertions”, which were implemented in TypeScript 4.5. The most obvious difference is the use of the with keyword over the assert keyword. But the less-visible difference is that runtimes are now free to use attributes to guide the resolution and interpretation of import paths, whereas import assertions could only assert some characteristics after loading a module.\n\nOver time, TypeScript will be deprecating the old syntax for import assertions in favor of the proposed syntax for import attributes. Existing code using assert should migrate towards the with keyword. New code that needs an import attribute should use with exclusively.\n\nWe’d like to thank Oleksandr Tarasiuk for implementing this proposal! And we’d also like to call out Wenlu Wang for their implementation of import assertions!\n\nStable Support \nresolution-mode\n in Import Types\n\nIn TypeScript 4.7, TypeScript added support for a resolution-mode attribute in /// <reference types=\"...\" /> to control whether a specifier should be resolved via import or require semantics.\n\n/// <reference types=\"pkg\" resolution-mode=\"require\" />\n// or\n/// <reference types=\"pkg\" resolution-mode=\"import\" />\n\nA corresponding field was added to import assertions on type-only imports as well; however, it was only supported in nightly versions of TypeScript. The rationale was that in spirit, import assertions were not intended to guide module resolution. So this feature was shipped experimentally in a nightly-only mode to get more feedback.\n\nBut given that import attributes can guide resolution, and that we’ve seen reasonable use-cases, TypeScript 5.3 now supports the resolution-mode attribute for import type.\n\n// Resolve `pkg` as if we were importing with a `require()`\nimport type { TypeFromRequire } from \"pkg\" with {\n    \"resolution-mode\": \"require\"\n};\n// Resolve `pkg` as if we were importing with an `import`\nimport type { TypeFromImport } from \"pkg\" with {\n    \"resolution-mode\": \"import\"\n};\nexport interface MergedType extends TypeFromRequire, TypeFromImport {}\n\nThese import attributes can also be used on import() types.\n\nexport type TypeFromRequire =\n    import(\"pkg\", { with: { \"resolution-mode\": \"require\" } }).TypeFromRequire;\nexport type TypeFromImport =\n    import(\"pkg\", { with: { \"resolution-mode\": \"import\" } }).TypeFromImport;\nexport interface MergedType extends TypeFromRequire, TypeFromImport {}\n\nFor more information, check out the change here\n\nresolution-mode\n Supported in All Module Modes\n\nPreviously, using resolution-mode was only allowed under the moduleResolution options node16 and nodenext. To make it easier to look up modules specifically for type purposes, resolution-mode now works appropriately in all other moduleResolution options like bundler, node10, and simply doesn’t error under classic.\n\nFor more information, see the implementing pull request.\n\nswitch (true)\n Narrowing\n\nTypeScript 5.3 now can perform narrowing based on conditions in each case clause within a switch (true).\n\nfunction f(x: unknown) {\n    switch (true) {\n        case typeof x === \"string\":\n            // 'x' is a 'string' here\n            console.log(x.toUpperCase());\n            // falls through...\n        case Array.isArray(x):\n            // 'x' is a 'string | any[]' here.\n            console.log(x.length);\n            // falls through...\n        default:\n          // 'x' is 'unknown' here.\n          // ...\n    }\n}\n\nThis feature was spearheaded initial work by Mateusz Burzyński We’d like to extend a “thank you!” for this contribution.\n\nNarrowing On Comparisons to Booleans\n\nOccasionally you may find yourself performing a direct comparison with true or false in a condition. Usually these are unnecessary comparisons, but you might prefer it as a point of style, or to avoid certain issues around JavaScript truthiness. Regardless, previously TypeScript just didn’t recognize such forms when performing narrowing.\n\nTypeScript 5.3 now keeps up and understands these expressions when narrowing variables.\n\ninterface A {\n    a: string;\n}\ninterface B {\n    b: string;\n}\ntype MyType = A | B;\nfunction isA(x: MyType): x is A {\n    return \"a\" in x;\n}\nfunction someFn(x: MyType) {\n    if (isA(x) === true) {\n        console.log(x.a); // works!\n    }\n}\n\nWe’d like to thank Mateusz Burzyński for the pull request that implemented this.\n\ninstanceof\n Narrowing Through \nSymbol.hasInstance\n\nA slightly esoteric feature of JavaScript is that it is possible to override the behavior of the instanceof operator. To do so, the value on the right side of the instanceof operator needs to have a specific method named by Symbol.hasInstance.\n\nclass Weirdo {\n    static [Symbol.hasInstance](testedValue) {\n        // wait, what?\n        return testedValue === undefined;\n    }\n}\n// false\nconsole.log(new Thing() instanceof Weirdo);\n// true\nconsole.log(undefined instanceof Weirdo);\n\nTo better model this behavior in instanceof, TypeScript now checks if such a [Symbol.hasInstance] method exists and is declared as a type predicate function. If it does, the tested value on the left side of the instanceof operator will be narrowed appropriately by that type predicate.\n\ninterface PointLike {\n    x: number;\n    y: number;\n}\nclass Point implements PointLike {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n    distanceFromOrigin() {\n        return Math.sqrt(this.x ** 2 + this.y ** 2);\n    }\n    static [Symbol.hasInstance](val: unknown): val is PointLike {\n        return !!val && typeof val === \"object\" &&\n            \"x\" in val && \"y\" in val &&\n            typeof val.x === \"number\" &&\n            typeof val.y === \"number\";\n    }\n}\nfunction f(value: unknown) {\n    if (value instanceof Point) {\n        // Can access both of these - correct!\n        value.x;\n        value.y;\n        // Can't access this - we have a 'PointLike',\n        // but we don't *actually* have a 'Point'.\n        value.distanceFromOrigin();\n    }\n}\n\nAs you can see in this example, Point defines its own [Symbol.hasInstance] method. It actually acts as a custom type guard over a separate type called PointLike. In the function f, we were able to narrow value down to a PointLike with instanceof, but not a Point. That means that we can access the properties x and y, but not the method distanceFromOrigin.\n\nFor more information, you can read up on this change here.\n\nChecks for \nsuper\n Property Accesses on Instance Fields\n\nIn JavaScript, it’s possible to access a declaration in a base class through the super keyword.\n\nclass Base {\n    someMethod() {\n        console.log(\"Base method called!\");\n    }\n}\nclass Derived extends Base {\n    someMethod() {\n        console.log(\"Derived method called!\");\n        super.someMethod();\n    }\n}\nnew Derived().someMethod();\n// Prints:\n//   Derived method called!\n//   Base method called!\n\nThis is different from writing something like this.someMethod(), since that could invoke an overridden method. This is a subtle distinction, made more subtle by the fact that often the two can be interchangeable if a declaration is never overridden at all.\n\nclass Base {\n    someMethod() {\n        console.log(\"someMethod called!\");\n    }\n}\nclass Derived extends Base {\n    someOtherMethod() {\n        // These act identically.\n        this.someMethod();\n        super.someMethod();\n    }\n}\nnew Derived().someOtherMethod();\n// Prints:\n//   someMethod called!\n//   someMethod called!\n\nThe problem is using them interchangeably is that super only works on members declared on the prototype — not instance properties. That means that if you wrote super.someMethod(), but someMethod was defined as a field, you’d get a runtime error!\n\nclass Base {\n    someMethod = () => {\n        console.log(\"someMethod called!\");\n    }\n}\nclass Derived extends Base {\n    someOtherMethod() {\n        super.someMethod();\n    }\n}\nnew Derived().someOtherMethod();\n// 💥\n// Doesn't work because 'super.someMethod' is 'undefined'.\n\nTypeScript 5.3 now more-closely inspects super property accesses/method calls to see if they correspond to class fields. If they do, we’ll now get a type-checking error.\n\nThis check was contributed thanks to Jack Works!\n\nInteractive Inlay Hints for Types\n\nTypeScript’s inlay hints now support jumping to the definition of types! This makes it easier to casually navigate your code.\n\nSee more at the implementation here.\n\nSettings to Prefer \ntype\n Auto-Imports\n\nPreviously when TypeScript generated auto-imports for something in a type position, it would add a type modifier based on your settings. For example, when getting an auto-import on Person in the following:\n\nexport let p: Person\n\nTypeScript’s editing experience would usually add an import for Person as:\n\nimport { Person } from \"./types\";\nexport let p: Person\n\nand under certain settings like verbatimModuleSyntax, it would add the type modifier:\n\nimport { type Person } from \"./types\";\nexport let p: Person\n\nHowever, maybe your codebase isn’t able to use some of these options; or you just have a preference for explicit type imports when possible.\n\nWith a recent change, TypeScript now enables this to be an editor-specific option. In Visual Studio Code, you can enable it in the UI under “TypeScript › Preferences: Prefer Type Only Auto Imports”, or as the JSON configuration option typescript.preferences.preferTypeOnlyAutoImports\n\nOptimizations by Skipping JSDoc Parsing\n\nWhen running TypeScript via tsc, the compiler will now avoid parsing JSDoc. This drops parsing time on its own, but also reduces memory usage to store comments along with time spent in garbage collection. All-in-all, you should see slightly faster compiles and quicker feedback in --watch mode.\n\nThe specific changes can be viewed here.\n\nBecause not every tool using TypeScript will need to store JSDoc (e.g. typescript-eslint and Prettier), this parsing strategy has been surfaced as part of the API itself. This can enable these tools to gain the same memory and speed improvements we’ve brought to the TypeScript compiler. The new options for comment parsing strategy are described in JSDocParsingMode. More information is available on this pull request.\n\nOptimizations by Comparing Non-Normalized Intersections\n\nIn TypeScript, unions and intersections always follow a specific form, where intersections can’t contain union types. That means that when we create an intersection over a union like A & (B | C), that intersection will be normalized into (A & B) | (A & C). Still, in some cases the type system will maintain the original form for display purposes.\n\nIt turns out that the original form can be used for some clever fast-path comparisons between types.\n\nFor example, let’s say we have SomeType & (Type1 | Type2 | ... | Type99999NINE) and we want to see if that’s assignable to SomeType. Recall that we don’t really have an intersection as our source type — we have a union that looks like (SomeType & Type1) | (SomeType & Type2) | ... |(SomeType & Type99999NINE). When checking if a union is assignable to some target type, we have to check if every member of the union is assignable to the target type, and that can be very slow.\n\nIn TypeScript 5.3, we peek at the original intersection form that we were able to tuck away. When we compare the types, we do a quick check to see if the target exists in any constituent of the source intersection.\n\nFor more information, see this pull request.\n\nConsolidation Between \ntsserverlibrary.js\n and \ntypescript.js\n\nTypeScript itself ships two library files: tsserverlibrary.js and typescript.js. There are certain APIs available only in tsserverlibrary.js (like the ProjectService API), which may be useful to some importers. Still, the two are distinct bundles with have a lot of overlap, duplicating code in the package. What’s more, it can be challenging to consistently use one over the other due to auto-imports or muscle memory. Accidentally loading both modules is far too easy, and code may not work properly on a different instance of the API. Even if it does work, loading a second bundle increases resource usage.\n\nGiven this, we’ve decided to consolidate the two. typescript.js now contains what tsserverlibrary.js used to contain, and tsserverlibrary.js now simply re-exports typescript.js. Comparing the before/after of this consolidation, we saw the following reduction in package size:\n\n\tBefore\tAfter\tDiff\tDiff (percent)\nPacked\t6.90 MiB\t5.48 MiB\t-1.42 MiB\t-20.61%\nUnpacked\t38.74 MiB\t30.41 MiB\t-8.33 MiB\t-21.50%\n\tBefore\tAfter\tDiff\tDiff (percent)\nlib/tsserverlibrary.d.ts\t570.95 KiB\t865.00 B\t-570.10 KiB\t-99.85%\nlib/tsserverlibrary.js\t8.57 MiB\t1012.00 B\t-8.57 MiB\t-99.99%\nlib/typescript.d.ts\t396.27 KiB\t570.95 KiB\t+174.68 KiB\t+44.08%\nlib/typescript.js\t7.95 MiB\t8.57 MiB\t+637.53 KiB\t+7.84%\n\nIn other words, this is over a 20.5% reduction in package size.\n\nFor more information, you can see the work involved here.\n\nBreaking Changes and Correctness Improvements\nlib.d.ts\n Changes\n\nTypes generated for the DOM may have an impact on your codebase. For more information, see the DOM updates for TypeScript 5.3.\n\nChecks for \nsuper\n Accesses on Instance Properties\n\nTypeScript 5.3 now detects when the declaration referenced by a super. property access is a class field and issues an error. This prevents errors that might occur at runtime.\n\nSee more on this change here.\n\nOn this page\nImport Attributes\nStable Support resolution-mode in Import Types\nresolution-mode Supported in All Module Modes\nswitch (true) Narrowing\nNarrowing On Comparisons to Booleans\ninstanceof Narrowing Through Symbol.hasInstance\nChecks for super Property Accesses on Instance Fields\nInteractive Inlay Hints for Types\nSettings to Prefer type Auto-Imports\nOptimizations by Skipping JSDoc Parsing\nOptimizations by Comparing Non-Normalized Intersections\nConsolidation Between tsserverlibrary.js and typescript.js\nBreaking Changes and Correctness Improvements\nlib.d.ts Changes\nChecks for super Accesses on Instance Properties\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.296 seconds."
  },
  {
    "title": "TypeScript: Documentation - Using Babel with TypeScript",
    "url": "https://www.typescriptlang.org/docs/handbook/babel-with-typescript.html",
    "html": "Using Babel with TypeScript\nBabel vs \ntsc\n for TypeScript\n\nWhen making a modern JavaScript project, you might ask yourself what is the right way to convert files from TypeScript to JavaScript?\n\nA lot of the time the answer is “it depends”, or “someone may have decided for you” depending on the project. If you are building your project with an existing framework like tsdx, Angular, NestJS or any framework mentioned in the Getting Started then this decision is handled for you.\n\nHowever, a useful heuristic could be:\n\nIs your build output mostly the same as your source input files? Use tsc\nDo you need a build pipeline with multiple potential outputs? Use babel for transpiling and tsc for type checking\nBabel for transpiling, \ntsc\n for types\n\nThis is a common pattern for projects with existing build infrastructure which may have been ported from a JavaScript codebase to TypeScript.\n\nThis technique is a hybrid approach, using Babel’s preset-typescript to generate your JS files, and then using TypeScript to do type checking and .d.ts file generation.\n\nBy using babel’s support for TypeScript, you get the ability to work with existing build pipelines and are more likely to have a faster JS emit time because Babel does not type check your code.\n\nType Checking and d.ts file generation\n\nThe downside to using babel is that you don’t get type checking during the transition from TS to JS. This can mean that type errors which you miss in your editor could sneak through into production code.\n\nIn addition to that, Babel cannot create .d.ts files for your TypeScript which can make it harder to work with your project if it is a library.\n\nTo fix these issues, you would probably want to set up a command to type check your project using TSC. This likely means duplicating some of your babel config into a corresponding tsconfig.json and ensuring these flags are enabled:\n\n\"compilerOptions\": {\n  // Ensure that .d.ts files are created by tsc, but not .js files\n  \"declaration\": true,\n  \"emitDeclarationOnly\": true,\n  // Ensure that Babel can safely transpile files in the TypeScript project\n  \"isolatedModules\": true\n}\n\nFor more information on these flags:\n\nisolatedModules\ndeclaration, emitDeclarationOnly\nOn this page\nBabel vs tsc for TypeScript\nBabel for transpiling, tsc for types\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nR\nUS\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.265 seconds."
  },
  {
    "title": "TypeScript: Documentation - Migrating from JavaScript",
    "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
    "html": "Migrating from JavaScript\n\nTypeScript doesn’t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we’re going to look at how you might start out. We assume you’ve read enough of the handbook to write new TypeScript code.\n\nIf you’re looking to convert a React project, we recommend looking at the React Conversion Guide first.\n\nSetting up your Directories\n\nIf you’re writing in plain JavaScript, it’s likely that you’re running your JavaScript directly, where your .js files are in a src, lib, or dist directory, and then run as desired.\n\nIf that’s the case, the files that you’ve written are going to be used as inputs to TypeScript, and you’ll run the outputs it produces. During our JS to TS migration, we’ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.\n\nYou might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.\n\nFrom this point on, we’re going to assume that your directory is set up something like this:\n\nprojectRoot\n├── src\n│   ├── file1.js\n│   └── file2.js\n├── built\n└── tsconfig.json\n\nIf you have a tests folder outside of your src directory, you might have one tsconfig.json in src, and one in tests as well.\n\nWriting a Configuration File\n\nTypeScript uses a file called tsconfig.json for managing your project’s options, such as which files you want to include, and what sorts of checking you want to perform. Let’s create a bare-bones one for our project:\n\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./built\",\n    \"allowJs\": true,\n    \"target\": \"es5\"\n  },\n  \"include\": [\"./src/**/*\"]\n}\n\nHere we’re specifying a few things to TypeScript:\n\nRead in any files it understands in the src directory (with include).\nAccept JavaScript files as inputs (with allowJs).\nEmit all of the output files in built (with outDir).\nTranslate newer JavaScript constructs down to an older version like ECMAScript 5 (using target).\n\nAt this point, if you try running tsc at the root of your project, you should see output files in the built directory. The layout of files in built should look identical to the layout of src. You should now have TypeScript working with your project.\n\nEarly Benefits\n\nEven at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like VS Code or Visual Studio, you’ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:\n\nnoImplicitReturns which prevents you from forgetting to return at the end of a function.\nnoFallthroughCasesInSwitch which is helpful if you never want to forget a break statement between cases in a switch block.\n\nTypeScript will also warn about unreachable code and labels, which you can disable with allowUnreachableCode and allowUnusedLabels respectively.\n\nIntegrating with Build Tools\n\nYou might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we’ll do our best to cover the gist of things.\n\nGulp\n\nIf you’re using Gulp in some fashion, we have a tutorial on using Gulp with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.\n\nWebpack\n\nWebpack integration is pretty simple. You can use ts-loader, a TypeScript loader, combined with source-map-loader for easier debugging. Simply run\n\nnpm install ts-loader source-map-loader\n\nand merge in options from the following into your webpack.config.js file:\n\nmodule.exports = {\n  entry: \"./src/index.ts\",\n  output: {\n    filename: \"./dist/bundle.js\",\n  },\n  // Enable sourcemaps for debugging webpack's output.\n  devtool: \"source-map\",\n  resolve: {\n    // Add '.ts' and '.tsx' as resolvable extensions.\n    extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"],\n  },\n  module: {\n    rules: [\n      // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'.\n      { test: /\\.tsx?$/, loader: \"ts-loader\" },\n      // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'.\n      { test: /\\.js$/, loader: \"source-map-loader\" },\n    ],\n  },\n  // Other options...\n};\n\nIt’s important to note that ts-loader will need to run before any other loader that deals with .js files.\n\nYou can see an example of using Webpack in our tutorial on React and Webpack.\n\nMoving to TypeScript Files\n\nAt this point, you’re probably ready to start using TypeScript files. The first step is to rename one of your .js files to .ts. If your file uses JSX, you’ll need to rename it to .tsx.\n\nFinished with that step? Great! You’ve successfully migrated a file from JavaScript to TypeScript!\n\nOf course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run tsc --pretty), you might see red squiggles on certain lines. You should think of these the same way you’d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.\n\nIf that sounds too lax for you, you can tighten that behavior up. If, for instance, you don’t want TypeScript to compile to JavaScript in the face of errors, you can use the noEmitOnError option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.\n\nIf you plan on using the stricter settings that are available, it’s best to turn them on now (see Getting Stricter Checks below). For instance, if you never want TypeScript to silently infer any for a type without you explicitly saying so, you can use noImplicitAny before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.\n\nWeeding out Errors\n\nLike we mentioned, it’s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you’ll have to explain what you’re trying to do a little better to TypeScript.\n\nImporting from Modules\n\nYou might start out getting a bunch of errors like Cannot find name 'require'., and Cannot find name 'define'.. In these cases, it’s likely that you’re using modules. While you can just convince TypeScript that these exist by writing out\n\n// For Node/CommonJS\ndeclare function require(path: string): any;\n\nor\n\n// For RequireJS/AMD\ndeclare function define(...args: any[]): any;\n\nit’s better to get rid of those calls and use TypeScript syntax for imports.\n\nFirst, you’ll need to enable some module system by setting TypeScript’s module option. Valid options are commonjs, amd, system, and umd.\n\nIf you had the following Node/CommonJS code:\n\nvar foo = require(\"foo\");\nfoo.doStuff();\n\nor the following RequireJS/AMD code:\n\ndefine([\"foo\"], function (foo) {\n  foo.doStuff();\n});\n\nthen you would write the following TypeScript code:\n\nimport foo = require(\"foo\");\nfoo.doStuff();\nGetting Declaration Files\n\nIf you started converting over to TypeScript imports, you’ll probably run into errors like Cannot find module 'foo'.. The issue here is that you likely don’t have declaration files to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like lodash, you can just write\n\nnpm install -S @types/lodash\n\nIf you’re using a module option other than commonjs, you’ll need to set your moduleResolution option to node.\n\nAfter that, you’ll be able to import lodash with no issues, and get accurate completions.\n\nExporting from Modules\n\nTypically, exporting from a module involves adding properties to a value like exports or module.exports. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:\n\nmodule.exports.feedPets = function (pets) {\n  // ...\n};\n\nyou could write that out as the following:\n\nexport function feedPets(pets) {\n  // ...\n}\n\nSometimes you’ll entirely overwrite the exports object. This is a common pattern people use to make their modules immediately callable like in this snippet:\n\nvar express = require(\"express\");\nvar app = express();\n\nYou might have previously written that like so:\n\nfunction foo() {\n  // ...\n}\nmodule.exports = foo;\n\nIn TypeScript, you can model this with the export = construct.\n\nfunction foo() {\n  // ...\n}\nexport = foo;\nToo many/too few arguments\n\nYou’ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the arguments object instead of writing out any parameters:\n\nfunction myCoolFunction() {\n  if (arguments.length == 2 && !Array.isArray(arguments[1])) {\n    var f = arguments[0];\n    var arr = arguments[1];\n    // ...\n  }\n  // ...\n}\nmyCoolFunction(\n  function (x) {\n    console.log(x);\n  },\n  [1, 2, 3, 4]\n);\nmyCoolFunction(\n  function (x) {\n    console.log(x);\n  },\n  1,\n  2,\n  3,\n  4\n);\n\nIn this case, we need to use TypeScript to tell any of our callers about the ways myCoolFunction can be called using function overloads.\n\nfunction myCoolFunction(f: (x: number) => void, nums: number[]): void;\nfunction myCoolFunction(f: (x: number) => void, ...nums: number[]): void;\nfunction myCoolFunction() {\n  if (arguments.length == 2 && !Array.isArray(arguments[1])) {\n    var f = arguments[0];\n    var arr = arguments[1];\n    // ...\n  }\n  // ...\n}\n\nWe added two overload signatures to myCoolFunction. The first checks states that myCoolFunction takes a function (which takes a number), and then a list of numbers. The second one says that it will take a function as well, and then uses a rest parameter (...nums) to state that any number of arguments after that need to be numbers.\n\nSequentially Added Properties\n\nSome people find it more aesthetically pleasing to create an object and add properties immediately after like so:\n\nvar options = {};\noptions.color = \"red\";\noptions.volume = 11;\n\nTypeScript will say that you can’t assign to color and volume because it first figured out the type of options as {} which doesn’t have any properties. If you instead moved the declarations into the object literal themselves, you’d get no errors:\n\nlet options = {\n  color: \"red\",\n  volume: 11,\n};\n\nYou could also define the type of options and add a type assertion on the object literal.\n\ninterface Options {\n  color: string;\n  volume: number;\n}\nlet options = {} as Options;\noptions.color = \"red\";\noptions.volume = 11;\n\nAlternatively, you can just say options has the type any which is the easiest thing to do, but which will benefit you the least.\n\nany, Object, and {}\n\nYou might be tempted to use Object or {} to say that a value can have any property on it because Object is, for most purposes, the most general type. However any is actually the type you want to use in those situations, since it’s the most flexible type.\n\nFor instance, if you have something that’s typed as Object you won’t be able to call methods like toLowerCase() on it. Being more general usually means you can do less with a type, but any is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use any, you lose out on most of the error checking and editor support that TypeScript gives you.\n\nIf a decision ever comes down to Object and {}, you should prefer {}. While they are mostly the same, technically {} is a more general type than Object in certain esoteric cases.\n\nGetting Stricter Checks\n\nTypeScript comes with certain checks to give you more safety and analysis of your program. Once you’ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.\n\nNo Implicit any\n\nThere are certain cases where TypeScript can’t figure out what certain types should be. To be as lenient as possible, it will decide to use the type any in its place. While this is great for migration, using any means that you’re not getting any type safety, and you won’t get the same tooling support you’d get elsewhere. You can tell TypeScript to flag these locations down and give an error with the noImplicitAny option.\n\nStrict null & undefined Checks\n\nBy default, TypeScript assumes that null and undefined are in the domain of every type. That means anything declared with the type number could be null or undefined. Since null and undefined are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the strictNullChecks option to spare you the stress of worrying about these issues.\n\nWhen strictNullChecks is enabled, null and undefined get their own types called null and undefined respectively. Whenever anything is possibly null, you can use a union type with the original type. So for instance, if something could be a number or null, you’d write the type out as number | null.\n\nIf you ever have a value that TypeScript thinks is possibly null/undefined, but you know better, you can use the postfix ! operator to tell it otherwise.\n\ndeclare var foo: string[] | null;\nfoo.length; // error - 'foo' is possibly 'null'\nfoo!.length; // okay - 'foo!' just has type 'string[]'\n\nAs a heads up, when using strictNullChecks, your dependencies may need to be updated to use strictNullChecks as well.\n\nNo Implicit any for this\n\nWhen you use the this keyword outside of classes, it has the type any by default. For instance, imagine a Point class, and imagine a function that we wish to add as a method:\n\nclass Point {\n  constructor(public x, public y) {}\n  getDistance(p: Point) {\n    let dx = p.x - this.x;\n    let dy = p.y - this.y;\n    return Math.sqrt(dx ** 2 + dy ** 2);\n  }\n}\n// ...\n// Reopen the interface.\ninterface Point {\n  distanceFromOrigin(): number;\n}\nPoint.prototype.distanceFromOrigin = function () {\n  return this.getDistance({ x: 0, y: 0 });\n};\n\nThis has the same problems we mentioned above - we could easily have misspelled getDistance and not gotten an error. For this reason, TypeScript has the noImplicitThis option. When that option is set, TypeScript will issue an error when this is used without an explicit (or inferred) type. The fix is to use a this-parameter to give an explicit type in the interface or in the function itself:\n\nPoint.prototype.distanceFromOrigin = function (this: Point) {\n  return this.getDistance({ x: 0, y: 0 });\n};\nOn this page\nSetting up your Directories\nWriting a Configuration File\nEarly Benefits\nIntegrating with Build Tools\nGulp\nWebpack\nMoving to TypeScript Files\nWeeding out Errors\nGetting Stricter Checks\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nTA\nMG\nMF\n19+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.322 seconds."
  },
  {
    "title": "TypeScript: Documentation - DOM Manipulation",
    "url": "https://www.typescriptlang.org/docs/handbook/dom-manipulation.html",
    "html": "DOM Manipulation\nDOM Manipulation\nAn exploration into the HTMLElement type\n\nIn the 20+ years since its standardization, JavaScript has come a very long way. While in 2020, JavaScript can be used on servers, in data science, and even on IoT devices, it is important to remember its most popular use case: web browsers.\n\nWebsites are made up of HTML and/or XML documents. These documents are static, they do not change. The Document Object Model (DOM) is a programming interface implemented by browsers to make static websites functional. The DOM API can be used to change the document structure, style, and content. The API is so powerful that countless frontend frameworks (jQuery, React, Angular, etc.) have been developed around it to make dynamic websites even easier to develop.\n\nTypeScript is a typed superset of JavaScript, and it ships type definitions for the DOM API. These definitions are readily available in any default TypeScript project. Of the 20,000+ lines of definitions in lib.dom.d.ts, one stands out among the rest: HTMLElement. This type is the backbone for DOM manipulation with TypeScript.\n\nYou can explore the source code for the DOM type definitions\n\nBasic Example\n\nGiven a simplified index.html file:\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head><title>TypeScript Dom Manipulation</title></head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- Assume index.js is the compiled output of index.ts -->\n    <script src=\"index.js\"></script>\n  </body>\n</html>\n\nLet’s explore a TypeScript script that adds a <p>Hello, World!</p> element to the #app element.\n\n// 1. Select the div element using the id property\nconst app = document.getElementById(\"app\");\n// 2. Create a new <p></p> element programmatically\nconst p = document.createElement(\"p\");\n// 3. Add the text content\np.textContent = \"Hello, World!\";\n// 4. Append the p element to the div element\napp?.appendChild(p);\n\nAfter compiling and running the index.html page, the resulting HTML will be:\n\n<div id=\"app\">\n  <p>Hello, World!</p>\n</div>\nThe \nDocument\n Interface\n\nThe first line of the TypeScript code uses a global variable document. Inspecting the variable shows it is defined by the Document interface from the lib.dom.d.ts file. The code snippet contains calls to two methods, getElementById and createElement.\n\nDocument.getElementById\n\nThe definition for this method is as follows:\n\ngetElementById(elementId: string): HTMLElement | null;\n\nPass it an element id string and it will return either HTMLElement or null. This method introduces one of the most important types, HTMLElement. It serves as the base interface for every other element interface. For example, the p variable in the code example is of type HTMLParagraphElement. Also, take note that this method can return null. This is because the method can’t be certain pre-runtime if it will be able to actually find the specified element or not. In the last line of the code snippet, the new optional chaining operator is used to call appendChild.\n\nDocument.createElement\n\nThe definition for this method is (I have omitted the deprecated definition):\n\ncreateElement<K extends keyof HTMLElementTagNameMap>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K];\ncreateElement(tagName: string, options?: ElementCreationOptions): HTMLElement;\n\nThis is an overloaded function definition. The second overload is simplest and works a lot like the getElementById method does. Pass it any string and it will return a standard HTMLElement. This definition is what enables developers to create unique HTML element tags.\n\nFor example document.createElement('xyz') returns a <xyz></xyz> element, clearly not an element that is specified by the HTML specification.\n\nFor those interested, you can interact with custom tag elements using the document.getElementsByTagName\n\nFor the first definition of createElement, it is using some advanced generic patterns. It is best understood broken down into chunks, starting with the generic expression: <K extends keyof HTMLElementTagNameMap>. This expression defines a generic parameter K that is constrained to the keys of the interface HTMLElementTagNameMap. The map interface contains every specified HTML tag name and its corresponding type interface. For example here are the first 5 mapped values:\n\ninterface HTMLElementTagNameMap {\n    \"a\": HTMLAnchorElement;\n    \"abbr\": HTMLElement;\n    \"address\": HTMLElement;\n    \"applet\": HTMLAppletElement;\n    \"area\": HTMLAreaElement;\n        ...\n}\n\nSome elements do not exhibit unique properties and so they just return HTMLElement, but other types do have unique properties and methods so they return their specific interface (which will extend from or implement HTMLElement).\n\nNow, for the remainder of the createElement definition: (tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]. The first argument tagName is defined as the generic parameter K. The TypeScript interpreter is smart enough to infer the generic parameter from this argument. This means that the developer does not have to specify the generic parameter when using the method; whatever value is passed to the tagName argument will be inferred as K and thus can be used throughout the remainder of the definition. This is exactly what happens; the return value HTMLElementTagNameMap[K] takes the tagName argument and uses it to return the corresponding type. This definition is how the p variable from the code snippet gets a type of HTMLParagraphElement. And if the code was document.createElement('a'), then it would be an element of type HTMLAnchorElement.\n\nThe \nNode\n interface\n\nThe document.getElementById function returns an HTMLElement. HTMLElement interface extends the Element interface which extends the Node interface. This prototypal extension allows for all HTMLElements to utilize a subset of standard methods. In the code snippet, we use a property defined on the Node interface to append the new p element to the website.\n\nNode.appendChild\n\nThe last line of the code snippet is app?.appendChild(p). The previous, document.getElementById, section detailed that the optional chaining operator is used here because app can potentially be null at runtime. The appendChild method is defined by:\n\nappendChild<T extends Node>(newChild: T): T;\n\nThis method works similarly to the createElement method as the generic parameter T is inferred from the newChild argument. T is constrained to another base interface Node.\n\nDifference between \nchildren\n and \nchildNodes\n\nPreviously, this document details the HTMLElement interface extends from Element which extends from Node. In the DOM API there is a concept of children elements. For example in the following HTML, the p tags are children of the div element\n\n<div>\n  <p>Hello, World</p>\n  <p>TypeScript!</p>\n</div>;\nconst div = document.getElementsByTagName(\"div\")[0];\ndiv.children;\n// HTMLCollection(2) [p, p]\ndiv.childNodes;\n// NodeList(2) [p, p]\n\nAfter capturing the div element, the children prop will return an HTMLCollection list containing the HTMLParagraphElements. The childNodes property will return a similar NodeList list of nodes. Each p tag will still be of type HTMLParagraphElements, but the NodeList can contain additional HTML nodes that the HTMLCollection list cannot.\n\nModify the HTML by removing one of the p tags, but keep the text.\n\n<div>\n  <p>Hello, World</p>\n  TypeScript!\n</div>;\nconst div = document.getElementsByTagName(\"div\")[0];\ndiv.children;\n// HTMLCollection(1) [p]\ndiv.childNodes;\n// NodeList(2) [p, text]\n\nSee how both lists change. children now only contains the <p>Hello, World</p> element, and the childNodes contains a text node rather than two p nodes. The text part of the NodeList is the literal Node containing the text TypeScript!. The children list does not contain this Node because it is not considered an HTMLElement.\n\nThe \nquerySelector\n and \nquerySelectorAll\n methods\n\nBoth of these methods are great tools for getting lists of dom elements that fit a more unique set of constraints. They are defined in lib.dom.d.ts as:\n\n/**\n * Returns the first element that is a descendant of node that matches selectors.\n */\nquerySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\nquerySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\nquerySelector<E extends Element = Element>(selectors: string): E | null;\n/**\n * Returns all element descendants of node that match selectors.\n */\nquerySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>;\nquerySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>;\nquerySelectorAll<E extends Element = Element>(selectors: string): NodeListOf<E>;\n\nThe querySelectorAll definition is similar to getElementsByTagName, except it returns a new type: NodeListOf. This return type is essentially a custom implementation of the standard JavaScript list element. Arguably, replacing NodeListOf<E> with E[] would result in a very similar user experience. NodeListOf only implements the following properties and methods: length, item(index), forEach((value, key, parent) => void), and numeric indexing. Additionally, this method returns a list of elements, not nodes, which is what NodeList was returning from the .childNodes method. While this may appear as a discrepancy, take note that interface Element extends from Node.\n\nTo see these methods in action modify the existing code to:\n\n<ul>\n  <li>First :)</li>\n  <li>Second!</li>\n  <li>Third times a charm.</li>\n</ul>;\nconst first = document.querySelector(\"li\"); // returns the first li element\nconst all = document.querySelectorAll(\"li\"); // returns the list of all li elements\nInterested in learning more?\n\nThe best part about the lib.dom.d.ts type definitions is that they are reflective of the types annotated in the Mozilla Developer Network (MDN) documentation site. For example, the HTMLElement interface is documented by this HTMLElement page on MDN. These pages list all available properties, methods, and sometimes even examples. Another great aspect of the pages is that they provide links to the corresponding standard documents. Here is the link to the W3C Recommendation for HTMLElement.\n\nSources:\n\nECMA-262 Standard\nIntroduction to the DOM\nOn this page\nDOM Manipulation\nAn exploration into the HTMLElement type\nBasic Example\nThe Document Interface\nDocument.getElementById\nDocument.createElement\nThe Node interface\nNode.appendChild\nDifference between children and childNodes\nThe querySelector and querySelectorAll methods\nInterested in learning more?\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nEA\nOT\nSA\nM\nIO\n6+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 4.16 seconds."
  },
  {
    "title": "TypeScript: Documentation - Gulp",
    "url": "https://www.typescriptlang.org/docs/handbook/gulp.html",
    "html": "Gulp\n\nThis quick start guide will teach you how to build TypeScript with gulp and then add Browserify, terser, or Watchify to the gulp pipeline. This guide also shows how to add Babel functionality using Babelify.\n\nWe assume that you’re already using Node.js with npm.\n\nMinimal project\n\nLet’s start out with a new directory. We’ll name it proj for now, but you can change it to whatever you want.\n\nmkdir proj\ncd proj\n\nTo start, we’re going to structure our project in the following way:\n\nproj/\n   ├─ src/\n   └─ dist/\n\nTypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.\n\nLet’s scaffold this out:\n\nmkdir src\nmkdir dist\nInitialize the project\n\nNow we’ll turn this folder into an npm package.\n\nnpm init\n\nYou’ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use ./dist/main.js. You can always go back and change these in the package.json file that’s been generated for you.\n\nInstall our dependencies\n\nNow we can use npm install to install packages. First install gulp-cli globally (if you use a Unix system, you may need to prefix the npm install commands in this guide with sudo).\n\nnpm install -g gulp-cli\n\nThen install typescript, gulp and gulp-typescript in your project’s dev dependencies. Gulp-typescript is a gulp plugin for TypeScript.\n\nnpm install --save-dev typescript gulp@4.0.0 gulp-typescript\nWrite a simple example\n\nLet’s write a Hello World program. In src, create the file main.ts:\n\nfunction hello(compiler: string) {\n  console.log(`Hello from ${compiler}`);\n}\nhello(\"TypeScript\");\n\nIn the project root, proj, create the file tsconfig.json:\n\n{\n  \"files\": [\"src/main.ts\"],\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"target\": \"es5\"\n  }\n}\nCreate a \ngulpfile.js\n\nIn the project root, create the file gulpfile.js:\n\nvar gulp = require(\"gulp\");\nvar ts = require(\"gulp-typescript\");\nvar tsProject = ts.createProject(\"tsconfig.json\");\ngulp.task(\"default\", function () {\n  return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest(\"dist\"));\n});\nTest the resulting app\ngulp\nnode dist/main.js\n\nThe program should print “Hello from TypeScript!“.\n\nAdd modules to the code\n\nBefore we get to Browserify, let’s build our code out and add modules to the mix. This is the structure you’re more likely to use for a real app.\n\nCreate a file called src/greet.ts:\n\nexport function sayHello(name: string) {\n  return `Hello from ${name}`;\n}\n\nNow change the code in src/main.ts to import sayHello from greet.ts:\n\nimport { sayHello } from \"./greet\";\nconsole.log(sayHello(\"TypeScript\"));\n\nFinally, add src/greet.ts to tsconfig.json:\n\n{\n  \"files\": [\"src/main.ts\", \"src/greet.ts\"],\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"target\": \"es5\"\n  }\n}\n\nMake sure that the modules work by running gulp and then testing in Node:\n\ngulp\nnode dist/main.js\n\nNotice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We’ll stick with CommonJS for this tutorial, but you could set module in the options object to change this.\n\nBrowserify\n\nNow let’s move this project from Node to the browser. To do this, we’d like to bundle all our modules into one JavaScript file. Fortunately, that’s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.\n\nFirst, install browserify, tsify, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called vinyl.\n\nnpm install --save-dev browserify tsify vinyl-source-stream\nCreate a page\n\nCreate a file in src named index.html:\n\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Hello World!</title>\n  </head>\n  <body>\n    <p id=\"greeting\">Loading ...</p>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n\nNow change main.ts to update the page:\n\nimport { sayHello } from \"./greet\";\nfunction showHello(divName: string, name: string) {\n  const elt = document.getElementById(divName);\n  elt.innerText = sayHello(name);\n}\nshowHello(\"greeting\", \"TypeScript\");\n\nCalling showHello calls sayHello to change the paragraph’s text. Now change your gulpfile to the following:\n\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar tsify = require(\"tsify\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n\nThis adds the copy-html task and adds it as a dependency of default. That means any time default is run, copy-html has to run first. We’ve also changed default to call Browserify with the tsify plugin instead of gulp-typescript. Conveniently, they both allow us to pass the same options object to the TypeScript compiler.\n\nAfter calling bundle we use source (our alias for vinyl-source-stream) to name our output bundle bundle.js.\n\nTest the page by running gulp and then opening dist/index.html in a browser. You should see “Hello from TypeScript” on the page.\n\nNotice that we specified debug: true to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside main.ts. When you refresh the page the breakpoint should pause the page and let you debug greet.ts.\n\nWatchify, Babel, and Terser\n\nNow that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.\n\nWatchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.\n\nBabel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn’t support.\n\nTerser compacts your code so that it takes less time to download.\n\nWatchify\n\nWe’ll start with Watchify to provide background compilation:\n\nnpm install --save-dev watchify fancy-log\n\nNow change your gulpfile to the following:\n\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar watchify = require(\"watchify\");\nvar tsify = require(\"tsify\");\nvar fancy_log = require(\"fancy-log\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\nvar watchedBrowserify = watchify(\n  browserify({\n    basedir: \".\",\n    debug: true,\n    entries: [\"src/main.ts\"],\n    cache: {},\n    packageCache: {},\n  }).plugin(tsify)\n);\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\nfunction bundle() {\n  return watchedBrowserify\n    .bundle()\n    .on(\"error\", fancy_log)\n    .pipe(source(\"bundle.js\"))\n    .pipe(gulp.dest(\"dist\"));\n}\ngulp.task(\"default\", gulp.series(gulp.parallel(\"copy-html\"), bundle));\nwatchedBrowserify.on(\"update\", bundle);\nwatchedBrowserify.on(\"log\", fancy_log);\n\nThere are basically three changes here, but they require you to refactor your code a bit.\n\nWe wrapped our browserify instance in a call to watchify, and then held on to the result.\nWe called watchedBrowserify.on('update', bundle); so that Browserify will run the bundle function every time one of your TypeScript files changes.\nWe called watchedBrowserify.on('log', fancy_log); to log to the console.\n\nTogether (1) and (2) mean that we have to move our call to browserify out of the default task. And we have to give the function for default a name since both Watchify and Gulp need to call it. Adding logging with (3) is optional but very useful for debugging your setup.\n\nNow when you run Gulp, it should start and stay running. Try changing the code for showHello in main.ts and saving it. You should see output that looks like this:\n\nproj$ gulp\n[10:34:20] Using gulpfile ~/src/proj/gulpfile.js\n[10:34:20] Starting 'copy-html'...\n[10:34:20] Finished 'copy-html' after 26 ms\n[10:34:20] Starting 'default'...\n[10:34:21] 2824 bytes written (0.13 seconds)\n[10:34:21] Finished 'default' after 1.36 s\n[10:35:22] 2261 bytes written (0.02 seconds)\n[10:35:24] 2808 bytes written (0.05 seconds)\nTerser\n\nFirst install Terser. Since the point of Terser is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.\n\nnpm install --save-dev gulp-terser vinyl-buffer gulp-sourcemaps\n\nNow change your gulpfile to the following:\n\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar terser = require(\"gulp-terser\");\nvar tsify = require(\"tsify\");\nvar sourcemaps = require(\"gulp-sourcemaps\");\nvar buffer = require(\"vinyl-buffer\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(buffer())\n      .pipe(sourcemaps.init({ loadMaps: true }))\n      .pipe(terser())\n      .pipe(sourcemaps.write(\"./\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n\nNotice that terser itself has just one call — the calls to buffer and sourcemaps exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that bundle.js does get minified into an unreadable mess:\n\ngulp\ncat dist/bundle.js\nBabel\n\nFirst install Babelify and the Babel preset for ES2015. Like Terser, Babelify mangles code, so we’ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of .js, .es, .es6 and .jsx so we need to add the .ts extension as an option to Babelify.\n\nnpm install --save-dev babelify@8 babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps\n\nNow change your gulpfile to the following:\n\nvar gulp = require(\"gulp\");\nvar browserify = require(\"browserify\");\nvar source = require(\"vinyl-source-stream\");\nvar tsify = require(\"tsify\");\nvar sourcemaps = require(\"gulp-sourcemaps\");\nvar buffer = require(\"vinyl-buffer\");\nvar paths = {\n  pages: [\"src/*.html\"],\n};\ngulp.task(\"copy-html\", function () {\n  return gulp.src(paths.pages).pipe(gulp.dest(\"dist\"));\n});\ngulp.task(\n  \"default\",\n  gulp.series(gulp.parallel(\"copy-html\"), function () {\n    return browserify({\n      basedir: \".\",\n      debug: true,\n      entries: [\"src/main.ts\"],\n      cache: {},\n      packageCache: {},\n    })\n      .plugin(tsify)\n      .transform(\"babelify\", {\n        presets: [\"es2015\"],\n        extensions: [\".ts\"],\n      })\n      .bundle()\n      .pipe(source(\"bundle.js\"))\n      .pipe(buffer())\n      .pipe(sourcemaps.init({ loadMaps: true }))\n      .pipe(sourcemaps.write(\"./\"))\n      .pipe(gulp.dest(\"dist\"));\n  })\n);\n\nWe also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let’s modify tsconfig.json:\n\n{\n  \"files\": [\"src/main.ts\"],\n  \"compilerOptions\": {\n    \"noImplicitAny\": true,\n    \"target\": \"es2015\"\n  }\n}\n\nBabel’s ES5 output should be very similar to TypeScript’s output for such a simple script.\n\nOn this page\nMinimal project\nInitialize the project\nInstall our dependencies\nWrite a simple example\nCreate a gulpfile.js\nTest the resulting app\nAdd modules to the code\nBrowserify\nCreate a page\nWatchify, Babel, and Terser\nWatchify\nTerser\nBabel\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nBK\nOT\nDR\nRC\nMF\n19+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 4.187 seconds."
  },
  {
    "title": "TypeScript: Documentation - ASP.NET Core",
    "url": "https://www.typescriptlang.org/docs/handbook/asp-net-core.html",
    "html": "ASP.NET Core\nInstall ASP.NET Core and TypeScript\n\nFirst, install ASP.NET Core if you need it. This quick-start guide requires Visual Studio 2015 or 2017.\n\nNext, if your version of Visual Studio does not already have the latest TypeScript, you can install it.\n\nCreate a new project\nChoose File\nChoose New Project (Ctrl + Shift + N)\nSearch for .NET Core in the project search bar\nSelect ASP.NET Core Web Application and press the Next button\n\nName your project and solution. After select the Create button\n\nIn the last window, select the Empty template and press the Create button\n\nRun the application and make sure that it works.\n\nSet up the server\n\nOpen Dependencies > Manage NuGet Packages > Browse. Search and install Microsoft.AspNetCore.StaticFiles and Microsoft.TypeScript.MSBuild:\n\nOpen up your Startup.cs file and edit your Configure function to look like this:\n\npublic void Configure(IApplicationBuilder app, IHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseDefaultFiles();\n    app.UseStaticFiles();\n}\n\nYou may need to restart VS for the red squiggly lines below UseDefaultFiles and UseStaticFiles to disappear.\n\nAdd TypeScript\n\nNext we will add a new folder and call it scripts.\n\nAdd TypeScript code\n\nRight click on scripts and click New Item. Then choose TypeScript File and name the file app.ts\n\nAdd example code\n\nAdd the following code to the app.ts file.\n\nfunction sayHello() {\n  const compiler = (document.getElementById(\"compiler\") as HTMLInputElement)\n    .value;\n  const framework = (document.getElementById(\"framework\") as HTMLInputElement)\n    .value;\n  return `Hello from ${compiler} and ${framework}!`;\n}\nSet up the build\n\nConfigure the TypeScript compiler\n\nFirst we need to tell TypeScript how to build. Right click on scripts and click New Item. Then choose TypeScript Configuration File and use the default name of tsconfig.json\n\nReplace the contents of the tsconfig.json file with:\n\n{\n  \"compilerOptions\": {\n    \"noEmitOnError\": true,\n    \"noImplicitAny\": true,\n    \"sourceMap\": true,\n    \"target\": \"es6\"\n  },\n  \"files\": [\"./app.ts\"],\n  \"compileOnSave\": true\n}\nnoEmitOnError : Do not emit outputs if any errors were reported.\nnoImplicitAny : Raise error on expressions and declarations with an implied any type.\nsourceMap : Generates corresponding .map file.\ntarget : Specify ECMAScript target version.\n\nNote: \"ESNext\" targets latest supported\n\nnoImplicitAny is good idea whenever you’re writing new code — you can make sure that you don’t write any untyped code by mistake. \"compileOnSave\" makes it easy to update your code in a running web app.\n\nSet up NPM\n\nWe need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select New Item. Then choose NPM Configuration File and use the default name of package.json.\n\nInside the \"devDependencies\" section of the package.json file, add gulp and del\n\n\"devDependencies\": {\n    \"gulp\": \"4.0.2\",\n    \"del\": \"5.1.0\"\n}\n\nVisual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.\n\nAfter you should see an npm folder in your solution explorer\n\nSet up gulp\n\nRight click on the project and click New Item. Then choose JavaScript File and use the name of gulpfile.js\n\n/// <binding AfterBuild='default' Clean='clean' />\n/*\nThis file is the main entry point for defining Gulp tasks and using Gulp plugins.\nClick here to learn more. http://go.microsoft.com/fwlink/?LinkId=518007\n*/\nvar gulp = require(\"gulp\");\nvar del = require(\"del\");\nvar paths = {\n  scripts: [\"scripts/**/*.js\", \"scripts/**/*.ts\", \"scripts/**/*.map\"],\n};\ngulp.task(\"clean\", function () {\n  return del([\"wwwroot/scripts/**/*\"]);\n});\ngulp.task(\"default\", function (done) {\n    gulp.src(paths.scripts).pipe(gulp.dest(\"wwwroot/scripts\"));\n    done();\n});\n\nThe first line tells Visual Studio to run the task ‘default’ after the build finishes. It will also run the ‘clean’ task when you ask Visual Studio to clean the build.\n\nNow right-click on gulpfile.js and click Task Runner Explorer.\n\nIf ‘default’ and ‘clean’ tasks don’t show up, refresh the explorer:\n\nWrite a HTML page\n\nRight click on the wwwroot folder (if you don’t see the folder try building the project) and add a New Item named index.html inside. Use the following code for index.html\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <script src=\"scripts/app.js\"></script>\n    <title></title>\n</head>\n<body>\n    <div id=\"message\"></div>\n    <div>\n        Compiler: <input id=\"compiler\" value=\"TypeScript\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" /><br />\n        Framework: <input id=\"framework\" value=\"ASP.NET\" onkeyup=\"document.getElementById('message').innerText = sayHello()\" />\n    </div>\n</body>\n</html>\nTest\nRun the project\nAs you type on the boxes you should see the message appear/change!\n\nDebug\nIn Edge, press F12 and click the Debugger tab.\nLook in the first localhost folder, then scripts/app.ts\nPut a breakpoint on the line with return.\nType in the boxes and confirm that the breakpoint hits in TypeScript code and that inspection works correctly.\n\nCongrats you’ve built your own .NET Core project with a TypeScript frontend.\n\nOn this page\nInstall ASP.NET Core and TypeScript\nCreate a new project\nSet up the server\nAdd TypeScript\nAdd TypeScript code\nAdd example code\nSet up the build\nWrite a HTML page\nTest\nDebug\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nBK\nOT\nGC\nDR\nLZ\n14+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.84 seconds."
  },
  {
    "title": "TypeScript: Documentation - Modules - ESM/CJS Interoperability",
    "url": "https://www.typescriptlang.org/docs/handbook/modules/appendices/esm-cjs-interop.html",
    "html": "Modules - ESM/CJS Interoperability\n\nIt’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are supposed to interact with each other, knowledge of how CommonJS modules interact with each other, and a knack for figuring things out. Consider an exporting ES module:\n\nexport const A = {};\nexport const B = {};\nexport default \"Hello, world!\";\n\nHow would you turn this into a CommonJS module? Recalling that default exports are just named exports with special syntax, there seems to be only one choice:\n\nexports.A = {};\nexports.B = {};\nexports.default = \"Hello, world!\";\n\nThis is a nice analog, and it lets you implement a similar on the importing side:\n\nimport hello, { A, B } from \"./module\";\nconsole.log(hello, A, B);\n// transpiles to:\nconst module_1 = require(\"./module\");\nconsole.log(module_1.default, module_1.A, module_1.B);\n\nSo far, everything in CJS-world matches up one-to-one with everything in ESM-world. Extending the equivalence above one step further, we can see that we also have:\n\nimport * as mod from \"./module\";\nconsole.log(mod.default, mod.A, mod.B);\n// transpiles to:\nconst mod = require(\"./module\");\nconsole.log(mod.default, mod.A, mod.B);\n\nYou might notice that in this scheme, there’s no way to write an ESM export that produces an output where exports is assigned a function, class, or primitive:\n\n// @Filename: exports-function.js\nmodule.exports = function hello() {\n  console.log(\"Hello, world!\");\n};\n\nBut existing CommonJS modules frequently take this form. How might an ESM import, processed with our transpiler, access this module? We just established that a namespace import (import *) transpiles to a plain require call, so we can support an input like:\n\nimport * as hello from \"./exports-function\";\nhello();\n// transpiles to:\nconst hello = require(\"./exports-function\");\nhello();\n\nOur output works at runtime, but we have a compliance problem: according to the JavaScript specification, a namespace import always resolves to a Module Namespace Object, that is, an object whose members are the exports of the module. In this case, require would return the function hello, but import * can never return a function. The correspondence we assumed appears invalid.\n\nIt’s worth taking a step back here and clarifying what the goal is. As soon as modules landed in the ES2015 specification, transpilers emerged with support for downleveling ESM to CJS, allowing users to adopt the new syntax long before runtimes implemented support for it. There was even a sense that writing ESM code was a good way to “future-proof” new projects. For this to be true, there needed to be a seamless migration path from executing the transpilers’ CJS output to executing the ESM input natively once runtimes developed support for it. The goal was to find a way to downlevel ESM to CJS that would allow any or all of those transpiled outputs to be replaced by their true ESM inputs in a future runtime, with no observable change in behavior.\n\nBy following the specification, it was easy enough for transpilers to find a set of transformations that made the semantics of their transpiled CommonJS outputs match the specified semantics of their ESM inputs (arrows represent imports):\n\nHowever, CommonJS modules (written as CommonJS, not as ESM transpiled to CommonJS) were already well-established in the Node.js ecosystem, so it was inevitable that modules written as ESM and transpiled to CJS would start “importing” modules written as CommonJS. The behavior for this interoperability, though, was not specified by ES2015, and didn’t yet exist in any real runtime.\n\nEven if transpiler authors did nothing, a behavior would emerge from the existing semantics between the require calls they emitted in transpiled code and the exports defined in existing CJS modules. And to allow users to transition seamlessly from transpiled ESM to true ESM once their runtime supported it, that behavior would have to match the one the runtime chose to implement.\n\nGuessing what interop behavior runtimes would support wasn’t limited to ESM importing “true CJS” modules either. Whether ESM would be able to recognize ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able to require ES modules, were also unspecified. Even whether ESM imports would use the same module resolution algorithm as CJS require calls was unknowable. All these variables would have to be predicted correctly in order to give transpiler users a seamless migration path toward native ESM.\n\nallowSyntheticDefaultImports\n and \nesModuleInterop\n\nLet’s return to our specification compliance problem, where import * transpiles to require:\n\n// Invalid according to the spec:\nimport * as hello from \"./exports-function\";\nhello();\n// but the transpilation works:\nconst hello = require(\"./exports-function\");\nhello();\n\nWhen TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whose exports was not a namespace-like object:\n\nimport * as hello from \"./exports-function\";\n// TS2497              ^^^^^^^^^^^^^^^^^^^^\n// External module '\"./exports-function\"' resolves to a non-module entity\n// and cannot be imported using this construct.\n\nThe only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJS require:\n\nimport hello = require(\"./exports-function\");\n\nForcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like \"./exports-function\" will be accessible with ESM imports in the future, but we know it can’t be with import *, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing the import * to link to a function. This is still the behavior in TypeScript today when allowSyntheticDefaultImports and esModuleInterop are disabled.\n\nUnfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:\n\ndeclare function $(selector: string): any;\nexport = $; // Cannot `import *` this 👍\n\nA should-be-meaningless change allowed the invalid import to type check without errors:\n\ndeclare namespace $ {}\ndeclare function $(selector: string): any;\nexport = $; // Allowed to `import *` this and call it 😱\n\nMeanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:\n\nTo import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.\nMost likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules always link directly to the whole exports, rather than only doing so if the exports is a function or primitive.\nSo, a default import of a true CJS module should work just like a require call. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile export default \"hello\" to exports.default = \"hello\" and have a default import of that module link to exports.default. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).\nWhen we transpile an ES module to CJS, let’s add a special extra field to the output:\nexports.A = {};\nexports.B = {};\nexports.default = \"Hello, world!\";\n// Extra special flag!\nexports.__esModule = true;\nthat we can check for when we transpile a default import:\n// import hello from \"./modue\";\nconst _mod = require(\"./module\");\nconst hello = _mod.__esModule ? _mod.default : _mod;\n\nThe __esModule flag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added the allowSyntheticDefaultImports in 1.8 to allow the type checker to link default imports directly to the exports, rather than the exports.default, of any module types that lacked an export default declaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” where import * was an error:\n\n// Error:\nimport * as hello from \"./exports-function\";\n// Old workaround:\nimport hello = require(\"./exports-function\");\n// New way, with `allowSyntheticDefaultImports`:\nimport hello from \"./exports-function\";\n\nThis was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:\n\nBabel and others varied their default import behavior on whether an __esModule property was found on the target module, but allowSyntheticDefaultImports only enabled a fallback behavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an __esModule flag but no default export. Transpilers and bundlers would still link a default import of such a module to its exports.default, which would be undefined, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But with allowSyntheticDefaultImports, TypeScript would think a default import of such an import links to the whole exports object, allowing named exports to be accessed as its properties.\nallowSyntheticDefaultImports didn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:\n// @Filename: exportEqualsObject.d.ts\ndeclare const obj: object;\nexport = obj;\n// @Filename: main.ts\nimport objDefault from \"./exportEqualsObject\";\nimport * as objNamespace from \"./exportEqualsObject\";\n// This should be true at runtime, but TypeScript gives an error:\nobjNamespace.default === objDefault;\n//           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'.\nMost importantly, allowSyntheticDefaultImports did not change the JavaScript emitted by tsc. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting --module commonjs with tsc and running in Node.js. If they encountered an error with import *, it may have appeared as if enabling allowSyntheticDefaultImports would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.\n\nTypeScript introduced the esModuleInterop flag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same __esModule-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper for import * ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node.\n\nInterop in Node.js\n\nNode.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of their exports object, allowing the entire module contents to be accessed with a default import from ESM:\n\n// @Filename: export.cjs\nmodule.exports = { hello: \"world\" };\n// @Filename: import.mjs\nimport greeting from \"./export.cjs\";\ngreeting.hello; // \"world\"\n\nThat’s one win for seamless migration! Unfortunately, the similarities mostly end there.\n\nNo \n__esModule\n detection (the “double default” problem)\n\nNode.js wasn’t able to respect the __esModule marker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:\n\n// @Filename: node_modules/dependency/index.js\nexports.__esModule = true;\nexports.default = function doSomething() { /*...*/ }\n// @Filename: transpile-vs-run-directly.{js/mjs}\nimport doSomething from \"dependency\";\n// Works after transpilation, but not a function in Node.js ESM:\ndoSomething();\n// Doesn't exist after trasnpilation, but works in Node.js ESM:\ndoSomething.default();\n\nWhile the transpiled default import only makes the synthetic default export if the target module lacks an __esModule flag, Node.js always synthesizes a default export, creating a “double default” on the transpiled module.\n\nUnreliable named exports\n\nIn addition to making a CommonJS module’s exports object available as a default import, Node.js attempts to find properties of exports to make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js uses syntactic analysis to synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:\n\n// @Filename: named-exports.cjs\nexports.hello = \"world\";\nexports[\"worl\" + \"d\"] = \"hello\";\n// @Filename: transpile-vs-run-directly.{js/mjs}\nimport { hello, world } from \"./named-exports.cjs\";\n// `hello` works, but `world` is missing in Node.js 💥\nimport mod from \"./named-exports.cjs\";\nmod.world;\n// Accessing properties from the default always works ✅\nCannot \nrequire\n a true ES module\n\nTrue CommonJS modules can require an ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js, require crashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:\n\n// @Filename: node_modules/dependency/index.js\nexport function doSomething() { /* ... */ }\n// @Filename: dependent.js\nimport { doSomething } from \"dependency\";\n// ✅ Works if dependent and dependency are both transpiled\n// ✅ Works if dependent and dependency are both true ESM\n// ✅ Works if dependent is true ESM and dependency is transpiled\n// 💥 Crashes if dependent is transpiled and dependency is true ESM\nDifferent module resolution algorithms\n\nNode.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolving require calls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:\n\n// @Filename: add.js\nexport function add(a, b) {\n  return a + b;\n}\n// @Filename: math.js\nexport * from \"./add\";\n//            ^^^^^^^\n// Works when transpiled to CJS,\n// but would have to be \"./add.js\"\n// in Node.js ESM.\nConclusions\n\nClearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?\n\nSetting the right \nmodule\n compiler option is critical\n\nSince interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of the module compiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unless module is set to node16 or nodenext.)\n\nApplications with CommonJS code should always enable \nesModuleInterop\n\nIn a TypeScript application (as opposed to a library that others may consume) where tsc is used to emit JavaScript files, whether esModuleInterop is enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leaving esModuleInterop disabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMASCript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future.\n\nIn an application that gets processed by a third-party transpiler or bundler, on the other hand, enabling esModuleInterop is more important. All major bundlers and transpilers use an esModuleInterop-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files that tsc would emit, so even if another tool is being used in place of tsc, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.)\n\nallowSyntheticDefaultImports without esModuleInterop should be avoided. It changes the compiler’s checking behavior without changing the code emitted by tsc, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced by esModuleInterop. Even if tsc isn’t being used for emit, it’s better to enable esModuleInterop than allowSyntheticDefaultImports.\n\nSome people object to the inclusion of the __importDefault and __importStar helper functions included in tsc’s JavaScript output when esModuleInterop is enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for __esModule, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited with esModuleInterop disabled. First, the importHelpers compiler option can be used to import the helper functions from tslib rather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:\n\n// @Filename: node_modules/transpiled-dependency/index.js\nexports.__esModule = true;\nexports.default = function doSomething() { /* ... */ };\nexports.something = \"something\";\n// @Filename: node_modules/true-cjs-dependency/index.js\nmodule.exports = function doSomethingElse() { /* ... */ };\n// @Filename: src/sayHello.ts\nexport default function sayHello() { /* ... */ }\nexport const hello = \"hello\";\n// @Filename: src/main.ts\nimport doSomething from \"transpiled-dependency\";\nimport doSomethingElse from \"true-cjs-dependency\";\nimport sayHello from \"./sayHello.js\";\n\nAssume we’re compiling src to CommonJS for use in Node.js. Without allowSyntheticDefaultImports or esModuleInterop, the import of doSomethingElse from \"true-cjs-dependency\" is an error, and the others are not. To fix the error without changing any compiler options, you could change the import to import doSomethingElse = require(\"true-cjs-dependency\"). However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. With esModuleInterop, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught.\n\nWhat would change if we decided to migrate src to true ESM in Node.js (say, add \"type\": \"module\" to our root package.json)? The first import, doSomething from \"transpiled-dependency\", would no longer be callable—it exhibits the “double default” problem, where we’d have to call doSomething.default() rather than doSomething(). (TypeScript understands and catches this under --module node16 and nodenext.) But notably, the second import of doSomethingElse, which needed esModuleInterop to work when compiling to CommonJS, works fine in true ESM.\n\nIf there’s something to complain about here, it’s not what esModuleInterop does with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is that esModuleInterop seems to fail at giving us a seamless migration path for the first import. But this problem was not introduced by enabling esModuleInterop; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract between main.ts and sayHello.ts, because the CommonJS output of sayHello.ts looks structurally identical to transpiled-dependency/index.js. If esModuleInterop changed the way the transpiled import of doSomething works to be identical to the way it would work in Node.js ESM, it would change the behavior of the sayHello import in the same way, making the input code violate ESM semantics (thus still preventing the src directory from being migrated to ESM without changes).\n\nAs we’ve seen, there is no seamless migration path from transpiled modules to true ESM. But esModuleInterop is one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enabling verbatimModuleSyntax is a better choice than disabling esModuleInterop. verbatimModuleSyntax enforces that the import mod = require(\"mod\") and export = ns syntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM.\n\nLibrary code needs special considerations\n\nLibraries (that ship declaration files) should take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully when strictNullChecks is disabled. If a library were to publish types like that, it would force all their users to disable strictNullChecks too. esModuleInterop can allow type declarations to contain similarly “infectious” default imports:\n\n// @Filename: /node_modules/dependency/index.d.ts\nimport express from \"express\";\ndeclare function doSomething(req: express.Request): any;\nexport = doSomething;\n\nSuppose this default import only works with esModuleInterop enabled, and causes an error when a user without that option references this file. The user should probably enable esModuleInterop anyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:\n\nimport express = require(\"express\");\n// ...\n\nExamples like this have led to conventional wisdom that says libraries should not enable esModuleInterop. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentially introducing an error, when enabling esModuleInterop. So whether libraries compile with or without esModuleInterop, they run the risk of writing syntax that makes their choice infectious.\n\nLibrary authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But using verbatimModuleSyntax completely sidesteps the issue with esModuleInterop by forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, since esModuleInterop only affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline.\n\nOn this page\nallowSyntheticDefaultImports and esModuleInterop\nInterop in Node.js\nNo __esModule detection (the “double default” problem)\nUnreliable named exports\nCannot require a true ES module\nDifferent module resolution algorithms\nConclusions\nSetting the right module compiler option is critical\nApplications with CommonJS code should always enable esModuleInterop\nLibrary code needs special considerations\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.691 seconds."
  },
  {
    "title": "TypeScript: Documentation - Modules - Reference",
    "url": "https://www.typescriptlang.org/docs/handbook/modules/reference.html",
    "html": "Modules - Reference\nModule syntax\n\nThe TypeScript compiler recognizes standard ECMAScript module syntax in TypeScript and JavaScript files and many forms of CommonJS syntax in JavaScript files.\n\nThere are also a few TypeScript-specific syntax extensions that can be used in TypeScript files and/or JSDoc comments.\n\nImporting and exporting TypeScript-specific declarations\n\nType aliases, interfaces, enums, and namespaces can be exported from a module with an export modifier, like any standard JavaScript declaration:\n\n// Standard JavaScript syntax...\nexport function f() {}\n// ...extended to type declarations\nexport type SomeType = /* ... */;\nexport interface SomeInterface { /* ... */ }\n\nThey can also be referenced in named exports, even alongside references to standard JavaScript declarations:\n\nexport { f, SomeType, SomeInterface };\n\nExported types (and other TypeScript-specific declarations) can be imported with standard ECMAScript imports:\n\nimport { f, SomeType, SomeInterface } from \"./module.js\";\n\nWhen using namespace imports or exports, exported types are available on the namespace when referenced in a type position:\n\nimport * as mod from \"./module.js\";\nmod.f();\nmod.SomeType; // Property 'SomeType' does not exist on type 'typeof import(\"./module.js\")'\nlet x: mod.SomeType; // Ok\nType-only imports and exports\n\nWhen emitting imports and exports to JavaScript, by default, TypeScript automatically elides (does not emit) imports that are only used in type positions and exports that only refer to types. Type-only imports and exports can be used to force this behavior and make the elision explicit. Import declarations written with import type, export declarations written with export type { ... }, and import or export specifiers prefixed with the type keyword are all guaranteed to be elided from the output JavaScript.\n\n// @Filename: main.ts\nimport { f, type SomeInterface } from \"./module.js\";\nimport type { SomeType } from \"./module.js\";\nclass C implements SomeInterface {\n  constructor(p: SomeType) {\n    f();\n  }\n}\nexport type { C };\n// @Filename: main.js\nimport { f } from \"./module.js\";\nclass C {\n  constructor(p) {\n    f();\n  }\n}\n\nEven values can be imported with import type, but since they won’t exist in the output JavaScript, they can only be used in non-emitting positions:\n\nimport type { f } from \"./module.js\";\nf(); // 'f' cannot be used as a value because it was imported using 'import type'\nlet otherFunction: typeof f = () => {}; // Ok\n\nA type-only import declaration may not declare both a default import and named bindings, since it appears ambiguous whether type applies to the default import or to the entire import declaration. Instead, split the import declaration into two, or use default as a named binding:\n\nimport type fs, { BigIntOptions } from \"fs\";\n//          ^^^^^^^^^^^^^^^^^^^^^\n// Error: A type-only import can specify a default import or named bindings, but not both.\nimport type { default as fs, BigIntOptions } from \"fs\"; // Ok\nimport()\n types\n\nTypeScript provides a type syntax similar to JavaScript’s dynamic import for referencing the type of a module without writing an import declaration:\n\n// Access an exported type:\ntype WriteFileOptions = import(\"fs\").WriteFileOptions;\n// Access the type of an exported value:\ntype WriteFileFunction = typeof import(\"fs\").writeFile;\n\nThis is especially useful in JSDoc comments in JavaScript files, where it’s not possible to import types otherwise:\n\n/** @type {import(\"webpack\").Configuration} */\nmodule.exports = {\n  // ...\n}\nexport =\n and \nimport = require()\n\nWhen emitting CommonJS modules, TypeScript files can use a direct analog of module.exports = ... and const mod = require(\"...\") JavaScript syntax:\n\n// @Filename: main.ts\nimport fs = require(\"fs\");\nexport = fs.readFileSync(\"...\");\n// @Filename: main.js\n\"use strict\";\nconst fs = require(\"fs\");\nmodule.exports = fs.readFileSync(\"...\");\n\nThis syntax was used over its JavaScript counterparts since variable declarations and property assignments could not refer to TypeScript types, whereas special TypeScript syntax could:\n\n// @Filename: a.ts\ninterface Options { /* ... */ }\nmodule.exports = Options; // Error: 'Options' only refers to a type, but is being used as a value here.\nexport = Options; // Ok\n// @Filename: b.ts\nconst Options = require(\"./a\");\nconst options: Options = { /* ... */ }; // Error: 'Options' refers to a value, but is being used as a type here.\n// @Filename: c.ts\nimport Options = require(\"./a\");\nconst options: Options = { /* ... */ }; // Ok\nAmbient modules\n\nTypeScript supports a syntax in script (non-module) files for declaring a module that exists in the runtime but has no corresponding file. These ambient modules usually represent runtime-provided modules, like \"fs\" or \"path\" in Node.js:\n\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export var sep: string;\n}\n\nOnce an ambient module is loaded into a TypeScript program, TypeScript will recognize imports of the declared module in other files:\n\n// 👇 Ensure the ambient module is loaded -\n//    may be unnecessary if path.d.ts is included\n//    by the project tsconfig.json somehow.\n/// <reference path=\"path.d.ts\" />\nimport { normalize, join } from \"path\";\n\nAmbient module declarations are easy to confuse with module augmentations since they use identical syntax. This module declaration syntax becomes a module augmentation when the file is a module, meaning it has a top-level import or export statement (or is affected by --moduleDetection force or auto):\n\n// Not an ambient module declaration anymore!\nexport {};\ndeclare module \"path\" {\n  export function normalize(p: string): string;\n  export function join(...paths: any[]): string;\n  export var sep: string;\n}\n\nAmbient modules may use imports inside the module declaration body to refer to other modules without turning the containing file into a module (which would make the ambient module declaration a module augmentation):\n\ndeclare module \"m\" {\n  // Moving this outside \"m\" would totally change the meaning of the file!\n  import { SomeType } from \"other\";\n  export function f(): SomeType;\n}\n\nA pattern ambient module contains a single * wildcard character in its name, matching zero or more characters in import paths. This can be useful for declaring modules provided by custom loaders:\n\ndeclare module \"*.html\" {\n  const content: string;\n  export default content;\n}\nThe \nmodule\n compiler option\n\nThis section discusses the details of each module compiler option value. See the Module output format theory section for more background on what the option is and how it fits into the overall compilation process. In brief, the module compiler option was historically only used to control the output module format of emitted JavaScript files. The more recent node16 and nodenext values, however, describe a wide range of characteristics of Node.js’s module system, including what module formats are supported, how the module format of each file is determined, and how different module formats interoperate.\n\nnode16\n, \nnodenext\n\nNode.js supports both CommonJS and ECMAScript modules, with specific rules for which format each file can be and how the two formats are allowed to interoperate. node16 and nodenext describe the full range of behavior for Node.js’s dual-format module system, and emit files in either CommonJS or ESM format. This is different from every other module option, which are runtime-agnostic and force all output files into a single format, leaving it to the user to ensure the output is valid for their runtime.\n\nA common misconception is that node16 and nodenext only emit ES modules. In reality, node16 and nodenext describe versions of Node.js that support ES modules, not just projects that use ES modules. Both ESM and CommonJS emit are supported, based on the detected module format of each file. Because node16 and nodenext are the only module options that reflect the complexities of Node.js’s dual module system, they are the only correct module options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\n\nnode16 and nodenext are currently identical, with the exception that they imply different target option values. If Node.js makes significant changes to its module system in the future, node16 will be frozen while nodenext will be updated to reflect the new behavior.\n\nModule format detection\n.mts/.mjs/.d.mts files are always ES modules.\n.cts/.cjs/.d.cts files are always CommonJS modules.\n.ts/.tsx/.js/.jsx/.d.ts files are ES modules if the nearest ancestor package.json file contains \"type\": \"module\", otherwise CommonJS modules.\n\nThe detected module format of input .ts/.tsx/.mts/.cts files determines the module format of the emitted JavaScript files. So, for example, a project consisting entirely of .ts files will emit all CommonJS modules by default under --module nodenext, and can be made to emit all ES modules by adding \"type\": \"module\" to the project package.json.\n\nInteroperability rules\nWhen an ES module references a CommonJS module:\nThe module.exports of the CommonJS module is available as a default import to the ES module.\nProperties (other than default) of the CommonJS module’s module.exports may or may not be available as named imports to the ES module. Node.js attempts to make them available via static analysis. TypeScript cannot know from a declaration file whether that static analysis will succeed, and optimistically assumes it will. This limits TypeScript’s ability to catch named imports that may crash at runtime. See #54018 for more details.\nWhen a CommonJS module references an ES module:\nrequire cannot reference an ES module. For TypeScript, this includes import statements in files that are detected to be CommonJS modules, since those import statements will be transformed to require calls in the emitted JavaScript.\nA dynamic import() call may be used to import an ES module. It returns a Promise of the module’s Module Namespace Object (what you’d get from import * as ns from \"./module.js\" from another ES module).\nEmit\n\nThe emit format of each file is determined by the detected module format of each file. ESM emit is similar to --module esnext, but has a special transformation for import x = require(\"...\"), which is not allowed in --module esnext:\n\nimport x = require(\"mod\");\nimport { createRequire as _createRequire } from \"module\";\nconst __require = _createRequire(import.meta.url);\nconst x = __require(\"mod\");\n\nCommonJS emit is similar to --module commonjs, but dynamic import() calls are not transformed. Emit here is shown with esModuleInterop enabled:\n\nimport fs from \"fs\"; // transformed\nconst dynamic = import(\"mod\"); // not transformed\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs_1 = __importDefault(require(\"fs\")); // transformed\nconst dynamic = import(\"mod\"); // not transformed\nImplied and enforced options\n--module nodenext or node16 implies and enforces the moduleResolution with the same name.\n--module nodenext implies --target esnext.\n--module node16 implies --target es2022.\n--module nodenext or node16 implies --esModuleInterop.\nSummary\nnode16 and nodenext are the only correct module options for all apps and libraries that are intended to run in Node.js v12 or later, whether they use ES modules or not.\nnode16 and nodenext emit files in either CommonJS or ESM format, based on the detected module format of each file.\nNode.js’s interoperability rules between ESM and CJS are reflected in type checking.\nESM emit transforms import x = require(\"...\") to a require call constructed from a createRequire import.\nCommonJS emit leaves dynamic import() calls untransformed, so CommonJS modules can asynchronously import ES modules.\nes2015\n, \nes2020\n, \nes2022\n, \nesnext\nSummary\nUse esnext with --moduleResolution bundler for bundlers, Bun, and tsx.\nDo not use for Node.js. Use node16 or nodenext with \"type\": \"module\" in package.json to emit ES modules for Node.js.\nimport mod = require(\"mod\") is not allowed in non-declaration files.\nes2020 adds support for import.meta properties.\nes2022 adds support for top-level await.\nesnext is a moving target that may include support for Stage 3 proposals to ECMAScript modules.\nEmitted files are ES modules, but dependencies may be any format.\nExamples\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\nexport const e1 = 0;\nexport default \"default export\";\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\nexport const e1 = 0;\nexport default \"default export\";\ncommonjs\nSummary\nYou probably shouldn’t use this. Use node16 or nodenext to emit CommonJS modules for Node.js.\nEmitted files are CommonJS modules, but dependencies may be any format.\nDynamic import() is transformed to a Promise of a require() call.\nesModuleInterop affects the output code for default and namespace imports.\nExamples\n\nOutput is shown with esModuleInterop: false.\n\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\nexport const e1 = 0;\nexport default \"default export\";\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.e1 = void 0;\nconst mod_1 = require(\"mod\");\nconst mod = require(\"mod\");\nconst dynamic = Promise.resolve().then(() => require(\"mod\"));\nconsole.log(mod_1.default, mod_1.y, mod_1.z, mod);\nexports.e1 = 0;\nexports.default = \"default export\";\nimport mod = require(\"mod\");\nconsole.log(mod);\nexport = {\n    p1: true,\n    p2: false\n};\n\"use strict\";\nconst mod = require(\"mod\");\nconsole.log(mod);\nmodule.exports = {\n    p1: true,\n    p2: false\n};\nsystem\nSummary\nDesigned for use with the SystemJS module loader.\nExamples\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\nexport const e1 = 0;\nexport default \"default export\";\nSystem.register([\"mod\"], function (exports_1, context_1) {\n    \"use strict\";\n    var mod_1, mod, dynamic, e1;\n    var __moduleName = context_1 && context_1.id;\n    return {\n        setters: [\n            function (mod_1_1) {\n                mod_1 = mod_1_1;\n                mod = mod_1_1;\n            }\n        ],\n        execute: function () {\n            dynamic = context_1.import(\"mod\");\n            console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);\n            exports_1(\"e1\", e1 = 0);\n            exports_1(\"default\", \"default export\");\n        }\n    };\n});\namd\nSummary\nDesigned for AMD loaders like RequireJS.\nYou probably shouldn’t use this. Use a bundler instead.\nEmitted files are AMD modules, but dependencies may be any format.\nSupports outFile.\nExamples\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\nexport const e1 = 0;\nexport default \"default export\";\ndefine([\"require\", \"exports\", \"mod\", \"mod\"], function (require, exports, mod_1, mod) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.e1 = void 0;\n    const dynamic = new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });\n    console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);\n    exports.e1 = 0;\n    exports.default = \"default export\";\n});\numd\nSummary\nDesigned for AMD or CommonJS loaders.\nDoes not expose a global variable like most other UMD wrappers.\nYou probably shouldn’t use this. Use a bundler instead.\nEmitted files are UMD modules, but dependencies may be any format.\nExamples\nimport x, { y, z } from \"mod\";\nimport * as mod from \"mod\";\nconst dynamic = import(\"mod\");\nconsole.log(x, y, z, mod, dynamic);\nexport const e1 = 0;\nexport default \"default export\";\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"mod\", \"mod\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var __syncRequire = typeof module === \"object\" && typeof module.exports === \"object\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.e1 = void 0;\n    const mod_1 = require(\"mod\");\n    const mod = require(\"mod\");\n    const dynamic = __syncRequire ? Promise.resolve().then(() => require(\"mod\")) : new Promise((resolve_1, reject_1) => { require([\"mod\"], resolve_1, reject_1); });\n    console.log(mod_1.default, mod_1.y, mod_1.z, mod, dynamic);\n    exports.e1 = 0;\n    exports.default = \"default export\";\n});\nThe \nmoduleResolution\n compiler option\n\nThis section describes module resolution features and processes shared by multiple moduleResolution modes, then specifies the details of each mode. See the Module resolution theory section for more background on what the option is and how it fits into the overall compilation process. In brief, moduleResolution controls how TypeScript resolves module specifiers (string literals in import/export/require statements) to files on disk, and should be set to match the module resolver used by the target runtime or bundler.\n\nCommon features and processes\nFile extension substitution\n\nTypeScript always wants to resolve internally to a file that can provide type information, while ensuring that the runtime or bundler can use the same path to resolve to a file that provides a JavaScript implementation. For any module specifier that would, according to the moduleResolution algorithm specified, trigger a lookup of a JavaScript file in the runtime or bundler, TypeScript will first try to find a TypeScript implementation file or type declaration file with the same name and analagous file extension.\n\nRuntime lookup\tTypeScript lookup #1\tTypeScript lookup #2\tTypeScript lookup #3\tTypeScript lookup #4\tTypeScript lookup #5\n/mod.js\t/mod.ts\t/mod.tsx\t/mod.d.ts\t/mod.js\t./mod.jsx\n/mod.mjs\t/mod.mts\t/mod.d.mts\t/mod.mjs\t\t\n/mod.cjs\t/mod.cts\t/mod.d.cts\t/mod.cjs\t\t\n\nNote that this behavior is independent of the actual module specifier written in the import. This means that TypeScript can resolve to a .ts or .d.ts file even if the module specifier explicitly uses a .js file extension:\n\nimport x from \"./mod.js\";\n// Runtime lookup: \"./mod.js\"\n// TypeScript lookup #1: \"./mod.ts\"\n// TypeScript lookup #2: \"./mod.d.ts\"\n// TypeScript lookup #3: \"./mod.js\"\n\nSee TypeScript imitates the host’s module resolution, but with types for an explanation of why TypeScript’s module resolution works this way.\n\nRelative file path resolution\n\nAll of TypeScript’s moduleResolution algorithms support referencing a module by a relative path that includes a file extension (which will be substituted according to the rules above):\n\n// @Filename: a.ts\nexport {};\n// @Filename: b.ts\nimport {} from \"./a.js\"; // ✅ Works in every `moduleResolution`\nExtensionless relative paths\n\nIn some cases, the runtime or bundler allows omitting a .js file extension from a relative path. TypeScript supports this behavior where the moduleResolution setting and the context indicate that the runtime or bundler supports it:\n\n// @Filename: a.ts\nexport {};\n// @Filename: b.ts\nimport {} from \"./a\";\n\nIf TypeScript determines that the runtime will perform a lookup for ./a.js given the module specifier \"./a\", then ./a.js will undergo extension substitution, and resolve to the file a.ts in this example.\n\nExtensionless relative paths are not supported in import paths in Node.js, and are not always supported in file paths specified in package.json files. TypeScript currently never supports omitting a .mjs/.mts or .cjs/.cts file extension, even though some runtimes and bundlers do.\n\nDirectory modules (index file resolution)\n\nIn some cases, a directory, rather than a file, can be referenced as a module. In the simplest and most common case, this involves the runtime or bundler looking for an index.js file in a directory. TypeScript supports this behavior where the moduleResolution setting and the context indicate that the runtime or bundler supports it:\n\n// @Filename: dir/index.ts\nexport {};\n// @Filename: b.ts\nimport {} from \"./dir\";\n\nIf TypeScript determines that the runtime will perform a lookup for ./dir/index.js given the module specifier \"./dir\", then ./dir/index.js will undergo extension substitution, and resolve to the file dir/index.ts in this example.\n\nDirectory modules may also contain a package.json file, where resolution of the \"main\" and \"types\" fields are supported, and take precedence over index.js lookups. The \"typesVersions\" field is also supported in directory modules.\n\nNote that directory modules are not the same as node_modules packages and only support a subset of the features available to packages, and are not supported at all in some contexts. Node.js considers them a legacy feature.\n\npaths\nOverview\n\nTypeScript offers a way to override the compiler’s module resolution for bare specifiers with the paths compiler option. While the feature was originally designed to be used with the AMD module loader (a means of running modules in the browser before ESM existed or bundlers were widely used), it still has uses today when a runtime or bundler supports module resolution features that TypeScript does not model. For example, when running Node.js with --experimental-network-imports, you can manually specify a local type definition file for a specific https:// import:\n\n{\n  \"compilerOptions\": {\n    \"module\": \"nodenext\",\n    \"paths\": {\n      \"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"]\n    }\n  }\n}\n// Typed by ./node_modules/@types/lodash/index.d.ts due to `paths` entry\nimport { add } from \"https://esm.sh/lodash@4.17.21\";\n\nIt’s also common for apps built with bundlers to define convenience path aliases in their bundler configuration, and then inform TypeScript of those aliases with paths:\n\n{\n  \"compilerOptions\": {\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"paths\": {\n      \"@app/*\": [\"./src/*\"]\n    }\n  }\n}\npaths does not affect emit\n\nThe paths option does not change the import path in the code emitted by TypeScript. Consequently, it’s very easy to create path aliases that appear to work in TypeScript but will crash at runtime:\n\n{\n  \"compilerOptions\": {\n    \"module\": \"nodenext\",\n    \"paths\": {\n      \"node-has-no-idea-what-this-is\": [\"./oops.ts\"]\n    }\n  }\n}\n// TypeScript: ✅\n// Node.js: 💥\nimport {} from \"node-has-no-idea-what-this-is\";\n\nWhile it’s ok for bundled apps to set up paths, it’s very important that published libraries do not, since the emitted JavaScript will not work for consumers of the library without those users setting up the same aliases for both TypeScript and their bundler. Both libraries and apps can consider package.json \"imports\" as a standard replacement for convenience paths aliases.\n\npaths should not point to monorepo packages or node_modules packages\n\nWhile module specifiers that match paths aliases are bare specifiers, once the alias is resolved, module resolution proceeds on the resolved path as a relative path. Consequently, resolution features that happen for node_modules package lookups, including package.json \"exports\" field support, do not take effect when a paths alias is matched. This can lead to surprising behavior if paths is used to point to a node_modules package:\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"pkg\": [\"./node_modules/pkg/dist/index.d.ts\"],\n      \"pkg/*\": [\"./node_modules/pkg/*\"]\n    }\n  }\n}\n\nWhile this configuration may simulate some of the behavior of package resolution, it overrides any main, types, exports, and typesVersions the package’s package.json file defines, and imports from the package may fail at runtime.\n\nThe same caveat applies to packages referencing each other in a monorepo. Instead of using paths to make TypeScript artificially resolve \"@my-scope/lib\" to a sibling package, it’s best to use workspaces via npm, yarn, or pnpm to symlink your packages into node_modules, so both TypeScript and the runtime or bundler perform real node_modules package lookups. This is especially important if the monorepo packages will be published to npm—the packages will reference each other via node_modules package lookups once installed by users, and using workspaces allows you to test that behavior during local development.\n\nRelationship to baseUrl\n\nWhen baseUrl is provided, the values in each paths array are resolved relative to the baseUrl. Otherwise, they are resolved relative to the tsconfig.json file that defines them.\n\nWildcard substitutions\n\npaths patterns can contain a single * wildcard, which matches any string. The * token can then be used in the file path values to substitute the matched string:\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"@app/*\": [\"./src/*\"]\n    }\n  }\n}\n\nWhen resolving an import of \"@app/components/Button\", TypeScript will match on @app/*, binding * to components/Button, and then attempt to resolve the path ./src/components/Button relative to the tsconfig.json path. The remainder of this lookup will follow the same rules as any other relative path lookup according to the moduleResolution setting.\n\nWhen multiple patterns match a module specifier, the pattern with the longest matching prefix before any * token is used:\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./src/foo/one.ts\"],\n      \"foo/*\": [\"./src/foo/two.ts\"],\n      \"foo/bar\": [\"./src/foo/three.ts\"]\n    }\n  }\n}\n\nWhen resolving an import of \"foo/bar\", all three paths patterns match, but the last is used because \"foo/bar\" is longer than \"foo/\" and \"\".\n\nFallbacks\n\nMultiple file paths can be provided for a path mapping. If resolution fails for one path, the next one in the array will be attempted until resolution succeeds or the end of the array is reached.\n\n{\n  \"compilerOptions\": {\n    \"paths\": {\n      \"*\": [\"./vendor/*\", \"./types/*\"]\n    }\n  }\n}\nbaseUrl\n\nbaseUrl was designed for use with AMD module loaders. If you aren’t using an AMD module loader, you probably shouldn’t use baseUrl. Since TypeScript 4.1, baseUrl is no longer required to use paths and should not be used just to set the directory paths values are resolved from.\n\nThe baseUrl compiler option can be combined with any moduleResolution mode and specifies a directory that bare specifiers (module specifiers that don’t begin with ./, ../, or /) are resolved from. baseUrl has a higher precedence than node_modules package lookups in moduleResolution modes that support them.\n\nWhen performing a baseUrl lookup, resolution proceeds with the same rules as other relative path resolutions. For example, in a moduleResolution mode that supports extensionless relative paths a module specifier \"some-file\" may resolve to /src/some-file.ts if baseUrl is set to /src.\n\nResolution of relative module specifiers are never affected by the baseUrl option.\n\nnode_modules package lookups\n\nNode.js treats module specifiers that aren’t relative paths, absolute paths, or URLs as references to packages that it looks up in node_modules subdirectories. Bundlers conveniently adopted this behavior to allow their users to use the same dependency management system, and often even the same dependencies, as they would in Node.js. All of TypeScript’s moduleResolution options except classic support node_modules lookups. (classic supports lookups in node_modules/@types when other means of resolution fail, but never looks for packages in node_modules directly.) Every node_modules package lookup has the following structure (beginning after higher precedence bare specifier rules, like paths, baseUrl, self-name imports, and package.json \"imports\" lookups have been exhausted):\n\nFor each ancestor directory of the importing file, if a node_modules directory exists within it:\nIf a directory with the same name as the package exists within node_modules:\nAttempt to resolve types from the package directory.\nIf a result is found, return it and stop the search.\nIf a directory with the same name as the package exists within node_modules/@types:\nAttempt to resolve types from the @types package directory.\nIf a result is found, return it and stop the search.\nRepeat the previous search through all node_modules directories, but this time, allow JavaScript files as a result, and do not search in @types directories.\n\nAll moduleResolution modes (except classic) follow this pattern, while the details of how they resolve from a package directory, once located, differ, and are explained in the following sections.\n\npackage.json \"exports\"\n\nWhen moduleResolution is set to node16, nodenext, or bundler, and resolvePackageJsonExports is not disabled, TypeScript follows Node.js’s package.json \"exports\" spec when resolving from a package directory triggered by a bare specifier node_modules package lookup.\n\nTypeScript’s implementation for resolving a module specifier through \"exports\" to a file path follows Node.js exactly. Once a file path is resolved, however, TypeScript will still try multiple file extensions in order to prioritize finding types.\n\nWhen resolving through conditional \"exports\", TypeScript always matches the \"types\" and \"default\" conditions if present. Additionally, TypeScript will match a versioned types condition in the form \"types@{selector}\" (where {selector} is a \"typesVersions\"-compatible version selector) according to the same version-matching rules implemented in \"typesVersions\". Other non-configurable conditions are dependent on the moduleResolution mode and specified in the following sections. Additional conditions can be configured to match with the customConditions compiler option.\n\nNote that the presence of \"exports\" prevents any subpaths not explicitly listed or matched by a pattern in \"exports\" from being resolved.\n\nExample: subpaths, conditions, and extension substitution\n\nScenario: \"pkg/subpath\" is requested with conditions [\"types\", \"node\", \"require\"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n{\n  \"name\": \"pkg\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.cjs\"\n    },\n    \"./subpath\": {\n      \"import\": \"./subpath/index.mjs\",\n      \"require\": \"./subpath/index.cjs\"\n    }\n  }\n}\n\nResolution process within the package directory:\n\nDoes \"exports\" exist? Yes.\nDoes \"exports\" have a \"./subpath\" entry? Yes.\nThe value at exports[\"./subpath\"] is an object—it must be specifying conditions.\nDoes the first condition \"import\" match this request? No.\nDoes the second condition \"require\" match this request? Yes.\nDoes the path \"./subpath/index.cjs\" have a recognized TypeScript file extension? No, so use extension substitution.\nVia extension substitution, try the following paths, returning the first one that exists, or undefined otherwise:\n./subpath/index.cts\n./subpath/index.d.cts\n./subpath/index.cjs\n\nIf ./subpath/index.cts or ./subpath.d.cts exists, resolution is complete. Otherwise, resolution searches node_modules/@types/pkg and other node_modules directories in an attempt to resolve types, according to the node_modules package lookups rules. If no types are found, a second pass through all node_modules resolves to ./subpath/index.cjs (assuming it exists), which counts as a successful resolution, but one that does not provide types, leading to any-typed imports and a noImplicitAny error if enabled.\n\nExample: explicit \"types\" condition\n\nScenario: \"pkg/subpath\" is requested with conditions [\"types\", \"node\", \"import\"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n{\n  \"name\": \"pkg\",\n  \"exports\": {\n    \"./subpath\": {\n      \"import\": {\n        \"types\": \"./types/subpath/index.d.mts\",\n        \"default\": \"./es/subpath/index.mjs\"\n      },\n      \"require\": {\n        \"types\": \"./types/subpath/index.d.cts\",\n        \"default\": \"./cjs/subpath/index.cjs\"\n      }\n    }\n  }\n}\n\nResolution process within the package directory:\n\nDoes \"exports\" exist? Yes.\nDoes \"exports\" have a \"./subpath\" entry? Yes.\nThe value at exports[\"./subpath\"] is an object—it must be specifying conditions.\nDoes the first condition \"import\" match this request? Yes.\nThe value at exports[\"./subpath\"].import is an object—it must be specifying conditions.\nDoes the first condition \"types\" match this request? Yes.\nDoes the path \"./types/subpath/index.d.mts\" have a recognized TypeScript file extension? Yes, so don’t use extension substitution.\nReturn the path \"./types/subpath/index.d.mts\" if the file exists, undefined otherwise.\nExample: versioned \"types\" condition\n\nScenario: using TypeScript 4.7.5, \"pkg/subpath\" is requested with conditions [\"types\", \"node\", \"import\"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n{\n  \"name\": \"pkg\",\n  \"exports\": {\n    \"./subpath\": {\n      \"types@>=5.2\": \"./ts5.2/subpath/index.d.ts\",\n      \"types@>=4.6\": \"./ts4.6/subpath/index.d.ts\",\n      \"types\": \"./tsold/subpath/index.d.ts\",\n      \"default\": \"./dist/subpath/index.js\"\n    }\n  }\n}\n\nResolution process within the package directory:\n\nDoes \"exports\" exist? Yes.\nDoes \"exports\" have a \"./subpath\" entry? Yes.\nThe value at exports[\"./subpath\"] is an object—it must be specifying conditions.\nDoes the first condition \"types@>=5.2\" match this request? No, 4.7.5 is not greater than or equal to 5.2.\nDoes the second condition \"types@>=4.6\" match this request? Yes, 4.7.5 is greater than or equal to 4.6.\nDoes the path \"./ts4.6/subpath/index.d.ts\" have a recognized TypeScript file extension? Yes, so don’t use extension substitution.\nReturn the path \"./ts4.6/subpath/index.d.ts\" if the file exists, undefined otherwise.\nExample: subpath patterns\n\nScenario: \"pkg/wildcard.js\" is requested with conditions [\"types\", \"node\", \"import\"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a package directory with the following package.json:\n\n{\n  \"name\": \"pkg\",\n  \"type\": \"module\",\n  \"exports\": {\n    \"./*.js\": {\n      \"types\": \"./types/*.d.ts\",\n      \"default\": \"./dist/*.js\"\n    }\n  }\n}\n\nResolution process within the package directory:\n\nDoes \"exports\" exist? Yes.\nDoes \"exports\" have a \"./wildcard.js\" entry? No.\nDoes any key with a * in it match \"./wildcard.js\"? Yes, \"./*.js\" matches and sets wildcard to be the substitution.\nThe value at exports[\"./*.js\"] is an object—it must be specifying conditions.\nDoes the first condition \"types\" match this request? Yes.\nIn ./types/*.d.ts, replace * with the substitution wildcard. ./types/wildcard.d.ts\nDoes the path \"./types/wildcard.d.ts\" have a recognized TypeScript file extension? Yes, so don’t use extension substitution.\nReturn the path \"./types/wildcard.d.ts\" if the file exists, undefined otherwise.\nExample: \"exports\" block other subpaths\n\nScenario: \"pkg/dist/index.js\" is requested in a package directory with the following package.json:\n\n{\n  \"name\": \"pkg\",\n  \"main\": \"./dist/index.js\",\n  \"exports\": \"./dist/index.js\"\n}\n\nResolution process within the package directory:\n\nDoes \"exports\" exist? Yes.\nThe value at exports is a string—it must be a file path for the package root (\".\").\nIs the request \"pkg/dist/index.js\" for the package root? No, it has a subpath dist/index.js.\nResolution fails; return undefined.\n\nWithout \"exports\", the request could have succeeded, but the presence of \"exports\" prevents resolving any subpaths that cannot be matched through \"exports\".\n\npackage.json \"typesVersions\"\n\nA node_modules package or directory module may specify a \"typesVersions\" field in its package.json to redirect TypeScript’s resolution process according to the TypeScript compiler version, and for node_modules packages, according to the subpath being resolved. This allows package authors to include new TypeScript syntax in one set of type definitions while providing another set for backward compatibility with older TypeScript versions (through a tool like downlevel-dts). \"typesVersions\" is supported in all moduleResolution modes; however, the field is not read in situations when package.json \"exports\" are read.\n\nExample: redirect all requests to a subdirectory\n\nScenario: a module imports \"pkg\" using TypeScript 5.2, where node_modules/pkg/package.json is:\n\n{\n  \"name\": \"pkg\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \">=3.1\": {\n      \"*\": [\"ts3.1/*\"]\n    }\n  }\n}\n\nResolution process:\n\n(Depending on compiler options) Does \"exports\" exist? No.\nDoes \"typesVersions\" exist? Yes.\nIs the TypeScript version >=3.1? Yes. Remember the mapping \"*\": [\"ts3.1/*\"].\nAre we resolving a subpath after the package name? No, just the root \"pkg\".\nDoes \"types\" exist? Yes.\nDoes any key in \"typesVersions\" match ./index.d.ts? Yes, \"*\" matches and sets index.d.ts to be the substitution.\nIn ts3.1/*, replace * with the substitution ./index.d.ts: ts3.1/index.d.ts.\nDoes the path ./ts3.1/index.d.ts have a recognized TypeScript file extension? Yes, so don’t use extension substitution.\nReturn the path ./ts3.1/index.d.ts if the file exists, undefined otherwise.\nExample: redirect requests for a specific file\n\nScenario: a module imports \"pkg\" using TypeScript 3.9, where node_modules/pkg/package.json is:\n\n{\n  \"name\": \"pkg\",\n  \"version\": \"1.0.0\",\n  \"types\": \"./index.d.ts\",\n  \"typesVersions\": {\n    \"<4.0\": { \"index.d.ts\": [\"index.v3.d.ts\"] }\n  }\n}\n\nResolution process:\n\n(Depending on compiler options) Does \"exports\" exist? No.\nDoes \"typesVersions\" exist? Yes.\nIs the TypeScript version <4.0? Yes. Remember the mapping \"index.d.ts\": [\"index.v3.d.ts\"].\nAre we resolving a subpath after the package name? No, just the root \"pkg\".\nDoes \"types\" exist? Yes.\nDoes any key in \"typesVersions\" match ./index.d.ts? Yes, \"index.d.ts\" matches.\nDoes the path ./index.v3.d.ts have a recognized TypeScript file extension? Yes, so don’t use extension substitution.\nReturn the path ./index.v3.d.ts if the file exists, undefined otherwise.\npackage.json \"main\" and \"types\"\n\nIf a directory’s package.json \"exports\" field is not read (either due to compiler options, or because it is not present, or because the directory is being resolved as a directory module instead of a node_modules package) and the module specifier does not have a subpath after the package name or package.json-containing directory, TypeScript will attempt to resolve from these package.json fields, in order, in an attempt to find the main module for the package or directory:\n\n\"types\"\n\"typings\" (legacy)\n\"main\"\n\nThe declaration file found at \"types\" is assumed to be an accurate representation of the implementation file found at \"main\". If \"types\" and \"typings\" are not present or cannot be resolved, TypeScript will read the \"main\" field and perform extension substitution to find a declaration file.\n\nWhen publishing a typed package to npm, it’s recommended to include a \"types\" field even if extension substitution or package.json \"exports\" make it unnecessary, because npm shows a TS icon on the package registry listing only if the package.json contains a \"types\" field.\n\nPackage-relative file paths\n\nIf neither package.json \"exports\" nor package.json \"typesVersions\" apply, subpaths of a bare package specifier resolve relative to the package directory, according to applicable relative path resolution rules. In modes that respect [package.json \"exports\"], this behavior is blocked by the mere presence of the \"exports\" field in the package’s package.json, even if the import fails to resolve through \"exports\", as demonstrated in an example above. On the other hand, if the import fails to resolve through \"typesVersions\", a package-relative file path resolution is attempted as a fallback.\n\nWhen package-relative paths are supported, they resolve under the same rules as any other relative path considering the moduleResolution mode and context. For example, in --moduleResolution nodenext, directory modules and extensionless paths are only supported in require calls, not in imports:\n\n// @Filename: module.mts\nimport \"pkg/dist/foo\";                // ❌ import, needs `.js` extension\nimport \"pkg/dist/foo.js\";             // ✅\nimport foo = require(\"pkg/dist/foo\"); // ✅ require, no extension needed\npackage.json \"imports\" and self-name imports\n\nWhen moduleResolution is set to node16, nodenext, or bundler, and resolvePackageJsonImports is not disabled, TypeScript will attempt to resolve import paths beginning with # through the the \"imports\" field of the nearest ancestor package.json of the importing file. Similarly, when package.json \"exports\" lookups are enabled, TypeScript will attempt to resolve import paths beginning with the current package name—that is, the value in the \"name\" field of the nearest ancestor package.json of the importing file—through the \"exports\" field of that package.json. Both of these features allow files in a package to import other files in the same package, replacing a relative import path.\n\nTypeScript follows Node.js’s resolution algorithm for \"imports\" and self references exactly up until a file path is resolved. At that point, TypeScript’s resolution algorithm forks based on whether the package.json containing the \"imports\" or \"exports\" being resolved belongs to a node_modules dependency or the local project being compiled (i.e., its directory contains the tsconfig.json file for the project that contains the importing file):\n\nIf the package.json is in node_modules, TypeScript will apply extension substitution to the file path if it doesn’t already have a recognized TypeScript file extension, and check for the existence of the resulting file paths.\nIf the package.json is part of the local project, an additional remapping step is performed in order to find the input TypeScript implementation file that will eventually produce the output JavaScript or declaration file path that was resolved from \"imports\". Without this step, any compilation that resolves an \"imports\" path would be referencing output files from the previous compilation instead of other input files that are intended to be included in the current compilation. This remapping uses the outDir/declarationDir and rootDir from the tsconfig.json, so using \"imports\" usually requires an explicit rootDir to be set.\n\nThis variation allows package authors to write \"imports\" and \"exports\" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.\n\nExample: local project with conditions\n\nScenario: \"/src/main.mts\" imports \"#utils\" with conditions [\"types\", \"node\", \"import\"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"moduleResolution\": \"node16\",\n    \"resolvePackageJsonImports\": true,\n    \"rootDir\": \"./src\",\n    \"outDir\": \"./dist\"\n  }\n}\n// package.json\n{\n  \"name\": \"pkg\",\n  \"imports\": {\n    \"#utils\": {\n      \"import\": \"./dist/utils.d.mts\",\n      \"require\": \"./dist/utils.d.cts\"\n    }\n  }\n}\n\nResolution process:\n\nImport path starts with #, try to resolve through \"imports\".\nDoes \"imports\" exist in the nearest ancestor package.json? Yes.\nDoes \"#utils\" exist in the \"imports\" object? Yes.\nThe value at imports[\"#utils\"] is an object—it must be specifying conditions.\nDoes the first condition \"import\" match this request? Yes.\nShould we attempt to map the output path to an input path? Yes, because:\nIs the package.json in node_modules? No, it’s in the local project.\nIs the tsconfig.json within the package.json directory? Yes.\nIn ./dist/utils.d.mts, replace the outDir prefix with rootDir. ./src/utils.d.mts\nReplace the output extension .d.mts with the corresponding input extension .mts. ./src/utils.mts\nReturn the path \"./src/utils.mts\" if the file exists.\nOtherwise, return the path \"./dist/utils.d.mts\" if the file exists.\nExample: node_modules dependency with subpath pattern\n\nScenario: \"/node_modules/pkg/main.mts\" imports \"#internal/utils\" with conditions [\"types\", \"node\", \"import\"] (determined by moduleResolution setting and the context that triggered the module resolution request) with the package.json:\n\n// /node_modules/pkg/package.json\n{\n  \"name\": \"pkg\",\n  \"imports\": {\n    \"#internal/*\": {\n      \"import\": \"./dist/internal/*.mjs\",\n      \"require\": \"./dist/internal/*.cjs\"\n    }\n  }\n}\n\nResolution process:\n\nImport path starts with #, try to resolve through \"imports\".\nDoes \"imports\" exist in the nearest ancestor package.json? Yes.\nDoes \"#internal/utils\" exist in the \"imports\" object? No, check for pattern matches.\nDoes any key with a * match \"#internal/utils\"? Yes, \"#internal/*\" matches and sets utils to be the substitution.\nThe value at imports[\"#internal/*\"] is an object—it must be specifying conditions.\nDoes the first condition \"import\" match this request? Yes.\nShould we attempt to map the output path to an input path? No, because the package.json is in node_modules.\nIn ./dist/internal/*.mjs, replace * with the substitution utils. ./dist/internal/utils.mjs\nDoes the path ./dist/internal/utils.mjs have a recognized TypeScript file extension? No, try extension substitution.\nVia extension substitution, try the following paths, returning the first one that exists, or undefined otherwise:\n./dist/internal/utils.mts\n./dist/internal/utils.d.mts\n./dist/internal/utils.mjs\nnode16\n, \nnodenext\n\nThese modes reflect the module resolution behavior of Node.js v12 and later. (node16 and nodenext are currently identical, but if Node.js makes significant changes to its module system in the future, node16 will be frozen while nodenext will be updated to reflect the new behavior.) In Node.js, the resolution algorithm for ECMAScript imports is significantly different from the algorithm for CommonJS require calls. For each module specifier being resolved, the syntax and the module format of the importing file are first used to determine whether the module specifier will be in an import or require in the emitted JavaScript. That information is then passed into the module resolver to determine which resolution algorithm to use (and whether to use the \"import\" or \"require\" condition for package.json \"exports\" or \"imports\").\n\nTypeScript files that are determined to be in CommonJS format may still use import and export syntax by default, but the emitted JavaScript will use require and module.exports instead. This means that it’s common to see import statements that are resolved using the require algorithm. If this causes confusion, the verbatimModuleSyntax compiler option can be enabled, which prohibits the use of import statements that would be emitted as require calls.\n\nNote that dynamic import() calls are always resolved using the import algorithm, according to Node.js’s behavior. However, import() types are resolved according to the format of the importing file (for backward compatibility with existing CommonJS-format type declarations):\n\n// @Filename: module.mts\nimport x from \"./mod.js\";             // `import` algorithm due to file format (emitted as-written)\nimport(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)\ntype Mod = typeof import(\"./mod.js\"); // `import` algorithm due to file format\nimport mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)\n// @Filename: commonjs.cts\nimport x from \"./mod\";                // `require` algorithm due to file format (emitted as `require`)\nimport(\"./mod.js\");                   // `import` algorithm due to syntax (emitted as-written)\ntype Mod = typeof import(\"./mod\");    // `require` algorithm due to file format\nimport mod = require(\"./mod\");        // `require` algorithm due to syntax (emitted as `require`)\nImplied and enforced options\n--moduleResolution node16 and nodenext must be paired with their corresponding module value.\nSupported features\n\nFeatures are listed in order of precedence.\n\n\timport\trequire\npaths\t✅\t✅\nbaseUrl\t✅\t✅\nnode_modules package lookups\t✅\t✅\npackage.json \"exports\"\t✅ matches types, node, import\t✅ matches types, node, require\npackage.json \"imports\" and self-name imports\t✅ matches types, node, import\t✅ matches types, node, require\npackage.json \"typesVersions\"\t✅\t✅\nPackage-relative paths\t✅ when exports not present\t✅ when exports not present\nFull relative paths\t✅\t✅\nExtensionless relative paths\t❌\t✅\nDirectory modules\t❌\t✅\nbundler\n\n--moduleResolution bundler attempts to model the module resolution behavior common to most JavaScript bundlers. In short, this means supporting all the behaviors traditionally associated with Node.js’s CommonJS require resolution algorithm like node_modules lookups, directory modules, and extensionless paths, while also supporting newer Node.js resolution features like package.json \"exports\" and package.json \"imports\".\n\nThis is very similar to the behavior of node16 and nodenext resolving in CommonJS mode, but in bundler, the conditions used to resolve package.json \"exports\" and \"imports\" are always \"types\" and \"import\". To understand why, let’s compare against what happens to an import in a .ts file in nodenext:\n\n// index.ts\nimport { foo } from \"pkg\";\n\nIn --module nodenext --moduleResolution nodenext, the --module setting first determines whether the import will be emitted to the .js file as an import or require call and passes that information to TypeScript’s module resolver, which decides whether to match \"import\" or \"require\" conditions accordingly. This ensures TypeScript’s module resolution process, although working from input .ts files, reflects what will happen in Node.js’s module resolution process when it runs the output .js files.\n\nWhen using a bundler, on the other hand, the bundler typically processes the raw .ts files directly and runs its module resolution process on the untransformed import statement. In this scenario, it doesn’t make a lot of sense to think about how TypeScript will emit the import, because TypeScript isn’t being used to emit anything at all. As far as the bundler is concerned, imports are imports and requires are requires, so the conditions used to resolve package.json \"exports\" and \"imports\" are determined by the syntax seen in the input .ts file. Likewise, the conditions TypeScript’s module resolution process uses in --moduleResolution bundler are also determined by the input syntax in input TypeScript files—it’s just that require calls are not currently resolved at all:\n\n// Some library file:\ndeclare function require(module: string): any;\n// index.ts\nimport { foo } from \"pkg\";    // Resolved with \"import\" condition\nimport pkg2 = require(\"pkg\"); // Not allowed\nconst pkg = require(\"pkg\");   // Not an error, but not resolved to anything\n   // ^? any\n\nSince TypeScript doesn’t currently support resolving require calls in --moduleResolution bundler, everything it does resolve uses the \"import\" condition.\n\nImplied and enforced options\n--moduleResolution bundler must be paired with the --module esnext option.\n--moduleResolution bundler implies --allowSyntheticDefaultImports.\nSupported features\npaths ✅\nbaseUrl ✅\nnode_modules package lookups ✅\npackage.json \"exports\" ✅ matches types, import\npackage.json \"imports\" and self-name imports ✅ matches types, import\npackage.json \"typesVersions\" ✅\nPackage-relative paths ✅ when exports not present\nFull relative paths ✅\nExtensionless relative paths ✅\nDirectory modules ✅\nnode10\n (formerly known as \nnode\n)\n\n--moduleResolution node was renamed to node10 (keeping node as an alias for backward compatibility) in TypeScript 5.0. It reflects the CommonJS module resolution algorithm as it existed in Node.js versions earlier than v12. It should no longer be used.\n\nSupported features\npaths ✅\nbaseUrl ✅\nnode_modules package lookups ✅\npackage.json \"exports\" ❌\npackage.json \"imports\" and self-name imports ❌\npackage.json \"typesVersions\" ✅\nPackage-relative paths ✅\nFull relative paths ✅\nExtensionless relative paths ✅\nDirectory modules ✅\nclassic\n\nDo not use classic.\n\nOn this page\nModule syntax\nImporting and exporting TypeScript-specific declarations\nType-only imports and exports\nimport() types\nexport = and import = require()\nAmbient modules\nThe module compiler option\nnode16, nodenext\nes2015, es2020, es2022, esnext\ncommonjs\nsystem\namd\numd\nThe moduleResolution compiler option\nCommon features and processes\nnode16, nodenext\nbundler\nnode10 (formerly known as node)\nclassic\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\nHCDC\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.638 seconds."
  },
  {
    "title": "TypeScript: Documentation - Modules - Choosing Compiler Options",
    "url": "https://www.typescriptlang.org/docs/handbook/modules/guides/choosing-compiler-options.html",
    "html": "Modules - Choosing Compiler Options\nI’m writing an app\n\nA single tsconfig.json can only represent a single environment, both in terms of what globals are available and in terms of how modules behave. If your app contains server code, DOM code, web worker code, test code, and code to be shared by all of those, each of those should have its own tsconfig.json, connected with project references. Then, use this guide once for each tsconfig.json. For library-like projects within an app, especially ones that need to run in multiple runtime environments, use the “I’m writing a library” section.\n\nI’m using a bundler\n\nIn addition to adopting the following settings, it’s also recommended not to set { \"type\": \"module\" } or use .mts files in bundler projects for now. Some bundlers adopt different ESM/CJS interop behavior under these circumstances, which TypeScript cannot currently analyze with \"moduleResolution\": \"bundler\". See issue #54102 for more information.\n\n{\n  \"compilerOptions\": {\n    // This is not a complete template; it only\n    // shows relevant module-related settings.\n    // Be sure to set other important options\n    // like `target`, `lib`, and `strict`.\n    // Required\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"esModuleInterop\": true,\n    // Consult your bundler’s documentation\n    \"customConditions\": [\"module\"],\n    // Recommended\n    \"noEmit\": true, // or `emitDeclarationOnly`\n    \"allowImportingTsExtensions\": true,\n    \"allowArbitraryExtensions\": true,\n    \"verbatimModuleSyntax\": true, // or `isolatedModules`\n  }\n}\nI’m compiling and running the outputs in Node.js\n\nRemember to set \"type\": \"module\" or use .mts files if you intend to emit ES modules.\n\n{\n  \"compilerOptions\": {\n    // This is not a complete template; it only\n    // shows relevant module-related settings.\n    // Be sure to set other important options\n    // like `target`, `lib`, and `strict`.\n    // Required\n    \"module\": \"nodenext\",\n    // Implied by `\"module\": \"nodenext\"`:\n    // \"moduleResolution\": \"nodenext\",\n    // \"esModuleInterop\": true,\n    // \"target\": \"esnext\",\n    // Recommended\n    \"verbatimModuleSyntax\": true,\n  }\n}\nI’m using ts-node\n\nts-node attempts to be compatible with the same code and the same tsconfig.json settings that can be used to compile and run the JS outputs in Node.js. Refer to ts-node documentation for more details.\n\nI’m using tsx\n\nWhereas ts-node makes minimal modifications to Node.js’s module system by default, tsx behaves more like a bundler, allowing extensionless/index module specifiers and arbitrary mixing of ESM and CJS. Use the same settings for tsx as you would for a bundler.\n\nI’m writing ES modules for the browser, with no bundler or module compiler\n\nTypeScript does not currently have options dedicated to this scenario, but you can approximate them by using a combination of the nodenext ESM module resolution algorithm and paths as a substitute for URL and import map support.\n\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // This is not a complete template; it only\n    // shows relevant module-related settings.\n    // Be sure to set other important options\n    // like `target`, `lib`, and `strict`.\n    // Combined with `\"type\": \"module\"` in a local package.json,\n    // this enforces including file extensions on relative path imports.\n    \"module\": \"nodenext\",\n    \"paths\": {\n      // Point TS to local types for remote URLs:\n      \"https://esm.sh/lodash@4.17.21\": [\"./node_modules/@types/lodash/index.d.ts\"],\n      // Optional: point bare specifier imports to an empty file\n      // to prohibit importing from node_modules specifiers not listed here:\n      \"*\": [\"./empty-file.ts\"]\n    }\n  }\n}\n\nThis setup allows explicitly listed HTTPS imports to use locally-installed type declaration files, while erroring on imports that would normally resolve in node_modules:\n\nimport {} from \"lodash\";\n//             ^^^^^^^^\n// File '/project/empty-file.ts' is not a module. ts(2306)\n\nAlternatively, you can use import maps to explicitly map a list of bare specifiers to URLs in the browser, while relying on nodenext’s default node_modules lookups, or on paths, to direct TypeScript to type declaration files for those bare specifier imports:\n\n<script type=\"importmap\">\n{\n  \"imports\": {\n    \"lodash\": \"https://esm.sh/lodash@4.17.21\"\n  }\n}\n</script>\nimport {} from \"lodash\";\n// Browser: https://esm.sh/lodash@4.17.21\n// TypeScript: ./node_modules/@types/lodash/index.d.ts\nI’m writing a library\n\nChoosing compilation settings as a library author is a fundamentally different process from choosing settings as an app author. When writing an app, settings are chosen that reflect the runtime environment or bundler—typically a single entity with known behavior. When writing a library, you would ideally check your code under all possible library consumer compilation settings. Since this is impractical, you can instead use the strictest possible settings, since satisfying those tends to satisfy all others.\n\n{\n  \"compilerOptions\": {\n    \"module\": \"node16\",\n    \"target\": \"es2020\", // set to the *lowest* target you support\n    \"strict\": true,\n    \"verbatimModuleSyntax\": true,\n    \"declaration\": true,\n    \"sourceMap\": true,\n    \"declarationMap\": true\n  }\n}\n\nLet’s examine why we picked each of these settings:\n\nmodule: \"node16\". When a codebase is compatible with Node.js’s module system, it almost always works in bundlers as well. If you’re using a third-party emitter to emit ESM outputs, ensure that you set \"type\": \"module\" in your package.json so TypeScript checks your code as ESM, which uses a stricter module resolution algorithm in Node.js than CommonJS does. As an example, let’s look at what would happen if a library were to compile with \"moduleResolution\": \"bundler\":\n\nexport * from \"./utils\";\n\nAssuming ./utils.ts (or ./utils/index.ts) exists, a bundler would be fine with this code, so \"moduleResolution\": \"bundler\" doesn’t complain. Compiled with \"module\": \"esnext\", the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\nError [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js\nDid you mean to import ./utils.js?\n\nOn the other hand, if we had written:\n\nexport * from \"./utils.js\";\n\nThis would produce output that works both in Node.js and in bundlers.\n\nIn short, \"moduleResolution\": \"bundler\" is infectious, allowing code that only works in bundlers to be produced. Likewise, \"moduleResolution\": \"nodenext\" is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\ntarget: \"es2020\". Setting this value to the lowest ECMAScript version that you intend to support ensures the emitted code will not use language features introduced in a later version. Since target also implies a corresponding value for lib, this also ensures you don’t access globals that may not be available in older environments.\n\nstrict: true. Without this, you may write type-level code that ends up in your output .d.ts files and errors when a consumer compiles with strict enabled. For example, this extends clause:\n\nexport interface Super {\n  foo: string;\n}\nexport interface Sub extends Super {\n  foo: string | undefined;\n}\n\nis only an error under strictNullChecks. On the other hand, it’s very difficult to write code that errors only when strict is disabled, so it’s highly recommended for libraries to compile with strict.\n\nverbatimModuleSyntax: true. This setting protects against a few module-related pitfalls that can cause problems for library consumers. First, it prevents writing any import statements that could be interpreted ambiguously based on the user’s value of esModuleInterop or allowSyntheticDefaultImports. Previously, it was often suggested that libraries compile without esModuleInterop, since its use in libraries could force users to adopt it too. However, it’s also possible to write imports that only work without esModuleInterop, so neither value for the setting guarantees portability for libraries. verbatimModuleSyntax does provide such a guarantee.1 Second, it prevents the use of export default in modules that will be emitted as CommonJS, which can require bundler users and Node.js ESM users to consume the module differently. See the appendix on ESM/CJS Interop for more details.\n\ndeclaration: true emits type declaration files alongside the output JavaScript. This is needed for consumers of the library to have any type information.\n\nsourceMap: true and declarationMap: true emit source maps for the output JavaScript and type declaration files, respectively. These are only useful if the library also ships its source (.ts) files. By shipping source maps and source files, consumers of the library will be able to debug the library code somewhat more easily. By shipping declaration maps and source files, consumers will be able to see the original TypeScript sources when they run Go To Definition on imports from the libraries. Both of these represent a tradeoff between developer experience and library size, so it’s up to you whether to include them.\n\nConsiderations for bundling libraries\n\nIf you’re using a bundler to emit your library, then all your (non-externalized) imports will be processed by the bundler with known behavior, not by your users’ unknowable environments. In this case, you can use \"module\": \"esnext\" and \"moduleResolution\": \"bundler\", but only with two caveats:\n\nTypeScript cannot model module resolution when some files are bundled and some are externalized. When bundling libraries with dependencies, it’s common to bundle the first-party library source code into a single file, but leave imports of external dependencies as real imports in the bundled output. This essentially means module resolution is split between the bundler and the end user’s environment. To model this in TypeScript, you would want to process bundled imports with \"moduleResolution\": \"bundler\" and externalized imports with \"moduleResolution\": \"nodenext\" (or with multiple options to check that everything will work in a range of end-user environments). But TypeScript cannot be configured to use two different module resolution settings in the same compilation. As a consequence, using \"moduleResolution\": \"bundler\" may allow imports of externalized dependencies that would work in a bundler but are unsafe in Node.js. On the other hand, using \"moduleResolution\": \"nodenext\" may impose overly strict requirements on bundled imports.\n\nYou must ensure that your declaration files get bundled as well. Recall the first rule of declaration files: every declaration file represents exactly one JavaScript file. If you use \"moduleResolution\": \"bundler\" and use a bundler to emit an ESM bundle while using tsc to emit many individual declaration files, your declaration files may cause errors when consumed under \"module\": \"nodenext\". For example, an input file like:\n\nimport { Component } from \"./extensionless-relative-import\";\n\nwill have its import erased by the JS bundler, but produce a declaration file with an identical import statement. That import statement, however, will contain an invalid module specifier in Node.js, since it’s missing a file extension. For Node.js users, TypeScript will error on the declaration file and infect types referencing Component with any, assuming the dependency will crash at runtime.\n\nIf your TypeScript bundler does not produce bundled declaration files, use \"moduleResolution\": \"nodenext\" to ensure that the imports preserved in your declaration files will be compatible with end-users’ TypeScript settings. Even better, consider not bundling your library.\n\nNotes on dual-emit solutions\n\nA single TypeScript compilation (whether emitting or just type checking) assumes that each input file will only produce one output file. Even if tsc isn’t emitting anything, the type checking it performs on imported names rely on knowledge about how the output file will behave at runtime, based on the module- and emit-related options set in the tsconfig.json. While third-party emitters are generally safe to use in combination with tsc type checking as long as tsc can be configured to understand what the other emitter will emit, any solution that emits two different sets of outputs with different module formats while only type checking once leaves (at least) one of the outputs unchecked. Because external dependencies may expose different APIs to CommonJS and ESM consumers, there’s no configuration you can use to guarantee in a single compilation that both outputs will be type-safe. In practice, most dependencies follow best practices and dual-emit outputs work. Running tests and static analysis against all output bundles before publishing significantly reduces the chance of a serious problem going unnoticed.\n\nverbatimModuleSyntax can only work when the JS emitter emits the same module kind as tsc would given the tsconfig.json, source file extension, and package.json \"type\". The option works by enforcing that the import/require written is identical to the import/require emitted. Any configuration that produces both an ESM and a CJS output from the same source file is fundamentally incompatible with verbatimModuleSyntax, since its whole purpose is to prevent you from writing import anywhere that a require would be emitted. verbatimModuleSyntax can also be defeated by configuring a third-party emitter to emit a different module kind than tsc would—for example, by setting \"module\": \"esnext\" in tsconfig.json while configuring Babel to emit CommonJS.↩\nOn this page\nI’m writing an app\nI’m using a bundler\nI’m compiling and running the outputs in Node.js\nI’m using ts-node\nI’m using tsx\nI’m writing ES modules for the browser, with no bundler or module compiler\nI’m writing a library\nConsiderations for bundling libraries\nNotes on dual-emit solutions\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.314 seconds."
  },
  {
    "title": "TypeScript: Documentation - Modules - Theory",
    "url": "https://www.typescriptlang.org/docs/handbook/modules/theory.html",
    "html": "Modules - Theory\nScripts and modules in JavaScript\n\nIn the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiple script tags in HTML:\n\n<html>\n  <head>\n    <script src=\"a.js\"></script>\n    <script src=\"b.js\"></script>\n  </head>\n  <body></body>\n</html>\n\nThis approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope—appropriately called the “global scope”—meaning the scripts had to be very careful not to overwrite each others’ variables and functions.\n\nAny system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a “module system.” (It may sound obvious to say that each file in a module system is called a “module,” but the term is often used to contrast with script files, which run outside a module system, in a global scope.)\n\nThere are many module systems, and TypeScript supports emitting several, but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS).\n\nECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicated import and export syntax:\n\n// a.js\nexport default \"Hello from a.js\";\n// b.js\nimport a from \"./a.js\";\nconsole.log(a); // 'Hello from a.js'\n\nCommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It’s still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions named exports and require:\n\n// a.js\nexports.message = \"Hello from a.js\";\n// b.js\nconst a = require(\"./a\");\nconsole.log(a.message); // 'Hello from a.js'\n\nAccordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler’s job gets a little more complicated.\n\nTypeScript’s job concerning modules\n\nThe TypeScript compiler’s chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code’s intended runtime environment—what globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let’s use a few lines of input code as an example to think about all the information needed to analyze it:\n\nimport sayHello from \"greetings\";\nsayHello(\"world\");\n\nTo check this file, the compiler needs to know the type of sayHello (is it a function that can accept one string argument?), which opens quite a few additional questions:\n\nWill the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?\nWhat kind of module does the module system expect to find, given the file name it will load and its location on disk?\nIf output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?\nWhere will the module system look to find the module specified by \"greetings\"? Will the lookup succeed?\nWhat kind of module is the file resolved by that lookup?\nDoes the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?\nOnce the \"greetings\" module has been analyzed, what piece of that module is bound to sayHello?\n\nNotice that all of these questions depend on characteristics of the host—the system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack).\n\nThe ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn’t specify how the file lookup in (4), known as module resolution, happens, and it doesn’t say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There’s no single right answer, so the compiler must be told the rules through configuration options.\n\nThe other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of its output JavaScript files, not its input TypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn’t make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler’s options and behavior—it’s easier to start there and simplify when thinking about esbuild, Bun, and other TypeScript-first runtimes and bundlers. So for now, we can summarize TypeScript’s job when it comes to modules in terms of output files:\n\nUnderstand the rules of the host enough\n\nto compile files into a valid output module format,\nto ensure that imports in those outputs will resolve successfully, and\nto know what type to assign to imported names.\nWho is the host?\n\nBefore we move on, it’s worth making sure we’re on the same page about the term host, because it will come up frequently. We defined it before as “the system that ultimately consumes the output code to direct its module loading behavior.” In other words, it’s the system outside of TypeScript that TypeScript’s module analysis tries to model:\n\nWhen the output code (whether produced by tsc or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.\nWhen there is no “output code” because a runtime consumes TypeScript files directly, the runtime is still the host.\nWhen a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn’t know about anything that happens post-bundler.)\nIf another transpiler, optimizer, or formatter runs on TypeScript’s outputs, it’s not a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.\nWhen loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser’s JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.\nThe TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.\nThe module output format\n\nIn any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host only supports one kind of module—ESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions and package.json files to determine what format each file should be, and throws an error if the file’s contents don’t match the expected format.\n\nThe module compiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features like import.meta and top-level await are available. So, even if a TypeScript project is using noEmit, choosing the right setting for module still matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. See Choosing compiler options for guidance on choosing the right module setting for your project.\n\nThe available module settings are\n\nnode16: Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.\nnodenext: Currently identical to node16, but will be a moving target reflecting the latest Node.js versions as Node.js’s module system evolves.\nes2015: Reflects the ES2015 language specification for JavaScript modules (the version that first introduced import and export to the language).\nes2020: Adds support for import.meta and export * as ns from \"mod\" to es2015.\nes2022: Adds support for top-level await to es2020.\nesnext: Currently identical to es2022, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.\ncommonjs, system, amd, and umd: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.\n\nNode.js’s rules for module format detection and interoperability make it incorrect to specify module as esnext or commonjs for projects that run in Node.js, even if all files emitted by tsc are ESM or CJS, respectively. The only correct module settings for projects that intend to run in Node.js are node16 and nodenext. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations using esnext and nodenext, the type checking can differ. See the reference section on nodenext for more details.\n\nModule format detection\n\nNode.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and the type field of the first package.json file found in a search of the file’s directory and all ancestor directories:\n\n.mjs and .cjs files are always interpreted as ES modules and CJS modules, respectively.\n.js files are interpreted as ES modules if the nearest package.json file contains a type field with the value \"module\". If there is no package.json file, or if the type field is missing or has any other value, .js files are interpreted as CJS modules.\n\nIf a file is determined to be an ES module by these rules, Node.js will not inject the CommonJS module and require objects into the file’s scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module, import and export declarations in the file will cause a syntax error crash.\n\nWhen the module compiler option is set to node16 or nodenext, TypeScript applies this same algorithm to the project’s input files to determine the module kind of each corresponding output file. Let’s look at how module formats are detected in an example project that uses --module nodenext:\n\nInput file name\tContents\tOutput file name\tModule kind\tReason\n/package.json\t{}\t\t\t\n/main.mts\t\t/main.mjs\tESM\tFile extension\n/utils.cts\t\t/utils.cjs\tCJS\tFile extension\n/example.ts\t\t/example.js\tCJS\tNo \"type\": \"module\" in package.json\n/node_modules/pkg/package.json\t{ \"type\": \"module\" }\t\t\t\n/node_modules/pkg/index.d.ts\t\t\tESM\t\"type\": \"module\" in package.json\n/node_modules/pkg/index.d.cts\t\t\tCJS\tFile extension\n\nWhen the input file extension is .mts or .cts, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output .mjs file as an ES module or the output .cjs file as a CJS module. When the input file extension is .ts, TypeScript has to consult the nearest package.json file to determine the module format, because this is what Node.js will do when it encounters the output .js file. (Notice that the same rules apply to the .d.cts and .d.ts declaration files in the pkg dependency: though they will not produce an output file as part of this compilation, the presence of a .d.ts file implies the existence of a corresponding .js file—perhaps created when the author of the pkg library ran tsc on an input .ts file of their own—which Node.js must interpret as an ES module, due to its .js extension and the presence of the \"type\": \"module\" field in /node_modules/pkg/package.json. Declaration files are covered in more detail in a later section.)\n\nThe detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit /example.js with import and export statements in it, Node.js would crash when parsing the file. If TypeScript were to emit /main.mjs with require calls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we’ll discuss in the following sections.\n\nIt’s worth mentioning again that TypeScript’s behavior in --module node16 and --module nodenext is entirely motivated by Node.js’s behavior. Since TypeScript’s goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection is necessary for checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts.\n\nInput module syntax\n\nIt’s important to note that the input module syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:\n\nimport { sayHello } from \"greetings\";\nsayHello(\"world\");\n\nmight be emitted in ESM format exactly as-is, or might be emitted as CommonJS:\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst greetings_1 = require(\"greetings\");\n(0, greetings_1.sayHello)(\"world\");\n\ndepending on the module compiler option (and any applicable module format detection rules, if the module option supports more than one kind of module). In general, this means that looking at the contents of an input file isn’t enough to determine whether it’s an ES module or a CJS module.\n\nToday, most TypeScript files are authored using ESM syntax (import and export statements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspired import fs = require(\"fs\") syntax in the 1.5 release.\n\nThe upside of this “author ESM, output anything” strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:\n\nEarly assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.\nWhen the syntax in input files all looks like ESM, it’s easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js’s interoperability rules, what kind of module each file is became very important.\nWhen input files are written in ESM, the syntax in type declaration outputs (.d.ts files) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can’t tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScript has to know what kind of module everything is in order to provide correct types and prevent imports that will crash.\n\nIn TypeScript 5.0, a new compiler option called verbatimModuleSyntax was introduced to help TypeScript authors know exactly how their import and export statements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (import fs = require(\"fs\") and export = {}). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future.\n\nESM and CJS interoperability\n\nCan an ES module import a CommonJS module? If so, does a default import link to exports or exports.default? Can a CommonJS module require an ES module? CommonJS isn’t part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:\n\nESM-only. Some runtimes, like browser engines, only support what’s actually a part of the language: ECMAScript Modules.\nBundler-like. Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.\nNode.js. In Node.js, CommonJS modules cannot load ES modules synchronously (with require); they can only load them asynchronously with dynamic import() calls. ES modules can default-import CJS modules, which always binds to exports. (This means that a default import of a Babel-like CJS output with __esModule behaves differently between Node.js and some bundlers.)\n\nTypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularly default) imports and to error on imports that will crash at runtime. When the module compiler option is set to node16 or nodenext, Node.js’s rules are enforced. All other module settings, combined with the esModuleInterop option, result in bundler-like interop in TypeScript. (While using --module esnext does prevent you from writing CommonJS modules, it does not prevent you from importing them as dependencies. There’s currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)\n\nModule specifiers are not transformed\n\nWhile the module compiler option can transform imports and exports in input files to different module formats in output files, the module specifier (the string from which you import, or pass to require) is always emitted as-written. For example, an input like:\n\nimport { add } from \"./math.mjs\";\nadd(1, 2);\n\nmight be emitted as either:\n\nimport { add } from \"./math.mjs\";\nadd(1, 2);\n\nor:\n\nconst math_1 = require(\"./math.mjs\");\nmath_1.add(1, 2);\n\ndepending on the module compiler option, but the module specifier will always be \"./math.mjs\". There is no compiler option that enables transforming, substituting, or rewriting module specifiers. Consequently, module specifiers must be written in a way that works for the code’s target runtime or bundler, and it’s TypeScript’s job to understand those output-relative specifiers. The process of finding the file referenced by a module specifier is called module resolution.\n\nModule resolution\n\nLet’s return to our first example and review what we’ve learned about it so far:\n\nimport sayHello from \"greetings\";\nsayHello(\"world\");\n\nSo far, we’ve discussed how the host’s module system and TypeScript’s module compiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on the module compiler option, potentially the file extension, and package.json \"type\" field. We also know that what sayHello gets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven’t yet discussed how to find the target file.\n\nModule resolution is host-defined\n\nWhile the ECMAScript specification defines how to parse and interpret import and export statements, it leaves module resolution up to the host. If you’re creating a hot new JavaScript runtime, you’re free to create a module resolution scheme like:\n\nimport monkey from \"🐒\"; // Looks for './eats/bananas.js'\nimport cow from \"🐄\";    // Looks for './eats/grass.js'\nimport lion from \"🦁\";   // Looks for './eats/you.js'\n\nand still claim to implement “standards-compliant ESM.” Needless to say, TypeScript would have no idea what types to assign to monkey, cow, and lion without built-in knowledge of this runtime’s module resolution algorithm. Just as module informs the compiler about the host’s expected module format, moduleResolution, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn’t modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host.\n\nThe available moduleResolution options are:\n\nclassic: TypeScript’s oldest module resolution mode, this is unfortunately the default when module is set to anything other than commonjs, node16, or nodenext. It was probably made to provide best-effort resolution for a wide range of RequireJS configurations. It should not be used for new projects (or even old projects that don’t use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.\nnode10: Formerly known as node, this is the unfortunate default when module is set to commonjs. It’s a pretty good model of Node.js versions older than v12, and sometimes it’s a passable approximation of how most bundlers do module resolution. It supports looking up packages from node_modules, loading directory index.js files, and omitting .js extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it’s a very bad model of modern versions of Node.js. It should not be used for new projects.\nnode16: This is the counterpart of --module node16 and is set by default with that module setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic import() calls are not allowed to omit file extensions or /index.js suffixes, while module specifiers in require calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the module format detection rules instated by --module node16. (For node16 and nodenext, module and moduleResolution go hand-in-hand: setting one to node16 or nodenext while setting the other to something else has unsupported behavior and may be an error in the future.)\nnodenext: Currently identical to node16, this is the counterpart of --module nodenext and is set by default with that module setting. It’s intended to be a forward-looking mode that will support new Node.js module resolution features as they’re added.\nbundler: Node.js v12 introduced some new module resolution features for importing npm packages—the \"exports\" and \"imports\" fields of package.json—and many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports package.json \"exports\" and \"imports\" by default, but can be configured to ignore them. It requires setting module to esnext.\nTypeScript imitates the host’s module resolution, but with types\n\nRemember the three components of TypeScript’s job concerning modules?\n\nCompile files into a valid output module format\nEnsure that imports in those outputs will resolve successfully\nKnow what type to assign to imported names.\n\nModule resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)—that a key component of module resolution is validating that the imports or require calls in the output files, containing the same module specifiers as the input files, will actually work at runtime. Let’s look at a new example with multiple files:\n\n// @Filename: math.ts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n// @Filename: main.ts\nimport { add } from \"./math\";\nadd(1, 2);\n\nWhen we see the import from \"./math\", it might be tempting to think, “This is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type to add.”\n\nThis isn’t entirely wrong, but the reality is deeper. The resolution of \"./math\" (and subsequently, the type of add) need to reflect the reality of what happens at runtime to the output files. A more robust way to think about this process would look like this:\n\nThis model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host’s module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let’s look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:\n\n// @moduleResolution: node16\n// @rootDir: src\n// @outDir: dist\n// @Filename: src/math.mts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n// @Filename: src/main.mts\nimport { add } from \"./math.mjs\";\nadd(1, 2);\n\nNode.js ESM import declarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it’s a little strange that \"./math.mjs\" seems to resolve to math.mts. Since we’re using an outDir to put compiled outputs in a different directory, math.mjs doesn’t even exist next to main.mts! Why should this resolve? With our new mental model, it’s no problem:\n\nUnderstanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it’s natural to think in terms of shortcuts: \"./math.mjs\" refers to the input file math.mts. I have to write the output extension, but the compiler knows to look for .mts when I write .mjs. This shortcut is even how the compiler works internally, but the more robust mental model explains why module resolution in TypeScript works this way: given the constraint that the module specifier in the output file will be the same as the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types.\n\nThe role of declaration files\n\nIn the previous example, we saw the “remapping” part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can’t rely on mapping the library’s JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types?\n\nThis is where declaration files (.d.ts, .d.mts, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you run tsc --declaration on an input file, you get one output JavaScript file and one output declaration file:\n\nBecause of this relationship, the compiler assumes that wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn’t continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript file will exist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else’s) already happened and created a JavaScript file at the same time as the declaration file.\n\nThe declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:\n\nDeclaration file extension\tJavaScript file extension\tTypeScript file extension\n.d.ts\t.js\t.ts\n.d.ts\t.js\t.tsx\n.d.mts\t.mjs\t.mts\n.d.cts\t.cjs\t.cts\n.d.*.ts\t.*\t\n\nThe last row expresses that non-JS files can be typed with the allowArbitraryExtensions compiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file named styles.css can be represented by a declaration file named styles.d.css.ts.\n\n“But wait! Plenty of declaration files are written by hand, not generated by tsc. Ever heard of DefinitelyTyped?” you might object. And it’s true—hand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not using tsc to generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package @arethetypeswrong/cli can help catch and explain these errors before they’re published.\n\nModule resolution for bundlers, TypeScript runtimes, and Node.js loaders\n\nSo far, we’ve really emphasized the distinction between input files and output files. Recall that when specifying a file extension on a relative module specifier, TypeScript typically makes you use the output file extension:\n\n// @Filename: src/math.ts\nexport function add(a: number, b: number) {\n  return a + b;\n}\n// @Filename: src/main.ts\nimport { add } from \"./math.ts\";\n//                  ^^^^^^^^^^^\n// An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.\n\nThis restriction applies since TypeScript won’t rewrite the extension to .js, and if \"./math.ts\" appears in an output JS file, that import won’t resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if there is no output JS file? What if you’re in one of these situations:\n\nYou’re bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you’ve written to produce a bundle.\nYou’re running this code directly in a TypeScript runtime like Deno or Bun.\nYou’re using ts-node, tsx, or another transpiling loader for Node.\n\nIn these cases, you can turn on noEmit (or emitDeclarationOnly) and allowImportingTsExtensions to disable emitting unsafe JavaScript files and silence the error on .ts-extensioned imports.\n\nWith or without allowImportingTsExtensions, it’s still important to pick the most appropriate moduleResolution setting for the module resolution host. For bundlers and the Bun runtime, it’s bundler. These module resolvers were inspired by Node.js, but didn’t adopt the strict ESM resolution algorithm that disables extension searching that Node.js applies to imports. The bundler module resolution setting reflects this, enabling package.json \"exports\" support like node16 and nodenext, while always allowing extensionless imports. See Choosing compiler options for more guidance.\n\nModule resolution for libraries\n\nWhen compiling an app, you choose the moduleResolution option for a TypeScript project based on who the module resolution host is. When compiling a library, you don’t know where the output code will run, but you’d like it to run in as many places as possible. Using \"module\": \"nodenext\" (along with the implied \"moduleResolution\": \"nodenext\") is the best bet for maximizing the compatibility of the output JavaScript’s module specifiers, since it will force you to comply with Node.js’s stricter rules for import module resolution. Let’s look at what would happen if a library were to compile with \"moduleResolution\": \"bundler\" (or worse, \"node10\"):\n\nexport * from \"./utils\";\n\nAssuming ./utils.ts (or ./utils/index.ts) exists, a bundler would be fine with this code, so \"moduleResolution\": \"bundler\" doesn’t complain. Compiled with \"module\": \"esnext\", the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:\n\nError [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js\nDid you mean to import ./utils.js?\n\nOn the other hand, if we had written:\n\nexport * from \"./utils.js\";\n\nThis would produce output that works both in Node.js and in bundlers.\n\nIn short, \"moduleResolution\": \"bundler\" is infectious, allowing code that only works in bundlers to be produced. Likewise, \"moduleResolution\": \"nodenext\" is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.\n\nOf course, this guidance can only apply in cases where the library ships outputs from tsc. If the library is being bundled before shipping, \"moduleResolution\": \"bundler\" may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product’s module code, and tsc can no longer contribute to that task, since it can’t know what module code will exist at runtime.\n\nOn this page\nScripts and modules in JavaScript\nTypeScript’s job concerning modules\nWho is the host?\nThe module output format\nModule format detection\nInput module syntax\nESM and CJS interoperability\nModule specifiers are not transformed\nModule resolution\nModule resolution is host-defined\nTypeScript imitates the host’s module resolution, but with types\nThe role of declaration files\nModule resolution for bundlers, TypeScript runtimes, and Node.js loaders\nModule resolution for libraries\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.324 seconds."
  },
  {
    "title": "TypeScript: Documentation - Modules - Introduction",
    "url": "https://www.typescriptlang.org/docs/handbook/modules/introduction.html",
    "html": "Modules - Introduction\n\nThis document is divided into four sections:\n\nThe first section develops the theory behind how TypeScript approaches modules. If you want to be able to write the correct module-related compiler options for any situation, reason about how to integrate TypeScript with other tools, or understand how TypeScript processes dependency packages, this is the place to start. While there are guides and reference pages on these topics, building an understanding of these fundamentals will make reading the guides easier, and give you a mental framework for dealing with real-world problems not specifically covered here.\nThe guides show how to accomplish specific real-world tasks, starting with picking the right compilation settings for a new project. The guides are a good place to start both for beginners who want to get up and running as quickly as possible and for experts who already have a good grasp of the theory but want concrete guidance on a complicated task.\nThe reference section provides a more detailed look at the syntaxes and configurations presented in previous sections.\nThe appendices cover complicated topics that deserve additional explanation in more detail than the theory or reference sections allow.\nOn this page\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nAB\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.253 seconds."
  },
  {
    "title": "TypeScript: Documentation - Variable Declaration",
    "url": "https://www.typescriptlang.org/docs/handbook/variable-declarations.html",
    "html": "Variable Declaration\n\nlet and const are two relatively new concepts for variable declarations in JavaScript. As we mentioned earlier, let is similar to var in some respects, but allows users to avoid some of the common “gotchas” that users run into in JavaScript.\n\nconst is an augmentation of let in that it prevents re-assignment to a variable.\n\nWith TypeScript being an extension of JavaScript, the language naturally supports let and const. Here we’ll elaborate more on these new declarations and why they’re preferable to var.\n\nIf you’ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you’re intimately familiar with all the quirks of var declarations in JavaScript, you might find it easier to skip ahead.\n\nvar\n declarations\n\nDeclaring a variable in JavaScript has always traditionally been done with the var keyword.\n\nvar a = 10;\n\nAs you might’ve figured out, we just declared a variable named a with the value 10.\n\nWe can also declare a variable inside of a function:\n\nfunction f() {\n  var message = \"Hello, world!\";\n  return message;\n}\n\nand we can also access those same variables within other functions:\n\nfunction f() {\n  var a = 10;\n  return function g() {\n    var b = a + 1;\n    return b;\n  };\n}\nvar g = f();\ng(); // returns '11'\n\nIn this above example, g captured the variable a declared in f. At any point that g gets called, the value of a will be tied to the value of a in f. Even if g is called once f is done running, it will be able to access and modify a.\n\nfunction f() {\n  var a = 1;\n  a = 2;\n  var b = g();\n  a = 3;\n  return b;\n  function g() {\n    return a;\n  }\n}\nf(); // returns '2'\nScoping rules\n\nvar declarations have some odd scoping rules for those used to other languages. Take the following example:\n\nfunction f(shouldInitialize: boolean) {\n  if (shouldInitialize) {\n    var x = 10;\n  }\n  return x;\n}\nf(true); // returns '10'\nf(false); // returns 'undefined'\n\nSome readers might do a double-take at this example. The variable x was declared within the if block, and yet we were able to access it from outside that block. That’s because var declarations are accessible anywhere within their containing function, module, namespace, or global scope - all which we’ll go over later on - regardless of the containing block. Some people call this var-scoping or function-scoping. Parameters are also function scoped.\n\nThese scoping rules can cause several types of mistakes. One problem they exacerbate is the fact that it is not an error to declare the same variable multiple times:\n\nfunction sumMatrix(matrix: number[][]) {\n  var sum = 0;\n  for (var i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (var i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n\nMaybe it was easy to spot out for some experienced JavaScript developers, but the inner for-loop will accidentally overwrite the variable i because i refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.\n\nVariable capturing quirks\n\nTake a quick second to guess what the output of the following snippet is:\n\nfor (var i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n\nFor those unfamiliar, setTimeout will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).\n\nReady? Take a look:\n\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n\nMany JavaScript developers are intimately familiar with this behavior, but if you’re surprised, you’re certainly not alone. Most people expect the output to be\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\nRemember what we mentioned earlier about variable capturing? Every function expression we pass to setTimeout actually refers to the same i from the same scope.\n\nLet’s take a minute to consider what that means. setTimeout will run a function after some number of milliseconds, but only after the for loop has stopped executing; By the time the for loop has stopped executing, the value of i is 10. So each time the given function gets called, it will print out 10!\n\nA common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture i at each iteration:\n\nfor (var i = 0; i < 10; i++) {\n  // capture the current state of 'i'\n  // by invoking a function with its current value\n  (function (i) {\n    setTimeout(function () {\n      console.log(i);\n    }, 100 * i);\n  })(i);\n}\n\nThis odd-looking pattern is actually pretty common. The i in the parameter list actually shadows the i declared in the for loop, but since we named them the same, we didn’t have to modify the loop body too much.\n\nlet\n declarations\n\nBy now you’ve figured out that var has some problems, which is precisely why let statements were introduced. Apart from the keyword used, let statements are written the same way var statements are.\n\nlet hello = \"Hello!\";\n\nThe key difference is not in the syntax, but in the semantics, which we’ll now dive into.\n\nBlock-scoping\n\nWhen a variable is declared using let, it uses what some call lexical-scoping or block-scoping. Unlike variables declared with var whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or for-loop.\n\nfunction f(input: boolean) {\n  let a = 100;\n  if (input) {\n    // Still okay to reference 'a'\n    let b = a + 1;\n    return b;\n  }\n  // Error: 'b' doesn't exist here\n  return b;\n}\n\nHere, we have two local variables a and b. a’s scope is limited to the body of f while b’s scope is limited to the containing if statement’s block.\n\nVariables declared in a catch clause also have similar scoping rules.\n\ntry {\n  throw \"oh no!\";\n} catch (e) {\n  console.log(\"Oh well.\");\n}\n// Error: 'e' doesn't exist here\nconsole.log(e);\n\nAnother property of block-scoped variables is that they can’t be read or written to before they’re actually declared. While these variables are “present” throughout their scope, all points up until their declaration are part of their temporal dead zone. This is just a sophisticated way of saying you can’t access them before the let statement, and luckily TypeScript will let you know that.\n\na++; // illegal to use 'a' before it's declared;\nlet a;\n\nSomething to note is that you can still capture a block-scoped variable before it’s declared. The only catch is that it’s illegal to call that function before the declaration. If targeting ES2015, a modern runtime will throw an error; however, right now TypeScript is permissive and won’t report this as an error.\n\nfunction foo() {\n  // okay to capture 'a'\n  return a;\n}\n// illegal call 'foo' before 'a' is declared\n// runtimes should throw an error here\nfoo();\nlet a;\n\nFor more information on temporal dead zones, see relevant content on the Mozilla Developer Network.\n\nRe-declarations and Shadowing\n\nWith var declarations, we mentioned that it didn’t matter how many times you declared your variables; you just got one.\n\nfunction f(x) {\n  var x;\n  var x;\n  if (true) {\n    var x;\n  }\n}\n\nIn the above example, all declarations of x actually refer to the same x, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, let declarations are not as forgiving.\n\nlet x = 10;\nlet x = 20; // error: can't re-declare 'x' in the same scope\n\nThe variables don’t necessarily need to both be block-scoped for TypeScript to tell us that there’s a problem.\n\nfunction f(x) {\n  let x = 100; // error: interferes with parameter declaration\n}\nfunction g() {\n  let x = 100;\n  var x = 100; // error: can't have both declarations of 'x'\n}\n\nThat’s not to say that a block-scoped variable can never be declared with a function-scoped variable. The block-scoped variable just needs to be declared within a distinctly different block.\n\nfunction f(condition, x) {\n  if (condition) {\n    let x = 100;\n    return x;\n  }\n  return x;\n}\nf(false, 0); // returns '0'\nf(true, 0); // returns '100'\n\nThe act of introducing a new name in a more nested scope is called shadowing. It is a bit of a double-edged sword in that it can introduce certain bugs on its own in the event of accidental shadowing, while also preventing certain bugs. For instance, imagine we had written our earlier sumMatrix function using let variables.\n\nfunction sumMatrix(matrix: number[][]) {\n  let sum = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    var currentRow = matrix[i];\n    for (let i = 0; i < currentRow.length; i++) {\n      sum += currentRow[i];\n    }\n  }\n  return sum;\n}\n\nThis version of the loop will actually perform the summation correctly because the inner loop’s i shadows i from the outer loop.\n\nShadowing should usually be avoided in the interest of writing clearer code. While there are some scenarios where it may be fitting to take advantage of it, you should use your best judgement.\n\nBlock-scoped variable capturing\n\nWhen we first touched on the idea of variable capturing with var declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an “environment” of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.\n\nfunction theCityThatAlwaysSleeps() {\n  let getCity;\n  if (true) {\n    let city = \"Seattle\";\n    getCity = function () {\n      return city;\n    };\n  }\n  return getCity();\n}\n\nBecause we’ve captured city from within its environment, we’re still able to access it despite the fact that the if block finished executing.\n\nRecall that with our earlier setTimeout example, we ended up needing to use an IIFE to capture the state of a variable for every iteration of the for loop. In effect, what we were doing was creating a new variable environment for our captured variables. That was a bit of a pain, but luckily, you’ll never have to do that again in TypeScript.\n\nlet declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope per iteration. Since this is what we were doing anyway with our IIFE, we can change our old setTimeout example to just use a let declaration.\n\nfor (let i = 0; i < 10; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 100 * i);\n}\n\nand as expected, this will print out\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\nconst\n declarations\n\nconst declarations are another way of declaring variables.\n\nconst numLivesForCat = 9;\n\nThey are like let declarations but, as their name implies, their value cannot be changed once they are bound. In other words, they have the same scoping rules as let, but you can’t re-assign to them.\n\nThis should not be confused with the idea that the values they refer to are immutable.\n\nconst numLivesForCat = 9;\nconst kitty = {\n  name: \"Aurora\",\n  numLives: numLivesForCat,\n};\n// Error\nkitty = {\n  name: \"Danielle\",\n  numLives: numLivesForCat,\n};\n// all \"okay\"\nkitty.name = \"Rory\";\nkitty.name = \"Kitty\";\nkitty.name = \"Cat\";\nkitty.numLives--;\n\nUnless you take specific measures to avoid it, the internal state of a const variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are readonly. The chapter on Interfaces has the details.\n\nlet\n vs. \nconst\n\nGiven that we have two types of declarations with similar scoping semantics, it’s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.\n\nApplying the principle of least privilege, all declarations other than those you plan to modify should use const. The rationale is that if a variable didn’t need to get written to, others working on the same codebase shouldn’t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using const also makes code more predictable when reasoning about flow of data.\n\nUse your best judgement, and if applicable, consult the matter with the rest of your team.\n\nThe majority of this handbook uses let declarations.\n\nDestructuring\n\nAnother ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see the article on the Mozilla Developer Network. In this section, we’ll give a short overview.\n\nArray destructuring\n\nThe simplest form of destructuring is array destructuring assignment:\n\nlet input = [1, 2];\nlet [first, second] = input;\nconsole.log(first); // outputs 1\nconsole.log(second); // outputs 2\n\nThis creates two new variables named first and second. This is equivalent to using indexing, but is much more convenient:\n\nfirst = input[0];\nsecond = input[1];\n\nDestructuring works with already-declared variables as well:\n\n// swap variables\n[first, second] = [second, first];\n\nAnd with parameters to a function:\n\nfunction f([first, second]: [number, number]) {\n  console.log(first);\n  console.log(second);\n}\nf([1, 2]);\n\nYou can create a variable for the remaining items in a list using the syntax ...:\n\nlet [first, ...rest] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\nconsole.log(rest); // outputs [ 2, 3, 4 ]\n\nOf course, since this is JavaScript, you can just ignore trailing elements you don’t care about:\n\nlet [first] = [1, 2, 3, 4];\nconsole.log(first); // outputs 1\n\nOr other elements:\n\nlet [, second, , fourth] = [1, 2, 3, 4];\nconsole.log(second); // outputs 2\nconsole.log(fourth); // outputs 4\nTuple destructuring\n\nTuples may be destructured like arrays; the destructuring variables get the types of the corresponding tuple elements:\n\nlet tuple: [number, string, boolean] = [7, \"hello\", true];\nlet [a, b, c] = tuple; // a: number, b: string, c: boolean\n\nIt’s an error to destructure a tuple beyond the range of its elements:\n\nlet [a, b, c, d] = tuple; // Error, no element at index 3\n\nAs with arrays, you can destructure the rest of the tuple with ..., to get a shorter tuple:\n\nlet [a, ...bc] = tuple; // bc: [string, boolean]\nlet [a, b, c, ...d] = tuple; // d: [], the empty tuple\n\nOr ignore trailing elements, or other elements:\n\nlet [a] = tuple; // a: number\nlet [, b] = tuple; // b: string\nObject destructuring\n\nYou can also destructure objects:\n\nlet o = {\n  a: \"foo\",\n  b: 12,\n  c: \"bar\",\n};\nlet { a, b } = o;\n\nThis creates new variables a and b from o.a and o.b. Notice that you can skip c if you don’t need it.\n\nLike array destructuring, you can have assignment without declaration:\n\n({ a, b } = { a: \"baz\", b: 101 });\n\nNotice that we had to surround this statement with parentheses. JavaScript normally parses a { as the start of block.\n\nYou can create a variable for the remaining items in an object using the syntax ...:\n\nlet { a, ...passthrough } = o;\nlet total = passthrough.b + passthrough.c.length;\nProperty renaming\n\nYou can also give different names to properties:\n\nlet { a: newName1, b: newName2 } = o;\n\nHere the syntax starts to get confusing. You can read a: newName1 as ”a as newName1”. The direction is left-to-right, as if you had written:\n\nlet newName1 = o.a;\nlet newName2 = o.b;\n\nConfusingly, the colon here does not indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:\n\nlet { a: newName1, b: newName2 }: { a: string; b: number } = o;\nDefault values\n\nDefault values let you specify a default value in case a property is undefined:\n\nfunction keepWholeObject(wholeObject: { a: string; b?: number }) {\n  let { a, b = 1001 } = wholeObject;\n}\n\nIn this example the b? indicates that b is optional, so it may be undefined. keepWholeObject now has a variable for wholeObject as well as the properties a and b, even if b is undefined.\n\nFunction declarations\n\nDestructuring also works in function declarations. For simple cases this is straightforward:\n\ntype C = { a: string; b?: number };\nfunction f({ a, b }: C): void {\n  // ...\n}\n\nBut specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.\n\nfunction f({ a = \"\", b = 0 } = {}): void {\n  // ...\n}\nf();\n\nThe snippet above is an example of type inference, explained earlier in the handbook.\n\nThen, you need to remember to give a default for optional properties on the destructured property instead of the main initializer. Remember that C was defined with b optional:\n\nfunction f({ a, b = 0 } = { a: \"\" }): void {\n  // ...\n}\nf({ a: \"yes\" }); // ok, default b = 0\nf(); // ok, default to { a: \"\" }, which then defaults b = 0\nf({}); // error, 'a' is required if you supply an argument\n\nUse destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets really hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.\n\nSpread\n\nThe spread operator is the opposite of destructuring. It allows you to spread an array into another array, or an object into another object. For example:\n\nlet first = [1, 2];\nlet second = [3, 4];\nlet bothPlus = [0, ...first, ...second, 5];\n\nThis gives bothPlus the value [0, 1, 2, 3, 4, 5]. Spreading creates a shallow copy of first and second. They are not changed by the spread.\n\nYou can also spread objects:\n\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { ...defaults, food: \"rich\" };\n\nNow search is { food: \"rich\", price: \"$$\", ambiance: \"noisy\" }. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:\n\nlet defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };\nlet search = { food: \"rich\", ...defaults };\n\nThen the food property in defaults overwrites food: \"rich\", which is not what we want in this case.\n\nObject spread also has a couple of other surprising limits. First, it only includes an objects’ own, enumerable properties. Basically, that means you lose methods when you spread instances of an object:\n\nclass C {\n  p = 12;\n  m() {}\n}\nlet c = new C();\nlet clone = { ...c };\nclone.p; // ok\nclone.m(); // error!\n\nSecond, the TypeScript compiler doesn’t allow spreads of type parameters from generic functions. That feature is expected in future versions of the language.\n\nusing\n declarations\n\nusing declarations are an upcoming feature for JavaScript that are part of the Stage 3 Explicit Resource Management proposal. A using declaration is much like a const declaration, except that it couples the lifetime of the value bound to the declaration with the scope of the variable.\n\nWhen control exits the block containing a using declaration, the [Symbol.dispose]() method of the declared value is executed, which allows that value to perform cleanup:\n\nfunction f() {\n  using x = new C();\n  doSomethingWith(x);\n} // `x[Symbol.dispose]()` is called\n\nAt runtime, this has an effect roughly equivalent to the following:\n\nfunction f() {\n  const x = new C();\n  try {\n    doSomethingWith(x);\n  }\n  finally {\n    x[Symbol.dispose]();\n  }\n}\n\nusing declarations are extremely useful for avoiding memory leaks when working with JavaScript objects that hold on to native references like file handles\n\n{\n  using file = await openFile();\n  file.write(text);\n  doSomethingThatMayThrow();\n} // `file` is disposed, even if an error is thrown\n\nor scoped operations like tracing\n\nfunction f() {\n  using activity = new TraceActivity(\"f\"); // traces entry into function\n  // ...\n} // traces exit of function\n\nUnlike var, let, and const, using declarations do not support destructuring.\n\nnull\n and \nundefined\n\nIt’s important to note that the value can be null or undefined, in which case nothing is disposed at the end of the block:\n\n{\n  using x = b ? new C() : null;\n  // ...\n}\n\nwhich is roughly equivalent to:\n\n{\n  const x = b ? new C() : null;\n  try {\n    // ...\n  }\n  finally {\n    x?.[Symbol.dispose]();\n  }\n}\n\nThis allows you to conditionally acquire resources when declaring a using declaration without the need for complex branching or repetition.\n\nDefining a disposable resource\n\nYou can indicate the classes or objects you produce are disposable by implementing the Disposable interface:\n\n// from the default lib:\ninterface Disposable {\n  [Symbol.dispose](): void;\n}\n// usage:\nclass TraceActivity implements Disposable {\n  readonly name: string;\n  constructor(name: string) {\n    this.name = name;\n    console.log(`Entering: ${name}`);\n  }\n  [Symbol.dispose](): void {\n    console.log(`Exiting: ${name}`);\n  }\n}\nfunction f() {\n  using _activity = new TraceActivity(\"f\");\n  console.log(\"Hello world!\");\n}\nf();\n// prints:\n//   Entering: f\n//   Hello world!\n//   Exiting: f\nawait using\n declarations\n\nSome resources or operations may have cleanup that needs to be performed asynchronously. To accommodate this, the Explicit Resource Management proposal also introduces the await using declaration:\n\nasync function f() {\n  await using x = new C();\n} // `await x[Symbol.asyncDispose]()` is invoked\n\nAn await using declaration invokes, and awaits, its value’s [Symbol.asyncDispose]() method as control leaves the containing block. This allows for asynchronous cleanup, such as a database transaction performing a rollback or commit, or a file stream flushing any pending writes to storage before it is closed.\n\nAs with await, await using can only be used in an async function or method, or at the top level of a module.\n\nDefining an asynchronously disposable resource\n\nJust as using relies on objects that are Disposable, an await using relies on objects that are AsyncDisposable:\n\n// from the default lib:\ninterface AsyncDisposable {\n  [Symbol.asyncDispose]: PromiseLike<void>;\n}\n// usage:\nclass DatabaseTransaction implements AsyncDisposable {\n  public success = false;\n  private db: Database | undefined;\n  private constructor(db: Database) {\n    this.db = db;\n  }\n  static async create(db: Database) {\n    await db.execAsync(\"BEGIN TRANSACTION\");\n    return new DatabaseTransaction(db);\n  }\n  async [Symbol.asyncDispose]() {\n    if (this.db) {\n      const db = this.db:\n      this.db = undefined;\n      if (this.success) {\n        await db.execAsync(\"COMMIT TRANSACTION\");\n      }\n      else {\n        await db.execAsync(\"ROLLBACK TRANSACTION\");\n      }\n    }\n  }\n}\nasync function transfer(db: Database, account1: Account, account2: Account, amount: number) {\n  using tx = await DatabaseTransaction.create(db);\n  if (await debitAccount(db, account1, amount)) {\n    await creditAccount(db, account2, amount);\n  }\n  // if an exception is thrown before this line, the transaction will roll back\n  tx.success = true;\n  // now the transaction will commit\n}\nawait using\n vs \nawait\n\nThe await keyword that is part of the await using declaration only indicates that the disposal of the resource is await-ed. It does not await the value itself:\n\n{\n  await using x = getResourceSynchronously();\n} // performs `await x[Symbol.asyncDispose]()`\n{\n  await using y = await getResourceAsynchronously();\n} // performs `await y[Symbol.asyncDispose]()`\nawait using\n and \nreturn\n\nIt’s important to note that there is a small caveat with this behavior if you are using an await using declaration in an async function that returns a Promise without first await-ing it:\n\nfunction g() {\n  return Promise.reject(\"error!\");\n}\nasync function f() {\n  await using x = new C();\n  return g(); // missing an `await`\n}\n\nBecause the returned promise isn’t await-ed, it’s possible that the JavaScript runtime may report an unhandled rejection since execution pauses while await-ing the asynchronous disposal of x, without having subscribed to the returned promise. This is not a problem that is unique to await using, however, as this can also occur in an async function that uses try..finally:\n\nasync function f() {\n  try {\n    return g(); // also reports an unhandled rejection\n  }\n  finally {\n    await somethingElse();\n  }\n}\n\nTo avoid this situation, it is recommended that you await your return value if it may be a Promise:\n\nasync function f() {\n  await using x = new C();\n  return await g();\n}\nusing\n and \nawait using\n in \nfor\n and \nfor..of\n statements\n\nBoth using and await using can be used in a for statement:\n\nfor (using x = getReader(); !x.eof; x.next()) {\n  // ...\n}\n\nIn this case, the lifetime of x is scoped to the entire for statement and is only disposed when control leaves the loop due to break, return, throw, or when the loop condition is false.\n\nIn addition to for statements, both declarations can also be used in for..of statements:\n\nfunction * g() {\n  yield createResource1();\n  yield createResource2();\n}\nfor (using x of g()) {\n  // ...\n}\n\nHere, x is disposed at the end of each iteration of the loop, and is then reinitialized with the next value. This is especially useful when consuming resources produced one at a time by a generator.\n\nusing\n and \nawait using\n in older runtimes\n\nusing and await using declarations can be used when targeting older ECMAScript editions as long as you are using a compatible polyfill for Symbol.dispose/Symbol.asyncDispose, such as the one provided by default in recent editions of NodeJS.\n\nOn this page\nvar declarations\nScoping rules\nVariable capturing quirks\nlet declarations\nBlock-scoping\nRe-declarations and Shadowing\nBlock-scoped variable capturing\nconst declarations\nlet vs. const\nDestructuring\nArray destructuring\nTuple destructuring\nObject destructuring\nFunction declarations\nSpread\nusing declarations\nnull and undefined\nDefining a disposable resource\nawait using declarations\nDefining an asynchronously disposable resource\nawait using vs await\nawait using and return\nusing and await using in for and for..of statements\nusing and await using in older runtimes\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nNS\nVR\nBC\n24+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.37 seconds."
  },
  {
    "title": "TypeScript: Documentation - Type Inference",
    "url": "https://www.typescriptlang.org/docs/handbook/type-inference.html",
    "html": "Type Inference\n\nIn TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code\n\nlet x = 3;\n   \nlet x: number\nTry\n\nThe type of the x variable is inferred to be number. This kind of inference takes place when initializing variables and members, setting parameter default values, and determining function return types.\n\nIn most cases, type inference is straightforward. In the following sections, we’ll explore some of the nuances in how types are inferred.\n\nBest common type\n\nWhen a type inference is made from several expressions, the types of those expressions are used to calculate a “best common type”. For example,\n\nlet x = [0, 1, null];\n   \nlet x: (number | null)[]\nTry\n\nTo infer the type of x in the example above, we must consider the type of each array element. Here we are given two choices for the type of the array: number and null. The best common type algorithm considers each candidate type, and picks the type that is compatible with all the other candidates.\n\nBecause the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:\n\nlet zoo = [new Rhino(), new Elephant(), new Snake()];\n    \nlet zoo: (Rhino | Elephant | Snake)[]\nTry\n\nIdeally, we may want zoo to be inferred as an Animal[], but because there is no object that is strictly of type Animal in the array, we make no inference about the array element type. To correct this, explicitly provide the type when no one type is a super type of all other candidates:\n\nlet zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()];\n    \nlet zoo: Animal[]\nTry\n\nWhen no best common type is found, the resulting inference is the union array type, (Rhino | Elephant | Snake)[].\n\nContextual Typing\n\nType inference also works in “the other direction” in some cases in TypeScript. This is known as “contextual typing”. Contextual typing occurs when the type of an expression is implied by its location. For example:\n\nwindow.onmousedown = function (mouseEvent) {\n  console.log(mouseEvent.button);\n  console.log(mouseEvent.kangaroo);\nProperty 'kangaroo' does not exist on type 'MouseEvent'.\nProperty 'kangaroo' does not exist on type 'MouseEvent'.\n};\nTry\n\nHere, the TypeScript type checker used the type of the Window.onmousedown function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the type of the mouseEvent parameter, which does contain a button property, but not a kangaroo property.\n\nThis works because window already has onmousedown declared in its type:\n\n// Declares there is a global variable called 'window'\ndeclare var window: Window & typeof globalThis;\n// Which is declared as (simplified):\ninterface Window extends GlobalEventHandlers {\n  // ...\n}\n// Which defines a lot of known handler events\ninterface GlobalEventHandlers {\n  onmousedown: ((this: GlobalEventHandlers, ev: MouseEvent) => any) | null;\n  // ...\n}\n\nTypeScript is smart enough to infer types in other contexts as well:\n\nwindow.onscroll = function (uiEvent) {\n  console.log(uiEvent.button);\nProperty 'button' does not exist on type 'Event'.\nProperty 'button' does not exist on type 'Event'.\n};\nTry\n\nBased on the fact that the above function is being assigned to Window.onscroll, TypeScript knows that uiEvent is a UIEvent, and not a MouseEvent like the previous example. UIEvent objects contain no button property, and so TypeScript will throw an error.\n\nIf this function were not in a contextually typed position, the function’s argument would implicitly have type any, and no error would be issued (unless you are using the noImplicitAny option):\n\nconst handler = function (uiEvent) {\n  console.log(uiEvent.button); // <- OK\n};\nTry\n\nWe can also explicitly give type information to the function’s argument to override any contextual type:\n\nwindow.onscroll = function (uiEvent: any) {\n  console.log(uiEvent.button); // <- Now, no error is given\n};\nTry\n\nHowever, this code will log undefined, since uiEvent has no property called button.\n\nContextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:\n\nfunction createZoo(): Animal[] {\n  return [new Rhino(), new Elephant(), new Snake()];\n}\nTry\n\nIn this example, best common type has a set of four candidates: Animal, Rhino, Elephant, and Snake. Of these, Animal can be chosen by the best common type algorithm.\n\nOn this page\nBest common type\nContextual Typing\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nRC\nOT\nDR\nMH\nTLAT\n12+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.307 seconds."
  },
  {
    "title": "TypeScript: Documentation - Type Compatibility",
    "url": "https://www.typescriptlang.org/docs/handbook/type-compatibility.html",
    "html": "Type Compatibility\n\nType compatibility in TypeScript is based on structural subtyping. Structural typing is a way of relating types based solely on their members. This is in contrast with nominal typing. Consider the following code:\n\ninterface Pet {\n  name: string;\n}\nclass Dog {\n  name: string;\n}\nlet pet: Pet;\n// OK, because of structural typing\npet = new Dog();\n\nIn nominally-typed languages like C# or Java, the equivalent code would be an error because the Dog class does not explicitly describe itself as being an implementer of the Pet interface.\n\nTypeScript’s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it’s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.\n\nA Note on Soundness\n\nTypeScript’s type system allows certain operations that can’t be known at compile-time to be safe. When a type system has this property, it is said to not be “sound”. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we’ll explain where these happen and the motivating scenarios behind them.\n\nStarting out\n\nThe basic rule for TypeScript’s structural type system is that x is compatible with y if y has at least the same members as x. For example consider the following code involving an interface named Pet which has a name property:\n\ninterface Pet {\n  name: string;\n}\nlet pet: Pet;\n// dog's inferred type is { name: string; owner: string; }\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\npet = dog;\n\nTo check whether dog can be assigned to pet, the compiler checks each property of pet to find a corresponding compatible property in dog. In this case, dog must have a member called name that is a string. It does, so the assignment is allowed.\n\nThe same rule for assignment is used when checking function call arguments:\n\ninterface Pet {\n  name: string;\n}\nlet dog = { name: \"Lassie\", owner: \"Rudd Weatherwax\" };\nfunction greet(pet: Pet) {\n  console.log(\"Hello, \" + pet.name);\n}\ngreet(dog); // OK\n\nNote that dog has an extra owner property, but this does not create an error. Only members of the target type (Pet in this case) are considered when checking for compatibility. This comparison process proceeds recursively, exploring the type of each member and sub-member.\n\nBe aware, however, that object literals may only specify known properties. For example, because we have explicitly specified that dog is of type Pet, the following code is invalid:\n\nlet dog: Pet = { name: \"Lassie\", owner: \"Rudd Weatherwax\" }; // Error\nComparing two functions\n\nWhile comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let’s start with a basic example of two functions that differ only in their parameter lists:\n\nlet x = (a: number) => 0;\nlet y = (b: number, s: string) => 0;\ny = x; // OK\nx = y; // Error\n\nTo check if x is assignable to y, we first look at the parameter list. Each parameter in x must have a corresponding parameter in y with a compatible type. Note that the names of the parameters are not considered, only their types. In this case, every parameter of x has a corresponding compatible parameter in y, so the assignment is allowed.\n\nThe second assignment is an error, because y has a required second parameter that x does not have, so the assignment is disallowed.\n\nYou may be wondering why we allow ‘discarding’ parameters like in the example y = x. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, Array#forEach provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it’s very useful to provide a callback that only uses the first parameter:\n\nlet items = [1, 2, 3];\n// Don't force these extra parameters\nitems.forEach((item, index, array) => console.log(item));\n// Should be OK!\nitems.forEach((item) => console.log(item));\n\nNow let’s look at how return types are treated, using two functions that differ only by their return type:\n\nlet x = () => ({ name: \"Alice\" });\nlet y = () => ({ name: \"Alice\", location: \"Seattle\" });\nx = y; // OK\ny = x; // Error, because x() lacks a location property\n\nThe type system enforces that the source function’s return type be a subtype of the target type’s return type.\n\nFunction Parameter Bivariance\n\nWhen comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:\n\nenum EventType {\n  Mouse,\n  Keyboard,\n}\ninterface Event {\n  timestamp: number;\n}\ninterface MyMouseEvent extends Event {\n  x: number;\n  y: number;\n}\ninterface MyKeyEvent extends Event {\n  keyCode: number;\n}\nfunction listenEvent(eventType: EventType, handler: (n: Event) => void) {\n  /* ... */\n}\n// Unsound, but useful and common\nlistenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + \",\" + e.y));\n// Undesirable alternatives in presence of soundness\nlistenEvent(EventType.Mouse, (e: Event) =>\n  console.log((e as MyMouseEvent).x + \",\" + (e as MyMouseEvent).y)\n);\nlistenEvent(EventType.Mouse, ((e: MyMouseEvent) =>\n  console.log(e.x + \",\" + e.y)) as (e: Event) => void);\n// Still disallowed (clear error). Type safety enforced for wholly incompatible types\nlistenEvent(EventType.Mouse, (e: number) => console.log(e));\n\nYou can have TypeScript raise errors when this happens via the compiler flag strictFunctionTypes.\n\nOptional Parameters and Rest Parameters\n\nWhen comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.\n\nWhen a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.\n\nThis is unsound from a type system perspective, but from a runtime point of view the idea of an optional parameter is generally not well-enforced since passing undefined in that position is equivalent for most functions.\n\nThe motivating example is the common pattern of a function that takes a callback and invokes it with some predictable (to the programmer) but unknown (to the type system) number of arguments:\n\nfunction invokeLater(args: any[], callback: (...args: any[]) => void) {\n  /* ... Invoke callback with 'args' ... */\n}\n// Unsound - invokeLater \"might\" provide any number of arguments\ninvokeLater([1, 2], (x, y) => console.log(x + \", \" + y));\n// Confusing (x and y are actually required) and undiscoverable\ninvokeLater([1, 2], (x?, y?) => console.log(x + \", \" + y));\nFunctions with overloads\n\nWhen a function has overloads, each overload in the target type must be matched by a compatible signature on the source type. This ensures that the source function can be called in all the same cases as the target function.\n\nEnums\n\nEnums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,\n\nenum Status {\n  Ready,\n  Waiting,\n}\nenum Color {\n  Red,\n  Blue,\n  Green,\n}\nlet status = Status.Ready;\nstatus = Color.Green; // Error\nClasses\n\nClasses work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.\n\nclass Animal {\n  feet: number;\n  constructor(name: string, numFeet: number) {}\n}\nclass Size {\n  feet: number;\n  constructor(numFeet: number) {}\n}\nlet a: Animal;\nlet s: Size;\na = s; // OK\ns = a; // OK\nPrivate and protected members in classes\n\nPrivate and protected members in a class affect their compatibility. When an instance of a class is checked for compatibility, if the target type contains a private member, then the source type must also contain a private member that originated from the same class. Likewise, the same applies for an instance with a protected member. This allows a class to be assignment compatible with its super class, but not with classes from a different inheritance hierarchy which otherwise have the same shape.\n\nGenerics\n\nBecause TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,\n\ninterface Empty<T> {}\nlet x: Empty<number>;\nlet y: Empty<string>;\nx = y; // OK, because y matches structure of x\n\nIn the above, x and y are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to Empty<T> shows how this works:\n\ninterface NotEmpty<T> {\n  data: T;\n}\nlet x: NotEmpty<number>;\nlet y: NotEmpty<string>;\nx = y; // Error, because x and y are not compatible\n\nIn this way, a generic type that has its type arguments specified acts just like a non-generic type.\n\nFor generic types that do not have their type arguments specified, compatibility is checked by specifying any in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.\n\nFor example,\n\nlet identity = function <T>(x: T): T {\n  // ...\n};\nlet reverse = function <U>(y: U): U {\n  // ...\n};\nidentity = reverse; // OK, because (x: any) => any matches (y: any) => any\nAdvanced Topics\nSubtype vs Assignment\n\nSo far, we’ve used “compatible”, which is not a term defined in the language spec. In TypeScript, there are two kinds of compatibility: subtype and assignment. These differ only in that assignment extends subtype compatibility with rules to allow assignment to and from any, and to and from enum with corresponding numeric values.\n\nDifferent places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the implements and extends clauses.\n\nany\n, \nunknown\n, \nobject\n, \nvoid\n, \nundefined\n, \nnull\n, and \nnever\n assignability\n\nThe following table summarizes assignability between some abstract types. Rows indicate what each is assignable to, columns indicate what is assignable to them. A ”✓” indicates a combination that is compatible only when strictNullChecks is off.\n\n\tany\tunknown\tobject\tvoid\tundefined\tnull\tnever\nany →\t\t✓\t✓\t✓\t✓\t✓\t✕\nunknown →\t✓\t\t✕\t✕\t✕\t✕\t✕\nobject →\t✓\t✓\t\t✕\t✕\t✕\t✕\nvoid →\t✓\t✓\t✕\t\t✕\t✕\t✕\nundefined →\t✓\t✓\t✓\t✓\t\t✓\t✕\nnull →\t✓\t✓\t✓\t✓\t✓\t\t✕\nnever →\t✓\t✓\t✓\t✓\t✓\t✓\t\n\nReiterating The Basics:\n\nEverything is assignable to itself.\nany and unknown are the same in terms of what is assignable to them, different in that unknown is not assignable to anything except any.\nunknown and never are like inverses of each other. Everything is assignable to unknown, never is assignable to everything. Nothing is assignable to never, unknown is not assignable to anything (except any).\nvoid is not assignable to or from anything, with the following exceptions: any, unknown, never, undefined, and null (if strictNullChecks is off, see table for details).\nWhen strictNullChecks is off, null and undefined are similar to never: assignable to most types, most types are not assignable to them. They are assignable to each other.\nWhen strictNullChecks is on, null and undefined behave more like void: not assignable to or from anything, except for any, unknown, never, and void (undefined is always assignable to void).\nOn this page\nA Note on Soundness\nStarting out\nComparing two functions\nFunction Parameter Bivariance\nOptional Parameters and Rest Parameters\nFunctions with overloads\nEnums\nClasses\nPrivate and protected members in classes\nGenerics\nAdvanced Topics\nSubtype vs Assignment\nany, unknown, object, void, undefined, null, and never assignability\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nRC\nDR\nOT\nMH\nJB\n25+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.271 seconds."
  },
  {
    "title": "TypeScript: Documentation - Triple-Slash Directives",
    "url": "https://www.typescriptlang.org/docs/handbook/triple-slash-directives.html",
    "html": "Triple-Slash Directives\n\nTriple-slash directives are single-line comments containing a single XML tag. The contents of the comment are used as compiler directives.\n\nTriple-slash directives are only valid at the top of their containing file. A triple-slash directive can only be preceded by single or multi-line comments, including other triple-slash directives. If they are encountered following a statement or a declaration they are treated as regular single-line comments, and hold no special meaning.\n\n/// <reference path=\"...\" />\n\nThe /// <reference path=\"...\" /> directive is the most common of this group. It serves as a declaration of dependency between files.\n\nTriple-slash references instruct the compiler to include additional files in the compilation process.\n\nThey also serve as a method to order the output when using out or outFile. Files are emitted to the output file location in the same order as the input after preprocessing pass.\n\nPreprocessing input files\n\nThe compiler performs a preprocessing pass on input files to resolve all triple-slash reference directives. During this process, additional files are added to the compilation.\n\nThe process starts with a set of root files; these are the file names specified on the command-line or in the files list in the tsconfig.json file. These root files are preprocessed in the same order they are specified. Before a file is added to the list, all triple-slash references in it are processed, and their targets included. Triple-slash references are resolved in a depth-first manner, in the order they have been seen in the file.\n\nA triple-slash reference path is resolved relative to the containing file, if a relative path is used.\n\nErrors\n\nIt is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.\n\nUsing \n--noResolve\n\nIf the compiler flag noResolve is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.\n\n/// <reference types=\"...\" />\n\nSimilar to a /// <reference path=\"...\" /> directive, which serves as a declaration of dependency, a /// <reference types=\"...\" /> directive declares a dependency on a package.\n\nThe process of resolving these package names is similar to the process of resolving module names in an import statement. An easy way to think of triple-slash-reference-types directives are as an import for declaration packages.\n\nFor example, including /// <reference types=\"node\" /> in a declaration file declares that this file uses names declared in @types/node/index.d.ts; and thus, this package needs to be included in the compilation along with the declaration file.\n\nUse these directives only when you’re authoring a d.ts file by hand.\n\nFor declaration files generated during compilation, the compiler will automatically add /// <reference types=\"...\" /> for you; A /// <reference types=\"...\" /> in a generated declaration file is added if and only if the resulting file uses any declarations from the referenced package.\n\nFor declaring a dependency on an @types package in a .ts file, use types on the command line or in your tsconfig.json instead. See using @types, typeRoots and types in tsconfig.json files for more details.\n\n/// <reference lib=\"...\" />\n\nThis directive allows a file to explicitly include an existing built-in lib file.\n\nBuilt-in lib files are referenced in the same fashion as the lib compiler option in tsconfig.json (e.g. use lib=\"es2015\" and not lib=\"lib.es2015.d.ts\", etc.).\n\nFor declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like Symbol or Iterable, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.\n\nFor example, adding /// <reference lib=\"es2017.string\" /> to one of the files in a compilation is equivalent to compiling with --lib es2017.string.\n\n/// <reference lib=\"es2017.string\" />\n\"foo\".padStart(4);\n/// <reference no-default-lib=\"true\"/>\n\nThis directive marks a file as a default library. You will see this comment at the top of lib.d.ts and its different variants.\n\nThis directive instructs the compiler to not include the default library (i.e. lib.d.ts) in the compilation. The impact here is similar to passing noLib on the command line.\n\nAlso note that when passing skipDefaultLibCheck, the compiler will only skip checking files with /// <reference no-default-lib=\"true\"/>.\n\n/// <amd-module />\n\nBy default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. r.js).\n\nThe amd-module directive allows passing an optional module name to the compiler:\n\namdModule.ts\n/// <amd-module name=\"NamedModule\"/>\nexport class C {}\n\nWill result in assigning the name NamedModule to the module as part of calling the AMD define:\n\namdModule.js\ndefine(\"NamedModule\", [\"require\", \"exports\"], function (require, exports) {\n  var C = (function () {\n    function C() {}\n    return C;\n  })();\n  exports.C = C;\n});\n/// <amd-dependency />\n\nNote: this directive has been deprecated. Use import \"moduleName\"; statements instead.\n\n/// <amd-dependency path=\"x\" /> informs the compiler about a non-TS module dependency that needs to be injected in the resulting module’s require call.\n\nThe amd-dependency directive can also have an optional name property; this allows passing an optional name for an amd-dependency:\n\n/// <amd-dependency path=\"legacy/moduleA\" name=\"moduleA\"/>\ndeclare var moduleA: MyType;\nmoduleA.callStuff();\n\nGenerated JS code:\n\ndefine([\"require\", \"exports\", \"legacy/moduleA\"], function (\n  require,\n  exports,\n  moduleA\n) {\n  moduleA.callStuff();\n});\nOn this page\n/// <reference path=\"...\" />\nPreprocessing input files\nErrors\nUsing --noResolve\n/// <reference types=\"...\" />\n/// <reference lib=\"...\" />\n/// <reference no-default-lib=\"true\"/>\n/// <amd-module />\n/// <amd-dependency />\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nJM\nJB\nGS\n9+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.274 seconds."
  },
  {
    "title": "TypeScript: Documentation - Symbols",
    "url": "https://www.typescriptlang.org/docs/handbook/symbols.html",
    "html": "Symbols\n\nStarting with ECMAScript 2015, symbol is a primitive data type, just like number and string.\n\nsymbol values are created by calling the Symbol constructor.\n\nlet sym1 = Symbol();\nlet sym2 = Symbol(\"key\"); // optional string key\n\nSymbols are immutable, and unique.\n\nlet sym2 = Symbol(\"key\");\nlet sym3 = Symbol(\"key\");\nsym2 === sym3; // false, symbols are unique\n\nJust like strings, symbols can be used as keys for object properties.\n\nconst sym = Symbol();\nlet obj = {\n  [sym]: \"value\",\n};\nconsole.log(obj[sym]); // \"value\"\n\nSymbols can also be combined with computed property declarations to declare object properties and class members.\n\nconst getClassNameSymbol = Symbol();\nclass C {\n  [getClassNameSymbol]() {\n    return \"C\";\n  }\n}\nlet c = new C();\nlet className = c[getClassNameSymbol](); // \"C\"\nunique symbol\n\nTo enable treating symbols as unique literals a special type unique symbol is available. unique symbol is a subtype of symbol, and are produced only from calling Symbol() or Symbol.for(), or from explicit type annotations. This type is only allowed on const declarations and readonly static properties, and in order to reference a specific unique symbol, you’ll have to use the typeof operator. Each reference to a unique symbol implies a completely unique identity that’s tied to a given declaration.\n\ndeclare const sym1: unique symbol;\n \n// sym2 can only be a constant reference.\nlet sym2: unique symbol = Symbol();\nA variable whose type is a 'unique symbol' type must be 'const'.\nA variable whose type is a 'unique symbol' type must be 'const'.\n \n// Works - refers to a unique symbol, but its identity is tied to 'sym1'.\nlet sym3: typeof sym1 = sym1;\n \n// Also works.\nclass C {\n  static readonly StaticSymbol: unique symbol = Symbol();\n}\nTry\n\nBecause each unique symbol has a completely separate identity, no two unique symbol types are assignable or comparable to each other.\n\nconst sym2 = Symbol();\nconst sym3 = Symbol();\n \nif (sym2 === sym3) {\nThis comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.\nThis comparison appears to be unintentional because the types 'typeof sym2' and 'typeof sym3' have no overlap.\n  // ...\n}\nTry\nWell-known Symbols\n\nIn addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.\n\nHere is a list of well-known symbols:\n\nSymbol.asyncIterator\n\nA method that returns async iterator for an object, compatible to be used with for await..of loop.\n\nSymbol.hasInstance\n\nA method that determines if a constructor object recognizes an object as one of the constructor’s instances. Called by the semantics of the instanceof operator.\n\nSymbol.isConcatSpreadable\n\nA Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.\n\nSymbol.iterator\n\nA method that returns the default iterator for an object. Called by the semantics of the for-of statement.\n\nSymbol.match\n\nA regular expression method that matches the regular expression against a string. Called by the String.prototype.match method.\n\nSymbol.replace\n\nA regular expression method that replaces matched substrings of a string. Called by the String.prototype.replace method.\n\nSymbol.search\n\nA regular expression method that returns the index within a string that matches the regular expression. Called by the String.prototype.search method.\n\nSymbol.species\n\nA function valued property that is the constructor function that is used to create derived objects.\n\nSymbol.split\n\nA regular expression method that splits a string at the indices that match the regular expression. Called by the String.prototype.split method.\n\nSymbol.toPrimitive\n\nA method that converts an object to a corresponding primitive value. Called by the ToPrimitive abstract operation.\n\nSymbol.toStringTag\n\nA String value that is used in the creation of the default string description of an object. Called by the built-in method Object.prototype.toString.\n\nSymbol.unscopables\n\nAn Object whose own property names are property names that are excluded from the ‘with’ environment bindings of the associated objects.\n\nOn this page\nunique symbol\nWell-known Symbols\nSymbol.asyncIterator\nSymbol.hasInstance\nSymbol.isConcatSpreadable\nSymbol.iterator\nSymbol.match\nSymbol.replace\nSymbol.search\nSymbol.species\nSymbol.split\nSymbol.toPrimitive\nSymbol.toStringTag\nSymbol.unscopables\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nGB\nMF\nMN\n9+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.301 seconds."
  },
  {
    "title": "TypeScript: Documentation - Namespaces and Modules",
    "url": "https://www.typescriptlang.org/docs/handbook/namespaces-and-modules.html",
    "html": "Namespaces and Modules\n\nThis post outlines the various ways to organize your code using modules and namespaces in TypeScript. We’ll also go over some advanced topics of how to use namespaces and modules, and address some common pitfalls when using them in TypeScript.\n\nSee the Modules documentation for more information about ES Modules. See the Namespaces documentation for more information about TypeScript namespaces.\n\nNote: In very old versions of TypeScript namespaces were called ‘Internal Modules’, these pre-date JavaScript module systems.\n\nUsing Modules\n\nModules can contain both code and declarations.\n\nModules also have a dependency on a module loader (such as CommonJs/Require.js) or a runtime which supports ES Modules. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.\n\nIt is also worth noting that, for Node.js applications, modules are the default and we recommended modules over namespaces in modern code.\n\nStarting with ECMAScript 2015, modules are native part of the language, and should be supported by all compliant engine implementations. Thus, for new projects modules would be the recommended code organization mechanism.\n\nUsing Namespaces\n\nNamespaces are a TypeScript-specific way to organize code.\nNamespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. Unlike modules, they can span multiple files, and can be concatenated using outFile. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as <script> tags in your HTML page.\n\nJust like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.\n\nPitfalls of Namespaces and Modules\n\nIn this section we’ll describe various common pitfalls in using namespaces and modules, and how to avoid them.\n\n/// <reference>\n-ing a module\n\nA common mistake is to try to use the /// <reference ... /> syntax to refer to a module file, rather than using an import statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an import (e.g. the ... in import x from \"...\";, import x = require(\"...\");, etc.) path.\n\nThe compiler will try to find a .ts, .tsx, and then a .d.ts with the appropriate path. If a specific file could not be found, then the compiler will look for an ambient module declaration. Recall that these need to be declared in a .d.ts file.\n\nmyModules.d.ts\n\n// In a .d.ts file or .ts file that is not a module:\ndeclare module \"SomeModule\" {\n  export function fn(): string;\n}\n\nmyOtherModule.ts\n\n/// <reference path=\"myModules.d.ts\" />\nimport * as m from \"SomeModule\";\n\nThe reference tag here allows us to locate the declaration file that contains the declaration for the ambient module. This is how the node.d.ts file that several of the TypeScript samples use is consumed.\n\nNeedless Namespacing\n\nIf you’re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:\n\nshapes.ts\n\nexport namespace Shapes {\n  export class Triangle {\n    /* ... */\n  }\n  export class Square {\n    /* ... */\n  }\n}\n\nThe top-level namespace here Shapes wraps up Triangle and Square for no reason. This is confusing and annoying for consumers of your module:\n\nshapeConsumer.ts\n\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Shapes.Triangle(); // shapes.Shapes?\n\nA key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there’s no need to proactively wrap up the exported symbols in a namespace.\n\nTo reiterate why you shouldn’t try to namespace your module contents, the general idea of namespacing is to provide logical grouping of constructs and to prevent name collisions. Because the module file itself is already a logical grouping, and its top-level name is defined by the code that imports it, it’s unnecessary to use an additional module layer for exported objects.\n\nHere’s a revised example:\n\nshapes.ts\n\nexport class Triangle {\n  /* ... */\n}\nexport class Square {\n  /* ... */\n}\n\nshapeConsumer.ts\n\nimport * as shapes from \"./shapes\";\nlet t = new shapes.Triangle();\nTrade-offs of Modules\n\nJust as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it’s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can’t use the outFile option while targeting commonjs or umd, but with TypeScript 1.8 and later, it’s possible to use outFile when targeting amd or system.\n\nOn this page\nUsing Modules\nUsing Namespaces\nPitfalls of Namespaces and Modules\n/// <reference>-ing a module\nNeedless Namespacing\nTrade-offs of Modules\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nDR\nOT\nMH\nB\nMF\n15+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.155 seconds."
  },
  {
    "title": "TypeScript: Documentation - JSX",
    "url": "https://www.typescriptlang.org/docs/handbook/jsx.html",
    "html": "JSX\n\nJSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the React framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.\n\nBasic usage\n\nIn order to use JSX you must do two things.\n\nName your files with a .tsx extension\nEnable the jsx option\n\nTypeScript ships with three JSX modes: preserve, react, and react-native. These modes only affect the emit stage - type checking is unaffected. The preserve mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. Babel). Additionally the output will have a .jsx file extension. The react mode will emit React.createElement, does not need to go through a JSX transformation before use, and the output will have a .js file extension. The react-native mode is the equivalent of preserve in that it keeps all JSX, but the output will instead have a .js file extension.\n\nMode\tInput\tOutput\tOutput File Extension\npreserve\t<div />\t<div />\t.jsx\nreact\t<div />\tReact.createElement(\"div\")\t.js\nreact-native\t<div />\t<div />\t.js\nreact-jsx\t<div />\t_jsx(\"div\", {}, void 0);\t.js\nreact-jsxdev\t<div />\t_jsxDEV(\"div\", {}, void 0, false, {...}, this);\t.js\n\nYou can specify this mode using either the jsx command line flag or the corresponding option jsx in your tsconfig.json file.\n\n*Note: You can specify the JSX factory function to use when targeting react JSX emit with jsxFactory option (defaults to React.createElement)\n\nThe \nas\n operator\n\nRecall how to write a type assertion:\n\nconst foo = <foo>bar;\n\nThis asserts the variable bar to have the type foo. Since TypeScript also uses angle brackets for type assertions, combining it with JSX’s syntax would introduce certain parsing difficulties. As a result, TypeScript disallows angle bracket type assertions in .tsx files.\n\nSince the above syntax cannot be used in .tsx files, an alternate type assertion operator should be used: as. The example can easily be rewritten with the as operator.\n\nconst foo = bar as foo;\n\nThe as operator is available in both .ts and .tsx files, and is identical in behavior to the angle-bracket type assertion style.\n\nType Checking\n\nIn order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression <expr />, expr may either refer to something intrinsic to the environment (e.g. a div or span in a DOM environment) or to a custom component that you’ve created. This is important for two reasons:\n\nFor React, intrinsic elements are emitted as strings (React.createElement(\"div\")), whereas a component you’ve created is not (React.createElement(MyComponent)).\nThe types of the attributes being passed in the JSX element should be looked up differently. Intrinsic element attributes should be known intrinsically whereas components will likely want to specify their own set of attributes.\n\nTypeScript uses the same convention that React does for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.\n\nIntrinsic elements\n\nIntrinsic elements are looked up on the special interface JSX.IntrinsicElements. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface is present, then the name of the intrinsic element is looked up as a property on the JSX.IntrinsicElements interface. For example:\n\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: any;\n  }\n}\n<foo />; // ok\n<bar />; // error\n\nIn the above example, <foo /> will work fine but <bar /> will result in an error since it has not been specified on JSX.IntrinsicElements.\n\nNote: You can also specify a catch-all string indexer on JSX.IntrinsicElements as follows:\n\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    [elemName: string]: any;\n  }\n}\nValue-based elements\n\nValue-based elements are simply looked up by identifiers that are in scope.\n\nimport MyComponent from \"./myComponent\";\n<MyComponent />; // ok\n<SomeOtherComponent />; // error\n\nThere are two ways to define a value-based element:\n\nFunction Component (FC)\nClass Component\n\nBecause these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.\n\nFunction Component\n\nAs the name suggests, the component is defined as a JavaScript function where its first argument is a props object. TS enforces that its return type must be assignable to JSX.Element.\n\ninterface FooProp {\n  name: string;\n  X: number;\n  Y: number;\n}\ndeclare function AnotherComponent(prop: { name: string });\nfunction ComponentFoo(prop: FooProp) {\n  return <AnotherComponent name={prop.name} />;\n}\nconst Button = (prop: { value: string }, context: { color: string }) => (\n  <button />\n);\n\nBecause a Function Component is simply a JavaScript function, function overloads may be used here as well:\n\ninterface ClickableProps {\n  children: JSX.Element[] | JSX.Element;\n}\n \ninterface HomeProps extends ClickableProps {\n  home: JSX.Element;\n}\n \ninterface SideProps extends ClickableProps {\n  side: JSX.Element | string;\n}\n \nfunction MainButton(prop: HomeProps): JSX.Element;\nfunction MainButton(prop: SideProps): JSX.Element;\nfunction MainButton(prop: ClickableProps): JSX.Element {\n  // ...\n}\nTry\n\nNote: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type SFC and its alias StatelessComponent were deprecated.\n\nClass Component\n\nIt is possible to define the type of a class component. However, to do so it is best to understand two new terms: the element class type and the element instance type.\n\nGiven <Expr />, the element class type is the type of Expr. So in the example above, if MyComponent was an ES6 class the class type would be that class’s constructor and statics. If MyComponent was a factory function, the class type would be that function.\n\nOnce the class type is established, the instance type is determined by the union of the return types of the class type’s construct or call signatures (whichever is present). So again, in the case of an ES6 class, the instance type would be the type of an instance of that class, and in the case of a factory function, it would be the type of the value returned from the function.\n\nclass MyComponent {\n  render() {}\n}\n// use a construct signature\nconst myComponent = new MyComponent();\n// element class type => MyComponent\n// element instance type => { render: () => void }\nfunction MyFactoryFunction() {\n  return {\n    render: () => {},\n  };\n}\n// use a call signature\nconst myComponent = MyFactoryFunction();\n// element class type => MyFactoryFunction\n// element instance type => { render: () => void }\n\nThe element instance type is interesting because it must be assignable to JSX.ElementClass or it will result in an error. By default JSX.ElementClass is {}, but it can be augmented to limit the use of JSX to only those types that conform to the proper interface.\n\ndeclare namespace JSX {\n  interface ElementClass {\n    render: any;\n  }\n}\nclass MyComponent {\n  render() {}\n}\nfunction MyFactoryFunction() {\n  return { render: () => {} };\n}\n<MyComponent />; // ok\n<MyFactoryFunction />; // ok\nclass NotAValidComponent {}\nfunction NotAValidFactoryFunction() {\n  return {};\n}\n<NotAValidComponent />; // error\n<NotAValidFactoryFunction />; // error\nAttribute type checking\n\nThe first step to type checking attributes is to determine the element attributes type. This is slightly different between intrinsic and value-based elements.\n\nFor intrinsic elements, it is the type of the property on JSX.IntrinsicElements\n\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { bar?: boolean };\n  }\n}\n// element attributes type for 'foo' is '{bar?: boolean}'\n<foo bar />;\n\nFor value-based elements, it is a bit more complex. It is determined by the type of a property on the element instance type that was previously determined. Which property to use is determined by JSX.ElementAttributesProperty. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if JSX.ElementAttributesProperty is not provided, the type of first parameter of the class element’s constructor or Function Component’s call will be used instead.\n\ndeclare namespace JSX {\n  interface ElementAttributesProperty {\n    props; // specify the property name to use\n  }\n}\nclass MyComponent {\n  // specify the property on the element instance type\n  props: {\n    foo?: string;\n  };\n}\n// element attributes type for 'MyComponent' is '{foo?: string}'\n<MyComponent foo=\"bar\" />;\n\nThe element attribute type is used to type check the attributes in the JSX. Optional and required properties are supported.\n\ndeclare namespace JSX {\n  interface IntrinsicElements {\n    foo: { requiredProp: string; optionalProp?: number };\n  }\n}\n<foo requiredProp=\"bar\" />; // ok\n<foo requiredProp=\"bar\" optionalProp={0} />; // ok\n<foo />; // error, requiredProp is missing\n<foo requiredProp={0} />; // error, requiredProp should be a string\n<foo requiredProp=\"bar\" unknownProp />; // error, unknownProp does not exist\n<foo requiredProp=\"bar\" some-unknown-prop />; // ok, because 'some-unknown-prop' is not a valid identifier\n\nNote: If an attribute name is not a valid JS identifier (like a data-* attribute), it is not considered to be an error if it is not found in the element attributes type.\n\nAdditionally, the JSX.IntrinsicAttributes interface can be used to specify extra properties used by the JSX framework which are not generally used by the components’ props or arguments - for instance key in React. Specializing further, the generic JSX.IntrinsicClassAttributes<T> type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the ref attribute of type Ref<T>. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.\n\nThe spread operator also works:\n\nconst props = { requiredProp: \"bar\" };\n<foo {...props} />; // ok\nconst badProps = {};\n<foo {...badProps} />; // error\nChildren Type Checking\n\nIn TypeScript 2.3, TS introduced type checking of children. children is a special property in an element attributes type where child JSXExpressions are taken to be inserted into the attributes. Similar to how TS uses JSX.ElementAttributesProperty to determine the name of props, TS uses JSX.ElementChildrenAttribute to determine the name of children within those props. JSX.ElementChildrenAttribute should be declared with a single property.\n\ndeclare namespace JSX {\n  interface ElementChildrenAttribute {\n    children: {}; // specify children name to use\n  }\n}\n<div>\n  <h1>Hello</h1>\n</div>;\n<div>\n  <h1>Hello</h1>\n  World\n</div>;\nconst CustomComp = (props) => <div>{props.children}</div>\n<CustomComp>\n  <div>Hello World</div>\n  {\"This is just a JS expression...\" + 1000}\n</CustomComp>\n\nYou can specify the type of children like any other attribute. This will override the default type from, e.g. the React typings if you use them.\n\ninterface PropsType {\n  children: JSX.Element\n  name: string\n}\nclass Component extends React.Component<PropsType, {}> {\n  render() {\n    return (\n      <h2>\n        {this.props.children}\n      </h2>\n    )\n  }\n}\n// OK\n<Component name=\"foo\">\n  <h1>Hello World</h1>\n</Component>\n// Error: children is of type JSX.Element not array of JSX.Element\n<Component name=\"bar\">\n  <h1>Hello World</h1>\n  <h2>Hello World</h2>\n</Component>\n// Error: children is of type JSX.Element not array of JSX.Element or string.\n<Component name=\"baz\">\n  <h1>Hello</h1>\n  World\n</Component>\nThe JSX result type\n\nBy default the result of a JSX expression is typed as any. You can customize the type by specifying the JSX.Element interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.\n\nEmbedding Expressions\n\nJSX allows you to embed expressions between tags by surrounding the expressions with curly braces ({ }).\n\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map((i) => (\n      <span>{i / 2}</span>\n    ))}\n  </div>\n);\n\nThe above code will result in an error since you cannot divide a string by a number. The output, when using the preserve option, looks like:\n\nconst a = (\n  <div>\n    {[\"foo\", \"bar\"].map(function (i) {\n      return <span>{i / 2}</span>;\n    })}\n  </div>\n);\nReact integration\n\nTo use JSX with React you should use the React typings. These typings define the JSX namespace appropriately for use with React.\n\n/// <reference path=\"react.d.ts\" />\ninterface Props {\n  foo: string;\n}\nclass MyComponent extends React.Component<Props, {}> {\n  render() {\n    return <span>{this.props.foo}</span>;\n  }\n}\n<MyComponent foo=\"bar\" />; // ok\n<MyComponent foo={0} />; // error\nConfiguring JSX\n\nThere are multiple compiler flags which can be used to customize your JSX, which work as both a compiler flag and via inline per-file pragmas. To learn more see their tsconfig reference pages:\n\njsxFactory\njsxFragmentFactory\njsxImportSource\nOn this page\nBasic usage\nThe as operator\nType Checking\nIntrinsic elements\nValue-based elements\nAttribute type checking\nChildren Type Checking\nThe JSX result type\nEmbedding Expressions\nReact integration\nConfiguring JSX\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nRC\nDZ\nKT\n32+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.902 seconds."
  },
  {
    "title": "TypeScript: Documentation - Namespaces",
    "url": "https://www.typescriptlang.org/docs/handbook/namespaces.html",
    "html": "Namespaces\n\nA note about terminology: It’s important to note that in TypeScript 1.5, the nomenclature has changed. “Internal modules” are now “namespaces”. “External modules” are now simply “modules”, as to align with ECMAScript 2015’s terminology, (namely that module X { is equivalent to the now-preferred namespace X {).\n\nThis post outlines the various ways to organize your code using namespaces (previously “internal modules”) in TypeScript. As we alluded in our note about terminology, “internal modules” are now referred to as “namespaces”. Additionally, anywhere the module keyword was used when declaring an internal module, the namespace keyword can and should be used instead. This avoids confusing new users by overloading them with similarly named terms.\n\nFirst steps\n\nLet’s start with the program we’ll be using as our example throughout this page. We’ve written a small set of simplistic string validators, as you might write to check a user’s input on a form in a webpage or check the format of an externally-provided data file.\n\nValidators in a single file\ninterface StringValidator {\n  isAcceptable(s: string): boolean;\n}\nlet lettersRegexp = /^[A-Za-z]+$/;\nlet numberRegexp = /^[0-9]+$/;\nclass LettersOnlyValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return lettersRegexp.test(s);\n  }\n}\nclass ZipCodeValidator implements StringValidator {\n  isAcceptable(s: string) {\n    return s.length === 5 && numberRegexp.test(s);\n  }\n}\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// Validators to use\nlet validators: { [s: string]: StringValidator } = {};\nvalidators[\"ZIP code\"] = new ZipCodeValidator();\nvalidators[\"Letters only\"] = new LettersOnlyValidator();\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    let isMatch = validators[name].isAcceptable(s);\n    console.log(`'${s}' ${isMatch ? \"matches\" : \"does not match\"} '${name}'.`);\n  }\n}\nNamespacing\n\nAs we add more validators, we’re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let’s wrap up our objects into a namespace.\n\nIn this example, we’ll move all validator-related entities into a namespace called Validation. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with export. Conversely, the variables lettersRegexp and numberRegexp are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. Validation.LettersOnlyValidator.\n\nNamespaced Validators\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n  const lettersRegexp = /^[A-Za-z]+$/;\n  const numberRegexp = /^[0-9]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`\n    );\n  }\n}\nSplitting Across Files\n\nAs our application grows, we’ll want to split the code across multiple files to make it easier to maintain.\n\nMulti-file namespaces\n\nHere, we’ll split our Validation namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we’ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.\n\nValidation.ts\nnamespace Validation {\n  export interface StringValidator {\n    isAcceptable(s: string): boolean;\n  }\n}\nLettersOnlyValidator.ts\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const lettersRegexp = /^[A-Za-z]+$/;\n  export class LettersOnlyValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return lettersRegexp.test(s);\n    }\n  }\n}\nZipCodeValidator.ts\n/// <reference path=\"Validation.ts\" />\nnamespace Validation {\n  const numberRegexp = /^[0-9]+$/;\n  export class ZipCodeValidator implements StringValidator {\n    isAcceptable(s: string) {\n      return s.length === 5 && numberRegexp.test(s);\n    }\n  }\n}\nTest.ts\n/// <reference path=\"Validation.ts\" />\n/// <reference path=\"LettersOnlyValidator.ts\" />\n/// <reference path=\"ZipCodeValidator.ts\" />\n// Some samples to try\nlet strings = [\"Hello\", \"98052\", \"101\"];\n// Validators to use\nlet validators: { [s: string]: Validation.StringValidator } = {};\nvalidators[\"ZIP code\"] = new Validation.ZipCodeValidator();\nvalidators[\"Letters only\"] = new Validation.LettersOnlyValidator();\n// Show whether each string passed each validator\nfor (let s of strings) {\n  for (let name in validators) {\n    console.log(\n      `\"${s}\" - ${\n        validators[name].isAcceptable(s) ? \"matches\" : \"does not match\"\n      } ${name}`\n    );\n  }\n}\n\nOnce there are multiple files involved, we’ll need to make sure all of the compiled code gets loaded. There are two ways of doing this.\n\nFirst, we can use concatenated output using the outFile option to compile all of the input files into a single JavaScript output file:\n\ntsc --outFile sample.js Test.ts\n\nThe compiler will automatically order the output file based on the reference tags present in the files. You can also specify each file individually:\n\ntsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts\n\nAlternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we’ll need to use <script> tags on our webpage to load each emitted file in the appropriate order, for example:\n\nMyTestPage.html (excerpt)\n<script src=\"Validation.js\" type=\"text/javascript\" />\n<script src=\"LettersOnlyValidator.js\" type=\"text/javascript\" />\n<script src=\"ZipCodeValidator.js\" type=\"text/javascript\" />\n<script src=\"Test.js\" type=\"text/javascript\" />\nAliases\n\nAnother way that you can simplify working with namespaces is to use import q = x.y.z to create shorter names for commonly-used objects. Not to be confused with the import x = require(\"name\") syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.\n\nnamespace Shapes {\n  export namespace Polygons {\n    export class Triangle {}\n    export class Square {}\n  }\n}\nimport polygons = Shapes.Polygons;\nlet sq = new polygons.Square(); // Same as 'new Shapes.Polygons.Square()'\n\nNotice that we don’t use the require keyword; instead we assign directly from the qualified name of the symbol we’re importing. This is similar to using var, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, import is a distinct reference from the original symbol, so changes to an aliased var will not be reflected in the original variable.\n\nWorking with Other JavaScript Libraries\n\nTo describe the shape of libraries not written in TypeScript, we need to declare the API that the library exposes. Because most JavaScript libraries expose only a few top-level objects, namespaces are a good way to represent them.\n\nWe call declarations that don’t define an implementation “ambient”. Typically these are defined in .d.ts files. If you’re familiar with C/C++, you can think of these as .h files. Let’s look at a few examples.\n\nAmbient Namespaces\n\nThe popular library D3 defines its functionality in a global object called d3. Because this library is loaded through a <script> tag (instead of a module loader), its declaration uses namespaces to define its shape. For the TypeScript compiler to see this shape, we use an ambient namespace declaration. For example, we could begin writing it as follows:\n\nD3.d.ts (simplified excerpt)\ndeclare namespace D3 {\n  export interface Selectors {\n    select: {\n      (selector: string): Selection;\n      (element: EventTarget): Selection;\n    };\n  }\n  export interface Event {\n    x: number;\n    y: number;\n  }\n  export interface Base extends Selectors {\n    event: Event;\n  }\n}\ndeclare var d3: D3.Base;\nOn this page\nFirst steps\nValidators in a single file\nNamespacing\nNamespaced Validators\nSplitting Across Files\nMulti-file namespaces\nAliases\nWorking with Other JavaScript Libraries\nAmbient Namespaces\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nMH\nOT\nDR\nIO\nJB\n14+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.62 seconds."
  },
  {
    "title": "TypeScript: Documentation - Mixins",
    "url": "https://www.typescriptlang.org/docs/handbook/mixins.html",
    "html": "Mixins\n\nAlong with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.\n\nHow Does A Mixin Work?\n\nThe pattern relies on using generics with class inheritance to extend a base class. TypeScript’s best mixin support is done via the class expression pattern. You can read more about how this pattern works in JavaScript here.\n\nTo get started, we’ll need a class which will have the mixins applied on top of:\n\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n \n  constructor(name: string) {\n    this.name = name;\n  }\n}\nTry\n\nThen you need a type and a factory function which returns a class expression extending the base class.\n\n// To get started, we need a type which we'll use to extend\n// other classes from. The main responsibility is to declare\n// that the type being passed in is a class.\n \ntype Constructor = new (...args: any[]) => {};\n \n// This mixin adds a scale property, with getters and setters\n// for changing it with an encapsulated private property:\n \nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class Scaling extends Base {\n    // Mixins may not declare private/protected properties\n    // however, you can use ES2020 private fields\n    _scale = 1;\n \n    setScale(scale: number) {\n      this._scale = scale;\n    }\n \n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\nTry\n\nWith these all set up, then you can create a class which represents the base class with mixins applied:\n\n// Compose a new class from the Sprite class,\n// with the Mixin Scale applier:\nconst EightBitSprite = Scale(Sprite);\n \nconst flappySprite = new EightBitSprite(\"Bird\");\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\nTry\nConstrained Mixins\n\nIn the above form, the mixin’s have no underlying knowledge of the class which can make it hard to create the design you want.\n\nTo model this, we modify the original constructor type to accept a generic argument.\n\n// This was our previous constructor:\ntype Constructor = new (...args: any[]) => {};\n// Now we use a generic version which can apply a constraint on\n// the class which this mixin is applied to\ntype GConstructor<T = {}> = new (...args: any[]) => T;\nTry\n\nThis allows for creating classes which only work with constrained base classes:\n\ntype Positionable = GConstructor<{ setPos: (x: number, y: number) => void }>;\ntype Spritable = GConstructor<Sprite>;\ntype Loggable = GConstructor<{ print: () => void }>;\nTry\n\nThen you can create mixins which only work when you have a particular base to build on:\n\nfunction Jumpable<TBase extends Positionable>(Base: TBase) {\n  return class Jumpable extends Base {\n    jump() {\n      // This mixin will only work if it is passed a base\n      // class which has setPos defined because of the\n      // Positionable constraint.\n      this.setPos(0, 20);\n    }\n  };\n}\nTry\nAlternative Pattern\n\nPrevious versions of this document recommended a way to write mixins where you created both the runtime and type hierarchies separately, then merged them at the end:\n\n// Each mixin is a traditional ES class\nclass Jumpable {\n  jump() {}\n}\n \nclass Duckable {\n  duck() {}\n}\n \n// Including the base\nclass Sprite {\n  x = 0;\n  y = 0;\n}\n \n// Then you create an interface which merges\n// the expected mixins with the same name as your base\ninterface Sprite extends Jumpable, Duckable {}\n// Apply the mixins into the base class via\n// the JS at runtime\napplyMixins(Sprite, [Jumpable, Duckable]);\n \nlet player = new Sprite();\nplayer.jump();\nconsole.log(player.x, player.y);\n \n// This can live anywhere in your codebase:\nfunction applyMixins(derivedCtor: any, constructors: any[]) {\n  constructors.forEach((baseCtor) => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach((name) => {\n      Object.defineProperty(\n        derivedCtor.prototype,\n        name,\n        Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||\n          Object.create(null)\n      );\n    });\n  });\n}\nTry\n\nThis pattern relies less on the compiler, and more on your codebase to ensure both runtime and type-system are correctly kept in sync.\n\nConstraints\n\nThe mixin pattern is supported natively inside the TypeScript compiler by code flow analysis. There are a few cases where you can hit the edges of the native support.\n\nDecorators and Mixins #4881\n\nYou cannot use decorators to provide mixins via code flow analysis:\n\n// A decorator function which replicates the mixin pattern:\nconst Pausable = (target: typeof Player) => {\n  return class Pausable extends target {\n    shouldFreeze = false;\n  };\n};\n \n@Pausable\nclass Player {\n  x = 0;\n  y = 0;\n}\n \n// The Player class does not have the decorator's type merged:\nconst player = new Player();\nplayer.shouldFreeze;\nProperty 'shouldFreeze' does not exist on type 'Player'.\nProperty 'shouldFreeze' does not exist on type 'Player'.\n \n// The runtime aspect could be manually replicated via\n// type composition or interface merging.\ntype FreezablePlayer = Player & { shouldFreeze: boolean };\n \nconst playerTwo = (new Player() as unknown) as FreezablePlayer;\nplayerTwo.shouldFreeze;\nTry\nStatic Property Mixins #17829\n\nMore of a gotcha than a constraint. The class expression pattern creates singletons, so they can’t be mapped at the type system to support different variable types.\n\nYou can work around this by using functions to return your classes which differ based on a generic:\n\nfunction base<T>() {\n  class Base {\n    static prop: T;\n  }\n  return Base;\n}\n \nfunction derived<T>() {\n  class Derived extends base<T>() {\n    static anotherProp: T;\n  }\n  return Derived;\n}\n \nclass Spec extends derived<string>() {}\n \nSpec.prop; // string\nSpec.anotherProp; // string\nTry\nOn this page\nHow Does A Mixin Work?\nConstrained Mixins\nAlternative Pattern\nConstraints\nIs this page helpful?\nYes\nNo\n\nThe TypeScript docs are an open source project. Help us improve these pages by sending a Pull Request ❤\n\nContributors to this page:\n\nOT\nGM\nIO\nDE\nO\n5+\n\nLast updated: Nov 27, 2023\n\nThis page loaded in 0.831 seconds."
  }
]