[
  {
    "title": "zod/README.md at master · colinhacks/zod · GitHub",
    "url": "https://github.com/colinhacks/zod/blob/master/README.md",
    "html": "Zod\n\n✨ https://zod.dev ✨\nTypeScript-first schema validation with static type inference\nInstallation\nRequirements\nFrom npm (Node/Bun)\nFrom deno.land/x (Deno)\nBasic usage\nPrimitives\nCoercion for primitives\nLiterals\nStrings\nISO datetimes\nIP addresses\nNumbers\nBigInts\nNaNs\nBooleans\nDates\nZod enums\nNative enums\nOptionals\nNullables\nObjects\n.shape\n.keyof\n.extend\n.merge\n.pick/.omit\n.partial\n.deepPartial\n.required\n.passthrough\n.strict\n.strip\n.catchall\nArrays\n.element\n.nonempty\n.min/.max/.length\nTuples\nUnions\nDiscriminated unions\nRecords\nRecord key type\nMaps\nSets\nIntersections\nRecursive types\nZodType with ZodEffects\nJSON type\nCyclical objects\nPromises\nInstanceof\nFunctions\nPreprocess\nCustom schemas\nSchema methods\n.parse\n.parseAsync\n.safeParse\n.safeParseAsync\n.refine\nArguments\nCustomize error path\nAsynchronous refinements\nRelationship to transforms\n.superRefine\nAbort early\nType refinements\n.transform\nChaining order\nValidating during transform\nRelationship to refinements\nAsync transforms\n.default\n.describe\n.catch\n.optional\n.nullable\n.nullish\n.array\n.promise\n.or\n.and\n.brand\n.readonly\n.pipe\nYou can use .pipe() to fix common issues with z.coerce.\nGuides and concepts\nType inference\nWriting generic functions\nConstraining allowable inputs\nError handling\nError formatting\nComparison\nJoi\nYup\nio-ts\nRuntypes\nOw\nChangelog\nIntroduction\n\nZod is a TypeScript-first schema declaration and validation library. I'm using the term \"schema\" to broadly refer to any data type, from a simple string to a complex nested object.\n\nZod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator once and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.\n\nSome other great aspects:\n\nZero dependencies\nWorks in Node.js and all modern browsers\nTiny: 8kb minified + zipped\nImmutable: methods (e.g. .optional()) return a new instance\nConcise, chainable interface\nFunctional approach: parse, don't validate\nWorks with plain JavaScript too! You don't need to use TypeScript.\nSponsors\n\nSponsorship at any level is appreciated and encouraged. For individual developers, consider the Cup of Coffee tier. If you built a paid product using Zod, consider one of the podium tiers.\n\nGold\n\nSpeakeasy\nspeakeasyapi.dev\n\n\nSDKs, Terraform, Docs.\nYour API made enterprise-ready.\n\n\t\nGlow Wallet\nglow.app\n\n\nYour new favorite\nSolana wallet.\n\n\n\nDeletype\ndeletype.com\t\nTrigger.dev\ntrigger.dev\n\n\nEffortless automation for developers.\n\n\n\nTransloadit\ntransloadit.com\n\n\nSimple file processing for developers.\n\n\t\nInfisical\ninfisical.com\n\n\nOpen-source platform for secret\nmanagement: sync secrets across your\nteam/infrastructure and prevent secret leaks.\n\n\n\nWhop\nwhop.com\n\n\nA marketplace for really cool internet products.\n\n\t\nCryptoJobsList\ncryptojobslist.com\n\n\nThe biggest list of crypto, blockchain and Web3 jobs\n\n\n\nPlain.\nplain.com\n\n\nHow developers support their users.\n\nSilver\n\nNumeric\nnumeric.io\t\nMarcato Partners\nmarcatopartners.com\n\nInterval\ninterval.com\t\nSeasoned Software\nseasoned.cc\t\nBamboo Creative\nbamboocreative.nz\nBronze\n\nBrandon Bayer\n@flybayer, creator of Blitz.js\n\t\nJiří Brabec\n@brabeji\n\t\nAlex Johansson\n@alexdotjs\n\nFungible Systems\nfungible.systems\n\t\nAdaptable\nadaptable.io\n\t\nAvana Wallet\navanawallet.com\nSolana non-custodial wallet\n\n\nJason Lengstorf\nlearnwithjason.dev\n\t\nGlobal Illumination, Inc.\nill.inc\n\t\nMasterBorn\nmasterborn.com\n\nEcosystem\n\nThere are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it on Twitter or start a Discussion. I'll add it below and tweet it out.\n\nResources\nTotal TypeScript Zod Tutorial by @mattpocockuk\nFixing TypeScript's Blindspot: Runtime Typechecking by @jherr\nAPI libraries\ntRPC: Build end-to-end typesafe APIs without GraphQL.\n@anatine/zod-nestjs: Helper methods for using Zod in a NestJS project.\nzod-endpoints: Contract-first strictly typed endpoints with Zod. OpenAPI compatible.\ndomain-functions: Decouple your business logic from your framework using composable functions. With first-class type inference from end to end powered by Zod schemas.\n@zodios/core: A typescript API client with runtime and compile time validation backed by axios and zod.\nexpress-zod-api: Build Express-based APIs with I/O schema validation and custom middlewares.\ntapiduck: End-to-end typesafe JSON APIs with Zod and Express; a bit like tRPC, but simpler.\nkoa-zod-router: Create typesafe routes in Koa with I/O validation using Zod.\nForm integrations\nconform: A progressive enhancement first form validation library for Remix and React Router\nreact-hook-form: A first-party Zod resolver for React Hook Form.\nzod-validation-error: Generate user-friendly error messages from ZodErrors.\nzod-formik-adapter: A community-maintained Formik adapter for Zod.\nreact-zorm: Standalone <form> generation and validation for React using Zod.\nzodix: Zod utilities for FormData and URLSearchParams in Remix loaders and actions.\nremix-params-helper: Simplify integration of Zod with standard URLSearchParams and FormData for Remix apps.\nformik-validator-zod: Formik-compliant validator library that simplifies using Zod with Formik.\nzod-i18n-map: Useful for translating Zod error messages.\n@modular-forms/solid: Modular form library for SolidJS that supports Zod for validation.\nhouseform: A React form library that uses Zod for validation.\nsveltekit-superforms: Supercharged form library for SvelteKit with Zod validation.\nmobx-zod-form: Data-first form builder based on MobX & Zod.\n@vee-validate/zod: Form library for Vue.js with Zod schema validation.\nZod to X\nzod-to-ts: Generate TypeScript definitions from Zod schemas.\nzod-to-json-schema: Convert your Zod schemas into JSON Schemas.\n@anatine/zod-openapi: Converts a Zod schema to an OpenAPI v3.x SchemaObject.\nzod-fast-check: Generate fast-check arbitraries from Zod schemas.\nzod-dto: Generate Nest.js DTOs from a Zod schema.\nfastify-type-provider-zod: Create Fastify type providers from Zod schemas.\nzod-to-openapi: Generate full OpenAPI (Swagger) docs from Zod, including schemas, endpoints & parameters.\nnestjs-graphql-zod: Generates NestJS GraphQL model classes from Zod schemas. Provides GraphQL method decorators working with Zod schemas.\nzod-openapi: Create full OpenAPI v3.x documentation from Zod schemas.\nfastify-zod-openapi: Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.\ntypeschema: Universal adapter for schema validation.\nX to Zod\nts-to-zod: Convert TypeScript definitions into Zod schemas.\n@runtyping/zod: Generate Zod from static types & JSON schema.\njson-schema-to-zod: Convert your JSON Schemas into Zod schemas. Live demo.\njson-to-zod: Convert JSON objects into Zod schemas. Live demo.\ngraphql-codegen-typescript-validation-schema: GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema.\nzod-prisma: Generate Zod schemas from your Prisma schema.\nSupervillain: Generate Zod schemas from your Go structs.\nprisma-zod-generator: Emit Zod schemas from your Prisma schema.\nprisma-trpc-generator: Emit fully implemented tRPC routers and their validation schemas using Zod.\nzod-prisma-types Create Zod types from your Prisma models.\nquicktype: Convert JSON objects and JSON schemas into Zod schemas.\n@sanity-typed/zod: Generate Zod Schemas from Sanity Schemas.\nMocking\n@anatine/zod-mock: Generate mock data from a Zod schema. Powered by faker.js.\nzod-mocking: Generate mock data from your Zod schemas.\nzod-fixture: Use your zod schemas to automate the generation of non-relevant test fixtures in a deterministic way.\nzocker: Generate plausible mock-data from your schemas.\nzodock Generate mock data based on Zod schemas.\nPowered by Zod\nfreerstore: Firestore cost optimizer.\nslonik: Node.js Postgres client with strong Zod integration.\nsoly: Create CLI applications with zod.\nzod-xlsx: A xlsx based resource validator using Zod schemas.\nznv: Type-safe environment parsing and validation for Node.js with Zod schemas.\nUtilities for Zod\nzod_utilz: Framework agnostic utilities for Zod.\nzod-sandbox: Controlled environment for testing zod schemas. Live demo.\nInstallation\nRequirements\n\nTypeScript 4.5+!\n\nYou must enable strict mode in your tsconfig.json. This is a best practice for all TypeScript projects.\n\n// tsconfig.json\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true\n  }\n}\nFrom npm (Node/Bun)\nnpm install zod       # npm\nyarn add zod          # yarn\nbun add zod           # bun\npnpm add zod          # pnpm\n\nZod also publishes a canary version on every commit. To install the canary:\n\nnpm install zod@canary       # npm\nyarn add zod@canary          # yarn\nbun add zod@canary           # bun\npnpm add zod@canary          # pnpm\nFrom deno.land/x (Deno)\n\nUnlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on deno.land/x. The latest version can be imported like so:\n\nimport { z } from \"https://deno.land/x/zod/mod.ts\";\n\nYou can also specify a particular version:\n\nimport { z } from \"https://deno.land/x/zod@v3.16.1/mod.ts\";\n\nThe rest of this README assumes you are using npm and importing directly from the \"zod\" package.\n\nBasic usage\n\nCreating a simple string schema\n\nimport { z } from \"zod\";\n\n// creating a schema for strings\nconst mySchema = z.string();\n\n// parsing\nmySchema.parse(\"tuna\"); // => \"tuna\"\nmySchema.parse(12); // => throws ZodError\n\n// \"safe\" parsing (doesn't throw error if validation fails)\nmySchema.safeParse(\"tuna\"); // => { success: true; data: \"tuna\" }\nmySchema.safeParse(12); // => { success: false; error: ZodError }\n\nCreating an object schema\n\nimport { z } from \"zod\";\n\nconst User = z.object({\n  username: z.string(),\n});\n\nUser.parse({ username: \"Ludwig\" });\n\n// extract the inferred type\ntype User = z.infer<typeof User>;\n// { username: string }\nPrimitives\nimport { z } from \"zod\";\n\n// primitive values\nz.string();\nz.number();\nz.bigint();\nz.boolean();\nz.date();\nz.symbol();\n\n// empty types\nz.undefined();\nz.null();\nz.void(); // accepts undefined\n\n// catch-all types\n// allows any value\nz.any();\nz.unknown();\n\n// never type\n// allows no values\nz.never();\nCoercion for primitives\n\nZod now provides a more convenient way to coerce primitive values.\n\nconst schema = z.coerce.string();\nschema.parse(\"tuna\"); // => \"tuna\"\nschema.parse(12); // => \"12\"\nschema.parse(true); // => \"true\"\n\nDuring the parsing step, the input is passed through the String() function, which is a JavaScript built-in for coercing data into strings. Note that the returned schema is a ZodString instance so you can use all string methods.\n\nz.coerce.string().email().min(5);\n\nAll primitive types support coercion.\n\nz.coerce.string(); // String(input)\nz.coerce.number(); // Number(input)\nz.coerce.boolean(); // Boolean(input)\nz.coerce.bigint(); // BigInt(input)\nz.coerce.date(); // new Date(input)\n\nBoolean coercion\n\nZod's boolean coercion is very simple! It passes the value into the Boolean(value) function, that's it. Any truthy value will resolve to true, any falsy value will resolve to false.\n\nz.coerce.boolean().parse(\"tuna\"); // => true\nz.coerce.boolean().parse(\"true\"); // => true\nz.coerce.boolean().parse(\"false\"); // => true\nz.coerce.boolean().parse(1); // => true\nz.coerce.boolean().parse([]); // => true\n\nz.coerce.boolean().parse(0); // => false\nz.coerce.boolean().parse(undefined); // => false\nz.coerce.boolean().parse(null); // => false\nLiterals\n\nLiteral schemas represent a literal type, like \"hello world\" or 5.\n\nconst tuna = z.literal(\"tuna\");\nconst twelve = z.literal(12);\nconst twobig = z.literal(2n); // bigint literal\nconst tru = z.literal(true);\n\nconst terrificSymbol = Symbol(\"terrific\");\nconst terrific = z.literal(terrificSymbol);\n\n// retrieve literal value\ntuna.value; // \"tuna\"\n\nCurrently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue.\n\nStrings\n\nZod includes a handful of string-specific validations.\n\n// validations\nz.string().max(5);\nz.string().min(5);\nz.string().length(5);\nz.string().email();\nz.string().url();\nz.string().emoji();\nz.string().uuid();\nz.string().cuid();\nz.string().cuid2();\nz.string().ulid();\nz.string().regex(regex);\nz.string().includes(string);\nz.string().startsWith(string);\nz.string().endsWith(string);\nz.string().datetime(); // ISO 8601; default is without UTC offset, see below for options\nz.string().ip(); // defaults to IPv4 and IPv6, see below for options\n\n// transformations\nz.string().trim(); // trim whitespace\nz.string().toLowerCase(); // toLowerCase\nz.string().toUpperCase(); // toUpperCase\n\nCheck out validator.js for a bunch of other useful string validation functions that can be used in conjunction with Refinements.\n\nYou can customize some common error messages when creating a string schema.\n\nconst name = z.string({\n  required_error: \"Name is required\",\n  invalid_type_error: \"Name must be a string\",\n});\n\nWhen using validation methods, you can pass in an additional argument to provide a custom error message.\n\nz.string().min(5, { message: \"Must be 5 or more characters long\" });\nz.string().max(5, { message: \"Must be 5 or fewer characters long\" });\nz.string().length(5, { message: \"Must be exactly 5 characters long\" });\nz.string().email({ message: \"Invalid email address\" });\nz.string().url({ message: \"Invalid url\" });\nz.string().emoji({ message: \"Contains non-emoji characters\" });\nz.string().uuid({ message: \"Invalid UUID\" });\nz.string().includes(\"tuna\", { message: \"Must include tuna\" });\nz.string().startsWith(\"https://\", { message: \"Must provide secure URL\" });\nz.string().endsWith(\".com\", { message: \"Only .com domains allowed\" });\nz.string().datetime({ message: \"Invalid datetime string! Must be UTC.\" });\nz.string().ip({ message: \"Invalid IP address\" });\nISO datetimes\n\nThe z.string().datetime() method enforces ISO 8601; default is no timezone offsets and arbitrary sub-second decimal precision.\n\nconst datetime = z.string().datetime();\n\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // pass (arbitrary precision)\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // fail (no offsets allowed)\n\nTimezone offsets can be allowed by setting the offset option to true.\n\nconst datetime = z.string().datetime({ offset: true });\n\ndatetime.parse(\"2020-01-01T00:00:00+02:00\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00.123+02:00\"); // pass (millis optional)\ndatetime.parse(\"2020-01-01T00:00:00.123+0200\"); // pass (millis optional)\ndatetime.parse(\"2020-01-01T00:00:00.123+02\"); // pass (only offset hours)\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // pass (Z still supported)\n\nYou can additionally constrain the allowable precision. By default, arbitrary sub-second precision is supported (but optional).\n\nconst datetime = z.string().datetime({ precision: 3 });\n\ndatetime.parse(\"2020-01-01T00:00:00.123Z\"); // pass\ndatetime.parse(\"2020-01-01T00:00:00Z\"); // fail\ndatetime.parse(\"2020-01-01T00:00:00.123456Z\"); // fail\nIP addresses\n\nThe z.string().ip() method by default validate IPv4 and IPv6.\n\nconst ip = z.string().ip();\n\nip.parse(\"192.168.1.1\"); // pass\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // pass\nip.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1\"); // pass\n\nip.parse(\"256.1.1.1\"); // fail\nip.parse(\"84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003\"); // fail\n\nYou can additionally set the IP version.\n\nconst ipv4 = z.string().ip({ version: \"v4\" });\nipv4.parse(\"84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003\"); // fail\n\nconst ipv6 = z.string().ip({ version: \"v6\" });\nipv6.parse(\"192.168.1.1\"); // fail\nNumbers\n\nYou can customize certain error messages when creating a number schema.\n\nconst age = z.number({\n  required_error: \"Age is required\",\n  invalid_type_error: \"Age must be a number\",\n});\n\nZod includes a handful of number-specific validations.\n\nz.number().gt(5);\nz.number().gte(5); // alias .min(5)\nz.number().lt(5);\nz.number().lte(5); // alias .max(5)\n\nz.number().int(); // value must be an integer\n\nz.number().positive(); //     > 0\nz.number().nonnegative(); //  >= 0\nz.number().negative(); //     < 0\nz.number().nonpositive(); //  <= 0\n\nz.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)\n\nz.number().finite(); // value must be finite, not Infinity or -Infinity\nz.number().safe(); // value must be between Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER\n\nOptionally, you can pass in a second argument to provide a custom error message.\n\nz.number().lte(5, { message: \"this👏is👏too👏big\" });\nBigInts\n\nZod includes a handful of bigint-specific validations.\n\nz.bigint().gt(5n);\nz.bigint().gte(5n); // alias `.min(5n)`\nz.bigint().lt(5n);\nz.bigint().lte(5n); // alias `.max(5n)`\n\nz.bigint().positive(); // > 0n\nz.bigint().nonnegative(); // >= 0n\nz.bigint().negative(); // < 0n\nz.bigint().nonpositive(); // <= 0n\n\nz.bigint().multipleOf(5n); // Evenly divisible by 5n.\nNaNs\n\nYou can customize certain error messages when creating a nan schema.\n\nconst isNaN = z.nan({\n  required_error: \"isNaN is required\",\n  invalid_type_error: \"isNaN must be not a number\",\n});\nBooleans\n\nYou can customize certain error messages when creating a boolean schema.\n\nconst isActive = z.boolean({\n  required_error: \"isActive is required\",\n  invalid_type_error: \"isActive must be a boolean\",\n});\nDates\n\nUse z.date() to validate Date instances.\n\nz.date().safeParse(new Date()); // success: true\nz.date().safeParse(\"2022-01-12T00:00:00.000Z\"); // success: false\n\nYou can customize certain error messages when creating a date schema.\n\nconst myDateSchema = z.date({\n  required_error: \"Please select a date and time\",\n  invalid_type_error: \"That's not a date!\",\n});\n\nZod provides a handful of date-specific validations.\n\nz.date().min(new Date(\"1900-01-01\"), { message: \"Too old\" });\nz.date().max(new Date(), { message: \"Too young!\" });\n\nCoercion to Date\n\nSince zod 3.20, use z.coerce.date() to pass the input through new Date(input).\n\nconst dateSchema = z.coerce.date();\ntype DateSchema = z.infer<typeof dateSchema>;\n// type DateSchema = Date\n\n/* valid dates */\nconsole.log(dateSchema.safeParse(\"2023-01-10T00:00:00.000Z\").success); // true\nconsole.log(dateSchema.safeParse(\"2023-01-10\").success); // true\nconsole.log(dateSchema.safeParse(\"1/10/23\").success); // true\nconsole.log(dateSchema.safeParse(new Date(\"1/10/23\")).success); // true\n\n/* invalid dates */\nconsole.log(dateSchema.safeParse(\"2023-13-10\").success); // false\nconsole.log(dateSchema.safeParse(\"0000-00-00\").success); // false\n\nFor older zod versions, use z.preprocess like described in this thread.\n\nZod enums\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\ntype FishEnum = z.infer<typeof FishEnum>;\n// 'Salmon' | 'Tuna' | 'Trout'\n\nz.enum is a Zod-native way to declare a schema with a fixed set of allowable string values. Pass the array of values directly into z.enum(). Alternatively, use as const to define your enum values as a tuple of strings. See the const assertion docs for details.\n\nconst VALUES = [\"Salmon\", \"Tuna\", \"Trout\"] as const;\nconst FishEnum = z.enum(VALUES);\n\nThis is not allowed, since Zod isn't able to infer the exact values of each element.\n\nconst fish = [\"Salmon\", \"Tuna\", \"Trout\"];\nconst FishEnum = z.enum(fish);\n\nAutocompletion\n\nTo get autocompletion with a Zod enum, use the .enum property of your schema:\n\nFishEnum.enum.Salmon; // => autocompletes\n\nFishEnum.enum;\n/*\n=> {\n  Salmon: \"Salmon\",\n  Tuna: \"Tuna\",\n  Trout: \"Trout\",\n}\n*/\n\nYou can also retrieve the list of options as a tuple with the .options property:\n\nFishEnum.options; // [\"Salmon\", \"Tuna\", \"Trout\"];\nNative enums\n\nZod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use z.nativeEnum().\n\nNumeric enums\n\nenum Fruits {\n  Apple,\n  Banana,\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // passes\nFruitEnum.parse(Fruits.Banana); // passes\nFruitEnum.parse(0); // passes\nFruitEnum.parse(1); // passes\nFruitEnum.parse(3); // fails\n\nString enums\n\nenum Fruits {\n  Apple = \"apple\",\n  Banana = \"banana\",\n  Cantaloupe, // you can mix numerical and string enums\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // passes\nFruitEnum.parse(Fruits.Cantaloupe); // passes\nFruitEnum.parse(\"apple\"); // passes\nFruitEnum.parse(\"banana\"); // passes\nFruitEnum.parse(0); // passes\nFruitEnum.parse(\"Cantaloupe\"); // fails\n\nConst enums\n\nThe .nativeEnum() function works for as const objects as well. ⚠️ as const requires TypeScript 3.4+!\n\nconst Fruits = {\n  Apple: \"apple\",\n  Banana: \"banana\",\n  Cantaloupe: 3,\n} as const;\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // \"apple\" | \"banana\" | 3\n\nFruitEnum.parse(\"apple\"); // passes\nFruitEnum.parse(\"banana\"); // passes\nFruitEnum.parse(3); // passes\nFruitEnum.parse(\"Cantaloupe\"); // fails\n\nYou can access the underlying object with the .enum property:\n\nFruitEnum.enum.Apple; // \"apple\"\nOptionals\n\nYou can make any schema optional with z.optional(). This wraps the schema in a ZodOptional instance and returns the result.\n\nconst schema = z.optional(z.string());\n\nschema.parse(undefined); // => returns undefined\ntype A = z.infer<typeof schema>; // string | undefined\n\nFor convenience, you can also call the .optional() method on an existing schema.\n\nconst user = z.object({\n  username: z.string().optional(),\n});\ntype C = z.infer<typeof user>; // { username?: string | undefined };\n\nYou can extract the wrapped schema from a ZodOptional instance with .unwrap().\n\nconst stringSchema = z.string();\nconst optionalString = stringSchema.optional();\noptionalString.unwrap() === stringSchema; // true\nNullables\n\nSimilarly, you can create nullable types with z.nullable().\n\nconst nullableString = z.nullable(z.string());\nnullableString.parse(\"asdf\"); // => \"asdf\"\nnullableString.parse(null); // => null\n\nOr use the .nullable() method.\n\nconst E = z.string().nullable(); // equivalent to nullableString\ntype E = z.infer<typeof E>; // string | null\n\nExtract the inner schema with .unwrap().\n\nconst stringSchema = z.string();\nconst nullableString = stringSchema.nullable();\nnullableString.unwrap() === stringSchema; // true\nObjects\n// all properties are required by default\nconst Dog = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n\n// extract the inferred type like this\ntype Dog = z.infer<typeof Dog>;\n\n// equivalent to:\ntype Dog = {\n  name: string;\n  age: number;\n};\n.shape\n\nUse .shape to access the schemas for a particular key.\n\nDog.shape.name; // => string schema\nDog.shape.age; // => number schema\n.keyof\n\nUse .keyof to create a ZodEnum schema from the keys of an object schema.\n\nconst keySchema = Dog.keyof();\nkeySchema; // ZodEnum<[\"name\", \"age\"]>\n.extend\n\nYou can add additional fields to an object schema with the .extend method.\n\nconst DogWithBreed = Dog.extend({\n  breed: z.string(),\n});\n\nYou can use .extend to overwrite fields! Be careful with this power!\n\n.merge\n\nEquivalent to A.extend(B.shape).\n\nconst BaseTeacher = z.object({ students: z.array(z.string()) });\nconst HasID = z.object({ id: z.string() });\n\nconst Teacher = BaseTeacher.merge(HasID);\ntype Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }\n\nIf the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the \"unknownKeys\" policy (strip/strict/passthrough) and the catchall schema of B.\n\n.pick/.omit\n\nInspired by TypeScript's built-in Pick and Omit utility types, all Zod object schemas have .pick and .omit methods that return a modified version. Consider this Recipe schema:\n\nconst Recipe = z.object({\n  id: z.string(),\n  name: z.string(),\n  ingredients: z.array(z.string()),\n});\n\nTo only keep certain keys, use .pick .\n\nconst JustTheName = Recipe.pick({ name: true });\ntype JustTheName = z.infer<typeof JustTheName>;\n// => { name: string }\n\nTo remove certain keys, use .omit .\n\nconst NoIDRecipe = Recipe.omit({ id: true });\n\ntype NoIDRecipe = z.infer<typeof NoIDRecipe>;\n// => { name: string, ingredients: string[] }\n.partial\n\nInspired by the built-in TypeScript utility type Partial, the .partial method makes all properties optional.\n\nStarting from this object:\n\nconst user = z.object({\n  email: z.string(),\n  username: z.string(),\n});\n// { email: string; username: string }\n\nWe can create a partial version:\n\nconst partialUser = user.partial();\n// { email?: string | undefined; username?: string | undefined }\n\nYou can also specify which properties to make optional:\n\nconst optionalEmail = user.partial({\n  email: true,\n});\n/*\n{\n  email?: string | undefined;\n  username: string\n}\n*/\n.deepPartial\n\nThe .partial method is shallow — it only applies one level deep. There is also a \"deep\" version:\n\nconst user = z.object({\n  username: z.string(),\n  location: z.object({\n    latitude: z.number(),\n    longitude: z.number(),\n  }),\n  strings: z.array(z.object({ value: z.string() })),\n});\n\nconst deepPartialUser = user.deepPartial();\n\n/*\n{\n  username?: string | undefined,\n  location?: {\n    latitude?: number | undefined;\n    longitude?: number | undefined;\n  } | undefined,\n  strings?: { value?: string}[]\n}\n*/\n\nImportant limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.\n\n.required\n\nContrary to the .partial method, the .required method makes all properties required.\n\nStarting from this object:\n\nconst user = z\n  .object({\n    email: z.string(),\n    username: z.string(),\n  })\n  .partial();\n// { email?: string | undefined; username?: string | undefined }\n\nWe can create a required version:\n\nconst requiredUser = user.required();\n// { email: string; username: string }\n\nYou can also specify which properties to make required:\n\nconst requiredEmail = user.required({\n  email: true,\n});\n/*\n{\n  email: string;\n  username?: string | undefined;\n}\n*/\n.passthrough\n\nBy default Zod object schemas strip out unrecognized keys during parsing.\n\nconst person = z.object({\n  name: z.string(),\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\" }\n// extraKey has been stripped\n\nInstead, if you want to pass through unknown keys, use .passthrough() .\n\nperson.passthrough().parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\", extraKey: 61 }\n.strict\n\nBy default Zod object schemas strip out unrecognized keys during parsing. You can disallow unknown keys with .strict() . If there are any unknown keys in the input, Zod will throw an error.\n\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .strict();\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => throws ZodError\n.strip\n\nYou can use the .strip method to reset an object schema to the default behavior (stripping unrecognized keys).\n\n.catchall\n\nYou can pass a \"catchall\" schema into an object schema. All unknown keys will be validated against it.\n\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .catchall(z.number());\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: 61, // works fine\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: false, // fails\n});\n// => throws ZodError\n\nUsing .catchall() obviates .passthrough() , .strip() , or .strict(). All keys are now considered \"known\".\n\nArrays\nconst stringArray = z.array(z.string());\n\n// equivalent\nconst stringArray = z.string().array();\n\nBe careful with the .array() method. It returns a new ZodArray instance. This means the order in which you call methods matters. For instance:\n\nz.string().optional().array(); // (string | undefined)[]\nz.string().array().optional(); // string[] | undefined\n.element\n\nUse .element to access the schema for an element of the array.\n\nstringArray.element; // => string schema\n.nonempty\n\nIf you want to ensure that an array contains at least one element, use .nonempty().\n\nconst nonEmptyStrings = z.string().array().nonempty();\n// the inferred type is now\n// [string, ...string[]]\n\nnonEmptyStrings.parse([]); // throws: \"Array cannot be empty\"\nnonEmptyStrings.parse([\"Ariana Grande\"]); // passes\n\nYou can optionally specify a custom error message:\n\n// optional custom error message\nconst nonEmptyStrings = z.string().array().nonempty({\n  message: \"Can't be empty!\",\n});\n.min/.max/.length\nz.string().array().min(5); // must contain 5 or more items\nz.string().array().max(5); // must contain 5 or fewer items\nz.string().array().length(5); // must contain 5 items exactly\n\nUnlike .nonempty() these methods do not change the inferred type.\n\nTuples\n\nUnlike arrays, tuples have a fixed number of elements and each element can have a different type.\n\nconst athleteSchema = z.tuple([\n  z.string(), // name\n  z.number(), // jersey number\n  z.object({\n    pointsScored: z.number(),\n  }), // statistics\n]);\n\ntype Athlete = z.infer<typeof athleteSchema>;\n// type Athlete = [string, number, { pointsScored: number }]\n\nA variadic (\"rest\") argument can be added with the .rest method.\n\nconst variadicTuple = z.tuple([z.string()]).rest(z.number());\nconst result = variadicTuple.parse([\"hello\", 1, 2, 3]);\n// => [string, ...number[]];\nUnions\n\nZod includes a built-in z.union method for composing \"OR\" types.\n\nconst stringOrNumber = z.union([z.string(), z.number()]);\n\nstringOrNumber.parse(\"foo\"); // passes\nstringOrNumber.parse(14); // passes\n\nZod will test the input against each of the \"options\" in order and return the first value that validates successfully.\n\nFor convenience, you can also use the .or method:\n\nconst stringOrNumber = z.string().or(z.number());\n\nOptional string validation:\n\nTo validate an optional form input, you can union the desired string validation with an empty string literal.\n\nThis example validates an input that is optional but needs to contain a valid URL:\n\nconst optionalUrl = z.union([z.string().url().nullish(), z.literal(\"\")]);\n\nconsole.log(optionalUrl.safeParse(undefined).success); // true\nconsole.log(optionalUrl.safeParse(null).success); // true\nconsole.log(optionalUrl.safeParse(\"\").success); // true\nconsole.log(optionalUrl.safeParse(\"https://zod.dev\").success); // true\nconsole.log(optionalUrl.safeParse(\"not a valid url\").success); // false\nDiscriminated unions\n\nA discriminated union is a union of object schemas that all share a particular key.\n\ntype MyUnion =\n  | { status: \"success\"; data: string }\n  | { status: \"failed\"; error: Error };\n\nSuch unions can be represented with the z.discriminatedUnion method. This enables faster evaluation, because Zod can check the discriminator key (status in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.\n\nWith the basic union method, the input is tested against each of the provided \"options\", and in the case of invalidity, issues for all the \"options\" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the \"options\", testing against it, and showing only the issues related to this \"option\".\n\nconst myUnion = z.discriminatedUnion(\"status\", [\n  z.object({ status: z.literal(\"success\"), data: z.string() }),\n  z.object({ status: z.literal(\"failed\"), error: z.instanceof(Error) }),\n]);\n\nmyUnion.parse({ status: \"success\", data: \"yippie ki yay\" });\nRecords\n\nRecord schemas are used to validate types such as { [k: string]: number }.\n\nIf you want to validate the values of an object against some schema but don't care about the keys, use z.record(valueType):\n\nconst NumberCache = z.record(z.number());\n\ntype NumberCache = z.infer<typeof NumberCache>;\n// => { [k: string]: number }\n\nThis is particularly useful for storing or caching items by ID.\n\nconst userSchema = z.object({ name: z.string() });\nconst userStoreSchema = z.record(userSchema);\n\ntype UserStore = z.infer<typeof userStoreSchema>;\n// => type UserStore = { [ x: string ]: { name: string } }\n\nconst userStore: UserStore = {};\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  name: \"Carlotta\",\n}; // passes\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  whatever: \"Ice cream sundae\",\n}; // TypeError\nRecord key type\n\nIf you want to validate both the keys and the values, use z.record(keyType, valueType):\n\nconst NoEmptyKeysSchema = z.record(z.string().min(1), z.number());\nNoEmptyKeysSchema.parse({ count: 1 }); // => { 'count': 1 }\nNoEmptyKeysSchema.parse({ \"\": 1 }); // fails\n\n(Notice how when passing two arguments, valueType is the second argument)\n\nA note on numerical keys\n\nWhile z.record(keyType, valueType) is able to accept numerical key types and TypeScript's built-in Record type is Record<KeyType, ValueType>, it's hard to represent the TypeScript type Record<number, any> in Zod.\n\nAs it turns out, TypeScript's behavior surrounding [k: number] is a little unintuitive:\n\nconst testMap: { [k: number]: string } = {\n  1: \"one\",\n};\n\nfor (const key in testMap) {\n  console.log(`${key}: ${typeof key}`);\n}\n// prints: `1: string`\n\nAs you can see, JavaScript automatically casts all object keys to strings under the hood. Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.\n\nMaps\nconst stringNumberMap = z.map(z.string(), z.number());\n\ntype StringNumberMap = z.infer<typeof stringNumberMap>;\n// type StringNumberMap = Map<string, number>\nSets\nconst numberSet = z.set(z.number());\ntype NumberSet = z.infer<typeof numberSet>;\n// type NumberSet = Set<number>\n\nSet schemas can be further constrained with the following utility methods.\n\nz.set(z.string()).nonempty(); // must contain at least one item\nz.set(z.string()).min(5); // must contain 5 or more items\nz.set(z.string()).max(5); // must contain 5 or fewer items\nz.set(z.string()).size(5); // must contain 5 items exactly\nIntersections\n\nIntersections are useful for creating \"logical AND\" types. This is useful for intersecting two object types.\n\nconst Person = z.object({\n  name: z.string(),\n});\n\nconst Employee = z.object({\n  role: z.string(),\n});\n\nconst EmployedPerson = z.intersection(Person, Employee);\n\n// equivalent to:\nconst EmployedPerson = Person.and(Employee);\n\nThough in many cases, it is recommended to use A.merge(B) to merge two objects. The .merge method returns a new ZodObject instance, whereas A.and(B) returns a less useful ZodIntersection instance that lacks common object methods like pick and omit.\n\nconst a = z.union([z.number(), z.string()]);\nconst b = z.union([z.number(), z.boolean()]);\nconst c = z.intersection(a, b);\n\ntype c = z.infer<typeof c>; // => number\nRecursive types\n\nYou can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a \"type hint\".\n\nconst baseCategorySchema = z.object({\n  name: z.string(),\n});\n\ntype Category = z.infer<typeof baseCategorySchema> & {\n  subcategories: Category[];\n};\n\nconst categorySchema: z.ZodType<Category> = baseCategorySchema.extend({\n  subcategories: z.lazy(() => categorySchema.array()),\n});\n\ncategorySchema.parse({\n  name: \"People\",\n  subcategories: [\n    {\n      name: \"Politicians\",\n      subcategories: [\n        {\n          name: \"Presidents\",\n          subcategories: [],\n        },\n      ],\n    },\n  ],\n}); // passes\n\nThanks to crasite for this example.\n\nZodType with ZodEffects\n\nWhen using z.ZodType with z.ZodEffects ( .refine, .transform, preprocess, etc... ), you will need to define the input and output types of the schema. z.ZodType<Output, z.ZodTypeDef, Input>\n\nconst isValidId = (id: string): id is `${string}/${string}` =>\n  id.split(\"/\").length === 2;\n\nconst baseSchema = z.object({\n  id: z.string().refine(isValidId),\n});\n\ntype Input = z.input<typeof baseSchema> & {\n  children: Input[];\n};\n\ntype Output = z.output<typeof baseSchema> & {\n  children: Output[];\n};\n\nconst schema: z.ZodType<Output, z.ZodTypeDef, Input> = baseSchema.extend({\n  children: z.lazy(() => schema.array()),\n});\n\nThanks to marcus13371337 and JoelBeeldi for this example.\n\nJSON type\n\nIf you want to validate any JSON value, you can use the snippet below.\n\nconst literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\ntype Literal = z.infer<typeof literalSchema>;\ntype Json = Literal | { [key: string]: Json } | Json[];\nconst jsonSchema: z.ZodType<Json> = z.lazy(() =>\n  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])\n);\n\njsonSchema.parse(data);\n\nThanks to ggoodman for suggesting this.\n\nCyclical objects\n\nDespite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop.\n\nPromises\nconst numberPromise = z.promise(z.number());\n\n\"Parsing\" works a little differently with promise schemas. Validation happens in two parts:\n\nZod synchronously checks that the input is an instance of Promise (i.e. an object with .then and .catch methods.).\nZod uses .then to attach an additional validation step onto the existing Promise. You'll have to use .catch on the returned Promise to handle validation failures.\nnumberPromise.parse(\"tuna\");\n// ZodError: Non-Promise type: string\n\nnumberPromise.parse(Promise.resolve(\"tuna\"));\n// => Promise<number>\n\nconst test = async () => {\n  await numberPromise.parse(Promise.resolve(\"tuna\"));\n  // ZodError: Non-number type: string\n\n  await numberPromise.parse(Promise.resolve(3.14));\n  // => 3.14\n};\nInstanceof\n\nYou can use z.instanceof to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.\n\nclass Test {\n  name: string;\n}\n\nconst TestSchema = z.instanceof(Test);\n\nconst blob: any = \"whatever\";\nTestSchema.parse(new Test()); // passes\nTestSchema.parse(\"blob\"); // throws\nFunctions\n\nZod also lets you define \"function schemas\". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and \"business logic\".\n\nYou can create a function schema with z.function(args, returnType) .\n\nconst myFunction = z.function();\n\ntype myFunction = z.infer<typeof myFunction>;\n// => ()=>unknown\n\nDefine inputs and outputs.\n\nconst myFunction = z\n  .function()\n  .args(z.string(), z.number()) // accepts an arbitrary number of arguments\n  .returns(z.boolean());\n\ntype myFunction = z.infer<typeof myFunction>;\n// => (arg0: string, arg1: number)=>boolean\n\nFunction schemas have an .implement() method which accepts a function and returns a new function that automatically validates its inputs and outputs.\n\nconst trimmedLength = z\n  .function()\n  .args(z.string()) // accepts an arbitrary number of arguments\n  .returns(z.number())\n  .implement((x) => {\n    // TypeScript knows x is a string!\n    return x.trim().length;\n  });\n\ntrimmedLength(\"sandwich\"); // => 8\ntrimmedLength(\" asdf \"); // => 4\n\nIf you only care about validating inputs, just don't call the .returns() method. The output type will be inferred from the implementation.\n\nYou can use the special z.void() option if your function doesn't return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.)\n\nconst myFunction = z\n  .function()\n  .args(z.string())\n  .implement((arg) => {\n    return [arg.length];\n  });\n\nmyFunction; // (arg: string)=>number[]\n\nExtract the input and output schemas from a function schema.\n\nmyFunction.parameters();\n// => ZodTuple<[ZodString, ZodNumber]>\n\nmyFunction.returnType();\n// => ZodBoolean\nPreprocess\n\nZod now supports primitive coercion without the need for .preprocess(). See the coercion docs for more information.\n\nTypically Zod operates under a \"parse then transform\" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the .transform docs.)\n\nBut sometimes you want to apply some transform to the input before parsing happens. A common use case: type coercion. Zod enables this with the z.preprocess().\n\nconst castToString = z.preprocess((val) => String(val), z.string());\n\nThis returns a ZodEffects instance. ZodEffects is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.\n\nCustom schemas\n\nYou can create a Zod schema for any TypeScript type by using z.custom(). This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.\n\nconst px = z.custom<`${number}px`>((val) => {\n  return typeof val === \"string\" ? /^\\d+px$/.test(val) : false;\n});\n\ntype px = z.infer<typeof px>; // `${number}px`\n\npx.parse(\"42px\"); // \"42px\"\npx.parse(\"42vw\"); // throws;\n\nIf you don't provide a validation function, Zod will allow any value. This can be dangerous!\n\nz.custom<{ arg: string }>(); // performs no validation\n\nYou can customize the error message and other options by passing a second argument. This parameter works the same way as the params parameter of .refine.\n\nz.custom<...>((val) => ..., \"custom error message\");\nSchema methods\n\nAll Zod schemas contain certain methods.\n\n.parse\n\n.parse(data: unknown): T\n\nGiven any Zod schema, you can call its .parse method to check data is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.\n\nIMPORTANT: The value returned by .parse is a deep clone of the variable you passed in.\n\nconst stringSchema = z.string();\n\nstringSchema.parse(\"fish\"); // => returns \"fish\"\nstringSchema.parse(12); // throws error\n.parseAsync\n\n.parseAsync(data:unknown): Promise<T>\n\nIf you use asynchronous refinements or transforms (more on those later), you'll need to use .parseAsync.\n\nconst stringSchema = z.string().refine(async (val) => val.length <= 8);\n\nawait stringSchema.parseAsync(\"hello\"); // => returns \"hello\"\nawait stringSchema.parseAsync(\"hello world\"); // => throws error\n.safeParse\n\n.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }\n\nIf you don't want Zod to throw errors when validation fails, use .safeParse. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.\n\nstringSchema.safeParse(12);\n// => { success: false; error: ZodError }\n\nstringSchema.safeParse(\"billie\");\n// => { success: true; data: 'billie' }\n\nThe result is a discriminated union, so you can handle errors very conveniently:\n\nconst result = stringSchema.safeParse(\"billie\");\nif (!result.success) {\n  // handle error then return\n  result.error;\n} else {\n  // do something\n  result.data;\n}\n.safeParseAsync\n\nAlias: .spa\n\nAn asynchronous version of safeParse.\n\nawait stringSchema.safeParseAsync(\"billie\");\n\nFor convenience, this has been aliased to .spa:\n\nawait stringSchema.spa(\"billie\");\n.refine\n\n.refine(validator: (data:T)=>any, params?: RefineParams)\n\nZod lets you provide custom validation logic via refinements. (For advanced features like creating multiple issues and customizing error codes, see .superRefine.)\n\nZod was designed to mirror TypeScript as closely as possible. But there are many so-called \"refinement types\" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.\n\nFor example, you can define a custom validation check on any Zod schema with .refine :\n\nconst myString = z.string().refine((val) => val.length <= 255, {\n  message: \"String can't be more than 255 characters\",\n});\n\n⚠️ Refinement functions should not throw. Instead they should return a falsy value to signal failure.\n\nArguments\n\nAs you can see, .refine takes two arguments.\n\nThe first is the validation function. This function takes one input (of type T — the inferred type of the schema) and returns any. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)\nThe second argument accepts some options. You can use this to customize certain error-handling behavior:\ntype RefineParams = {\n  // override error message\n  message?: string;\n\n  // appended to error path\n  path?: (string | number)[];\n\n  // params object you can use to customize message\n  // in error map\n  params?: object;\n};\n\nFor advanced cases, the second argument can also be a function that returns RefineParams.\n\nconst longString = z.string().refine(\n  (val) => val.length > 10,\n  (val) => ({ message: `${val} is not more than 10 characters` })\n);\nCustomize error path\nconst passwordForm = z\n  .object({\n    password: z.string(),\n    confirm: z.string(),\n  })\n  .refine((data) => data.password === data.confirm, {\n    message: \"Passwords don't match\",\n    path: [\"confirm\"], // path of error\n  });\n\npasswordForm.parse({ password: \"asdf\", confirm: \"qwer\" });\n\nBecause you provided a path parameter, the resulting error will be:\n\nZodError {\n  issues: [{\n    \"code\": \"custom\",\n    \"path\": [ \"confirm\" ],\n    \"message\": \"Passwords don't match\"\n  }]\n}\nAsynchronous refinements\n\nRefinements can also be async:\n\nconst userId = z.string().refine(async (id) => {\n  // verify that ID exists in database\n  return true;\n});\n\n⚠️ If you use async refinements, you must use the .parseAsync method to parse data! Otherwise Zod will throw an error.\n\nRelationship to transforms\n\nTransforms and refinements can be interleaved:\n\nz.string()\n  .transform((val) => val.length)\n  .refine((val) => val > 25);\n.superRefine\n\nThe .refine method is actually syntactic sugar atop a more versatile (and verbose) method called superRefine. Here's an example:\n\nconst Strings = z.array(z.string()).superRefine((val, ctx) => {\n  if (val.length > 3) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_big,\n      maximum: 3,\n      type: \"array\",\n      inclusive: true,\n      message: \"Too many items 😡\",\n    });\n  }\n\n  if (val.length !== new Set(val).size) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: `No duplicates allowed.`,\n    });\n  }\n});\n\nYou can add as many issues as you like. If ctx.addIssue is not called during the execution of the function, validation passes.\n\nNormally refinements always create issues with a ZodIssueCode.custom error code, but with superRefine it's possible to throw issues of any ZodIssueCode. Each issue code is described in detail in the Error Handling guide: ERROR_HANDLING.md.\n\nAbort early\n\nBy default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to abort early to prevent later refinements from being executed. To achieve this, pass the fatal flag to ctx.addIssue and return z.NEVER.\n\nconst schema = z.number().superRefine((val, ctx) => {\n  if (val < 10) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"should be >= 10\",\n      fatal: true,\n    });\n\n    return z.NEVER;\n  }\n\n  if (val !== 12) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"should be twelve\",\n    });\n  }\n});\nType refinements\n\nIf you provide a type predicate to .refine() or .superRefine(), the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:\n\nconst schema = z\n  .object({\n    first: z.string(),\n    second: z.number(),\n  })\n  .nullable()\n  .superRefine((arg, ctx): arg is { first: string; second: number } => {\n    if (!arg) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom, // customize your issue\n        message: \"object should exist\",\n      });\n    }\n\n    return z.NEVER; // The return value is not used, but we need to return something to satisfy the typing\n  })\n  // here, TS knows that arg is not null\n  .refine((arg) => arg.first === \"bob\", \"`first` is not `bob`!\");\n\n⚠️ You must use ctx.addIssue() instead of returning a boolean value to indicate whether the validation passes. If ctx.addIssue is not called during the execution of the function, validation passes.\n\n.transform\n\nTo transform data after parsing, use the transform method.\n\nconst stringToNumber = z.string().transform((val) => val.length);\n\nstringToNumber.parse(\"string\"); // => 6\nChaining order\n\nNote that stringToNumber above is an instance of the ZodEffects subclass. It is NOT an instance of ZodString. If you want to use the built-in methods of ZodString (e.g. .email()) you must apply those methods before any transforms.\n\nconst emailToDomain = z\n  .string()\n  .email()\n  .transform((val) => val.split(\"@\")[1]);\n\nemailToDomain.parse(\"colinhacks@example.com\"); // => example.com\nValidating during transform\n\nThe .transform method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining transform and refine.\n\nAs with .superRefine, the transform function receives a ctx object with an addIssue method that can be used to register validation issues.\n\nconst numberInString = z.string().transform((val, ctx) => {\n  const parsed = parseInt(val);\n  if (isNaN(parsed)) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: \"Not a number\",\n    });\n\n    // This is a special symbol you can use to\n    // return early from the transform function.\n    // It has type `never` so it does not affect the\n    // inferred return type.\n    return z.NEVER;\n  }\n  return parsed;\n});\nRelationship to refinements\n\nTransforms and refinements can be interleaved. These will be executed in the order they are declared.\n\nconst nameToGreeting = z\n  .string()\n  .transform((val) => val.toUpperCase())\n  .refine((val) => val.length > 15)\n  .transform((val) => `Hello ${val}`)\n  .refine((val) => val.indexOf(\"!\") === -1);\nAsync transforms\n\nTransforms can also be async.\n\nconst IdToUser = z\n  .string()\n  .uuid()\n  .transform(async (id) => {\n    return await getUserById(id);\n  });\n\n⚠️ If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.\n\n.default\n\nYou can use transforms to implement the concept of \"default values\" in Zod.\n\nconst stringWithDefault = z.string().default(\"tuna\");\n\nstringWithDefault.parse(undefined); // => \"tuna\"\n\nOptionally, you can pass a function into .default that will be re-executed whenever a default value needs to be generated:\n\nconst numberWithRandomDefault = z.number().default(Math.random);\n\nnumberWithRandomDefault.parse(undefined); // => 0.4413456736055323\nnumberWithRandomDefault.parse(undefined); // => 0.1871840107401901\nnumberWithRandomDefault.parse(undefined); // => 0.7223408162401552\n\nConceptually, this is how Zod processes default values:\n\nIf the input is undefined, the default value is returned\nOtherwise, the data is parsed using the base schema\n.describe\n\nUse .describe() to add a description property to the resulting schema.\n\nconst documentedString = z\n  .string()\n  .describe(\"A useful bit of text, if you know what to do with it.\");\ndocumentedString.description; // A useful bit of text…\n\nThis can be useful for documenting a field, for example in a JSON Schema using a library like zod-to-json-schema).\n\n.catch\n\nUse .catch() to provide a \"catch value\" to be returned in the event of a parsing error.\n\nconst numberWithCatch = z.number().catch(42);\n\nnumberWithCatch.parse(5); // => 5\nnumberWithCatch.parse(\"tuna\"); // => 42\n\nOptionally, you can pass a function into .catch that will be re-executed whenever a default value needs to be generated. A ctx object containing the caught error will be passed into this function.\n\nconst numberWithRandomCatch = z.number().catch((ctx) => {\n  ctx.error; // the caught ZodError\n  return Math.random();\n});\n\nnumberWithRandomCatch.parse(\"sup\"); // => 0.4413456736055323\nnumberWithRandomCatch.parse(\"sup\"); // => 0.1871840107401901\nnumberWithRandomCatch.parse(\"sup\"); // => 0.7223408162401552\n\nConceptually, this is how Zod processes \"catch values\":\n\nThe data is parsed using the base schema\nIf the parsing fails, the \"catch value\" is returned\n.optional\n\nA convenience method that returns an optional version of a schema.\n\nconst optionalString = z.string().optional(); // string | undefined\n\n// equivalent to\nz.optional(z.string());\n.nullable\n\nA convenience method that returns a nullable version of a schema.\n\nconst nullableString = z.string().nullable(); // string | null\n\n// equivalent to\nz.nullable(z.string());\n.nullish\n\nA convenience method that returns a \"nullish\" version of a schema. Nullish schemas will accept both undefined and null. Read more about the concept of \"nullish\" in the TypeScript 3.7 release notes.\n\nconst nullishString = z.string().nullish(); // string | null | undefined\n\n// equivalent to\nz.string().nullable().optional();\n.array\n\nA convenience method that returns an array schema for the given type:\n\nconst stringArray = z.string().array(); // string[]\n\n// equivalent to\nz.array(z.string());\n.promise\n\nA convenience method for promise types:\n\nconst stringPromise = z.string().promise(); // Promise<string>\n\n// equivalent to\nz.promise(z.string());\n.or\n\nA convenience method for union types.\n\nconst stringOrNumber = z.string().or(z.number()); // string | number\n\n// equivalent to\nz.union([z.string(), z.number()]);\n.and\n\nA convenience method for creating intersection types.\n\nconst nameAndAge = z\n  .object({ name: z.string() })\n  .and(z.object({ age: z.number() })); // { name: string } & { age: number }\n\n// equivalent to\nz.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));\n.brand\n\n.brand<T>() => ZodBranded<this, B>\n\nTypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.\n\ntype Cat = { name: string };\ntype Dog = { name: string };\n\nconst petCat = (cat: Cat) => {};\nconst fido: Dog = { name: \"fido\" };\npetCat(fido); // works fine\n\nIn some cases, its can be desirable to simulate nominal typing inside TypeScript. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with branded types (AKA opaque types).\n\nconst Cat = z.object({ name: z.string() }).brand<\"Cat\">();\ntype Cat = z.infer<typeof Cat>;\n\nconst petCat = (cat: Cat) => {};\n\n// this works\nconst simba = Cat.parse({ name: \"simba\" });\npetCat(simba);\n\n// this doesn't\npetCat({ name: \"fido\" });\n\nUnder the hood, this works by attaching a \"brand\" to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.\n\nconst Cat = z.object({ name: z.string() }).brand<\"Cat\">();\ntype Cat = z.infer<typeof Cat>;\n// {name: string} & {[symbol]: \"Cat\"}\n\nNote that branded types do not affect the runtime result of .parse. It is a static-only construct.\n\n.readonly\n\n.readonly() => ZodReadonly<this>\n\nThis method returns a ZodReadonly schema instance that parses the input using the base schema, then calls Object.freeze() on the result. The inferred type is also marked as readonly.\n\nconst schema = z.object({ name: string }).readonly();\ntype schema = z.infer<typeof schema>;\n// Readonly<{name: string}>\n\nconst result = schema.parse({ name: \"fido\" });\nresult.name = \"simba\"; // error\n\nThe inferred type uses TypeScript's built-in readonly types when relevant.\n\nz.array(z.string()).readonly();\n// readonly string[]\n\nz.tuple([z.string(), z.number()]).readonly();\n// readonly [string, number]\n\nz.map(z.string(), z.date()).readonly();\n// ReadonlyMap<string, Date>\n\nz.set(z.string()).readonly();\n// ReadonlySet<Promise<string>>\n.pipe\n\nSchemas can be chained into validation \"pipelines\". It's useful for easily validating the result after a .transform():\n\nz.string()\n  .transform((val) => val.length)\n  .pipe(z.number().min(5));\n\nThe .pipe() method returns a ZodPipeline instance.\n\nYou can use .pipe() to fix common issues with z.coerce.\n\nYou can constrain the input to types that work well with your chosen coercion. Then use .pipe() to apply the coercion.\n\nwithout constrained input:\n\nconst toDate = z.coerce.date();\n\n// works intuitively\nconsole.log(toDate.safeParse(\"2023-01-01\").success); // true\n\n// might not be what you want\nconsole.log(toDate.safeParse(null).success); // true\n\nwith constrained input:\n\nconst datelike = z.union([z.number(), z.string(), z.date()]);\nconst datelikeToDate = datelike.pipe(z.coerce.date());\n\n// still works intuitively\nconsole.log(datelikeToDate.safeParse(\"2023-01-01\").success); // true\n\n// more likely what you want\nconsole.log(datelikeToDate.safeParse(null).success); // false\n\nYou can also use this technique to avoid coercions that throw uncaught errors.\n\nwithout constrained input:\n\nconst toBigInt = z.coerce.bigint();\n\n// works intuitively\nconsole.log(toBigInt.safeParse(\"42\")); // true\n\n// probably not what you want\nconsole.log(toBigInt.safeParse(null)); // throws uncaught error\n\nwith constrained input:\n\nconst toNumber = z.number().or(z.string()).pipe(z.coerce.number());\nconst toBigInt = z.bigint().or(toNumber).pipe(z.coerce.bigint());\n\n// still works intuitively\nconsole.log(toBigInt.safeParse(\"42\").success); // true\n\n// error handled by zod, more likely what you want\nconsole.log(toBigInt.safeParse(null).success); // false\nGuides and concepts\nType inference\n\nYou can extract the TypeScript type of any schema with z.infer<typeof mySchema> .\n\nconst A = z.string();\ntype A = z.infer<typeof A>; // string\n\nconst u: A = 12; // TypeError\nconst u: A = \"asdf\"; // compiles\n\nWhat about transforms?\n\nIn reality each Zod schema internally tracks two types: an input and an output. For most schemas (e.g. z.string()) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance z.string().transform(val => val.length) has an input of string and an output of number.\n\nYou can separately extract the input and output types like so:\n\nconst stringToNumber = z.string().transform((val) => val.length);\n\n// ⚠️ Important: z.infer returns the OUTPUT type!\ntype input = z.input<typeof stringToNumber>; // string\ntype output = z.output<typeof stringToNumber>; // number\n\n// equivalent to z.output!\ntype inferred = z.infer<typeof stringToNumber>; // number\nWriting generic functions\n\nWhen attempting to write a function that accepts a Zod schema as an input, it's common to try something like this:\n\nfunction makeSchemaOptional<T>(schema: z.ZodType<T>) {\n  return schema.optional();\n}\n\nThis approach has some issues. The schema variable in this function is typed as an instance of ZodType, which is an abstract class that all Zod schemas inherit from. This approach loses type information, namely which subclass the input actually is.\n\nconst arg = makeSchemaOptional(z.string());\narg.unwrap();\n\nA better approach is for the generic parameter to refer to the schema as a whole.\n\nfunction makeSchemaOptional<T extends z.ZodTypeAny>(schema: T) {\n  return schema.optional();\n}\n\nZodTypeAny is just a shorthand for ZodType<any, any, any>, a type that is broad enough to match any Zod schema.\n\nAs you can see, schema is now fully and properly typed.\n\nconst arg = makeSchemaOptional(z.string());\narg.unwrap(); // ZodString\nConstraining allowable inputs\n\nThe ZodType class has three generic parameters.\n\nclass ZodType<\n  Output = any,\n  Def extends ZodTypeDef = ZodTypeDef,\n  Input = Output\n> { ... }\n\nBy constraining these in your generic input, you can limit what schemas are allowable as inputs to your function:\n\nfunction makeSchemaOptional<T extends z.ZodType<string>>(schema: T) {\n  return schema.optional();\n}\n\nmakeSchemaOptional(z.string());\n// works fine\n\nmakeSchemaOptional(z.number());\n// Error: 'ZodNumber' is not assignable to parameter of type 'ZodType<string, ZodTypeDef, string>'\nError handling\n\nZod provides a subclass of Error called ZodError. ZodErrors contain an issues array containing detailed information about the validation problems.\n\nconst result = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!result.success) {\n  result.error.issues;\n  /* [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"string\",\n        \"received\": \"number\",\n        \"path\": [ \"name\" ],\n        \"message\": \"Expected string, received number\"\n      }\n  ] */\n}\n\nFor detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: ERROR_HANDLING.md\n\nZod's error reporting emphasizes completeness and correctness. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third-party library like zod-validation-error\n\nError formatting\n\nYou can use the .format() method to convert this error into a nested object.\n\nconst result = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!result.success) {\n  const formatted = result.error.format();\n  /* {\n    name: { _errors: [ 'Expected string, received number' ] }\n  } */\n\n  formatted.name?._errors;\n  // => [\"Expected string, received number\"]\n}\nComparison\n\nThere are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.\n\nJoi\n\nhttps://github.com/hapijs/joi\n\nDoesn't support static type inference 😕\n\nYup\n\nhttps://github.com/jquense/yup\n\nYup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.\n\nSupports casting and transforms\nAll object fields are optional by default\nMissing promise schemas\nMissing function schemas\nMissing union & intersection schemas\nio-ts\n\nhttps://github.com/gcanti/io-ts\n\nio-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.\n\nIn our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:\n\nimport * as t from \"io-ts\";\n\nconst A = t.type({\n  foo: t.string,\n});\n\nconst B = t.partial({\n  bar: t.number,\n});\n\nconst C = t.intersection([A, B]);\n\ntype C = t.TypeOf<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n\nYou must define the required and optional props in separate object validators, pass the optionals through t.partial (which marks all properties as optional), then combine them with t.intersection .\n\nConsider the equivalent in Zod:\n\nconst C = z.object({\n  foo: z.string(),\n  bar: z.number().optional(),\n});\n\ntype C = z.infer<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n\nThis more declarative API makes schema definitions vastly more concise.\n\nio-ts also requires the use of gcanti's functional programming library fp-ts to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on fp-ts necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the fp-ts nomenclature to use the library.\n\nSupports codecs with serialization & deserialization transforms\nSupports branded types\nSupports advanced functional programming, higher-kinded types, fp-ts compatibility\nMissing object methods: (pick, omit, partial, deepPartial, merge, extend)\nMissing nonempty arrays with proper typing ([T, ...T[]])\nMissing promise schemas\nMissing function schemas\nRuntypes\n\nhttps://github.com/pelotom/runtypes\n\nGood type inference support.\n\nSupports \"pattern matching\": computed properties that distribute over unions\nMissing object methods: (deepPartial, merge)\nMissing nonempty arrays with proper typing ([T, ...T[]])\nMissing promise schemas\nMissing error customization\nOw\n\nhttps://github.com/sindresorhus/ow\n\nOw is focused on function input validation. It's a library that makes it easy to express complicated assert statements, but it doesn't let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript's type system, whereas ow lets you validate several highly-specific types out of the box (e.g. int32Array , see full list in their README).\n\nIf you want to validate function inputs, use function schemas in Zod! It's a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won't be any unexpected data passed downstream."
  }
]
