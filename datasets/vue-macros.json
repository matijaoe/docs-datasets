[
  {
    "title": "booleanProp | Vue Macros",
    "url": "https://vue-macros.dev/features/boolean-prop.html",
    "html": "booleanProp\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nConvert <Comp checked /> to <Comp :checked=\"true\" />.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚ùå\nVolar Plugin\t‚úÖ\nUsage\n‚Äã\nvue\n<template>\n  <Comp checked />\n</template>\nvue\n<script setup lang=\"ts\">\n// Comp.vue\ndefineProps<{\n  checked?: any\n}>()\n</script>"
  },
  {
    "title": "jsxDirective | Vue Macros",
    "url": "https://vue-macros.dev/features/jsx-directive.html",
    "html": "jsxDirective\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nVue built-in directives for JSX.\n\nDirective\tVue 3\tVue 2\tVolar\nv-if\t‚úÖ\t‚úÖ\t‚úÖ\nv-else-if\t‚úÖ\t‚úÖ\t‚úÖ\nv-else\t‚úÖ\t‚úÖ\t‚úÖ\nv-for\t‚úÖ\t‚úÖ\t‚úÖ\nv-slot\t‚úÖ\t‚úÖ\t‚úÖ\nv-html\t‚úÖ\t‚úÖ\t/\nv-once\t‚úÖ\t‚ùå\t/\nv-memo\t‚úÖ\t‚ùå\t/\nUsage\n‚Äã\nvue\n<script setup lang=\"tsx\">\nimport Child from './Child.vue'\n\nconst { foo, list } = defineProps<{\n  foo: number\n  list: number[]\n}>()\n\ndefineRender(() => (\n  <>\n    <div v-if={foo === 0}>\n      <div v-if={foo === 0}>0-0</div>\n      <div v-else-if={foo === 1}>0-1</div>\n      <div v-else>0-2</div>\n    </div>\n\n    <div v-for={(i, index) in list} v-memo={[foo === i]} key={index}>\n      {i}\n    </div>\n\n    <Child v-slot={props}>{props}</Child>\n  </>\n))\n</script>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3,\n    \"plugins\": [\n      \"@vue-macros/volar/jsx-directive\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "exportRender | Vue Macros",
    "url": "https://vue-macros.dev/features/export-render.html",
    "html": "exportRender\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nTransform the default export statement, in <script setup> of Vue SFC, as a component render function.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚ùì\nVue 2\t‚úÖ\nVolar Plugin\t‚úÖ\n\nTIP\n\nThis feature depends on defineRender, and make sure defineRender is not disabled.\n\nUsage\n‚Äã\nvue\n<script setup lang=\"tsx\">\n// JSX passed directly\nexport default <div>ok</div>\n\n// Or using render function\nexport default () => <div>ok</div>\n</script>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3,\n    \"plugins\": [\n      \"@vue-macros/volar/export-render\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "exportExpose | Vue Macros",
    "url": "https://vue-macros.dev/features/export-expose.html",
    "html": "exportExpose\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nTransform export statement as defineExpose params in Vue SFC script-setup.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t?\nVue 2\t‚úÖ\nVolar Plugin\t‚úÖ\nUsage\n‚Äã\n\nSupport these syntaxes:\n\nlocal variable/function/class\nexport with alias\nexport from other file\nnamespace export\nrename export\n1. local variable/function/class\n‚Äã\nvue\n<script setup lang=\"ts\">\nexport const foo: string = 'foo',\n  bar = 10\nexport let baz: string | undefined\nexport var qux = fn()\nexport const { a, b, c } = { a: 1, b: 2, c: 3 }\n\nexport function fn() {}\nexport class A {}\n</script>\nCompiled Code\n2. export with alias\n‚Äã\nvue\n<script setup lang=\"ts\">\nexport { foo as foo1 }\n</script>\nCompiled Code\n3. export from other file\n‚Äã\nvue\n<script setup lang=\"ts\">\nexport { foo, type Foo, foo as bar } from './types'\n</script>\nCompiled Code\n4. namespace export\n‚Äã\nvue\n<script setup lang=\"ts\">\nexport * as foo from './types'\n</script>\nCompiled Code\n5. rename export\n‚Äã\nvue\n<script setup lang=\"ts\">\nconst foo = 1,\n  bar = 1\n\nexport { foo } from './types'\nexport * as bar from './types'\n</script>\nCompiled Code\nLimitations\n‚Äã\n\nCurrently does't support these following cases:\n\nts\n// 1. export all ‚ùå\nexport * from '../types'\n\n// 2. export default ‚ùå\nconst a = 'a'\nexport default a\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3,\n    \"plugins\": [\n      \"@vue-macros/volar/export-expose\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "exportProps | Vue Macros",
    "url": "https://vue-macros.dev/features/export-props.html",
    "html": "exportProps\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nSvelte-like Declaring props for Vue.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚ùì\nVue 2\t‚úÖ\nVolar Plugin\t‚úÖ\nUsage\n‚Äã\n\nUsing export syntax to declare props.\n\nvue\n<script setup lang=\"ts\">\nexport let foo: string\nexport const bar: number = 1 // with default value\n</script>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3,\n    \"plugins\": [\n      \"@vue-macros/volar/export-props\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "namedTemplate | Vue Macros",
    "url": "https://vue-macros.dev/features/named-template.html",
    "html": "namedTemplate\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nWARNING\n\nNot actively maintained now. Try createReusableTemplate instead.\n\nWith enabling namedTemplate, <template> can be referenced like a variable.\n\nSometimes we need to reverse the order of the very simple components, and don't want to give the features of Vue template up and use JSX/TSX. Then this feature is much helpful.\n\nIf you support this feature, you can go to the discussion and hit like üëç or comment.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nVue 3.3\t‚ùå\nNuxt 3\t‚ùå\nVue 2\t‚ùå\nTypeScript / Volar\t‚ùå\nBasic Usage\n‚Äã\nvue\n<script setup>\nconst pager = 'top'\n</script>\n\n<template name=\"pager\">\n  <span>This is pager</span>\n</template>\n\n<template>\n  <template v-if=\"pager === 'top'\">\n    <template is=\"pager\" />\n  </template>\n\n  <span>Here is data table</span>\n\n  <template v-if=\"pager === 'bottom'\">\n    <template is=\"pager\" />\n  </template>\n</template>\nKnown Usage\n‚Äã\nTypeScript / Volar support is not yet completed."
  },
  {
    "title": "Reactivity Transform | Vue Macros",
    "url": "https://vue-macros.dev/features/reactivity-transform.html",
    "html": "Reactivity Transform\n‚Äã\nStability: stable\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript / Volar\t‚úÖ\nInstallation Standalone Version\n‚Äã\n\nif you need Reactivity Transform feature only, the standalone version is more appropriate for you.\n\nInstallation\n‚Äã\nnpm\nyarn\npnpm\nbash\nnpm i -D @vue-macros/reactivity-transform\nVite\nRollup\nesbuild\nWebpack\nts\n// vite.config.ts\nimport ReactivityTransform from '@vue-macros/reactivity-transform/vite'\n\nexport default defineConfig({\n  plugins: [ReactivityTransform()],\n})\nTypeScript Support\n‚Äã\njson\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // ...\n    \"types\": [\"@vue-macros/reactivity-transform/macros-global\" /* ... */]\n  }\n}\nRefs vs. Reactive Variables\n‚Äã\n\nEver since the introduction of the Composition API, one of the primary unresolved questions is the use of refs vs. reactive objects. It's easy to lose reactivity when destructuring reactive objects, while it can be cumbersome to use .value everywhere when using refs. Also, .value is easy to miss if not using a type system.\n\nReactivity Transform is a compile-time transform that allows us to write code like this:\n\nvue\n<script setup>\nlet count = $ref(0)\n\nconsole.log(count)\n\nfunction increment() {\n  count++\n}\n</script>\n\n<template>\n  <button @click=\"increment\">{{ count }}</button>\n</template>\n\nThe $ref() method here is a compile-time macro: it is not an actual method that will be called at runtime. Instead, the Vue compiler uses it as a hint to treat the resulting count variable as a reactive variable.\n\nReactive variables can be accessed and re-assigned just like normal variables, but these operations are compiled into refs with .value. For example, the <script> part of the above component is compiled into:\n\njs\nimport { ref } from 'vue'\n\nlet count = ref(0)\n\nconsole.log(count.value)\n\nfunction increment() {\n  count.value++\n}\n\nEvery reactivity API that returns refs will have a $-prefixed macro equivalent. These APIs include:\n\nref -> $ref\ncomputed -> $computed\nshallowRef -> $shallowRef\ncustomRef -> $customRef\ntoRef -> $toRef\n\nThese macros are globally available and do not need to be imported when Reactivity Transform is enabled, but you can optionally import them from unplugin-vue-macros/macros or @vue-macros/reactivity-transform/macros-global if you want to be more explicit:\n\njs\nimport { $ref } from 'unplugin-vue-macros/macros'\n// for standalone version:\n// import { $ref } from '@vue-macros/reactivity-transform/macros-global'\n\nconst count = $ref(0)\nDestructuring with $()\n‚Äã\n\nIt is common for a composition function to return an object of refs, and use destructuring to retrieve these refs. For this purpose, reactivity transform provides the $() macro:\n\njs\nimport { useMouse } from '@vueuse/core'\n\nconst { x, y } = $(useMouse())\n\nconsole.log(x, y)\n\nCompiled output:\n\njs\nimport { toRef } from 'vue'\nimport { useMouse } from '@vueuse/core'\n\nconst __temp = useMouse(),\n  x = toRef(__temp, 'x'),\n  y = toRef(__temp, 'y')\n\nconsole.log(x.value, y.value)\n\nNote that if x is already a ref, toRef(__temp, 'x') will simply return it as-is and no additional ref will be created. If a destructured value is not a ref (e.g. a function), it will still work - the value will be wrapped in a ref so the rest of the code works as expected.\n\n$() destructure works on both reactive objects and plain objects containing refs.\n\nConvert Existing Refs to Reactive Variables with $()\n‚Äã\n\nIn some cases we may have wrapped functions that also return refs. However, the Vue compiler won't be able to know ahead of time that a function is going to return a ref. In such cases, the $() macro can also be used to convert any existing refs into reactive variables:\n\njs\nfunction myCreateRef() {\n  return ref(0)\n}\n\nconst count = $(myCreateRef())\nReactive Props Destructure\n‚Äã\n\nThere are two pain points with the current defineProps() usage in <script setup>:\n\nSimilar to .value, you need to always access props as props.x in order to retain reactivity. This means you cannot destructure defineProps because the resulting destructured variables are not reactive and will not update.\n\nWhen using the type-only props declaration, there is no easy way to declare default values for the props. We introduced the withDefaults() API for this exact purpose, but it's still clunky to use.\n\nWe can address these issues by applying a compile-time transform when defineProps is used with destructuring, similar to what we saw earlier with $():\n\nhtml\n<script setup lang=\"ts\">\n  interface Props {\n    msg: string\n    count?: number\n    foo?: string\n  }\n\n  const {\n    msg,\n    // default value just works\n    count = 1,\n    // local aliasing also just works\n    // here we are aliasing `props.foo` to `bar`\n    foo: bar,\n  } = defineProps<Props>()\n\n  watchEffect(() => {\n    // will log whenever the props change\n    console.log(msg, count, bar)\n  })\n</script>\n\nThe above will be compiled into the following runtime declaration equivalent:\n\njs\nexport default {\n  props: {\n    msg: { type: String, required: true },\n    count: { type: Number, default: 1 },\n    foo: String,\n  },\n  setup(props) {\n    watchEffect(() => {\n      console.log(props.msg, props.count, props.foo)\n    })\n  },\n}\nRetaining Reactivity Across Function Boundaries\n‚Äã\n\nWhile reactive variables relieve us from having to use .value everywhere, it creates an issue of \"reactivity loss\" when we pass reactive variables across function boundaries. This can happen in two cases:\n\nPassing into function as argument\n‚Äã\n\nGiven a function that expects a ref as an argument, e.g.:\n\nts\nfunction trackChange(x: Ref<number>) {\n  watch(x, (x) => {\n    console.log('x changed!')\n  })\n}\n\nconst count = $ref(0)\ntrackChange(count) // doesn't work!\n\nThe above case will not work as expected because it compiles to:\n\nts\nconst count = ref(0)\ntrackChange(count.value)\n\nHere count.value is passed as a number, whereas trackChange expects an actual ref. This can be fixed by wrapping count with $$() before passing it:\n\ndiff\nlet count = $ref(0)\n- trackChange(count)\n+ trackChange($$(count))\n\nThe above compiles to:\n\njs\nimport { ref } from 'vue'\n\nconst count = ref(0)\ntrackChange(count)\n\nAs we can see, $$() is a macro that serves as an escape hint: reactive variables inside $$() will not get .value appended.\n\nReturning inside function scope\n‚Äã\n\nReactivity can also be lost if reactive variables are used directly in a returned expression:\n\nts\nfunction useMouse() {\n  const x = $ref(0)\n  const y = $ref(0)\n\n  // listen to mousemove...\n\n  // doesn't work!\n  return {\n    x,\n    y,\n  }\n}\n\nThe above return statement compiles to:\n\nts\nreturn {\n  x: x.value,\n  y: y.value,\n}\n\nIn order to retain reactivity, we should be returning the actual refs, not the current value at return time.\n\nAgain, we can use $$() to fix this. In this case, $$() can be used directly on the returned object - any reference to reactive variables inside the $$() call will retain the reference to their underlying refs:\n\nts\nfunction useMouse() {\n  const x = $ref(0)\n  const y = $ref(0)\n\n  // listen to mousemove...\n\n  // fixed\n  return $$({\n    x,\n    y,\n  })\n}\nUsing $$() on destructured props\n‚Äã\n\n$$() works on destructured props since they are reactive variables as well. The compiler will convert it with toRef for efficiency:\n\nts\nconst { count } = defineProps<{ count: number }>()\n\npassAsRef($$(count))\n\ncompiles to:\n\njs\nexport default {\n  setup(props) {\n    const __props_count = toRef(props, 'count')\n    passAsRef(__props_count)\n  },\n}\nTypeScript Integration\n‚Äã\n\nVue provides typings for these macros (available globally) and all types will work as expected. There are no incompatibilities with standard TypeScript semantics, so the syntax will work with all existing tooling.\n\nThis also means the macros can work in any files where valid JS / TS are allowed - not just inside Vue SFCs.\n\nSince the macros are available globally, their types need to be explicitly referenced (e.g. in a env.d.ts file):\n\nts\n/// <reference types=\"unplugin-vue-macros/macros-global\" />\n\n// or for standalone version:\n/// <reference types=\"@vue-macros/reactivity-transform/macros-global\" />\n\nWhen explicitly importing the macros from unplugin-vue-macros/macros or @vue-macros/reactivity-transform/macros-global, the type will work without declaring the globals."
  },
  {
    "title": "betterDefine | Vue Macros",
    "url": "https://vue-macros.dev/features/better-define.html",
    "html": "betterDefine\n‚Äã\nStability: stable\n\nWith enabling betterDefine, imported types are supported in <script setup> type-based-macros.\n\nRelated issue\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript\t‚úÖ\nBasic Usage\n‚Äã\nApp.vue\ntypes.ts\nvue\n<script setup lang=\"ts\">\nimport type { BaseProps } from './types'\n\ninterface Props extends BaseProps {\n  foo: string\n}\ndefineProps<Props>()\n</script>\n‚ö†Ô∏è Limitations\n‚Äã\nComplex types\n‚Äã\n\nComplex types are not supported in some key places. For example:\n\nWhat are Complex Types?\n‚Äã\nAll utility types\nBuilt-in types\nAll types from type-fest package.\ntypeof keyword.\n...\nIndex Signature\nts\ninterface Type {\n  [key: string]: string\n}\nGenerics will be ignored directly\nWhat are Key Places?\n‚Äã\nThe names of props.\nts\n// ‚úÖ\ndefineProps<{\n  foo: ComplexType\n}>()\n\n// ‚ùå\ndefineProps<{\n  [ComplexType]: string\n}>()\nThe names of emits.\nts\ninterface Emits {\n  (event: 'something', value: ComplexType): void // ‚úÖ\n  (event: ComplexType): void // ‚ùå\n}"
  },
  {
    "title": "shortBind | Vue Macros",
    "url": "https://vue-macros.dev/macros/short-bind.html",
    "html": "shortBind\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nA shorthand for binding prop with the same data name.\n\n:value -> :value=\"value\"\n\nIf you have any questions about this feature, you can comment on RFC Discussion.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚ùå\nVolar Plugin\t‚úÖ\nUsage\n‚Äã\nBasic Usage\n‚Äã\nvue\n<template>\n  <input :msg />\n  <!-- => <input :msg=\"msg\" /> -->\n  <demo $msg />\n  <!-- => <input $msg=\"msg\" /> -->\n</template>\nWith shortVmodel\n‚Äã\nvue\n<template>\n  <input ::msg />\n  <!-- => <input ::msg=\"msg\" /> => <input v-model:msg=\"msg\" /> -->\n  <demo $msg />\n  <!-- => <input $msg=\"msg\" /> => <input v-model:msg=\"msg\" /> -->\n  <demo *msg />\n  <!-- => <input *msg=\"msg\" /> => <input v-model:msg=\"msg\" /> -->\n</template>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"plugins\": [\n      \"@vue-macros/volar/short-bind\"\n      // ...\n    ]\n  }\n}\nESLint Configuration\n‚Äã\njsonc\n// .eslintrc\n{\n  \"rules\": {\n    \"vue/valid-v-bind\": \"off\"\n  }\n}"
  },
  {
    "title": "chainCall | Vue Macros",
    "url": "https://vue-macros.dev/macros/chain-call.html",
    "html": "chainCall\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nExtends defineProps, support call withDefaults as a chain.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚ùì\nVue 2\t‚ùì\nTypeScript\t‚úÖ\nVolar Plugin\t‚ùå\n\nTIP\n\nchainCall does not support definePropsRefs\nTo fully support TypeScript, you need to import this macro from unplugin-vue-macros/macros.\nBasic Usage\n‚Äã\nvue\n<script setup lang=\"ts\">\nconst props = defineProps<{\n  foo?: string\n  bar?: number[]\n  baz?: boolean\n}>().withDefaults({\n  foo: '111',\n  bar: () => [1, 2, 3],\n})\n</script>\nCompiled Code\n\nAlso support props destructuring and JSX:\n\nvue\n<script setup lang=\"tsx\">\nconst { foo } = defineProps<{ foo: string }>().withDefaults({\n  foo: '111',\n})\n</script>\nTypeScript\n‚Äã\n\nTo fully support TypeScript, you need to import this macro from unplugin-vue-macros/macros with specific syntax.\n\nvue\n<script setup lang=\"ts\">\nimport { defineProps } from 'unplugin-vue-macros/macros' assert { type: 'macro' }\n\ndefineProps<{\n  /* ... */\n}>().withDefaults({\n  /* ... */\n})\n// ‚úÖ type safe\n</script>\n\nWorks without import assertion, but tsc will report an error:\n\nts\ndefineProps<{\n  /* ... */\n}>().withDefaults({\n  /* ... */\n})\n// ‚ùå Property 'withDefaults' does not exist on type 'DefineProps<{ /* ... */ }>'."
  },
  {
    "title": "setupSFC | Vue Macros",
    "url": "https://vue-macros.dev/macros/setup-sfc.html",
    "html": "setupSFC\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nTIP\n\nIf you're using setupSFC, then defineRender cannot be disabled.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript / Volar\t‚ùå\nSetup\n‚Äã\nVite\nRollup\nüöß esbuild\nüöß Webpack\nts\n// vite.config.ts\nimport VueMacros from 'unplugin-vue-macros/vite'\nimport Vue from '@vitejs/plugin-vue'\n\nexport default defineConfig({\n  plugins: [\n    VueMacros({\n      plugins: {\n        vue: Vue({\n          include: [/\\.vue$/, /\\.setup\\.[cm]?[jt]sx?$/],\n          //                   ‚¨ÜÔ∏è setupSFC pattern need to be added\n        }),\n      },\n    }),\n  ],\n})\nBasic Usage\n‚Äã\ntsx\n// Foo.setup.tsx\ndefineProps<{\n  foo: string\n}>()\n\ndefineEmits<{\n  (evt: 'change'): void\n}>()\n\nexport default () => (\n  <div>\n    <h1>Hello World</h1>\n  </div>\n)\nKnown Issues\n‚Äã\nThe source map does not correspond properly in JSX/TSX files.\nTypeScript support is not yet completed."
  },
  {
    "title": "setupComponent | Vue Macros",
    "url": "https://vue-macros.dev/macros/setup-component.html",
    "html": "setupComponent\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nTIP\n\ndefineRender cannot be disabled when using setupComponent.\n\nFiles in node_modules will be ignored by default.\n\nWith defineSetupComponent, <script setup> code can be put in pure JS/TS(X) without Vue Language Tools (Volar) extension.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚ùå\nVue 2\t‚ùå\nTypeScript\t‚ùå\n\nSee also Vue Vine - another style for Vue functional component.\n\nBasic Usage\n‚Äã\ntsx\nexport const App = defineSetupComponent(() => {\n  defineProps<{\n    foo: string\n  }>()\n\n  defineEmits<{\n    (evt: 'change'): void\n  }>()\n\n  defineOptions({\n    name: 'App',\n  })\n\n  // ...\n  return <div />\n})\nType Annotation\n‚Äã\nts\nexport const App: SetupFC = () => {\n  defineProps<{\n    foo: string\n  }>()\n\n  defineEmits<{\n    (evt: 'change'): void\n  }>()\n\n  defineOptions({\n    name: 'App',\n  })\n}\nKnown Issues\n‚Äã\nTypeScript support is not yet completed.\nThe source map does not correspond properly."
  },
  {
    "title": "defineEmit | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-emit.html",
    "html": "defineEmit\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nDeclare single emit one by one using defineEmit.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript\t‚úÖ\nVolar Plugin\t‚ùå\n\nWARNING\n\ndefineEmit can not be used with defineEmits at same time\n\nAPI Reference\n‚Äã\nts\ndefineEmit<T>(emitName)\ndefineEmit<T>(emitName, validator)\n\n// emitName parameter can be optional,\n// and will be inferred from variable name\nconst emitName = defineEmit<T>()\nBasic Usage\n‚Äã\nvue\n<script setup>\n// Declare emit\nconst increment = defineEmit('increment')\n// Infer emit name from variable name\nconst change = defineEmit()\n// emit event\nincrement()\n</script>\nWith Validation\n‚Äã\nvue\n<script setup>\n// Declare event with validation\nconst increment = defineEmit('increment', (value) => value < 20)\n</script>\nTypeScript\n‚Äã\nvue\n<script setup lang=\"ts\">\nconst increment = defineEmit('increment', (value: number) => value < 20)\nconst decrement = defineEmit<[value: number]>()\n\nincrement(2) // pass\nincrement('2') // TS type error\n</script>"
  },
  {
    "title": "defineProp | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-prop.html",
    "html": "defineProp\n‚Äã\nStability: experimental\n‚ö†Ô∏è Experimental feature, use at your risk\n\nDeclare single prop one by one using defineProp.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript / Volar\t‚úÖ\n\nWARNING\n\ndefineProp can not be used in the same file as defineProps.\n\nConfiguration\n‚Äã\nts\nVueMacros({\n  defineProp: {\n    /**\n     * 'kevinEdition' | 'johnsonEdition'\n     * @default 'kevinEdition'\n     */\n    edition: 'kevinEdition',\n  },\n})\nVolar\n‚Äã\n\nRequire Volar >= 1.3.12\n\njsonc\n// tsconfig.json\n{\n  // ...\n  \"vueCompilerOptions\": {\n    // \"kevinEdition\" | \"johnsonEdition\" | false\n    \"experimentalDefinePropProposal\": \"kevinEdition\"\n  }\n}\nKevin's Edition (Default)\n‚Äã\nAPI Reference\n‚Äã\nts\ndefineProp<T>(propName)\ndefineProp<T>(propName, options)\n\n// propName parameter can be optional,\n// and will be inferred from variable name\nconst propName = defineProp<T>()\nBasic Usage\n‚Äã\nvue\n<script setup>\n// Declare prop\nconst count = defineProp('count')\n// Infer prop name from variable name\nconst value = defineProp()\n// access prop value\nconsole.log(count.value)\n</script>\nWith Options\n‚Äã\nvue\n<script setup>\n// Declare prop with options\nconst count = defineProp('count', {\n  type: Number,\n  required: true,\n  default: 0,\n  validator: (value) => value < 20,\n})\n</script>\nTypeScript\n‚Äã\nvue\n<script setup lang=\"ts\">\n// Declare prop of type number and infer prop name from variable name\nconst count = defineProp<number>()\ncount.value\n//    ^? type: number | undefined\n\n// Declare prop of TS type boolean with default value\nconst disabled = defineProp<boolean>('disabled', { default: true })\ndisabled.value\n//        ^? type: boolean\n</script>\nJohnson's Edition\n‚Äã\nAPI Reference\n‚Äã\nts\n// the prop name will be inferred from variable name\nconst propName = defineProp<T>()\nconst propName = defineProp<T>(defaultValue)\nconst propName = defineProp<T>(defaultValue, required)\nconst propName = defineProp<T>(defaultValue, required, rest)\nBasic Usage\n‚Äã\nvue\n<script setup>\n// declare prop `count` with default value `0`\nconst count = defineProp(0)\n\n// declare required prop `disabled`\nconst disabled = defineProp(undefined, true)\n\n// access prop value\nconsole.log(count.value, disabled.value)\n</script>\nWith Options\n‚Äã\nvue\n<script setup>\n// Declare prop with options\nconst count = defineProp(0, false, {\n  type: Number,\n  validator: (value) => value < 20,\n})\n</script>\nTypeScript\n‚Äã\nvue\n<script setup lang=\"ts\">\nconst count = defineProp<number>()\ncount.value\n//    ^? type: number | undefined\n\n// Declare prop of TS type boolean with default value\nconst disabled = defineProp<boolean>(true)\ndisabled.value\n//        ^? type: boolean\n</script>"
  },
  {
    "title": "shortVmodel | Vue Macros",
    "url": "https://vue-macros.dev/macros/short-vmodel.html",
    "html": "shortVmodel\n‚Äã\nStability: stable\n\nA shorthand for v-model.\n\nv-model -> :: / $ / *\n\nIf you have any questions about this feature, you can comment on RFC Discussion.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚ùå\nVolar Plugin\t‚úÖ\nOptions\n‚Äã\nts\ninterface Options {\n  /**\n   * @default '$'\n   */\n  prefix?: '::' | '$' | '*'\n}\nUsage\n‚Äã\n$ Dollar Sign (Default)\n‚Äã\nvue\n<template>\n  <input $=\"msg\" />\n  <!-- => <input v-model=\"msg\" /> -->\n  <demo $msg=\"msg\" />\n  <!-- => <input v-model:msg=\"msg\" /> -->\n</template>\n:: Double Binding\n‚Äã\nvue\n<template>\n  <!-- prettier-ignore -->\n  <input ::=\"msg\" />\n  <!-- => <input v-model=\"msg\" /> -->\n  <demo ::msg=\"msg\" />\n  <!-- => <input v-model:msg=\"msg\" /> -->\n</template>\n* Asterisk Sign\n‚Äã\nvue\n<template>\n  <input *=\"msg\" />\n  <!-- => <input v-model=\"msg\" /> -->\n  <demo *msg=\"msg\" />\n  <!-- => <input v-model:msg=\"msg\" /> -->\n</template>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"plugins\": [\n      \"@vue-macros/volar/short-vmodel\"\n      // ...\n    ],\n    \"vueMacros\": {\n      \"shortVmodel\": {\n        \"prefix\": \"$\"\n      }\n    }\n  }\n}\nKnown Issues\n‚Äã\nPrettier will format ::= to := (e.g. <div ::=\"msg\" /> -> <div :=\"msg\" />). The comment <!-- prettier-ignore --> is required if prefix is ::."
  },
  {
    "title": "defineRender | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-render.html",
    "html": "defineRender\n‚Äã\nStability: stable\n\nDefining render function in <script setup> using the defineRender.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript\t‚úÖ\n\nWe need more feedback on RFC Discussion!\n\nBasic Usage\n‚Äã\nvue\n<script setup lang=\"tsx\">\n// JSX passed directly\ndefineRender(\n  <div>\n    <span>Hello</span>\n  </div>,\n)\n\n// Or using render function\ndefineRender(() => {\n  return (\n    <div>\n      <h1>Hello World</h1>\n    </div>\n  )\n})\n</script>"
  },
  {
    "title": "definePropsRefs | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-props-refs.html",
    "html": "definePropsRefs\n‚Äã\nStability: stable\n\nReturns refs from defineProps instead of a reactive object. It can be destructured without losing reactivity.\n\ntoRefs(defineProps()) => definePropsRefs()\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript / Volar Plugin\t‚úÖ\nBasic Usage\n‚Äã\nvue\n<script setup lang=\"ts\">\n// ‚úÖ won't lose reactivity with destructuring\nconst { foo, bar } = definePropsRefs<{\n  foo: string\n  bar: number\n}>()\n//          ‚¨áÔ∏è Ref<string>\nconsole.log(foo.value, bar.value)\n</script>\nWith Default Value\n‚Äã\nvue\n<script setup lang=\"ts\">\nimport { withDefaults } from 'unplugin-vue-macros/macros' assert { type: 'macro' }\n\nconst { foo } = withDefaults(\n  definePropsRefs<{\n    foo?: string\n  }>(),\n  { foo: 'test' },\n)\n//          ‚¨áÔ∏è Ref<string>\nconsole.log(foo.value)\n</script>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3,\n    \"plugins\": [\n      \"@vue-macros/volar/define-props-refs\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "defineModels | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-models.html",
    "html": "defineModels\n‚Äã\nStability: stable\n\nDeclaring and mutate v-model props as the same as normal variable using the defineModels.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nVolar Plugin\t‚úÖ\nOptions\n‚Äã\nts\nVueMacros({\n  defineModels: {\n    /**\n     * Unified mode, only works for Vue 2\n     *\n     * Converts `modelValue` to `value`\n     */\n    unified: false,\n  },\n})\nBasic Usage\n‚Äã\n\nRequires @vueuse/core, install it by yourself before using.\n\nvue\n<script setup lang=\"ts\">\nconst { modelValue, count } = defineModels<{\n  modelValue: string\n  count: number\n}>()\n\nconsole.log(modelValue.value)\nmodelValue.value = 'newValue'\n</script>\n\n‚ùå Object declaring is not supported.\n\nvue\n<script setup lang=\"ts\">\nconst { modelValue } = defineModels({\n  modelValue: String,\n})\n</script>\nWith Model Options\n‚Äã\nvue\n<script setup lang=\"ts\">\nconst { modelValue } = defineModels<{\n  modelValue: ModelOptions<\n    string,\n    { defaultValue: 'something'; deep: true; passive: true }\n  >\n}>()\n</script>\nWith Reactivity Transform\n‚Äã\n\nWARNING\n\nAssignment expression is only supported in <script setup> block. In other words invalid in <template>.\n\n@vueuse/core is not required.\n\nvue\n<script setup lang=\"ts\">\nlet { modelValue, count } = $defineModels<{\n  modelValue: string\n  count: number\n}>()\n\nconsole.log(modelValue)\nmodelValue = 'newValue'\ncount++\n</script>\nCompiled Code\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3, // or 2.7 for Vue 2\n    \"plugins\": [\n      \"@vue-macros/volar/define-models\"\n      // ...more feature\n    ],\n    \"vueMacros\": {\n      \"defineModels\": {\n        // Only works when target is 2.7.\n        \"unified\": true\n      }\n    }\n  }\n}"
  },
  {
    "title": "defineProps | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-props.html",
    "html": "defineProps\n‚Äã\nStability: stable\n\nCorrect types of destructured props using $defineProps.\n\nSee also Vue issue, Reactivity Transform RFC.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript / Volar Plugin\t‚úÖ\n\nWARNING\n\nReactivity Transform is required. You should enable it first.\n\nBasic Usage\n‚Äã\nvue\n<script setup lang=\"ts\">\n//       ‚¨áÔ∏è ReactiveVariable<string[]>\nconst { foo } = $defineProps<{\n  foo: string[]\n}>()\n\n//     ‚¨áÔ∏è Ref<string[]>\nconst fooRef = $$(foo)\n</script>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3,\n    \"plugins\": [\n      \"@vue-macros/volar/define-props\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "defineSlots | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-slots.html",
    "html": "defineSlots\n‚Äã\nStability: stable\n\nDeclaring type of SFC slots in <script setup> using the defineSlots.\n\nFor Vue >= 3.3, this feature will be turned off by default.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nVolar Plugin\t‚úÖ\nBasic Usage\n‚Äã\nShort Syntax\n‚Äã\nvue\n<script setup lang=\"ts\">\ndefineSlots<{\n  // slot name\n  title: {\n    // scoped slot\n    foo: 'bar' | boolean\n  }\n}>()\n</script>\nFull Syntax (Official Version)\n‚Äã\nvue\n<script setup lang=\"ts\">\ndefineSlots<{\n  title: (scope: { text: string }) => any\n}>()\n</script>\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3, // or 2.7 for Vue 2\n    \"plugins\": [\n      \"@vue-macros/volar/define-slots\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "shortEmits | Vue Macros",
    "url": "https://vue-macros.dev/macros/short-emits.html",
    "html": "shortEmits\n‚Äã\nStability: stable\n\nSimplify the definition of emits.\n\nFor Vue >= 3.3, this feature will be turned off by default.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript\t‚úÖ\nBasic Usage\n‚Äã\n\nUsing type ShortEmits or for short SE.\n\nvue\n<script setup lang=\"ts\">\nconst emits = defineEmits<{\n  // tuple\n  'update:modelValue': [val: string]\n  // function\n  update(val: string): void\n}>()\n</script>\nDifference with Official Version\n‚Äã\nfunction style of declaration is not supported by official version."
  },
  {
    "title": "defineOptions | Vue Macros",
    "url": "https://vue-macros.dev/macros/define-options.html",
    "html": "defineOptions\n‚Äã\nStability: stable\n\nOptions API can be declared using the defineOptions in <script setup>, specifically to be able to set name, props, emits, and render inside of one function.\n\nFor Vue >= 3.3, this feature will be turned off by default.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nTypeScript\t‚úÖ\nInstallation Standalone Version\n‚Äã\n\nif you need defineOptions feature only, the standalone version is more appropriate for you.\n\nInstallation\n‚Äã\nnpm\nyarn\npnpm\nbash\nnpm i -D unplugin-vue-define-options @vue-macros/volar\nVite\nRollup\nesbuild\nWebpack\nts\n// vite.config.ts\nimport DefineOptions from 'unplugin-vue-define-options/vite'\n\nexport default defineConfig({\n  plugins: [DefineOptions()],\n})\nTypeScript Support\n‚Äã\njson\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // ...\n    \"types\": [\"unplugin-vue-define-options/macros-global\" /* ... */]\n  }\n}\nBasic Usage\n‚Äã\nvue\n<script setup lang=\"ts\">\nimport { useSlots } from 'vue'\ndefineOptions({\n  name: 'Foo',\n  inheritAttrs: false,\n})\nconst slots = useSlots()\n</script>\nCompiled Code\nJSX in <script setup>\n‚Äã\nvue\n<script setup lang=\"tsx\">\ndefineOptions({\n  render() {\n    return <h1>Hello World</h1>\n  },\n})\n</script>\nCompiled Code\nVolar Configuration\n‚Äã\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"target\": 3, // or 2.7 for Vue 2\n    \"plugins\": [\n      \"@vue-macros/volar/define-options\"\n      // ...more feature\n    ]\n  }\n}"
  },
  {
    "title": "Configurations | Vue Macros",
    "url": "https://vue-macros.dev/guide/configurations.html",
    "html": "Configurations\n‚Äã\nPlugin Options\n‚Äã\n\nAll features are enabled by default except the following.\n\ndefineOptions (Vue >= 3.3)\ndefineSlots (Vue >= 3.3)\nhoistStatic (Vue >= 3.3)\nshortEmits (Vue >= 3.3)\nexportExpose\nexportProps\nexportRender\nsetupSFC\nbooleanProp\nshortBind\n\nYou can disable them by setting the option to false.\n\nts\nVueMacros({\n  root: '/your-project-path',\n\n  /**\n   * Vue version, 2 or 3.\n   *\n   * optional, detecting automatically.\n   */\n  version: 3,\n\n  plugins: {\n    vue: Vue(),\n    vueJsx: VueJsx(),\n  },\n\n  /** Defaults to true  */\n  defineModels: {\n    /**\n     * Unified mode, only works for Vue 2\n     *\n     * Converts `modelValue` to `value`\n     */\n    unified: true,\n  },\n\n  // Disable features\n  hoistStatic: false,\n\n  // ... more features\n})\n\nSee the features page for options for each feature."
  },
  {
    "title": "Astro Integration | Vue Macros",
    "url": "https://vue-macros.dev/guide/astro-integration.html",
    "html": "Astro Integration\n‚Äã\nInstallation\n‚Äã\nnpm\nyarn\npnpm\nbash\nnpm i -D @vue-macros/astro\nConfiguration\n‚Äã\nts\n// astro.config.mjs\nimport { defineConfig } from 'astro/config'\nimport Vue from '@astrojs/vue'\nimport Macros from '@vue-macros/astro'\n\nexport default defineConfig({\n  integrations: [\n    Vue(),\n    Macros({\n      // ... configs\n    }),\n  ],\n})\nTypeScript Support & Volar Support\n‚Äã\n\nSee the corresponding chapter on Bundler Integration\n\nüéâ Congratulations! That's all.\n\nTo learn more about the macros, please visit All Macros üòÜ."
  },
  {
    "title": "Nuxt Integration | Vue Macros",
    "url": "https://vue-macros.dev/guide/nuxt-integration.html",
    "html": "Nuxt Integration\n‚Äã\nInstallation\n‚Äã\nnpm\nyarn\npnpm\nbash\nnpm i -D @vue-macros/nuxt\nConfiguration\n‚Äã\nts\n// nuxt.config.ts\nexport default {\n  modules: [\n    '@vue-macros/nuxt',\n    // ...\n  ],\n  macros: {\n    // configure plugin options, if needed\n  },\n}\n\nüéâ Congratulations! That's all.\n\nTo learn more about the macros, please visit All Macros üòÜ."
  },
  {
    "title": "Bundler Integration | Vue Macros",
    "url": "https://vue-macros.dev/guide/bundler-integration.html",
    "html": "Bundler Integration\n‚Äã\nInstallation\n‚Äã\nnpm\nyarn\npnpm\nbash\nnpm i -D unplugin-vue-macros\nVite (first-class support)\nRollup (first-class support)\nesbuild\nWebpack\nVue CLI\nts\n// vite.config.ts\nimport VueMacros from 'unplugin-vue-macros/vite'\nimport Vue from '@vitejs/plugin-vue'\n// import VueJsx from '@vitejs/plugin-vue-jsx'\n\nexport default defineConfig({\n  plugins: [\n    VueMacros({\n      plugins: {\n        vue: Vue(),\n        // vueJsx: VueJsx(), // if needed\n      },\n    }),\n  ],\n})\nTypeScript Support\n‚Äã\nVue 3\nVue 2\njson\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    // ...\n    \"types\": [\"unplugin-vue-macros/macros-global\" /* ... */]\n  }\n}\nVolar Support\n‚Äã\n\nFor detailed configuration, please refer to the description of the specific macro.\n\nbash\nnpm i -D @vue-macros/volar\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"plugins\": [\n      \"@vue-macros/volar/define-options\",\n      \"@vue-macros/volar/define-models\",\n      \"@vue-macros/volar/define-props\",\n      \"@vue-macros/volar/define-props-refs\",\n      \"@vue-macros/volar/short-vmodel\",\n      \"@vue-macros/volar/define-slots\",\n      \"@vue-macros/volar/jsx-directive\",\n      \"@vue-macros/volar/setup-jsdoc\"\n\n      // Choose only one of the following\n      // \"@vue-macros/volar/export-expose\",\n      // \"@vue-macros/volar/export-props\",\n      // \"@vue-macros/volar/export-render\",\n    ]\n    // ...\n  }\n}\nScoped Plugins\n‚Äã\n\nexport-expose, export-props, and export-render plugins cannot be used at the same time unless providing a scope.\n\njsonc\n// tsconfig.json\n{\n  \"vueCompilerOptions\": {\n    \"plugins\": [\n      \"@vue-macros/volar/export-render\",\n      \"@vue-macros/volar/export-expose\",\n      \"@vue-macros/volar/export-props\"\n    ],\n    \"vueMacros\": {\n      \"exportExpose\": {\n        \"include\": [\"**/export-expose/**\"]\n      },\n      \"exportProps\": {\n        \"include\": [\"**/export-props/**\"]\n      },\n      \"exportRender\": {\n        \"include\": [\"**/export-render/**\"]\n      }\n    }\n  }\n}\n\nüéâ Congratulations! You have successfully set up Vue Macros.\n\nTo learn more about the macros, please visit All Macros üòÜ."
  },
  {
    "title": "ÂÖ•Èó® | Vue Macros",
    "url": "https://vue-macros.dev/zh-CN/guide/getting-started.html",
    "html": "ÂÖ•Èó®\n‚Äã\n\nVue Macros ÊòØ‰∏Ä‰∏™Â∫ìÔºåÁî®‰∫éÂÆûÁé∞Â∞öÊú™Ë¢´ Vue Ê≠£ÂºèÂÆûÁé∞ÁöÑÊèêÊ°àÊàñÊÉ≥Ê≥ï„ÄÇËøôÊÑèÂë≥ÁùÄÂÆÉÂ∞ÜÊé¢Á¥¢Êõ¥Â§öÂÆèÂíåËØ≠Ê≥ïÁ≥ñÂà∞ Vue ‰∏≠„ÄÇ\n\nÂú®ÁªßÁª≠‰πãÂâçÔºåÊàë‰ª¨ÂÅáËÆæ‰Ω†Â∑≤ÁªèÁÜüÊÇâ Vue ÁöÑÂü∫Êú¨Áî®Ê≥ï„ÄÇ\n\nË¶ÅÊ±Ç\n‚Äã\nNode.js 16.14.0 ÊàñÊõ¥È´ò\nVue >= 2.7 Êàñ Vue >= 3.0\nÊüê‰∫õÂäüËÉΩÈúÄË¶Å Vue >= 3.2.25\nVSCode ÂÆâË£Ö‰∫Ü Vue Language Features (Volar) Êâ©Â±ï\n‚ùå ‰∏çÊîØÊåÅ WebStorm\nÁ§∫‰æã\n‚Äã\nVite + Vue 3\nVite + Vue 2\nNuxt 3 + Vue 3\nVue CLI + Vue 2\n\nüåü Ê¨¢ËøéÊèê‰æõÊõ¥Â§öÁ§∫‰æãÔºÅ\n\nNuxt ÈõÜÊàê\n‚Äã\n\nÂ¶ÇÊûú‰Ω†‰ΩøÁî®ÁöÑÊòØ Nuxt 3ÔºåËØ∑ÈòÖËØª Nuxt ÈõÜÊàê„ÄÇ\n\nÊâìÂåÖÂô®ÈõÜÊàê\n‚Äã\n\nÂ¶ÇÊûú‰Ω†‰ΩøÁî®ÁöÑÊòØ Vite„ÄÅRollup„ÄÅesbuildÔºåÊàñ Webpack Ê≠§Á±ªÊâìÂåÖÂô®ÔºåËØ∑ÈòÖËØª ÊâìÂåÖÂô®ÈõÜÊàê„ÄÇ"
  },
  {
    "title": "hoistStatic | Vue Macros",
    "url": "https://vue-macros.dev/features/hoist-static.html",
    "html": "hoistStatic\n‚Äã\nStability: stable\n\nWith enabling hoistStatic, constants declared in macros of <script setup> can be referenced.\n\nFor Vue >= 3.3, this feature will be turned off by default.\n\nFeatures\tSupported\nVue 3\t‚úÖ\nNuxt 3\t‚úÖ\nVue 2\t‚úÖ\nBasic Usage\n‚Äã\nvue\n<script setup lang=\"ts\">\nconst name = 'AppFoo'\ndefineOptions({\n  name,\n})\n</script>\nCompiled Code\nMagic Comments\n‚Äã\nvue\n<script setup lang=\"ts\">\n// A value that's even not a constant\nconst name = /* hoist-static */ fn()\ndefineOptions({\n  name,\n})\n</script>\nCompiled Code"
  },
  {
    "title": "Usage | Vue Macros",
    "url": "https://vue-macros.dev/macros/",
    "html": "Usage\n‚Äã\n\nList of all available macros.\n\nPlease make sure unplugin-vue-macros is set up correctly. If you haven't yet, read Getting Started first.\n\nImplemented by Vue 3.3\n‚Äã\ndefineOptions\ndefineSlots\nshortEmits\nStable Features\n‚Äã\ndefineModels\ndefineProps\ndefinePropsRefs\ndefineRender\nshortVmodel\nExperimental Features\n‚Äã\ndefineProp\ndefineEmit\nsetupComponent\nsetupSFC\nchainCall"
  },
  {
    "title": "Getting Started | Vue Macros",
    "url": "https://vue-macros.dev/guide/getting-started.html",
    "html": "Getting Started\n‚Äã\n\nVue Macros is a library that implements proposals or ideas that have not been officially implemented by Vue. That means it will explore and extend more features and syntax sugar to Vue.\n\nWe assume you are already familiar with the basic usages of Vue before you continue.\n\nRequirements\n‚Äã\nNode.js 16.14.0 or higher.\nVue >= 2.7 or Vue >= 3.0.\nSome features need Vue >= 3.2.25.\nVSCode with the latest Vue Language Features (Volar) extension.\n‚ùå WebStorm is not supported.\nDemos\n‚Äã\nVite + Vue 3\nVite + Vue 2\nNuxt 3 + Vue 3\nVue CLI + Vue 2\n\nüåü More demos are welcome!\n\nNuxt Integration\n‚Äã\n\nIf you're using Nuxt 3, read the Nuxt Integration.\n\nBundler Integrations\n‚Äã\n\nIf you're using Vite, Rollup, esbuild, or Webpack, read the Bundler Integration."
  }
]
