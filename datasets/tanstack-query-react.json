[
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/overview#persistqueryclientprovider",
    "html": "Overview\n\nTanStack Query (FKA React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMotivation\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n\nIs persisted remotely in a location you do not control or own\nRequires asynchronous APIs for fetching and updating\nImplies shared ownership and can be changed by other people without your knowledge\nCan potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n\nCaching... (possibly the hardest thing to do in programming)\nDeduping multiple requests for the same data into a single request\nUpdating \"out of date\" data in the background\nKnowing when data is \"out of date\"\nReflecting updates to data as quickly as possible\nPerformance optimizations like pagination and lazy loading data\nManaging memory and garbage collection of server state\nMemoizing query results with structural sharing\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nReact Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nReact Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, React Query will likely:\n\nHelp you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of React Query logic.\nMake your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\nHave a direct impact on your end-users by making your application feel faster and more responsive than ever before.\nPotentially help you save on bandwidth and increase memory performance\nEnough talk, show me some code already!\n\nIn the example below, you can see React Query in its most basic and simple form being used to fetch the GitHub stats for the React Query GitHub project itself:\n\nOpen in CodeSandbox\n\ntsx\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/react-query'\n\n\nconst queryClient = new QueryClient()\n\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n\n\nfunction Example() {\n  const { isPending, error, data } = useQuery({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      fetch('https://api.github.com/repos/TanStack/query').then(\n        (res) => res.json(),\n      ),\n  })\n\n\n  if (isPending) return 'Loading...'\n\n\n  if (error) return 'An error has occurred: ' + error.message\n\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.description}</p>\n      <strong>üëÄ {data.subscribers_count}</strong>{' '}\n      <strong>‚ú® {data.stargazers_count}</strong>{' '}\n      <strong>üç¥ {data.forks_count}</strong>\n    </div>\n  )\n}"
  },
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/overview",
    "html": "Overview\n\nTanStack Query (FKA React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMotivation\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n\nIs persisted remotely in a location you do not control or own\nRequires asynchronous APIs for fetching and updating\nImplies shared ownership and can be changed by other people without your knowledge\nCan potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n\nCaching... (possibly the hardest thing to do in programming)\nDeduping multiple requests for the same data into a single request\nUpdating \"out of date\" data in the background\nKnowing when data is \"out of date\"\nReflecting updates to data as quickly as possible\nPerformance optimizations like pagination and lazy loading data\nManaging memory and garbage collection of server state\nMemoizing query results with structural sharing\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nReact Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nReact Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, React Query will likely:\n\nHelp you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of React Query logic.\nMake your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\nHave a direct impact on your end-users by making your application feel faster and more responsive than ever before.\nPotentially help you save on bandwidth and increase memory performance\nEnough talk, show me some code already!\n\nIn the example below, you can see React Query in its most basic and simple form being used to fetch the GitHub stats for the React Query GitHub project itself:\n\nOpen in CodeSandbox\n\ntsx\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/react-query'\n\n\nconst queryClient = new QueryClient()\n\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n\n\nfunction Example() {\n  const { isPending, error, data } = useQuery({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      fetch('https://api.github.com/repos/TanStack/query').then(\n        (res) => res.json(),\n      ),\n  })\n\n\n  if (isPending) return 'Loading...'\n\n\n  if (error) return 'An error has occurred: ' + error.message\n\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.description}</p>\n      <strong>üëÄ {data.subscribers_count}</strong>{' '}\n      <strong>‚ú® {data.stargazers_count}</strong>{' '}\n      <strong>üç¥ {data.forks_count}</strong>\n    </div>\n  )\n}"
  },
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/overview",
    "html": "Overview\n\nTanStack Query (FKA React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMotivation\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n\nIs persisted remotely in a location you do not control or own\nRequires asynchronous APIs for fetching and updating\nImplies shared ownership and can be changed by other people without your knowledge\nCan potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n\nCaching... (possibly the hardest thing to do in programming)\nDeduping multiple requests for the same data into a single request\nUpdating \"out of date\" data in the background\nKnowing when data is \"out of date\"\nReflecting updates to data as quickly as possible\nPerformance optimizations like pagination and lazy loading data\nManaging memory and garbage collection of server state\nMemoizing query results with structural sharing\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nReact Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nReact Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, React Query will likely:\n\nHelp you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of React Query logic.\nMake your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\nHave a direct impact on your end-users by making your application feel faster and more responsive than ever before.\nPotentially help you save on bandwidth and increase memory performance\nEnough talk, show me some code already!\n\nIn the example below, you can see React Query in its most basic and simple form being used to fetch the GitHub stats for the React Query GitHub project itself:\n\nOpen in CodeSandbox\n\ntsx\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/react-query'\n\n\nconst queryClient = new QueryClient()\n\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n\n\nfunction Example() {\n  const { isPending, error, data } = useQuery({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      fetch('https://api.github.com/repos/TanStack/query').then(\n        (res) => res.json(),\n      ),\n  })\n\n\n  if (isPending) return 'Loading...'\n\n\n  if (error) return 'An error has occurred: ' + error.message\n\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.description}</p>\n      <strong>üëÄ {data.subscribers_count}</strong>{' '}\n      <strong>‚ú® {data.stargazers_count}</strong>{' '}\n      <strong>üç¥ {data.forks_count}</strong>\n    </div>\n  )\n}"
  },
  {
    "title": "hydration | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/hydration",
    "html": "hydration\ndehydrate\n\ndehydrate creates a frozen representation of a cache that can later be hydrated with HydrationBoundary or hydrate. This is useful for passing prefetched queries from server to client or persisting queries to localStorage or other persistent locations. It only includes currently successful queries by default.\n\ntsx\nimport { dehydrate } from '@tanstack/react-query'\n\n\nconst dehydratedState = dehydrate(queryClient, {\n  shouldDehydrateQuery,\n  shouldDehydrateMutation,\n})\n\nOptions\n\nclient: QueryClient\nRequired\nThe queryClient that should be dehydrated\noptions: DehydrateOptions\nOptional\nshouldDehydrateMutation: (mutation: Mutation) => boolean\nOptional\nWhether to dehydrate mutations.\nThe function is called for each mutation in the cache\nReturn true to include this mutation in dehydration, or false otherwise\nDefaults to only including paused mutations\nIf you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateMutation as part of the return statement\nshouldDehydrateQuery: (query: Query) => boolean\nOptional\nWhether to dehydrate queries.\nThe function, it is called for each query in the cache\nReturn true to include this query in dehydration, or false otherwise\nDefaults to only including successful queries\nIf you would like to extend the function while retaining the default behavior, import and execute defaultShouldDehydrateQuery as part of the return statement\n\nReturns\n\ndehydratedState: DehydratedState\nThis includes everything that is needed to hydrate the queryClient at a later point\nYou should not rely on the exact format of this response, it is not part of the public API and can change at any time\nThis result is not in serialized form, you need to do that yourself if desired\nlimitations\n\nSome storage systems (such as browser Web Storage API) require values to be JSON serializable. If you need to dehydrate values that are not automatically serializable to JSON (like Error or undefined), you have to serialize them for yourself. Since only successful queries are included per default, to also include Errors, you have to provide shouldDehydrateQuery, e.g.:\n\ntsx\n// server\nconst state = dehydrate(client, { shouldDehydrateQuery: () => true }) // to also include Errors\nconst serializedState = mySerialize(state) // transform Error instances to objects\n\n\n// client\nconst state = myDeserialize(serializedState) // transform objects back to Error instances\nhydrate(client, state)\nhydrate\n\nhydrate adds a previously dehydrated state into a cache.\n\ntsx\nimport { hydrate } from '@tanstack/react-query'\n\n\nhydrate(queryClient, dehydratedState, options)\n\nOptions\n\nclient: QueryClient\nRequired\nThe queryClient to hydrate the state into\ndehydratedState: DehydratedState\nRequired\nThe state to hydrate into the client\noptions: HydrateOptions\nOptional\ndefaultOptions: DefaultOptions\nOptional\nmutations: MutationOptions The default mutation options to use for the hydrated mutations.\nqueries: QueryOptions The default query options to use for the hydrated queries.\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\nLimitations\n\nIf the queries included in dehydration already exist in the queryCache, hydrate does not overwrite them and they will be silently discarded.\n\nHydrationBoundary\n\nHydrationBoundary adds a previously dehydrated state into the queryClient that would be returned by useQueryClient(). If the client already contains data, the new queries will be intelligently merged based on update timestamp.\n\ntsx\nimport { HydrationBoundary } from '@tanstack/react-query'\n\n\nfunction App() {\n  return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>\n}\n\nOptions\n\nstate: DehydratedState\nThe state to hydrate\noptions: HydrateOptions\nOptional\ndefaultOptions: QueryOptions\nThe default query options to use for the hydrated queries.\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used."
  },
  {
    "title": "FocusManager | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/focusManager",
    "html": "FocusManager\n\nThe FocusManager manages the focus state within TanStack Query.\n\nIt can be used to change the default event listeners or to manually change the focus state.\n\nIts available methods are:\n\nsetEventListener\nsubscribe\nsetFocused\nisFocused\nfocusManager.setEventListener\n\nsetEventListener can be used to set a custom event listener:\n\ntsx\nimport { focusManager } from '@tanstack/react-query'\n\n\nfocusManager.setEventListener((handleFocus) => {\n  // Listen to visibilitychange\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('visibilitychange', handleFocus, false)\n  }\n\n\n  return () => {\n    // Be sure to unsubscribe if a new handler is set\n    window.removeEventListener('visibilitychange', handleFocus)\n  }\n})\nfocusManager.subscribe\n\nsubscribe can be used to subscribe to changes in the visibility state. It returns an unsubscribe function:\n\ntsx\nimport { focusManager } from '@tanstack/react-query'\n\n\nconst unsubscribe = focusManager.subscribe(isVisible => {\n  console.log('isVisible', isVisible)\n})\nfocusManager.setFocused\n\nsetFocused can be used to manually set the focus state. Set undefined to fall back to the default focus check.\n\ntsx\nimport { focusManager } from '@tanstack/react-query'\n\n\n// Set focused\nfocusManager.setFocused(true)\n\n\n// Set unfocused\nfocusManager.setFocused(false)\n\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)\n\nOptions\n\nfocused: boolean | undefined\nfocusManager.isFocused\n\nisFocused can be used to get the current focus state.\n\ntsx\nconst isFocused = focusManager.isFocused()"
  },
  {
    "title": "OnlineManager | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/onlineManager",
    "html": "OnlineManager\n\nThe OnlineManager manages the online state within TanStack Query. It can be used to change the default event listeners or to manually change the online state.\n\nPer default, the onlineManager assumes an active network connection, and listens to the online and offline events on the window object to detect changes.\n\nIn previous versions, navigator.onLine was used to determine the network status. However, it doesn't work well in Chromium based browsers. There are a lot of issues around false negatives, which lead to Queries being wrongfully marked as offline.\n\nTo circumvent this, we now always start with online: true and only listen to online and offline events to update the status.\n\nThis should reduce the likelihood of false negatives, however, it might mean false positives for offline apps that load via serviceWorkers, which can work even without an internet connection.\n\nIts available methods are:\n\nsetEventListener\nsubscribe\nsetOnline\nisOnline\nonlineManager.setEventListener\n\nsetEventListener can be used to set a custom event listener:\n\ntsx\nimport NetInfo from '@react-native-community/netinfo'\nimport { onlineManager } from '@tanstack/react-query'\n\n\nonlineManager.setEventListener(setOnline => {\n  return NetInfo.addEventListener(state => {\n    setOnline(!!state.isConnected)\n  })\n})\nonlineManager.subscribe\n\nsubscribe can be used to subscribe to changes in the online state. It returns an unsubscribe function:\n\ntsx\nimport { onlineManager } from '@tanstack/react-query'\n\n\nconst unsubscribe = onlineManager.subscribe(isOnline => {\n  console.log('isOnline', isOnline)\n})\nonlineManager.setOnline\n\nsetOnline can be used to manually set the online state.\n\ntsx\nimport { onlineManager } from '@tanstack/react-query'\n\n\n// Set to online\nonlineManager.setOnline(true)\n\n\n// Set to offline\nonlineManager.setOnline(false)\n\nOptions\n\nonline: boolean\nonlineManager.isOnline\n\nisOnline can be used to get the current online state.\n\ntsx\nconst isOnline = onlineManager.isOnline()"
  },
  {
    "title": "useQueryErrorResetBoundary | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useQueryErrorResetBoundary",
    "html": "useQueryErrorResetBoundary\n\nThis hook will reset any query errors within the closest QueryErrorResetBoundary. If there is no boundary defined it will reset them globally:\n\ntsx\nimport { useQueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\n\nconst App: React.FC = () => {\n  const { reset } = useQueryErrorResetBoundary()\n  return (\n    <ErrorBoundary\n      onReset={reset}\n      fallbackRender={({ resetErrorBoundary }) => (\n        <div>\n          There was an error!\n          <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n        </div>\n      )}\n    >\n      <Page />\n    </ErrorBoundary>\n  )\n}"
  },
  {
    "title": "QueryErrorResetBoundary | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/QueryErrorResetBoundary",
    "html": "QueryErrorResetBoundary\n\nWhen using suspense or throwOnError in your queries, you need a way to let queries know that you want to try again when re-rendering after some error occurred. With the QueryErrorResetBoundary component you can reset any query errors within the boundaries of the component.\n\ntsx\nimport { QueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\n\nconst App: React.FC = () => (\n  <QueryErrorResetBoundary>\n    {({ reset }) => (\n      <ErrorBoundary\n        onReset={reset}\n        fallbackRender={({ resetErrorBoundary }) => (\n          <div>\n            There was an error!\n            <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n          </div>\n        )}\n      >\n        <Page />\n      </ErrorBoundary>\n    )}\n  </QueryErrorResetBoundary>\n)"
  },
  {
    "title": "QueriesObserver | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/QueriesObserver",
    "html": "QueriesObserver\nQueriesObserver\n\nThe QueriesObserver can be used to observe multiple queries.\n\ntsx\nconst observer = new QueriesObserver(queryClient, [\n  { queryKey: ['post', 1], queryFn: fetchPost },\n  { queryKey: ['post', 2], queryFn: fetchPost },\n])\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\n\nOptions\n\nThe options for the QueriesObserver are exactly the same as those of useQueries.\n"
  },
  {
    "title": "InfiniteQueryObserver | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/InfiniteQueryObserver",
    "html": "InfiniteQueryObserver\nInfiniteQueryObserver\n\nThe InfiniteQueryObserver can be used to observe and switch between infinite queries.\n\ntsx\nconst observer = new InfiniteQueryObserver(queryClient, {\n  queryKey: ['posts'],\n  queryFn: fetchPosts,\n  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n})\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\n\nOptions\n\nThe options for the InfiniteQueryObserver are exactly the same as those of useInfiniteQuery.\n"
  },
  {
    "title": "QueryObserver | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/QueryObserver",
    "html": "QueryObserver\nQueryObserver\n\nThe QueryObserver can be used to observe and switch between queries.\n\ntsx\nconst observer = new QueryObserver(queryClient, { queryKey: ['posts'] })\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\n\nOptions\n\nThe options for the QueryObserver are exactly the same as those of useQuery.\n"
  },
  {
    "title": "QueryCache | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/QueryCache",
    "html": "QueryCache\n\nThe QueryCache is the storage mechanism for TanStack Query. It stores all the data, meta information and state of queries it contains.\n\nNormally, you will not interact with the QueryCache directly and instead use the QueryClient for a specific cache.\n\ntsx\nimport { QueryCache } from '@tanstack/react-query'\n\n\nconst queryCache = new QueryCache({\n  onError: (error) => {\n    console.log(error)\n  },\n  onSuccess: (data) => {\n    console.log(data)\n  },\n  onSettled: (data, error) => {\n    console.log(data, error)\n  },\n})\n\n\nconst query = queryCache.find(['posts'])\n\nIts available methods are:\n\nfind\nfindAll\nsubscribe\nclear\n\nOptions\n\nonError?: (error: unknown, query: Query) => void\nOptional\nThis function will be called if some query encounters an error.\nonSuccess?: (data: unknown, query: Query) => void\nOptional\nThis function will be called if some query is successful.\nonSettled?: (data: unknown | undefined, error: unknown | null, query: Query) => void\nOptional\nThis function will be called if some query is settled (either successful or errored).\nGlobal callbacks\n\nThe onError, onSuccess and onSettled callbacks on the QueryCache can be used to handle these events on a global level. They are different to defaultOptions provided to the QueryClient because:\n\ndefaultOptions can be overridden by each Query - the global callbacks will always be called.\ndefaultOptions callbacks will be called once for each Observer, while the global callbacks will only be called once per Query.\nqueryCache.find\n\nfind is a slightly more advanced synchronous method that can be used to get an existing query instance from the cache. This instance not only contains all the state for the query, but all of the instances, and underlying guts of the query as well. If the query does not exist, undefined will be returned.\n\nNote: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios (eg. Looking at the query.state.dataUpdatedAt timestamp to decide whether a query is fresh enough to be used as an initial value)\n\ntsx\nconst query = queryCache.find(queryKey)\n\nOptions\n\nqueryKey?: QueryKey: Query Keys\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nQuery\nThe query instance from the cache\nqueryCache.findAll\n\nfindAll is even more advanced synchronous method that can be used to get existing query instances from the cache that partially match query key. If queries do not exist, empty array will be returned.\n\nNote: This is not typically needed for most applications, but can come in handy when needing more information about a query in rare scenarios\n\ntsx\nconst queries = queryCache.findAll(queryKey)\n\nOptions\n\nqueryKey?: QueryKey: Query Keys\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nQuery[]\nQuery instances from the cache\nqueryCache.subscribe\n\nThe subscribe method can be used to subscribe to the query cache as a whole and be informed of safe/known updates to the cache like query states changing or queries being updated, added or removed\n\ntsx\nconst callback = (event) => {\n  console.log(event.type, event.query)\n}\n\n\nconst unsubscribe = queryCache.subscribe(callback)\n\nOptions\n\ncallback: (event: QueryCacheNotifyEvent) => void\nThis function will be called with the query cache any time it is updated via its tracked update mechanisms (eg, query.setState, queryClient.removeQueries, etc). Out of scope mutations to the cache are not encouraged and will not fire subscription callbacks\n\nReturns\n\nunsubscribe: Function => void\nThis function will unsubscribe the callback from the query cache.\nqueryCache.clear\n\nThe clear method can be used to clear the cache entirely and start fresh.\n\ntsx\nqueryCache.clear()\nFurther reading\n\nTo get a better understanding how the QueryCache works internally, have a look at #18: Inside React Query from the Community Resources.\n"
  },
  {
    "title": "QueryClient | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/QueryClient",
    "html": "QueryClient\nQueryClient\n\nThe QueryClient can be used to interact with a cache:\n\ntsx\nimport { QueryClient } from '@tanstack/react-query'\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: Infinity,\n    },\n  },\n})\n\n\nawait queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })\n\nIts available methods are:\n\nqueryClient.fetchQuery\nqueryClient.fetchInfiniteQuery\nqueryClient.prefetchQuery\nqueryClient.prefetchInfiniteQuery\nqueryClient.getQueryData\nqueryClient.ensureQueryData\nqueryClient.getQueriesData\nqueryClient.setQueryData\nqueryClient.getQueryState\nqueryClient.setQueriesData\nqueryClient.invalidateQueries\nqueryClient.refetchQueries\nqueryClient.cancelQueries\nqueryClient.removeQueries\nqueryClient.resetQueries\nqueryClient.isFetching\nqueryClient.isMutating\nqueryClient.getDefaultOptions\nqueryClient.setDefaultOptions\nqueryClient.getQueryDefaults\nqueryClient.setQueryDefaults\nqueryClient.getMutationDefaults\nqueryClient.setMutationDefaults\nqueryClient.getQueryCache\nqueryClient.getMutationCache\nqueryClient.clear\nqueryClient.resumePausedMutations\n\nOptions\n\nqueryCache?: QueryCache\nOptional\nThe query cache this client is connected to.\nmutationCache?: MutationCache\nOptional\nThe mutation cache this client is connected to.\ndefaultOptions?: DefaultOptions\nOptional\nDefine defaults for all queries and mutations using this queryClient.\nqueryClient.fetchQuery\n\nfetchQuery is an asynchronous method that can be used to fetch and cache a query. It will either resolve with the data or throw with the error. Use the prefetchQuery method if you just want to fetch a query without needing the result.\n\nIf the query exists and the data is not invalidated or older than the given staleTime, then the data from the cache will be returned. Otherwise it will try to fetch the latest data.\n\nThe difference between using fetchQuery and setQueryData is that fetchQuery is async and will ensure that duplicate requests for this query are not created with useQuery instances for the same query are rendered while the data is fetching.\n\ntsx\ntry {\n  const data = await queryClient.fetchQuery({ queryKey, queryFn })\n} catch (error) {\n  console.log(error)\n}\n\nSpecify a staleTime to only fetch when the data is older than a certain amount of time:\n\ntsx\ntry {\n  const data = await queryClient.fetchQuery({ queryKey, queryFn, staleTime: 10000 })\n} catch (error) {\n  console.log(error)\n}\n\nOptions\n\nThe options for fetchQuery are exactly the same as those of useQuery, except the following: enabled, refetchInterval, refetchIntervalInBackground, refetchOnWindowFocus, refetchOnReconnect, refetchOnMount, notifyOnChangeProps, throwOnError, select, suspense, placeholderData; which are strictly for useQuery and useInfiniteQuery. You can check the source code for more clarity.\n\nReturns\n\nPromise<TData>\nqueryClient.fetchInfiniteQuery\n\nfetchInfiniteQuery is similar to fetchQuery but can be used to fetch and cache an infinite query.\n\ntsx\ntry {\n  const data = await queryClient.fetchInfiniteQuery({ queryKey, queryFn })\n  console.log(data.pages)\n} catch (error) {\n  console.log(error)\n}\n\nOptions\n\nThe options for fetchInfiniteQuery are exactly the same as those of fetchQuery.\n\nReturns\n\nPromise<InfiniteData<TData, TPageParam>>\nqueryClient.prefetchQuery\n\nprefetchQuery is an asynchronous method that can be used to prefetch a query before it is needed or rendered with useQuery and friends. The method works the same as fetchQuery except that it will not throw or return any data.\n\ntsx\nawait queryClient.prefetchQuery({ queryKey, queryFn })\n\nYou can even use it with a default queryFn in your config!\n\ntsx\nawait queryClient.prefetchQuery({ queryKey })\n\nOptions\n\nThe options for prefetchQuery are exactly the same as those of fetchQuery.\n\nReturns\n\nPromise<void>\nA promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.\nqueryClient.prefetchInfiniteQuery\n\nprefetchInfiniteQuery is similar to prefetchQuery but can be used to prefetch and cache an infinite query.\n\ntsx\nawait queryClient.prefetchInfiniteQuery({ queryKey, queryFn })\n\nOptions\n\nThe options for prefetchInfiniteQuery are exactly the same as those of fetchQuery.\n\nReturns\n\nPromise<void>\nA promise is returned that will either immediately resolve if no fetch is needed or after the query has been executed. It will not return any data or throw any errors.\nqueryClient.getQueryData\n\ngetQueryData is a synchronous function that can be used to get an existing query's cached data. If the query does not exist, undefined will be returned.\n\ntsx\nconst data = queryClient.getQueryData(queryKey)\n\nOptions\n\nqueryKey: QueryKey: Query Keys\n\nReturns\n\ndata: TQueryFnData | undefined\nThe data for the cached query, or undefined if the query does not exist.\nqueryClient.ensureQueryData\n\nensureQueryData is an asynchronous function that can be used to get an existing query's cached data. If the query does not exist, queryClient.fetchQuery will be called and its results returned.\n\ntsx\nconst data = await queryClient.ensureQueryData({ queryKey, queryFn })\n\nOptions\n\nThe options for ensureQueryData are exactly the same as those of fetchQuery except that queryKey is required.\n\nReturns\n\nPromise<TData>\nqueryClient.getQueriesData\n\ngetQueriesData is a synchronous function that can be used to get the cached data of multiple queries. Only queries that match the passed queryKey or queryFilter will be returned. If there are no matching queries, an empty array will be returned.\n\ntsx\nconst data = queryClient.getQueriesData(filters)\n\nOptions\n\nfilters: QueryFilters: Query Filters\nif a filter is passed, the data with queryKeys matching the filter will be returned\n\nReturns\n\n[queryKey: QueryKey, data: TQueryFnData | undefined][]\nAn array of tuples for the matched query keys, or [] if there are no matches. The tuples are the query key and its associated data.\n\nCaveats\n\nBecause the returned data in each tuple can be of varying structures (i.e. using a filter to return \"active\" queries can return different data types), the TData generic defaults to unknown. If you provide a more specific type to TData it is assumed that you are certain each tuple's data entry is all the same type.\n\nThis distinction is more a \"convenience\" for ts devs that know which structure will be returned.\n\nqueryClient.setQueryData\n\nsetQueryData is a synchronous function that can be used to immediately update a query's cached data. If the query does not exist, it will be created. If the query is not utilized by a query hook in the default gcTime of 5 minutes, the query will be garbage collected. To update multiple queries at once and match query keys partially, you need to use queryClient.setQueriesData instead.\n\nThe difference between using setQueryData and fetchQuery is that setQueryData is sync and assumes that you already synchronously have the data available. If you need to fetch the data asynchronously, it's suggested that you either refetch the query key or use fetchQuery to handle the asynchronous fetch.\n\ntsx\nqueryClient.setQueryData(queryKey, updater)\n\nOptions\n\nqueryKey: QueryKey: Query Keys\nupdater: TQueryFnData | undefined | ((oldData: TQueryFnData | undefined) => TQueryFnData | undefined)\nIf non-function is passed, the data will be updated to this value\nIf a function is passed, it will receive the old data value and be expected to return a new one.\n\nUsing an updater value\n\ntsx\nsetQueryData(queryKey, newData)\n\nIf the value is undefined, the query data is not updated.\n\nUsing an updater function\n\nFor convenience in syntax, you can also pass an updater function which receives the current data value and returns the new one:\n\ntsx\nsetQueryData(queryKey, oldData => newData)\n\nIf the updater function returns undefined, the query data will not be updated. If the updater function receives undefined as input, you can return undefined to bail out of the update and thus not create a new cache entry.\n\nImmutability\n\nUpdates via setQueryData must be performed in an immutable way. DO NOT attempt to write directly to the cache by mutating oldData or data that you retrieved via getQueryData in place.\n\nqueryClient.getQueryState\n\ngetQueryState is a synchronous function that can be used to get an existing query's state. If the query does not exist, undefined will be returned.\n\ntsx\nconst state = queryClient.getQueryState(queryKey)\nconsole.log(state.dataUpdatedAt)\n\nOptions\n\nqueryKey: QueryKey: Query Keys\nqueryClient.setQueriesData\n\nsetQueriesData is a synchronous function that can be used to immediately update cached data of multiple queries by using filter function or partially matching the query key. Only queries that match the passed queryKey or queryFilter will be updated - no new cache entries will be created. Under the hood, setQueryData is called for each existing query.\n\ntsx\nqueryClient.setQueriesData(filters, updater)\n\nOptions\n\nfilters: QueryFilters: Query Filters\nif a filter is passed, queryKeys matching the filter will be updated\nupdater: TQueryFnData | (oldData: TQueryFnData | undefined) => TQueryFnData\nthe setQueryData updater function or new data, will be called for each matching queryKey\nqueryClient.invalidateQueries\n\nThe invalidateQueries method can be used to invalidate and refetch single or multiple queries in the cache based on their query keys or any other functionally accessible property/state of the query. By default, all matching queries are immediately marked as invalid and active queries are refetched in the background.\n\nIf you do not want active queries to refetch, and simply be marked as invalid, you can use the refetchType: 'none' option.\nIf you want inactive queries to refetch as well, use the refetchType: 'all' option\ntsx\nawait queryClient.invalidateQueries({\n  queryKey: ['posts'],\n  exact,\n  refetchType: 'active',\n}, { throwOnError, cancelRefetch })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\nqueryKey?: QueryKey: Query Keys\nrefetchType?: 'active' | 'inactive' | 'all' | 'none'\nDefaults to 'active'\nWhen set to active, only queries that match the refetch predicate and are actively being rendered via useQuery and friends will be refetched in the background.\nWhen set to inactive, only queries that match the refetch predicate and are NOT actively being rendered via useQuery and friends will be refetched in the background.\nWhen set to all, all queries that match the refetch predicate will be refetched in the background.\nWhen set to none, no queries will be refetched, and those that match the refetch predicate will be marked as invalid only.\noptions?: InvalidateOptions:\nthrowOnError?: boolean\nWhen set to true, this method will throw if any of the query refetch tasks fail.\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running.\nqueryClient.refetchQueries\n\nThe refetchQueries method can be used to refetch queries based on certain conditions.\n\nExamples:\n\ntsx\n// refetch all queries:\nawait queryClient.refetchQueries()\n\n\n// refetch all stale queries:\nawait queryClient.refetchQueries({ stale: true })\n\n\n// refetch all active queries partially matching a query key:\nawait queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })\n\n\n// refetch all active queries exactly matching a query key:\nawait queryClient.refetchQueries({ queryKey: ['posts', 1], type: 'active', exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\noptions?: RefetchOptions:\nthrowOnError?: boolean\nWhen set to true, this method will throw if any of the query refetch tasks fail.\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running.\n\nReturns\n\nThis function returns a promise that will resolve when all of the queries are done being refetched. By default, it will not throw an error if any of those queries refetches fail, but this can be configured by setting the throwOnError option to true\n\nqueryClient.cancelQueries\n\nThe cancelQueries method can be used to cancel outgoing queries based on their query keys or any other functionally accessible property/state of the query.\n\nThis is most useful when performing optimistic updates since you will likely need to cancel any outgoing query refetches so they don't clobber your optimistic update when they resolve.\n\ntsx\nawait queryClient.cancelQueries({ queryKey: ['posts'], exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nThis method does not return anything\n\nqueryClient.removeQueries\n\nThe removeQueries method can be used to remove queries from the cache based on their query keys or any other functionally accessible property/state of the query.\n\ntsx\nqueryClient.removeQueries({ queryKey, exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nThis method does not return anything\n\nqueryClient.resetQueries\n\nThe resetQueries method can be used to reset queries in the cache to their initial state based on their query keys or any other functionally accessible property/state of the query.\n\nThis will notify subscribers ‚Äî unlike clear, which removes all subscribers ‚Äî and reset the query to its pre-loaded state ‚Äî unlike invalidateQueries. If a query has initialData, the query's data will be reset to that. If a query is active, it will be refetched.\n\ntsx\nqueryClient.resetQueries({ queryKey, exact: true })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\noptions?: ResetOptions:\nthrowOnError?: boolean\nWhen set to true, this method will throw if any of the query refetch tasks fail.\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running.\n\nReturns\n\nThis method returns a promise that resolves when all active queries have been refetched.\n\nqueryClient.isFetching\n\nThis isFetching method returns an integer representing how many queries, if any, in the cache are currently fetching (including background-fetching, loading new pages, or loading more infinite query results)\n\ntsx\nif (queryClient.isFetching()) {\n  console.log('At least one query is fetching!')\n}\n\nTanStack Query also exports a handy useIsFetching hook that will let you subscribe to this state in your components without creating a manual subscription to the query cache.\n\nOptions\n\nfilters?: QueryFilters: Query Filters\n\nReturns\n\nThis method returns the number of fetching queries.\n\nqueryClient.isMutating\n\nThis isMutating method returns an integer representing how many mutations, if any, in the cache are currently fetching.\n\ntsx\nif (queryClient.isMutating()) {\n  console.log('At least one mutation is fetching!')\n}\n\nTanStack Query also exports a handy useIsMutating hook that will let you subscribe to this state in your components without creating a manual subscription to the mutation cache.\n\nOptions\n\nfilters: MutationFilters: Mutation Filters\n\nReturns\n\nThis method returns the number of fetching mutations.\n\nqueryClient.getDefaultOptions\n\nThe getDefaultOptions method returns the default options which have been set when creating the client or with setDefaultOptions.\n\ntsx\nconst defaultOptions = queryClient.getDefaultOptions()\nqueryClient.setDefaultOptions\n\nThe setDefaultOptions method can be used to dynamically set the default options for this queryClient. Previously defined default options will be overwritten.\n\ntsx\nqueryClient.setDefaultOptions({\n  queries: {\n    staleTime: Infinity,\n  },\n})\nqueryClient.getQueryDefaults\n\nThe getQueryDefaults method returns the default options which have been set for specific queries:\n\ntsx\nconst defaultOptions = queryClient.getQueryDefaults(['posts'])\n\nNote that if several query defaults match the given query key, the first matching one is returned. This could lead to unexpected behaviours. See setQueryDefaults.\n\nqueryClient.setQueryDefaults\n\nsetQueryDefaults can be used to set default options for specific queries:\n\ntsx\nqueryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })\n\n\nfunction Component() {\n  const { data } = useQuery({ queryKey: ['posts'] })\n}\n\nOptions\n\nqueryKey: QueryKey: Query Keys\noptions: QueryOptions\n\nAs stated in getQueryDefaults, the order of registration of query defaults does matter. Since the first matching defaults are returned by getQueryDefaults, the registration should be made in the following order: from the least generic key to the most generic one. This way, in case of specific key, the first matching one would be the expected one.\n\nqueryClient.getMutationDefaults\n\nThe getMutationDefaults method returns the default options which have been set for specific mutations:\n\ntsx\nconst defaultOptions = queryClient.getMutationDefaults(['addPost'])\nqueryClient.setMutationDefaults\n\nsetMutationDefaults can be used to set default options for specific mutations:\n\ntsx\nqueryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })\n\n\nfunction Component() {\n  const { data } = useMutation({ mutationKey: ['addPost'] })\n}\n\nOptions\n\nmutationKey: unknown[]\noptions: MutationOptions\n\nSimilar to setQueryDefaults, the order of registration does matter here.\n\nqueryClient.getQueryCache\n\nThe getQueryCache method returns the query cache this client is connected to.\n\ntsx\nconst queryCache = queryClient.getQueryCache()\nqueryClient.getMutationCache\n\nThe getMutationCache method returns the mutation cache this client is connected to.\n\ntsx\nconst mutationCache = queryClient.getMutationCache()\nqueryClient.clear\n\nThe clear method clears all connected caches.\n\ntsx\nqueryClient.clear()\nqueryClient.resumePausedMutations\n\nCan be used to resume mutations that have been paused because there was no network connection.\n\ntsx\nqueryClient.resumePausedMutations()"
  },
  {
    "title": "MutationCache | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/MutationCache",
    "html": "MutationCache\n\nThe MutationCache is the storage for mutations.\n\nNormally, you will not interact with the MutationCache directly and instead use the QueryClient.\n\ntsx\nimport { MutationCache } from '@tanstack/react-query'\n\n\nconst mutationCache = new MutationCache({\n  onError: error => {\n    console.log(error)\n  },\n  onSuccess: data => {\n    console.log(data)\n  },\n})\n\nIts available methods are:\n\ngetAll\nsubscribe\nclear\n\nOptions\n\nonError?: (error: unknown, variables: unknown, context: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called if some mutation encounters an error.\nIf you return a Promise from it, it will be awaited\nonSuccess?: (data: unknown, variables: unknown, context: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called if some mutation is successful.\nIf you return a Promise from it, it will be awaited\nonSettled?: (data: unknown | undefined, error: unknown | null, variables: unknown, context: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called if some mutation is settled (either successful or errored).\nIf you return a Promise from it, it will be awaited\nonMutate?: (variables: unknown, mutation: Mutation) => Promise<unknown> | unknown\nOptional\nThis function will be called before some mutation executes.\nIf you return a Promise from it, it will be awaited\nGlobal callbacks\n\nThe onError, onSuccess, onSettled and onMutate callbacks on the MutationCache can be used to handle these events on a global level. They are different to defaultOptions provided to the QueryClient because:\n\ndefaultOptions can be overridden by each Mutation - the global callbacks will always be called.\nonMutate does not allow returning a context value.\nmutationCache.getAll\n\ngetAll returns all mutations within the cache.\n\nNote: This is not typically needed for most applications, but can come in handy when needing more information about a mutation in rare scenarios\n\ntsx\nconst mutations = mutationCache.getAll()\n\nReturns\n\nMutation[]\nMutation instances from the cache\nmutationCache.subscribe\n\nThe subscribe method can be used to subscribe to the mutation cache as a whole and be informed of safe/known updates to the cache like mutation states changing or mutations being updated, added or removed.\n\ntsx\nconst callback = event => {\n  console.log(event.type, event.mutation)\n}\n\n\nconst unsubscribe = mutationCache.subscribe(callback)\n\nOptions\n\ncallback: (mutation?: MutationCacheNotifyEvent) => void\nThis function will be called with the mutation cache any time it is updated.\n\nReturns\n\nunsubscribe: Function => void\nThis function will unsubscribe the callback from the mutation cache.\nmutationCache.clear\n\nThe clear method can be used to clear the cache entirely and start fresh.\n\ntsx\nmutationCache.clear()"
  },
  {
    "title": "useQueryClient | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useQueryClient",
    "html": "useQueryClient\n\nThe useQueryClient hook returns the current QueryClient instance.\n\ntsx\nimport { useQueryClient } from '@tanstack/react-query'\n\n\nconst queryClient = useQueryClient(queryClient?: QueryClient)\n\nOptions\n\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used."
  },
  {
    "title": "QueryClientProvider | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/QueryClientProvider",
    "html": "QueryClientProvider\n\nUse the QueryClientProvider component to connect and provide a QueryClient to your application:\n\ntsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\n\nconst queryClient = new QueryClient()\n\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n\nOptions\n\nclient: QueryClient\nRequired\nthe QueryClient instance to provide"
  },
  {
    "title": "useSuspenseQueries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useSuspenseQueries",
    "html": "useSuspenseQueries\ntsx\nconst result = useSuspenseQueries(options)\n\nOptions\n\nThe same as for useQueries, except that each query can't have:\n\nsuspense\nthrowOnError\nenabled\nplaceholderData\n\nReturns\n\nSame structure as useQueries, except that for each query:\n\ndata is guaranteed to be defined\nisPlaceholderData is missing\nstatus is always success\nthe derived flags are set accordingly."
  },
  {
    "title": "useSuspenseInfiniteQuery | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useSuspenseInfiniteQuery",
    "html": "useSuspenseInfiniteQuery\ntsx\nconst result = useSuspenseInfiniteQuery(options)\n\nOptions\n\nThe same as for useInfiniteQuery, except for:\n\nsuspense\nthrowOnError\nenabled\nplaceholderData\n\nReturns\n\nSame object as useInfiniteQuery, except that:\n\ndata is guaranteed to be defined\nisPlaceholderData is missing\nstatus is always success\nthe derived flags are set accordingly."
  },
  {
    "title": "useSuspenseQuery | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useSuspenseQuery",
    "html": "useSuspenseQuery\ntsx\nconst result = useSuspenseQuery(options)\n\nOptions\n\nThe same as for useQuery, except for:\n\nsuspense\nthrowOnError\nenabled\nplaceholderData\n\nReturns\n\nSame object as useQuery, except that:\n\ndata is guaranteed to be defined\nisPlaceholderData is missing\nstatus is always success\nthe derived flags are set accordingly."
  },
  {
    "title": "useMutationState | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useMutationState",
    "html": "useMutationState\n\nuseMutationState is a hook that gives you access to all mutations in the MutationCache. You can pass filters to it to narrow down your mutations, and select to transform the mutation state.\n\nExample 1: Get all variables of all running mutations\n\ntsx\nimport { useMutationState } from '@tanstack/react-query'\n\n\nconst variables = useMutationState({\n  filters: { status: 'pending' },\n  select: (mutation) => mutation.state.variables,\n})\n\nExample 2: Get all data for specific mutations via the mutationKey\n\ntsx\nimport { useMutation, useMutationState } from '@tanstack/react-query'\n\n\nconst mutationKey = ['posts']\n\n\n// Some mutation that we want to get the state for\nconst mutation = useMutation({\n  mutationKey,\n  mutationFn: (newPost) => {\n    return axios.post('/posts', newPost)\n  },\n})\n\n\nconst data = useMutationState({\n  // this mutation key needs to match the mutation key of the given mutation (see above)\n  filters: { mutationKey },\n  select: (mutation) => mutation.state.data,\n})\n\nOptions\n\noptions\nfilters?: MutationFilters: Mutation Filters\nselect?: (mutation: Mutation) => TResult\nUse this to transform the mutation state.\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nArray<TResult>\nWill be an Array of whatever select returns for each matching mutation."
  },
  {
    "title": "useIsMutating | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useIsMutating",
    "html": "useIsMutating\n\nuseIsMutating is an optional hook that returns the number of mutations that your application is fetching (useful for app-wide loading indicators).\n\ntsx\nimport { useIsMutating } from '@tanstack/react-query'\n// How many mutations are fetching?\nconst isMutating = useIsMutating()\n// How many mutations matching the posts prefix are fetching?\nconst isMutatingPosts = useIsMutating({ mutationKey: ['posts'] })\n\nOptions\n\nfilters?: MutationFilters: Mutation Filters\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nisMutating: number\nWill be the number of the mutations that your application is currently fetching."
  },
  {
    "title": "useIsFetching | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useIsFetching",
    "html": "useIsFetching\n\nuseIsFetching is an optional hook that returns the number of the queries that your application is loading or fetching in the background (useful for app-wide loading indicators).\n\ntsx\nimport { useIsFetching } from '@tanstack/react-query'\n// How many queries are fetching?\nconst isFetching = useIsFetching()\n// How many queries matching the posts prefix are fetching?\nconst isFetchingPosts = useIsFetching({ queryKey: ['posts'] })\n\nOptions\n\nfilters?: QueryFilters: Query Filters\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nisFetching: number\nWill be the number of the queries that your application is currently loading or fetching in the background."
  },
  {
    "title": "useMutation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useMutation",
    "html": "useMutation\ntsx\nconst {\n  data,\n  error,\n  isError,\n  isIdle,\n  isPending,\n  isPaused,\n  isSuccess,\n  failureCount,\n  failureReason,\n  mutate,\n  mutateAsync,\n  reset,\n  status,\n  submittedAt,\n  variables,\n} = useMutation({\n  mutationFn,\n  gcTime,\n  mutationKey,\n  networkMode,\n  onError,\n  onMutate,\n  onSettled,\n  onSuccess,\n  retry,\n  retryDelay,\n  throwOnError,\n  meta,\n})\n\n\nmutate(variables, {\n  onError,\n  onSettled,\n  onSuccess,\n})\n\nOptions\n\nmutationFn: (variables: TVariables) => Promise<TData>\nRequired, but only if no default mutation function has been defined\nA function that performs an asynchronous task and returns a promise.\nvariables is an object that mutate will pass to your mutationFn\ngcTime: number | Infinity\nThe time in milliseconds that unused/inactive cache data remains in memory. When a mutation's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different cache times are specified, the longest one will be used.\nIf set to Infinity, will disable garbage collection\nmutationKey: unknown[]\nOptional\nA mutation key can be set to inherit defaults set with queryClient.setMutationDefaults.\nnetworkMode: 'online' | 'always' | 'offlineFirst\noptional\ndefaults to 'online'\nsee Network Mode for more information.\nonMutate: (variables: TVariables) => Promise<TContext | void> | TContext | void\nOptional\nThis function will fire before the mutation function is fired and is passed the same variables the mutation function would receive\nUseful to perform optimistic updates to a resource in hopes that the mutation succeeds\nThe value returned from this function will be passed to both the onError and onSettled functions in the event of a mutation failure and can be useful for rolling back optimistic updates.\nonSuccess: (data: TData, variables: TVariables, context?: TContext) => Promise<unknown> | unknown\nOptional\nThis function will fire when the mutation is successful and will be passed the mutation's result.\nIf a promise is returned, it will be awaited and resolved before proceeding\nonError: (err: TError, variables: TVariables, context?: TContext) => Promise<unknown> | unknown\nOptional\nThis function will fire if the mutation encounters an error and will be passed the error.\nIf a promise is returned, it will be awaited and resolved before proceeding\nonSettled: (data: TData, error: TError, variables: TVariables, context?: TContext) => Promise<unknown> | unknown\nOptional\nThis function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error\nIf a promise is returned, it will be awaited and resolved before proceeding\nretry: boolean | number | (failureCount: number, error: TError) => boolean\nDefaults to 0.\nIf false, failed mutations will not retry.\nIf true, failed mutations will retry infinitely.\nIf set to an number, e.g. 3, failed mutations will retry until the failed mutations count meets that number.\nretryDelay: number | (retryAttempt: number, error: TError) => number\nThis function receives a retryAttempt integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.\nA function like attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) applies exponential backoff.\nA function like attempt => attempt * 1000 applies linear backoff.\nthrowOnError: undefined | boolean | (error: TError) => boolean\nDefaults to the global query config's throwOnError value, which is undefined\nSet this to true if you want mutation errors to be thrown in the render phase and propagate to the nearest error boundary\nSet this to false to disable the behavior of throwing errors to the error boundary.\nIf set to a function, it will be passed the error and should return a boolean indicating whether to show the error in an error boundary (true) or return the error as state (false)\nmeta: Record<string, unknown>\nOptional\nIf set, stores additional information on the mutation cache entry that can be used as needed. It will be accessible wherever the mutation is available (eg. onError, onSuccess functions of the MutationCache).\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nmutate: (variables: TVariables, { onSuccess, onSettled, onError }) => void\nThe mutation function you can call with variables to trigger the mutation and optionally hooks on additional callback options.\nvariables: TVariables\nOptional\nThe variables object to pass to the mutationFn.\nonSuccess: (data: TData, variables: TVariables, context: TContext) => void\nOptional\nThis function will fire when the mutation is successful and will be passed the mutation's result.\nVoid function, the returned value will be ignored\nonError: (err: TError, variables: TVariables, context: TContext | undefined) => void\nOptional\nThis function will fire if the mutation encounters an error and will be passed the error.\nVoid function, the returned value will be ignored\nonSettled: (data: TData | undefined, error: TError | null, variables: TVariables, context: TContext | undefined) => void\nOptional\nThis function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error\nVoid function, the returned value will be ignored\nIf you make multiple requests, onSuccess will fire only after the latest call you've made.\nmutateAsync: (variables: TVariables, { onSuccess, onSettled, onError }) => Promise<TData>\nSimilar to mutate but returns a promise which can be awaited.\nstatus: string\nWill be:\nidle initial status prior to the mutation function executing.\npending if the mutation is currently executing.\nerror if the last mutation attempt resulted in an error.\nsuccess if the last mutation attempt was successful.\nisIdle, isPending, isSuccess, isError: boolean variables derived from status\nisPaused: boolean\nwill be true if the mutation has been paused\nsee Network Mode for more information.\ndata: undefined | unknown\nDefaults to undefined\nThe last successfully resolved data for the query.\nerror: null | TError\nThe error object for the query, if an error was encountered.\nreset: () => void\nA function to clean the mutation internal state (i.e., it resets the mutation to its initial state).\nfailureCount: number\nThe failure count for the mutation.\nIncremented every time the mutation fails.\nReset to 0 when the mutation succeeds.\nfailureReason: null | TError\nThe failure reason for the mutation retry.\nReset to null when the mutation succeeds.\nsubmittedAt: number\nThe timestamp for when the mutation was submitted.\nDefaults to 0.\nvariables: undefined | TVariables\nThe variables object passed to the mutationFn.\nDefaults to undefined."
  },
  {
    "title": "useQuery | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useQuery",
    "html": "useQuery\ntsx\nconst {\n  data,\n  dataUpdatedAt,\n  error,\n  errorUpdatedAt,\n  failureCount,\n  failureReason,\n  fetchStatus,\n  isError,\n  isFetched,\n  isFetchedAfterMount,\n  isFetching,\n  isInitialLoading,\n  isLoading,\n  isLoadingError,\n  isPaused,\n  isPending,\n  isPlaceholderData,\n  isRefetchError,\n  isRefetching,\n  isStale,\n  isSuccess,\n  refetch,\n  status,\n} = useQuery({\n  queryKey,\n  queryFn,\n  gcTime,\n  enabled,\n  networkMode,\n  initialData,\n  initialDataUpdatedAt,\n  meta,\n  notifyOnChangeProps,\n  placeholderData,\n  queryKeyHashFn,\n  refetchInterval,\n  refetchIntervalInBackground,\n  refetchOnMount,\n  refetchOnReconnect,\n  refetchOnWindowFocus,\n  retry,\n  retryOnMount,\n  retryDelay,\n  select,\n  staleTime,\n  structuralSharing,\n  throwOnError,\n})\n\nOptions\n\nqueryKey: unknown[]\nRequired\nThe query key to use for this query.\nThe query key will be hashed into a stable hash. See Query Keys for more information.\nThe query will automatically update when this key changes (as long as enabled is not set to false).\nqueryFn: (context: QueryFunctionContext) => Promise<TData>\nRequired, but only if no default query function has been defined See Default Query Function for more information.\nThe function that the query will use to request data.\nReceives a QueryFunctionContext\nMust return a promise that will either resolve data or throw an error. The data cannot be undefined.\nenabled: boolean\nSet this to false to disable this query from automatically running.\nCan be used for Dependent Queries.\nnetworkMode: 'online' | 'always' | 'offlineFirst\noptional\ndefaults to 'online'\nsee Network Mode for more information.\nretry: boolean | number | (failureCount: number, error: TError) => boolean\nIf false, failed queries will not retry by default.\nIf true, failed queries will retry infinitely.\nIf set to a number, e.g. 3, failed queries will retry until the failed query count meets that number.\ndefaults to 3 on the client and 0 on the server\nretryOnMount: boolean\nIf set to false, the query will not be retried on mount if it contains an error. Defaults to true.\nretryDelay: number | (retryAttempt: number, error: TError) => number\nThis function receives a retryAttempt integer and the actual Error and returns the delay to apply before the next attempt in milliseconds.\nA function like attempt => Math.min(attempt > 1 ? 2 ** attempt * 1000 : 1000, 30 * 1000) applies exponential backoff.\nA function like attempt => attempt * 1000 applies linear backoff.\nstaleTime: number | Infinity\nOptional\nDefaults to 0\nThe time in milliseconds after data is considered stale. This value only applies to the hook it is defined on.\nIf set to Infinity, the data will never be considered stale\ngcTime: number | Infinity\nDefaults to 5 * 60 * 1000 (5 minutes) or Infinity during SSR\nThe time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times are specified, the longest one will be used.\nIf set to Infinity, will disable garbage collection\nqueryKeyHashFn: (queryKey: QueryKey) => string\nOptional\nIf specified, this function is used to hash the queryKey to a string.\nrefetchInterval: number | false | ((query: Query) => number | false | undefined)\nOptional\nIf set to a number, all queries will continuously refetch at this frequency in milliseconds\nIf set to a function, the function will be executed with the query to compute a frequency\nrefetchIntervalInBackground: boolean\nOptional\nIf set to true, queries that are set to continuously refetch with a refetchInterval will continue to refetch while their tab/window is in the background\nrefetchOnMount: boolean | \"always\" | ((query: Query) => boolean | \"always\")\nOptional\nDefaults to true\nIf set to true, the query will refetch on mount if the data is stale.\nIf set to false, the query will not refetch on mount.\nIf set to \"always\", the query will always refetch on mount.\nIf set to a function, the function will be executed with the query to compute the value\nrefetchOnWindowFocus: boolean | \"always\" | ((query: Query) => boolean | \"always\")\nOptional\nDefaults to true\nIf set to true, the query will refetch on window focus if the data is stale.\nIf set to false, the query will not refetch on window focus.\nIf set to \"always\", the query will always refetch on window focus.\nIf set to a function, the function will be executed with the query to compute the value\nrefetchOnReconnect: boolean | \"always\" | ((query: Query) => boolean | \"always\")\nOptional\nDefaults to true\nIf set to true, the query will refetch on reconnect if the data is stale.\nIf set to false, the query will not refetch on reconnect.\nIf set to \"always\", the query will always refetch on reconnect.\nIf set to a function, the function will be executed with the query to compute the value\nnotifyOnChangeProps: string[] | \"all\" | (() => string[] | \"all\")\nOptional\nIf set, the component will only re-render if any of the listed properties change.\nIf set to ['data', 'error'] for example, the component will only re-render when the data or error properties change.\nIf set to \"all\", the component will opt-out of smart tracking and re-render whenever a query is updated.\nIf set to a function, the function will be executed to compute the list of properties.\nBy default, access to properties will be tracked, and the component will only re-render when one of the tracked properties change.\nselect: (data: TData) => unknown\nOptional\nThis option can be used to transform or select a part of the data returned by the query function. It affects the returned data value, but does not affect what gets stored in the query cache.\ninitialData: TData | () => TData\nOptional\nIf set, this value will be used as the initial data for the query cache (as long as the query hasn't been created or cached yet)\nIf set to a function, the function will be called once during the shared/root query initialization, and be expected to synchronously return the initialData\nInitial data is considered stale by default unless a staleTime has been set.\ninitialData is persisted to the cache\ninitialDataUpdatedAt: number | (() => number | undefined)\nOptional\nIf set, this value will be used as the time (in milliseconds) of when the initialData itself was last updated.\nplaceholderData: TData | (previousValue: TData | undefined; previousQuery: Query | undefined,) => TData\nOptional\nIf set, this value will be used as the placeholder data for this particular query observer while the query is still in the pending state.\nplaceholderData is not persisted to the cache\nIf you provide a function for placeholderData, as a first argument you will receive previously watched query data if available, and the second argument will be the complete previousQuery instance.\nstructuralSharing: boolean | (<T>(oldData: T | undefined, newData: T) => T)\nOptional\nDefaults to true\nIf set to false, structural sharing between query results will be disabled.\nIf set to a function, the old and new data values will be passed through this function, which should combine them into resolved data for the query. This way, you can retain references from the old data to improve performance even when that data contains non-serializable values.\nthrowOnError: undefined | boolean | (error: TError, query: Query) => boolean\nDefaults to the global query config's throwOnError value, which is undefined\nSet this to true if you want errors to be thrown in the render phase and propagate to the nearest error boundary\nSet this to false to disable suspense's default behavior of throwing errors to the error boundary.\nIf set to a function, it will be passed the error and the query, and it should return a boolean indicating whether to show the error in an error boundary (true) or return the error as state (false)\nmeta: Record<string, unknown>\nOptional\nIf set, stores additional information on the query cache entry that can be used as needed. It will be accessible wherever the query is available, and is also part of the QueryFunctionContext provided to the queryFn.\nqueryClient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\n\nReturns\n\nstatus: String\nWill be:\npending if there's no cached data and no query attempt was finished yet.\nerror if the query attempt resulted in an error. The corresponding error property has the error received from the attempted fetch\nsuccess if the query has received a response with no errors and is ready to display its data. The corresponding data property on the query is the data received from the successful fetch or if the query's enabled property is set to false and has not been fetched yet data is the first initialData supplied to the query on initialization.\nisPending: boolean\nA derived boolean from the status variable above, provided for convenience.\nisSuccess: boolean\nA derived boolean from the status variable above, provided for convenience.\nisError: boolean\nA derived boolean from the status variable above, provided for convenience.\nisLoadingError: boolean\nWill be true if the query failed while fetching for the first time.\nisRefetchError: boolean\nWill be true if the query failed while refetching.\ndata: TData\nDefaults to undefined.\nThe last successfully resolved data for the query.\ndataUpdatedAt: number\nThe timestamp for when the query most recently returned the status as \"success\".\nerror: null | TError\nDefaults to null\nThe error object for the query, if an error was thrown.\nerrorUpdatedAt: number\nThe timestamp for when the query most recently returned the status as \"error\".\nisStale: boolean\nWill be true if the data in the cache is invalidated or if the data is older than the given staleTime.\nisPlaceholderData: boolean\nWill be true if the data shown is the placeholder data.\nisFetched: boolean\nWill be true if the query has been fetched.\nisFetchedAfterMount: boolean\nWill be true if the query has been fetched after the component mounted.\nThis property can be used to not show any previously cached data.\nfetchStatus: FetchStatus\nfetching: Is true whenever the queryFn is executing, which includes initial pending as well as background refetches.\npaused: The query wanted to fetch, but has been paused.\nidle: The query is not fetching.\nsee Network Mode for more information.\nisFetching: boolean\nA derived boolean from the fetchStatus variable above, provided for convenience.\nisPaused: boolean\nA derived boolean from the fetchStatus variable above, provided for convenience.\nisRefetching: boolean\nIs true whenever a background refetch is in-flight, which does not include initial pending\nIs the same as isFetching && !isPending\nisLoading: boolean\nIs true whenever the first fetch for a query is in-flight\nIs the same as isFetching && isPending\nisInitialLoading: boolean\ndeprecated\nAn alias for isLoading, will be removed in the next major version.\nfailureCount: number\nThe failure count for the query.\nIncremented every time the query fails.\nReset to 0 when the query succeeds.\nfailureReason: null | TError\nThe failure reason for the query retry.\nReset to null when the query succeeds.\nerrorUpdateCount: number\nThe sum of all errors.\nrefetch: (options: { throwOnError: boolean, cancelRefetch: boolean }) => Promise<UseQueryResult>\nA function to manually refetch the query.\nIf the query errors, the error will only be logged. If you want an error to be thrown, pass the throwOnError: true option\ncancelRefetch?: boolean\nDefaults to true\nPer default, a currently running request will be cancelled before a new request is made\nWhen set to false, no refetch will be made if there is already a request running."
  },
  {
    "title": "experimental_createPersister | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/plugins/createPersister",
    "html": "experimental_createPersister\nInstallation\n\nThis utility comes as a separate package and is available under the '@tanstack/query-persist-client-core' import.\n\nbash\nnpm install @tanstack/query-persist-client-core\n\nor\n\nbash\npnpm add @tanstack/query-persist-client-core\n\nor\n\nbash\nyarn add @tanstack/query-persist-client-core\n\nNote: This util is also included in the @tanstack/react-query-persist-client package, so you do not need to install it separately if you are using that package.\n\nUsage\nImport the experimental_createPersister function\nCreate a new experimental_createPersister\nyou can pass any storage to it that adheres to the AsyncStorage or Storage interface - the example below uses the async-storage from React Native.\nPass that persister as an option to your Query. This can be done either by passing it to the defaultOptions of the QueryClient or to any useQuery hook instance.\nIf you pass this persister as defaultOptions, all queries will be persisted to the provided storage. You can additionally narrow this down by passing filters. In contrast to the persistClient plugin, this will not persist the whole query client as a single item, but each query separately. As a key, the query hash is used.\nIf you provide this persister to a single useQuery hook, only this Query will be persisted.\n\nThis way, you do not need to store whole QueryClient, but choose what is worth to be persisted in your application. Each query is lazily restored (when the Query is first used) and persisted (after each run of the queryFn), so it does not need to be throttled. staleTime is also respected after restoring the Query, so if data is considered stale, it will be refetched immediately after restoring. If data is fresh, the queryFn will not run.\n\nGarbage collecting a Query from memory does not affect the persisted data. That means Queries can be kept in memory for a shorter period of time to be more memory efficient. If they are used the next time, they will just be restored from the persistent storage again.\n\ntsx\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { QueryClient } from '@tanstack/react-query'\nimport { experimental_createPersister } from '@tanstack/query-persist-client-core'\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 30, // 30 seconds\n      persister: experimental_createPersister({\n        storage: AsyncStorage,\n        maxAge: 1000 * 60 * 60 * 12 // 12 hours\n      }),\n    },\n  },\n})\nAdapted defaults\n\nThe createPersister plugin technically wraps the queryFn, so it doesn't restore if the queryFn doesn't run. In that way, it acts as a caching layer between the Query and the network. Thus, the networkMode defaults to 'offlineFirst' when a persister is used, so that restoring from the persistent storage can also happen even if there is no network connection.\n\nAPI experimental_createPersister\ntsx\nexperimental_createPersister(options: StoragePersisterOptions)\nOptions\ntsx\nexport interface StoragePersisterOptions {\n  /** The storage client used for setting and retrieving items from cache.\n   * For SSR pass in `undefined`.\n   */\n  storage: AsyncStorage | Storage | undefined | null\n  /**\n   * How to serialize the data to storage.\n   * @default `JSON.stringify`\n   */\n  serialize?: (persistedQuery: PersistedQuery) => string\n  /**\n   * How to deserialize the data from storage.\n   * @default `JSON.parse`\n   */\n  deserialize?: (cachedString: string) => PersistedQuery\n  /**\n   * A unique string that can be used to forcefully invalidate existing caches,\n   * if they do not share the same buster string\n   */\n  buster?: string\n  /**\n   * The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be discarded\n   * @default 24 hours\n   */\n  maxAge?: number\n  /**\n   * Prefix to be used for storage key.\n   * Storage key is a combination of prefix and query hash in a form of `prefix-queryHash`.\n   */\n  prefix?: string\n  /**\n   * Filters to narrow down which Queries should be persisted.\n   */\n  filters?: QueryFilters\n}\n\n\ninterface AsyncStorage {\n  getItem: (key: string) => Promise<string | undefined | null>\n  setItem: (key: string, value: string) => Promise<unknown>\n  removeItem: (key: string) => Promise<void>\n}\n\nThe default options are:\n\ntsx\n{\n  prefix = 'tanstack-query',\n  maxAge = 1000 * 60 * 60 * 24,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n}"
  },
  {
    "title": "useInfiniteQuery | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useInfiniteQuery",
    "html": "useInfiniteQuery\ntsx\nconst {\n  fetchNextPage,\n  fetchPreviousPage,\n  hasNextPage,\n  hasPreviousPage,\n  isFetchingNextPage,\n  isFetchingPreviousPage,\n  ...result\n} = useInfiniteQuery({\n  queryKey,\n  queryFn: ({ pageParam }) => fetchPage(pageParam),\n  initialPageParam: 1,\n  ...options,\n  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>\n    lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>\n    firstPage.prevCursor,\n})\n\nOptions\n\nThe options for useInfiniteQuery are identical to the useQuery hook with the addition of the following:\n\nqueryFn: (context: QueryFunctionContext) => Promise<TData>\nRequired, but only if no default query function has been defined defaultQueryFn\nThe function that the query will use to request data.\nReceives a QueryFunctionContext\nMust return a promise that will either resolve data or throw an error.\ninitialPageParam: TPageParam\nRequired\nThe default page param to use when fetching the first page.\ngetNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => TPageParam | undefined | null\nRequired\nWhen new data is received for this query, this function receives both the last page of the infinite list of data and the full array of all pages, as well as pageParam information.\nIt should return a single variable that will be passed as the last optional parameter to your query function.\nReturn undefined or null to indicate there is no next page available.\ngetPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) => TPageParam | undefined | null\nWhen new data is received for this query, this function receives both the first page of the infinite list of data and the full array of all pages, as well as pageParam information.\nIt should return a single variable that will be passed as the last optional parameter to your query function.\nReturn undefined or nullto indicate there is no previous page available.\nmaxPages: number | undefined\nThe maximum number of pages to store in the infinite query data.\nWhen the maximum number of pages is reached, fetching a new page will result in the removal of either the first or last page from the pages array, depending on the specified direction.\nIf undefined or equals 0, the number of pages is unlimited\nDefault value is undefined\ngetNextPageParam and getPreviousPageParam must be properly defined if maxPages value is greater than 0 to allow fetching a page in both directions when needed.\n\nReturns\n\nThe returned properties for useInfiniteQuery are identical to the useQuery hook, with the addition of the following and a small difference in isRefetching:\n\ndata.pages: TData[]\nArray containing all pages.\ndata.pageParams: unknown[]\nArray containing all page params.\nisFetchingNextPage: boolean\nWill be true while fetching the next page with fetchNextPage.\nisFetchingPreviousPage: boolean\nWill be true while fetching the previous page with fetchPreviousPage.\nfetchNextPage: (options?: FetchNextPageOptions) => Promise<UseInfiniteQueryResult>\nThis function allows you to fetch the next \"page\" of results. getNextPageParam.\noptions.cancelRefetch: boolean if set to true, calling fetchNextPage repeatedly will invoke fetchPage every time, whether the previous invocation has resolved or not. Also, the result from previous invocations will be ignored. If set to false, calling fetchNextPage repeatedly won't have any effect until the first invocation has resolved. Default is true.\nfetchPreviousPage: (options?: FetchPreviousPageOptions) => Promise<UseInfiniteQueryResult>\nThis function allows you to fetch the previous \"page\" of results.\noptions.cancelRefetch: boolean same as for fetchNextPage.\nhasNextPage: boolean\nThis will be true if there is a next page to be fetched (known via the getNextPageParam option).\nhasPreviousPage: boolean\nThis will be true if there is a previous page to be fetched (known via the getPreviousPageParam option).\nisRefetching: boolean\nIs true whenever a background refetch is in-flight, which does not include initial pending or fetching of next or previous page\nIs the same as isFetching && !isPending && !isFetchingNextPage && !isFetchingPreviousPage\n\nKeep in mind that imperative fetch calls, such as fetchNextPage, may interfere with the default refetch behaviour, resulting in outdated data. Make sure to call these functions only in response to user actions, or add conditions like hasNextPage && !isFetching.\n"
  },
  {
    "title": "useQueries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/reference/useQueries",
    "html": "useQueries\n\nThe useQueries hook can be used to fetch a variable number of queries:\n\ntsx\nconst ids = [1,2,3]\nconst results = useQueries({\n  queries: ids.map(id => (\n    { queryKey: ['post', id], queryFn: () => fetchPost(id), staleTime: Infinity },\n  )),\n})\n\nOptions\n\nThe useQueries hook accepts an options object with a queries key whose value is an array with query option objects identical to the useQuery hook (excluding the queryClient option - because the QueryClient can be passed in on the top level).\n\nqueryClient?: QueryClient,\nUse this to provide a custom QueryClient. Otherwise, the one from the nearest context will be used.\ncombine?: (result: UseQueriesResults) => TCombinedResult\nUse this to combine the results of the queries into a single value.\n\nHaving the same query key more than once in the array of query objects may cause some data to be shared between queries. To avoid this, consider de-duplicating the queries and map the results back to the desired structure.\n\nplaceholderData\n\nThe placeholderData option exists for useQueries as well, but it doesn't get information passed from previously rendered Queries like useQuery does, because the input to useQueries can be a different number of Queries on each render.\n\nReturns\n\nThe useQueries hook returns an array with all the query results. The order returned is the same as the input order.\n\nCombine\n\nIf you want to combine data (or other Query information) from the results into a single value, you can use the combine option. The result will be structurally shared to be as referentially stable as possible.\n\ntsx\nconst ids = [1,2,3]\nconst combinedQueries = useQueries({\n  queries: ids.map(id => (\n    { queryKey: ['post', id], queryFn: () => fetchPost(id) },\n  )),\n  combine: (results) => {\n    return ({\n      data: results.map(result => result.data),\n      pending: results.some(result => result.isPending),\n    })\n  }\n})\n\nIn the above example, combinedQueries will be an object with a data and a pending property. Note that all other properties of the Query results will be lost.\n"
  },
  {
    "title": "broadcastQueryClient (Experimental) | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/plugins/broadcastQueryClient",
    "html": "broadcastQueryClient (Experimental)\n\nVERY IMPORTANT: This utility is currently in an experimental stage. This means that breaking changes will happen in minor AND patch releases. Use at your own risk. If you choose to rely on this in production in an experimental stage, please lock your version to a patch-level version to avoid unexpected breakages.\n\nbroadcastQueryClient is a utility for broadcasting and syncing the state of your queryClient between browser tabs/windows with the same origin.\n\nInstallation\n\nThis utility comes as a separate package and is available under the '@tanstack/query-broadcast-client-experimental' import.\n\nUsage\n\nImport the broadcastQueryClient function, and pass it your QueryClient instance, and optionally, set a broadcastChannel.\n\ntsx\nimport { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'\n\n\nconst queryClient = new QueryClient()\n\n\nbroadcastQueryClient({\n  queryClient,\n  broadcastChannel: 'my-app',\n})\nAPI broadcastQueryClient\n\nPass this function a QueryClient instance and optionally, a broadcastChannel.\n\ntsx\nbroadcastQueryClient({ queryClient, broadcastChannel })\nOptions\n\nAn object of options:\n\ntsx\ninterface broadcastQueryClient {\n  /** The QueryClient to sync */\n  queryClient: QueryClient\n  /** This is the unique channel name that will be used\n   * to communicate between tabs and windows */\n  broadcastChannel?: string\n  /** Options for the BroadcastChannel API */\n  options?: BroadcastChannelOptions\n}\n\nThe default options are:\n\ntsx\n{\n  broadcastChannel = 'react-query',\n}"
  },
  {
    "title": "createAsyncStoragePersister | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/plugins/createAsyncStoragePersister",
    "html": "createAsyncStoragePersister\nInstallation\n\nThis utility comes as a separate package and is available under the '@tanstack/query-async-storage-persister' import.\n\nbash\nnpm install @tanstack/query-async-storage-persister @tanstack/react-query-persist-client\n\nor\n\nbash\npnpm add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client\n\nor\n\nbash\nyarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client\nUsage\nImport the createAsyncStoragePersister function\nCreate a new asyncStoragePersister\nyou can pass any storage to it that adheres to the AsyncStorage interface - the example below uses the async-storage from React Native\nWrap your app by using PersistQueryClientProvider component.\ntsx\nimport AsyncStorage from '@react-native-async-storage/async-storage'\nimport { QueryClient } from '@tanstack/react-query'\nimport { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'\nimport { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n\nconst asyncStoragePersister = createAsyncStoragePersister({\n  storage: AsyncStorage\n})\n\n\nconst Root = () => (\n  <PersistQueryClientProvider\n    client={queryClient}\n    persistOptions={{ persister: asyncStoragePersister }}\n  >\n    <App />\n  </PersistQueryClientProvider>\n);\n\n\nexport default Root;\nRetries\n\nRetries work the same as for a SyncStoragePersister, except that they can also be asynchronous. You can also use all the predefined retry handlers.\n\nAPI createAsyncStoragePersister\n\nCall this function to create an asyncStoragePersister that you can use later with persistQueryClient.\n\ntsx\ncreateAsyncStoragePersister(options: CreateAsyncStoragePersisterOptions)\nOptions\ntsx\ninterface CreateAsyncStoragePersisterOptions {\n  /** The storage client used for setting an retrieving items from cache */\n  storage: AsyncStorage | undefined | null\n  /** The key to use when storing the cache to localStorage */\n  key?: string\n  /** To avoid localStorage spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /** How to serialize the data to storage */\n  serialize?: (client: PersistedClient) => string\n  /** How to deserialize the data from storage */\n  deserialize?: (cachedString: string) => PersistedClient\n  /** How to retry persistence on error **/\n  retry?: AsyncPersistRetryer\n}\n\n\ninterface AsyncStorage {\n   getItem: (key: string) => Promise<string | null>\n   setItem: (key: string, value: string) => Promise<unknown>\n   removeItem: (key: string) => Promise<void>\n}\n\nThe default options are:\n\ntsx\n{\n  key = `REACT_QUERY_OFFLINE_CACHE`,\n  throttleTime = 1000,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n}"
  },
  {
    "title": "Exhaustive dependencies for query keys | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/eslint/exhaustive-deps",
    "html": "Exhaustive dependencies for query keys\n\nQuery keys should be seen like a dependency array to your query function: Every variable that is used inside the queryFn should be added to the query key. This makes sure that queries are cached independently and that queries are refetched automatically when the variables changes.\n\nRule Details\n\nExamples of incorrect code for this rule:\n\ntsx\n/* eslint \"@tanstack/query/exhaustive-deps\": \"error\" */\n\n\nuseQuery({\n    queryKey: [\"todo\"],\n    queryFn: () => api.getTodo(todoId)\n})\n\n\nconst todoQueries = {\n    detail: (id) => ({ queryKey: [\"todo\"], queryFn: () => api.getTodo(id) })\n}\n\nExamples of correct code for this rule:\n\ntsx\nuseQuery({\n    queryKey: [\"todo\", todoId],\n    queryFn: () => api.getTodo(todoId)\n})\n\n\nconst todoQueries = {\n    detail: (id) => ({ queryKey: [\"todo\", id], queryFn: () => api.getTodo(id) })\n}\nWhen Not To Use It\n\nIf you don't care about the rules of the query keys, then you will not need this rule.\n\nAttributes\n ‚úÖ Recommended\n üîß Fixable"
  },
  {
    "title": "createSyncStoragePersister | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/plugins/createSyncStoragePersister",
    "html": "createSyncStoragePersister\nInstallation\n\nThis utility comes as a separate package and is available under the '@tanstack/query-sync-storage-persister' import.\n\nbash\nnpm install @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client\n\nor\n\nbash\npnpm add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client\n\nor\n\nbash\nyarn add @tanstack/query-sync-storage-persister @tanstack/react-query-persist-client\nUsage\nImport the createSyncStoragePersister function\nCreate a new syncStoragePersister\nPass it to the persistQueryClient function\ntsx\nimport { persistQueryClient } from '@tanstack/react-query-persist-client'\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n\nconst localStoragePersister = createSyncStoragePersister({ storage: window.localStorage })\n// const sessionStoragePersister = createSyncStoragePersister({ storage: window.sessionStorage })\n\n\npersistQueryClient({\n  queryClient,\n  persister: localStoragePersister,\n})\nRetries\n\nPersistence can fail, e.g. if the size exceeds the available space on the storage. Errors can be handled gracefully by providing a retry function to the persister.\n\nThe retry function receives the persistedClient it tried to save, as well as the error and the errorCount as input. It is expected to return a new PersistedClient, with which it tries to persist again. If undefined is returned, there will be no further attempt to persist.\n\ntsx\nexport type PersistRetryer = (props: {\n  persistedClient: PersistedClient\n  error: Error\n  errorCount: number\n}) => PersistedClient | undefined\nPredefined strategies\n\nPer default, no retry will occur. You can use one of the predefined strategies to handle retries. They can be imported from '@tanstack/react-query-persist-client':\n\nremoveOldestQuery\nwill return a new PersistedClient with the oldest query removed.\ntsx\nconst localStoragePersister = createSyncStoragePersister({\n  storage: window.localStorage,\n  retry: removeOldestQuery\n})\nAPI createSyncStoragePersister\n\nCall this function to create a syncStoragePersister that you can use later with persistQueryClient.\n\ntsx\ncreateSyncStoragePersister(options: CreateSyncStoragePersisterOptions)\nOptions\ntsx\ninterface CreateSyncStoragePersisterOptions {\n  /** The storage client used for setting an retrieving items from cache (window.localStorage or window.sessionStorage) */\n  storage: Storage | undefined | null\n  /** The key to use when storing the cache */\n  key?: string\n  /** To avoid spamming,\n   * pass a time in ms to throttle saving the cache to disk */\n  throttleTime?: number\n  /** How to serialize the data to storage */\n  serialize?: (client: PersistedClient) => string\n  /** How to deserialize the data from storage */\n  deserialize?: (cachedString: string) => PersistedClient\n  /** How to retry persistence on error **/\n  retry?: PersistRetryer\n}\n\nThe default options are:\n\ntsx\n{\n  key = `REACT_QUERY_OFFLINE_CACHE`,\n  throttleTime = 1000,\n  serialize = JSON.stringify,\n  deserialize = JSON.parse,\n}\nserialize and deserialize options\n\nThere is a limit to the amount of data which can be stored in localStorage. If you need to store more data in localStorage, you can override the serialize and deserialize functions to compress and decrompress the data using a library like lz-string.\n\ntsx\nimport { QueryClient } from '@tanstack/react-query';\nimport { persistQueryClient } from '@tanstack/react-query-persist-client'\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'\n\n\nimport { compress, decompress } from 'lz-string';\n\n\nconst queryClient = new QueryClient({ defaultOptions: { queries: { staleTime: Infinity } } });\n\n\npersistQueryClient({\n  queryClient: queryClient,\n  persister: createSyncStoragePersister({\n    storage: window.localStorage,\n    serialize: data => compress(JSON.stringify(data)),\n    deserialize: data => JSON.parse(decompress(data)),\n  }),\n  maxAge: Infinity,\n});"
  },
  {
    "title": "persistQueryClient | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/plugins/persistQueryClient",
    "html": "persistQueryClient\n\nThis is set of utilities for interacting with \"persisters\" which save your queryClient for later use. Different persisters can be used to store your client and cache to many different storage layers.\n\nBuild Persisters\ncreateSyncStoragePersister\ncreateAsyncStoragePersister\ncreate a custom persister\nHow It Works\n\nIMPORTANT - for persist to work properly, you probably want to pass QueryClient a gcTime value to override the default during hydration (as shown above).\n\nIf it is not set when creating the QueryClient instance, it will default to 300000 (5 minutes) for hydration, and the stored cache will be discarded after 5 minutes of inactivity. This is the default garbage collection behavior.\n\nIt should be set as the same value or higher than persistQueryClient's maxAge option. E.g. if maxAge is 24 hours (the default) then gcTime should be 24 hours or higher. If lower than maxAge, garbage collection will kick in and discard the stored cache earlier than expected.\n\nYou can also pass it Infinity to disable garbage collection behavior entirely.\n\ntsx\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\nCache Busting\n\nSometimes you may make changes to your application or data that immediately invalidate any and all cached data. If and when this happens, you can pass a buster string option. If the cache that is found does not also have that buster string, it will be discarded. The following several functions accept this option:\n\ntsx\npersistQueryClient({ queryClient, persister, buster: buildHash })\npersistQueryClientSave({ queryClient, persister, buster: buildHash })\npersistQueryClientRestore({ queryClient, persister, buster: buildHash })\nRemoval\n\nIf data is found to be any of the following:\n\nexpired (see maxAge)\nbusted (see buster)\nerror (ex: throws ...)\nempty (ex: undefined)\n\nthe persister removeClient() is called and the cache is immediately discarded.\n\nAPI persistQueryClientSave\nYour query/mutation are dehydrated and stored by the persister you provided.\ncreateSyncStoragePersister and createAsyncStoragePersister throttle this action to happen at most every 1 second to save on potentially expensive writes. Review their documentation to see how to customize their throttle timing.\n\nYou can use this to explicitly persist the cache at the moment(s) you choose.\n\ntsx\npersistQueryClientSave({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions = undefined,\n})\npersistQueryClientSubscribe\n\nRuns persistQueryClientSave whenever the cache changes for your queryClient. For example: you might initiate the subscribe when a user logs-in and checks \"Remember me\".\n\nIt returns an unsubscribe function which you can use to discontinue the monitor; ending the updates to the persisted cache.\nIf you want to erase the persisted cache after the unsubscribe, you can send a new buster to persistQueryClientRestore which will trigger the persister's removeClient function and discard the persisted cache.\ntsx\npersistQueryClientSubscribe({\n  queryClient,\n  persister,\n  buster = '',\n  dehydrateOptions = undefined,\n})\npersistQueryClientRestore\nAttempts to hydrate a previously persisted dehydrated query/mutation cache from the persister back into the query cache of the passed query client.\nIf a cache is found that is older than the maxAge (which by default is 24 hours), it will be discarded. This timing can be customized as you see fit.\n\nYou can use this to restore the cache at moment(s) you choose.\n\ntsx\npersistQueryClientRestore({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24, // 24 hours\n  buster = '',\n  hydrateOptions = undefined,\n})\npersistQueryClient\n\nTakes the following actions:\n\nImmediately restores any persisted cache (see persistQueryClientRestore)\nSubscribes to the query cache and returns the unsubscribe function (see persistQueryClientSubscribe).\n\nThis functionality is preserved from version 3.x.\n\ntsx\npersistQueryClient({\n  queryClient,\n  persister,\n  maxAge = 1000 * 60 * 60 * 24, // 24 hours\n  buster = '',\n  hydrateOptions = undefined,\n  dehydrateOptions = undefined,\n})\nOptions\n\nAll options available are as follows:\n\ntsx\ninterface PersistQueryClientOptions {\n  /** The QueryClient to persist */\n  queryClient: QueryClient\n  /** The Persister interface for storing and restoring the cache\n   * to/from a persisted location */\n  persister: Persister\n  /** The max-allowed age of the cache in milliseconds.\n   * If a persisted cache is found that is older than this\n   * time, it will be **silently** discarded\n   * (defaults to 24 hours) */\n  maxAge?: number\n  /** A unique string that can be used to forcefully\n   * invalidate existing caches if they do not share the same buster string */\n  buster?: string\n  /** The options passed to the hydrate function\n   * Not used on `persistQueryClientSave` or `persistQueryClientSubscribe` */\n  hydrateOptions?: HydrateOptions\n  /** The options passed to the dehydrate function\n  * Not used on `persistQueryClientRestore` */\n  dehydrateOptions?: DehydrateOptions\n}\n\nThere are actually three interfaces available:\n\nPersistedQueryClientSaveOptions is used for persistQueryClientSave and persistQueryClientSubscribe (doesn't use hydrateOptions).\nPersistedQueryClientRestoreOptions is used for persistQueryClientRestore (doesn't use dehydrateOptions).\nPersistQueryClientOptions is used for persistQueryClient\nUsage with React\n\npersistQueryClient will try to restore the cache and automatically subscribes to further changes, thus syncing your client to the provided storage.\n\nHowever, restoring is asynchronous, because all persisters are async by nature, which means that if you render your App while you are restoring, you might get into race conditions if a query mounts and fetches at the same time.\n\nFurther, if you subscribe to changes outside of the React component lifecycle, you have no way of unsubscribing:\n\ntsx\n// üö® never unsubscribes from syncing\npersistQueryClient({\n  queryClient,\n  persister: localStoragePersister,\n})\n\n\n// üö® happens at the same time as restoring\nReactDOM.createRoot(rootElement).render(<App />)\nPersistQueryClientProvider\n\nFor this use-case, you can use the PersistQueryClientProvider. It will make sure to subscribe / unsubscribe correctly according to the React component lifecycle, and it will also make sure that queries will not start fetching while we are still restoring. Queries will still render though, they will just be put into fetchingState: 'idle' until data has been restored. Then, they will refetch unless the restored data is fresh enough, and initialData will also be respected. It can be used instead of the normal QueryClientProvider:\n\ntsx\nimport { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'\nimport { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\n\n\nReactDOM.createRoot(rootElement).render(\n  <PersistQueryClientProvider\n    client={queryClient}\n    persistOptions={{ persister }}\n  >\n    <App />\n  </PersistQueryClientProvider>\n)\nProps\n\nPersistQueryClientProvider takes the same props as QueryClientProvider, and additionally:\n\npersistOptions: PersistQueryClientOptions\nall options you can pass to persistQueryClient minus the QueryClient itself\nonSuccess?: () => Promise<unknown> | unknown\noptional\nwill be called when the initial restore is finished\ncan be used to resumePausedMutations\nif a Promise is returned, it will be awaited; restoring is seen as ongoing until then\nuseIsRestoring\n\nIf you are using the PersistQueryClientProvider, you can also use the useIsRestoring hook alongside it to check if a restore is currently in progress. useQuery and friends also check this internally to avoid race conditions between the restore and mounting queries.\n\nPersisters Persisters Interface\n\nPersisters have the following interfaces:\n\ntsx\nexport interface Persister {\n  persistClient(persistClient: PersistedClient): Promisable<void>\n  restoreClient(): Promisable<PersistedClient | undefined>\n  removeClient(): Promisable<void>\n}\n\nPersisted Client entries have the following interface:\n\ntsx\nexport interface PersistedClient {\n  timestamp: number\n  buster: string\n  cacheState: any\n}\n\nYou can import these (to build a persister):\n\ntsx\nimport { PersistedClient, Persister } from \"@tanstack/react-query-persist-client\";\nBuilding A Persister\n\nYou can persist however you like. Here is an example of how to build an Indexed DB persister. Compared to Web Storage API, Indexed DB is faster, stores more than 5MB, and doesn't require serialization. That means it can readily store Javascript native types, such as Date and File.\n\ntsx\nimport { get, set, del } from \"idb-keyval\";\nimport { PersistedClient, Persister } from \"@tanstack/react-query-persist-client\";\n\n\n/**\n * Creates an Indexed DB persister\n * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\n */\nexport function createIDBPersister(idbValidKey: IDBValidKey = \"reactQuery\") {\n  return {\n    persistClient: async (client: PersistedClient) => {\n      await set(idbValidKey, client);\n    },\n    restoreClient: async () => {\n      return await get<PersistedClient>(idbValidKey);\n    },\n    removeClient: async () => {\n      await del(idbValidKey);\n    },\n  } as Persister;\n}"
  },
  {
    "title": "Disallow object rest destructuring on query results | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/eslint/no-rest-destructuring",
    "html": "Disallow object rest destructuring on query results\n\nUse object rest destructuring on query results automatically subscribes to every field of the query result, which may cause unnecessary re-renders. This makes sure that you only subscribe to the fields that you actually need.\n\nRule Details\n\nExamples of incorrect code for this rule:\n\ntsx\n/* eslint \"@tanstack/query/no-rest-destructuring\": \"warn\" */\n\n\nconst useTodos = () => {\n  const { data: todos, ...rest } = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => api.getTodos(),\n  })\n  return { todos, ...rest }\n}\n\nExamples of correct code for this rule:\n\ntsx\nconst todosQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => api.getTodos(),\n})\n\n\n// normal object destructuring is fine\nconst { data: todos } = todosQuery\nWhen Not To Use It\n\nIf you set the notifyOnChangeProps options manually, you can disable this rule. Since you are not using tracked queries, you are responsible for specifying which props should trigger a re-render.\n\nAttributes\n ‚úÖ Recommended\n üîß Fixable"
  },
  {
    "title": "Stable Query Client | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/eslint/stable-query-client",
    "html": "Stable Query Client\n\nThe QueryClient contains the QueryCache, so you'd only want to create one instance of the QueryClient for the lifecycle of your application - not a new instance on every render.\n\nException: It's allowed to create a new QueryClient inside an async Server Component, because the async function is only called once on the server.\n\nRule Details\n\nExamples of incorrect code for this rule:\n\ntsx\n/* eslint \"@tanstack/query/stable-query-client\": \"error\" */\n\n\nfunction App() {\n  const queryClient = new QueryClient()\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Home />\n    </QueryClientProvider>\n  )\n}\n\nExamples of correct code for this rule:\n\ntsx\nfunction App() {\n  const [queryClient] = useState(() => new QueryClient())\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Home />\n    </QueryClientProvider>\n  )\n}\ntsx\nconst queryClient = new QueryClient()\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Home />\n    </QueryClientProvider>\n  )\n}\nbash\nasync function App() {\n  const queryClient = new QueryClient()\n  await queryClient.prefetchQuery(options)\n}\nAttributes\n ‚úÖ Recommended\n üîß Fixable"
  },
  {
    "title": "ESLint Plugin Query | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/eslint/eslint-plugin-query",
    "html": "ESLint Plugin Query\n\nTanStack Query comes with its own ESLint plugin. This plugin is used to enforce best practices and to help you avoid common mistakes.\n\nInstallation\n\nThe plugin is a separate package that you need to install:\n\nbash\n$ npm i -D @tanstack/eslint-plugin-query\n# or\n$ pnpm add -D @tanstack/eslint-plugin-query\n# or\n$ yarn add -D @tanstack/eslint-plugin-query\nUsage\n\nTo enable all of the recommended rules for our plugin, add plugin:@tanstack/eslint-plugin-query/recommended in extends:\n\nbash\n{\n  \"extends\": [\"plugin:@tanstack/eslint-plugin-query/recommended\"]\n}\nAlternative config\n\nAlternatively, add @tanstack/eslint-plugin-query to the plugins section of your .eslintrc configuration file:\n\nbash\n{\n  \"plugins\": [\"@tanstack/query\"]\n}\n\nThen configure the rules you want to use under the rules section:\n\nbash\n{\n  \"rules\": {\n    \"@tanstack/query/exhaustive-deps\": \"error\",\n    \"@tanstack/query/no-rest-destructuring\": \"warn\",\n    \"@tanstack/query/stable-query-client\": \"error\"\n  }\n}"
  },
  {
    "title": "Community Projects | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/community/community-projects",
    "html": "Community Projects\n\nThere are lots of community projects that build on top of React Query and use it to provide additional functionality or enhanced developer experience. Projects are listed in alphabetical order. If you have a project that you would like to add to this list, please open a PR!\n\nPlease note that these projects are entirely community maintained. If you have questions about these projects, please reach out to the project maintainers.\n\nbatshit\n\nA batch manager that will deduplicate and batch requests for a certain data type made within a window\n\nLink: https://github.com/yornaath/batshit\n\nBlitz\n\nThe Missing Fullstack Toolkit for Next.js\n\nLink: https://blitzjs.com/\n\nGraphQL Code Generator\n\nGenerate React Query hooks from your GraphQL schema\n\nLink: https://the-guild.dev/graphql/codegen\n\nHttp-wizard\n\nEnd-to-end type-safe Fastify API with typecript magic ‚ú®\n\nLink: https://http-wizard.com\n\nKubb\n\nGenerate SDKs for all your APIs\n\nLink: https://www.kubb.dev/\n\nNgQuery\n\nQuery adapter for Angular\n\nLink: https://ngneat.github.io/query/\n\nNormy\n\nAutomatic normalization and data updates for data fetching libraries\n\nLink: https://github.com/klis87/normy\n\nOpenAPI codegen\n\nA tool for generating code based on an OpenAPI schema.\n\nLink: https://github.com/fabien0102/openapi-codegen\n\nOpenAPI React Query codegen\n\nGenerate TanStack Query hooks based on an OpenAPI specification file.\n\nLink: https://github.com/7nohe/openapi-react-query-codegen\n\nOpenAPI zod client\n\nGenerate a zodios client from an OpenAPI specification\n\nLink: https://github.com/astahmer/openapi-zod-client\n\nOrval\n\nGenerate TypeScript client from OpenAPI specifications\n\nLink: https://orval.dev/\n\nQuery Key factory\n\nA library for creating typesafe standardized query keys, useful for cache management in @tanstack/query\n\nLink: https://github.com/lukemorales/query-key-factory\n\nReact Query Kit\n\nüïäÔ∏è A toolkit for ReactQuery that makes ReactQuery hooks reusable and typesafe\n\nLink: https://github.com/liaoliao666/react-query-kit\n\nReact Query Swagger\n\nGenerate React Query hooks based on Swagger API definitions\n\nLink: https://github.com/Shaddix/react-query-swagger\n\ntRPC\n\nEnd-to-end typesafe APIs made easy\n\nLink: https://trpc.io/\n\nts-rest\n\nIncrementally adoptable type-safety for your new and existing APIs\n\nLink: https://ts-rest.com/\n\nwagmi\n\nReact Hooks for Ethereum based on @tanstack/react-query\n\nLink: https://wagmi.sh/\n\nzodios\n\nEnd-to-end typesafe REST API toolbox\n\nLink: https://www.zodios.org/\n"
  },
  {
    "title": "TkDodo's Blog | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/community/tkdodos-blog",
    "html": "TkDodo's Blog\n\nTanStack Query maintainer TkDodo has a series of blog posts about using and working with the library. Some articles show general best practices, but most have an opinionated point of view.\n\n#1: Practical React Query\n\nAn advanced introduction to React Query, showing practical tips that go beyond the docs. It covers explaining the defaults (staleTime vs. gcTime), concepts like keeping server and client state separate, handling dependencies and creating custom hooks, as well as outlining why the enabled option is very powerful. Read more...\n\n#2: React Query Data Transformations\n\nLearn the possibilities to perform the quite common and important task of transforming your data with React Query. From transforming in the queryFn to using the select option, this article outlines the pros and cons of all the different approaches. Read more...\n\n#3: React Query Render Optimizations\n\nLet's take a look at what you can do when your component re-renders too often when using React Query. The library is already pretty optimized, but there are still some opt-in features (like tracked queries) that you can use to avoid the isFetching transition. We're also looking into what structural sharing refers to. Read more...\n\n#4: Status Checks in React Query\n\nWe usually check for isPending first before checking for isError , but sometimes, checking if data is available should be the first thing to do. This article shows how the wrong status check order can negatively impact user experience. Read more...\n\n#5: Testing React Query\n\nThe docs already cover pretty well what you need to do to get started when testing React Query. This article shows some additional tips (like turning off retries or silencing the console) you might want to follow when testing custom hooks or components using them. It also links to an example repository with tests for success and error states, powered by mock-service-worker. Read more...\n\n#6: React Query and TypeScript\n\nSince React Query is written in TypeScript, it has great support for it. This blog post explains the various Generics, how you can leverage type inference to avoid having to explicitly type useQuery and friends, what to do with unknown errors, how type narrowing works and more! Read more...\n\n#7: Using WebSockets with React Query\n\nA step-by-step guide on how to make real-time notifications work with React Query, with either event-based subscriptions or pushing full data directly to the client. Applicable to anything from the browser native WebSocket API over Firebase and even GraphQL subscriptions. Read more...\n\n#8: Effective React Query Keys\n\nMost examples just use a simple String or Array Query Key, but how do you organize your keys effectively once your app grows past a todo list? This article shows how co-location and Query Key Factories can make life easier. Read more...\n\n#8a: Leveraging the Query Function Context\n\nIn this amendment to the previous blog post, we look at how we can leverage the Query Function Context and Object Query Keys for maximum safety as our app grows. Read more...\n\n#9: Placeholder and Initial Data in React Query\n\nPlaceholder and Initial Data are two similar yet different concepts for synchronously showing data instead of a loading spinner to improve an application's UX. This blog post compares the two and outlines the scenarios where each one shines. Read more...\n\n#10: React Query as a State Manager\n\nReact Query doesn't fetch any data for you - it's a data synchronization tool that excels when used for server state. This article has everything you need to know to make React Query your single source of truth state manager for your async state. You'll learn how to let React Query do it's magic and why customizing staleTime might be all you need. Read more...\n\n#11: React Query Error Handling\n\nHandling errors is an integral part of working with asynchronous data, especially data fetching. We have to face it: Not all requests will be successful, and not all Promises will be fulfilled. This blog post describes various ways of coping with errors in React Query, such as the error property, using Error Boundaries or onError callbacks, so that you can prepare your application for the cases when \"Something went wrong\". Read more...\n\n#12: Mastering Mutations in React Query\n\nMutations are the important, second part necessary to work with server data - for situations where you need to update it. This blog post covers what mutations are and how they are different from queries. You'll learn the difference between mutate and mutateAsync as well as how you can tie queries and mutations together. Read more...\n\n#13: Offline React Query\n\nThere are many ways to produce promises - which is everything React Query needs - but by far the biggest use-case is data fetching. Very often, that requires an active network connection. But sometimes, especially on mobile devices where, the network connection can be unreliable, you need your app to also work without it. In this article, you'll learn about the different offline strategies React Query offers. Read more...\n\n#14: React Query and Forms\n\nForms tend to blur the line between what is server state and what is client state. In most applications, we would not only like to display state, but also let the user interact with it. This article shows two different approaches as well as some tips and tricks about using React Query with Forms. Read more...\n\n#15: React Query FAQs\n\nThis article tries to answer the most frequently asked questions about React Query. Read more...\n\n#16: React Query meets React Router\n\nRemix and React Router are changing the game when thinking about when to fetch data. This article goes into why React Query and Routers that support data loading are a match made in heaven. Read more...\n\n#17: Seeding the Query Cache\n\nThis blog post shows multiple ways how to get data into your Query Cache before you start rendering to minimize the amount of loading spinners displayed in your app. The options range from prefetching on the server or in your router to seeding cache entries via setQueryData. Read more...\n\n#18: Inside React Query\n\nIf you've ever wondered how React Query works under the hood - this post is for you. It explains the architecture (including visuals), starting with the agnostic Query Core and how it communicates with the framework specific adapters. Read more...\n\n#19: Type-safe React Query\n\nThere's a big difference between \"having types\" and \"being type-safe\". This article tries to outline those differences and shows how you can get the best possible type-safety when using React Query together with TypeScript Read more...\n"
  },
  {
    "title": "Migrating to React Query 4 | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/migrating-to-react-query-4",
    "html": "Migrating to React Query 4\nBreaking Changes\n\nv4 is a major version, so there are some breaking changes to be aware of:\n\nreact-query is now @tanstack/react-query\n\nYou will need to un-/install dependencies and change the imports:\n\nbash\nnpm uninstall react-query\nnpm install @tanstack/react-query\nnpm install @tanstack/react-query-devtools\ndiff\n- import { useQuery } from 'react-query'\n- import { ReactQueryDevtools } from 'react-query/devtools'\n+ import { useQuery } from '@tanstack/react-query'\n+ import { ReactQueryDevtools } from '@tanstack/react-query-devtools'\nCodemod\n\nTo make the import migration easier, v4 comes with a codemod.\n\nThe codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.\n\nYou can easily apply it by using one (or both) of the following commands:\n\nIf you want to run it against .js or .jsx files, please use the command below:\n\nbash\nnpx jscodeshift ./path/to/src/ \\\n  --extensions=js,jsx \\\n  --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js\n\nIf you want to run it against .ts or .tsx files, please use the command below:\n\nbash\nnpx jscodeshift ./path/to/src/ \\\n  --extensions=ts,tsx \\\n  --parser=tsx \\\n  --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js\n\nPlease note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!\n\nNote: Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!\n\nNote: The codemod will only change the imports - you still have to install the separate devtools package manually.\n\nQuery Keys (and Mutation Keys) need to be an Array\n\nIn v3, Query and Mutation Keys could be a String or an Array. Internally, React Query has always worked with Array Keys only, and we've sometimes exposed this to consumers. For example, in the queryFn, you would always get the key as an Array to make working with Default Query Functions easier.\n\nHowever, we have not followed this concept through to all apis. For example, when using the predicate function on Query Filters you would get the raw Query Key. This makes it difficult to work with such functions if you use Query Keys that are mixed Arrays and Strings. The same was true when using global callbacks.\n\nTo streamline all apis, we've decided to make all keys Arrays only:\n\ndiff\n- useQuery('todos', fetchTodos)\n+ useQuery(['todos'], fetchTodos)\nCodemod\n\nTo make this migration easier, we decided to deliver a codemod.\n\nThe codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.\n\nYou can easily apply it by using one (or both) of the following commands:\n\nIf you want to run it against .js or .jsx files, please use the command below:\n\nbash\nnpx jscodeshift ./path/to/src/ \\\n  --extensions=js,jsx \\\n  --transform=./node_modules/@tanstack/react-query/codemods/v4/key-transformation.js\n\nIf you want to run it against .ts or .tsx files, please use the command below:\n\nbash\nnpx jscodeshift ./path/to/src/ \\\n  --extensions=ts,tsx \\\n  --parser=tsx \\\n  --transform=./node_modules/@tanstack/react-query/codemods/v4/key-transformation.js\n\nPlease note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!\n\nNote: Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!\n\nThe idle state has been removed\n\nWith the introduction of the new fetchStatus for better offline support, the idle state became irrelevant, because fetchStatus: 'idle' captures the same state better. For more information, please read Why two different states.\n\nThis will mostly affect disabled queries that don't have any data yet, as those were in idle state before:\n\ndiff\n- status: 'idle'\n+ status: 'loading'\n+ fetchStatus: 'idle'\n\nAlso, have a look at the guide on dependent queries\n\ndisabled queries\n\nDue to this change, disabled queries (even temporarily disabled ones) will start in loading state. To make migration easier, especially for having a good flag to know when to display a loading spinner, you can check for isInitialLoading instead of isLoading:\n\ndiff\n- isLoading\n+ isInitialLoading\n\nSee also the guide on disabling queries\n\nnew API for useQueries\n\nThe useQueries hook now accepts an object with a queries prop as its input. The value of the queries prop is an array of queries (this array is identical to what was passed into useQueries in v3).\n\ndiff\n- useQueries([{ queryKey1, queryFn1, options1 }, { queryKey2, queryFn2, options2 }])\n+ useQueries({ queries: [{ queryKey1, queryFn1, options1 }, { queryKey2, queryFn2, options2 }] })\nUndefined is an illegal cache value for successful queries\n\nIn order to make bailing out of updates possible by returning undefined, we had to make undefined an illegal cache value. This is in-line with other concepts of react-query, for example, returning undefined from the initialData function will also not set data.\n\nFurther, it is an easy bug to produce Promise<void> by adding logging in the queryFn:\n\ntsx\nuseQuery(['key'], () => axios.get(url).then(result => console.log(result.data)))\n\nThis is now disallowed on type level; at runtime, undefined will be transformed to a failed Promise, which means you will get an error, which will also be logged to the console in development mode.\n\nQueries and mutations, per default, need network connection to run\n\nPlease read the New Features announcement about online / offline support, and also the dedicated page about Network mode\n\nEven though React Query is an Async State Manager that can be used for anything that produces a Promise, it is most often used for data fetching in combination with data fetching libraries. That is why, per default, queries and mutations will be paused if there is no network connection. If you want to opt-in to the previous behavior, you can globally set networkMode: offlineFirst for both queries and mutations:\n\ntsx\nnew QueryClient({\n  defaultOptions: {\n    queries: {\n      networkMode: 'offlineFirst',\n    },\n    mutations: {\n      networkMode: 'offlineFirst',\n    },\n  },\n})\nnotifyOnChangeProps property no longer accepts \"tracked\" as a value\n\nThe notifyOnChangeProps option no longer accepts a \"tracked\" value. Instead, useQuery defaults to tracking properties. All queries using notifyOnChangeProps: \"tracked\" should be updated by removing this option.\n\nIf you would like to bypass this in any queries to emulate the v3 default behavior of re-rendering whenever a query changes, notifyOnChangeProps now accepts an \"all\" value to opt-out of the default smart tracking optimization.\n\nnotifyOnChangePropsExclusion has been removed\n\nIn v4, notifyOnChangeProps defaults to the \"tracked\" behavior of v3 instead of undefined. Now that \"tracked\" is the default behavior for v4, it no longer makes sense to include this config option.\n\nConsistent behavior for cancelRefetch\n\nThe cancelRefetch option can be passed to all functions that imperatively fetch a query, namely:\n\nqueryClient.refetchQueries\nqueryClient.invalidateQueries\nqueryClient.resetQueries\nrefetch returned from useQuery\nfetchNextPage and fetchPreviousPage returned from useInfiniteQuery\n\nExcept for fetchNextPage and fetchPreviousPage, this flag was defaulting to false, which was inconsistent and potentially troublesome: Calling refetchQueries or invalidateQueries after a mutation might not yield the latest result if a previous slow fetch was already ongoing, because this refetch would have been skipped.\n\nWe believe that if a query is actively refetched by some code you write, it should, per default, re-start the fetch.\n\nThat is why this flag now defaults to true for all methods mentioned above. It also means that if you call refetchQueries twice in a row, without awaiting it, it will now cancel the first fetch and re-start it with the second one:\n\nbash\nqueryClient.refetchQueries({ queryKey: ['todos'] })\n// this will abort the previous refetch and start a new fetch\nqueryClient.refetchQueries({ queryKey: ['todos'] })\n\nYou can opt-out of this behaviour by explicitly passing cancelRefetch:false:\n\nbash\nqueryClient.refetchQueries({ queryKey: ['todos'] })\n// this will not abort the previous refetch - it will just be ignored\nqueryClient.refetchQueries({ queryKey: ['todos'] }, { cancelRefetch: false })\n\nNote: There is no change in behaviour for automatically triggered fetches, e.g. because a query mounts or because of a window focus refetch.\n\nQuery Filters\n\nA query filter is an object with certain conditions to match a query. Historically, the filter options have mostly been a combination of boolean flags. However, combining those flags can lead to impossible states. Specifically:\n\nbash\nactive?: boolean\n  - When set to true it will match active queries.\n  - When set to false it will match inactive queries.\ninactive?: boolean\n  - When set to true it will match inactive queries.\n  - When set to false it will match active queries.\n\nThose flags don't work well when used together, because they are mutually exclusive. Setting false for both flags could match all queries, judging from the description, or no queries, which doesn't make much sense.\n\nWith v4, those filters have been combined into a single filter to better show the intent:\n\ndiff\n- active?: boolean\n- inactive?: boolean\n+ type?: 'active' | 'inactive' | 'all'\n\nThe filter defaults to all, and you can choose to only match active or inactive queries.\n\nrefetchActive / refetchInactive\n\nqueryClient.invalidateQueries had two additional, similar flags:\n\nbash\nrefetchActive: Boolean\n  - Defaults to true\n  - When set to false, queries that match the refetch predicate and are actively being rendered\n    via useQuery and friends will NOT be refetched in the background, and only marked as invalid.\nrefetchInactive: Boolean\n  - Defaults to false\n  - When set to true, queries that match the refetch predicate and are not being rendered\n    via useQuery and friends will be both marked as invalid and also refetched in the background\n\nFor the same reason, those have also been combined:\n\ndiff\n- refetchActive?: boolean\n- refetchInactive?: boolean\n+ refetchType?: 'active' | 'inactive' | 'all' | 'none'\n\nThis flag defaults to active because refetchActive defaulted to true. This means we also need a way to tell invalidateQueries to not refetch at all, which is why a fourth option (none) is also allowed here.\n\nonSuccess is no longer called from setQueryData\n\nThis was confusing to many and also created infinite loops if setQueryData was called from within onSuccess. It was also a frequent source of error when combined with staleTime, because if data was read from the cache only, onSuccess was not called.\n\nSimilar to onError and onSettled, the onSuccess callback is now tied to a request being made. No request -> no callback.\n\nIf you want to listen to changes of the data field, you can best do this with a useEffect, where data is part of the dependency Array. Since React Query ensures stable data through structural sharing, the effect will not execute with every background refetch, but only if something within data has changed:\n\nbash\nconst { data } = useQuery({ queryKey, queryFn })\nReact.useEffect(() => mySideEffectHere(data), [data])\npersistQueryClient and the corresponding persister plugins are no longer experimental and have been renamed\n\nThe plugins createWebStoragePersistor and createAsyncStoragePersistor have been renamed to createSyncStoragePersister and createAsyncStoragePersister respectively. The interface Persistor in persistQueryClient has also been renamed to Persister. Checkout this stackexchange for the motivation of this change.\n\nSince these plugins are no longer experimental, their import paths have also been updated:\n\ndiff\n- import { persistQueryClient } from 'react-query/persistQueryClient-experimental'\n- import { createWebStoragePersistor } from 'react-query/createWebStoragePersistor-experimental'\n- import { createAsyncStoragePersistor } from 'react-query/createAsyncStoragePersistor-experimental'\n+ import { persistQueryClient } from '@tanstack/react-query-persist-client'\n+ import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'\n+ import { createAsyncStoragePersister } from '@tanstack/query-async-storage-persister'\nThe cancel method on promises is no longer supported\n\nThe old cancel method that allowed you to define a cancel function on promises, which was then used by the library to support query cancellation, has been removed. We recommend to use the newer API (introduced with v3.30.0) for query cancellation that uses the AbortController API internally and provides you with an AbortSignal instance for your query function to support query cancellation.\n\nTypeScript\n\nTypes now require using TypeScript v4.1 or greater\n\nSupported Browsers\n\nAs of v4, React Query is optimized for modern browsers. We have updated our browserslist to produce a more modern, performant and smaller bundle. You can read about the requirements here.\n\nsetLogger is removed\n\nIt was possible to change the logger globally by calling setLogger. In v4, that function is replaced with an optional field when creating a QueryClient.\n\ndiff\n- import { QueryClient, setLogger } from 'react-query';\n+ import { QueryClient } from '@tanstack/react-query';\n- setLogger(customLogger)\n- const queryClient = new QueryClient();\n+ const queryClient = new QueryClient({ logger: customLogger })\nNo default manual Garbage Collection server-side\n\nIn v3, React Query would cache query results for a default of 5 minutes, then manually garbage collect that data. This default was applied to server-side React Query as well.\n\nThis lead to high memory consumption and hanging processes waiting for this manual garbage collection to complete. In v4, by default the server-side cacheTime is now set to Infinity effectively disabling manual garbage collection (the NodeJS process will clear everything once a request is complete).\n\nThis change only impacts users of server-side React Query, such as with Next.js. If you are setting a cacheTime manually this will not impact you (although you may want to mirror behavior).\n\nLogging in production\n\nStarting with v4, react-query will no longer log errors (e.g. failed fetches) to the console in production mode, as this was confusing to many. Errors will still show up in development mode.\n\nESM Support\n\nReact Query now supports package.json \"exports\" and is fully compatible with Node's native resolution for both CommonJS and ESM. We don't expect this to be a breaking change for most users, but this restricts the files you can import into your project to only the entry points we officially support.\n\nStreamlined NotifyEvents\n\nSubscribing manually to the QueryCache has always given you a QueryCacheNotifyEvent, but this was not true for the MutationCache. We have streamlined the behavior and also adapted event names accordingly.\n\nQueryCacheNotifyEvent\ndiff\n- type: 'queryAdded'\n+ type: 'added'\n- type: 'queryRemoved'\n+ type: 'removed'\n- type: 'queryUpdated'\n+ type: 'updated'\nMutationCacheNotifyEvent\n\nThe MutationCacheNotifyEvent uses the same types as the QueryCacheNotifyEvent.\n\nNote: This is only relevant if you manually subscribe to the caches via queryCache.subscribe or mutationCache.subscribe\n\nSeparate hydration exports have been removed\n\nWith version 3.22.0, hydration utilities moved into the React Query core. With v3, you could still use the old exports from react-query/hydration, but these exports have been removed with v4.\n\ndiff\n- import { dehydrate, hydrate, useHydrate, Hydrate } from 'react-query/hydration'\n+ import { dehydrate, hydrate, useHydrate, Hydrate } from '@tanstack/react-query'\nRemoved undocumented methods from the queryClient, query and mutation\n\nThe methods cancelMutatations and executeMutation on the QueryClient were undocumented and unused internally, so we removed them. Since it was just a wrapper around a method available on the mutationCache, you can still use the functionality of executeMutation\n\ndiff\n- executeMutation<\n-   TData = unknown,\n-   TError = unknown,\n-   TVariables = void,\n-   TContext = unknown\n- >(\n-   options: MutationOptions<TData, TError, TVariables, TContext>\n- ): Promise<TData> {\n-   return this.mutationCache.build(this, options).execute()\n- }\n\nAdditionally, query.setDefaultOptions was removed because it was also unused. mutation.cancel was removed because it didn't actually cancel the outgoing request.\n\nThe src/react directory was renamed to src/reactjs\n\nPreviously, React Query had a directory named react which imported from the react module. This could cause problems with some Jest configurations, resulting in errors when running tests like:\n\nbash\nTypeError: Cannot read property 'createContext' of undefined\n\nWith the renamed directory this no longer is an issue.\n\nIf you were importing anything from 'react-query/react' directly in your project (as opposed to just 'react-query'), then you need to update your imports:\n\ndiff\n- import { QueryClientProvider } from 'react-query/react';\n+ import { QueryClientProvider } from '@tanstack/react-query/reactjs';\nNew Features üöÄ\n\nv4 comes with an awesome set of new features:\n\nSupport for React 18\n\nReact 18 was released earlier this year, and v4 now has first class support for it and the new concurrent features it brings.\n\nProper offline support\n\nIn v3, React Query has always fired off queries and mutations, but then taken the assumption that if you want to retry it, you need to be connected to the internet. This has led to several confusing situations:\n\nYou are offline and mount a query - it goes to loading state, the request fails, and it stays in loading state until you go online again, even though it is not really fetching.\nSimilarly, if you are offline and have retries turned off, your query will just fire and fail, and the query goes to error state.\nYou are offline and want to fire off a query that doesn't necessarily need network connection (because you can use React Query for something other than data fetching), but it fails for some other reason. That query will now be paused until you go online again.\nWindow focus refetching didn't do anything at all if you were offline.\n\nWith v4, React Query introduces a new networkMode to tackle all these issues. Please read the dedicated page about the new Network mode for more information.\n\nTracked Queries per default\n\nReact Query defaults to \"tracking\" query properties, which should give you a nice boost in render optimization. The feature has existed since v3.6.0 and has now become the default behavior with v4.\n\nBailing out of updates with setQueryData\n\nWhen using the functional updater form of setQueryData, you can now bail out of the update by returning undefined. This is helpful if undefined is given to you as previousValue, which means that currently, no cached entry exists and you don't want to / cannot create one, like in the example of toggling a todo:\n\ntsx\nqueryClient.setQueryData(['todo', id], previousTodo =>\n  previousTodo ? { ...previousTodo, done: true } : undefined\n)\nMutation Cache Garbage Collection\n\nMutations can now also be garbage collected automatically, just like queries. The default cacheTime for mutations is also set to 5 minutes.\n\nCustom Contexts for Multiple Providers\n\nCustom contexts can now be specified to pair hooks with their matching Provider. This is critical when there may be multiple React Query Provider instances in the component tree, and you need to ensure your hook uses the correct Provider instance.\n\nAn example:\n\nCreate a data package.\ntsx\n// Our first data package: @my-scope/container-data\n\n\nconst context = React.createContext<QueryClient | undefined>(undefined)\nconst queryClient = new QueryClient()\n\n\nexport const useUser = () => {\n  return useQuery(USER_KEY, USER_FETCHER, {\n    context,\n  })\n}\n\n\nexport const ContainerDataProvider = ({\n  children,\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <QueryClientProvider client={queryClient} context={context}>\n      {children}\n    </QueryClientProvider>\n  )\n}\nCreate a second data package.\ntsx\n// Our second data package: @my-scope/my-component-data\n\n\nconst context = React.createContext<QueryClient | undefined>(undefined)\nconst queryClient = new QueryClient()\n\n\nexport const useItems = () => {\n  return useQuery(ITEMS_KEY, ITEMS_FETCHER, {\n    context,\n  })\n}\n\n\nexport const MyComponentDataProvider = ({\n  children,\n}: {\n  children: React.ReactNode\n}) => {\n  return (\n    <QueryClientProvider client={queryClient} context={context}>\n      {children}\n    </QueryClientProvider>\n  )\n}\nUse these two data packages in your application.\ntsx\n// Our application\n\n\nimport { ContainerDataProvider, useUser } from \"@my-scope/container-data\";\nimport { AppDataProvider } from \"@my-scope/app-data\";\nimport { MyComponentDataProvider, useItems } from \"@my-scope/my-component-data\";\n\n\n<ContainerDataProvider> // <-- Provides container data (like \"user\") using its own React Query provider\n  ...\n  <AppDataProvider> // <-- Provides app data using its own React Query provider (unused in this example)\n    ...\n      <MyComponentDataProvider> // <-- Provides component data (like \"items\") using its own React Query provider\n        <MyComponent />\n      </MyComponentDataProvider>\n    ...\n  </AppDataProvider>\n  ...\n</ContainerDataProvider>\n\n\n// Example of hooks provided by the \"DataProvider\" components above:\nconst MyComponent = () => {\n  const user = useUser() // <-- Uses the context specified in ContainerDataProvider.\n  const items = useItems() // <-- Uses the context specified in MyComponentDataProvider\n  ...\n}"
  },
  {
    "title": "Migrating to TanStack Query v5 | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5",
    "html": "Migrating to TanStack Query v5\nBreaking Changes\n\nv5 is a major version, so there are some breaking changes to be aware of:\n\nSupports a single signature, one object\n\nuseQuery and friends used to have many overloads in TypeScript - different ways how the function can be invoked. Not only this was tough to maintain, type wise, it also required a runtime check to see which type the first and the second parameter, to correctly create options.\n\nnow we only support the object format.\n\ndiff\n- useQuery(key, fn, options)\n+ useQuery({ queryKey, queryFn, ...options })\n- useInfiniteQuery(key, fn, options)\n+ useInfiniteQuery({ queryKey, queryFn, ...options })\n- useMutation(fn, options)\n+ useMutation({ mutationFn, ...options })\n- useIsFetching(key, filters)\n+ useIsFetching({ queryKey, ...filters })\n- useIsMutating(key, filters)\n+ useIsMutating({ mutationKey, ...filters })\ndiff\n- queryClient.isFetching(key, filters)\n+ queryClient.isFetching({ queryKey, ...filters })\n- queryClient.ensureQueryData(key, filters)\n+ queryClient.ensureQueryData({ queryKey, ...filters })\n- queryClient.getQueriesData(key, filters)\n+ queryClient.getQueriesData({ queryKey, ...filters })\n- queryClient.setQueriesData(key, updater, filters, options)\n+ queryClient.setQueriesData({ queryKey, ...filters }, updater, options)\n- queryClient.removeQueries(key, filters)\n+ queryClient.removeQueries({ queryKey, ...filters })\n- queryClient.resetQueries(key, filters, options)\n+ queryClient.resetQueries({ queryKey, ...filters }, options)\n- queryClient.cancelQueries(key, filters, options)\n+ queryClient.cancelQueries({ queryKey, ...filters }, options)\n- queryClient.invalidateQueries(key, filters, options)\n+ queryClient.invalidateQueries({ queryKey, ...filters }, options)\n- queryClient.refetchQueries(key, filters, options)\n+ queryClient.refetchQueries({ queryKey, ...filters }, options)\n- queryClient.fetchQuery(key, fn, options)\n+ queryClient.fetchQuery({ queryKey, queryFn, ...options })\n- queryClient.prefetchQuery(key, fn, options)\n+ queryClient.prefetchQuery({ queryKey, queryFn, ...options })\n- queryClient.fetchInfiniteQuery(key, fn, options)\n+ queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options })\n- queryClient.prefetchInfiniteQuery(key, fn, options)\n+ queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options })\ndiff\n- queryCache.find(key, filters)\n+ queryCache.find({ queryKey, ...filters })\n- queryCache.findAll(key, filters)\n+ queryCache.findAll({ queryKey, ...filters })\nqueryClient.getQueryData now accepts queryKey only as an Argument\n\nqueryClient.getQueryData argument is changed to accept only a queryKey\n\ndiff\n- queryClient.getQueryData(queryKey, filters)\n+ queryClient.getQueryData(queryKey)\nqueryClient.getQueryState now accepts queryKey only as an Argument\n\nqueryClient.getQueryState argument is changed to accept only a queryKey\n\ndiff\n- queryClient.getQueryState(queryKey, filters)\n+ queryClient.getQueryState(queryKey)\nCodemod\n\nTo make the remove overloads migration easier, v5 comes with a codemod.\n\nThe codemod is a best efforts attempt to help you migrate the breaking change. Please review the generated code thoroughly! Also, there are edge cases that cannot be found by the code mod, so please keep an eye on the log output.\n\nIf you want to run it against .js or .jsx files, please use the command below:\n\nbash\nnpx jscodeshift@latest ./path/to/src/ \\\n  --extensions=js,jsx \\\n  --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.js\n\nIf you want to run it against .ts or .tsx files, please use the command below:\n\nbash\nnpx jscodeshift@latest ./path/to/src/ \\\n  --extensions=ts,tsx \\\n  --parser=tsx \\\n  --transform=./node_modules/@tanstack/react-query/build/codemods/src/v5/remove-overloads/remove-overloads.js\n\nPlease note in the case of TypeScript you need to use tsx as the parser; otherwise, the codemod won't be applied properly!\n\nNote: Applying the codemod might break your code formatting, so please don't forget to run prettier and/or eslint after you've applied the codemod!\n\nA few notes about how codemod works:\n\nGenerally, we're looking for the lucky case, when the first parameter is an object expression and contains the \"queryKey\" or \"mutationKey\" property (depending on which hook/method call is being transformed). If this is the case, your code already matches the new signature, so the codemod won't touch it. üéâ\nIf the condition above is not fulfilled, then the codemod will check whether the first parameter is an array expression or an identifier that references an array expression. If this is the case, the codemod will put it into an object expression, then it will be the first parameter.\nIf object parameters can be inferred, the codemod will attempt to copy the already existing properties to the newly created one.\nIf the codemod cannot infer the usage, then it will leave a message on the console. The message contains the file name and the line number of the usage. In this case, you need to do the migration manually.\nIf the transformation results in an error, you will also see a message on the console. This message will notify you something unexpected happened, please do the migration manually.\nCallbacks on useQuery (and QueryObserver) have been removed\n\nonSuccess, onError and onSettled have been removed from Queries. They haven't been touched for Mutations. Please see this RFC for motivations behind this change and what to do instead.\n\nThe refetchInterval callback function only gets query passed\n\nThis streamlines how callbacks are invoked (the refetchOnWindowFocus, refetchOnMount and refetchOnReconnect callbacks all only get the query passed as well), and it fixes some typing issues when callbacks get data transformed by select.\n\ndiff\n- refetchInterval: number | false | ((data: TData | undefined, query: Query) => number | false | undefined)\n+ refetchInterval: number | false | ((query: Query) => number | false | undefined)\n\nYou can still access data with query.state.data, however, it will not be data that has been transformed by select. If you need to access the transformed data, you can call the transformation again on query.state.data.\n\nThe remove method has been removed from useQuery\n\nPreviously, remove method used to remove the query from the queryCache without informing observers about it. It was best used to remove data imperatively that is no longer needed, e.g. when logging a user out.\n\nBut It doesn't make much sense to do this while a query is still active, because it will just trigger a hard loading state with the next re-render.\n\nif you still need to remove a query, you can use queryClient.removeQueries({queryKey: key})\n\ndiff\nconst queryClient = useQueryClient();\n const query = useQuery({ queryKey, queryFn });\n- query.remove()\n+ queryClient.removeQueries({ queryKey })\nThe minimum required TypeScript version is now 4.7\n\nMainly because an important fix was shipped around type inference. Please see this TypeScript issue for more information.\n\nThe isDataEqual option has been removed from useQuery\n\nPreviously, This function was used to indicate whether to use previous data (true) or new data (false) as a resolved data for the query.\n\nYou can achieve the same functionality by passing a function to structuralSharing instead:\n\ndiff\nimport { replaceEqualDeep } from '@tanstack/react-query'\n\n\n- isDataEqual: (oldData, newData) => customCheck(oldData, newData)\n+ structuralSharing: (oldData, newData) => customCheck(oldData, newData) ? oldData : replaceEqualDeep(oldData, newData)\nThe deprecated custom logger has been removed\n\nCustom loggers were already deprecated in 4 and have been removed in this version. Logging only had an effect in development mode, where passing a custom logger is not necessary.\n\nSupported Browsers\n\nWe have updated our browserslist to produce a more modern, performant and smaller bundle. You can read about the requirements here.\n\nPrivate class fields and methods\n\nTanStack Query has always had private fields and methods on classes, but they weren't really private - they were just private in TypeScript. We now use ECMAScript Private class features, which means those fields are now truly private and can't be accessed from the outside at runtime.\n\nRename cacheTime to gcTime\n\nAlmost everyone gets cacheTime wrong. It sounds like \"the amount of time that data is cached for\", but that is not correct.\n\ncacheTime does nothing as long as a query is still in used. It only kicks in as soon as the query becomes unused. After the time has passed, data will be \"garbage collected\" to avoid the cache from growing.\n\ngc is referring to \"garbage collect\" time. It's a bit more technical, but also a quite well known abbreviation in computer science.\n\ndiff\nconst MINUTE = 1000 * 60;\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n-      cacheTime: 10 * MINUTE,\n+      gcTime: 10 * MINUTE,\n    },\n  },\n})\nThe useErrorBoundary option has been renamed to throwOnError\n\nTo make the useErrorBoundary option more framework-agnostic and avoid confusion with the established React function prefix \"use\" for hooks and the \"ErrorBoundary\" component name, it has been renamed to throwOnError to more accurately reflect its functionality.\n\nTypeScript: Error is now the default type for errors instead of unknown\n\nEven though in JavaScript, you can throw anything (which makes unknown the most correct type), almost always, Errors (or subclasses of Error) are thrown. This change makes it easier to work with the error field in TypeScript for most cases.\n\nIf you want to throw something that isn't an Error, you'll now have to set the generic for yourself:\n\nts\nuseQuery<number, string>({\n  queryKey: ['some-query'],\n  queryFn: async () => {\n    if (Math.random() > 0.5) {\n      throw 'some error'\n    }\n    return 42\n  },\n})\n\nFor a way to set a different kind of Error globally, see the TypeScript Guide.\n\neslint prefer-query-object-syntax rule is removed\n\nSince the only supported syntax now is the object syntax, this rule is no longer needed\n\nRemoved keepPreviousData in favor of placeholderData identity function\n\nWe have removed the keepPreviousData option and isPreviousData flag as they were doing mostly the same thing as placeholderData and isPlaceholderData flag.\n\nTo achieve the same functionality as keepPreviousData, we have added previous query data as an argument to placeholderData which accepts an identity function. Therefore you just need to provide an identity function to placeholderData or use the included keepPreviousData function from Tanstack Query.\n\nA note here is that useQueries would not receive previousData in the placeholderData function as argument. This is due to a dynamic nature of queries passed in the array, which may lead to a different shape of result from placeholder and queryFn.\n\ndiff\nimport {\n   useQuery,\n+  keepPreviousData\n} from \"@tanstack/react-query\";\n\n\nconst {\n   data,\n-  isPreviousData,\n+  isPlaceholderData,\n} = useQuery({\n  queryKey,\n  queryFn,\n- keepPreviousData: true,\n+ placeholderData: keepPreviousData\n});\n\nAn identity function, in the context of Tanstack Query, refers to a function that always returns its provided argument (i.e. data) unchanged.\n\nts\nuseQuery({\n  queryKey,\n  queryFn,\n  placeholderData: (previousData, previousQuery) => previousData, // identity function with the same behaviour as `keepPreviousData`\n})\n\nThere are some caveats to this change however, which you must be aware of:\n\nplaceholderData will always put you into success state, while keepPreviousData gave you the status of the previous query. That status could be error if we have data fetched successfully and then got a background refetch error. However, the error itself was not shared, so we decided to stick with behavior of placeholderData.\n\nkeepPreviousData gave you the dataUpdatedAt timestamp of the previous data, while with placeholderData, dataUpdatedAt will stay at 0. This might be annoying if you want to show that timestamp continuously on screen. However you might get around it with useEffect.\n\nts\nconst [updatedAt, setUpdatedAt] = useState(0)\n\n\nconst { data, dataUpdatedAt } = useQuery({\n  queryKey: ['projects', page],\n  queryFn: () => fetchProjects(page),\n})\n\n\nuseEffect(() => {\n  if (dataUpdatedAt > updatedAt) {\n    setUpdatedAt(dataUpdatedAt)\n  }\n}, [dataUpdatedAt])\nWindow focus refetching no longer listens to the focus event\n\nThe visibilitychange event is used exclusively now. This is possible because we only support browsers that support the visibilitychange event. This fixes a bunch of issues as listed here.\n\nNetwork status no longer relies on the navigator.onLine property\n\nnavigator.onLine doesn't work well in Chromium based browsers. There are a lot of issues around false negatives, which lead to Queries being wrongfully marked as offline.\n\nTo circumvent this, we now always start with online: true and only listen to online and offline events to update the status.\n\nThis should reduce the likelihood of false negatives, however, it might mean false positives for offline apps that load via serviceWorkers, which can work even without an internet connection.\n\nRemoved custom context prop in favor of custom queryClient instance\n\nIn v4, we introduced the possibility to pass a custom context to all react-query hooks. This allowed for proper isolation when using MicroFrontends.\n\nHowever, context is a react-only feature. All that context does is give us access to the queryClient. We could achieve the same isolation by allowing to pass in a custom queryClient directly. This in turn will enable other frameworks to have the same functionality in a framework-agnostic way.\n\ndiff\nimport { queryClient } from './my-client'\n\n\nconst { data } = useQuery(\n  {\n    queryKey: ['users', id],\n    queryFn: () => fetch(...),\n-   context: customContext\n  },\n+  queryClient,\n)\nRemoved refetchPage in favor of maxPages\n\nIn v4, we introduced the possibility to define the pages to refetch for infinite queries with the refetchPage function.\n\nHowever, refetching all pages might lead to UI inconsistencies. Also, this option is available on e.g. queryClient.refetchQueries, but it only does something for infinite queries, not \"normal\" queries.\n\nThe v5 includes a new maxPages option for infinite queries to limit the number of pages to store in the query data and to refetch. This new feature handles the use cases initially identified for the refetchPage page feature without the related issues.\n\nNew dehydrate API\n\nThe options you can pass to dehydrate have been simplified. Queries and Mutations are always dehydrated (according to the default function implementation). To change this behaviour, instead of using the removed boolean options dehydrateMutations and dehydrateQueries you can implement the function equivalents shouldDehydrateQuery or shouldDehydrateMutation instead. To get the old behaviour of not hydrating queries/mutations at all, pass in () => false.\n\ndiff\n- dehydrateMutations?: boolean\n- dehydrateQueries?: boolean\nInfinite queries now need a initialPageParam\n\nPreviously, we've passed undefined to the queryFn as pageParam, and you could assign a default value to the pageParam parameter in the queryFn function signature. This had the drawback of storing undefined in the queryCache, which is not serializable.\n\nInstead, you now have to pass an explicit initialPageParam to the infinite query options. This will be used as the pageParam for the first page:\n\ndiff\nuseInfiniteQuery({\n   queryKey,\n-  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam),\n+  queryFn: ({ pageParam }) => fetchSomething(pageParam),\n+  initialPageParam: 0,\n   getNextPageParam: (lastPage) => lastPage.next,\n})\nManual mode for infinite queries has been removed\n\nPreviously, we've allowed to overwrite the pageParams that would be returned from getNextPageParam or getPreviousPageParam by passing a pageParam value directly to fetchNextPage or fetchPreviousPage. This feature didn't work at all with refetches and wasn't widely known or used. This also means that getNextPageParam is now required for infinite queries.\n\nReturning null from getNextPageParam or getPreviousPageParam now indicates that there is no further page available\n\nIn v4, you needed to explicitly return undefined to indicate that there is no further page available. We've widened this check to include null.\n\nNo retries on the server\n\nOn the server, retry now defaults to 0 instead of 3. For prefetching, we have always defaulted to 0 retries, but since queries that have suspense enabled can now execute directly on the server as well (since React18), we have to make sure that we don't retry on the server at all.\n\nstatus: loading has been changed to status: pending and isLoading has been changed to isPending and isInitialLoading has now been renamed to isLoading\n\nThe loading status has been renamed to pending, and similarly the derived isLoading flag has been renamed to isPending.\n\nFor mutations as well the status has been changed from loading to pending and the isLoading flag has been changed to isPending.\n\nLastly, a new derived isLoading flag has been added to the queries that is implemented as isPending && isFetching. This means that isLoading and isInitialLoading have the same thing, but isInitialLoading is deprecated now and will be removed in the next major version.\n\nTo understand the reasoning behing this change checkout the v5 roadmap discussion.\n\nhashQueryKey has been renamed to hashKey\n\nbecause it also hashes mutation keys and can be used inside the predicate functions of useIsMutating and useMutationState, which gets mutations passed.\n\nThe minimum required React version is now 18.0\n\nReact Query v5 requires React 18.0 or later. This is because we are using the new useSyncExternalStore hook, which is only available in React 18.0 and later. Previously, we have been using the shim provided by React.\n\nThe contextSharing prop has been removed from QueryClientProvider\n\nYou could previously use the contextSharing property to share the first (and at least one) instance of the query client context across the window. This ensured that if TanStack Query was used across different bundles or microfrontends then they will all use the same instance of the context, regardless of module scoping.\n\nHowever, isolation is often preferred for microfrontends. In v4 the option to pass a custom context to the QueryClientProvider was added, which allows exactly this. If you wish to use the same query client across multiple packages of an application, you can create a QueryClient in your application and then let the bundles share this through the context property of the QueryClientProvider.\n\nNo longer using unstable_batchedUpdates as the batching function in React and React Native\n\nSince the function unstable_batchedUpdates is noop in React 18, it will no longer be automatically set as the batching function in react-query.\n\nIf your framework supports a custom batching function, you can let TanStack Query know about it by calling notifyManager.setBatchNotifyFunction.\n\nFor example, this is how the batch function is set in solid-query:\n\nts\nimport { notifyManager } from '@tanstack/query-core'\nimport { batch } from 'solid-js'\n\n\nnotifyManager.setBatchNotifyFunction(batch)\nHydration API changes\n\nTo better support concurrent features and transitions we've made some changes to the hydration APIs. The Hydrate component has been renamed to HydrationBoundary and the useHydrate hook has been removed.\n\nThe HydrationBoundary no longer hydrates mutations, only queries. To hydrate mutations, use the low level hydrate API or the persistQueryClient plugin.\n\nFinally, as a technical detail, the timing for when queries are hydrated have changed slightly. New queries are still hydrated in the render phase so that SSR works as usual, but any queries that already exist in the cache are now hydrated in an effect instead (as long as their data is fresher than what is in the cache). If you are hydrating just once at the start of your application as is common, this wont affect you, but if you are using Server Components and pass down fresh data for hydration on a page navigation, you might notice a flash of the old data before the page immediately rerenders.\n\nThis last change is technically a breaking one, and was made so we don't prematurely update content on the existing page before a page transition has been fully committed. No action is required on your part.\n\ndiff\n- import { Hydrate } from '@tanstack/react-query'\n+ import { HydrationBoundary } from '@tanstack/react-query'\n\n\n- <Hydrate state={dehydratedState}>\n+ <HydrationBoundary state={dehydratedState}>\n  <App />\n- </Hydrate>\n+ </HydrationBoundary>\nNew Features üöÄ\n\nv5 also comes with new features:\n\nSimplified optimistic updates\n\nWe have a new, simplified way to perform optimistic updates by leveraging the returned variables from useMutation:\n\ntsx\nconst queryInfo = useTodos()\nconst addTodoMutation = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n})\n\n\nif (queryInfo.data) {\n  return (\n    <ul>\n      {queryInfo.data.items.map((todo) => (\n        <li key={todo.id}>{todo.text}</li>\n      ))}\n      {addTodoMutation.isPending && (\n        <li key={String(addTodoMutation.submittedAt)} style={{ opacity: 0.5 }}>\n          {addTodoMutation.variables}\n        </li>\n      )}\n    </ul>\n  )\n}\n\nHere, we are only changing how the UI looks when the mutation is running instead of writing data directly to the cache. This works best if we only have one place where we need to show the optimistic update. For more details, have a look at the optimistic updates documentation.\n\nLimited, Infinite Queries with new maxPages option\n\nInfinite queries are great when infinite scroll or pagination are needed. However, the more pages you fetch, the more memory you consume, and this also slows down the query refetching process as all the pages are sequentially refetched.\n\nVersion 5 has a new maxPages option for infinite queries, which allows developers to limit the number of pages that are stored in the query data and subsequently refetched. You can adjust the maxPages value according to the UX and refetching performance you want to deliver.\n\nNote that the infinite list must be bi-directional, which requires both getNextPageParam and getPreviousPageParam to be defined.\n\nInfinite Queries can prefetch multiple pages\n\nInfinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option. Read the prefetching guide for more information.\n\nNew combine option for useQueries\n\nSee the useQueries docs for more details.\n\nExperimental fine grained storage persister\n\nSee the experimental_createPersister docs for more details.\n\nTypesafe way to create Query Options\n\nSee the TypeScript docs for more details.\n\nnew hooks for suspense\n\nWith v5, suspense for data fetching finally becomes \"stable\". We've added dedicated useSuspenseQuery, useSuspenseInfiniteQuery and useSuspenseQueries hooks. With these hooks, data will never be potentially undefined on type level:\n\njs\nconst { data: post } = useSuspenseQuery({\n  // ^? const post: Post\n  queryKey: ['post', postId],\n  queryFn: () => fetchPost(postId),\n})\n\nThe experimental suspense: boolean flag on the query hooks has been removed.\n\nYou can read more about them in the suspense docs.\n"
  },
  {
    "title": "Migrating to React Query 3 | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/migrating-to-react-query-3",
    "html": "Migrating to React Query 3\n\nPrevious versions of React Query were awesome and brought some amazing new features, more magic, and an overall better experience to the library. They also brought on massive adoption and likewise a lot of refining fire (issues/contributions) to the library and brought to light a few things that needed more polish to make the library even better. v3 contains that very polish.\n\nOverview\nMore scalable and testable cache configuration\nBetter SSR support\nData-lag (previously usePaginatedQuery) anywhere!\nBi-directional Infinite Queries\nQuery data selectors!\nFully configure defaults for queries and/or mutations before use\nMore granularity for optional rendering optimization\nNew useQueries hook! (Variable-length parallel query execution)\nQuery filter support for the useIsFetching() hook!\nRetry/offline/replay support for mutations\nObserve queries/mutations outside of React\nUse the React Query core logic anywhere you want!\nBundled/Colocated Devtools via react-query/devtools\nCache Persistence to web storage (experimental via react-query/persistQueryClient-experimental and react-query/createWebStoragePersistor-experimental)\nBreaking Changes The QueryCache has been split into a QueryClient and lower-level QueryCache and MutationCache instances.\n\nThe QueryCache contains all queries, the MutationCache contains all mutations, and the QueryClient can be used to set configuration and to interact with them.\n\nThis has some benefits:\n\nAllows for different types of caches.\nMultiple clients with different configurations can use the same cache.\nClients can be used to track queries, which can be used for shared caches on SSR.\nThe client API is more focused towards general usage.\nEasier to test the individual components.\n\nWhen creating a new QueryClient(), a QueryCache and MutationCache are automatically created for you if you don't supply them.\n\ntsx\nimport { QueryClient } from 'react-query'\n\n\nconst queryClient = new QueryClient()\nReactQueryConfigProvider and ReactQueryCacheProvider have both been replaced by QueryClientProvider\n\nDefault options for queries and mutations can now be specified in QueryClient:\n\nNotice that it's now defaultOptions instead of defaultConfig\n\ntsx\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // query options\n    },\n    mutations: {\n      // mutation options\n    },\n  },\n})\n\nThe QueryClientProvider component is now used to connect a QueryClient to your application:\n\ntsx\nimport { QueryClient, QueryClientProvider } from 'react-query'\n\n\nconst queryClient = new QueryClient()\n\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\nThe default QueryCache is gone. For real this time!\n\nAs previously noted with a deprecation, there is no longer a default QueryCache that is created or exported from the main package. You must create your own via new QueryClient() or new QueryCache() (which you can then pass to new QueryClient({ queryCache }) )\n\nThe deprecated makeQueryCache utility has been removed.\n\nIt's been a long time coming, but it's finally gone :)\n\nQueryCache.prefetchQuery() has been moved to QueryClient.prefetchQuery()\n\nThe new QueryClient.prefetchQuery() function is async, but does not return the data from the query. If you require the data, use the new QueryClient.fetchQuery() function\n\ntsx\n// Prefetch a query:\nawait queryClient.prefetchQuery('posts', fetchPosts)\n\n\n// Fetch a query:\ntry {\n  const data = await queryClient.fetchQuery('posts', fetchPosts)\n} catch (error) {\n  // Error handling\n}\nReactQueryErrorResetBoundary and QueryCache.resetErrorBoundaries() have been replaced by QueryErrorResetBoundary and useQueryErrorResetBoundary().\n\nTogether, these provide the same experience as before, but with added control to choose which component trees you want to reset. For more information, see:\n\nQueryErrorResetBoundary\nuseQueryErrorResetBoundary\nQueryCache.getQuery() has been replaced by QueryCache.find().\n\nQueryCache.find() should now be used to look up individual queries from a cache\n\nQueryCache.getQueries() has been moved to QueryCache.findAll().\n\nQueryCache.findAll() should now be used to look up multiple queries from a cache\n\nQueryCache.isFetching has been moved to QueryClient.isFetching().\n\nNotice that it's now a function instead of a property\n\nThe useQueryCache hook has been replaced by the useQueryClient hook.\n\nIt returns the provided queryClient for its component tree and shouldn't need much tweaking beyond a rename.\n\nQuery key parts/pieces are no longer automatically spread to the query function.\n\nInline functions are now the suggested way of passing parameters to your query functions:\n\ntsx\n// Old\nuseQuery(['post', id], (_key, id) => fetchPost(id))\n\n\n// New\nuseQuery(['post', id], () => fetchPost(id))\n\nIf you still insist on not using inline functions, you can use the newly passed QueryFunctionContext:\n\ntsx\nuseQuery(['post', id], context => fetchPost(context.queryKey[1]))\nInfinite Query Page params are now passed via QueryFunctionContext.pageParam\n\nThey were previously added as the last query key parameter in your query function, but this proved to be difficult for some patterns\n\ntsx\n// Old\nuseInfiniteQuery(['posts'], (_key, pageParam = 0) => fetchPosts(pageParam))\n\n\n// New\nuseInfiniteQuery(['posts'], ({ pageParam = 0 }) => fetchPosts(pageParam))\nusePaginatedQuery() has been removed in favor of the keepPreviousData option\n\nThe new keepPreviousData options is available for both useQuery and useInfiniteQuery and will have the same \"lagging\" effect on your data:\n\ntsx\nimport { useQuery } from 'react-query'\n\n\nfunction Page({ page }) {\n  const { data } = useQuery(['page', page], fetchPage, {\n    keepPreviousData: true,\n  })\n}\nuseInfiniteQuery() is now bi-directional\n\nThe useInfiniteQuery() interface has changed to fully support bi-directional infinite lists.\n\noptions.getFetchMore has been renamed to options.getNextPageParam\nqueryResult.canFetchMore has been renamed to queryResult.hasNextPage\nqueryResult.fetchMore has been renamed to queryResult.fetchNextPage\nqueryResult.isFetchingMore has been renamed to queryResult.isFetchingNextPage\nAdded the options.getPreviousPageParam option\nAdded the queryResult.hasPreviousPage property\nAdded the queryResult.fetchPreviousPage property\nAdded the queryResult.isFetchingPreviousPage\nThe data of an infinite query is now an object containing the pages and the pageParams used to fetch the pages: { pages: [data, data, data], pageParams: [...]}\n\nOne direction:\n\ntsx\nconst {\n  data,\n  fetchNextPage,\n  hasNextPage,\n  isFetchingNextPage,\n} = useInfiniteQuery(\n  'projects',\n  ({ pageParam = 0 }) => fetchProjects(pageParam),\n  {\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  }\n)\n\nBoth directions:\n\ntsx\nconst {\n  data,\n  fetchNextPage,\n  fetchPreviousPage,\n  hasNextPage,\n  hasPreviousPage,\n  isFetchingNextPage,\n  isFetchingPreviousPage,\n} = useInfiniteQuery(\n  'projects',\n  ({ pageParam = 0 }) => fetchProjects(pageParam),\n  {\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  }\n)\n\nOne direction reversed:\n\ntsx\nconst {\n  data,\n  fetchNextPage,\n  hasNextPage,\n  isFetchingNextPage,\n} = useInfiniteQuery(\n  'projects',\n  ({ pageParam = 0 }) => fetchProjects(pageParam),\n  {\n    select: data => ({\n      pages: [...data.pages].reverse(),\n      pageParams: [...data.pageParams].reverse(),\n    }),\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  }\n)\nInfinite Query data now contains the array of pages and pageParams used to fetch those pages.\n\nThis allows for easier manipulation of the data and the page params, like, for example, removing the first page of data along with it's params:\n\ntsx\nqueryClient.setQueryData(['projects'], data => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\nuseMutation now returns an object instead of an array\n\nThough the old way gave us warm fuzzy feelings of when we first discovered useState for the first time, they didn't last long. Now the mutation return is a single object.\n\ntsx\n// Old:\nconst [mutate, { status, reset }] = useMutation()\n\n\n// New:\nconst { mutate, status, reset } = useMutation()\nmutation.mutate no longer return a promise\nThe [mutate] variable has been changed to the mutation.mutate function\nAdded the mutation.mutateAsync function\n\nWe got a lot of questions regarding this behavior as users expected the promise to behave like a regular promise.\n\nBecause of this the mutate function is now split into a mutate and mutateAsync function.\n\nThe mutate function can be used when using callbacks:\n\ntsx\nconst { mutate } = useMutation({ mutationFn: addTodo })\n\n\nmutate('todo', {\n  onSuccess: data => {\n    console.log(data)\n  },\n  onError: error => {\n    console.error(error)\n  },\n  onSettled: () => {\n    console.log('settled')\n  },\n})\n\nThe mutateAsync function can be used when using async/await:\n\ntsx\nconst { mutateAsync } = useMutation({ mutationFn: addTodo })\n\n\ntry {\n  const data = await mutateAsync('todo')\n  console.log(data)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('settled')\n}\nThe object syntax for useQuery now uses a collapsed config:\ntsx\n// Old:\nuseQuery({\n  queryKey: 'posts',\n  queryFn: fetchPosts,\n  config: { staleTime: Infinity },\n})\n\n\n// New:\nuseQuery({\n  queryKey: 'posts',\n  queryFn: fetchPosts,\n  staleTime: Infinity,\n})\nIf set, the QueryOptions.enabled option must be a boolean (true/false)\n\nThe enabled query option will now only disable a query when the value is false. If needed, values can be casted with !!userId or Boolean(userId) and a handy error will be thrown if a non-boolean value is passed.\n\nThe QueryOptions.initialStale option has been removed\n\nThe initialStale query option has been removed and initial data is now treated as regular data. Which means that if initialData is provided, the query will refetch on mount by default. If you do not want to refetch immediately, you can define a staleTime.\n\nThe QueryOptions.forceFetchOnMount option has been replaced by refetchOnMount: 'always'\n\nHonestly, we were accruing way too many refetchOn____ options, so this should clean things up.\n\nThe QueryOptions.refetchOnMount options now only applies to its parent component instead of all query observers\n\nWhen refetchOnMount was set to false any additional components were prevented from refetching on mount. In version 3 only the component where the option has been set will not refetch on mount.\n\nThe QueryOptions.queryFnParamsFilter has been removed in favor of the new QueryFunctionContext object.\n\nThe queryFnParamsFilter option has been removed because query functions now get a QueryFunctionContext object instead of the query key.\n\nParameters can still be filtered within the query function itself as the QueryFunctionContext also contains the query key.\n\nThe QueryOptions.notifyOnStatusChange option has been superseded by the new notifyOnChangeProps and notifyOnChangePropsExclusions options.\n\nWith these new options it is possible to configure when a component should re-render on a granular level.\n\nOnly re-render when the data or error properties change:\n\ntsx\nimport { useQuery } from 'react-query'\n\n\nfunction User() {\n  const { data } = useQuery(['user'], fetchUser, {\n    notifyOnChangeProps: ['data', 'error'],\n  })\n  return <div>Username: {data.username}</div>\n}\n\nPrevent re-render when the isStale property changes:\n\ntsx\nimport { useQuery } from 'react-query'\n\n\nfunction User() {\n  const { data } = useQuery(['user'], fetchUser, {\n    notifyOnChangePropsExclusions: ['isStale'],\n  })\n  return <div>Username: {data.username}</div>\n}\nThe QueryResult.clear() function has been renamed to QueryResult.remove()\n\nAlthough it was called clear, it really just removed the query from the cache. The name now matches the functionality.\n\nThe QueryResult.updatedAt property has been split into QueryResult.dataUpdatedAt and QueryResult.errorUpdatedAt properties\n\nBecause data and errors can be present at the same time, the updatedAt property has been split into dataUpdatedAt and errorUpdatedAt.\n\nsetConsole() has been replaced by the new setLogger() function\ntsx\nimport { setLogger } from 'react-query'\n\n\n// Log with Sentry\nsetLogger({\n  error: error => {\n    Sentry.captureException(error)\n  },\n})\n\n\n// Log with Winston\nsetLogger(winston.createLogger())\nReact Native no longer requires overriding the logger\n\nTo prevent showing error screens in React Native when a query fails it was necessary to manually change the Console:\n\ntsx\nimport { setConsole } from 'react-query'\n\n\nsetConsole({\n  log: console.log,\n  warn: console.warn,\n  error: console.warn,\n})\n\nIn version 3 this is done automatically when React Query is used in React Native.\n\nTypescript QueryStatus has been changed from an enum to a union type\n\nSo, if you were checking the status property of a query or mutation against a QueryStatus enum property you will have to check it now against the string literal the enum previously held for each property.\n\nTherefore you have to change the enum properties to their equivalent string literal, like this:\n\nQueryStatus.Idle -> 'idle'\nQueryStatus.Loading -> 'loading'\nQueryStatus.Error -> 'error'\nQueryStatus.Success -> 'success'\n\nHere is an example of the changes you would have to make:\n\ndiff\n- import { useQuery, QueryStatus } from 'react-query';\n+ import { useQuery } from 'react-query';\nconst { data, status } = useQuery(['post', id], () => fetchPost(id))\n\n\n- if (status === QueryStatus.Loading) {\n+ if (status === 'loading') {\n  ...\n}\n\n\n- if (status === QueryStatus.Error) {\n+ if (status === 'error') {\n  ...\n}\nNew features Query Data Selectors\n\nThe useQuery and useInfiniteQuery hooks now have a select option to select or transform parts of the query result.\n\ntsx\nimport { useQuery } from 'react-query'\n\n\nfunction User() {\n  const { data } = useQuery(['user'], fetchUser, {\n    select: user => user.username,\n  })\n  return <div>Username: {data}</div>\n}\n\nSet the notifyOnChangeProps option to ['data', 'error'] to only re-render when the selected data changes.\n\nThe useQueries() hook, for variable-length parallel query execution\n\nWish you could run useQuery in a loop? The rules of hooks say no, but with the new useQueries() hook, you can!\n\ntsx\nimport { useQueries } from 'react-query'\n\n\nfunction Overview() {\n  const results = useQueries([\n    { queryKey: ['post', 1], queryFn: fetchPost },\n    { queryKey: ['post', 2], queryFn: fetchPost },\n  ])\n  return (\n    <ul>\n      {results.map(({ data }) => data && <li key={data.id}>{data.title})</li>)}\n    </ul>\n  )\n}\nRetry/offline mutations\n\nBy default React Query will not retry a mutation on error, but it is possible with the retry option:\n\ntsx\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\n\nIf mutations fail because the device is offline, they will be retried in the same order when the device reconnects.\n\nPersist mutations\n\nMutations can now be persisted to storage and resumed at a later point. More information can be found in the mutations documentation.\n\nQueryObserver\n\nA QueryObserver can be used to create and/or watch a query:\n\ntsx\nconst observer = new QueryObserver(queryClient, { queryKey: 'posts' })\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\nInfiniteQueryObserver\n\nA InfiniteQueryObserver can be used to create and/or watch an infinite query:\n\ntsx\nconst observer = new InfiniteQueryObserver(queryClient, {\n  queryKey: 'posts',\n  queryFn: fetchPosts,\n  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,\n})\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\nQueriesObserver\n\nA QueriesObserver can be used to create and/or watch multiple queries:\n\ntsx\nconst observer = new QueriesObserver(queryClient, [\n  { queryKey: ['post', 1], queryFn: fetchPost },\n  { queryKey: ['post', 2], queryFn: fetchPost },\n])\n\n\nconst unsubscribe = observer.subscribe(result => {\n  console.log(result)\n  unsubscribe()\n})\nSet default options for specific queries\n\nThe QueryClient.setQueryDefaults() method can be used to set default options for specific queries:\n\ntsx\nqueryClient.setQueryDefaults(['posts'], { queryFn: fetchPosts })\n\n\nfunction Component() {\n  const { data } = useQuery(['posts'])\n}\nSet default options for specific mutations\n\nThe QueryClient.setMutationDefaults() method can be used to set default options for specific mutations:\n\ntsx\nqueryClient.setMutationDefaults(['addPost'], { mutationFn: addPost })\n\n\nfunction Component() {\n  const { mutate } = useMutation({ mutationKey: ['addPost'] })\n}\nuseIsFetching()\n\nThe useIsFetching() hook now accepts filters which can be used to for example only show a spinner for certain type of queries:\n\ntsx\nconst fetches = useIsFetching({ queryKey: ['posts'] })\nCore separation\n\nThe core of React Query is now fully separated from React, which means it can also be used standalone or in other frameworks. Use the react-query/core entry point to only import the core functionality:\n\ntsx\nimport { QueryClient } from 'react-query/core'\nDevtools are now part of the main repo and npm package\n\nThe devtools are now included in the react-query package itself under the import react-query/devtools. Simply replace react-query-devtools imports with react-query/devtools\n"
  },
  {
    "title": "Does TanStack Query replace Redux, MobX or other global state managers? | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/does-this-replace-client-state",
    "html": "Does TanStack Query replace Redux, MobX or other global state managers?\n\nWell, let's start with a few important items:\n\nTanStack Query is a server-state library, responsible for managing asynchronous operations between your server and client\nRedux, MobX, Zustand, etc. are client-state libraries that can be used to store asynchronous data, albeit inefficiently when compared to a tool like TanStack Query\n\nWith those points in mind, the short answer is that TanStack Query replaces the boilerplate code and related wiring used to manage cache data in your client-state and replaces it with just a few lines of code.\n\nFor a vast majority of applications, the truly globally accessible client state that is left over after migrating all of your async code to TanStack Query is usually very tiny.\n\nThere are still some circumstances where an application might indeed have a massive amount of synchronous client-only state (like a visual designer or music production application), in which case, you will probably still want a client state manager. In this situation it's important to note that TanStack Query is not a replacement for local/client state management. However, you can use TanStack Query alongside most client state managers with zero issues.\n\nA Contrived Example\n\nHere we have some \"global\" state being managed by a global state library:\n\ntsx\nconst globalState = {\n  projects,\n  teams,\n  tasks,\n  users,\n  themeMode,\n  sidebarStatus,\n}\n\nCurrently, the global state manager is caching 4 types of server-state: projects, teams, tasks, and users. If we were to move these server-state assets to TanStack Query, our remaining global state would look more like this:\n\ntsx\nconst globalState = {\n  themeMode,\n  sidebarStatus,\n}\n\nThis also means that with a few hook calls to useQuery and useMutation, we also get to remove any boilerplate code that was used to manage our server state e.g.\n\nConnectors\nAction Creators\nMiddlewares\nReducers\nLoading/Error/Result states\nContexts\n\nWith all of those things removed, you may ask yourself, \"Is it worth it to keep using our client state manager for this tiny global state?\"\n\nAnd that's up to you!\n\nBut TanStack Query's role is clear. It removes asynchronous wiring and boilerplate from your application and replaces it with just a few lines of code.\n\nWhat are you waiting for, give it a go already!\n"
  },
  {
    "title": "Testing | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/testing",
    "html": "Testing\n\nReact Query works by means of hooks - either the ones we offer or custom ones that wrap around them.\n\nWith React 17 or earlier, writing unit tests for these custom hooks can be done by means of the React Hooks Testing Library library.\n\nInstall this by running:\n\nsh\nnpm install @testing-library/react-hooks react-test-renderer --save-dev\n\n(The react-test-renderer library is needed as a peer dependency of @testing-library/react-hooks, and needs to correspond to the version of React that you are using.)\n\nNote: when using React 18 or later, renderHook is available directly through the @testing-library/react package, and @testing-library/react-hooks is no longer required.\n\nOur First Test\n\nOnce installed, a simple test can be written. Given the following custom hook:\n\ntsx\nexport function useCustomHook() {\n  return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' });\n}\n\nUsing React 17 or earlier, we can write a test for this as follows:\n\ntsx\nconst queryClient = new QueryClient();\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>\n    {children}\n  </QueryClientProvider>\n);\n\n\nconst { result, waitFor } = renderHook(() => useCustomHook(), { wrapper });\n\n\nawait waitFor(() => result.current.isSuccess);\n\n\nexpect(result.current.data).toEqual(\"Hello\");\n\nUsing React 18 or later, the semantics of waitFor have changed, and the above test needs to be modified as follows:\n\ntsx\nimport { renderHook, waitFor } from \"@testing-library/react\";\n\n\n...\n\n\nconst { result } = renderHook(() => useCustomHook(), { wrapper });\n\n\nawait waitFor(() => expect(result.current.isSuccess).toBe(true));\n\nNote that we provide a custom wrapper that builds the QueryClient and QueryClientProvider. This helps to ensure that our test is completely isolated from any other tests.\n\nIt is possible to write this wrapper only once, but if so we need to ensure that the QueryClient gets cleared before every test, and that tests don't run in parallel otherwise one test will influence the results of others.\n\nTurn off retries\n\nThe library defaults to three retries with exponential backoff, which means that your tests are likely to timeout if you want to test an erroneous query. The easiest way to turn retries off is via the QueryClientProvider. Let's extend the above example:\n\ntsx\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // ‚úÖ turns retries off\n      retry: false,\n    },\n  },\n})\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>\n    {children}\n  </QueryClientProvider>\n);\n\nThis will set the defaults for all queries in the component tree to \"no retries\". It is important to know that this will only work if your actual useQuery has no explicit retries set. If you have a query that wants 5 retries, this will still take precedence, because defaults are only taken as a fallback.\n\nSet gcTime to Infinity with Jest\n\nIf you use Jest, you can set the gcTime to Infinity to prevent \"Jest did not exit one second after the test run completed\" error message. This is the default behavior on the server, and is only necessary to set if you are explicitly setting a gcTime.\n\nTesting Network Calls\n\nThe primary use for React Query is to cache network requests, so it's important that we can test our code is making the correct network requests in the first place.\n\nThere are plenty of ways that these can be tested, but for this example we are going to use nock.\n\nGiven the following custom hook:\n\ntsx\nfunction useFetchData() {\n  return useQuery({\n    queryKey: ['fetchData'],\n    queryFn: () => request('/api/data'),\n  });\n}\n\nWe can write a test for this as follows:\n\ntsx\nconst queryClient = new QueryClient();\nconst wrapper = ({ children }) => (\n  <QueryClientProvider client={queryClient}>\n    {children}\n  </QueryClientProvider>\n);\n\n\nconst expectation = nock('http://example.com')\n  .get('/api/data')\n  .reply(200, {\n    answer: 42\n  });\n\n\nconst { result, waitFor } = renderHook(() => useFetchData(), { wrapper });\n\n\nawait waitFor(() => {\n  return result.current.isSuccess;\n});\n\n\nexpect(result.current.data).toEqual({answer: 42});\n\nHere we are making use of waitFor and waiting until the query status indicates that the request has succeeded. This way we know that our hook has finished and should have the correct data. Note: when using React 18, the semantics of waitFor have changed as noted above.\n\nTesting Load More / Infinite Scroll\n\nFirst we need to mock our API response\n\ntsx\nfunction generateMockedResponse(page) {\n  return {\n    page: page,\n    items: [...]\n  }\n}\n\nThen, our nock configuration needs to differentiate responses based on the page, and we'll be using uri to do this. uri's value here will be something like \"/?page=1 or /?page=2\n\ntsx\nconst expectation = nock('http://example.com')\n  .persist()\n  .query(true)\n  .get('/api/data')\n  .reply(200, (uri) => {\n    const url = new URL(`http://example.com${uri}`);\n    const { page } = Object.fromEntries(url.searchParams);\n    return generateMockedResponse(page);\n  });\n\n(Notice the .persist(), because we'll be calling from this endpoint multiple times)\n\nNow we can safely run our tests, the trick here is to await for the data assertion to pass:\n\ntsx\nconst { result, waitFor } = renderHook(\n  () => useInfiniteQueryCustomHook(),\n  { wrapper },\n);\n\n\nawait waitFor(() => result.current.isSuccess);\n\n\nexpect(result.current.data.pages).toStrictEqual(generateMockedResponse(1));\n\n\nresult.current.fetchNextPage();\n\n\nawait waitFor(() =>\n  expect(result.current.data.pages).toStrictEqual([\n    ...generateMockedResponse(1),\n    ...generateMockedResponse(2),\n  ]),\n);\n\n\nexpectation.done();\n\nNote: when using React 18, the semantics of waitFor have changed as noted above.\n\nFurther reading\n\nFor additional tips and an alternative setup using mock-service-worker, have a look at Testing React Query from the Community Resources.\n"
  },
  {
    "title": "Suspense | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/suspense",
    "html": "Suspense\n\nReact Query can also be used with React's Suspense for Data Fetching API's. For this, we have dedicated hooks:\n\nuseSuspenseQuery\nuseSuspenseInfiniteQuery\nuseSuspenseQueries\n\nWhen using suspense mode, status states and error objects are not needed and are then replaced by usage of the React.Suspense component (including the use of the fallback prop and React error boundaries for catching errors). Please read the Resetting Error Boundaries and look at the Suspense Example for more information on how to set up suspense mode.\n\nIf you want mutations to propagate errors to the nearest error boundary (similar to queries), you can set the throwOnError option to true as well.\n\nEnabling suspense mode for a query:\n\ntsx\nimport { useSuspenseQuery } from '@tanstack/react-query'\n\n\nconst { data } = useSuspenseQuery({ queryKey, queryFn })\n\nThis works nicely in TypeScript, because data is guaranteed to be defined (as errors and loading states are handled by Suspense- and ErrorBoundaries).\n\nOn the flip side, you therefore can't conditionally enable / disable the Query. This generally shouldn't be necessary for dependent Queries because with suspense, all your Queries inside one component are fetched in serial.\n\nplaceholderData also doesn't exist for this Query. To prevent the UI from being replaced by a fallback during an update, wrap your updates that change the QueryKey into startTransition.\n\nthrowOnError default\n\nNot all errors are thrown to the nearest Error Boundary per default - we're only throwing errors if there is no other data to show. That means if a Query ever successfully got data in the cache, the component will render, even if data is stale. Thus, the default for throwOnError is:\n\nbash\nthrowOnError: (error, query) => typeof query.state.data === 'undefined'\n\nSince you can't change throwOnError (because it would allow for data to become potentially undefined), you have to throw errors manually if you want all errors to be handled by Error Boundaries:\n\ntsx\nimport { useSuspenseQuery } from '@tanstack/react-query'\n\n\nconst { data, error } = useSuspenseQuery({ queryKey, queryFn })\n\n\nif (error) {\n    throw error\n}\n\n\n// continue rendering data\nResetting Error Boundaries\n\nWhether you are using suspense or throwOnError in your queries, you will need a way to let queries know that you want to try again when re-rendering after some error occurred.\n\nQuery errors can be reset with the QueryErrorResetBoundary component or with the useQueryErrorResetBoundary hook.\n\nWhen using the component it will reset any query errors within the boundaries of the component:\n\ntsx\nimport { QueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\n\nconst App: React.FC = () => (\n  <QueryErrorResetBoundary>\n    {({ reset }) => (\n      <ErrorBoundary\n        onReset={reset}\n        fallbackRender={({ resetErrorBoundary }) => (\n          <div>\n            There was an error!\n            <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n          </div>\n        )}\n      >\n        <Page />\n      </ErrorBoundary>\n    )}\n  </QueryErrorResetBoundary>\n)\n\nWhen using the hook it will reset any query errors within the closest QueryErrorResetBoundary. If there is no boundary defined it will reset them globally:\n\ntsx\nimport { useQueryErrorResetBoundary } from '@tanstack/react-query'\nimport { ErrorBoundary } from 'react-error-boundary'\n\n\nconst App: React.FC = () => {\n  const { reset } = useQueryErrorResetBoundary()\n  return (\n    <ErrorBoundary\n      onReset={reset}\n      fallbackRender={({ resetErrorBoundary }) => (\n        <div>\n          There was an error!\n          <Button onClick={() => resetErrorBoundary()}>Try again</Button>\n        </div>\n      )}\n    >\n      <Page />\n    </ErrorBoundary>\n  )\n}\nFetch-on-render vs Render-as-you-fetch\n\nOut of the box, React Query in suspense mode works really well as a Fetch-on-render solution with no additional configuration. This means that when your components attempt to mount, they will trigger query fetching and suspend, but only once you have imported them and mounted them. If you want to take it to the next level and implement a Render-as-you-fetch model, we recommend implementing Prefetching on routing callbacks and/or user interactions events to start loading queries before they are mounted and hopefully even before you start importing or mounting their parent components.\n\nSuspense on the Server with streaming\n\nIf you are using NextJs, you can use our experimental integration for Suspense on the Server: @tanstack/react-query-next-experimental. This package will allow you to fetch data on the server (in a client component) by just calling useSuspenseQuery in your component. Results will then be streamed from the server to the client as SuspenseBoundaries resolve.\n\nTo achieve this, wrap your app in the ReactQueryStreamedHydration component:\n\ntsx\n// app/providers.tsx\n'use client'\n\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport * as React from 'react'\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\n\nexport function Providers(props: { children: React.ReactNode }) {\n  const [queryClient] = React.useState(() => new QueryClient())\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ReactQueryStreamedHydration>\n        {props.children}\n      </ReactQueryStreamedHydration>\n    </QueryClientProvider>\n  )\n}\n\nFor more information, check out the NextJs Suspense Streaming Example and the Advanced Rendering & Hydration guide.\n"
  },
  {
    "title": "Default Query Function | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/default-query-function",
    "html": "Default Query Function\n\nIf you find yourself wishing for whatever reason that you could just share the same query function for your entire app and just use query keys to identify what it should fetch, you can do that by providing a default query function to TanStack Query:\n\ntsx\n// Define a default query function that will receive the query key\nconst defaultQueryFn = async ({ queryKey }) => {\n  const { data } = await axios.get(\n    `https://jsonplaceholder.typicode.com${queryKey[0]}`,\n  )\n  return data\n}\n\n\n// provide the default query function to your app with defaultOptions\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: defaultQueryFn,\n    },\n  },\n})\n\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <YourApp />\n    </QueryClientProvider>\n  )\n}\n\n\n// All you have to do now is pass a key!\nfunction Posts() {\n  const { status, data, error, isFetching } = useQuery({ queryKey: ['/posts'] })\n\n\n  // ...\n}\n\n\n// You can even leave out the queryFn and just go straight into options\nfunction Post({ postId }) {\n  const { status, data, error, isFetching } = useQuery({\n    queryKey: [`/posts/${postId}`],\n    enabled: !!postId,\n  })\n\n\n  // ...\n}\n\nIf you ever want to override the default queryFn, you can just provide your own like you normally would.\n"
  },
  {
    "title": "Caching Examples | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/caching",
    "html": "Caching Examples\n\nPlease thoroughly read the Important Defaults before reading this guide\n\nBasic Example\n\nThis caching example illustrates the story and lifecycle of:\n\nQuery Instances with and without cache data\nBackground Refetching\nInactive Queries\nGarbage Collection\n\nLet's assume we are using the default gcTime of 5 minutes and the default staleTime of 0.\n\nA new instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) mounts.\nSince no other queries have been made with the ['todos'] query key, this query will show a hard loading state and make a network request to fetch the data.\nWhen the network request has completed, the returned data will be cached under the ['todos'] key.\nThe hook will mark the data as stale after the configured staleTime (defaults to 0, or immediately).\nA second instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) mounts elsewhere.\nSince the cache already has data for the ['todos'] key from the first query, that data is immediately returned from the cache.\nThe new instance triggers a new network request using its query function.\nNote that regardless of whether both fetchTodos query functions are identical or not, both queries' status are updated (including isFetching, isPending, and other related values) because they have the same query key.\nWhen the request completes successfully, the cache's data under the ['todos'] key is updated with the new data, and both instances are updated with the new data.\nBoth instances of the useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) query are unmounted and no longer in use.\nSince there are no more active instances of this query, a garbage collection timeout is set using gcTime to delete and garbage collect the query (defaults to 5 minutes).\nBefore the cache timeout has completed, another instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) mounts. The query immediately returns the available cached data while the fetchTodos function is being run in the background. When it completes successfully, it will populate the cache with fresh data.\nThe final instance of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) unmounts.\nNo more instances of useQuery({ queryKey: ['todos'], queryFn: fetchTodos }) appear within 5 minutes.\nThe cached data under the ['todos'] key is deleted and garbage collected."
  },
  {
    "title": "Server Rendering & Hydration | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/ssr",
    "html": "Server Rendering & Hydration\n\nIn this guide you'll learn how to use React Query with server rendering.\n\nSee the guide on Prefetching & Router Integration for some background. You might also want to check out the Performance & Request Waterfalls guide before that.\n\nFor advanced server rendering patterns, such as streaming, Server Components and the new Next.js app router, see the Advanced Server Rendering guide.\n\nIf you just want to see some code, you can skip ahead to the Full Next.js pages router example or the Full Remix example below.\n\nServer Rendering & React Query\n\nSo what is server rendering anyway? The rest of this guide will assume you are familiar with the concept, but let's spend some time to look at how it relates to React Query. Server rendering is the act of generating the initial html on the server, so that the user has some content to look at as soon as the page loads. This can happen on demand when a page is requested (SSR). It can also happen ahead of time either because a previous request was cached, or at build time (SSG).\n\nIf you've read the Request Waterfalls guide, you might remember this:\n\nbash\n1. |-> Markup (without content)\n2.   |-> JS\n3.     |-> Query\n\nWith a client rendered application, these are the minimum 3 server roundtrips you will need to make before getting any content on the screen for the user. One way of viewing server rendering is that it turns the above into this:\n\nbash\n1. |-> Markup (with content AND initial data)\n2.   |-> JS\n\nAs soon as 1. is complete, the user can see the content and when 2. finishes, the page is interactive and clickable. Because the markup also contains the initial data we need, step 3. does not need to run on the client at all, at least until you want to revalidate the data for some reason.\n\nThis is all from the clients perspective. On the server, we need to prefetch that data before we generate/render the markup, we need to dehydrate that data into a serializable format we can embed in the markup, and on the client we need to hydrate that data into a React Query cache so we can avoid doing a new fetch on the client.\n\nRead on to learn how to implement these three steps with React Query.\n\nA quick note on Suspense\n\nThis guide uses the regular useQuery API. While we don't necessarily recommend it, it is possible to replace this with useSuspenseQuery instead as long as you always prefetch all your queries. The upside is that you get to use <Suspense> for loading states on the client.\n\nIf you do forget to prefetch a query when you are using useSuspenseQuery, the consequences will depend on the framework you are using. In some cases, the data will Suspend and get fetched on the server but never be hydrated to the client, where it will fetch again. In these cases you will get a markup hydration mismatch, because the server and the client tried to render different things.\n\nInitial setup\n\nThe first steps of using React Query is always to create a queryClient and wrap the application in a <QueryClientProvider>. When doing server rendering, it's important to create the queryClient instance inside of your app, in React state (an instance ref works fine too). This ensures that data is not shared between different users and requests, while still only creating the queryClient once per component lifecycle.\n\nNext.js pages router:\n\ntsx\n// _app.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\n\n// NEVER DO THIS:\n// const queryClient = new QueryClient()\n//\n// Creating the queryClient at the file root level makes the cache shared\n// between all requests and means _all_ data gets passed to _all_ users.\n// Besides being bad for performance, this also leaks any sensitive data.\n\n\nexport default function MyApp({ Component, pageProps }) {\n  // Instead do this, which ensures each request has its own cache:\n  const [queryClient] = React.useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Component {...pageProps} />\n    </QueryClientProvider>\n  )\n}\n\nRemix:\n\ntsx\n// app/root.tsx\nimport { Outlet } from '@remix-run/react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\n\nexport default function MyApp() {\n  const [queryClient] = React.useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Outlet />\n    </QueryClientProvider>\n  )\n}\nGet started fast with initialData\n\nThe quickest way to get started is to not involve React Query at all when it comes to prefetching and not use the dehydrate/hydrate APIs. What you do instead is passing the raw data in as the initialData option to useQuery. Let's look at an example using Next.js pages router, using getServerSideProps.\n\ntsx\nexport async function getServerSideProps() {\n  const posts = await getPosts()\n  return { props: { posts } }\n}\n\n\nfunction Posts(props) {\n  const { data } = useQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n    initialData: props.posts,\n  })\n\n\n  // ...\n}\n\nThis also works with getStaticProps or even the older getInitialProps and the same pattern can be applied in any other framework that has equivalent functions. This is what the same example looks like with Remix:\n\ntsx\nexport async function loader() {\n  const posts = await getPosts()\n  return json({ posts })\n}\n\n\nfunction Posts() {\n  const { posts } = useLoaderData<typeof loader>()\n\n\n  const { data } = useQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n    initialData: posts,\n  })\n\n\n  // ...\n}\n\nThe setup is minimal and this can be a quick solution for some cases, but there are a few tradeoffs to consider when compared to the full approach:\n\nIf you are calling useQuery in a component deeper down in the tree you need to pass the initialData down to that point\nIf you are calling useQuery with the same query in multiple locations, passing initialData to only one of them can be brittle and break when your app changes since. If you remove or move the component that has the useQuery with initialData, the more deeply nested useQuery might no longer have any data. Passing initialData to all queries that needs it can also be cumbersome.\nThere is no way to know at what time the query was fetched on the server, so dataUpdatedAt and determining if the query needs refetching is based on when the page loaded instead\nIf there is already data in the cache for a query, initialData will never overwrite this data, even if the new data is fresher than the old one.\nTo understand why this is especially bad, consider the getServerSideProps example above. If you navigate back and forth to a page several times, getServerSideProps would get called each time and fetch new data, but because we are using the initialData option, the client cache and data would never be updated.\n\nSetting up the full hydration solution is straightforward and does not have these drawbacks, this will be the focus for the rest of the documentation.\n\nUsing the Hydration APIs\n\nWith just a little more setup, you can use a queryClient to prefetch queries during a preload phase, pass a serialized version of that queryClient to the rendering part of the app and reuse it there. This avoid the drawbacks above. Feel free to skip ahead for full Next.js pages router and Remix examples, but at a general level these are the extra steps:\n\nIn the framework loader function, create a const queryClient = new QueryClient(options)\nIn the loader function, do await queryClient.prefetchQuery(...) for each query you want to prefetch\nYou want to use await Promise.all(...) to fetch the queries in parallel when possible\nIt's fine to have queries that aren't prefetched. These wont be server rendered, instead they will be fetched on the client after the application is interactive. This can be great for content that are shown only after user interaction, or is far down on the page to avoid blocking more critical content.\nFrom the loader, return dehydrate(queryClient), note that the exact syntax to return this differs between frameworks\nWrap your tree with <HydrationBoundary state={dehydratedState}> where dehydratedState comes from the framework loader. How you get dehydratedState also differs between frameworks.\nThis can be done for each route, or at the top of the application to avoid boilerplate, see examples\n\nAn interesting detail is that there are actually three queryClients involved. The framework loaders are a form of \"preloading\" phase that happens before rendering, and this phase has it's own queryClient that does the prefetching. The dehydrated result of this phase gets passed to both the server rendering process and the client rendering process which each has it's own queryClient. This ensures they both start with the same data so they can return the same markup.\n\nServer Components are another form of \"preloading\" phase, that can also \"preload\" (pre-render) parts of a React component tree. Read more in the Advanced Server Rendering guide.\n\nFull Next.js pages router example\n\nFor app router documentation, see the Advanced Server Rendering guide.\n\nInitial setup:\n\ntsx\n// _app.tsx\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\n\nexport default function MyApp({ Component, pageProps }) {\n  const [queryClient] = React.useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Component {...pageProps} />\n    </QueryClientProvider>\n  )\n}\n\nIn each route:\n\ntsx\n// pages/posts.jsx\nimport { dehydrate, HydrationBoundary, QueryClient, useQuery } from '@tanstack/react-query'\n\n\n// This could also be getServerSideProps\nexport async function getStaticProps() {\n  const queryClient = new QueryClient()\n\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient),\n    },\n  }\n}\n\n\nfunction Posts() {\n  // This useQuery could just as well happen in some deeper child to\n  // the <PostsRoute>, data will be available immediately either way\n  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n\n  // This query was not prefetched on the server and will not start\n  // fetching until on the client, both patterns are fine to mix\n  const { data: commentsData } = useQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n\n  // ...\n}\n\n\nexport default PostsRoute({ dehydratedState }) {\n  return (\n    <HydrationBoundary state={dehydratedState}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\nFull Remix example\n\nInitial setup:\n\ntsx\n// app/root.tsx\nimport { Outlet } from '@remix-run/react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\n\nexport default function MyApp() {\n  const [queryClient] = React.useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Outlet />\n    </QueryClientProvider>\n  )\n}\n\nIn each route, note that it's fine to do this in nested routes too:\n\ntsx\n// app/routes/posts.tsx\nimport { json } from '@remix-run/node'\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n  useQuery,\n} from '@tanstack/react-query'\n\n\nexport async function loader() {\n  const queryClient = new QueryClient()\n\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n\n  return json({ dehydratedState: dehydrate(queryClient) })\n}\n\n\nfunction Posts() {\n  // This useQuery could just as well happen in some deeper child to\n  // the <PostsRoute>, data will be available immediately either way\n  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n\n  // This query was not prefetched on the server and will not start\n  // fetching until on the client, both patterns are fine to mix\n  const { data: commentsData } = useQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n\n  // ...\n}\n\n\nexport default PostsRoute() {\n  const { dehydratedState } = useLoaderData<typeof loader>();\n  return (\n    <HydrationBoundary state={dehydratedState}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\nOptional - Remove boilerplate\n\nHaving this part in every route might seem like a lot of boilerplate:\n\ntsx\nexport default PostsRoute({ dehydratedState }) {\n  return (\n    <HydrationBoundary state={dehydratedState}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n\nWhile there is nothing wrong with this approach, if you want to get rid of this boilerplate, here's how you can modify your setup in Next.js:\n\ntsx\n// _app.tsx\nimport {\n  HydrationBoundary,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\n\nexport default function MyApp({ Component, pageProps }) {\n  const [queryClient] = React.useState(() => new QueryClient())\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <HydrationBoundary state={pageProps.dehydratedState}>\n        <Component {...pageProps} />\n      </HydrationBoundary>\n    </QueryClientProvider>\n  )\n}\n\n\n// pages/posts.tsx\n// Remove PostsRoute with the HydrationBoundary and instead export Posts directly:\nexport default function Posts() { ... }\n\nWith Remix, this is a little bit more involved, we recommend checking out the use-dehydrated-state package.\n\nPrefetching dependent queries\n\nOver in the Prefetching guide we learned how to prefetch dependent queries, but how do we do this in framework loaders? Consider the following code, taken from the Dependent Queries guide:\n\ntsx\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\n\nconst userId = user?.id\n\n\n// Then get the user's projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\n\nHow would we prefetch this so it can be server rendered? Here's an example:\n\ntsx\n// For Remix, rename this to loader instead\nexport async function getServerSideProps() {\n  const queryClient = new QueryClient()\n\n\n  const user = await queryClient.fetchQuery({\n    queryKey: ['user', email],\n    queryFn: getUserByEmail,\n  })\n\n\n  if (user?.userId) {\n    await queryClient.prefetchQuery({\n      queryKey: ['projects', userId],\n      queryFn: getProjectsByUser,\n    })\n  }\n\n\n  // For Remix:\n  // return json({ dehydratedState: dehydrate(queryClient) })\n  return { props: { dehydratedState: dehydrate(queryClient) } }\n}\n\nThis can get more complex of course, but since these loader functions are just JavaScript, you can use the full power of the language to build your logic. Make sure you prefetch all queries that you want to be server rendered.\n\nError handling\n\nReact Query defaults to a graceful degradation strategy. This means:\n\nqueryClient.prefetchQuery(...) never throws errors\ndehydrate(...) only includes successful queries, not failed ones\n\nThis will lead to any failed queries being retried on the client and that the server rendered output will include loading states instead of the full content.\n\nWhile a good default, sometimes this is not what you want. When critical content is missing, you might want to respond with a 404 or 500 status code depending on the situation. For these cases, use queryClient.fetchQuery(...) instead, which will throw errors when it fails, letting you handle things in a suitable way.\n\ntsx\nlet result\n\n\ntry {\n  result = await queryClient.fetchQuery(...)\n} catch (error) {\n  // Handle the error, refer to your framework documentation\n}\n\n\n// You might also want to check and handle any invalid `result` here\n\nIf you for some reason want to include failed queries in the dehydrated state to avoid retries, you can use the option shouldDehydrateQuery to override the default function and implement your own logic:\n\ntsx\ndehydrate(queryClient, {\n  shouldDehydrateQuery: (query) => {\n    // This will include all queries, including failed ones,\n    // but you can also implement your own logic by inspecting `query`\n    return true\n  },\n})\nSerialization\n\nWhen doing return { props: { dehydratedState: dehydrate(queryClient) } } in Next.js, or return json({ dehydratedState: dehydrate(queryClient) }) in Remix, what happens is that the dehydratedState representation of the queryClient is serialized by the framework so it can be embedded into the markup and transported to the client.\n\nBy default, these frameworks only supports returning things that are safely serializable/parsable, and therefor does not support undefined, Error, Date, Map, Set, BigInt, Infinity, NaN, -0, regular expressions etc. This also means that you can not return any of these things from your queries. If returning these values is something you want, check out superjson or similar packages.\n\nIf you are using a custom SSR setup, you need to take care of this step yourself. Your first instinct might be to use JSON.stringify(dehydratedState), but because this doesn't escape things like <script>alert('Oh no..')</script> by default, this can easily lead to XSS-vulnerabilities in your application. superjson also does not escape values and is unsafe to use by itself in a custom SSR setup (unless you add an extra step for escaping the output). Instead we recommend using a library like Serialize JavaScript or devalue which are both safe against XSS injections out of the box.\n\nA note about request waterfalls\n\nIn the Performance & Request Waterfalls guide we mentioned we would revisit how server rendering changes one of the more complex nested waterfalls. Check back for the specific code example, but as a refresher, we have a code split <GraphFeedItem> component inside a <Feed> component. This only renders if the feed contains a graph item and both of these components fetches their own data. With client rendering, this leads to the following request waterfall:\n\nbash\n1. |> Markup (without content)\n2.   |> JS for <Feed>\n3.     |> getFeed()\n4.       |> JS for <GraphFeedItem>\n5.         |> getGraphDataById()\n\nThe nice thing about server rendering is that we can turn the above into:\n\nbash\n1. |> Markup (with content AND initial data)\n2.   |> JS for <Feed>\n2.   |> JS for <GraphFeedItem>\n\nNote that the queries are no longer fetched on the client, instead their data was included in the markup. The reason we can now load the JS in parallel is that since <GraphFeedItem> was rendered on the server we know that we are going to need this JS on the client as well and can insert a script-tag for this chunk in the markup. On the server, we would still have this request waterfall:\n\nbash\n1. |> getFeed()\n2.   |> getGraphDataById()\n\nWe simply can not know before we have fetched the feed if we also need to fetch graph data, they are dependent queries. Because this happens on the server where latency is generally both lower and more stable, this often isn't such a big deal.\n\nAmazing, we've mostly flattened our waterfalls! There's a catch though. Let's call this page the /feed page, and let's pretend we also have another page like /posts. If we type in www.example.com/feed directly in the url bar and hit enter, we get all these great server rendering benefits, BUT, if we instead type in www.example.com/posts and then click a link to /feed, we're back to to this:\n\nbash\n1. |> JS for <Feed>\n2.   |> getFeed()\n3.     |> JS for <GraphFeedItem>\n4.       |> getGraphDataById()\n\nThis is because with SPA's, server rendering only works for the initial page load, not for any subsequent navigation.\n\nModern frameworks often tries to solve this by fetching the initial code and data in parallel, so if you were using Next.js or Remix with the prefetching patterns we outlined in this guide, including how to prefetch dependent queries, it would actually look like this instead:\n\nbash\n1. |> JS for <Feed>\n1. |> getFeed() + getGraphDataById()\n2.   |> JS for <GraphFeedItem>\n\nThis is much better, but if we want to improve this further we can flatten this to a single roundtrip with Server Components. Learn how in the Advanced Server Rendering guide.\n\nTips, Tricks and Caveats Staleness is measured from when the query was fetched on the server\n\nA query is considered stale depending on when it was dataUpdatedAt. A caveat here is that the server needs to have the correct time for this to work properly, but UTC time is used, so timezones do not factor into this.\n\nBecause staleTime defaults to 0, queries will be refetched in the background on page load by default. You might want to use a higher staleTime to avoid this double fetching, especially if you don't cache your markup.\n\nThis refetching of stale queries is a perfect match when caching markup in a CDN! You can set the cache time of the page itself decently high to avoid having to re-render pages on the server, but configure the staleTime of the queries lower to make sure data is refetched in the background as soon as a user visits the page. Maybe you want to cache the pages for a week, but refetch the data automatically on page load if it's older than a day?\n\nHigh memory consumption on server\n\nIn case you are creating the QueryClient for every request, React Query creates the isolated cache for this client, which is preserved in memory for the gcTime period. That may lead to high memory consumption on server in case of high number of requests during that period.\n\nOn the server, gcTime defaults to Infinity which disables manual garbage collection and will automatically clear memory once a request has finished. If you are explicitly setting a non-Infinity gcTime then you will be responsible for clearing the cache early.\n\nTo clear the cache after it is not needed and to lower memory consumption, you can add a call to queryClient.clear() after the request is handled and dehydrated state has been sent to the client.\n\nAlternatively, you can set a smaller gcTime.\n\nCaveat for Next.js rewrites\n\nThere's a catch if you're using Next.js' rewrites feature together with Automatic Static Optimization or getStaticProps: It will cause a second hydration by React Query. That's because Next.js needs to ensure that they parse the rewrites on the client and collect any params after hydration so that they can be provided in router.query.\n\nThe result is missing referential equality for all the hydration data, which for example triggers wherever your data is used as props of components or in the dependency array of useEffects/useMemos.\n"
  },
  {
    "title": "Advanced Server Rendering | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/advanced-ssr",
    "html": "Advanced Server Rendering\n\nWelcome to the Advanced Server Rendering guide, where you will learn all about using React Query with streaming, Server Components and the Next.js app router.\n\nYou might want to read the Server Rendering & Hydration guide before this one as it teaches the basics for using React Query with SSR, and Performance & Request Waterfalls as well as Prefetching & Router Integration also contains valuable background.\n\nBefore we start, let's note that while the initialData approach outlined in the SSR guide also works with Server Components, we'll focus this guide on the hydration APIs.\n\nServer Components & Next.js app router\n\nWe won't cover Server Components in depth here, but the short version is that they are components that are guaranteed to only run on the server, both for the initial page view and also on page transitions. This is similar to how Next.js getServerSideProps/getStaticProps and Remix loader works, as these also always run on the server but while those can only return data, Server Components can do a lot more. The data part is central to React Query however, so let's focus on that.\n\nHow do we take what we learned in the Server Rendering guide about passing data prefetched in framework loaders to the app and apply that to Server Components and the Next.js app router? The best way to start thinking about this is to consider Server Components as \"just\" another framework loader.\n\nA quick note on terminology\n\nSo far in these guides, we've been talking about the server and the client. It's important to note that confusingly enough this does not match 1-1 with Server Components and Client Components. Server Components are guaranteed to only run on the server, but Client Components can actually run in both places. The reason for this is that they can also render during the initial server rendering pass.\n\nOne way to think of this is that even though Server Components also render, they happen during a \"loader phase\" (always happens on the server), while Client Components run during the \"application phase\". That application can run both on the server during SSR, and in for example a browser. Where exactly that application runs and if it runs during SSR or not might differ between frameworks.\n\nInitial setup\n\nThe first step of any React Query setup is always to create a queryClient and wrap your application in a QueryClientProvider. With Server Components, this looks mostly the same across frameworks, one difference being the filename conventions:\n\ntsx\n// In Next.js, this file would be called: app/providers.jsx\n'use client'\n\n\n// We can not useState or useRef in a server component, which is why we are\n// extracting this part out into it's own file with 'use client' on top\nimport { useState } from 'react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\n\n\nexport default function Providers({ children }) {\n  const [queryClient] = useState(\n    () =>\n      new QueryClient({\n        defaultOptions: {\n          queries: {\n            // With SSR, we usually want to set some default staleTime\n            // above 0 to avoid refetching immediately on the client\n            staleTime: 60 * 1000,\n          },\n        },\n      }),\n  )\n\n\n  return (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  )\n}\ntsx\n// In Next.js, this file would be called: app/layout.jsx\nimport Providers from './providers'\n\n\nexport default function RootLayout({ children }) {\n  return (\n    <html lang=\"en\">\n      <head />\n      <body>\n        <Providers>{children}</Providers>\n      </body>\n    </html>\n  )\n}\n\nThis part is pretty similar to what we did in the SSR guide, we just need to split things up into two different files.\n\nPrefetching and de/hydrating data\n\nLet's next look at how to actually prefetch data and dehydrate and hydrate it. This is what it looked like using the Next.js pages router:\n\ntsx\n// pages/posts.jsx\nimport { dehydrate, HydrationBoundary, QueryClient, useQuery } from '@tanstack/react-query'\n\n\n// This could also be getServerSideProps\nexport async function getStaticProps() {\n  const queryClient = new QueryClient()\n\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient),\n    },\n  }\n}\n\n\nfunction Posts() {\n  // This useQuery could just as well happen in some deeper child to\n  // the <PostsRoute>, data will be available immediately either way\n  //\n  // Note that we are using useQuery here instead of useSuspenseQuery.\n  // Because this data has already been prefetched, there is no need to\n  // ever suspend in the component itself. If we forget or remove the\n  // prefetch, this will instead fetch the data on the client, while\n  // using useSuspenseQuery would have had worse side effects.\n  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n\n  // This query was not prefetched on the server and will not start\n  // fetching until on the client, both patterns are fine to mix\n  const { data: commentsData } = useQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n\n  // ...\n}\n\n\nexport default PostsRoute({ dehydratedState }) {\n  return (\n    <HydrationBoundary state={dehydratedState}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n\nConverting this to the app router actually looks pretty similar, we just need to move things around a bit. First, we'll create a Server Component to do the prefetching part:\n\ntsx\n// app/posts/page.jsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Posts from './posts'\n\n\nexport default async function PostsPage() {\n  const queryClient = new QueryClient()\n\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n\n  return (\n    // Neat! Serialization is now as easy as passing props.\n    // HydrationBoundary is a Client Component, so hydration will happen there.\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n\nNext, we'll look at what the Client Component part looks like:\n\ntsx\n// app/posts/posts.jsx\n'use client'\n\n\nexport default function Posts() {\n  // This useQuery could just as well happen in some deeper\n  // child to <Posts>, data will be available immediately either way\n  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })\n\n\n  // This query was not prefetched on the server and will not start\n  // fetching until on the client, both patterns are fine to mix.\n  const { data: commentsData } = useQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n\n  // ...\n}\n\nOne neat thing about the examples above is that the only thing that is Next.js-specific here are the file names, everything else would look the same in any other framework that supports Server Components.\n\nIn the SSR guide, we noted that you could get rid of the boilerplate of having <HydrationBoundary> in every route. This is not possible with Server Components.\n\nNOTE: If you encounter a type error while using async Server Components with TypeScript versions lower than 5.1.3 and @types/react versions lower than 18.2.8, it is recommended to update to the latest versions of both. Alternatively, you can use the temporary workaround of adding {/* @ts-expect-error Server Component */} when calling this component inside another. For more information, see Async Server Component TypeScript Error in the Next.js 13 docs.\n\nNesting Server Components\n\nA nice thing about Server Components is that they can be nested and exist on many levels in the React tree, making it possible to prefetch data closer to where it's actually used instead of only at the top of the application (just like Remix loaders). This can be as simple as a Server Component rendering another Server Component (we'll leave the Client Components out in this example for brevity):\n\ntsx\n// app/posts/page.jsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Posts from './posts'\nimport CommentsServerComponent from './comments-server'\n\n\nexport default async function PostsPage() {\n  const queryClient = new QueryClient()\n\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Posts />\n      <CommentsServerComponent />\n    </HydrationBoundary>\n  )\n}\n\n\n// app/posts/comments-server.jsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Comments from './comments'\n\n\nexport default async function CommentsServerComponent() {\n  const queryClient = new QueryClient()\n\n\n  await queryClient.prefetchQuery({\n    queryKey: ['posts-comments'],\n    queryFn: getComments,\n  })\n\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <Comments />\n    </HydrationBoundary>\n  )\n}\n\nAs you can see, it's perfectly fine to use <HydrationBoundary> in multiple places, and create and dehydrate multiple queryClient for prefetching.\n\nNote that because we are awaiting getPosts before rendering CommentsServerComponent this would lead to a server side waterfall:\n\nbash\n1. |> getPosts()\n2.   |> getComments()\n\nIf the server latency to the data is low, this might not be a huge issue, but is still worth pointing out.\n\nIn Next.js, besides prefetching data in page.tsx, you can also do it in layout.tsx, and in parallel routes. Because these are all part of the routing, Next.js knows how to fetch them all in parallel. So if CommentsServerComponent above was instead expressed as a parallel route, the waterfall would be flattened automatically.\n\nAs more frameworks start supporting Server Components, they might have other routing conventions. Read your framework docs for details.\n\nAlternative: Use a single queryClient for prefetching\n\nIn the example above, we create a new queryClient for each Server Component that fetches data. This is the recommended approach, but if you want to, you can alternatively create a single one that is reused across all Server Components:\n\ntsx\n// app/getQueryClient.jsx\nimport { QueryClient } from '@tanstack/react-query'\nimport { cache } from 'react'\n\n\n// cache() is scoped per request, so we don't leak data between requests\nconst getQueryClient = cache(() => new QueryClient())\nexport default getQueryClient\n\nThe benefit of this is that you can call getQueryClient() to get a hold of this client anywhere that gets called from a Server Component, including utility functions. The downside is that every time you call dehydrate(getQueryClient()), you serialize the entire queryClient, including queries that have already been serialized before and are unrelated to the current Server Component which is unnecessary overhead.\n\nNext.js already dedupes requests that utilize fetch(), but if you are using something else in your queryFn, or if you use a framework that does not dedupe these requests automatically, using a single queryClient as described above might make sense, despite the duplicated serialization.\n\nAs a future improvement, we might look into creating a dehydrateNew() function (name pending) that only dehydrate queries that are new since the last call to dehydrateNew(). Feel free to get in touch if this sounds interesting and like something you want to help out with!\n\nData ownership and revalidation\n\nWith Server Components, it's important to think about data ownership and revalidation. To explain why, let's look at a modified example from above:\n\ntsx\n// app/posts/page.jsx\nimport {\n  dehydrate,\n  HydrationBoundary,\n  QueryClient,\n} from '@tanstack/react-query'\nimport Posts from './posts'\n\n\nexport default async function PostsPage() {\n  const queryClient = new QueryClient()\n\n\n  // Note we are now using fetchQuery()\n  const posts = await queryClient.fetchQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n  })\n\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      {/* This is the new part */}\n      <div>Nr of posts: {posts.length}</div>\n      <Posts />\n    </HydrationBoundary>\n  )\n}\n\nWe are now rendering data from the getPosts query both in a Server Component and in a Client Component. This will be fine for the initial page render, but what happens when the query revalidates on the client for some reason when staleTime has been passed?\n\nReact Query has no idea of how to revalidate the Server Component, so if it refetches the data on the client, causing React to rerender the list of posts, the Nr of posts: {posts.length} will end up out of sync.\n\nThis is fine if you set staleTime: Infinity, so that React Query never revalidates, but this is probably not what you want if you are using React Query in the first place.\n\nUsing React Query with Server Components makes most sense if:\n\nYou have an app using React Query and want to migrate to Server Components without rewriting all the data fetching\nYou want a familiar programming paradigm, but want to still sprinkle in the benefits of Server Components where it makes most sense\nYou have some use case that React Query covers, but that your framework of choice does not cover\n\nIt's hard to give general advice on when it makes sense to pair React Query with Server Components and not. If you are just starting out with a new Server Components app, we suggest you start out with any tools for data fetching your framework provides you with and avoid bringing in React Query until you actually need it. This might be never, and that's fine, use the right tool for the job!\n\nIf you do use it, a good rule of thumb is to avoid queryClient.fetchQuery unless you need to catch errors. If you do use it, don't render its result on the server or pass the result to another component, even a Client Component one.\n\nFrom the React Query perspective, treat Server Components as a place to prefetch data, nothing more.\n\nOf course, it's fine to have Server Components own some data, and Client Components own other, just make sure those two realities don't get out of sync.\n\nStreaming with Server Components\n\nThe Next.js app router automatically streams any part of the application that is ready to be displayed to the browser as soon as possible, so finished content can be displayed immediately without waiting for still pending content. It does this along <Suspense> boundary lines. Note that if you create a file loading.tsx, this automatically creates a <Suspense> boundary behind the scenes.\n\nWith the prefetching patterns described above, React Query is perfectly compatible with this form of streaming. As the data for each Suspense boundary resolves, Next.js can render and stream the finished content to the browser. This works even if you are using useQuery as outlined above because the suspending actually happens when you await the prefetch.\n\nNote that right now, you have to await all prefetches for this to work. This means all prefetches are considered critical content and will block that Suspense boundary.\n\nAs an aside, in the future it might be possible to skip the await for \"optional\" prefetches that are not critical for this Suspense boundary. This would let you kick off prefetches as early as possible without letting them block an entire Suspense boundary, and streaming the data to the client as the query finishes. This could be useful for example if you want to prefetch some content that is only visible after some user interaction, or say if you want to await and render the first page of an infinite query, but start prefetching page 2 without blocking rendering.\n\nExperimental streaming without prefetching in Next.js\n\nWhile we recommend the prefetching solution detailed above because it flattens request waterfalls both on the initial page load and any subsequent page navigation, there is an experimental way to skip prefetching altogether and still have streaming SSR work: @tanstack/react-query-next-experimental\n\nThis package will allow you to fetch data on the server (in a Client Component) by just calling useSuspenseQuery in your component. Results will then be streamed from the server to the client as SuspenseBoundaries resolve. Note that all calls to useSuspenseQuery must be wrapped in a <Suspense> boundary somewhere further up the tree to work.\n\nTo achieve this, wrap your app in the ReactQueryStreamedHydration component:\n\ntsx\n// app/providers.tsx\n'use client'\n\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport * as React from 'react'\nimport { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'\n\n\nexport function Providers(props: { children: React.ReactNode }) {\n  const [queryClient] = React.useState(() => new QueryClient())\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <ReactQueryStreamedHydration>\n        {props.children}\n      </ReactQueryStreamedHydration>\n    </QueryClientProvider>\n  )\n}\n\nFor more information, check out the NextJs Suspense Streaming Example.\n\nThe big upside is that you no longer need to prefetch queries manually to have SSR work, and it even still streams in the result! This gives you phenomenal DX and lower code complexity.\n\nThe downside is easiest to explain if we look back at the complex request waterfall example in the Performance & Request Waterfalls guide. Server Components with prefetching effectively eliminates the request waterfalls both for the initial page load and any subsequent navigation. This prefetch-less approach however will only flatten the waterfalls on the initial page load but ends up the same deep waterfall as the original example on page navigations:\n\nbash\n1. |> JS for <Feed>\n2.   |> getFeed()\n3.     |> JS for <GraphFeedItem>\n4.       |> getGraphDataById()\n\nThis is even worse than with getServerSideProps/getStaticProps, since with those we could at least parallelize data- and code-fetching.\n\nIf you value DX, iteration/shipping speed and low code complexity over performance, or don't have deeply nested queries and you know you are on top of your request waterfalls anyway, this can be a good tradeoff.\n\nIt might be possible to combine the two approaches, but even we haven't tried that out yet. If you do try this, please report back your findings, or even update these docs with some tips!\n\nFinal words\n\nServer Components and streaming are still fairly new concepts and we are still figuring out how React Query fits in and what improvements we can make to the API. We welcome suggestions, feedback and bug reports!\n\nSimilarly, it would be impossible to teach all the intricacies of this new paradigm all in one guide, on the first try. If you are missing some piece of information here or have suggestions on how to improve this content, also get in touch, or even better, click the \"Edit on GitHub\" button below and help us out.\n"
  },
  {
    "title": "Prefetching & Router Integration | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/prefetching",
    "html": "Prefetching & Router Integration\n\nWhen you know or suspect that a certain piece of data will be needed, you can use prefetching to populate the cache with that data ahead of time, leading to a faster experience.\n\nThere are a few different prefetching patterns:\n\nIn event handlers\nIn components\nVia router integration\nDuring Server Rendering (another form of router integration)\n\nIn this guide, we'll take a look at the first three, while the fourth will be covered in depth in the Server Rendering & Hydration guide and the Advanced Server Rendering guide.\n\nOne specific use of prefetching is to avoid Request Waterfalls, for an in-depth background and explanation of those, see the Performance & Request Waterfalls guide.\n\nprefetchQuery & prefetchInfiniteQuery\n\nBefore jumping into the different specific prefetch patterns, let's look at the prefetchQuery and prefetchInfiniteQuery functions. First a few basics:\n\nOut of the box, these functions use the default staleTime configured for the queryClient to determine wether existing data in the cache is fresh or needs to be fetched again\nYou can also pass a specific staleTime like this: prefetchQuery({ queryKey: ['todos'], queryFn: fn, staleTime: 5000 })\nThis staleTime is only used for the prefetch, you still need to set it for any useQuery call as well\nIf you want to ignore staleTime and instead always return data if it's available in the cache, you can use the ensureQueryData function.\nTip: If you are prefetching on the server, set a default staleTime higher than 0 for that queryClient to avoid having to pass in a specific staleTime to each prefetch call\nIf no instances of useQuery appear for a prefetched query, it will be deleted and garbage collected after the time specified in gcTime\nThese functions returns Promise<void> and thus never return query data. If that's something you need, use fetchQuery/fetchInfiniteQuery instead.\nThe prefetch functions never throws errors because they usually try to fetch again in a useQuery which is a nice graceful fallback. If you need to catch errors, use fetchQuery/fetchInfiniteQuery instead.\n\nThis is how you use prefetchQuery:\n\ntsx\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n}\n\nInfinite Queries can be prefetched like regular Queries. Per default, only the first page of the Query will be prefetched and will be stored under the given QueryKey. If you want to prefetch more than one page, you can use the pages option, in which case you also have to provide a getNextPageParam function:\n\ntsx\nconst prefetchTodos = async () => {\n  // The results of this query will be cached like a normal query\n  await queryClient.prefetchInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n    pages: 3, // prefetch the first 3 pages\n  })\n}\n\nNext, let's look at how you can use these and other ways to prefetch in different situations.\n\nPrefetch in event handlers\n\nA straightforward form of prefetching is doing it when the user interacts with something. In this example we'll use queryClient.prefetchQuery to start a prefetch on onMouseEnter or onFocus.\n\ntsx\nfunction ShowDetailsButton() {\n  const queryClient = useQueryClient()\n\n\n  const prefetch = () => {\n    queryClient.prefetchQuery({\n      queryKey: ['details'],\n      queryFn: getDetailsData,\n      // Prefetch only fires when data is older than the staleTime,\n      // so in a case like this you definitely want to set one\n      staleTime: 60000,\n    })\n  }\n\n\n  return (\n    <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>\n      Show Details\n    </button>\n  )\n}\nPrefetch in components\n\nPrefetching during the component lifecycle is useful when we know some child or descendant will need a particular piece of data, but we can't render that until some other query has finished loading. Let's borrow an example from the Request Waterfall guide to explain:\n\ntsx\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n\n  ...\n}\n\nThis results in a request waterfall looking like this:\n\nbash\n1. |> getArticleById()\n2.   |> getArticleCommentsById()\n\nAs mentioned in that guide, one way to flatten this waterfall and improve performance is to hoist the getArticleCommentsById query to the parent and pass down the result as a prop, but what if this is not feasible or desirable, for example when the components are unrelated and have multiple levels between them?\n\nIn that case, we can instead prefetch the query in the parent. The simplest way to do this is to use a query but ignore the result:\n\ntsx\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n\n  // Prefetch\n  useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n    // Optional optimization to avoid rerenders when this query changes:\n    notifyOnChangeProps: [],\n  })\n\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n}\n\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n\n  ...\n}\n\nThis starts fetching 'article-comments' immediately and flattens the waterfall:\n\nbash\n1. |> getArticleById()\n1. |> getArticleCommentsById()\n\nIf you want to prefetch together with Suspense, you will have to do things a bit differently. You can't use useSuspenseQueries to prefetch, since the prefetch would block the component from rendering. You also can not use useQuery for the prefetch, because that wouldn't start the prefetch until after suspenseful query had resolved. What you can do is add a small usePrefetchQuery function (we might add this to the library itself at a later point):\n\ntsx\nconst usePrefetchQuery = (...args) => {\n  const queryClient = useQueryClient()\n\n\n  // This happens in render, but is safe to do because ensureQueryData\n  // only fetches if there is no data in the cache for this query. This\n  // means we know no observers are watching the data so the side effect\n  // is not observable, which is safe.\n  queryClient.ensureQueryData(...args)\n}\n\nThis approach works with both useQuery and useSuspenseQuery, so feel free to use it as an alternative to the useQuery({ ..., notifyOnChangeProps: [] }) approach as well. The only tradeoff is that the above function will never fetch and update existing data in the cache if it's stale, but this will usually happen in the later query anyway.\n\nYou can now use useSuspenseQuery in the component that actually needs the data. You might want to wrap this later component in its own <Suspense> boundary so the \"secondary\" query we are prefetching does not block rendering of the \"primary\" data.\n\ntsx\n// Prefetch\nusePrefetchQuery({\n  queryKey: ['article-comments', id],\n  queryFn: getArticleCommentsById,\n})\n\n\nconst { data: articleResult } = useSuspenseQuery({\n  queryKey: ['article', id],\n  queryFn: getArticleById,\n})\n\n\n// In nested component:\nconst { data: commentsResult } = useSuspenseQuery({\n  queryKey: ['article-comments', id],\n  queryFn: getArticleCommentsById,\n})\n\nAnother way is to prefetch inside of the query function. This makes sense if you know that every time an article is fetched it's very likely comments will also be needed. For this, we'll use queryClient.prefetchQuery:\n\ntsx\nconst queryClient = useQueryClient()\nconst { data: articleData, isPending } = useQuery({\n  queryKey: ['article', id],\n  queryFn: (...args) => {\n    queryClient.prefetchQuery({\n      queryKey: ['article-comments', id],\n      queryFn: getArticleCommentsById,\n    })\n\n\n    return getArticleById(...args)\n  },\n})\n\nPrefetching in an effect also works, but note that if you are using useSuspenseQuery in the same component, this effect wont run until after the query finishes which might not be what you want.\n\ntsx\nconst queryClient = useQueryClient()\n\n\nuseEffect(() => {\n  queryClient.prefetchQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n}, [queryClient, id])\n\nTo recap, if you want to prefetch a query during the component lifecycle, there are a few different ways to do it, pick the one that suits your situation best:\n\nUse useQuery or useSuspenseQueries and ignore the result\nPrefetch inside the query function\nPrefetch in an effect\n\nLet's look at a slightly more advanced case next.\n\nDependent Queries & Code Splitting\n\nSometimes we want to prefetch conditionally, based on the result of another fetch. Consider this example borrowed from the Performance & Request Waterfalls guide:\n\ntsx\n// This lazy loads the GraphFeedItem component, meaning\n// it wont start loading until something renders it\nconst GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))\n\n\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\n\n// GraphFeedItem.tsx\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n\n  ...\n}\n\nAs noted over in that guide, this example leads to the following double request waterfall:\n\nbash\n1. |> getFeed()\n2.   |> JS for <GraphFeedItem>\n3.     |> getGraphDataById()\n\nIf we can not restructure our API so getFeed() also returns the getGraphDataById() data when necessary, there is no way to get rid of the getFeed->getGraphDataById waterfall, but by leveraging conditional prefetching, we can at least load the code and data in parallel. Just like described above, there are multiple ways to do this, but for this example, we'll do it in the query function:\n\ntsx\nfunction Feed() {\n  const queryClient = useQueryClient()\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: async (...args) => {\n      const feed = await getFeed(...args)\n\n\n      for (const feedItem of feed) {\n        if (feedItem.type === 'GRAPH') {\n          queryClient.prefetchQuery({\n            queryKey: ['graph', feedItem.id],\n            queryFn: getGraphDataById,\n          })\n        }\n      }\n\n\n      return feed\n    }\n  })\n\n\n  ...\n}\n\nThis would load the code and data in parallel:\n\nbash\n1. |> getFeed()\n2.   |> JS for <GraphFeedItem>\n2.   |> getGraphDataById()\n\nThere is a tradeoff however, in that the code for getGraphDataById is now included in the parent bundle instead of in JS for <GraphFeedItem> so you'll need to determine what's the best performance tradeoff on a case by case basis. If GraphFeedItem are likely, it's probably worth to include the code in the parent. If they are exceedingly rare, it's probably not.\n\nRouter Integration\n\nBecause data fetching in the component tree itself can easily lead to request waterfalls and the different fixes for that can be cumbersome as they accumulate throughout the application, an attractive way to do prefetching is integrating it at the router level.\n\nIn this approach, you explicitly declare for each route what data is going to be needed for that component tree, ahead of time. Because Server Rendering has traditionally needed all data to be loaded before rendering starts, this has been the dominating approach for SSR'd apps for a long time. This is still a common approach and you can read more about it in the Server Rendering & Hydration guide.\n\nFor now, let's focus on the client side case and look at an example of how you can make this work with Tanstack Router. These examples leave out a lot of setup and boilerplate to stay concise, you can check out a full React Query example over in the Tanstack Router docs.\n\nWhen integrating at the router level, you can choose to either block rendering of that route until all data is present, or you can start a prefetch but not await the result. That way, you can start rendering the route as soon as possible. You can also mix these two approaches and await some critical data, but start rendering before all the secondary data has finished loading. In this example, we'll configure an /article route to not render until the article data has finished loading, as well as start prefetching comments as soon as possible, but not block rendering the route if comments haven't finished loading yet.\n\ntsx\nconst queryClient = new QueryClient()\nconst routerContext = new RouterContext()\nconst rootRoute = routerContext.createRootRoute({\n  component: () => { ... }\n})\n\n\nconst articleRoute = new Route({\n  getParentRoute: () => rootRoute,\n  path: 'article',\n  beforeLoad: () => {\n    return {\n      articleQueryOptions: { queryKey: ['article'], queryFn: fetchArticle },\n      commentsQueryOptions: { queryKey: ['comments'], queryFn: fetchComments },\n    }\n  },\n  loader: async ({\n    context: { queryClient },\n    routeContext: { articleQueryOptions, commentsQueryOptions },\n  }) => {\n    // Fetch comments asap, but don't block\n    queryClient.prefetchQuery(commentsQueryOptions)\n\n\n    // Don't render the route at all until article has been fetched\n    await queryClient.prefetchQuery(articleQueryOptions)\n  },\n  component: ({ useRouteContext }) => {\n    const { articleQueryOptions, commentsQueryOptions } = useRouteContext()\n    const articleQuery = useQuery(articleQueryOptions)\n    const commentsQuery = useQuery(commentsQueryOptions)\n\n\n    return (\n      ...\n    )\n  },\n  errorComponent: () => 'Oh crap!',\n})\n\nIntegration with other routers is also possible, see the React Router example for another demonstration.\n\nManually Priming a Query\n\nIf you already have the data for your query synchronously available, you don't need to prefetch it. You can just use the Query Client's setQueryData method to directly add or update a query's cached result by key.\n\ntsx\nqueryClient.setQueryData(['todos'], todos)\nFurther reading\n\nFor a deep-dive on how to get data into your Query Cache before you fetch, have a look at #17: Seeding the Query Cache from the Community Resources.\n\nIntegrating with Server Side routers and frameworks is very similar to what we just saw, with the addition that the data has to passed from the server to the client to be hydrated into the cache there. To learn how, continue on to the Server Rendering & Hydration guide.\n"
  },
  {
    "title": "Performance & Request Waterfalls | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/request-waterfalls",
    "html": "Performance & Request Waterfalls\n\nApplication performance is a broad and complex area and while React Query can't make your APIs faster, there are still things to be mindful about in how you use React Query to ensure the best performance.\n\nThe biggest performance footgun when using React Query, or indeed any data fetching library that lets you fetch data inside of components, is request waterfalls. The rest of this page will explain what they are, how you can spot them and how you can restructure your application or APIs to avoid them.\n\nThe Prefetching & Router Integration guide builds on this and teaches you how to prefetch data ahead of time when it's not possible or feasible to restructure your application or APIs.\n\nThe Server Rendering & Hydration guide teaches you how to prefetch data on the server and pass that data down to the client so you don't have to fetch it again.\n\nThe Advanced Server Rendering guide further teaches you how to apply these patterns to Server Components and Streaming Server Rendering.\n\nWhat is a Request Waterfall?\n\nA request waterfall is what happens when a request for a resource (code, css, images, data) does not start until after another request for a resource has finished.\n\nConsider a web page. Before you can load things like the CSS, JS etc, the browser first needs to load the markup. This is a request waterfall.\n\nbash\n1. |-> Markup\n2.   |-> CSS\n2.   |-> JS\n2.   |-> Image\n\nIf you fetch your CSS inside a JS file, you now have a double waterfall:\n\nbash\n1. |-> Markup\n2.   |-> JS\n3.     |-> CSS\n\nIf that CSS uses a background image, it's a triple waterfall:\n\nbash\n1. |-> Markup\n2.   |-> JS\n3.     |-> CSS\n4.       |-> Image\n\nThe best way to spot and analyze your request waterfalls is usually by opening your browsers devtools \"Network\" tab.\n\nEach waterfall represents at least one roundtrip to the server, unless the resource is locally cached (in practice, some of these waterfalls might represent more than one roundtrip because the browser needs to establish a connection which requires some back and forth, but let's ignore that here). Because of this, the negative effects of request waterfalls are highly dependent on the users latency. Consider the example of the triple waterfall, which actually represents 4 server roundtrips. With 250ms latency, which is not uncommon on 3g networks or in bad network conditions, we end up with a total time of 4*250=1000ms only counting latency. If we were able to flatten that to the first example with only 2 roundtrips, we get 500ms instead, possibly loading that background image in half the time!\n\nRequest Waterfalls & React Query\n\nNow let's consider React Query. We'll focus on the case without Server Rendering first. Before we can even start making a query, we need to load the JS, so before we can show that data on the screen, we have a double waterfall:\n\nbash\n1. |-> Markup\n2.   |-> JS\n3.     |-> Query\n\nWith this as a basis, let's look at a few different patterns that can lead to Request Waterfalls in React Query, and how to avoid them.\n\nSingle Component Waterfalls / Serial Queries\nNested Component Waterfalls\nCode Splitting\nSingle Component Waterfalls / Serial Queries\n\nWhen a single component first fetches one query, and then another, that's a request waterfall. This can happen when the second query is a Dependent Query, that is, it depends on data from the first query when fetching:\n\ntsx\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\n\nconst userId = user?.id\n\n\n// Then get the user's projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\n\nWhile not always feasible, for optimal performance it's better to restructure your API so you can fetch both of these in a single query. In the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.\n\nAnother way to mitigate dependent queries without restructuring your API is to move the waterfall to the server where latency is lower. This is the idea behind Server Components which are covered in the Advanced Server Rendering guide.\n\nAnother example of serial queries is when you use React Query with Suspense:\n\ntsx\nfunction App () {\n  // The following queries will execute in serial, causing separate roundtrips to the server:\n  const usersQuery = useSuspenseQuery({ queryKey: ['users'], queryFn: fetchUsers })\n  const teamsQuery = useSuspenseQuery({ queryKey: ['teams'], queryFn: fetchTeams })\n  const projectsQuery = useSuspenseQuery({ queryKey: ['projects'], queryFn: fetchProjects })\n\n\n  // Note that since the queries above suspend rendering, no data\n  // gets rendered until all of the queries finished\n  ...\n}\n\nNote that with regular useQuery these would happen in parallel.\n\nLuckily, this is easy to fix, by always using the hook useSuspenseQueries when you have multiple suspenseful queries in a component.\n\ntsx\nconst [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({\n  queries: [\n    { queryKey: ['users'], queryFn: fetchUsers },\n    { queryKey: ['teams'], queryFn: fetchTeams },\n    { queryKey: ['projects'], queryFn: fetchProjects },\n  ]\n}\nNested Component Waterfalls\n\nNested Component Waterfalls is when both a parent and a child component contains queries, and the parent does not render the child until its query is done. This can happen both with useQuery and useSuspenseQuery.\n\nIf the child renders conditionally based on the data in the parent, or if the child relies on some part of the result being passed down as a prop from the parent to make its query, we have a dependent nested component waterfall.\n\nLet's first look at an example where the child is not dependent on the parent.\n\ntsx\nfunction Article({ id }) {\n  const { data: articleData, isPending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n\n  if (isPending) {\n    return 'Loading article...'\n  }\n\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      <Comments id={id} />\n    </>\n  )\n\n\n}\n\n\nfunction Comments({ id }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n\n  ...\n}\n\nNote that while <Comments> takes a prop id from the parent, that id is already available when the <Article> renders so there is no reason we could not fetch the comments at the same time as the article. In real world applications, the child might be nested far below the parent and these kinds of waterfalls are often trickier to spot and fix, but for our example, one way to flatten the waterfall would be to hoist the comments query to the parent instead:\n\ntsx\nfunction Article({ id }) {\n  const { data: articleData, isPending: articlePending } = useQuery({\n    queryKey: ['article', id],\n    queryFn: getArticleById,\n  })\n\n\n  const { data: commentsData, isPending: commentsPending } = useQuery({\n    queryKey: ['article-comments', id],\n    queryFn: getArticleCommentsById,\n  })\n\n\n  if (articlePending) {\n    return 'Loading article...'\n  }\n\n\n  return (\n    <>\n      <ArticleHeader articleData={articleData} />\n      <ArticleBody articleData={articleData} />\n      {commentsPending ? (\n        'Loading comments...'\n      ) : (\n        <Comments commentsData={commentsData} />\n      )}\n    </>\n  )\n}\n\nThe two queries will now fetch in parallel. Note that if you are using suspense, you'd want to combine these two queries into a single useSuspenseQueries instead.\n\nAnother way to flatten this waterfall would be to prefetch the comments in the <Article> component, or prefetch both of these queries at the router level on page load or page navigation, read more about this in the Prefetching & Router Integration guide.\n\nNext, let's look at a Dependent Nested Component Waterfall.\n\ntsx\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\n\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n\n  ...\n}\n\nThe second query getGraphDataById is dependent on it's parent in two different ways. First of all, it doesn't ever happen unless the feedItem is a graph, and second, it needs an id from the parent.\n\nbash\n1. |> getFeed()\n2.   |> getGraphDataById()\n\nIn this example, we can't trivially flatten the waterfall by just hoisting the query to the parent, or even adding prefetching. Just like the dependent query example at the beginning of this guide, one option is to refactor our API to include the graph data in the getFeed query. Another more advanced solution is to leverage Server Components to move the waterfall to the server where latency is lower (read more about this in the Advanced Server Rendering guide) but note that this can be a very big architectural change.\n\nYou can have good performance even with a few query waterfalls here and there, just know they are a common performance concern and be mindful about them. An especially insidious version is when Code Splitting is involved, let's take a look at this next.\n\nCode Splitting\n\nSplitting an applications JS-code into smaller chunks and only loading the necessary parts is usually a critical step in achieving good performance. It does have a downside however, in that it often introduces request waterfalls. When that code split code also has a query inside it, this problem is worsened further.\n\nConsider this a slightly modified version of the Feed example.\n\ntsx\n// This lazy loads the GraphFeedItem component, meaning\n// it wont start loading until something renders it\nconst GraphFeedItem = React.lazy(() => import('./GraphFeedItem'))\n\n\nfunction Feed() {\n  const { data, isPending } = useQuery({\n    queryKey: ['feed'],\n    queryFn: getFeed,\n  })\n\n\n  if (isPending) {\n    return 'Loading feed...'\n  }\n\n\n  return (\n    <>\n      {data.map((feedItem) => {\n        if (feedItem.type === 'GRAPH') {\n          return <GraphFeedItem key={feedItem.id} feedItem={feedItem} />\n        }\n\n\n        return <StandardFeedItem key={feedItem.id} feedItem={feedItem} />\n      })}\n    </>\n  )\n}\n\n\n// GraphFeedItem.tsx\nfunction GraphFeedItem({ feedItem }) {\n  const { data, isPending } = useQuery({\n    queryKey: ['graph', feedItem.id],\n    queryFn: getGraphDataById,\n  })\n\n\n  ...\n}\n\nThis example has a double waterfall, looking like this:\n\nbash\n1. |> getFeed()\n2.   |> JS for <GraphFeedItem>\n3.     |> getGraphDataById()\n\nBut that's just looking at the code from the example, if we consider what the first page load of this page looks like, we actually have to complete 5 round trips to the server before we can render the graph!\n\nbash\n1. |> Markup\n2.   |> JS for <Feed>\n3.     |> getFeed()\n4.       |> JS for <GraphFeedItem>\n5.         |> getGraphDataById()\n\nNote that this looks a bit different when server rendering, we will explore that further in the Server Rendering & Hydration guide. Also note that it's not uncommon for the route that contains <Feed> to also be code split, which could add yet another hop.\n\nIn the code split case, it might actually help to hoist the getGraphDataById query to the <Feed> component and make it conditional, or add a conditional prefetch. That query could then be fetched in parallel with the code, turning the example part into this:\n\nbash\n1. |> getFeed()\n2.   |> getGraphDataById()\n2.   |> JS for <GraphFeedItem>\n\nThis is very much a tradeoff however. You are now including the data fetching code for getGraphDataById in the same bundle as <Feed>, so evaluate what is best for your case. Read more about how to do this in the Prefetching & Router Integration guide.\n\nThe tradeoff between:\n\nInclude all data fetching code in the main bundle, even if we seldom use it\nPut the data fetching code in the code split bundle, but with a request waterfall\n\nis not great and has been one of the motivations for Server Components. With Server Components, it's possible to avoid both, read more about how this applies to React Query in the Advanced Server Rendering guide.\n\nSummary and takeaways\n\nRequest Waterfalls are a very common and complex performance concern with many tradeoffs. There are many ways to accidentally introduce them into your application:\n\nAdding a query to a child, not realizing a parent already has a query\nAdding a query to a parent, not realizing a child already has a query\nMoving a component with descendants that has a query to a new parent with an ancestor that has a query\nEtc..\n\nBecause of this accidental complexity, it pays off to be mindful of waterfalls and regularly examine your application looking for them (a good way is to examine the Network tab every now and then!). You don't necessarily have to flatten them all to have good performance, but keep an eye out for the high impact ones.\n\nIn the next guide, we'll look at more ways to flatten waterfalls, by leveraging Prefetching & Router Integration.\n"
  },
  {
    "title": "Filters | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/filters",
    "html": "Filters\n\nSome methods within TanStack Query accept a QueryFilters or MutationFilters object.\n\nQuery Filters\n\nA query filter is an object with certain conditions to match a query with:\n\ntsx\n// Cancel all queries\nawait queryClient.cancelQueries()\n\n\n// Remove all inactive queries that begin with `posts` in the key\nqueryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })\n\n\n// Refetch all active queries\nawait queryClient.refetchQueries({ type: 'active' })\n\n\n// Refetch all active queries that begin with `posts` in the key\nawait queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })\n\nA query filter object supports the following properties:\n\nqueryKey?: QueryKey\nSet this property to define a query key to match on.\nexact?: boolean\nIf you don't want to search queries inclusively by query key, you can pass the exact: true option to return only the query with the exact query key you have passed.\ntype?: 'active' | 'inactive' | 'all'\nDefaults to all\nWhen set to active it will match active queries.\nWhen set to inactive it will match inactive queries.\nstale?: boolean\nWhen set to true it will match stale queries.\nWhen set to false it will match fresh queries.\nfetchStatus?: FetchStatus\nWhen set to fetching it will match queries that are currently fetching.\nWhen set to paused it will match queries that wanted to fetch, but have been paused.\nWhen set to idle it will match queries that are not fetching.\npredicate?: (query: Query) => boolean\nThis predicate function will be used as a final filter on all matching queries. If no other filters are specified, this function will be evaluated against every query in the cache.\nMutation Filters\n\nA mutation filter is an object with certain conditions to match a mutation with:\n\ntsx\n// Get the number of all fetching mutations\nawait queryClient.isMutating()\n\n\n// Filter mutations by mutationKey\nawait queryClient.isMutating({ mutationKey: [\"post\"] })\n\n\n// Filter mutations using a predicate function\nawait queryClient.isMutating({\n  predicate: (mutation) => mutation.options.variables?.id === 1,\n})\n\nA mutation filter object supports the following properties:\n\nmutationKey?: MutationKey\nSet this property to define a mutation key to match on.\nexact?: boolean\nIf you don't want to search mutations inclusively by mutation key, you can pass the exact: true option to return only the mutation with the exact mutation key you have passed.\nstatus?: MutationStatus\nAllows for filtering mutations according to their status.\npredicate?: (mutation: Mutation) => boolean\nThis predicate function will be used as a final filter on all matching mutations. If no other filters are specified, this function will be evaluated against every mutation in the cache."
  },
  {
    "title": "Scroll Restoration | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/scroll-restoration",
    "html": "Scroll Restoration\n\nTraditionally, when you navigate to a previously visited page on a web browser, you would find that the page would be scrolled to the exact position where you were before you navigated away from that page. This is called scroll restoration and has been in a bit of a regression since web applications have started moving towards client side data fetching. With TanStack Query however, that's no longer the case.\n\nOut of the box, \"scroll restoration\" for all queries (including paginated and infinite queries) Just Works‚Ñ¢Ô∏è in TanStack Query. The reason for this is that query results are cached and able to be retrieved synchronously when a query is rendered. As long as your queries are being cached long enough (the default time is 5 minutes) and have not been garbage collected, scroll restoration will work out of the box all the time.\n"
  },
  {
    "title": "Optimistic Updates | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/optimistic-updates",
    "html": "Optimistic Updates\n\nReact Query provides two ways to optimistically update your UI before a mutation has completed. You can either use the onMutate option to update your cache directly, or leverage the returned variables to update your UI from the useMutation result.\n\nVia the UI\n\nThis is the simpler variant, as it doesn't interact with the cache directly.\n\ntsx\nconst { isPending, submittedAt, variables, mutate, isError } = useMutation({\n    mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n    // make sure to _return_ the Promise from the query invalidation\n    // so that the mutation stays in `pending` state until the refetch is finished\n    onSettled: async () => {\n      return await queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n\nyou will then have access to addTodoMutation.variables, which contain the added todo. In your UI list, where the query is rendered, you can append another item to the list while the mutation is pending:\n\ntsx\n<ul>\n  {todoQuery.items.map((todo) => (\n    <li key={todo.id}>{todo.text}</li>\n  ))}\n  {isPending && (\n    <li style={{ opacity: 0.5 }}>\n      {variables}\n    </li>\n  )}\n</ul>\n\nWe're rendering a temporary item with a different opacity as long as the mutation is pending. Once it completes, the item will automatically no longer be rendered. Given that the refetch succeeded, we should see the item as a \"normal item\" in our list.\n\nIf the mutation errors, the item will also disappear. But we could continue to show it, if we want, by checking for the isError state of the mutation. variables are not cleared when the mutation errors, so we can still access them, maybe even show a retry button:\n\ntsx\n{isError && (\n  <li\n    style={{ color: 'red' }}\n  >\n    {variables}\n    <button onClick={() => mutate(variables)}>\n      Retry\n    </button>\n  </li>\n)}\nIf the mutation and the query don't live in the same component\n\nThis approach works very well if the mutation and the query live in the same component, However, you also get access to all mutations in other components via the dedicated useMutationState hook. It is best combined with a mutationKey:\n\ntsx\n// somewhere in your app\nconst { mutate } = useMutation({\n  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),\n  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),\n  mutationKey: ['addTodo']\n})\n\n\n// access variables somewhere else\nconst variables = useMutationState<string>({\n  filters: { mutationKey: ['addTodo'], status: 'pending' },\n  select: (mutation) => mutation.state.variables\n})\n\nvariables will be an Array, because there might be multiple mutations running at the same time. If we need a unique key for the items, we can also select mutation.state.submittedAt. This will even make displaying concurrent optimistic updates a breeze.\n\nVia the cache\n\nWhen you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you can instead choose to roll back your update.\n\nTo do this, useMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.\n\nUpdating a list of todos when adding a new todo\ntsx\nconst queryClient = useQueryClient()\n\n\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n\n    // Snapshot the previous value\n    const previousTodos = queryClient.getQueryData(['todos'])\n\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])\n\n\n    // Return a context object with the snapshotted value\n    return { previousTodos }\n  },\n  // If the mutation fails,\n  // use the context returned from onMutate to roll back\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(['todos'], context.previousTodos)\n  },\n  // Always refetch after error or success:\n  onSettled: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n  },\n})\nUpdating a single todo\ntsx\nuseMutation({\n  mutationFn: updateTodo,\n  // When mutate is called:\n  onMutate: async (newTodo) => {\n    // Cancel any outgoing refetches\n    // (so they don't overwrite our optimistic update)\n    await queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })\n\n\n    // Snapshot the previous value\n    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])\n\n\n    // Optimistically update to the new value\n    queryClient.setQueryData(['todos', newTodo.id], newTodo)\n\n\n    // Return a context with the previous and new todo\n    return { previousTodo, newTodo }\n  },\n  // If the mutation fails, use the context we returned above\n  onError: (err, newTodo, context) => {\n    queryClient.setQueryData(\n      ['todos', context.newTodo.id],\n      context.previousTodo,\n    )\n  },\n  // Always refetch after error or success:\n  onSettled: (newTodo) => {\n    queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] })\n  },\n})\n\nYou can also use the onSettled function in place of the separate onError and onSuccess handlers if you wish:\n\ntsx\nuseMutation({\n  mutationFn: updateTodo,\n  // ...\n  onSettled: (newTodo, error, variables, context) => {\n    if (error) {\n      // do something\n    }\n  },\n})\nWhen to use what\n\nIf you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle rollbacks at all.\n\nHowever, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.\n"
  },
  {
    "title": "Updates from Mutation Responses | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/updates-from-mutation-responses",
    "html": "Updates from Mutation Responses\n\nWhen dealing with mutations that update objects on the server, it's common for the new object to be automatically returned in the response of the mutation. Instead of refetching any queries for that item and wasting a network call for data we already have, we can take advantage of the object returned by the mutation function and update the existing query with the new data immediately using the Query Client's setQueryData method:\n\ntsx\nconst queryClient = useQueryClient()\n\n\nconst mutation = useMutation({\n  mutationFn: editTodo,\n  onSuccess: data => {\n    queryClient.setQueryData(['todo', { id: 5 }], data)\n  }\n})\n\n\nmutation.mutate({\n  id: 5,\n  name: 'Do the laundry',\n})\n\n\n// The query below will be updated with the response from the\n// successful mutation\nconst { status, data, error } = useQuery({\n  queryKey: ['todo', { id: 5 }],\n  queryFn: fetchTodoById,\n})\n\nYou might want to tie the onSuccess logic into a reusable mutation, for that you can create a custom hook like this:\n\ntsx\nconst useMutateTodo = () => {\n  const queryClient = useQueryClient()\n\n\n  return useMutation({\n    mutationFn: editTodo,\n    // Notice the second argument is the variables object that the `mutate` function receives\n    onSuccess: (data, variables) => {\n      queryClient.setQueryData(['todo', { id: variables.id }], data)\n    },\n  })\n}\nImmutability\n\nUpdates via setQueryData must be performed in an immutable way. DO NOT attempt to write directly to the cache by mutating data (that you retrieved from the cache) in place. It might work at first but can lead to subtle bugs along the way.\n\ntsx\nqueryClient.setQueryData(\n  ['posts', { id }],\n  (oldData) => {\n    if (oldData) {\n      // ‚ùå do not try this\n      oldData.title = 'my new post title'\n    }\n    return oldData\n  })\n\n\nqueryClient.setQueryData(\n  ['posts', { id }],\n  // ‚úÖ this is the way\n  (oldData) => oldData ? {\n    ...oldData,\n    title: 'my new post title'\n  } : oldData\n)"
  },
  {
    "title": "Query Cancellation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/query-cancellation",
    "html": "Query Cancellation\n\nTanStack Query provides each query function with an AbortSignal instance. When a query becomes out-of-date or inactive, this signal will become aborted. This means that all queries are cancellable, and you can respond to the cancellation inside your query function if desired. The best part about this is that it allows you to continue to use normal async/await syntax while getting all the benefits of automatic cancellation.\n\nThe AbortController API is available in most runtime environments, but if your runtime environment does not support it, you will need to provide a polyfill. There are several available.\n\nDefault behavior\n\nBy default, queries that unmount or become unused before their promises are resolved are not cancelled. This means that after the promise has resolved, the resulting data will be available in the cache. This is helpful if you've started receiving a query, but then unmount the component before it finishes. If you mount the component again and the query has not been garbage collected yet, data will be available.\n\nHowever, if you consume the AbortSignal, the Promise will be cancelled (e.g. aborting the fetch) and therefore, also the Query must be cancelled. Cancelling the query will result in its state being reverted to its previous state.\n\nUsing fetch\ntsx\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const todosResponse = await fetch('/todos', {\n      // Pass the signal to one fetch\n      signal,\n    })\n    const todos = await todosResponse.json()\n\n\n    const todoDetails = todos.map(async ({ details }) => {\n      const response = await fetch(details, {\n        // Or pass it to several\n        signal,\n      })\n      return response.json()\n    })\n\n\n    return Promise.all(todoDetails)\n  },\n})\nUsing axios v0.22.0+\ntsx\nimport axios from 'axios'\n\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) =>\n    axios.get('/todos', {\n      // Pass the signal to `axios`\n      signal,\n    }),\n})\nUsing axios with version lower than v0.22.0\ntsx\nimport axios from 'axios'\n\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    // Create a new CancelToken source for this request\n    const CancelToken = axios.CancelToken\n    const source = CancelToken.source()\n\n\n    const promise = axios.get('/todos', {\n      // Pass the source token to your request\n      cancelToken: source.token,\n    })\n\n\n    // Cancel the request if TanStack Query signals to abort\n    signal?.addEventListener('abort', () => {\n      source.cancel('Query was cancelled by TanStack Query')\n    })\n\n\n    return promise\n  },\n})\nUsing XMLHttpRequest\ntsx\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    return new Promise((resolve, reject) => {\n      var oReq = new XMLHttpRequest()\n      oReq.addEventListener('load', () => {\n        resolve(JSON.parse(oReq.responseText))\n      })\n      signal?.addEventListener('abort', () => {\n        oReq.abort()\n        reject()\n      })\n      oReq.open('GET', '/todos')\n      oReq.send()\n    })\n  },\n})\nUsing graphql-request\n\nAn AbortSignal can be set in the client request method.\n\ntsx\nconst client = new GraphQLClient(endpoint)\n\n\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    client.request({ document: query, signal })\n  },\n})\nUsing graphql-request with version lower than v4.0.0\n\nAn AbortSignal can be set in the GraphQLClient constructor.\n\ntsx\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: ({ signal }) => {\n    const client = new GraphQLClient(endpoint, {\n      signal,\n    })\n    return client.request(query, variables)\n  },\n})\nManual Cancellation\n\nYou might want to cancel a query manually. For example, if the request takes a long time to finish, you can allow the user to click a cancel button to stop the request. To do this, you just need to call queryClient.cancelQueries({ queryKey }), which will cancel the query and revert it back to its previous state. If you have consumed the signal passed to the query function, TanStack Query will additionally also cancel the Promise.\n\ntsx\nconst query = useQuery({\n  queryKey: ['todos'],\n  queryFn: async ({ signal }) => {\n    const resp = await fetch('/todos', { signal })\n    return resp.json()\n  },\n})\n\n\nconst queryClient = useQueryClient()\n\n\nreturn (\n  <button\n    onClick={(e) => {\n      e.preventDefault()\n      queryClient.cancelQueries({ queryKey: ['todos'] })\n    }}\n  >\n    Cancel\n  </button>\n)"
  },
  {
    "title": "Query Invalidation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/query-invalidation",
    "html": "Query Invalidation\n\nWaiting for queries to become stale before they are fetched again doesn't always work, especially when you know for a fact that a query's data is out of date because of something the user has done. For that purpose, the QueryClient has an invalidateQueries method that lets you intelligently mark queries as stale and potentially refetch them too!\n\ntsx\n// Invalidate every query in the cache\nqueryClient.invalidateQueries()\n// Invalidate every query with a key that starts with `todos`\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n\nNote: Where other libraries that use normalized caches would attempt to update local queries with the new data either imperatively or via schema inference, TanStack Query gives you the tools to avoid the manual labor that comes with maintaining normalized caches and instead prescribes targeted invalidation, background-refetching and ultimately atomic updates.\n\nWhen a query is invalidated with invalidateQueries, two things happen:\n\nIt is marked as stale. This stale state overrides any staleTime configurations being used in useQuery or related hooks\nIf the query is currently being rendered via useQuery or related hooks, it will also be refetched in the background\nQuery Matching with invalidateQueries\n\nWhen using APIs like invalidateQueries and removeQueries (and others that support partial query matching), you can match multiple queries by their prefix, or get really specific and match an exact query. For information on the types of filters you can use, please see Query Filters.\n\nIn this example, we can use the todos prefix to invalidate any queries that start with todos in their query key:\n\ntsx\nimport { useQuery, useQueryClient } from '@tanstack/react-query'\n\n\n// Get QueryClient from the context\nconst queryClient = useQueryClient()\n\n\nqueryClient.invalidateQueries({ queryKey: ['todos'] })\n\n\n// Both queries below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { page: 1 }],\n  queryFn: fetchTodoList,\n})\n\nYou can even invalidate queries with specific variables by passing a more specific query key to the invalidateQueries method:\n\ntsx\nqueryClient.invalidateQueries({\n  queryKey: ['todos', { type: 'done' }],\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n\nThe invalidateQueries API is very flexible, so even if you want to only invalidate todos queries that don't have any more variables or subkeys, you can pass an exact: true option to the invalidateQueries method:\n\ntsx\nqueryClient.invalidateQueries({\n  queryKey: ['todos'],\n  exact: true,\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n})\n\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { type: 'done' }],\n  queryFn: fetchTodoList,\n})\n\nIf you find yourself wanting even more granularity, you can pass a predicate function to the invalidateQueries method. This function will receive each Query instance from the query cache and allow you to return true or false for whether you want to invalidate that query:\n\ntsx\nqueryClient.invalidateQueries({\n  predicate: (query) =>\n    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 20 }],\n  queryFn: fetchTodoList,\n})\n\n\n// The query below will be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 10 }],\n  queryFn: fetchTodoList,\n})\n\n\n// However, the following query below will NOT be invalidated\nconst todoListQuery = useQuery({\n  queryKey: ['todos', { version: 5 }],\n  queryFn: fetchTodoList,\n})"
  },
  {
    "title": "Invalidations from Mutations | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/invalidations-from-mutations",
    "html": "Invalidations from Mutations\n\nInvalidating queries is only half the battle. Knowing when to invalidate them is the other half. Usually when a mutation in your app succeeds, it's VERY likely that there are related queries in your application that need to be invalidated and possibly refetched to account for the new changes from your mutation.\n\nFor example, assume we have a mutation to post a new todo:\n\ntsx\nconst mutation = useMutation({ mutationFn: postTodo })\n\nWhen a successful postTodo mutation happens, we likely want all todos queries to get invalidated and possibly refetched to show the new todo item. To do this, you can use useMutation's onSuccess options and the client's invalidateQueries function:\n\ntsx\nimport { useMutation, useQueryClient } from '@tanstack/react-query'\n\n\nconst queryClient = useQueryClient()\n\n\n// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  onSuccess: () => {\n    queryClient.invalidateQueries({ queryKey: ['todos'] })\n    queryClient.invalidateQueries({ queryKey: ['reminders'] })\n  },\n})\n\nYou can wire up your invalidations to happen using any of the callbacks available in the useMutation hook\n"
  },
  {
    "title": "Mutations | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/mutations",
    "html": "Mutations\n\nUnlike queries, mutations are typically used to create/update/delete data or perform server side-effects. For this purpose, TanStack Query exports a useMutation hook.\n\nHere's an example of a mutation that adds a new todo to the server:\n\ntsx\nfunction App() {\n  const mutation = useMutation({\n    mutationFn: (newTodo) => {\n      return axios.post('/todos', newTodo)\n    },\n  })\n\n\n  return (\n    <div>\n      {mutation.isPending ? (\n        'Adding todo...'\n      ) : (\n        <>\n          {mutation.isError ? (\n            <div>An error occurred: {mutation.error.message}</div>\n          ) : null}\n\n\n          {mutation.isSuccess ? <div>Todo added!</div> : null}\n\n\n          <button\n            onClick={() => {\n              mutation.mutate({ id: new Date(), title: 'Do Laundry' })\n            }}\n          >\n            Create Todo\n          </button>\n        </>\n      )}\n    </div>\n  )\n}\n\nA mutation can only be in one of the following states at any given moment:\n\nisIdle or status === 'idle' - The mutation is currently idle or in a fresh/reset state\nisPending or status === 'pending' - The mutation is currently running\nisError or status === 'error' - The mutation encountered an error\nisSuccess or status === 'success' - The mutation was successful and mutation data is available\n\nBeyond those primary states, more information is available depending on the state of the mutation:\n\nerror - If the mutation is in an error state, the error is available via the error property.\ndata - If the mutation is in a success state, the data is available via the data property.\n\nIn the example above, you also saw that you can pass variables to your mutations function by calling the mutate function with a single variable or object.\n\nEven with just variables, mutations aren't all that special, but when used with the onSuccess option, the Query Client's invalidateQueries method and the Query Client's setQueryData method, mutations become a very powerful tool.\n\nIMPORTANT: The mutate function is an asynchronous function, which means you cannot use it directly in an event callback in React 16 and earlier. If you need to access the event in onSubmit you need to wrap mutate in another function. This is due to React event pooling.\n\ntsx\n// This will not work in React 16 and earlier\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (event) => {\n      event.preventDefault()\n      return fetch('/api', new FormData(event.target))\n    },\n  })\n\n\n  return <form onSubmit={mutation.mutate}>...</form>\n}\n\n\n// This will work\nconst CreateTodo = () => {\n  const mutation = useMutation({\n    mutationFn: (formData) => {\n      return fetch('/api', formData)\n    },\n  })\n  const onSubmit = (event) => {\n    event.preventDefault()\n    mutation.mutate(new FormData(event.target))\n  }\n\n\n  return <form onSubmit={onSubmit}>...</form>\n}\nResetting Mutation State\n\nIt's sometimes the case that you need to clear the error or data of a mutation request. To do this, you can use the reset function to handle this:\n\ntsx\nconst CreateTodo = () => {\n  const [title, setTitle] = useState('')\n  const mutation = useMutation({ mutationFn: createTodo })\n\n\n  const onCreateTodo = (e) => {\n    e.preventDefault()\n    mutation.mutate({ title })\n  }\n\n\n  return (\n    <form onSubmit={onCreateTodo}>\n      {mutation.error && (\n        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>\n      )}\n      <input\n        type=\"text\"\n        value={title}\n        onChange={(e) => setTitle(e.target.value)}\n      />\n      <br />\n      <button type=\"submit\">Create Todo</button>\n    </form>\n  )\n}\nMutation Side Effects\n\nuseMutation comes with some helper options that allow quick and easy side-effects at any stage during the mutation lifecycle. These come in handy for both invalidating and refetching queries after mutations and even optimistic updates\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onMutate: (variables) => {\n    // A mutation is about to happen!\n\n\n    // Optionally return a context containing data to use when for example rolling back\n    return { id: 1 }\n  },\n  onError: (error, variables, context) => {\n    // An error happened!\n    console.log(`rolling back optimistic update with id ${context.id}`)\n  },\n  onSuccess: (data, variables, context) => {\n    // Boom baby!\n  },\n  onSettled: (data, error, variables, context) => {\n    // Error or success... doesn't matter!\n  },\n})\n\nWhen returning a promise in any of the callback functions it will first be awaited before the next callback is called:\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: async () => {\n    console.log(\"I'm first!\")\n  },\n  onSettled: async () => {\n    console.log(\"I'm second!\")\n  },\n})\n\nYou might find that you want to trigger additional callbacks beyond the ones defined on useMutation when calling mutate. This can be used to trigger component-specific side effects. To do that, you can provide any of the same callback options to the mutate function after your mutation variable. Supported options include: onSuccess, onError and onSettled. Please keep in mind that those additional callbacks won't run if your component unmounts before the mutation finishes.\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, variables, context) => {\n    // I will fire first\n  },\n  onError: (error, variables, context) => {\n    // I will fire first\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire first\n  },\n})\n\n\nmutate(todo, {\n  onSuccess: (data, variables, context) => {\n    // I will fire second!\n  },\n  onError: (error, variables, context) => {\n    // I will fire second!\n  },\n  onSettled: (data, error, variables, context) => {\n    // I will fire second!\n  },\n})\nConsecutive mutations\n\nThere is a slight difference in handling onSuccess, onError and onSettled callbacks when it comes to consecutive mutations. When passed to the mutate function, they will be fired up only once and only if the component is still mounted. This is due to the fact that mutation observer is removed and resubscribed every time when the mutate function is called. On the contrary, useMutation handlers execute for each mutate call.\n\nBe aware that most likely, mutationFn passed to useMutation is asynchronous. In that case, the order in which mutations are fulfilled may differ from the order of mutate function calls.\n\ntsx\nuseMutation({\n  mutationFn: addTodo,\n  onSuccess: (data, error, variables, context) => {\n    // Will be called 3 times\n  },\n})\n\n\n[('Todo 1', 'Todo 2', 'Todo 3')].forEach((todo) => {\n  mutate(todo, {\n    onSuccess: (data, error, variables, context) => {\n      // Will execute only once, for the last mutation (Todo 3),\n      // regardless which mutation resolves first\n    },\n  })\n})\nPromises\n\nUse mutateAsync instead of mutate to get a promise which will resolve on success or throw on an error. This can for example be used to compose side effects.\n\ntsx\nconst mutation = useMutation({ mutationFn: addTodo })\n\n\ntry {\n  const todo = await mutation.mutateAsync(todo)\n  console.log(todo)\n} catch (error) {\n  console.error(error)\n} finally {\n  console.log('done')\n}\nRetry\n\nBy default TanStack Query will not retry a mutation on error, but it is possible with the retry option:\n\ntsx\nconst mutation = useMutation({\n  mutationFn: addTodo,\n  retry: 3,\n})\n\nIf mutations fail because the device is offline, they will be retried in the same order when the device reconnects.\n\nPersist mutations\n\nMutations can be persisted to storage if needed and resumed at a later point. This can be done with the hydration functions:\n\ntsx\nconst queryClient = new QueryClient()\n\n\n// Define the \"addTodo\" mutation\nqueryClient.setMutationDefaults(['addTodo'], {\n  mutationFn: addTodo,\n  onMutate: async (variables) => {\n    // Cancel current queries for the todos list\n    await queryClient.cancelQueries({ queryKey: ['todos'] })\n\n\n    // Create optimistic todo\n    const optimisticTodo = { id: uuid(), title: variables.title }\n\n\n    // Add optimistic todo to todos list\n    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])\n\n\n    // Return context with the optimistic todo\n    return { optimisticTodo }\n  },\n  onSuccess: (result, variables, context) => {\n    // Replace optimistic todo in the todos list with the result\n    queryClient.setQueryData(['todos'], (old) =>\n      old.map((todo) =>\n        todo.id === context.optimisticTodo.id ? result : todo,\n      ),\n    )\n  },\n  onError: (error, variables, context) => {\n    // Remove optimistic todo from the todos list\n    queryClient.setQueryData(['todos'], (old) =>\n      old.filter((todo) => todo.id !== context.optimisticTodo.id),\n    )\n  },\n  retry: 3,\n})\n\n\n// Start mutation in some component:\nconst mutation = useMutation({ mutationKey: ['addTodo'] })\nmutation.mutate({ title: 'title' })\n\n\n// If the mutation has been paused because the device is for example offline,\n// Then the paused mutation can be dehydrated when the application quits:\nconst state = dehydrate(queryClient)\n\n\n// The mutation can then be hydrated again when the application is started:\nhydrate(queryClient, state)\n\n\n// Resume the paused mutations:\nqueryClient.resumePausedMutations()\nPersisting Offline mutations\n\nIf you persist offline mutations with the persistQueryClient plugin, mutations cannot be resumed when the page is reloaded unless you provide a default mutation function.\n\nThis is a technical limitation. When persisting to an external storage, only the state of mutations is persisted, as functions cannot be serialized. After hydration, the component that triggers the mutation might not be mounted, so calling resumePausedMutations might yield an error: No mutationFn found.\n\ntsx\nconst persister = createSyncStoragePersister({\n  storage: window.localStorage,\n})\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      gcTime: 1000 * 60 * 60 * 24, // 24 hours\n    },\n  },\n})\n\n\n// we need a default mutation function so that paused mutations can resume after a page reload\nqueryClient.setMutationDefaults(['todos'], {\n  mutationFn: ({ id, data }) => {\n    return api.updateTodo(id, data)\n  },\n})\n\n\nexport default function App() {\n  return (\n    <PersistQueryClientProvider\n      client={queryClient}\n      persistOptions={{ persister }}\n      onSuccess={() => {\n        // resume mutations after initial restore from localStorage was successful\n        queryClient.resumePausedMutations()\n      }}\n    >\n      <RestOfTheApp />\n    </PersistQueryClientProvider>\n  )\n}\n\nWe also have an extensive offline example that covers both queries and mutations.\n\nFurther reading\n\nFor more information about mutations, have a look at #12: Mastering Mutations in React Query from the Community Resources.\n"
  },
  {
    "title": "Placeholder Query Data | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/placeholder-query-data",
    "html": "Placeholder Query Data\nWhat is placeholder data?\n\nPlaceholder data allows a query to behave as if it already has data, similar to the initialData option, but the data is not persisted to the cache. This comes in handy for situations where you have enough partial (or fake) data to render the query successfully while the actual data is fetched in the background.\n\nExample: An individual blog post query could pull \"preview\" data from a parent list of blog posts that only include title and a small snippet of the post body. You would not want to persist this partial data to the query result of the individual query, but it is useful for showing the content layout as quickly as possible while the actual query finishes to fetch the entire object.\n\nThere are a few ways to supply placeholder data for a query to the cache before you need it:\n\nDeclaratively:\nProvide placeholderData to a query to prepopulate its cache if empty\nImperatively:\nPrefetch or fetch the data using queryClient and the placeholderData option\n\nWhen we use placeholderData, our Query will not be in a pending state - it will start out as being in success state, because we have data to display - even if that data is just \"placeholder\" data. To distinguish it from \"real\" data, we will also have the isPlaceholderData flag set to true on the Query result.\n\nPlaceholder Data as a Value\ntsx\nfunction Todos() {\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData: placeholderTodos,\n  })\n}\nPlaceholder Data Memoization\n\nIf the process for accessing a query's placeholder data is intensive or just not something you want to perform on every render, you can memoize the value:\n\ntsx\nfunction Todos() {\n  const placeholderData = useMemo(() => generateFakeTodos(), [])\n  const result = useQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetch('/todos'),\n    placeholderData,\n  })\n}\nPlaceholder Data as a Function\n\nplaceholderData can also be a function, where you can get access to the data and Query meta information of a \"previous\" successful Query. This is useful for situations where you want to use the data from one query as the placeholder data for another query. When the QueryKey changes, e.g. from ['todos', 1] to ['todos', 2], we can keep displaying \"old\" data instead of having to show a loading spinner while data is transitioning from one Query to the next. For more information, see Paginated Queries.\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos', id],\n  queryFn: () => fetch(`/todos/${id}`),\n  placeholderData: (previousData, previousQuery) => previousData,\n})\nPlaceholder Data from Cache\n\nIn some circumstances, you may be able to provide the placeholder data for a query from the cached result of another. A good example of this would be searching the cached data from a blog post list query for a preview version of the post, then using that as the placeholder data for your individual post query:\n\ntsx\nfunction Todo({ blogPostId }) {\n  const queryClient = useQueryClient();\n  const result = useQuery({\n    queryKey: ['blogPost', blogPostId],\n    queryFn: () => fetch(`/blogPosts/${blogPostId}`),\n    placeholderData: () => {\n      // Use the smaller/preview version of the blogPost from the 'blogPosts'\n      // query as the placeholder data for this blogPost query\n      return queryClient\n        .getQueryData(['blogPosts'])\n        ?.find((d) => d.id === blogPostId)\n    },\n  })\n}\nFurther reading\n\nFor a comparison between Placeholder Data and Initial Data, have a look at the Community Resources.\n"
  },
  {
    "title": "Initial Query Data | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/initial-query-data",
    "html": "Initial Query Data\n\nThere are many ways to supply initial data for a query to the cache before you need it:\n\nDeclaratively:\nProvide initialData to a query to prepopulate its cache if empty\nImperatively:\nPrefetch the data using queryClient.prefetchQuery\nManually place the data into the cache using queryClient.setQueryData\nUsing initialData to prepopulate a query\n\nThere may be times when you already have the initial data for a query available in your app and can simply provide it directly to your query. If and when this is the case, you can use the config.initialData option to set the initial data for a query and skip the initial loading state!\n\nIMPORTANT: initialData is persisted to the cache, so it is not recommended to provide placeholder, partial or incomplete data to this option and instead use placeholderData\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\nstaleTime and initialDataUpdatedAt\n\nBy default, initialData is treated as totally fresh, as if it were just fetched. This also means that it will affect how it is interpreted by the staleTime option.\n\nIf you configure your query observer with initialData, and no staleTime (the default staleTime: 0), the query will immediately refetch when it mounts:\n\ntsx\n// Will show initialTodos immediately, but also immediately refetch todos after mount\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n})\n\nIf you configure your query observer with initialData and a staleTime of 1000 ms, the data will be considered fresh for that same amount of time, as if it was just fetched from your query function.\n\ntsx\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 1000,\n})\n\nSo what if your initialData isn't totally fresh? That leaves us with the last configuration that is actually the most accurate and uses an option called initialDataUpdatedAt. This option allows you to pass a numeric JS timestamp in milliseconds of when the initialData itself was last updated, e.g. what Date.now() provides. Take note that if you have a unix timestamp, you'll need to convert it to a JS timestamp by multiplying it by 1000.\n\ntsx\n// Show initialTodos immediately, but won't refetch until another interaction event is encountered after 1000 ms\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: initialTodos,\n  staleTime: 60 * 1000, // 1 minute\n  // This could be 10 seconds ago or 10 minutes ago\n  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052\n})\n\nThis option allows the staleTime to be used for its original purpose, determining how fresh the data needs to be, while also allowing the data to be refetched on mount if the initialData is older than the staleTime. In the example above, our data needs to be fresh within 1 minute, and we can hint to the query when the initialData was last updated so the query can decide for itself whether the data needs to be refetched again or not.\n\nIf you would rather treat your data as prefetched data, we recommend that you use the prefetchQuery or fetchQuery APIs to populate the cache beforehand, thus letting you configure your staleTime independently from your initialData\n\nInitial Data Function\n\nIf the process for accessing a query's initial data is intensive or just not something you want to perform on every render, you can pass a function as the initialData value. This function will be executed only once when the query is initialized, saving you precious memory and/or CPU:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: () => fetch('/todos'),\n  initialData: () => getExpensiveTodos(),\n})\nInitial Data from Cache\n\nIn some circumstances, you may be able to provide the initial data for a query from the cached result of another. A good example of this would be searching the cached data from a todos list query for an individual todo item, then using that as the initial data for your individual todo query:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch('/todos'),\n  initialData: () => {\n    // Use a todo from the 'todos' query as the initial data for this todo query\n    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)\n  },\n})\nInitial Data from the cache with initialDataUpdatedAt\n\nGetting initial data from the cache means the source query you're using to look up the initial data from is likely old, but initialData. Instead of using an artificial staleTime to keep your query from refetching immediately, it's suggested that you pass the source query's dataUpdatedAt to initialDataUpdatedAt. This provides the query instance with all the information it needs to determine if and when the query needs to be refetched, regardless of initial data being provided.\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () =>\n    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),\n  initialDataUpdatedAt: () =>\n    queryClient.getQueryState(['todos'])?.dataUpdatedAt,\n})\nConditional Initial Data from Cache\n\nIf the source query you're using to look up the initial data from is old, you may not want to use the cached data at all and just fetch from the server. To make this decision easier, you can use the queryClient.getQueryState method instead to get more information about the source query, including a state.dataUpdatedAt timestamp you can use to decide if the query is \"fresh\" enough for your needs:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todo', todoId],\n  queryFn: () => fetch(`/todos/${todoId}`),\n  initialData: () => {\n    // Get the query state\n    const state = queryClient.getQueryState(['todos'])\n\n\n    // If the query exists and has data that is no older than 10 seconds...\n    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {\n      // return the individual todo\n      return state.data.find((d) => d.id === todoId)\n    }\n\n\n    // Otherwise, return undefined and let it fetch from a hard loading state!\n  },\n})\nFurther reading\n\nFor a comparison between Initial Data and Placeholder Data, have a look at the Community Resources.\n"
  },
  {
    "title": "Infinite Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/infinite-queries",
    "html": "Infinite Queries\n\nRendering lists that can additively \"load more\" data onto an existing set of data or \"infinite scroll\" is also a very common UI pattern. TanStack Query supports a useful version of useQuery called useInfiniteQuery for querying these types of lists.\n\nWhen using useInfiniteQuery, you'll notice a few things are different:\n\ndata is now an object containing infinite query data:\ndata.pages array containing the fetched pages\ndata.pageParams array containing the page params used to fetch the pages\nThe fetchNextPage and fetchPreviousPage functions are now available (fetchNextPage is required)\nThe initialPageParam option is now available (and required) to specify the initial page param\nThe getNextPageParam and getPreviousPageParam options are available for both determining if there is more data to load and the information to fetch it. This information is supplied as an additional parameter in the query function\nA hasNextPage boolean is now available and is true if getNextPageParam returns a value other than null or undefined\nA hasPreviousPage boolean is now available and is true if getPreviousPageParam returns a value other than null or undefined\nThe isFetchingNextPage and isFetchingPreviousPage booleans are now available to distinguish between a background refresh state and a loading more state\n\nNote: Options initialData or placeholderData need to conform to the same structure of an object with data.pages and data.pageParams properties.\n\nExample\n\nLet's assume we have an API that returns pages of projects 3 at a time based on a cursor index along with a cursor that can be used to fetch the next group of projects:\n\ntsx\nfetch('/api/projects?cursor=0')\n// { data: [...], nextCursor: 3}\nfetch('/api/projects?cursor=3')\n// { data: [...], nextCursor: 6}\nfetch('/api/projects?cursor=6')\n// { data: [...], nextCursor: 9}\nfetch('/api/projects?cursor=9')\n// { data: [...] }\n\nWith this information, we can create a \"Load More\" UI by:\n\nWaiting for useInfiniteQuery to request the first group of data by default\nReturning the information for the next query in getNextPageParam\nCalling fetchNextPage function\ntsx\nimport { useInfiniteQuery } from '@tanstack/react-query'\n\n\nfunction Projects() {\n  const fetchProjects = async ({ pageParam }) => {\n    const res = await fetch('/api/projects?cursor=' + pageParam)\n    return res.json()\n  }\n\n\n  const {\n    data,\n    error,\n    fetchNextPage,\n    hasNextPage,\n    isFetching,\n    isFetchingNextPage,\n    status,\n  } = useInfiniteQuery({\n    queryKey: ['projects'],\n    queryFn: fetchProjects,\n    initialPageParam: 0,\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  })\n\n\n  return status === 'pending' ? (\n    <p>Loading...</p>\n  ) : status === 'error' ? (\n    <p>Error: {error.message}</p>\n  ) : (\n    <>\n      {data.pages.map((group, i) => (\n        <React.Fragment key={i}>\n          {group.data.map((project) => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </React.Fragment>\n      ))}\n      <div>\n        <button\n          onClick={() => fetchNextPage()}\n          disabled={!hasNextPage || isFetchingNextPage}\n        >\n          {isFetchingNextPage\n            ? 'Loading more...'\n            : hasNextPage\n            ? 'Load More'\n            : 'Nothing more to load'}\n        </button>\n      </div>\n      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>\n    </>\n  )\n}\n\nIt's essential to understand that calling fetchNextPage while an ongoing fetch is in progress runs the risk of overwriting data refreshes happening in the background. This situation becomes particularly critical when rendering a list and triggering fetchNextPage simultaneously.\n\nRemember, there can only be a single ongoing fetch for an InfiniteQuery. A single cache entry is shared for all pages, attempting to fetch twice simultaneously might lead to data overwrites.\n\nIf you intend to enable simultaneous fetching, you can utilize the { cancelRefetch: false } option (default: true) within fetchNextPage.\n\nTo ensure a seamless querying process without conflicts, it's highly recommended to verify that the query is not in an isFetching state, especially if the user won't directly control that call.\n\njsx\n<List\n  onEndReached={() => !isFetching && fetchNextPage()}\n/>\nWhat happens when an infinite query needs to be refetched?\n\nWhen an infinite query becomes stale and needs to be refetched, each group is fetched sequentially, starting from the first one. This ensures that even if the underlying data is mutated, we're not using stale cursors and potentially getting duplicates or skipping records. If an infinite query's results are ever removed from the queryCache, the pagination restarts at the initial state with only the initial group being requested.\n\nWhat if I want to implement a bi-directional infinite list?\n\nBi-directional lists can be implemented by using the getPreviousPageParam, fetchPreviousPage, hasPreviousPage and isFetchingPreviousPage properties and functions.\n\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n})\nWhat if I want to show the pages in reversed order?\n\nSometimes you may want to show the pages in reversed order. If this is case, you can use the select option:\n\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  select: (data) => ({\n    pages: [...data.pages].reverse(),\n    pageParams: [...data.pageParams].reverse(),\n  }),\n})\nWhat if I want to manually update the infinite query? Manually removing first page:\ntsx\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(1),\n  pageParams: data.pageParams.slice(1),\n}))\nManually removing a single value from an individual page:\ntsx\nconst newPagesArray =\n  oldPagesArray?.pages.map((page) =>\n    page.filter((val) => val.id !== updatedId),\n  ) ?? []\n\n\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: newPagesArray,\n  pageParams: data.pageParams,\n}))\nKeep only the first page:\ntsx\nqueryClient.setQueryData(['projects'], (data) => ({\n  pages: data.pages.slice(0,1),\n  pageParams: data.pageParams.slice(0,1),\n}))\n\nMake sure to always keep the same data structure of pages and pageParams!\n\nWhat if I want to limit the number of pages?\n\nIn some use cases you may want to limit the number of pages stored in the query data to improve the performance and UX:\n\nwhen the user can load a large number of pages (memory usage)\nwhen you have to refetch an infinite query that contains dozens of pages (network usage: all the pages are sequentially fetched)\n\nThe solution is to use a \"Limited Infinite Query\". This is made possible by using the maxPages option in conjunction with getNextPageParam and getPreviousPageParam to allow fetching pages when needed in both directions.\n\nIn the following example only 3 pages are kept in the query data pages array. If a refetch is needed, only 3 pages will be refetched sequentially.\n\ntsx\nuseInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,\n  maxPages: 3,\n})\nWhat if my API doesn't return a cursor?\n\nIf your API doesn't return a cursor, you can use the pageParam as a cursor. Because getNextPageParam and getPreviousPageParam also get the pageParamof the current page, you can use it to calculate the next / previous page param.\n\ntsx\nreturn useInfiniteQuery({\n  queryKey: ['projects'],\n  queryFn: fetchProjects,\n  initialPageParam: 0,\n  getNextPageParam: (lastPage, allPages, lastPageParam) => {\n    if (lastPage.length === 0) {\n        return undefined\n    }\n    return lastPageParam + 1\n  },\n  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {\n    if (firstPageParam <= 1) {\n        return undefined\n    }\n    return firstPageParam - 1\n  },\n})"
  },
  {
    "title": "Paginated / Lagged Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/paginated-queries",
    "html": "Paginated / Lagged Queries\n\nRendering paginated data is a very common UI pattern and in TanStack Query, it \"just works\" by including the page information in the query key:\n\ntsx\nconst result = useQuery({\n  queryKey: ['projects', page],\n  queryFn: fetchProjects\n})\n\nHowever, if you run this simple example, you might notice something strange:\n\nThe UI jumps in and out of the success and pending states because each new page is treated like a brand new query.\n\nThis experience is not optimal and unfortunately is how many tools today insist on working. But not TanStack Query! As you may have guessed, TanStack Query comes with an awesome feature called placeholderData that allows us to get around this.\n\nBetter Paginated Queries with placeholderData\n\nConsider the following example where we would ideally want to increment a pageIndex (or cursor) for a query. If we were to use useQuery, it would still technically work fine, but the UI would jump in and out of the success and pending states as different queries are created and destroyed for each page or cursor. By setting placeholderData to (previousData) => previousData or keepPreviousData function exported from TanStack Query, we get a few new things:\n\nThe data from the last successful fetch is available while new data is being requested, even though the query key has changed.\nWhen the new data arrives, the previous data is seamlessly swapped to show the new data.\nisPlaceholderData is made available to know what data the query is currently providing you\ntsx\nimport { keepPreviousData, useQuery } from \"@tanstack/react-query\";\nimport React from \"react\";\n\n\nfunction Todos() {\n  const [page, setPage] = React.useState(0)\n\n\n  const fetchProjects = (page = 0) => fetch('/api/projects?page=' + page).then((res) => res.json())\n\n\n  const {\n    isPending,\n    isError,\n    error,\n    data,\n    isFetching,\n    isPlaceholderData,\n  } = useQuery({\n    queryKey: ['projects', page],\n    queryFn: () => fetchProjects(page),\n    placeholderData: keepPreviousData,\n  })\n\n\n  return (\n    <div>\n      {isPending ? (\n        <div>Loading...</div>\n      ) : isError ? (\n        <div>Error: {error.message}</div>\n      ) : (\n        <div>\n          {data.projects.map(project => (\n            <p key={project.id}>{project.name}</p>\n          ))}\n        </div>\n      )}\n      <span>Current Page: {page + 1}</span>\n      <button\n        onClick={() => setPage(old => Math.max(old - 1, 0))}\n        disabled={page === 0}\n      >\n        Previous Page\n      </button>{' '}\n      <button\n        onClick={() => {\n          if (!isPlaceholderData && data.hasMore) {\n            setPage(old => old + 1)\n          }\n        }}\n        // Disable the Next Page button until we know a next page is available\n        disabled={isPlaceholderData || !data?.hasMore}\n      >\n        Next Page\n      </button>\n      {isFetching ? <span> Loading...</span> : null}{' '}\n    </div>\n  )\n}\nLagging Infinite Query results with placeholderData\n\nWhile not as common, the placeholderData option also works flawlessly with the useInfiniteQuery hook, so you can seamlessly allow your users to continue to see cached data while infinite query keys change over time.\n"
  },
  {
    "title": "Query Retries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/query-retries",
    "html": "Query Retries\n\nWhen a useQuery query fails (the query function throws an error), TanStack Query will automatically retry the query if that query's request has not reached the max number of consecutive retries (defaults to 3) or a function is provided to determine if a retry is allowed.\n\nYou can configure retries both on a global level and an individual query level.\n\nSetting retry = false will disable retries.\nSetting retry = 6 will retry failing requests 6 times before showing the final error thrown by the function.\nSetting retry = true will infinitely retry failing requests.\nSetting retry = (failureCount, error) => ... allows for custom logic based on why the request failed.\n\nOn the server, retries default to 0 to make server rendering as fast as possible.\n\ntsx\nimport { useQuery } from '@tanstack/react-query'\n\n\n// Make a specific query retry a certain number of times\nconst result = useQuery({\n  queryKey: ['todos', 1],\n  queryFn: fetchTodoListPage,\n  retry: 10, // Will retry failed requests 10 times before displaying an error\n})\n\nInfo: Contents of the error property will be part of failureReason response property of useQuery until the last retry attempt. So in above example any error contents will be part of failureReason property for first 9 retry attempts (Overall 10 attempts) and finally they will be part of error after last attempt if error persists after all retry attempts.\n\nRetry Delay\n\nBy default, retries in TanStack Query do not happen immediately after a request fails. As is standard, a back-off delay is gradually applied to each retry attempt.\n\nThe default retryDelay is set to double (starting at 1000ms) with each attempt, but not exceed 30 seconds:\n\ntsx\n// Configure for all queries\nimport {\n  QueryCache,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\n\n\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    },\n  },\n})\n\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\n\nThough it is not recommended, you can obviously override the retryDelay function/integer in both the Provider and individual query options. If set to an integer instead of a function the delay will always be the same amount of time:\n\ntsx\nconst result = useQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodoList,\n  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries\n})"
  },
  {
    "title": "Disabling/Pausing Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/disabling-queries",
    "html": "Disabling/Pausing Queries\n\nIf you ever want to disable a query from automatically running, you can use the enabled = false option.\n\nWhen enabled is false:\n\nIf the query has cached data, then the query will be initialized in the status === 'success' or isSuccess state.\nIf the query does not have cached data, then the query will start in the status === 'pending' and fetchStatus === 'idle' state.\nThe query will not automatically fetch on mount.\nThe query will not automatically refetch in the background.\nThe query will ignore query client invalidateQueries and refetchQueries calls that would normally result in the query refetching.\nrefetch returned from useQuery can be used to manually trigger the query to fetch.\ntsx\nfunction Todos() {\n  const { isLoading, isError, data, error, refetch, isFetching } =\n    useQuery({\n      queryKey: ['todos'],\n      queryFn: fetchTodoList,\n      enabled: false,\n    })\n\n\n  return (\n    <div>\n      <button onClick={() => refetch()}>Fetch Todos</button>\n\n\n      {data ? (\n        <>\n          <ul>\n            {data.map((todo) => (\n              <li key={todo.id}>{todo.title}</li>\n            ))}\n          </ul>\n        </>\n      ) : isError ? (\n        <span>Error: {error.message}</span>\n      ) : isLoading ? (\n        <span>Loading...</span>\n      ) : (\n        <span>Not ready ...</span>\n      )}\n\n\n      <div>{isFetching ? 'Fetching...' : null}</div>\n    </div>\n  )\n}\n\nPermanently disabling a query opts out of many great features that TanStack Query has to offer (like background refetches), and it's also not the idiomatic way. It takes you from the declarative approach (defining dependencies when your query should run) into an imperative mode (fetch whenever I click here). It is also not possible to pass parameters to refetch. Oftentimes, all you want is a lazy query that defers the initial fetch:\n\nLazy Queries\n\nThe enabled option can not only be used to permanently disable a query, but also to enable / disable it at a later time. A good example would be a filter form where you only want to fire off the first request once the user has entered a filter value:\n\ntsx\nfunction Todos() {\n  const [filter, setFilter] = React.useState('')\n\n\n  const { data } = useQuery({\n      queryKey: ['todos', filter],\n      queryFn: () => fetchTodos(filter),\n      // ‚¨áÔ∏è disabled as long as the filter is empty\n      enabled: !!filter\n  })\n\n\n  return (\n      <div>\n        // üöÄ applying the filter will enable and execute the query\n        <FiltersForm onApply={setFilter} />\n        {data && <TodosTable data={data}} />\n      </div>\n  )\n}\nisLoading (Previously: isInitialLoading)\n\nLazy queries will be in status: 'pending' right from the start because pending means that there is no data yet. This is technically true, however, since we are not currently fetching any data (as the query is not enabled), it also means you likely cannot use this flag to show a loading spinner.\n\nIf you are using disabled or lazy queries, you can use the isLoading flag instead. It's a derived flag that is computed from:\n\nisPending && isFetching\n\nso it will only be true if the query is currently fetching for the first time.\n"
  },
  {
    "title": "Window Focus Refetching | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/window-focus-refetching",
    "html": "Window Focus Refetching\n\nIf a user leaves your application and returns and the query data is stale, TanStack Query automatically requests fresh data for you in the background. You can disable this globally or per-query using the refetchOnWindowFocus option:\n\nDisabling Globally\ntsx\n//\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      refetchOnWindowFocus: false, // default: true\n    },\n  },\n})\n\n\nfunction App() {\n  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>\n}\nDisabling Per-Query\ntsx\nuseQuery({\n  queryKey: ['todos'],\n  queryFn: fetchTodos,\n  refetchOnWindowFocus: false,\n})\nCustom Window Focus Event\n\nIn rare circumstances, you may want to manage your own window focus events that trigger TanStack Query to revalidate. To do this, TanStack Query provides a focusManager.setEventListener function that supplies you the callback that should be fired when the window is focused and allows you to set up your own events. When calling focusManager.setEventListener, the previously set handler is removed (which in most cases will be the default handler) and your new handler is used instead. For example, this is the default handler:\n\ntsx\nfocusManager.setEventListener((handleFocus) => {\n  // Listen to visibilitychange\n  if (typeof window !== 'undefined' && window.addEventListener) {\n    window.addEventListener('visibilitychange', () => handleFocus(), false)\n    return () => {\n      // Be sure to unsubscribe if a new handler is set\n      window.removeEventListener('visibilitychange', () => handleFocus())\n    }\n  }\n})\nManaging Focus in React Native\n\nInstead of event listeners on window, React Native provides focus information through the AppState module. You can use the AppState \"change\" event to trigger an update when the app state changes to \"active\":\n\ntsx\nimport { AppState } from 'react-native'\nimport { focusManager } from '@tanstack/react-query'\n\n\nfunction onAppStateChange(status: AppStateStatus) {\n  if (Platform.OS !== 'web') {\n    focusManager.setFocused(status === 'active')\n  }\n}\n\n\nuseEffect(() => {\n  const subscription = AppState.addEventListener('change', onAppStateChange)\n\n\n  return () => subscription.remove()\n}, [])\nManaging focus state\ntsx\nimport { focusManager } from '@tanstack/react-query'\n\n\n// Override the default focus state\nfocusManager.setFocused(true)\n\n\n// Fallback to the default focus check\nfocusManager.setFocused(undefined)"
  },
  {
    "title": "Background Fetching Indicators | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/background-fetching-indicators",
    "html": "Background Fetching Indicators\n\nA query's status === 'pending' state is sufficient enough to show the initial hard-loading state for a query, but sometimes you may want to display an additional indicator that a query is refetching in the background. To do this, queries also supply you with an isFetching boolean that you can use to show that it's in a fetching state, regardless of the state of the status variable:\n\ntsx\nfunction Todos() {\n  const {\n    status,\n    data: todos,\n    error,\n    isFetching,\n  } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodos,\n  })\n\n\n  return status === 'pending' ? (\n    <span>Loading...</span>\n  ) : status === 'error' ? (\n    <span>Error: {error.message}</span>\n  ) : (\n    <>\n      {isFetching ? <div>Refreshing...</div> : null}\n\n\n      <div>\n        {todos.map((todo) => (\n          <Todo todo={todo} />\n        ))}\n      </div>\n    </>\n  )\n}\nDisplaying Global Background Fetching Loading State\n\nIn addition to individual query loading states, if you would like to show a global loading indicator when any queries are fetching (including in the background), you can use the useIsFetching hook:\n\ntsx\nimport { useIsFetching } from '@tanstack/react-query'\n\n\nfunction GlobalLoadingIndicator() {\n  const isFetching = useIsFetching()\n\n\n  return isFetching ? (\n    <div>Queries are fetching in the background...</div>\n  ) : null\n}"
  },
  {
    "title": "Parallel Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/parallel-queries",
    "html": "Parallel Queries\n\n\"Parallel\" queries are queries that are executed in parallel, or at the same time so as to maximize fetching concurrency.\n\nManual Parallel Queries\n\nWhen the number of parallel queries does not change, there is no extra effort to use parallel queries. Just use any number of TanStack Query's useQuery and useInfiniteQuery hooks side-by-side!\n\ntsx\nfunction App () {\n  // The following queries will execute in parallel\n  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })\n  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })\n  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })\n  ...\n}\n\nWhen using React Query in suspense mode, this pattern of parallelism does not work, since the first query would throw a promise internally and would suspend the component before the other queries run. To get around this, you'll either need to use the useSuspenseQueries hook (which is suggested) or orchestrate your own parallelism with separate components for each useSuspenseQuery instance.\n\nDynamic Parallel Queries with useQueries\n\nIf the number of queries you need to execute is changing from render to render, you cannot use manual querying since that would violate the rules of hooks. Instead, TanStack Query provides a useQueries hook, which you can use to dynamically execute as many queries in parallel as you'd like.\n\nuseQueries accepts an options object with a queries key whose value is an array of query objects. It returns an array of query results:\n\ntsx\nfunction App({ users }) {\n  const userQueries = useQueries({\n    queries: users.map((user) => {\n      return {\n        queryKey: ['user', user.id],\n        queryFn: () => fetchUserById(user.id),\n      }\n    }),\n  })\n}"
  },
  {
    "title": "Dependent Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/dependent-queries",
    "html": "Dependent Queries\nuseQuery dependent Query\n\nDependent (or serial) queries depend on previous ones to finish before they can execute. To achieve this, it's as easy as using the enabled option to tell a query when it is ready to run:\n\ntsx\n// Get the user\nconst { data: user } = useQuery({\n  queryKey: ['user', email],\n  queryFn: getUserByEmail,\n})\n\n\nconst userId = user?.id\n\n\n// Then get the user's projects\nconst {\n  status,\n  fetchStatus,\n  data: projects,\n} = useQuery({\n  queryKey: ['projects', userId],\n  queryFn: getProjectsByUser,\n  // The query will not execute until the userId exists\n  enabled: !!userId,\n})\n\nThe projects query will start in:\n\ntsx\nstatus: 'pending'\nisPending: true\nfetchStatus: 'idle'\n\nAs soon as the user is available, the projects query will be enabled and will then transition to:\n\ntsx\nstatus: 'pending'\nisPending: true\nfetchStatus: 'fetching'\n\nOnce we have the projects, it will go to:\n\ntsx\nstatus: 'success'\nisPending: false\nfetchStatus: 'idle'\nuseQueries dependent Query\n\nDynamic parallel query - useQueries can depend on a previous query also, here's how to achieve this:\n\ntsx\n// Get the users ids\nconst { data: userIds } = useQuery({\n  queryKey: ['users'],\n  queryFn: getUsersData,\n  select: (users) => users.map((user) => user.id),\n})\n\n\n// Then get the users messages\nconst usersMessages = useQueries({\n  queries: userIds\n    ? userIds.map((id) => {\n        return {\n          queryKey: ['messages', id],\n          queryFn: () => getMessagesByUsers(id),\n        }\n      })\n    : [], // if users is undefined, an empty array will be returned\n})\n\nNote that useQueries return an array of query results\n\nA note about performance\n\nDependent queries by definition constitutes a form of request waterfall, which hurts performance. If we pretend both queries take the same amount of time, doing them serially instead of in parallel always takes twice as much time, which is especially hurtful when it happens on a client that has high latency. If you can, it's always better to restructure the backend APIs so that both queries can be fetched in parallel, though that might not always be practically feasible.\n\nIn the example above, instead of first fetching getUserByEmail to be able to getProjectsByUser, introducing a new getProjectsByUserEmail query would flatten the waterfall.\n"
  },
  {
    "title": "Query Functions | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/query-functions",
    "html": "Query Functions\n\nA query function can be literally any function that returns a promise. The promise that is returned should either resolve the data or throw an error.\n\nAll of the following are valid query function configurations:\n\ntsx\nuseQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })\nuseQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    const data = await fetchTodoById(todoId)\n    return data\n  },\n})\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),\n})\nHandling and Throwing Errors\n\nFor TanStack Query to determine a query has errored, the query function must throw or return a rejected Promise. Any error that is thrown in the query function will be persisted on the error state of the query.\n\ntsx\nconst { error } = useQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    if (somethingGoesWrong) {\n      throw new Error('Oh no!')\n    }\n    if (somethingElseGoesWrong) {\n      return Promise.reject(new Error('Oh no!'))\n    }\n\n\n    return data\n  },\n})\nUsage with fetch and other clients that do not throw by default\n\nWhile most utilities like axios or graphql-request automatically throw errors for unsuccessful HTTP calls, some utilities like fetch do not throw errors by default. If that's the case, you'll need to throw them on your own. Here is a simple way to do that with the popular fetch API:\n\ntsx\nuseQuery({\n  queryKey: ['todos', todoId],\n  queryFn: async () => {\n    const response = await fetch('/todos/' + todoId)\n    if (!response.ok) {\n      throw new Error('Network response was not ok')\n    }\n    return response.json()\n  },\n})\nQuery Function Variables\n\nQuery keys are not just for uniquely identifying the data you are fetching, but are also conveniently passed into your query function as part of the QueryFunctionContext. While not always necessary, this makes it possible to extract your query functions if needed:\n\ntsx\nfunction Todos({ status, page }) {\n  const result = useQuery({\n    queryKey: ['todos', { status, page }],\n    queryFn: fetchTodoList,\n  })\n}\n\n\n// Access the key, status and page variables in your query function!\nfunction fetchTodoList({ queryKey }) {\n  const [_key, { status, page }] = queryKey\n  return new Promise()\n}\nQueryFunctionContext\n\nThe QueryFunctionContext is the object passed to each query function. It consists of:\n\nqueryKey: QueryKey: Query Keys\nsignal?: AbortSignal\nAbortSignal instance provided by TanStack Query\nCan be used for Query Cancellation\nmeta: Record<string, unknown> | undefined\nan optional field you can fill with additional information about your query\n\nAdditionally, Infinite Queries get the following options passed:\n\npageParam: TPageParam\nthe page parameter used to fetch the current page\ndirection: 'forward' | 'backward'\nthe direction of the current page fetch"
  },
  {
    "title": "Network Mode | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/network-mode",
    "html": "Network Mode\n\nTanStack Query provides three different network modes to distinguish how Queries and Mutations should behave if you have no network connection. This mode can be set for each Query / Mutation individually, or globally via the query / mutation defaults.\n\nSince TanStack Query is most often used for data fetching in combination with data fetching libraries, the default network mode is online.\n\nNetwork Mode: online\n\nIn this mode, Queries and Mutations will not fire unless you have network connection. This is the default mode. If a fetch is initiated for a query, it will always stay in the state (pending, error, success) it is in if the fetch cannot be made because there is no network connection. However, a fetchStatus is exposed additionally. This can be either:\n\nfetching: The queryFn is really executing - a request is in-flight.\npaused: The query is not executing - it is paused until you have connection again\nidle: The query is not fetching and not paused\n\nThe flags isFetching and isPaused are derived from this state and exposed for convenience.\n\nKeep in mind that it might not be enough to check for pending state to show a loading spinner. Queries can be in state: 'pending', but fetchStatus: 'paused' if they are mounting for the first time, and you have no network connection.\n\nIf a query runs because you are online, but you go offline while the fetch is still happening, TanStack Query will also pause the retry mechanism. Paused queries will then continue to run once you re-gain network connection. This is independent of refetchOnReconnect (which also defaults to true in this mode), because it is not a refetch, but rather a continue. If the query has been cancelled in the meantime, it will not continue.\n\nNetwork Mode: always\n\nIn this mode, TanStack Query will always fetch and ignore the online / offline state. This is likely the mode you want to choose if you use TanStack Query in an environment where you don't need an active network connection for your Queries to work - e.g. if you just read from AsyncStorage, or if you just want to return Promise.resolve(5) from your queryFn.\n\nQueries will never be paused because you have no network connection.\nRetries will also not pause - your Query will go to error state if it fails.\nrefetchOnReconnect defaults to false in this mode, because reconnecting to the network is not a good indicator anymore that stale queries should be refetched. You can still turn it on if you want.\nNetwork Mode: offlineFirst\n\nThis mode is the middle ground between the first two options, where TanStack Query will run the queryFn once, but then pause retries. This is very handy if you have a serviceWorker that intercepts a request for caching like in an offline-first PWA, or if you use HTTP caching via the Cache-Control header.\n\nIn those situations, the first fetch might succeed because it comes from an offline storage / cache. However, if there is a cache miss, the network request will go out and fail, in which case this mode behaves like an online query - pausing retries.\n\nDevtools\n\nThe TanStack Query Devtools will show Queries in a paused state if they would be fetching, but there is no network connection. There is also a toggle button to Mock offline behavior. Please note that this button will not actually mess with your network connection (you can do that in the browser devtools), but it will set the OnlineManager in an offline state.\n\nSignature\nnetworkMode: 'online' | 'always' | 'offlineFirst'\noptional\ndefaults to 'online'"
  },
  {
    "title": "Query Keys | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/query-keys",
    "html": "Query Keys\n\nAt its core, TanStack Query manages query caching for you based on query keys. Query keys have to be an Array at the top level, and can be as simple as an Array with a single string, or as complex as an array of many strings and nested objects. As long as the query key is serializable, and unique to the query's data, you can use it!\n\nSimple Query Keys\n\nThe simplest form of a key is an array with constants values. This format is useful for:\n\nGeneric List/Index resources\nNon-hierarchical resources\ntsx\n// A list of todos\nuseQuery({ queryKey: ['todos'], ... })\n\n\n// Something else, whatever!\nuseQuery({ queryKey: ['something', 'special'], ... })\nArray Keys with variables\n\nWhen a query needs more information to uniquely describe its data, you can use an array with a string and any number of serializable objects to describe it. This is useful for:\n\nHierarchical or nested resources\nIt's common to pass an ID, index, or other primitive to uniquely identify the item\nQueries with additional parameters\nIt's common to pass an object of additional options\ntsx\n// An individual todo\nuseQuery({ queryKey: ['todo', 5], ... })\n\n\n// An individual todo in a \"preview\" format\nuseQuery({ queryKey: ['todo', 5, { preview: true }], ...})\n\n\n// A list of todos that are \"done\"\nuseQuery({ queryKey: ['todos', { type: 'done' }], ... })\nQuery Keys are hashed deterministically!\n\nThis means that no matter the order of keys in objects, all of the following queries are considered equal:\n\ntsx\nuseQuery({ queryKey: ['todos', { status, page }], ... })\nuseQuery({ queryKey: ['todos', { page, status }], ...})\nuseQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })\n\nThe following query keys, however, are not equal. Array item order matters!\n\ntsx\nuseQuery({ queryKey: ['todos', status, page], ... })\nuseQuery({ queryKey: ['todos', page, status], ...})\nuseQuery({ queryKey: ['todos', undefined, page, status], ...})\nIf your query function depends on a variable, include it in your query key\n\nSince query keys uniquely describe the data they are fetching, they should include any variables you use in your query function that change. For example:\n\ntsx\nfunction Todos({ todoId }) {\n  const result = useQuery({\n    queryKey: ['todos', todoId],\n    queryFn: () => fetchTodoById(todoId),\n  })\n}\n\nNote that query keys act as dependencies for your query functions. Adding dependent variables to your query key will ensure that queries are cached independently, and that any time a variable changes, queries will be refetched automatically (depending on your staleTime settings). See the exhaustive-deps section for more information and examples.\n\nFurther reading\n\nFor tips on organizing Query Keys in larger applications, have a look at Effective React Query Keys and check the Query Key Factory Package from the Community Resources.\n"
  },
  {
    "title": "Queries | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/queries",
    "html": "Queries\nQuery Basics\n\nA query is a declarative dependency on an asynchronous source of data that is tied to a unique key. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method modifies data on the server, we recommend using Mutations instead.\n\nTo subscribe to a query in your components or custom hooks, call the useQuery hook with at least:\n\nA unique key for the query\nA function that returns a promise that:\nResolves the data, or\nThrows an error\ntsx\nimport { useQuery } from '@tanstack/react-query'\n\n\nfunction App() {\n  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n}\n\nThe unique key you provide is used internally for refetching, caching, and sharing your queries throughout your application.\n\nThe query result returned by useQuery contains all of the information about the query that you'll need for templating and any other usage of the data:\n\ntsx\nconst result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })\n\nThe result object contains a few very important states you'll need to be aware of to be productive. A query can only be in one of the following states at any given moment:\n\nisPending or status === 'pending' - The query has no data yet\nisError or status === 'error' - The query encountered an error\nisSuccess or status === 'success' - The query was successful and data is available\n\nBeyond those primary states, more information is available depending on the state of the query:\n\nerror - If the query is in an isError state, the error is available via the error property.\ndata - If the query is in an isSuccess state, the data is available via the data property.\nisFetching - In any state, if the query is fetching at any time (including background refetching) isFetching will be true.\n\nFor most queries, it's usually sufficient to check for the isPending state, then the isError state, then finally, assume that the data is available and render the successful state:\n\ntsx\nfunction Todos() {\n  const { isPending, isError, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n\n  if (isPending) {\n    return <span>Loading...</span>\n  }\n\n\n  if (isError) {\n    return <span>Error: {error.message}</span>\n  }\n\n\n  // We can assume by this point that `isSuccess === true`\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nIf booleans aren't your thing, you can always use the status state as well:\n\ntsx\nfunction Todos() {\n  const { status, data, error } = useQuery({\n    queryKey: ['todos'],\n    queryFn: fetchTodoList,\n  })\n\n\n  if (status === 'pending') {\n    return <span>Loading...</span>\n  }\n\n\n  if (status === 'error') {\n    return <span>Error: {error.message}</span>\n  }\n\n\n  // also status === 'success', but \"else\" logic works, too\n  return (\n    <ul>\n      {data.map((todo) => (\n        <li key={todo.id}>{todo.title}</li>\n      ))}\n    </ul>\n  )\n}\n\nTypeScript will also narrow the type of data correctly if you've checked for pending and error before accessing it.\n\nFetchStatus\n\nIn addition to the status field, you will also get an additional fetchStatus property with the following options:\n\nfetchStatus === 'fetching' - The query is currently fetching.\nfetchStatus === 'paused' - The query wanted to fetch, but it is paused. Read more about this in the Network Mode guide.\nfetchStatus === 'idle' - The query is not doing anything at the moment.\nWhy two different states?\n\nBackground refetches and stale-while-revalidate logic make all combinations for status and fetchStatus possible. For example:\n\na query in success status will usually be in idle fetchStatus, but it could also be in fetching if a background refetch is happening.\na query that mounts and has no data will usually be in pending status and fetching fetchStatus, but it could also be paused if there is no network connection.\n\nSo keep in mind that a query can be in pending state without actually fetching data. As a rule of thumb:\n\nThe status gives information about the data: Do we have any or not?\nThe fetchStatus gives information about the queryFn: Is it running or not?\nFurther Reading\n\nFor an alternative way of performing status checks, have a look at the Community Resources.\n"
  },
  {
    "title": "React Native | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/react-native",
    "html": "React Native\n\nReact Query is designed to work out of the box with React Native, with the exception of the devtools, which are only supported with React DOM at this time.\n\nThere is a 3rd party Flipper plugin which you can try: https://github.com/bgaleotti/react-query-native-devtools\n\nThere is a 3rd party Reactotron plugin which you can try: https://github.com/hsndmr/reactotron-react-query\n\nIf you would like to help us make the built-in devtools platform agnostic, please let us know!\n\nOnline status management\n\nReact Query already supports auto refetch on reconnect in web browser. To add this behavior in React Native you have to use React Query onlineManager as in the example below:\n\ntsx\nimport NetInfo from '@react-native-community/netinfo'\nimport { onlineManager } from '@tanstack/react-query'\n\n\nonlineManager.setEventListener(setOnline => {\n  return NetInfo.addEventListener(state => {\n    setOnline(!!state.isConnected)\n  })\n})\nRefetch on App focus\n\nInstead of event listeners on window, React Native provides focus information through the AppState module. You can use the AppState \"change\" event to trigger an update when the app state changes to \"active\":\n\ntsx\nimport { useEffect } from \"react\"\nimport { AppState, Platform } from 'react-native'\nimport type { AppStateStatus } from \"react-native\"\nimport { focusManager } from '@tanstack/react-query'\n\n\nfunction onAppStateChange(status: AppStateStatus) {\n  if (Platform.OS !== 'web') {\n    focusManager.setFocused(status === 'active')\n  }\n}\n\n\nuseEffect(() => {\n  const subscription = AppState.addEventListener('change', onAppStateChange)\n\n\n  return () => subscription.remove()\n}, [])\nRefresh on Screen focus\n\nIn some situations, you may want to refetch the query when a React Native Screen is focused again. This custom hook will call the provided refetch function when the screen is focused again.\n\ntsx\nimport React from 'react'\nimport { useFocusEffect } from '@react-navigation/native'\n\n\nexport function useRefreshOnFocus<T>(refetch: () => Promise<T>) {\n  const firstTimeRef = React.useRef(true)\n\n\n  useFocusEffect(\n    React.useCallback(() => {\n      if (firstTimeRef.current) {\n         firstTimeRef.current = false;\n         return;\n      }\n\n\n      refetch()\n    }, [refetch])\n  )\n}\n\nIn the above code, refetch is skipped the first time because useFocusEffect calls our callback on mount in addition to screen focus.\n\nDisable re-renders on out of focus Screens\n\nIn some situations, including performance concerns, you may want to stop re-renders when a React Native screen gets out of focus. To achieve this we can use useFocusEffect from @react-navigation/native together with the notifyOnChangeProps query option.\n\nThis custom hook provides a notifyOnChangeProps option that will return an empty array whenever a screen goes out of focus - effectively stopping any re-renders on that scenario. Whenever the screens gets in focus again, the behavior goes back to normal.\n\ntsx\nimport React from 'react'\nimport { NotifyOnChangeProps } from '@tanstack/query-core'\nimport { useFocusEffect } from '@react-navigation/native'\n\n\nexport function useFocusNotifyOnChangeProps(notifyOnChangeProps?: NotifyOnChangeProps) {\n  const focusedRef = React.useRef(true)\n\n\n  useFocusEffect(\n    React.useCallback(() => {\n      focusedRef.current = true\n\n\n      return () => {\n        focusedRef.current = false\n      }\n    }, [])\n  )\n\n\n  return () => {\n    if (!focusedRef.current) {\n      return []\n    }\n\n\n    if (typeof notifyOnChangeProps === 'function') {\n      return notifyOnChangeProps()\n    }\n\n\n    return notifyOnChangeProps.current\n  }\n}\n\nIn the above code, useFocusEffect is used to change the value of a reference that the callback will use as a condition.\n\nThe argument is wrapped in a reference to also guarantee that the returned callback always keeps the same reference.\n\nExample usage:\n\ntsx\nfunction MyComponent() {\n  const notifyOnChangeProps = useFocusNotifyOnChangeProps();\n\n\n  const { dataUpdatedAt } = useQuery({\n    queryKey: ['myKey'],\n    queryFn: async () => {\n      const response = await fetch('https://api.github.com/repos/tannerlinsley/react-query');\n      return response.json();\n    },\n    notifyOnChangeProps,\n  });\n\n\n  return <div>DataUpdatedAt: {dataUpdatedAt}</div>;\n};"
  },
  {
    "title": "Important Defaults | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/guides/important-defaults",
    "html": "Important Defaults\n\nOut of the box, TanStack Query is configured with aggressive but sane defaults. Sometimes these defaults can catch new users off guard or make learning/debugging difficult if they are unknown by the user. Keep them in mind as you continue to learn and use TanStack Query:\n\nQuery instances via useQuery or useInfiniteQuery by default consider cached data as stale.\n\nTo change this behavior, you can configure your queries both globally and per-query using the staleTime option. Specifying a longer staleTime means queries will not refetch their data as often\n\nStale queries are refetched automatically in the background when:\nNew instances of the query mount\nThe window is refocused\nThe network is reconnected\nThe query is optionally configured with a refetch interval\n\nTo change this functionality, you can use options like refetchOnMount, refetchOnWindowFocus, refetchOnReconnect and refetchInterval.\n\nQuery results that have no more active instances of useQuery, useInfiniteQuery or query observers are labeled as \"inactive\" and remain in the cache in case they are used again at a later time.\n\nBy default, \"inactive\" queries are garbage collected after 5 minutes.\n\nTo change this, you can alter the default gcTime for queries to something other than 1000 * 60 * 5 milliseconds.\n\nQueries that fail are silently retried 3 times, with exponential backoff delay before capturing and displaying an error to the UI.\n\nTo change this, you can alter the default retry and retryDelay options for queries to something other than 3 and the default exponential backoff function.\n\nQuery results by default are structurally shared to detect if data has actually changed and if not, the data reference remains unchanged to better help with value stabilization with regards to useMemo and useCallback. If this concept sounds foreign, then don't worry about it! 99.9% of the time you will not need to disable this and it makes your app more performant at zero cost to you.\n\nStructural sharing only works with JSON-compatible values, any other value types will always be considered as changed. If you are seeing performance issues because of large responses for example, you can disable this feature with the config.structuralSharing flag. If you are dealing with non-JSON compatible values in your query responses and still want to detect if data has changed or not, you can provide your own custom function as config.structuralSharing to compute a value from the old and new responses, retaining references as required.\n\nFurther Reading\n\nHave a look at the following articles from our Community Resources for further explanations of the defaults:\n\nPractical React Query\nReact Query as a State Manager"
  },
  {
    "title": "GraphQL | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/graphql",
    "html": "GraphQL\n\nBecause React Query's fetching mechanisms are agnostically built on Promises, you can use React Query with literally any asynchronous data fetching client, including GraphQL!\n\nKeep in mind that React Query does not support normalized caching. While a vast majority of users do not actually need a normalized cache or even benefit from it as much as they believe they do, there may be very rare circumstances that may warrant it so be sure to check with us first to make sure it's truly something you need!\n\nType-Safety and Code Generation\n\nReact Query, used in combination with graphql-request^5 and GraphQL Code Generator provides full-typed GraphQL operations:\n\ntsx\nimport request from 'graphql-request'\nimport { useQuery } from '@tanstack/react-query'\n\n\nimport { graphql } from './gql/gql'\n\n\nconst allFilmsWithVariablesQueryDocument = graphql(/* GraphQL */ `\n  query allFilmsWithVariablesQuery($first: Int!) {\n    allFilms(first: $first) {\n      edges {\n        node {\n          id\n          title\n        }\n      }\n    }\n  }\n`)\n\n\nfunction App() {\n  // `data` is fully typed!\n  const { data } = useQuery({\n    queryKey: ['films'],\n    queryFn: async () =>\n      request(\n        'https://swapi-graphql.netlify.app/.netlify/functions/index',\n        allFilmsWithVariablesQueryDocument,\n        // variables are type-checked too!\n        { first: 10 },\n      ),\n  })\n  // ...\n}\n\nYou can find a complete example in the repo\n\nGet started with the dedicated guide on GraphQL Code Generator documentation.\n"
  },
  {
    "title": "TypeScript | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/typescript",
    "html": "TypeScript\n\nReact Query is now written in TypeScript to make sure the library and your projects are type-safe!\n\nThings to keep in mind:\n\nTypes currently require using TypeScript v4.7 or greater\nChanges to types in this repository are considered non-breaking and are usually released as patch semver changes (otherwise every type enhancement would be a major version!).\nIt is highly recommended that you lock your react-query package version to a specific patch release and upgrade with the expectation that types may be fixed or upgraded between any release\nThe non-type-related public API of React Query still follows semver very strictly.\nType Inference\n\nTypes in React Query generally flow through very well so that you don't have to provide type annotations for yourself\n\ntsx\nconst { data } = useQuery({\n  //    ^? const data: number | undefined\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n})\n\ntypescript playground\n\ntsx\nconst { data } = useQuery({\n  //      ^? const data: string | undefined\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n  select: (data) => data.toString(),\n})\n\ntypescript playground\n\nThis works best if your queryFn has a well-defined returned type. Keep in mind that most data fetching libraries return any per default, so make sure to extract it to a properly typed function:\n\ntsx\nconst fetchGroups = (): Promise<Group[]> =>\n  axios.get('/groups').then((response) => response.data)\n\n\nconst { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const data: Group[] | undefined\n\ntypescript playground\n\nType Narrowing\n\nReact Query uses a discriminated union type for the query result, discriminated by the status field and the derived status boolean flags. This will allow you to check for e.g. success status to make data defined:\n\ntsx\nconst { data, isSuccess } = useQuery({\n  queryKey: ['test'],\n  queryFn: () => Promise.resolve(5),\n})\n\n\nif (isSuccess) {\n  data\n  //  ^? const data: number\n}\n\ntypescript playground\n\nTyping the error field\n\nThe type for error defaults to Error, because that is what most users expect.\n\ntsx\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Error\n\ntypescript playground\n\nIf you want to throw a custom error, or something that isn't an Error at all, you can specify the type of the error field:\n\ntsx\nconst { error } = useQuery<Group[], string>(['groups'], fetchGroups)\n//      ^? const error: string | null\n\nHowever, this has the drawback that type inference for all other generics of useQuery will not work anymore. It is generally not considered a good practice to throw something that isn't an Error, so if you have a subclass like AxiosError you can use type narrowing to make the error field more specific:\n\ntsx\nimport axios from 'axios'\n\n\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: Error | null\n\n\nif (axios.isAxiosError(error)) {\n  error\n  // ^? const error: AxiosError\n}\n\ntypescript playground\n\nRegistering a global Error\n\nTanStack Query v5 allows for a way to set a global Error type for everything, without having to specify generics on call-sides, by amending the Register interface. This will make sure inference still works, but the error field will be of the specified type:\n\ntsx\nimport '@tanstack/react-query';\n\n\ndeclare module '@tanstack/react-query' {\n  interface Register {\n    defaultError: AxiosError\n  }\n}\n\n\nconst { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })\n//      ^? const error: AxiosError | null\nTyping meta Registering global Meta\n\nSimilarly to registering a global error type you can also register a global Meta type. This ensures the optional meta field on queries and mutations stays consistent and is type-safe.\n\nts\nimport '@tanstack/react-query';\n\n\ndeclare module '@tanstack/react-query' {\n  interface Register {\n    queryMeta: MyMeta,\n    mutationMeta: MyMeta\n  }\n}\nTyping Query Options\n\nIf you inline query options into useQuery, you'll get automatic type inference. However, you might want to extract the query options into a separate function to share them between useQuery and e.g. prefetchQuery. In that case, you'd lose type inference. To get it back, you can use queryOptions helper:\n\nts\nimport { queryOptions } from '@tanstack/react-query'\n\n\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\n\nuseQuery(groupOptions())\nqueryClient.prefetchQuery(groupOptions())\n\nFurther, the queryKey returned from queryOptions knows about the queryFn associated with it, and we can leverage that type information to make functions like queryClient.getQueryData aware of those types as well:\n\nts\nfunction groupOptions() {\n  return queryOptions({\n    queryKey: ['groups'],\n    queryFn: fetchGroups,\n    staleTime: 5 * 1000,\n  })\n}\n\n\nconst data = queryClient.getQueryData(groupOptions().queryKey)\n//     ^? const data: Group[] | undefined\n\nWithout queryOptions, the type of data would be unknown, unless we'd pass a generic to it:\n\nts\nconst data = queryClient.getQueryData<Group[]>(['groups'])\nFurther Reading\n\nFor tips and tricks around type inference, have a look at React Query and TypeScript from the Community Resources. To find out how to get the best possible type-safety, you can read Type-safe React Query.\n"
  },
  {
    "title": "Videos & Talks | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/videos",
    "html": "Videos & Talks\n\nClick here to view the Repository used for the above presentation\n"
  },
  {
    "title": "Comparison | React Query vs SWR vs Apollo vs RTK Query vs React Router | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/comparison",
    "html": "Comparison | React Query vs SWR vs Apollo vs RTK Query vs React Router\n\nThis comparison table strives to be as accurate and as unbiased as possible. If you use any of these libraries and feel the information could be improved, feel free to suggest changes (with notes or evidence of claims) using the link at the bottom of this page.\n\nFeature/Capability Key:\n\n‚úÖ 1st-class, built-in, and ready to use with no added configuration or code\nüü° Supported, but as an unofficial 3rd party or community library/contribution\nüî∂ Supported and documented, but requires extra user-code to implement\nüõë Not officially supported or documented.\n\tReact Query\tSWR (Website)\tApollo Client (Website)\tRTK-Query (Website)\tReact Router (Website)\nGithub Repo / Stars\t\n\t\n\t\n\t\n\t\n\nPlatform Requirements\tReact\tReact\tReact, GraphQL\tRedux\tReact\nTheir Comparison\t\t(none)\t(none)\tComparison\t(none)\nSupported Query Syntax\tPromise, REST, GraphQL\tPromise, REST, GraphQL\tGraphQL, Any (Reactive Variables)\tPromise, REST, GraphQL\tPromise, REST, GraphQL\nSupported Frameworks\tReact\tReact\tReact + Others\tAny\tReact\nCaching Strategy\tHierarchical Key -> Value\tUnique Key -> Value\tNormalized Schema\tUnique Key -> Value\tNested Route -> value\nCache Key Strategy\tJSON\tJSON\tGraphQL Query\tJSON\tRoute Path\nCache Change Detection\tDeep Compare Keys (Stable Serialization)\tDeep Compare Keys (Stable Serialization)\tDeep Compare Keys (Unstable Serialization)\tKey Referential Equality (===)\tRoute Change\nData Change Detection\tDeep Comparison + Structural Sharing\tDeep Compare (via stable-hash)\tDeep Compare (Unstable Serialization)\tKey Referential Equality (===)\tLoader Run\nData Memoization\tFull Structural Sharing\tIdentity (===)\tNormalized Identity\tIdentity (===)\tIdentity (===)\nBundle Size\t\n\t\n\t\n\t\n\t\n+\n\nAPI Definition Location\tComponent, External Config\tComponent\tGraphQL Schema\tExternal Config\tRoute Tree Configuration\nQueries\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nCache Persistence\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\tüõë Active Routes Only 8\nDevtools\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\tüõë\nPolling/Intervals\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\tüõë\nParallel Queries\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nDependent Queries\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nPaginated Queries\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nInfinite Queries\t‚úÖ\t‚úÖ\t‚úÖ\tüõë\tüõë\nBi-directional Infinite Queries\t‚úÖ\tüî∂\tüî∂\tüõë\tüõë\nInfinite Query Refetching\t‚úÖ\t‚úÖ\tüõë\tüõë\tüõë\nLagged Query Data1\t‚úÖ\t‚úÖ\tüõë\t‚úÖ\t‚úÖ\nSelectors\t‚úÖ\tüõë\t‚úÖ\t‚úÖ\tN/A\nInitial Data\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nScroll Recovery\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nCache Manipulation\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\tüõë\nOutdated Query Dismissal\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nRender Batching & Optimization2\t‚úÖ\t‚úÖ\tüõë\t‚úÖ\t‚úÖ\nAuto Garbage Collection\t‚úÖ\tüõë\tüõë\t‚úÖ\tN/A\nMutation Hooks\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nOffline Mutation Support\t‚úÖ\tüõë\tüü°\tüõë\tüõë\nPrefetching APIs\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\nQuery Cancellation\t‚úÖ\tüõë\tüõë\tüõë\t‚úÖ\nPartial Query Matching3\t‚úÖ\tüî∂\tüõë\t‚úÖ\tN/A\nStale While Revalidate\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\tüõë\nStale Time Configuration\t‚úÖ\tüõë7\tüõë\t‚úÖ\tüõë\nPre-usage Query/Mutation Configuration4\t‚úÖ\tüõë\tüõë\t‚úÖ\t‚úÖ\nWindow Focus Refetching\t‚úÖ\t‚úÖ\tüõë\t‚úÖ\tüõë\nNetwork Status Refetching\t‚úÖ\t‚úÖ\t‚úÖ\t‚úÖ\tüõë\nGeneral Cache Dehydration/Rehydration\t‚úÖ\tüõë\t‚úÖ\t‚úÖ\t‚úÖ\nOffline Caching\t‚úÖ\tüõë\t‚úÖ\tüî∂\tüõë\nReact Suspense\t‚úÖ\t‚úÖ\tüõë\tüõë\t‚úÖ\nAbstracted/Agnostic Core\t‚úÖ\tüõë\t‚úÖ\t‚úÖ\tüõë\nAutomatic Refetch after Mutation5\tüî∂\tüî∂\t‚úÖ\t‚úÖ\t‚úÖ\nNormalized Caching6\tüõë\tüõë\t‚úÖ\tüõë\tüõë\nNotes\n\n1 Lagged Query Data - React Query provides a way to continue to see an existing query's data while the next query loads (similar to the same UX that suspense will soon provide natively). This is extremely important when writing pagination UIs or infinite loading UIs where you do not want to show a hard loading state whenever a new query is requested. Other libraries do not have this capability and render a hard loading state for the new query (unless it has been prefetched), while the new query loads.\n\n2 Render Optimization - React Query has excellent rendering performance. By default, it will automatically track which fields are accessed and only re-render if one of them changes. If you would like to opt-out of this optimization, setting notifyOnChangeProps to 'all' will re-render your components whenever the query is updated. For example because it has new data, or to indicate it is fetching. React Query also batches updates together to make sure your application only re-renders once when multiple components are using the same query. If you are only interested in the data or error properties, you can reduce the number of renders even more by setting notifyOnChangeProps to ['data', 'error'].\n\n3 Partial query matching - Because React Query uses deterministic query key serialization, this allows you to manipulate variable groups of queries without having to know each individual query-key that you want to match, eg. you can refetch every query that starts with todos in its key, regardless of variables, or you can target specific queries with (or without) variables or nested properties, and even use a filter function to only match queries that pass your specific conditions.\n\n4 Pre-usage Query Configuration - This is simply a fancy name for being able to configure how queries and mutations will behave before they are used. For instance, a query can be fully configured with defaults beforehand and when the time comes to use it, only useQuery({ queryKey }) is necessary, instead of being required to pass the fetcher and/or options with every usage. SWR does have a partial form of this feature by allowing you to pre-configure a default fetcher, but only as a global fetcher, not on a per-query basis and definitely not for mutations.\n\n5 Automatic Refetch after Mutation - For truly automatic refetching to happen after a mutation occurs, a schema is necessary (like the one graphQL provides) along with heuristics that help the library know how to identify individual entities and entities types in that schema.\n\n6 Normalized Caching - React Query, SWR and RTK-Query do not currently support automatic-normalized caching which describes storing entities in a flat architecture to avoid some high-level data duplication.\n\n7 SWR's Immutable Mode - SWR ships with an \"immutable\" mode that does allow you to only fetch a query once for the life of the cache, but it still does not have the concept of stale-time or conditional auto-revalidation\n\n8 React Router cache persistence - React Router does not cache data beyond the currently matched routes. If a route is left, its data is lost.\n"
  },
  {
    "title": "Devtools | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/devtools",
    "html": "Devtools\n\nWave your hands in the air and shout hooray because React Query comes with dedicated devtools! ü•≥\n\nWhen you begin your React Query journey, you'll want these devtools by your side. They help visualize all of the inner workings of React Query and will likely save you hours of debugging if you find yourself in a pinch!\n\nPlease note that for now, the devtools do not support React Native. If you would like to help us make the devtools platform agnostic, please let us know!\n\nAlso note that you can use these devtools to observe queries, but not mutations\n\nInstall and Import the Devtools\n\nThe devtools are a separate package that you need to install:\n\nbash\n$ npm i @tanstack/react-query-devtools\n# or\n$ pnpm add @tanstack/react-query-devtools\n# or\n$ yarn add @tanstack/react-query-devtools\n\nFor Next 13+ App Dir you must install it as a dev dependency for it to work.\n\nYou can import the devtools like this:\n\ntsx\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\n\nBy default, React Query Devtools are only included in bundles when process.env.NODE_ENV === 'development', so you don't need to worry about excluding them during a production build.\n\nFloating Mode\n\nFloating Mode will mount the devtools as a fixed, floating element in your app and provide a toggle in the corner of the screen to show and hide the devtools. This toggle state will be stored and remembered in localStorage across reloads.\n\nPlace the following code as high in your React app as you can. The closer it is to the root of the page, the better it will work!\n\ntsx\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\n\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* The rest of your application */}\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  )\n}\nOptions\ninitialIsOpen: Boolean\nSet this true if you want the dev tools to default to being open\nbuttonPosition?: \"top-left\" | \"top-right\" | \"bottom-left\" | \"bottom-right\"\nDefaults to bottom-left\nThe position of the React Query logo to open and close the devtools panel\nposition?: \"top\" | \"bottom\" | \"left\" | \"right\"\nDefaults to bottom\nThe position of the React Query devtools panel\nclient?: QueryClient,\nUse this to use a custom QueryClient. Otherwise, the one from the nearest context will be used.\nerrorTypes?: { name: string; initializer: (query: Query) => TError}\nUse this to predefine some errors that can be triggered on your queries. Initializer will be called (with the specific query) when that error is toggled on from the UI. It must return an Error.\nstyleNonce?: string\nUse this to pass a nonce to the style tag that is added to the document head. This is useful if you are using a Content Security Policy (CSP) nonce to allow inline styles.\nDevtools in production\n\nDevtools are excluded in production builds. However, it might be desirable to lazy load the devtools in production:\n\ntsx\nimport * as React from 'react'\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query'\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools'\nimport { Example } from './Example'\n\n\nconst queryClient = new QueryClient()\n\n\nconst ReactQueryDevtoolsProduction = React.lazy(() =>\n  import('@tanstack/react-query-devtools/build/modern/production.js').then(\n    (d) => ({\n      default: d.ReactQueryDevtools,\n    }),\n  ),\n)\n\n\nfunction App() {\n  const [showDevtools, setShowDevtools] = React.useState(false)\n\n\n  React.useEffect(() => {\n    // @ts-ignore\n    window.toggleDevtools = () => setShowDevtools((old) => !old)\n  }, [])\n\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n      <ReactQueryDevtools initialIsOpen />\n      {showDevtools && (\n        <React.Suspense fallback={null}>\n          <ReactQueryDevtoolsProduction />\n        </React.Suspense>\n      )}\n    </QueryClientProvider>\n  )\n}\n\n\nexport default App\n\nWith this, calling window.toggleDevtools() will download the devtools bundle and show them.\n\nModern bundlers\n\nIf your bundler supports package exports, you can use the following import path:\n\ntsx\nconst ReactQueryDevtoolsProduction = React.lazy(() =>\n  import('@tanstack/react-query-devtools/production').then((d) => ({\n    default: d.ReactQueryDevtools,\n  })),\n)\n\nFor TypeScript, you would need to set moduleResolution: 'nodenext' in your tsconfig, which requires at least TypeScript v4.7.\n"
  },
  {
    "title": "Quick Start | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/quick-start",
    "html": "Quick Start\n\nThis code snippet very briefly illustrates the 3 core concepts of React Query:\n\nQueries\nMutations\nQuery Invalidation\n\nIf you're looking for a fully functioning example, please have a look at our simple codesandbox example\n\ntsx\nimport {\n  useQuery,\n  useMutation,\n  useQueryClient,\n  QueryClient,\n  QueryClientProvider,\n} from '@tanstack/react-query'\nimport { getTodos, postTodo } from '../my-api'\n\n\n// Create a client\nconst queryClient = new QueryClient()\n\n\nfunction App() {\n  return (\n    // Provide the client to your App\n    <QueryClientProvider client={queryClient}>\n      <Todos />\n    </QueryClientProvider>\n  )\n}\n\n\nfunction Todos() {\n  // Access the client\n  const queryClient = useQueryClient()\n\n\n  // Queries\n  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })\n\n\n  // Mutations\n  const mutation = useMutation({\n    mutationFn: postTodo,\n    onSuccess: () => {\n      // Invalidate and refetch\n      queryClient.invalidateQueries({ queryKey: ['todos'] })\n    },\n  })\n\n\n  return (\n    <div>\n      <ul>\n        {query.data?.map((todo) => (\n          <li key={todo.id}>{todo.title}</li>\n        ))}\n      </ul>\n\n\n      <button\n        onClick={() => {\n          mutation.mutate({\n            id: Date.now(),\n            title: 'Do Laundry',\n          })\n        }}\n      >\n        Add Todo\n      </button>\n    </div>\n  )\n}\n\n\nrender(<App />, document.getElementById('root'))\n\nThese three concepts make up most of the core functionality of React Query. The next sections of the documentation will go over each of these core concepts in great detail.\n"
  },
  {
    "title": "Installation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/installation",
    "html": "Installation\n\nYou can install React Query via NPM, or a good ol' <script> via ESM.sh.\n\nNPM\nbash\n$ npm i @tanstack/react-query\n# or\n$ pnpm add @tanstack/react-query\n# or\n$ yarn add @tanstack/react-query\n\nReact Query is compatible with React v18+ and works with ReactDOM and React Native.\n\nWanna give it a spin before you download? Try out the simple or basic examples!\n\nCDN\n\nIf you're not using a module bundler or package manager, you can also use this library via an ESM-compatible CDN such as ESM.sh. Simply add a <script type=\"module\"> tag to the bottom of your HTML file:\n\nhtml\n<script type=\"module\">\n  import React from 'https://esm.sh/react@18.2.0'\n  import ReactDOM from 'https://esm.sh/react-dom@18.2.0'\n  import { QueryClient } from 'https://esm.sh/@tanstack/react-query'\n</script>\n\nYou can find instructions on how to use React without JSX here.\n\nRequirements\n\nReact Query is optimized for modern browsers. It is compatible with the following browsers config\n\nbash\nChrome >= 91\nFirefox >= 90\nEdge >= 91\nSafari >= 15\niOS >= 15\nopera >= 77\n\nDepending on your environment, you might need to add polyfills. If you want to support older browsers, you need to transpile the library from node_modules yourselves.\n\nRecommendations\n\nIt is recommended to also use our ESLint Plugin Query to help you catch bugs and inconsistencies while you code. You can install it via:\n\nbash\n$ npm i -D @tanstack/eslint-plugin-query\n# or\n$ pnpm add -D @tanstack/eslint-plugin-query\n# or\n$ yarn add -D @tanstack/eslint-plugin-query"
  },
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/react/overview",
    "html": "Overview\n\nTanStack Query (FKA React Query) is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web applications a breeze.\n\nMotivation\n\nMost core web frameworks do not come with an opinionated way of fetching or updating data in a holistic way. Because of this developers end up building either meta-frameworks which encapsulate strict opinions about data-fetching, or they invent their own ways of fetching data. This usually means cobbling together component-based state and side-effects, or using more general purpose state management libraries to store and provide asynchronous data throughout their apps.\n\nWhile most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:\n\nIs persisted remotely in a location you do not control or own\nRequires asynchronous APIs for fetching and updating\nImplies shared ownership and can be changed by other people without your knowledge\nCan potentially become \"out of date\" in your applications if you're not careful\n\nOnce you grasp the nature of server state in your application, even more challenges will arise as you go, for example:\n\nCaching... (possibly the hardest thing to do in programming)\nDeduping multiple requests for the same data into a single request\nUpdating \"out of date\" data in the background\nKnowing when data is \"out of date\"\nReflecting updates to data as quickly as possible\nPerformance optimizations like pagination and lazy loading data\nManaging memory and garbage collection of server state\nMemoizing query results with structural sharing\n\nIf you're not overwhelmed by that list, then that must mean that you've probably solved all of your server state problems already and deserve an award. However, if you are like a vast majority of people, you either have yet to tackle all or most of these challenges and we're only scratching the surface!\n\nReact Query is hands down one of the best libraries for managing server state. It works amazingly well out-of-the-box, with zero-config, and can be customized to your liking as your application grows.\n\nReact Query allows you to defeat and overcome the tricky challenges and hurdles of server state and control your app data before it starts to control you.\n\nOn a more technical note, React Query will likely:\n\nHelp you remove many lines of complicated and misunderstood code from your application and replace with just a handful of lines of React Query logic.\nMake your application more maintainable and easier to build new features without worrying about wiring up new server state data sources\nHave a direct impact on your end-users by making your application feel faster and more responsive than ever before.\nPotentially help you save on bandwidth and increase memory performance\nEnough talk, show me some code already!\n\nIn the example below, you can see React Query in its most basic and simple form being used to fetch the GitHub stats for the React Query GitHub project itself:\n\nOpen in CodeSandbox\n\ntsx\nimport {\n  QueryClient,\n  QueryClientProvider,\n  useQuery,\n} from '@tanstack/react-query'\n\n\nconst queryClient = new QueryClient()\n\n\nexport default function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Example />\n    </QueryClientProvider>\n  )\n}\n\n\nfunction Example() {\n  const { isPending, error, data } = useQuery({\n    queryKey: ['repoData'],\n    queryFn: () =>\n      fetch('https://api.github.com/repos/TanStack/query').then(\n        (res) => res.json(),\n      ),\n  })\n\n\n  if (isPending) return 'Loading...'\n\n\n  if (error) return 'An error has occurred: ' + error.message\n\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <p>{data.description}</p>\n      <strong>üëÄ {data.subscribers_count}</strong>{' '}\n      <strong>‚ú® {data.stargazers_count}</strong>{' '}\n      <strong>üç¥ {data.forks_count}</strong>\n    </div>\n  )\n}"
  }
]
