[
  {
    "title": "Reactivity | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/svelte/reactivity",
    "html": "Reactivity\n\nSvelte uses a compiler to build your code which optimises rendering. By default, components run once, unless they are referenced in your markup. To be able to react to changes in options you need to use stores.\n\nIn the below example, the refetchInterval option is set from the variable intervalMs, which is bound to the input field. However, as the query is not able to react to changes in intervalMs, refetchInterval will not change when the input value changes.\n\nsvelte\n<script lang=\"ts\">\n  import { createQuery } from '@tanstack/svelte-query'\n\n\n  const endpoint = 'http://localhost:5173/api/data'\n\n\n  let intervalMs = 1000\n\n\n  const query = createQuery({\n    queryKey: ['refetch'],\n    queryFn: async () => await fetch(endpoint).then((r) => r.json()),\n    refetchInterval: intervalMs,\n  })\n</script>\n\n\n<input type=\"number\" bind:value={intervalMs} />\n\nTo solve this, we can convert intervalMs into a writable store. The query options can then be turned into a derived store, which will be passed into the function with true reactivity.\n\nsvelte\n<script lang=\"ts\">\n  import { derived, writable } from 'svelte/store'\n  import { createQuery } from '@tanstack/svelte-query'\n\n\n  const endpoint = 'http://localhost:5173/api/data'\n\n\n  const intervalMs = writable(1000)\n\n\n  const query = createQuery(\n    derived(intervalMs, ($intervalMs) => ({\n      queryKey: ['refetch'],\n      queryFn: async () => await fetch(endpoint).then((r) => r.json()),\n      refetchInterval: $intervalMs,\n    }))\n  )\n</script>\n\n\n<input type=\"number\" bind:value={$intervalMs} />"
  },
  {
    "title": "SSR and SvelteKit | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/svelte/ssr",
    "html": "SSR and SvelteKit\nSetup\n\nSvelteKit defaults to rendering routes with SSR. Because of this, you need to disable the query on the server. Otherwise, your query will continue executing on the server asynchronously, even after the HTML has been sent to the client.\n\nThe recommended way to achieve this is to use the browser module from SvelteKit in your QueryClient object. This will not disable queryClient.prefetchQuery(), which is used in one of the solutions below.\n\nsrc/routes/+layout.svelte\n\nsvelte\n<script lang=\"ts\">\n  import { browser } from '$app/environment'\n  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'\n\n\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        enabled: browser,\n      },\n    },\n  })\n</script>\n\n\n<QueryClientProvider client={queryClient}>\n  <slot />\n</QueryClientProvider>\nPrefetching data\n\nSvelte Query supports two ways of prefetching data on the server and passing that to the client with SvelteKit.\n\nIf you wish to view the ideal SSR setup, please have a look at the SSR example.\n\nUsing initialData\n\nTogether with SvelteKit's load, you can pass the data loaded server-side into createQuery's' initialData option:\n\nsrc/routes/+page.ts\n\nts\nexport async function load() {\n  const posts = await getPosts()\n  return { posts }\n}\n\nsrc/routes/+page.svelte\n\nsvelte\n<script>\n  import { createQuery } from '@tanstack/svelte-query'\n  import type { PageData } from './$types'\n\n\n  export let data: PageData\n\n\n  const query = createQuery({\n    queryKey: ['posts'],\n    queryFn: getPosts,\n    initialData: data.posts\n  })\n</script>\n\nPros:\n\nThis setup is minimal and this can be a quick solution for some cases\nWorks with both +page.ts/+layout.ts and +page.server.ts/+layout.server.ts load functions\n\nCons:\n\nIf you are calling createQuery in a component deeper down in the tree you need to pass the initialData down to that point\nIf you are calling createQuery with the same query in multiple locations, you need to pass initialData to all of them\nThere is no way to know at what time the query was fetched on the server, so dataUpdatedAt and determining if the query needs refetching is based on when the page loaded instead\nUsing prefetchQuery\n\nSvelte Query supports prefetching queries on the server. Using this setup below, you can fetch data and pass it into QueryClientProvider before it is sent to the user's browser. Therefore, this data is already available in the cache, and no initial fetch occurs client-side.\n\nsrc/routes/+layout.ts\n\nts\nimport { browser } from '$app/environment'\nimport { QueryClient } from '@tanstack/svelte-query'\n\n\nexport async function load() {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        enabled: browser,\n      },\n    },\n  })\n\n\n  return { queryClient }\n}\n\nsrc/routes/+layout.svelte\n\nsvelte\n<script lang=\"ts\">\n  import { QueryClientProvider } from '@tanstack/svelte-query'\n  import type { LayoutData } from './$types'\n\n\n  export let data: LayoutData\n</script>\n\n\n<QueryClientProvider client={data.queryClient}>\n  <slot />\n</QueryClientProvider>\n\nsrc/routes/+page.ts\n\nts\nexport async function load({ parent, fetch }) {\n  const { queryClient } = await parent()\n\n\n  // You need to use the SvelteKit fetch function here\n  await queryClient.prefetchQuery({\n    queryKey: ['posts'],\n    queryFn: async () => (await fetch('/api/posts')).json()\n  })\n}\n\nsrc/routes/+page.svelte\n\nsvelte\n<script lang=\"ts\">\n  import { createQuery } from '@tanstack/svelte-query'\n\n\n  // This data is cached by prefetchQuery in +page.ts so no fetch actually happens here\n  const query = createQuery({\n    queryKey: ['posts'],\n    queryFn: async () => (await fetch('/api/posts')).json()\n  })\n</script>\n\nPros:\n\nServer-loaded data can be accessed anywhere without prop-drilling\nNo initial fetch occurs client-side once the page is rendered, as the query cache retains all information about the query was made including dataUpdatedAt\n\nCons:\n\nRequires more files for initial setup\nWill not work with +page.server.ts/+layout.server.ts load functions (however, APIs which are used with TanStack Query need to be fully exposed to the browser anyway)"
  },
  {
    "title": "Installation | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/svelte/installation",
    "html": "Installation\n\nYou can install Svelte Query via NPM.\n\nv5 is currently available as a release-candidate. We don't anticipate any major API changes from here on out. We encourage you to try it out and report any issues you find.\n\nNPM\nbash\n$ npm i @tanstack/svelte-query\n# or\n$ pnpm add @tanstack/svelte-query\n# or\n$ yarn add @tanstack/svelte-query\n\nWanna give it a spin before you download? Try out the basic example!\n"
  },
  {
    "title": "Overview | TanStack Query Docs",
    "url": "https://tanstack.com/query/latest/docs/svelte/overview",
    "html": "Overview\n\nThe @tanstack/svelte-query package offers a 1st-class API for using TanStack Query via Svelte.\n\nExample\n\nInclude the QueryClientProvider near the root of your project:\n\nsvelte\n<script lang=\"ts\">\n  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'\n  import Example from './lib/Example.svelte'\n\n\n  const queryClient = new QueryClient()\n</script>\n\n\n<QueryClientProvider client={queryClient}>\n  <Example />\n</QueryClientProvider>\n\nThen call any function (e.g. createQuery) from any component:\n\nsvelte\n<script lang=\"ts\">\n  import { createQuery } from '@tanstack/svelte-query'\n\n\n  const query = createQuery({\n    queryKey: ['todos'],\n    queryFn: () => fetchTodos(),\n  })\n</script>\n\n\n<div>\n  {#if $query.isLoading}\n    <p>Loading...</p>\n  {:else if $query.isError}\n    <p>Error: {$query.error.message}</p>\n  {:else if $query.isSuccess}\n    {#each $query.data as todo}\n      <p>{todo.title}</p>\n    {/each}\n  {/if}\n</div>\nSvelteKit\n\nIf you are using SvelteKit, please have a look at SSR & SvelteKit.\n\nAvailable Functions\n\nSvelte Query offers useful functions and components that will make managing server state in Svelte apps easier.\n\ncreateQuery\ncreateQueries\ncreateInfiniteQuery\ncreateMutation\nuseQueryClient\nuseIsFetching\nuseIsMutating\nuseHydrate\n<QueryClientProvider>\n<HydrationBoundary>\nImportant Differences between Svelte Query & React Query\n\nSvelte Query offers an API similar to React Query, but there are some key differences to be mindful of.\n\nMany of the functions in Svelte Query return a Svelte store. To access values on these stores reactively, you need to prefix the store with a $. You can learn more about Svelte stores here.\nIf your query or mutation depends on variables, you must use a store for the options. You can read more about this here."
  }
]
