[
  {
    "title": "Create a Tailwind CSS theme ⚡️ FormKit",
    "url": "https://formkit.com/guides/create-a-tailwind-theme",
    "html": "Create a Tailwind CSS theme\nInline usage\nUsing @formkit/themes\nOur first Tailwind input\nUsing variants\nA complete Tailwind theme — recreating Genesis CSS\nSelective overrides\nNext steps\n\nIn this guide, we’ll walk through the process of creating a custom Tailwind theme for your forms and inputs. Tailwind has risen to the forefront of CSS utility class libraries, and FormKit was authored with its capabilities in mind. Let’s get started!\n\nSFC BUILD TOOL\n\nThis guide assumes you are using a standard Vue 3 build tool like Vite, Nuxt 3, or Vue CLI that will allow you to import .vue single file components.\n\nDON'T INCLUDE THE DEFAULT THEME\n\nIf you plan to use Tailwind CSS for your form styles then please ensure that your project is not importing the base genesis theme that ships with FormKit — otherwise you will get weird styling results.\n\nInline usage\n\nIn the context of a .vue file that represents a component, it's possible to create a Tailwind theme using the section-key class props or the classes prop provided by FormKit.\n\nIf your component represents your entire form and your project only requires a single form, this may be all that you need. Here is an example of applying the same Tailwind classes to a FormKit text input using both the section-key props and the classes prop:\n\nLoad live example\n\nThis is a low-barrier way to apply Tailwind styles to your FormKit forms, but what if you have multiple forms? Copy-pasting class lists between components is not ideal and will lead to inadvertent variations in styling across your project over time.\n\nLet's explore how we can apply Tailwind classes globally to all FormKit inputs within our project.\n\nUsing @formkit/themes\n\nFormKit ships a first-party package, @formkit/themes, that includes Tailwind CSS support — making it easy to create a Tailwind CSS theme for FormKit in your project.\n\nThe package enables you to author your theme as a JavaScript object grouped by input type and sectionKey. Additionally, you can access a number of Tailwind variants based on input and form state such as formkit-invalid: and formkit-disabled: which allow you to dynamically change your input styling.\n\nTo get started we need to add the package to our project.\n\nnpm install @formkit/themes\n\nFrom there we need to do three things:\n\nAdd the formKitTailwind plugin from @formkit/themes to our project's tailwind.config.js file.\nCreate a theme file (something like tailwind-theme.js) in our project.\nImport the generateClasses helper function from @formkit/themes and use it with our theme in our FormKit config options.\n// tailwind.config.js\n\nconst formKitTailwind = require('@formkit/themes/tailwindcss');\n\n\n\nmodule.exports {\n\n  ...\n\n  content: [\n\n    ...\n\n    './tailwind-theme.js',\n\n  ],\n\n  plugins: [\n\n    formKitTailwind\n\n  ]\n\n  ...\n\n}\n// tailwind-theme.js\n\nexport default {\n\n  // our theme will go here.\n\n  // ...\n\n  // text: {\n\n  //   label: 'font-bold text-gray-300',\n\n  //   ...\n\n  // }\n\n  // ...\n\n}\n// app.js\n\nimport { createApp } from 'vue'\n\nimport App from './App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\nimport { generateClasses } from '@formkit/themes'\n\nimport myTailwindTheme from './tailwind-theme.js'\n\nimport '../dist/index.css' // wherever your Tailwind styles exist\n\n\n\ncreateApp(App)\n\n  .use(\n\n    plugin,\n\n    defaultConfig({\n\n      config: {\n\n        classes: generateClasses(myTailwindTheme),\n\n      },\n\n    })\n\n  )\n\n  .mount('#app')\n\nOnce this setup is complete we are ready to begin writing our Tailwind theme!\n\nOur first Tailwind input\n\nTo start, let's apply some sensible classes to a text style input. This will cover a large surface area because we'll easily re-use these styles to other text-like inputs such as email, password, date, etc.\n\nTo specifically target text inputs we'll create a text key in our theme object and then apply classes to each sectionKey as needed.\n\nHere is a text input with Tailwind classes applied:\n\nLoad live example\nUsing variants\n\nThe formKitTailwind plugin from @formkit/themes provides a number of variants you can use in your class lists to dynamically respond to input and form state.\n\nGROUP VARIANTS\n\nIf you're using variants in a nested case, the variants may be linked to its parent instead of itself. To fix that, add to the outer section group/{modifier}, and use the variant with the same modifier formkit-invalid/{modifier}:\n\nThe currently provided variants are:\n\nformkit-disabled:\nformkit-invalid:\nformkit-checked:\nformkit-errors:\nformkit-complete:\nformkit-loading:\nformkit-submitted:\nformkit-multiple:\nformkit-prefix-icon\nformkit-suffix-icon\n\nYou use these variants in the same way you use the built-in Tailwind variants such as dark: and hover:.\n\nLet's add some variants for formkit-invalid and formkit-disabled to our text input:\n\nLoad live example\nA complete Tailwind theme — recreating Genesis CSS\nCreate a Tailwind CSS Theme - Vue School Course\n\n11 mins\n\nNow we're cooking! To create a comprehensive theme all we need to do is define class lists for the sectionKeys of all the other input types we'll use in our project.\n\nThere are some improvements we can make though. The generateClasses helper function from @formkit/themes allows for a special global key that will apply to all inputs. This is helpful for sectionKeys such as help and messages that are usually styled the same across all input types in a project.\n\nGLOBAL AND FAMILY CLASS LISTS\n\nBy using the global and family: keys in your theme object you can apply a class lists to all inputs that have a given sectionKey either globally or within a family of inputs. This is useful for things like labels or help text when you want to share styling across a wide variety of inputs.\n\nLet's create a \"Kitchen Sink\" of input types, each having their defined class lists applied. Here is the theme in isolation for better readability:\n\nAnd here is our Tailwind theme when it is applied to all available FormKit inputs:\n\nFORMKIT ICONS\n\nFormKit inputs ship with their own decorator icons that can be used in place of browser-default styles that typcially ship with checkboxes, radios, select inputs, and more.\n\nIf you want to use these types of icons in your Tailwind theme be sure to import them from @formkit/icons and include them in your FormKit config.\n\nLoad live example\nSelective overrides\n\nAnd there we have it! All FormKit inputs styled with Tailwind utility classes across our entire project.\n\nIf we need to override any specific one-offs within our project, we can do so using the section-key class props or the classes prop on a given FormKit input within our project which was covered in the opening section of this guide.\n\nOf particular importance when doing an override is the special $reset modifier for class lists. When the FormKit class system encounters a $reset class it will erase the current class list for the given section and only collect class names that occur after the $reset token was encountered. This is valuable in a system like Tailwind where it would be painful to have to write override classes or individually disable classes for every globally configured class when deviating from our theme:\n\nLoad live example\nNext steps\n\nThis guide has walked through creating a Tailwind theme that covers all input types included in FormKit, but there's still more that could be done in your own project.\n\nHere are some ways to take the above guide even further:\n\nAdd dark-mode support using Tailwind's built-in dark: modifier.\nCombine multiple variants such as formkit-invalid:formkit-submitted: to add extra emphasis to invalid fields when a user tries to submit an incomplete form.\nPublish your theme as an npm package for easy importing and sharing between projects.\n\nHopefully, this guide helped you understand how classes are applied to FormKit inputs and how you can leverage the formKitTailwind plugin from the @formkit/themes package to make use of Tailwind in your FormKit projects. If you want to dive in deeper, try reading about the core internals of FormKit and the FormKit schema!\n\nWant more? Start by reading about FormKit core.\nDig deeper"
  },
  {
    "title": "Build a multi-step form ⚡️ FormKit",
    "url": "https://formkit.com/guides/build-a-multi-step-form",
    "html": "Build a multi-step form\nRequirements\nCreating a basic form\nBreaking the form into sections\nTracking validity for each step\nShowing validity\nShowing errors\nAdding a group blur event\nThe error UI\nForm submission and receiving errors\nPutting it all together\nWays to improve\nOFFICIAL MULTI-STEP PLUGIN\n\nStarting with 1.0.0-beta.15 FormKit ships an official 1st-party plugin that creates a multi-step input type.\n\nWhile there is still value in understanding how to build a multi-step input on your own — if you're looking for the easiest way to use a multi-step input in your project check out the official FormKit multi-step plugin — it's free and open-source!\n\nFew interactions on the web cause as much displeasure as being confronted with a large, intimidating form. Multi-step forms — sometimes called \"wizards\" — can alleviate this pain by breaking a large form into smaller approachable steps — but they can also be complicated to build.\n\nIn this guide, we'll walk through building a multi-step form with FormKit and see how we can provide an elevated user experience with minimal code. Let's get started!\n\nCOMPOSITION API\n\nThis guide assumes you are are familiar with the Vue Composition API.\n\nRequirements\n\nLet's begin by laying out the requirements for our multi-part form:\n\nShow the user which step they are currently on in relation to all required steps.\nAllow the user to navigate to any step of the form at will.\nShow immediate feedback if each step has passed all frontend validations ✅.\nAggregate form data from all the steps into a single object for submission.\nDisplay any returned backend errors on the appropriate fields and also at the appropriate step.\nCreating a basic form\n\nFirst, let's create a basic form without steps so we have content to work with. Our example will be a pretend application to receive a grant, so we'll organize the form into 3 sections — \"Contact Info\", \"Organization Info\", and \"Application\". These will become the full form steps later.\n\nWe'll include a mix of validation rules for each input, and limit each section to 1 question for now until we have the full structure in place. Lastly, for the purposes of this guide, we'll output the collected form data at the bottom of each example:\n\nLoad live example\nBreaking the form into sections\n\nNow that we have a defined structure, let's break the form into distinct sections.\n\nTo start, let's wrap each section of inputs with a group (<FormKit type=\"group\" />) so we can validate each group independently. FormKit groups are powerful because they are aware of the validation state of all their descendants without affecting the markup of your form.\n\nA group itself becomes valid when all its children (and their children) are valid:\n\n<!-- Only showing a single group here for brevity -->\n\n<FormKit type=\"group\" name: \"contactInfo\">\n\n  <FormKit type=\"email\" label=\"*Email address\" validation=\"required|email\" />\n\n</FormKit>\n\n...\n\nIn our case, we're also going to want wrapping HTML. Let's put each group into a \"step\" section which we can conditionally show and hide:\n\n<!-- Only showing a single group here for brevity -->\n\n<section v-show=\"step === 'contactInfo'\">\n\n  <FormKit type=\"group\" name: \"contactInfo\">\n\n    <FormKit type=\"email\" label=\"*Email address\" validation=\"required|email\" />\n\n  </FormKit>\n\n</section>\n\n...\n\nNext, let's introduce some navigation UI so we can toggle between each step:\n\n// for now, manually set step names\n\nconst stepNames = ['contactInfo', 'organizationInfo', 'application']\n<!-- Set up tab-navigation UI. On click, change step -->\n\n<ul class=\"steps\">\n\n  <li\n\n    v-for=\"stepName in stepNames\"\n\n    class=\"step\"\n\n    @click=\"step = stepName\"\n\n    :data-step-active=\"step === stepName\"\n\n  >\n\n    {{ camel2title(panel) }}\n\n  </li>\n\n</ul>\n\nHere's what it looks like put together:\n\nSTYLES NOT INCLUDED\n\nThe CSS for multi-step forms — such as the tabs in this example — is not included in the default Genesis theme. Styles were custom-written for this example and you will need to provide your own.\n\nLoad live example\n\nIt's starting to look like a real multi-step form! There's more work to be done though as we've got a few issues:\n\nThe validity of each individual step is not being shown.\nWhen there are validations on a tab that's not the \"current step\", they cannot be seen.\n\nLet's address the first issue.\n\nTracking validity for each step\n\nFormKit already tracks group validity out-of-the-box. We'll just need to capture this data so we can use it in our UI.\n\nOne important concept to remember about FormKit is that every <FormKit> component has a matching core node, which itself has a reactive node.context object. This context object tracks the validity of the node in context.state.valid. As mentioned above, a group becomes valid when all its descendants are valid. With that in mind, let's build up an object that stores the reactive validity of each of the groups.\n\nWe'll leverage FormKit's plugin functionality to do this job. While the term \"plugin\" may sound intimidating, plugins in FormKit are just setup functions that are called when a node is created. Plugins are inherited by all descendants (such as children within a group).\n\nHere's our custom plugin, called stepPlugin:\n\n// our plugin and our template code will make use of 'steps'\n\nconst steps = reactive({})\n\n\n\nconst stepPlugin = (node) => {\n\n  // only runs for <FormKit type=\"group\" />\n\n  if (node.props.type == 'group') {\n\n    // build up our steps object\n\n    steps[node.name] = steps[node.name] || {}\n\n\n\n    // add the current group's reactive validity\n\n    node.on('created', () => {\n\n      steps[node.name].valid = toRef(node.context.state, 'valid')\n\n    })\n\n\n\n    // Stop plugin inheritance to descendant nodes.\n\n    // We only care about the the top-level groups\n\n    // that represent the steps.\n\n    return false\n\n  }\n\n}\n\nThe resulting steps reactive object from our plugin above looks like this:\n\n{\n\n  contactInfo: { valid: false },\n\n  organizationInfo: { valid: false }\n\n  application: { valid: false }\n\n}\n\nTo use our plugin, we'll add it to our root form <FormKit type=\"form\" />. This means that every top-level group in our form will inherit the plugin:\n\n<FormKit type=\"form\" :plugins=\"[stepPlugin]\"> ... rest of the form </FormKit>\nShowing validity\n\nNow that our template has real-time access to each group's validity state via our plugin, let's write the UI to show this data in the step navigation bar.\n\nWe also no longer need to manually define our steps since our plugin is dynamically storing the name of all groups in the steps object. Let's add a data-step-valid=\"true\" attribute to each step if it's valid so we can target with CSS:\n\n<ul class=\"steps\">\n\n  <li\n\n    v-for=\"(step, stepName) in steps\"\n\n    class=\"step\"\n\n    @click=\"activeStep = stepName\"\n\n    :data-step-valid=\"step.valid\"\n\n    :data-step-active=\"activeStep === stepName\"\n\n  >\n\n    {{ camel2title(stepName) }}\n\n  </li>\n\n</ul>\n\nWith these updates, our form is now capable of informing a user when they have correctly filled out all of the fields in a given step!\n\nWe'll also make a few other improvements:\n\nExtract the \"step logic\" to a Vue composable so it can be reused elsewhere.\nCreate a utils.js file for our utility functions.\nSet the 1st step we find as the activeStep.\nLoad live example\nShowing errors\n\nShowing errors is more nuanced. Though the user may not be aware, there are actually 2 types of errors we need to handle and communicate to the user:\n\nErrors from failing frontend validation rules (messages of type validation)\nBackend errors (messages of type error)\n\nFormKit uses its message store to track both of these types of errors/messages.\n\nWith our plugin already in place, it's relatively simple to add tracking for both:\n\nconst stepPlugin = (node) => {\n\n  ...\n\n  // Store or update the count of blocking validation messages.\n\n  // FormKit emits the \"count:blocking\" event (with the count) each time\n\n  // the count changes.\n\n  node.on('count:blocking', ({ payload: count }) => {\n\n    steps[node.name].blockingCount = count\n\n  })\n\n\n\n  // Store or update the count of backend error messages.\n\n  node.on('count:errors', ({ payload: count }) => {\n\n    steps[node.name].errorCount = count\n\n  })\n\n  ...\n\n}\nBLOCKING VALIDATION MESSAGES VS ERRORS\n\nFormKit makes a distinction between frontend validation messages (messages of type validation), and errors (messages of type error).\n\nLet's update our example to show both types of errors with the following requirements:\n\nWe'll always show the count of backend errors if they exist.\nWe'll only show the count of frontend validation errors if the user visits and then exits (blurs) a group — as we don't want to confront them with error UI if they are still in progress.\nAdding a group blur event\n\nSince \"blurring a group\" doesn't exist in HTML, we'll introduce it in our plugin with an array called visitedSteps. Here's the relevant code:\n\nimport { watch } from 'vue'\n\nimport { getNode, createMessage } from '@formkit/core'\n\n\n\nconst stepPlugin = (node) => {\n\n  ...\n\n  const activeStep = ref('')\n\n  const visitedSteps = ref([]) // track visited steps\n\n\n\n  // Watch our activeStep and store visited steps\n\n  watch(activeStep, (newStep, oldStep) => {\n\n    if (oldStep && !visitedSteps.value.includes(oldStep)) {\n\n      visitedSteps.value.push(oldStep)\n\n    }\n\n    // Trigger showing validation on fields if a group has been visited\n\n    visitedSteps.value.forEach((step) => {\n\n      const node = getNode(step)\n\n\n\n      // the node.walk() method walks through all the descendants of the current node\n\n      // and executes the provided function.\n\n      node.walk((n) => {\n\n        n.store.set(\n\n          createMessage({\n\n            key: 'submitted',\n\n            value: true,\n\n            visible: false\n\n          })\n\n        )\n\n      })\n\n    })\n\n  })\n\n  ...\n\n}\n\nYou might be wondering why we are walking all of the descendants of a given step (node.walk()) and creating messages with a key of submitted and value of true? When a user attempts to submit a form, this is how FormKit informs itself that all inputs are in a submitted state. In this state, FormKit forces any blocking validation messages to appear. We are manually triggering the same thing in our \"group blur\" event.\n\nThe error UI\n\nWe'll use the same UI for both types of errors since end-users don't really care about the distinction. Here's our updated step HTML, which outputs a red bubble with the sum total of the errors errorCount + blockingCount:\n\n<li v-for=\"(step, stepName) in steps\" class=\"step\" ...>\n\n  <span\n\n    v-if=\"checkStepValidity(stepName)\"\n\n    class=\"step--errors\"\n\n    v-text=\"step.errorCount + step.blockingCount\"\n\n  />\n\n  {{ camel2title(stepName) }}\n\n</li>\n\nWe are almost to the finish line! Here's our current form — which can now tell a user when they have properly or improperly filled out each step:\n\nLoad live example\nForm submission and receiving errors\n\nThe last piece of the puzzle is submitting the form and handling any errors we receive from the backend server. We'll fake the backend for the purposes of this guide.\n\nWe submit the form by adding an @submit handler to the <FormKit type=\"form\">:\n\n<FormKit type=\"form\" @submit=\"submitApp\"> ... rest of form</FormKit>\n\nAnd here's our submit handler:\n\nconst submitApp = async (formData, node) => {\n\n  try {\n\n    const res = await axios.post(formData)\n\n    node.clearErrors()\n\n    alert('Your application was submitted successfully!')\n\n  } catch (err) {\n\n    node.setErrors(err.formErrors, err.fieldErrors)\n\n  }\n\n}\n\nNotice that FormKit passes our submit handler 2 helpful arguments: the form's data in a single request-ready object (which we're calling formData), and the form's underlying core node, which we can use to clear errors or set any returned errors using the node.clearErrors() and node.setErrors() helpers, respectively.\n\nsetErrors() takes 2 arguments: form-level errors and field-specific errors. Our fake backend returns the err response which we use to set any errors.\n\nSo, what happens if the user is on step 3 (Application) when they submit, and there are field-level errors on a hidden step? Thankfully, so long as the nodes exist the DOM, FormKit is able place these errors appropriately. This is why we used a v-show for the steps instead of v-if — The DOM node needs to exist in order to have errors set on the corresponding FormKit node.\n\nPutting it all together\n\nAnd Voilà! 🎉 We are finished! In addition to our submit handler, we've added some more UI and UX flourishes to this final form to make it feel more real:\n\nAdded Previous / Next buttons for step navigation.\nAdded a fake backend to utils.js that returns errors.\nThe form submit button is now disabled until the entire form is in a valid state.\nAdded some additional text to the form to better mock a real-world UI.\n\nHere it is — a fully functioning multi-step form:\n\nLoad live example\nWant to see it built using FormKit Schema?\nCheck out the Playground\nWays to improve\n\nOf course, there are always ways to improve anything, and this form is no exception. Here are a few ideas:\n\nSave form state to window.localStorage so a user's form state is maintained even if they accidentally leave.\nPre-populate any known form values so the user doesn't have to fill out known data.\nAdd a \"not yet submitted\" status indicator to warn the user that they still need to submit.\n\nWe've covered a lot of topics in this guide and hope you've learned more about FormKit and how to use it to make multi-step forms easier!\n\nWant to use a multi-step input in your project?\nTry the official plugin"
  },
  {
    "title": "Autocomplete Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/autocomplete",
    "html": "Autocomplete\nView pricing →\nBasic examples\nSingle-select\nMulti-select\nFiltering\nDynamic options\nSearch parameter\nPage and hasNextPage parameters\nOption loader\nLoading Style\nLoad on created\nOption appearance\nOption slot\nSelection appearance\nSelection appearance prop\nSelection slot\nBehavioral props\nEmpty message\nClose on select\nReload on commit\nOpen on click\nOpen on focus\nClear search on open\nSelection removable\nOpen on remove\nMax\nFull example\nProps & Attributes\nSections\nSelection appearance text-input\nSelection appearance option, single selection\nSelection appearance option, multiple selection\nInner listbox structure\nPro installation quickstart 🚀\n\nThe autocomplete input allows you to search through a list of options.\n\nThe options prop can accept three different formats of values:\n\nAn array of objects with value and label keys (see example above)\nAn array of strings ['A', 'B', 'C']\nAn object literal with key-value pairs { a: 'A', b: 'B', c: 'C' }\nA function that returns any of the above\nEMPTY OPTIONS\n\nIf you assign options as an empty array, the input will be rendered in a disabled state.\n\nBasic examples\nSingle-select\n\nBy default, the autocomplete input will render in single-select mode:\n\nautocomplete-single.vue\ncountries.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n<script setup>\nimport countries from './countries.js'\n</script>\n<template>\n  <FormKit type=\"form\" #default=\"{ value }\" :actions=\"false\">\n    <FormKit\n      type=\"autocomplete\"\n      name=\"country\"\n      label=\"Search for a country\"\n      placeholder=\"Example: United States\"\n      :options=\"countries\"\n    />\n    <pre wrap>{{ value }}</pre>\n  </FormKit>\n</template>\nRender\nHTML\nMulti-select\n\nBy setting the multiple prop the autocomplete input will render in multi-select mode:\n\nRender\nHTML\nMULTI-SELECT INPUT VALUE\n\nNotice in the example above that because the multiple prop is set, the value prop must be an array.\n\nFiltering\n\nThe autocomplete input will filter options with its own internal search function. You can replace this search function by providing the filter prop a function of your own. Your function will receive two arguments, the option being iterated over and the current search value:\n\nRender\nHTML\nDynamic options\n\nInstead of passing a static list to the options prop, you can assign it to a function. Doing so is useful when you need to load options from an API or another source.\n\nSearch parameter\n\nIn this example, we'll assign the options prop the searchMovies function. By doing so, searchMovies will receive the context object as an argument. Within this context object is the search property, which is the current search value. To perform our search, we'll use the search value as the query parameter for our API request:\n\nRender\nHTML\nPage and hasNextPage parameters\n\nA likely scenario you'll encounter is needing to search through a paginated API. This can be done by referencing the same context object as before. Within this object, we can utilize the page and hasNextPage properties. The page property is the current page number, and the hasNextPage property is a function to be called when there are more pages to load:\n\nRender\nHTML\nOption loader\nRehydrating values\n\nFormKit's autocomplete input also provides an optionLoader prop that allows you to rehydrate values that are not in the options list. In this example, we'll provide the autocomplete an initial value (a movie ID), and assign the optionLoader to a function that will make a request to the API to get the movie:\n\nRender\nHTML\n\nNotice in the example above that the optionLoader function is passed two arguments: the value of the selected option (in this case, the movie ID) and the cachedOption. The cachedOption prop is used for preventing unnecessary lookups. If the cachedOption is not null it means that the selected option has already been loaded, and you can return the cachedOption directly.\n\nLoading Style\n\nInstead of requiring your users to click the Load more button to load additional options, you can set the loadOnScroll prop to true, which will paginate options as you scroll to the bottom of the options list.\n\nLoad on created\n\nIf you would rather load options when the autocomplete is created, you can set the load-on-created prop to true, and our function, loadCurrentlyPopularMovies will be called without the user needing to expand the listbox:\n\nRender\nHTML\nOption appearance\nOption slot\n\nThe autocomplete input allows you to customize the look and feel of each option by using the option slot. In this example, we are using the option slot to display each option's asset; logo and name:\n\nRender\nHTML\nSelection appearance\n\nThe autocomplete input allows you to customize the look and feel of the selected option.\n\nSelection appearance prop\n\nThe autocomplete input allows you to customize the look and feel of the selected option by using the selection-appearance prop. For either the single-select or multi-select autocomplete, you can set the selection-appearance prop to text-input (default) or option:\n\nRender\nHTML\nSelection slot\n\nIf you only want to customize the display of the selected option, set the selection appearance to option.\n\nRender\nHTML\nBehavioral props\nEmpty message\n\nThe autocomplete input, by default, will not expand the listbox when no search results are found while filtering. You can change this behavior by assigning the empty-message prop a message to display when no results are found:\n\nRender\nHTML\nClose on select\n\nIf you would like the listbox to remain expanded after selecting a value, you can set close-on-select to false.\n\nRender\nHTML\nReload on commit\n\nIf you want the options to be reloaded when the user commits a selection, use the reload-on-commit prop:\n\nRender\nHTML\nOpen on click\n\nTo enable opening the autocomplete's listbox on click of its search input, set the open-on-click prop to true:\n\nRender\nHTML\nOpen on focus\n\nIf you would like to open the autocomplete's listbox anytime the input is clicked, set the open-on-focus prop to true:\n\nRender\nHTML\nOPEN ON FOCUS VS OPEN ON CLICK\n\nIf open-on-focus is used, open-on-click will implicitly be set.\n\nClear search on open\n\nFor single-select autocompletes only, if you would like to clear the search input when the listbox is opened, set the clear-search-on-open:\n\nRender\nHTML\nSelection removable\n\nFor a single-select autocomplete, you can set the selection-removable prop. When set to true, a remove button will be displayed next to the selected option. This prop is by default set to true for autocompletes with selection appearance of option.\n\nSINGLE SELECT ONLY\n\nThe selection-removable prop cannot be used for multi-selects.\n\nRender\nHTML\nOpen on remove\n\nIf you want the listbox to expand when an selection is removed, use the open-on-remove prop:\n\nRender\nHTML\nMax\n\nIf you would like to limit the number of options that can be selected, you can use the max prop:\n\nRender\nHTML\nFull example\n\nNow let's combine what we've learned so far by leveraging the option slot for custom markup, and setting the options prop to a function that will return pages of movies from an API:\n\nRender\nHTML\nProps & Attributes\nProp\tType\tDefault\tDescription\ndebounce\tnumber\t200\tNumber of milliseconds to debounce calls to an options function.\noptions\tany\t[]\tThe list of options the user can select from.\nload-on-scroll\tboolean\tfalse\tWhen set to `true`, the autocomplete will try loading more options based on the end-user`s scroll position\nselection-appearance\tstring\ttext-input\tChanges the way the option label is display.\nmultiple\tboolean\tfalse\tAllows for multiple selections.\nopen-on-click\tboolean\tfalse\tThe autocomplete is expanded upon focus of the input, as opposed to waiting to expand until a search value is entered.\nfilter\tfunction\tnull\tUsed to apply your own custom filter function for static options.\noption-loader\tfunction\tnull\tUsed for hydrating initial value, or performing an additional request to load more information of a selected option.\nempty-message\tstring\tundefined\tRenders a message when there are no options to display.\nmax\tnumber\tundefined\tLimits the number of options that can be selected.\nopen-on-remove\tboolean\tfalse\tWhen the `selection-removable` prop is set to `true`, the autocomplete will not open after the selected value is removed. You can change this behavior by setting the `open-on-remove` prop to `true`.\nopen-on-focus\tboolean\tfalse\noptions-appearance\tstring\tundefined\tFor multi-select autocompletes, this prop allows you to customize the look and feel of the selected options. Possible values are `default` (the default) or `checkbox`.\nalways-load-on-open\tboolean\ttrue\tDetermines whether the autocomplete should always load its options when opened or whether it should reference the options that were previously found when opening.\nload-on-created\tboolean\tfalse\tWhen set to `true`, the autocomplete will load the options when the node is created.\nclear-search-on-open\tboolean\tfalse\tWhen set to `true`, the search input will be cleared when the listbox is opened.\nmax\tnumber | string\tundefined\tIf you would like to limit the number of options that can be selected, you can use the `max` prop (applies only to multi-select).\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nThe autocomplete's structure changes depending on a few different scenarios:\n\nWhether selection-appearance has been set to text-input (the default) or option.\nWhether multiple selections are enabled via the multiple attribute.\nSelection appearance text-input\nwrapper\nlabel\ninner\nprefixIcon\nprefix\ninput\nmessages\nmessage\nYour favorite athletes\nSerena, Pelé\n⌄\nTiger Pelé\nSearch for your favorite athletes.\nSorry, that athlete could not be found.\nouter\nloaderIcon\nlistboxButton\nselectIcon\nlistbox\nsuffix\nsuffixIcon\nhelp\nSelection appearance option, single selection\nwrapper\ninner\nprefixIcon\nprefix\ninput\nselections\nselection\noption\noptionLoading\nremoveSelection\ncloseIcon\nYour favorite athlete\nPelé\nX\n⌄\nTiger Pelé\nSearch for your favorite athlete.\nSorry, that athlete could not be found.\nouter\nlabel\nloaderIcon\nlistboxButton\nselectIcon\nlistbox\nsuffix\nsuffixIcon\nhelp\nmessages\nmessage\nSelection appearance option, multiple selection\nwrapper\ninner\nprefixIcon\nprefix\ninput\nselections\nselection\noption\nhelp\nmessages\nmessage\nYour favorite athlete\n⌄\nTiger Pelé\nPelé\nX\nSearch for your favorite athlete.\nSorry, that athlete could not be found.\nouter\nlabel\nloaderIcon\nlistboxButton\nselectIcon\nlistbox\nsuffix\nsuffixIcon\noptionLoading\nremoveSelection\ncloseIcon\nInner listbox structure\n\nBelow is the inner options list (listbox) structure from the diagrams above:\n\nemptyMessage\nemptyMessageInner\nselectedIcon\nloadMore\nloadMoreInner\nloaderIcon\nNo options to display.\n✔️\nSerena\n⏳\ndropdownWrapper\nlistbox\nlistitem\noption\nSection-key\tDescription\nselector\tThe selector section is a button element that opens the dropdown options list.\nselections\tContains individual selection sections.\nselection\tContains the selected option.\nlistitem\tA list item element that contains the option section.\noption\tA div that contains the option content.\nlistbox\tThe listbox section is a ul element that contains the options list.\ndropdownWrapper\tWraps the listbox section. A div that handles scrolling the listbox.\noptionLoading\tA span element that is conditionally rendered within the selected option when loading is occurring.\nloaderIcon\tAn element for outputting an icon in the selector element when loading is occurring.\nselectIcon\tAn element for outputting an icon in the selector element when the dropdown is closed.\nloadMore\tA list item element that is conditionally rendered at the bottom of the options list when there are more pages to load.\nloadMoreInner\tA span element that acts as a wrapper for the loaderIcon within the loadMore section.\nremoveSelection\tA button element used for removing a specific selection.\ncloseIcon\tAn element for outputting an icon within the removeSelection button.\nlistboxButton\tA button element that is used to open the dropdown.\nemptyMessage\tA list item element that is conditionally rendered when there are no options to display.\nemptyMessageInner\tA span element that acts as a wrapper for the emptyMessage section.\nShow Universal section keys"
  },
  {
    "title": "Changelog ⚡️ FormKit",
    "url": "https://formkit.com/changelog",
    "html": "Changelog\nFormKit\nFormKit Pro (Beta)\n1.3.2\nNovember 28, 2023\n🐛 Bug fixes\nFixes togglebuttons text color in default Tailwind Genesis theme.\n1.3.1\nNovember 28, 2023\n💪 New features\nAdds Tailwind styles for togglebuttons input.\n🐛 Bug fixes\nFixes Tailwind styles for alignment of prefix icon in button family of inputs.\n1.3.0\nOctober 9, 2023\n💪 New features\nAdds a new plugins for counting available characters in an input based on the length rule.\nAdds a <KitchenSink> component that renders all input specimen.\nAdds a data-has-multiple attribute to file inputs on the outer section when they have multiple files.\n🐛 Bug fixes\nFixes a bug with on the select input with option groups containing non-string values (#986).\nFixes an issue with nuxt autoImport in webpack (#983)\nFixes a bug that prevent deeply nested inputs from receiving the correct input value during a reset (#1025)\nFixes create-app command of the formkit cli tool when installing vite.\nFixes a bug that caused the @formkit/nuxt module with autoImport to not include the FormKit component (#995)\n1.2.2\nOctober 3, 2023\n🐛 Bug Fixes\nFixes a bug with @formkit/nuxt in autoImport mode where the SSR context was not being reset after each request leading to hydration errors and broken UI on some pro inputs.\n1.2.1\nSeptember 29, 2023\n🐛 Bug Fixes\nImproves dev mode support for @formkit/nuxt with the autoImport option enabled.\n1.2.0\nSeptember 29, 2023\n💪 New features\nThe select input now supports grouped options (<optgroup>) (#426).\nThe @formkit/nuxt package now includes an experimental autoImport option that only loads FormKit on the pages it is used rather than globally. This will remove FormKit from your entry file. We plan to eventually make this the default behavior and encourage everyone using the current nuxt module to try the new option.\nAdds support for prefix-icon and suffix-icon to inputs created with createInput().\nSignificantly improves tree shaking of inputs and configuration options (with manual configuration).\nAdds Tailwind support for new colorpicker input.\nAdds new color icon.\n📙 Documentation\nNew guide: Optimizing for Production\n🐛 Bug Fixes\nZod plugin now iterates over issues not errors (#945)\n1.1.0\nSeptember 20, 2023\n💪 New features\nAdds new <FormKitProvider :config=\"yourConfig\"> — a component that defines a new configuration boundary. Any <FormKit> components that are nested beneath a <FormKitProvider> will inherit their configuration from this location.\nAdds a new <FormKitLazyProvider> which checks for a higher order <Suspense> boundary (if not found it injects one) and injects a <FormKitConfigLoader> component.\nAdds a new <FormKitConfigLoader> component. An async component that performs a dynamic import for a configuration file.\n\nNote: The new components listed above are currently experimental and will be documented further as the API stabilizes.\n\n🐛 Bug Fixes\nFixes a bug in the TypeScript definition of the <FormKit> component that causes a TypeScript error in Vue Language Tools (Volar) > 1.8.11.\nImproves tree shaking across the board for @formkit/* packages.\nFixes a bug in the many of the alpha, alphanumeric, and contains_* validation rules for the latin charset.\n1.0.0\nSeptember 1, 2023\n\nWith this release we are officially declaring FormKit stable and production ready. Many community members have already been using FormKit in production for over a year now and have been very happy with the results. We hope you will be too!\n\nAdditionally FormKit Pro is now available to the general public (no early access required). FormKit Pro is still in Beta, and we are working hard to prepare it for a stable release.\n\n💪 New features\nAdds a new <FormKitSummary> component that automatically lists all the errors and validation messages in a form with jump links to each (a11y).\n🐛 Bug Fixes\nImproves focus styles for the radio, checkbox, and range inputs (a11y).\nImproves genesis contrast ratio to 4.5:1 (a11y).\nfile input now includes the file name in the remove file button (a11y).\nThe file input now re-focuses after removing a file (a11y).\n0.19.3 (Release Candidate 1)\nAugust 30, 2023\n🐛 Bug Fixes\nImproves prop inheritance via the config object.\n0.19.2 (Release Candidate 1)\nAugust 29, 2023\n💪 New features\nYou can now log in to your FormKit Pro account and create teams and projects directly from the CLI.\nExports StepHandlers and MultiStepHandlers and BeforeStepChangeData to assist typing multi-step inputs.\n🐛 Bug Fixes\nFixes an issue that caused datetime-local inputs to not resolve their slot typings.\nFixes a bug that caused nuxt installations to fail.\n0.19.1 (Release Candidate 1)\n\nWe don’t talk about Bruno.\n\n0.19.0 (Release Candidate 1)\nAugust 25, 2023\n💪 New features\nIntroduces a new hidden input meta. Meta inputs are in-memory only and add data to your form without displaying it to the user or rendering anything on the page. Meta docs.\nAdds a new number prop to text, number, range, and hidden inputs that casts the value to a number using parseInt or parseFloat and expands or contracts the type definition of the value to match.\nDynamic lists now automatically change the rendered name of any child radio inputs to ensure they do not conflict with each other.\n🇧🇦 Adds Bosnian (bs) locale.\n🐛 Bug Fixes\nFixes an issue that caused checkboxes and radios to use duplicate id attributes when used in a dynamic list (#908).\nCheckboxes and Radios used\nAdds stepIndex and steps to the step input’s type definition.\nImproves nl locale translations.\nAdds optional FocusEvent to type definition of context.handlers.blur.\n0.18.4 (Beta 18)\nAugust 22, 2023\n🐛 Bug Fixes\nImproves types for multi-step plugin and its slots.\n0.18.3 (Beta 18)\nAugust 18, 2023\n🐛 Bug Fixes\nImproves types for button and submit inputs (#895).\nImproves types for multi-step plugin\n0.18.2 (Beta 18)\nAugust 16, 2023\n🐛 Bug Fixes\nFixes a bug that caused the ledger to perform incorrect unmerge calculations for counters that were not the first in the set. This caused groups and lists to occasionally leave their counter values behind when unmounted (#878).\n0.18.1 (Beta 18)\nAugust 15, 2023\n🐛 Bug Fixes\nFixes a bug that caused forms with dynamic lists to throw errors when being reset (#731).\nFixes a bug that caused schema data to render improperly in some edge cases when the schema was being updated dynamically (#610).\nFixes the autoHeightTextareaPlugin and greatly improves it’s resizing accuracy (#888)\nFixes tet and lt translations (#886)\n0.18.0 (Beta 18)\nAugust 11, 2023\n🎉 Keynote features\nImproved TypeScript Support 🎉\n\n1 min\n\nEnhanced TypeScript prop support for Vue 3.3+. #627\nNew barcode input available via @formkit/barcode package. Barcode docs\n💪 New features\nIntroduced dropdown input functionalities:\nSupport for removing the current selection. #646\nMulti-select capability. #647\nThe whenAvailable utility from @formkit/utils dynamically references its document context, facilitating FormKit's usage within web component shadow DOM. #837\nNew behavioral properties for dropdown, autocomplete, and taglist inputs.\nAdded an #empty section/slot for the repeater input to display context when there are no values. Repeater docs\nAdds Lithuanian 🇱🇹 (lt)\n🐛 Bug fixes\nThe repeater respects the disabled state of its parent form. #579\nThe taglist accepts empty options. #586\nPrevented unnecessary calls to options method in dropdown family inputs. #657\nEnsured autocomplete input compatibility with Vue's @focus directive. #670\nThe taglist accepts values outside its options list. #681\nResolved field reactivation after parent form reenabling. #733\nAddressed datepicker error on keyboard navigation in picker-only mode. #736\nCorrected checkbox label slot overwrite by adjacent radio. #778\nGenesis theme limits pointer-events: none to submit-type buttons in the actions slot. #790\n\"Compare\" dirty checks adapt to new values provided during form reset. #791\nEnsured taglist respects the max prop with open-on-click enabled. #793\nEnhanced autocomplete with selectionAppearance set to option to work with open-on-click prop. #817\nFixed issues with the eq function from @formkit/utils. #819\nResolved datepicker navigation error when starting with year. #827\nEnsured taglist respects the max prop with close-on-select disabled. #838\nAddressed inline array-syntax validation prop exceptions. #852\nFixed FormKit CLI export path issues. #854\nResolved schema compiler issues with FormKit. #857\nThe formkit-icon class aligns with config.rootClasses. #859\nRemedied Transfer List drag-and-drop glitches. #863\nAddressed a datepicker Safari focus issue by modifying the open button to a role=\"button\" div. #864\nDropdown inputs (dropdown, autocomplete, taglist) can now render values that are not part of their options list. #877\n0.17.5 (Beta 17)\nJuly 20, 2023\n💪 New features\nAdds new <FormKitRoot> component. This component provides context about the root element (Document or ShadowRoot). When using FormKit inside a Custom Element (Web Component) wrap one or many FormKit input’s in <FormKitRoot> to ensure proper functionality.\nAdds new node.props.__root and context.__root property that references the node’s current root element (Document | ShadowRoot).\n🐛 Bug fixes\nFixes an issue where the mult-step input plugin would break when rendering steps in a v-for loop or conditionally rendering a step via schema. #823 #825\nTextarea Auto-height plugin recalculates height when programmatically changing the value. #839\nFixes an issue in Zod plugin that prevents transforms from being applied. #833\n0.17.4 (Beta 17)\nJune 30, 2023\n💪 New features\nAdds new data-empty attribute to input outer wrappers for styling purposes. #777\nUpdates to Nuxt module allowing for runtimeConfig support — see the new docs in the installation wizard guide. #795\n🐛 Bug fixes:\nActually really for real fixes issue where blur event could cause console errors on route change. #776\nFixes issue where null icon value would throw error. #780\nFixes missing semicolon in multistep.css. #783\nFixes use of :model-value prop not updating internal FormKit node values. #785\n0.17.3 (Beta 17)\nJune 16, 2023\n💪 New features\nAdds 🇲🇳 Mongolian (mn) language - #747\nAdds 🇮🇸 Icelandic (is) language #748\nAdds new node.next(), node.previous(), and node.goTo() extensions for multi-step inputs via MultiStep plugin. This allows for easier external control of multi-step input navigation. #685\nAdds new node.restoreCache() extension for the localStorage plugin to allow restoring of form values to cache on failed submit. #727\n🐛 Bug fixes:\nFixes SSR hydration issues for the multi-step input. #720\nFixes issue where blur event could cause console errors on route change. #735\nFixes issue where Pro inputs would break when used with the Floating Labels plugin. #742\nMultiStep beforeStepChange now works with async function calls. #743\nFixes issue where file inputs would not allow re-uploading the same file after calling reset. #762\nPrevents Genesis CSS keyframe naming conflict by adding fk- prefix.\n0.17.2 (Beta 17)\nMay 17, 2023\n🐛 Bug fixes:\nFixes an issue that caused deeply nested v-model’s to not update when a mutation originated at depth (#722)\nFixes an issue that caused custom inputs that overrode the text family of inputs to re-use the first schema(#719)\nExports type FormKitValidationMessage to help type validation message functions (#695)\n💪 New features\nlocalStorage plugin now supports new options: key, control, debounce, beforeSave, and beforeLoad.\nlocalStorage plugin can now be applied to any input of internal type group. eg (form, group, multi-step, etc).\n0.17.1 (Beta 17)\nMay 16, 2023\n🐛 Bug fixes\nFixed a bug that caused and error to be thrown when a dynamic list was initialized with identical initial scalar values (#715)\nFixed a bug that caused the value property of a slot to not be updated in some edge cases (#717).\n0.17.0 (Beta 17)\nMay 12, 2023\n💪 New features\nNew FormKit Zod plugin — Validate your FormKit forms using Zod schema.\nNew dynamic list prop allows you to easily create your own repeaters.\nNew Save to localStorage plugin for saving user progress in forms and protecting against lost data in the event of an unexpected event.\nAdds new validation rules: require_one (thanks @devoidofgenius), contains_alpha, contains_alphanumeric, contains_alpha_space, contains_symbol, contains_uppercase, contains_lowercase, contains_numeric, symbol, uppercase, and lowercase (thanks @riderx).\nNew Auto-height textarea plugin to create textarea inputs with dynamically resizing height.\nPro: New Slider input.\nAdds new commitRaw event that fires even if there is no change to the input value.\nFormKitSchema can now use a single root node (instead of a fragment)\nAll FormKit inputs now use a root node instead of a fragment meaning standard Vue directives like v-show now work adding a key to dynamic inputs is generally no longer required (#528).\nThe AutoAnimate plugin now supports animating the repeater input and other Pro inputs.\nValues passed into the node.reset() function become the new default value for the input (#621).\nAdds traditional Chinese 🇨🇳 (zh-TW)\nAdds Latvian 🇱🇻 (lv)\nAdds Tetum 🇹🇱 (tet)\nAdds new ability to extend a core node with node.extend().\n⚡️ Performance\nDramatically improved the performance of mounting inputs in a large form (5-10x faster).\nImproved performance of hydrating a form by diffing scalar values before inputting.\nReduced the noise on the @input event and removed the now unnecessary debounce on the change event.\n🐛 Bugfixes\nThe @formkit/observer will now observe changes to node._value in instances where you want to operate on the non-debounced input value.\nThe range icon in @formkit/icons has been updated to only show one control handle since HTML range inputs do not support multiple values. The old multi-handle icon has been repurposed for the new slider FormKit Pro input.\nPro: Fixes a bug that caused nested repeater inputs to not hydrate properly (#458).\nPro: Fixes a bug that caused nested repeater inputs to throw an error when being removed (#457).\nFixes a bug that caused the blur event to fire multiple times when manually binding to the @blur event on a custom input (#413).\nFixes a bug that caused v-model to only fire input events on every other input (#463)\nFixes a bug that caused the schema to iterate over the value of an array if the array had a length of 1 and the only value in the array was a number (#635)\nFixes an issue that caused node.walk() to prematurely end when using stopOnFalse.\nFixes memory leak in SPA browsing and SSR environments (#475)\n0.16.0 (Beta 16)\nMarch 14, 2023\nNEW VERSION SCHEME\n\nBeta 16 is the first version of FormKit that does not have a pre-release identifier. Beta 16 and all remaining beta versions will be released under the 0.x.x semantic version. The first stable release will be 1.0.0 and is targeted for later this year. This change in versioning should help with package manager dependency resolution as we complete our beta release cycles.\n\n💪 New features\nPro: New Transfer List input! A great option for helping your users select information from a large set of data.\nPro: The floating labels plugin now supports FormKit Pro Inputs.\nPro: The mask input now supports multiple colors by providing an overlay option.\nAdds a new dirty-behavior prop allows users to opt into a compare behavior which compares the current value of the input to the original value of the input. If the input is changed back to its original state the context.state.dirty flag will revert back to false.\nAdds i18n translations for some new ui and validation rules.\n🐛 Bugfixes\nThe options prop (used in select, radio, checkboxes and some pro inputs) can now differentiate between null and undefined values.\nFixes issues with the @formkit/nuxt module and syntax highlighting.\nFixes a bug that caused the dirty state of an unrelated input to get incorrectly set true when an object (like a group) was updated (#520).\nThe floating labels plugin now hides placeholders until focused (#574).\nFixes a bug that caused forms to not receive the submitted state like the form’s children on an unsuccessful form submission (#503).\nThe multi-step input now preserves step order when conditionally rendering steps (#613).\nFixes a tailwind styling bug for checkboxes and radios (#584).\n1.0.0-beta.15\nFebruary 6, 2023\n\nThis release adds new 1st-party plugins to the @formkit/addons package, ships bug fixes and styling updates for both CSS and Tailwind CSS users.\n\n💪 New features\nEasily create multi-step forms or include multi-step sections inside your forms with the new multi-step plugin in @formkit/addons. Ships with standalone CSS styling you can import that works well with our genesis theme. Check out the full documentation here.\nEnable floating labels for all text family (text, email, url, etc) and textarea inputs with the new floating labels plugin in @formkit/addons. Check out the full documentation here.\nAdds new Next and Previous strings to UI localization object for use in plugins and custom inputs.\n🐛 Bug fixes\nFixes missing Tailwind CSS genesis theme export path in @formkit/themes.\nAdds :focus-visible styling to buttons to show focus state when using keyboard navigation.\nAdds missing loading styles for submit buttons in the Tailwind CSS Genesis theme.\n📘 Articles\nNew Article: Create a Multi-Step form in Vue in 5 Minutes\n1.0.0-beta.14\nJanuary 21, 2023\n\nThis release addresses some issues for Tailwind users that were introduced in beta.13.\n\n🐛 Bug fixes\nReverts @formkit/themes/tailwindcss to only include a default export of the FormKitVariants plugin.\nMoves the provided Tailwind Genesis theme to a new export path of @formkit/themes/dist/tailwindcss/genesis.\nChanges remove class operator from ! to $remove: in order to not conflict with Tailwind's built-in ! operator that adds !important to a style rule.\nFixes issue where default icons would not load when using the provided FormKit Tailwind Genesis theme.\n1.0.0-beta.13\nJanuary 19, 2023\n💪 New features\nAdds new <FormKitMessages> component which allows relocation of a form’s validation and error messages and the ability for group and list inputs to display their own error and validation messages.\nWhen removing classes on a section of a FormKit input you can use the ! prefix operator to selectively remove an existing class without needing to use the long-form object syntax. eg outer-class=\"my-class !formkit-outer\" adds my-class and removes the default formkit-outer class.\nAdds  Catalan (thanks @petergithubmgw).\nThe checkbox and radio inputs now have a data-checked attribute around their respective wrapper making it easy to add custom styling for checked vs non-checked states.\nImproves validation messages in a handful of languages (en, pt, zh).\nPro: New Mask Pro input.\nPro: Adds empty-message prop allows for message to be rendered in listbox when no options are passed (dropdown, autocomplete, and taglist). #502\nPro: Adds checked attribute to formkit-option (dropdown, autocomplete, taglist). #350\nPro: Adds max prop for taglist and autocomplete with multiple inputs. #501\nPro: Adds closeOnSelect prop will keep the listbox expanded as selections are made (autocomplete multiple and taglist).\nPro: Adds forceExpanded prop forces the listbox to remain open for dev purposes (dropdown, autocomplete, and taglist).\nPro: All Pro inputs can now be disabled via disabled attribute.\n🐛 Bug fixes\nFixed a bug where date_after rule showed a incorrect validation message because of timezones. #488\nFixed a bug where self-generated ids did not have an attribute-safe value because of special characters. #517\nv-model values can now be initialized as undefined. #235\nFixed a bug that caused inline validation-rules props to recurse unexpectedly. #514\nFixed a bug that caused the label of checkboxes with multiple options to not be overridden with sections-schema. #541\nFixed a bug that caused labels to not change dynamically in already-rendered validation messages. #297\nFixed a bug that caused the disabled prop to need null instead of false to render the data-disabled attribute on the outer wrapper. #511\nFixed a bug that prevented slots from being conditional (ie using v-if on the <template v-slot> block). #489\nFixed Nuxt and Nuxt playground compatibility issues.\nFixed a bug that caused sections using to not properly respect sections-schema prop.\nFixed an issue with Tailwind prefix and suffix icon variants. #530\nPro: Fixed a taglist bug where duplicate options were loaded from API. #497\nPro: Fixed a bug where the taglist would render duplicate props when multiple prop set to false. #494\nPro: Fixed a bug where autocomplete options were duplicating when being used fast, repeatedly, or with pasted content. #431\nPro: Fixed issue where default value for autocomplete and taglist could not be removed when the provided value was an object literal. #505\nPro: Fixed an issue where the listbox was still visible when no options were passed. #504\n📙 Documentation & Playground\nNew API Reference — TypeScript users rejoice! The API Reference exposes previously undocumented functionality.\nNew Tailwind implementation of our Genesis theme.\nWhen choosing Tailwind CSS in the FormKit Playground the new FormKit Tailwind Genesis theme is loaded automatically for you if your Playground does not already have a formkit.config.js file.\n1.0.0-beta.12\nNovember 15, 2022\n💪 New features\nPro: New Taglist Pro Input now available!\nAdds npx formkit create-app command to easily bootstrap new FormKit projects.\nImproves length rule validation messages across all languages.\nAdds 🇬🇷 Greek (uk) language #460.\nAdds 🇳🇴 Norwegian Bokmål (nb) language #418.\nAdds 🇸🇰 Slovak (sk) language #401.\nPro: All Pro Inputs can now be disabled.\nPro: Improvements to Genesis Pro theme.\nPro: Autocompletes with multiple options selected can now be re-ordered via drag & drop.\nPro: Added missing attrs to the message schema.\n🐛 Bug fixes\nFixed a bug where the label slot didn't work without the label prop #456.\nFixed a bug where you couldn't dynamically change available validation rules #449.\nFixed a bug where swapping keys would not clear an input's value when inside a group. #446.\nFixed a bug where Date object methods were inaccessible from Schema #406.\nFixed a pathing issue that made it difficult for third-parties from accessing files #404.\nFixed a bug that prevented the stopIfFalse argument on the walkTree function.\nFixed a bug where a select input initialized with a null value doesn't have a good value #415.\nPro: Fixed a bug count:blocking event was not emitting properly in Repeaters.\nPro: Updated Repeater indexes to be numbers instead of strings. #422.\nPro: Fixed an autocomplete bug where the next page of options was overriding the current page. #447.\nPro: Fixed a bug where Pro inputs were not showing validation messages on blur #403.\n1.0.0-beta.11\nSeptember 29, 2022\n🎉 New features\nLays foundation for FormKit Pro Inputs!\n🐛 Bug fixes\nFixed a bug where the \"help\" slot appeared twice for checkbox and radio elements #353.\nFixed a bug that caused the FormKit AutoAnimate plugin to fail with Nuxt #361.\nFixed a schema bug where a dot-notation reference to a non-existing sub property causes [Object object] to output after the reference does exists #368.\nFormKit now works with Nuxt 3.0.0-rc.8 and 3.0.0-rc.9 #371 and #383.\nFixed a bug where users were unable to use hooks via plugin to update v-modeled values #391.\nFixed a bug where users were unable to import @formkit/themes/tailwindcss with TypeScript #376.\nFixed a bug that caused default icons to never load when included directly in the configuration.\nFixed a bug where a checkbox validation with \"required\" worked only the first time #169.\n1.0.0-beta.10\nJuly 29, 2022\n🎉 New features\nInput definitions now have an optional family property, which adds a data-family attribute, and sets the value on node.props.family. This is useful for applying plugins and styles to entire \"families\" of inputs like the text family of inputs, which would apply to text, email, password, number, etc.\nInput definitions now include an optional forceTypeProp property which ensures the node.props.type is initialized as a given value even if the input is registered under a different name. For example myModifiedCheckbox could still have node.props.type report \"checkbox\".\nAdds data-multiple attribute to checkboxes and radios when they have multiple options.\nAdds new @submit-invalid event to type=\"form\" inputs. The event is triggered when a user attempts to submit a form but it has invalid inputs.\nAdds new getValidationMessages helper function to @formkit/validation that extracts a Map of nodes and their validation messages.\nAdds new decorator-icon section to checkboxes and radios, making it easy to use custom SVGs in your checkboxes and radios.\nAdds new \"check\" and \"circle\" icons to the built in icon pack.\nAdds 🇦🇿 Azerbaijani (az) language.\nAdds 🇺🇦 Ukrainian (uk) language.\n🐛 Bug fixes\nFixed a regression where a single checkbox was no longer displaying the help text (#310).\nFixed a bug that caused the AutoAnimate plugin to fail on Nuxt SSR (#330).\nFixed a bug that caused all input’s context.state.dirty to turn true when a v-modeled form was edited (#311).\nFixed a bug that caused a race condition between the @change event of a select list and the v-model value propagation (#335).\nFixed a bug that caused conditional props/attrs that returned arrays to return objects instead of arrays (#317).\nFixed a bug that caused empty file inputs to be set to undefined instead of an empty array when node.reset() is called (#319).\nFixed a bug that caused the disabled prop to improperly disable checkboxes and radio inputs when set to a falsy (not nullish) value (#307).\n1.0.0-beta.9\nJune 29, 2022\n⚠️ Breaking changes\nThe file input’s removeFiles section has been renamed to fileRemove.\nThe fileRemove (previously removeFiles) section used to rendered an <a> tag, this has been changed to a button.\nComposables from @formkit/inputs have been replaced with \"sections\". This should only affect users who were creating their own inputs from pre-existing composables.\n🎉 New features\nIcons! FormKit now ships with first class support for icons, including a first-party MIT licensed icon pack with automatic CDN delivery. Read more about it on the new icons documentation page.\nAutoAnimate! FormKit now includes an AutoAnimate plugin, bringing AutoAnimate support to FormKit with a single line of code.\nExports! You can now export any of the existing inputs and restructure them at will using the new @formkit/cli command line tool. Alter existing inputs by adding, removing, updating, or re-ordering sections — or add your own exported and altered input variations to your input library.\nAll inputs have been refactored to use a much improved schema composition API that allows easy composition and modification of schema based inputs.\nAdds new meta property to schema specification (#248).\nFormKit CSS themes can be installed via CDN using the new theme option in defaultConfig()\nAdds new submit and setErrors hooks.\nAdds 🇧🇬 Bulgarian language.\nAdds 🇭🇺 Hungarian language.\nAdds 🇰🇿 Kazakh language.\nAdds 🇷🇸 Serbian language.\nAdds 🇹🇯 Tajik language.\n🐛 Bug fixes\nFixed a bug that caused the key property to not work when using the $formkit shorthand in schema (#232).\nFixed a bug that did not call event handlers on @blur (#239).\nFixed a bug that caused 1 too many for iterations on old Safari browsers (#299).\nAdded automatic keys to FormKit inputs which fixed a smattering reactivity bugs when explicit keys were not used with conditional inputs.\nThe input-errors prop will now reset any errors it previously set when set to an empty object {} (#277).\nAdds support for Czech/Slovak diacritics in alpha and alpha_spaces rules (#281).\n📙 Documentation\nNew docs page for FormKit Icons 🎉.\nNew guide for exporting and restructuring icons!\nNew docs using the AutoAnimate plugin.\nInput diagrams include new icon sections.\n1.0.0-beta.8\nMay 10, 2022\n⚠️ Breaking changes\nThe tailwindcss, unocss, and windicss plugins must now be imported from their own subpath of the @formkit/themes package. For example:\nimport formKitTailwindPlugin from '@formkit/themes/tailwindcss'\n🐛 Bug fixes\nRemoves improper imports from windicss, tailwindcss and unocss.\n1.0.0-beta.7\nMay 9, 2022\n⚠️ Breaking changes\nThe update:model-value event will now only be emitted when using the v-model directive.\nThe input event is now debounced to reduce the amount of noise being emitted. You can use the new input-raw to listen to every input event.\nErrors set via setErrors are now automatically cleared on input by default. To revert to the previous behavior, set preserveErrors: true in your global config object.\nThe @formkit/tailwindcss package is now deprecated — both the formKitTailwind plugin and the generateClasses function have been moved to the @formkit/themes package.\n🎉 New features\ncheckbox, radio, and select inputs (inputs that use :options) can now use any data type as their value like numbers, objects, or even null (#85).\nAdds new node.clearErrors and clearErrors utilities to assist in clearing backend errors from an input or form.\nNow inputs automatically clear any errors set with node.setErrors() on user input. You can override this default behavior (to keep the error on the input) with preserve-errors=\"true\".\nAdds a new node.addProps function for adding new props in custom plugins.\nAdds new message hook for modifying messages as they are being set.\nAdds a new core event reset — emitted after a form is reset.\nAdds a new index prop that allows inputs to be injected at a given index on a parent list type.\nThe <FormKit> component’s input event is now debounced, meaning it emits much less noise.\nExports all input feature functions import { features } from '@formkit/inputs'.\nAdds a new input-raw event to the <FormKit> component which is emitted for every single input event in an input, list, group, or form (very noisy).\nThe core node is now the second argument of the input, input-raw, submit and submit-raw events.\nAdds new core node event dom-input-event which has the native HTML Event object as the payload.\n@formkit/themes now includes named exports for plugin functions for Tailwind CSS (formKitTailwind), Windi CSS (formKitWindi), and Uno CSS (formKitUno). By adding the correct plugin to your CSS framework's configuration file you will have access to a variety of formkit variants such as formkit-invalid: and formkit-disabled:.\n@formkit/themes now includes the generateClasses helper function will allows you to easily supply different class lists to ${sectionKey}s based on input type.\nAdds 🇸🇪 Swedish language.\nAdds 🇸🇮 Slovenian language.\nAdds 🇷🇴 Romanian language.\nAdds 🇯🇵 Japanese language.\nAdds 🇹🇭 Thai language.\nImproves 🇵🇱 Polish language.\n🐛 Bug fixes\n🔥 Dramatically improves v-model performance and reliability for deeply nested structures like forms with list and groups.\nFixes an issue that caused null values to throw errors (#151)\nFixed a bug that caused validation-visibility to not change when updated reactively (#159)\nFixes a bug that caused the preserve keyword to block some form submissions (#145)\nFixes TypeScript typing for the @formkit/tailwind configuration (#143)\nFixes a bug that caused single checkboxes with an object as the on-value to not be set their initial value when using the :value prop.\nFixes a bug that caused validation rules to not be updated when the label prop changed (#170)\nFixes a bug that caused incorrect default selection on select lists with an explicit multiple=\"false\" attribute and a placeholder (#148).\nFixes a bug that caused the classes prop to not react to Vue’s reactivity when using nested refs (#155).\nFixes a bug that prevented submit buttons from being disabled when applied using using the disabled attribute on the form without specifying disabled=\"true\" (#215)\nFixes a schema compiler bug that caused the white space of a quoted string in a parenthesis to be incorrectly removed (#150).\n1.0.0-beta.6\nMarch 10, 2022\n🎉 New features\nAdds new alpha_spaces validation rule (#83)\nAdds 🇨🇿 Czech (thanks @dfridrich)\nAdds  Frisian (thanks @arjendejong12)\n📙 Documentation\nNew configuration documentation that explains the relationship of node options, config, and props.\n🐛 Bug fixes\nFixes a bug that caused radio inputs to loose reactivity when set via node.input() (#139)\nImproves TypeScript annotation for @submit event (#130)\nFixed an issue that caused selects not to render if set to an empty array (#129)\nFixed an error that caused server side rendering errors on Nuxt 3 when running a built project (#113)\nFixed a bug that caused schema variable scoping to be lost when referencing iteration data inside the slot of a component (#91)\n1.0.0-beta.5\nMarch 8, 2022\n⚠️ Breaking changes\nThe data-loading attribute has been moved from the submit button of a form to the <form> tag itself.\n🎉 New features\nAdds new @formkit/tailwindcss plugin to easily create Tailwind themes for your FormKit forms. Check out the Create a Tailwind CSS theme guide for more details.\nAdds a new programmatic reset function. This can be done on any input, group, form, or list and it will restore the value back to its initial state. It also resets the context.state object (like blurred and dirty).\nImproves accessibility by adding aria-describedby and aria-live to all provided input types. aria-describedby now targets help text, validation messages, and error messages (labeling provided by <label> tags that use the for attribute).\nGroups, lists and forms can now apply undefined values to their children. In other words, if a form is v-modeled and its value is set to an empty object {}, it will clear the entire form out.\nAdds new context.state.settled property that signals when the input’s internal debounce cycle has ended and a value is finished being committed to the form.\nAdds data-submitted attribute to inputs that have been submitted.\nAdds new section key fileName (thanks @santi).\nAdds new parent prop that accepts a core node for advanced use cases where inputs are decoupled from their form or data structure is desired.\nAdds 🇱🇾 Arabic (thanks @Ahmedelforjani)\nAdds 🇩🇰 Danish (thanks @bjerggaard)\nAdds 🇮🇩 Indonesian (thanks @rama-adi)\nAdds 🇮🇹 Italian (thanks @punga78, @Archetipo95)\nAdds 🇵🇱 Polish (thanks @xxSkyy)\nAdds 🇰🇷 Korean (thanks @bwp618)\nAdds 🇻🇳 Vietnamese (thanks @oanhnn)\nImproved 🇫🇷 French (thanks @pop123123123)\n🐛 Bug fixes\nFixes a bug that could cause validation errors to flash for 20ms before resolving when using browser autocomplete (#99).\nFixes a bug that caused class props (like input-class) inside schemas to not properly respect the $reset command because it was treated like a variable (#61).\nFixes a bug that didn't allow classes to be modified via section-key class props when the section-key has multiple words, such as file-list-class or file-item-class (#120).\n1.0.0-beta.4\nFebruary 22, 2022\n⚠️ Breaking change\nThe genesis theme should now be imported from import '@formkit/themes/genesis.\n🎉 New features\nAdds programmatic form submission:\nCan be submitted by node node.submit() (including any child node of the form).\nCan be submitted via function this.$formkit.submit('form-id') (for composition api it's submitForm('form-id')).\nImproved setErrors DX:\nCan now be called directly on a node node.setErrors(nodeErrors, childErrors).\nsetErrors now supports pure string node.setErrors('My error')\nSubmit handler is now passed the form’s node for easy error setting.\nA <FormKit> component’s core node is now available via template ref.\nAdds data-invalid attribute to the outer section when an input has failing validation messages that are currently displayed (playground example).\nAdds data-errors attribute to the outer section when the input has explicitly placed errors (via prop or setErrors).\nAdds data-complete attribute to the outer section when an input (playground example):\nEither:\nThe input has validation rules.\nThe validation rules are all passing.\nThere are no errors on the input.\nOr:\nThe input has no validation rules.\nThe input has no errors.\nThe input is dirty and has a value.\nNew context.state properties:\nstate.rules - true when the input has validation rules.\nstate.errors - true when the input has explicit errors placed on it.\nstate.complete - same as logic as data-complete.\nstate.validationVisible - true when the validation-visibility condition is met (it is showing validation errors if there are any).\nRefactors the Nuxt 3 module for faster build time and better file resolution.\nAdds 🇮🇷 Persian language support (thanks @shahabbasian)\nAdds 🇧🇷 Portuguese language support (thanks @r-martins)\nAdds 🇹🇷 Turkish language support (thanks @ragokan)\nAdds 🇫🇮 Finish language support (thanks @mihqusta)\nAdds 🇦🇷 Spanish language support (thanks @inibg)\n📙 Documentation\nAdded node.setErrors documentation.\nAdded programmatic form submission documentation.\nImproved context.state documentation with new properties and better descriptions.\n🐛 Bug fixes\nFixes an issue that caused server side rendering and server side generation on Nuxt and vite-ssg/vitesse to throw exceptions during build process (#81).\nFixes a bug that prevented file inputs from triggering custom onChange events (#90).\nFixes a bug that prevented forms from outputting their id to the DOM.\nFixes a styling issue in the Genesis theme that caused select list items to be grey before an option was selected when using a placeholder (#59)\nFixes a bug that caused the :value prop on forms to be mutated on input (#72).\nFixes inconsistency between prop:{propName} events emitted by default props and custom input defined props (#73)\n1.0.0-beta.3\nFebruary 22, 2022\nbeta.3 was going to be such a great release we decided to skip it and go straight to beta.4 👀 ! Only kidding. We had issues with npm and had to bump 🤦.\n1.0.0-beta.2\nFebruary 3, 2022\n🎉 New features\nNew @formkit/nuxt package is a full featured Nuxt 3 module that makes using FormKit with Nuxt 3 as simple as possible!\ndefaultConfig now includes a new package @formkit/dev which decodes FormKit’s error codes to helpful console messages (no action required) (#56).\nFormKit is officially open-source under the MIT license!\nThe preserve key now applies to all descendants (#53).\nExports all the text formatter functions in the @formkit/i18n package (#54).\nAdds 🇳🇱 Dutch language support (thanks @arjendejong12).\nAdds 🇭🇷 Croatian language support (thanks @antemarkic).\nImproves 🇩🇪 German language support (thanks @tosling).\n📙 Documentation\nNew installation documentation. You no longer need an auth token to install from the @formkit organization!\nNuxt installation documentation\nImproved internationalization documentation for selective message overrides.\n🐛 Bug fixes\nFixes a bug that caused multi-select checkboxes to not display the current value when set from parent node and when using options prop that is stored in an external variable (#55)\nFixed a bug that caused the placeholder on select inputs to be removed if something caused the input to re-render (#52).\nFixed the select placeholder color (#51)\n1.0.0-beta.1\nJanuary 28, 2022\n🎉 New features\nForms are automatically disabled when an async submit handler is pending (#44).\nAdded a new prop submit-behavior to opt-out of the new automatically disabled forms.\nExports the Vue to FormKit bindings plugin as bindings in the @formkit/vue package.\nThe type button and submit are automatically ignored.\nIntroduces a new messages key to the defaultConfig to allow partial overrides to locales. This allows selective message overrides for already registered locales (#42).\nThe schema compiler now supports \"undefined\" as a valid output (in other words $: undefined would output the value undefined instead of the string \"undefined\").\nAdds 🇮🇱 Hebrew locale (thanks @Hepi420)\nAdds 🇨🇳 Chinese locale (thanks @myleslee)\n🐛 Bug fixes\nFixed an issue that caused checkboxes with options to not properly hydrate when re-populated from a group, list, or form (#45).\nFixed an issue that caused checkboxes with options to not display incorrectly when missing a the label prop (#41).\nSignificantly improved TypeScript support for “synthetic” props (#43).\n1.0.0-alpha.5\nJanuary 20, 2022\n⚠️ Breaking changes\nChanges the validation-behavior prop on the <FormKit> component to validation-visibility.\nChanges the schema prop on the <FormKit> component to sections-schema.\n🎉 New features\nAdds the native file input type with support for some value-added features:\nDisplay only re-population.\nDrag and drop.\nInput clearing.\nAdds the createInput helper function to make custom inputs easy to write.\nNew incomplete-message prop allows inline customization (or disabling) of the message displayed by a form when it attempts to submit and all its inputs are not valid.\nUpdates the defaultConfig to accept custom inputs.\nAdds a prefix section key which allows content to be injected immediately before an input element.\nAdds a suffix section key which allows content to be injected immediately after an input element.\n🇷🇺 Russian locale (thank you @andreimakushkin!)\nRefactors Genesis theme to use much more robust CSS variable structure.\nAdds a new feature to schemas that allows users to prefix props and attrs properties with __raw__ to pass the raw value instead of its parsed result (#36).\n📙 Documentation\nNew create a custom input guide.\nNew advanced custom input documentation page.\n\"Composition keys\" will now be referred to as \"Section keys\".\nAdds documentation on plugin.library — the mechanism plugins use to define new input types.\nInteractive code editor for examples now supports multiple files.\nIn the FormKit Playground you can add new files and import them into each other. The FormKit Playground supports .vue, .js, formkit.config.js and tailwind.config.js files.\nThe FormKit Playground is now located at https://formkit.com/playground and old https://formkit.com/playground/vue playgrounds are deprecated.\n🐛 Bug fixes\nFixes a bug that prevented the incomplete message from displaying on forms (#29).\nFixes TypeScript typings for @submit and @submit-raw events.\nFixes the order of numbers in the length and between validation messages to always place the lower number first (#35).\nFixes an issue (#32)with select lists where the :options prop would not accept number values.\n1.0.0-alpha.4\nDecember 16, 2021\n🎉 New features\nNew validation rule “hints” — modifiers that change a validation rule’s behavior. Supported hints allow you to:\nRun a rule when the field is empty.\nForce a rule to run even when previous rules are failing.\nDebounce a validation rule.\nMake a validation rule optional.\nWhen an input is inside a form and unmounted (such as a v-if), it now removes it’s value from the form data and de-registers its core node.\nNew preserve prop allows inputs to not remove their data from groups, lists, and forms when they are removed.\n🐛 Bug fixes\nFixed an issue that caused numeric value radio and checkbox options to render incorrectly.\nFixed a bug that caused the placeholder to not render when the prop came after the options prop.\nFixed a bug that caused the delay value to not be respected when set using ancestor config.\n1.0.0-alpha.3\nDecember 13, 2021\n🎉 New features\nForm error handling is here. You can now set input errors on an entire form, group or list with the input-errors prop or the $formkit.setErrors() methods. Read more about it on the form docs.\nNew $formkit.setLocale() reactively changes the language of all displayed messages.\nAdds 🇫🇷 French and 🇩🇪 German locales (thank you @HoreKk and @digitalkaoz)\nAdds new rootConfig proxy object that is used to store global base config and prop values (significant refactor of configuration system).\nAdded ledger dependency tracking to instances of FormKitObservedNode.\nThe submit button on forms now use the locale for the default “Submit” label.\nNew child node event emitted when a parent has a child added to it.\nThe length rule can now take max/min arguments in either order length:15,5 or length:5,15 evaluate the same.\nAdds a new getNode function to directly access a FormKit node using the composition API.\nImproves the @formkit/theme css import location.\n🐛 Bug Fixes\nFixed a bug that caused children of list inputs to sometimes throw an exception when display validation errors.\nImproved several of the validation error messages.\nFixed an issue with select inputs prevented raw node.input() calls to not trigger reactivity in Vue.\n1.0.0-alpha.2\nNovember 30, 2021\n🎉 New features\nA new $formkit schema shorthand for using FormKit inputs in a schema (Issue #15).\nNew disabled prop on form, list, and group inputs automatically disables all child inputs (Issue #16).\nNew submitAttrs prop on forms allows you to pass attributes to the form’s submit button.\nAdded a new universal ignore prop that prevents an input’s data from being used in a form.\n🐛 Bug fixes\nFixed an issue that prevented schemas from rendering expressions when used inside the children property of a FormKit component. (Issue #21).\nAdded a check in case a rootClasses function incorrectly returns undefined (Issue #17).\nFixed a bug that caused a form's submit button to pollute the form’s data object with a submit_x property (Issue #22).\nFixed a bug that caused $cmp schema nodes to fail to remount if the schema’s root object was reset causing a full re-parse (Issue #14)."
  },
  {
    "title": "The Context Object ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/context",
    "html": "Context object\nIntroduction\n_value\nattrs\nfns\nhandlers\nhelp\nid\nlabel\nmessages\nnode\noptions\noption\nstate\ntype\nui\nclasses\nIntroduction\n\nFormKit inputs use a reactive object to expose data to template slots, rules, and the schema that defines each input. This is called the context object and is found in the each input's core node object at node.context.\n\nThe context object, in general, can be thought of as a general purpose data store for each input. In almost all cases props passed to the <FormKit> component end up in the context object. The context object is the also the slot data passed to all section slots.\n\nThe context object always (unless noted) has the following properties:\n\n_value\n\nFormKit inputs have two values — the committed value (node.value) and the uncommitted value (node._value). At rest, these two values are equivalent, but the uncommitted value is the undebounced raw value of the input.\n\nattrs\n\nAn object containing any attributes that will be passed to the internal input element.\n\nfns\n\nA small object of utility functions that are useful when writing schemas.\n\n{\n\n  // Returns the length of a given object\n\n  length: (obj: Record<PropertyKey, any>) => Number,\n\n  // Casts a value to a number\n\n  number: (value: any) => Number,\n\n  // Casts a value to a string\n\n  string: (value: any) => String,\n\n  // Returns the JSON representation of a value\n\n  json: (value: any) => String | false,\n\n}\nhandlers\n\nA small object of common input handlers for use in the schema. Keep in mind that input \"features\" can replace or add to handlers on an input by input basis.\n\n{\n\n  // sets the state.blurred value to true\n\n  blur: () => void,\n\n  // sets the state.touched value to true\n\n  touch: () => void,\n\n  // Sets the value of the input\n\n  DOMInput: (e: Event) => void\n\n}\nhelp\n\nThe help text of the input provided by the help prop.\n\nid\n\nThe unique identifier of the input. This value is auto-generated unless the id prop is set.\n\nlabel\n\nThe label of the input provided by the label prop.\n\nmessages\n\nAn object of visible messages (where the type is not ui — ui). The key of this object is the message name, and the value is a core message object. For example, for an input displaying a single failing validation message, this object would look like:\n\n{\n\n  rule_required: {\n\n    // Determines if the message prevents form submission\n\n    blocking: true,\n\n    // The unique key of this message\n\n    key: 'rule_required',\n\n    // Additional details about the message, you can put anything in here.\n\n    // Below are the meta details for validation messages:\n\n    meta: {\n\n      // The name of the validation message (used in message lookups)\n\n      messageKey: 'required',\n\n      // Arguments that can be used in i18n translation\n\n      i18nArgs: [{\n\n        node,\n\n        name: 'email',\n\n        args: []\n\n      }]\n\n    },\n\n    // The \"type\" of message — generally the plugin that generated it.\n\n    type: 'validation',\n\n    // The value of the message\n\n    value: 'Email is required',\n\n    // If this message is intended to be displayed to end users — this does not\n\n    // mean the message is actively visible — that is determined by the\n\n    // {type}-visibility rules, but if this is false, it is never displayed to\n\n    // users.\n\n    visible: true\n\n  }\n\n}\nnode\n\nThe underlying core node of the current input. This object is not reactive (within the context of Vue).\n\noptions\n\nFor inputs that accept an options prop, this is a normalized array of option objects.\n\noption\n\nFor inputs that accept an options prop, this object is available to section keys that are inside the iteration (i.e., the label section key on a checkbox input with multiple checkboxes). The object contains a label, value, and sometimes attrs:\n\n{\n\n  value: 'foo',\n\n  label: 'Foo',\n\n  attrs: {\n\n    disabled: true\n\n  }\n\n}\nstate\n\nCurrent state of the input:\n\n{\n\n  /**\n\n   * If the input has been blurred.\n\n   */\n\n  blurred: boolean\n\n  /**\n\n   * True when these conditions are met:\n\n   *\n\n   * Either:\n\n   * - The input has validation rules\n\n   * - The validation rules are all passing\n\n   * - There are no errors on the input\n\n   * Or:\n\n   * - The input has no validation rules\n\n   * - The input has no errors\n\n   * - The input is dirty and has a value\n\n   *\n\n   * This is not intended to be used on forms/groups/lists, but instead on\n\n   * individual inputs. Imagine placing a green checkbox next to each input\n\n   * when the user filled it out correctly — that's what these are for.\n\n   */\n\n  complete: boolean\n\n  /**\n\n   * The dirty-behavior prop controls how this state is set. By default it is\n\n   * considered dirty if any mutation was made to the input, but once a mutation\n\n   * has been made and dirty is `true` it stops checking.\n\n   * \n\n   * Alternatively the dirty-behavior prop can be set to `compare` which will\n\n   * diff the changes between the current value and the initial value after\n\n   * every mutation — this means if the input returns back to its initial value * dirty will become `false` again.\n\n   */\n\n  dirty: boolean\n\n  /**\n\n   * If the input has explicit errors placed on it, or in the case of a group,\n\n   * list, or form, this is true if any children have errors on them.\n\n   */\n\n  errors: boolean\n\n  /**\n\n   * The loading state of the input or form. This property is only added while\n\n   * the input is loading and is removed when loading is complete.\n\n   */\n\n  loading: true | undefined\n\n  /**\n\n   * True when the input has validation rules. Has nothing to do with the\n\n   * state of those validation rules.\n\n   */\n\n  rules: boolean\n\n  /**\n\n   * True when the input has completed its internal debounce cycle and the\n\n   * value was committed to the form.\n\n   */\n\n  settled: boolean\n\n  /**\n\n   * If the form has been submitted.\n\n   */\n\n  submitted: boolean\n\n  /**\n\n   * If the input (or group/form/list) is passing all validation rules. In\n\n   * the case of groups, forms, and lists this includes the validation state\n\n   * of all its children.\n\n   */\n\n  valid: boolean\n\n  /**\n\n   * == Added by @formkit/validation plugin — included in defaultConfig ==\n\n   * If the input (or group/form/list) is currently validating rules — including\n\n   * async validation rules. In the case of groups, forms, and lists this includes\n\n   * the validation state of all its children.\n\n   */\n\n  validating?: boolean\n\n  /**\n\n   * If validation-visibility has been satisfied and any validation\n\n   * messages should be displayed.\n\n   */\n\n  validationVisible: boolean\n\n}\ntype\n\nThe type of the input provided by the type prop. This is the value that should be referenced when looking up definitions in a library of inputs. Examples of this value: text, select, or autocomplete.\n\nui\n\nAn object of visible messages (keyed by the key) of type ui that can be used in the interface. This allows for localized text for use on interface elements.\n\nclasses\n\nA Proxy object for requesting classes. This object allows schema authors to request any section and get a generative class name. For example $classes.input would (by default without additional configuration) return formkit-input while $classes.foobar would return formkit-foobar.\n"
  },
  {
    "title": "formkit/zod ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-zod",
    "html": "@formkit/zod\nIntroduction\nFunctions\ncreateZodPlugin()\nIntroduction\n\nThe first-party zod package/plugin for FormKit. Read the documentation for usage instructions.\n\nFunctions\ncreateZodPlugin()\n\nCreates a new Zod schema plugin for form validation.\n\nSignature\ncreateZodPlugin<Z extends z.ZodTypeAny>(zodSchema: Z, submitCallback: (payload: z.infer<typeof zodSchema>, node: FormKitNode | undefined) => void | Promise<void>): [FormKitPlugin, (payload: any, node: FormKitNode | undefined) => void];\nParameters\nzodSchema — A Zod schema to validate the form against.\nsubmitCallback — A callback to run when the form is submitted and it passes validation.\nReturns\n\nA tuple of a FormKitPlugin and a submit handler.\n"
  },
  {
    "title": "formkit/vue ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-vue",
    "html": "@formkit/vue\nIntroduction\nFunctions\ncreateInput()\ndefineFormKitConfig()\nonSSRComplete()\nssrComplete()\nuseConfig()\nuseInput()\nTypeScript\nFormKitComponentLibrary\nFormKitSetupContext\nFormKitSummaryMessage\nFormKitVuePlugin\nPluginConfigs\nDefaultConfigOptions\nFormKitComponent\nRenderable\nRenderableList\nRenderableSlot\nRenderableSlots\nSlots\nVirtualNode\nIntroduction\n\nThe official FormKit/Vue integration. This package is responsible for integrating Vue with FormKit core and other first-party packages.\n\nFunctions\ncreateInput()\n\nCreates a new input from schema or a Vue component with the \"standard\" FormKit features in place such as labels, help text, validation messages, and class support.\n\nSignature\ncreateInput(schemaOrComponent: FormKitSchemaNode | FormKitSection | Component, definitionOptions?: Partial<FormKitTypeDefinition>): FormKitTypeDefinition;\nParameters\nschemaOrComponent — The actual schema of the input or the component.\ndefinitionOptions optional — Any options in the FormKitTypeDefinition you want to define.\nReturns\n\nFormKitTypeDefinition\n\ndefineFormKitConfig()\nSignature\ndefineFormKitConfig(config: DefaultConfigOptions | (() => DefaultConfigOptions)): () => DefaultConfigOptions;\nParameters\nconfig\nonSSRComplete()\n\nRegister a callback for when SSR is complete. No-op if not in a server context.\n\nSignature\nonSSRComplete(app: App<any> | undefined, callback: CallableFunction): void;\nParameters\napp — The Vue application.\ncallback — The callback to be called after SSR is complete.\nssrComplete()\n\nFlush all callbacks registered with onSSRComplete for a given app.\n\nSignature\nssrComplete(app: App<any>): void;\nParameters\napp — The Vue application.\nuseConfig()\nSignature\nuseConfig(config?: FormKitOptions | ((...args: any[]) => FormKitOptions)): void;\nParameters\nconfig optional\nuseInput()\n\nA composable for creating a new FormKit node.\n\nSignature\nuseInput<Props extends FormKitInputs<Props>, Context extends SetupContext<any, any>>(props: Props, context: Context, options?: FormKitOptions): FormKitNode;\nParameters\nprops\ncontext\noptions optional\nReturns\n\nFormKitNode\n\nTypeScript\nFormKitComponentLibrary\n\nA library of components available to the schema (in addition to globally registered ones)\n\ninterface FormKitComponentLibrary {\n\n    [index: string]: Component;\n\n}\nFormKitSetupContext\n\nType definition for the FormKit component Vue context.\n\ninterface FormKitSetupContext<Props extends FormKitInputs<Props>> {\n\n    attrs: any;\n\n    emit: FormKitEvents<Props>;\n\n    expose(exposed:{\n\n        \n\n    }): void;\n\n    props:{\n\n        \n\n    }&Props;\n\n    slots: Slots<Props>;\n\n}\nFormKitSummaryMessage\ninterface FormKitSummaryMessage {\n\n    id: string;\n\n    key: string;\n\n    message: string;\n\n    type: string;\n\n}\nFormKitVuePlugin\n\nThe global instance of the FormKit plugin.\n\ninterface FormKitVuePlugin {\n\n    clearErrors: (formId: string) => void;\n\n    get: (id: string) => FormKitNode | undefined;\n\n    reset: (formId: string, resetTo?: unknown) => void;\n\n    setErrors: (formId: string, errors: string[] | Record<string, string | string[]>, inputErrors?: string[] | Record<string, string | string[]>) => void;\n\n    setLocale: (locale: string) => void;\n\n    submit: (formId: string) => void;\n\n}\nPluginConfigs\n\nConfiguration for plugins\n\ninterface PluginConfigs {\n\n    iconLoader: FormKitIconLoader;\n\n    iconLoaderUrl: FormKitIconLoaderUrl;\n\n    icons: Record<string, string | undefined>;\n\n    inputs: FormKitLibrary;\n\n    locale: string;\n\n    locales: FormKitLocaleRegistry;\n\n    messages: Record<string, Partial<FormKitLocale>>;\n\n    rules: Record<string, FormKitValidationRule>;\n\n    theme: string;\n\n}\nDefaultConfigOptions\n\nThe allowed options for defaultConfig.\n\nexport type DefaultConfigOptions = FormKitOptions & Partial<PluginConfigs> & Record<string, unknown>;\nFormKitComponent\n\nThe TypeScript definition for the FormKit component.\n\nexport type FormKitComponent = <Props extends FormKitInputs<Props>>(props: Props & VNodeProps & AllowedComponentProps & ComponentCustomProps, context?: Pick<FormKitSetupContext<Props>, 'attrs' | 'emit' | 'slots'>, setup?: FormKitSetupContext<Props>) => VNode<RendererNode, RendererElement, {\n\n    [key: string]: any;\n\n}> & {\n\n    __ctx?: FormKitSetupContext<Props>;\n\n};\nRenderable\n\nThe types of values that can be rendered by Vue.\n\nexport type Renderable = null | string | number | boolean | VirtualNode;\nRenderableList\n\nA list of renderable items.\n\nexport type RenderableList = Renderable | Renderable[] | (Renderable | Renderable[])[];\nRenderableSlot\n\nA slot function that can be rendered.\n\nexport type RenderableSlot = (data?: Record<string, any>, key?: object) => RenderableList;\nRenderableSlots\n\nAn object of slots\n\nexport type RenderableSlots = Record<string, RenderableSlot>;\nSlots\n\nThe type definition for the FormKit’s slots, this is not intended to be used directly.\n\nexport type Slots<Props extends FormKitInputs<Props>> = InputType<Props> extends keyof FormKitInputSlots<Props> ? FormKitInputSlots<Props>[InputType<Props>] : {};\nVirtualNode\n\nThe actual signature of a VNode in Vue.\n\nexport type VirtualNode = VNode<RendererNode, RendererElement, {\n\n    [key: string]: any;\n\n}>;"
  },
  {
    "title": "formkit/utils ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-utils",
    "html": "@formkit/utils\nIntroduction\nFunctions\nassignDeep()\ncamel()\nclone()\ncloneAny()\ndedupe()\nempty()\neq()\neqRegExp()\nescapeExp()\nexcept()\nextend()\ngetAt()\nhas()\ninit()\nisObject()\nisPojo()\nisQuotedString()\nisRecord()\nkebab()\nnodeProps()\nnodeType()\noncePerTick()\nonly()\nparseArgs()\nregexForFormat()\nrmEscapes()\nsetify()\nshallowClone()\nslugify()\nspread()\ntoken()\nundefine()\nwhenAvailable()\nTypeScript\nFormKitDateTokens\nIntroduction\n\nCommonly shared utility functions between official FormKit packages.\n\nYou can add this package by using npm install @formkit/utils or yarn add @formkit/utils.\n\nFunctions\nassignDeep()\n\nPerforms a recursive Object.assign -like operation.\n\nSignature\nassignDeep<A extends Record<PropertyKey, any>, B extends Record<PropertyKey, any>>(a: A, b: B): A & B;\nParameters\na — An object to be assigned.\nb — An object to get values from.\nReturns\n\nA & B\n\ncamel()\n\nThis converts kebab-case to camelCase. It ONLY converts from kebab to camel.\n\nSignature\ncamel(str: string): string;\nParameters\nstr — String to be camel cased.\nReturns\n\nstring\n\nclone()\n\nPerform a recursive clone on a given object. Only intended to be used for simple objects like arrays and POJOs.\n\nSignature\nclone<T extends Record<string, unknown> | unknown[] | null>(obj: T, explicit?: string[]): T;\nParameters\nobj — Object to be cloned.\nexplicit optional — Array of items to be explicity cloned.\nReturns\n\nT\n\ncloneAny()\n\nClones anything. If the item is scalar, no worries, it passes it back. If it is an object, it performs a (fast/loose) clone operation.\n\nSignature\ncloneAny<T>(obj: T): T;\nParameters\nobj — The value to be cloned.\nReturns\n\nT\n\ndedupe()\n\nGiven 2 arrays, return them as a combined array with no duplicates.\n\nSignature\ndedupe<T extends any[] | Set<any>, X extends any[] | Set<any>>(arr1: T, arr2?: X): any[];\nParameters\narr1 — First array.\narr2 optional — Second array.\nReturns\n\nany[]\n\nempty()\n\nDetermines if a value is empty or not.\n\nSignature\nempty(value: any): boolean;\nParameters\nvalue — The value to check if it's empty.\nReturns\n\nboolean\n\neq()\n\nCompare two values for equality, optionally at depth.\n\nSignature\neq(valA: any, valB: any, deep?: boolean, explicit?: string[]): boolean;\nParameters\nvalA — First value.\nvalB — Second value.\ndeep optional — If it will compare deeply if it's an object.\nexplicit optional — An array of keys to explicity check.\nReturns\n\nboolean\n\neqRegExp()\n\nA regular expression to test for a valid date string.\n\nSignature\neqRegExp(x: RegExp, y: RegExp): boolean;\nParameters\nx — A RegExp to compare.\ny — A RegExp to compare.\nescapeExp()\n\nEscape a string for use in regular expressions.\n\nSignature\nescapeExp(string: string): string;\nParameters\nstring — String to be escaped.\nReturns\n\nstring\n\nexcept()\n\nReturn a new (shallow) object with any desired props removed.\n\nSignature\nexcept(obj: Record<string, any>, toRemove: Array<string | RegExp>): Record<string, any>;\nParameters\nobj — The starting object.\ntoRemove — The array of properties to remove. Accepts strings or regular expressions.\nReturns\n\nRecord<string, any>\n\nextend()\n\nRecursively merge data from additional into original returning a new object.\n\nSignature\nextend(original: Record<string, any>, additional: Record<string, any> | string | null, extendArrays?: boolean, ignoreUndefined?: boolean): Record<string, any> | string | null;\nParameters\noriginal — The original array.\nadditional — The array to merge.\nextendArrays optional — If it will extend/concatenate array values instead of replacing them.\nignoreUndefined optional — If it will preserve values from the original object even if the additional object has those values set to undefined.\nReturns\n\nRecord<string, any> | string | null\n\nNO_SIDE_EFFECTS\n\ngetAt()\n\nGet a specific value via dot notation.\n\nSignature\ngetAt(obj: any, addr: string): unknown;\nParameters\nobj — An object to fetch data from.\naddr — An \"address\" in dot notation.\nReturns\n\nunknown\n\nhas()\n\nChecks if the given property exists on the given object.\n\nSignature\nhas(obj: {\n\n    [index: string]: any;\n\n    [index: number]: any;\n\n}, property: string | symbol | number): boolean;\nParameters\nobj — An object to check.\nproperty — The property to check.\nReturns\n\nboolean\n\ninit()\n\nDefines an object as an initial value.\n\nSignature\ninit<T extends object>(obj: T): T & {\n\n    __init?: true;\n\n};\nParameters\nobj — Object to be added an initial value.\nReturns\n\nT & { __init?: true }\n\nisObject()\n\nChecks if an object is a simple array or record.\n\nSignature\nisObject(o: unknown): o is Record<PropertyKey, unknown> | unknown[];\nParameters\no — Value to be checked.\nReturns\n\nboolean\n\nisPojo()\n\nAttempts to determine if an object is a POJO (Plain Old JavaScript Object). Mostly lifted from is-plain-object: https://github.com/jonschlinkert/is-plain-object Copyright (c) 2014-2017, Jon Schlinkert.\n\nSignature\nisPojo(o: any): o is Record<string, any>;\nParameters\no — The value to be checked.\nReturns\n\nboolean\n\nisQuotedString()\n\nDetermine if the given string is fully quoted.\n\nSignature\nisQuotedString(str: string): boolean;\nParameters\nstr — The string to check.\nReturns\n\nboolean\n\nExamples\nhello - false\n\n\"hello\" - true\n\n'world' - true\n\n\"hello\"==\"world\" - false\n\n\"hello'this'\" - false\n\n\"hello\"'there' - false\n\n\"hello\"\"there\" - false\n\n'hello === world' - true\nisRecord()\n\nDetermines if an object is an object.\n\nSignature\nisRecord(o: unknown): o is Record<PropertyKey, unknown>;\nParameters\no — The value to be checked.\nReturns\n\nboolean\n\nkebab()\n\nThis converts camel-case to kebab case. It ONLY converts from camel to kebab.\n\nSignature\nkebab(str: string): string;\nParameters\nstr — String to be kebabed.\nReturns\n\nstring\n\nnodeProps()\n\nFilters out values from an object that should not be considered \"props\" of a core node, like \"value\" and \"name\".\n\nSignature\nnodeProps(...sets: Array<Record<string, any>>): Record<string, any>;\nParameters\nsets — The arrays to get values filtered out of.\nReturns\n\nRecord<string, any>\n\nnodeType()\n\nGiven a FormKit input type, returns the correct lowerCased() type.\n\nSignature\nnodeType(type: string): 'list' | 'group' | 'input';\nParameters\ntype — String to return to check for correct type\nReturns\n\n'list' | 'group' | 'input'\n\noncePerTick()\n\nGiven a function only 1 call will be made per call stack. All others will be discarded.\n\nSignature\noncePerTick<T extends CallableFunction>(fn: T): T;\nParameters\nfn — The function to be called once per tick.\nReturns\nonly()\n\nExtracts a set of keys from a given object. Importantly, this will extract values even if they are not set on the original object — they will just have an undefined value.\n\nSignature\nonly(obj: Record<string, any>, include: Array<string | RegExp>): Record<string, any>;\nParameters\nobj — The object to get values from.\ninclude — The array of items to get.\nReturns\n\nRecord<string, any>\n\nparseArgs()\n\nParse a string for comma-separated arguments.\n\nSignature\nparseArgs(str: string): string[];\nParameters\nstr — String to parse arguments from.\nReturns\n\nstring[]\n\nregexForFormat()\n\nGiven a string date format, return a regex to match against.\n\nSignature\nregexForFormat(format: string): RegExp;\nParameters\nformat — String to be transformed to RegExp.\nReturns\n\nRegExp\n\nExamples\nregexForFormat('MM') // returns '(0[1-9]|1[012])'\nrmEscapes()\n\nRemove extra escape characters.\n\nSignature\nrmEscapes(str: string): string;\nParameters\nstr — String to remove extra escape characters from.\nReturns\n\nstring\n\nsetify()\n\nCreates a new set of the specified type and uses the values from an Array or an existing Set.\n\nSignature\nsetify<T>(items: Set<T> | T[] | null | undefined): Set<T>;\nParameters\nitems — An array or a Set.\nReturns\n\nSet<T>\n\nExamples\nimport { setify } from '@formkit/utils'\n\n\n\nconst tk = setify(['a', 'b'])\n\n// Set(2) {'a', 'b'}\nshallowClone()\n\nShallowly clones the given object.\n\nSignature\nshallowClone<T>(obj: T, explicit?: string[]): T;\nParameters\nobj — Object to be shallowly cloned.\nexplicit optional — The array of keys to be explicity cloned.\nReturns\n\nT\n\nslugify()\n\nTurn any string into a URL/DOM-safe string.\n\nSignature\nslugify(str: string): string;\nParameters\nstr — String to be slugified to a URL -safe string.\nReturns\n\nstring\n\nspread()\n\nSpreads an object or an array, otherwise returns the same value.\n\nSignature\nspread<T>(obj: T, explicit?: string[]): T;\nParameters\nobj — The object to be spread.\nexplicit optional — The array of items to be explicity spread.\nReturns\n\nT\n\ntoken()\n\nGenerates a random string.\n\nSignature\ntoken(): string;\nReturns\n\nstring\n\nExamples\nimport { token } from '@formkit/utils'\n\n\n\nconst tk = token()\n\n// 'jkbyqnphqm'\nundefine()\n\nDetermines if the value of a prop that is either present (true) or not present (undefined). For example, the prop disabled should disable by just existing, but what if it is set to the string \"false\" — then it should not be disabled.\n\nSignature\nundefine(value: unknown): true | undefined;\nParameters\nvalue — Value to check for undefined.\nReturns\n\ntrue | undefined\n\nwhenAvailable()\n\nUses a global mutation observer to wait for a given element to appear in the DOM.\n\nSignature\nwhenAvailable(childId: string, callback: (el: Element) => void, root?: Document | ShadowRoot): void;\nParameters\nchildId — The id of the child node.\ncallback — The callback to call when the child node is found.\nroot optional\nTypeScript\nFormKitDateTokens\n\nThe date token strings that can be used for date formatting.\n\nexport type FormKitDateTokens = 'MM' | 'M' | 'DD' | 'D' | 'YYYY' | 'YY';"
  },
  {
    "title": "formkit/validation ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-validation",
    "html": "@formkit/validation\nIntroduction\nFunctions\ncreateMessageName()\ncreateValidationPlugin()\ngetValidationMessages()\nTypeScript\nFormKitValidationHints\nFormKitValidationMessage\nFormKitValidationMessages\nFormKitValidationRules\nFormKitValidation\nFormKitValidationI18NArgs\nFormKitValidationIntent\nFormKitValidationRule\nIntroduction\n\nThe first-party validation package/plugin for FormKit. Read the validation documentation for usage instructions.\n\nFunctions\ncreateMessageName()\n\nGiven a node, this returns the name that should be used in validation messages. This is either the validationLabel prop, the label prop, or the name of the input (in that order).\n\nSignature\ncreateMessageName(node: FormKitNode): string;\nParameters\nnode — The node to display\nReturns\ncreateValidationPlugin()\n\nThe actual validation plugin function. Everything must be bootstrapped here.\n\nSignature\ncreateValidationPlugin(baseRules?: FormKitValidationRules): (node: FormKitNode) => void;\nParameters\nbaseRules optional — Base validation rules to include in the plugin. By default, FormKit makes all rules in the @formkit/rules package available via the defaultConfig.\ngetValidationMessages()\n\nExtracts all validation messages from the given node and all its descendants. This is not reactive and must be re-called each time the messages change.\n\nSignature\ngetValidationMessages(node: FormKitNode): Map<FormKitNode, FormKitMessage[]>;\nParameters\nnode — The FormKit node to extract validation rules from — as well as its descendants.\nTypeScript\nFormKitValidationHints\n\nSpecial validation properties that affect the way validations are applied.\n\ninterface FormKitValidationHints {\n\n    blocking: boolean;\n\n    debounce: number;\n\n    force: boolean;\n\n    name: string;\n\n    skipEmpty: boolean;\n\n}\nFormKitValidationMessage\n\nThe interface for the localized validation message function.\n\ninterface FormKitValidationMessage {\n\n    (...args: FormKitValidationI18NArgs): string;\n\n}\nFormKitValidationMessages\n\nThe interface for the localized validation message registry.\n\ninterface FormKitValidationMessages {\n\n    [index: string]: string | FormKitValidationMessage;\n\n}\nFormKitValidationRules\n\nFormKit validation rules are structured as on object of key/function pairs where the key of the object is the validation rule name.\n\ninterface FormKitValidationRules {\n\n    [index: string]: FormKitValidationRule;\n\n}\nFormKitValidation\n\nDefines what fully parsed validation rules look like.\n\nexport type FormKitValidation = {\n\n    rule: FormKitValidationRule;\n\n    args: any[];\n\n    timer: number;\n\n    state: boolean | null;\n\n    queued: boolean;\n\n    deps: FormKitDependencies;\n\n    messageObserver?: FormKitObservedNode;\n\n} & FormKitValidationHints;\nFormKitValidationI18NArgs\n\nThe arguments that are passed to the validation messages in the i18n plugin.\n\nexport type FormKitValidationI18NArgs = [\n\n    {\n\n        node: FormKitNode;\n\n        name: string;\n\n        args: any[];\n\n        message?: string;\n\n    }\n\n];\nFormKitValidationIntent\n\nDefines what validation rules look like when they are parsed, but have not necessarily had validation rules substituted in yet.\n\nexport type FormKitValidationIntent = [string | FormKitValidationRule, ...any[]];\nFormKitValidationRule\n\nSignature for a generic validation rule. It accepts an input — often a string — but should be able to accept any input type, and returns a boolean indicating whether or not it passed validation.\n\nexport type FormKitValidationRule = {\n\n    (node: FormKitNode, ...args: any[]): boolean | Promise<boolean>;\n\n    ruleName?: string;\n\n} & Partial<FormKitValidationHints>;"
  },
  {
    "title": "formkit/inputs ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-inputs",
    "html": "@formkit/inputs\nIntroduction\nHelpers\n$attrs()\n$extend()\n$for()\n$if()\n$root()\nFeatures\ncheckboxes()\ndefaultIcon()\nfiles()\ninitialValue()\nlocalize()\nnormalizeBoxes()\noptions()\nradios()\nFunctions\ncasts()\ncreateLibraryPlugin()\ncreateSection()\ndisables()\neachSection()\nextendSchema()\nfindSection()\nform()\nignore()\nisGroupOption()\nisSchemaObject()\nisSlotCondition()\nnormalizeOptions()\nrenamesRadios()\nselect()\nuseSchema()\nTypeScript\nFormKitBaseEvents\nFormKitBaseProps\nFormKitBaseSlots\nFormKitBoxSlots\nFormKitConditionalProps\nFormKitEventsAsProps\nFormKitFile\nFormKitFileSlots\nFormKitInputEvents\nFormKitInputEventsAsProps\nFormKitInputProps\nFormKitInputSlots\nFormKitOptionsGroupItem\nFormKitOptionsGroupItemProp\nFormKitOptionsItem\nFormKitOptionsPropExtensions\nFormKitRuntimeProps\nFormKitSchemaExtendableSection\nFormKitSection\nFormKitSelectSlots\nFormKitSlotData\nFormKitTextSlots\nOptionSlotData\nAllReals\nFormKitButtonSlots\nFormKitEvents\nFormKitFileValue\nFormKitInputs\nFormKitInputSchema\nFormKitOptionsList\nFormKitOptionsListWithGroups\nFormKitOptionsListWithGroupsProp\nFormKitOptionsProp\nFormKitOptionsPropWithGroups\nFormKitOptionsValue\nInputType\nMergedEvents\nMergedProps\nPropType\nIntroduction\n\nThe official FormKit Inputs plugin. This package contains the source code for all native HTML input types. Read the inputs documentation for usage instructions.\n\nHelpers\n$attrs()\n\nApplies attributes to a given schema section by applying a higher order function that merges a given set of attributes into the node.\n\nSignature\n$attrs(attrs: FormKitSchemaAttributes | (() => FormKitSchemaAttributes), section: FormKitSchemaExtendableSection): FormKitSchemaExtendableSection;\nParameters\nattrs — Attributes to apply to a FormKitSchemaExtendableSection.\nsection — A section to apply attributes to.\nReturns\n\nFormKitSchemaExtendableSection\n\n$extend()\n\nExtends a schema node with a given set of extensions.\n\nSignature\n$extend(section: FormKitSchemaExtendableSection, extendWith: Partial<FormKitSchemaNode>): FormKitSchemaExtendableSection;\nParameters\nsection — A section to apply an extension to.\nextendWith — A partial schema snippet to apply to the section.\nReturns\n\nFormKitSchemaExtendableSection\n\n$for()\n\nApplies a condition to a given schema section.\n\nSignature\n$for(varName: string, inName: string, section: FormKitSchemaExtendableSection): (extensions: Record<string, Partial<FormKitSchemaNode>>) => FormKitSchemaNode;\nParameters\nvarName — The name of the variable that holds the current instance.\ninName — The variable we are iterating over.\nsection — A section to repeat.\nReturns\n\nFormKitSchemaExtendableSection\n\n$if()\n\nApplies a condition to a given schema section.\n\nSignature\n$if(condition: string, then: FormKitSchemaExtendableSection, otherwise?: FormKitSchemaExtendableSection): FormKitSchemaExtendableSection;\nParameters\ncondition — A schema condition to apply to a section.\nthen — The section that applies if the condition is true.\notherwise optional — (else) The section that applies if the condition is false.\nReturns\n\nFormKitSchemaExtendableSection\n\n$root()\n\nCreates a root schema section.\n\nSignature\n$root(section: FormKitSchemaExtendableSection): FormKitExtendableSchemaRoot;\nParameters\nsection — A section to make a root from.\nReturns\n\nFormKitSchemaExtendableSection\n\nFeatures\ncheckboxes()\n\nA feature that adds checkbox selection support.\n\nSignature\ncheckboxes(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\ndefaultIcon()\n\nAdds icon props definition.\n\nSignature\ndefaultIcon(sectionKey: string, defaultIcon: string): (node: FormKitNode) => void;\nParameters\nsectionKey — the location the icon should be loaded.\ndefaultIcon — the icon that should be loaded if a match is found in the user's CSS.\nReturns\n\nA FormKitPlugin.\n\nfiles()\n\nA feature to add file handling support to an input.\n\nSignature\nfiles(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\ninitialValue()\n\nA feature that ensures the input has an initialValue prop.\n\nSignature\ninitialValue(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\nlocalize()\n\nCreates a new feature that generates a localization message of type ui for use on a given component.\n\nSignature\nlocalize(key: string, value?: string): (node: FormKitNode) => void;\nParameters\nkey — The key of the message.\nvalue * optional * — The value of the message.\nReturns\n\nA FormKitPlugin.\n\nnormalizeBoxes()\n\nA feature that normalizes box types (checkboxes, radios).\n\nSignature\nnormalizeBoxes(node: FormKitNode): FormKitMiddleware<{\n\n    prop: string | symbol;\n\n    value: any;\n\n}>;\nParameters\nnode — A FormKitNode.\nReturns\n\nA FormKitMiddleware.\n\noptions()\n\nA feature that converts the options prop to usable values, to be used by a feature or a plugin.\n\nSignature\noptions(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\nradios()\n\nA feature to check if the value being checked is the current value.\n\nSignature\nradios(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\nFunctions\ncasts()\n\nA feature that allows casting to numbers.\n\nSignature\ncasts(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\ncreateLibraryPlugin()\n\nCreates a plugin based on a list of FormKitLibrary.\n\nSignature\ncreateLibraryPlugin(...libraries: FormKitLibrary[]): FormKitPlugin;\nParameters\nlibraries — One or many FormKitLibrary.\nReturns\n\nFormKitPlugin\n\ncreateSection()\n\nCreates a new reusable section.\n\nSignature\ncreateSection(section: string, el: string | null | (() => FormKitSchemaNode), fragment: true): FormKitSection<FormKitExtendableSchemaRoot>;\n\ncreateSection(section: string, el: string | null | (() => FormKitSchemaNode)): FormKitSection<FormKitSchemaExtendableSection>;\n\ncreateSection(section: string, el: string | (() => FormKitSchemaNode), fragment: false): FormKitSection<FormKitSchemaExtendableSection>;\nParameters\nsection — A single section of schema\nel — The element or a function that returns a schema node.\nfragment\nReturns\n\nReturns a FormKitExtendableSchemaRoot or a FormKitSchemaExtendableSection.\n\ndisables()\n\nA feature that allows disabling children of this node.\n\nSignature\ndisables(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\neachSection()\n\nRuns a callback over every section in a schema. if stopOnCallbackReturn is true and the callback returns a value, the loop will stop and return that value.\n\nSignature\neachSection<T>(schema: FormKitSchemaDefinition, callback: (section: FormKitSchemaComponent | FormKitSchemaDOMNode, schemaParent: FormKitSchemaNode[], schema: FormKitSchemaCondition) => T, stopOnCallbackReturn?: boolean, schemaParent?: FormKitSchemaNode[]): T | void;\nParameters\nschema — A FormKitSchemaNode array.\ncallback — A callback to run on every section.\nstopOnCallbackReturn * optional * — If true, the loop will stop if the callback returns a value.\nschemaParent * optional * — The parent of the current schema node.\nReturns\nextendSchema()\n\nExtends a single schema node with an extension. The extension can be any partial node including strings.\n\nSignature\nextendSchema(schema: FormKitSchemaNode, extension?: Partial<FormKitSchemaNode>): FormKitSchemaNode;\nParameters\nschema — The base schema node.\nextension * optional * — The values to extend on the base schema node.\nReturns\n\nFormKitSchemaNode\n\nfindSection()\n\nFinds a seciton by name in a schema.\n\nSignature\nfindSection(schema: FormKitSchemaDefinition, target: string): [false, false] | [FormKitSchemaNode[] | false, FormKitSchemaCondition];\nParameters\nschema — A FormKitSchemaDefinition array.\ntarget — The name of the section to find.\nReturns\n\na tuple of the schema and the section or a tuple of false and false if not found.\n\nform()\n\nA feature to add a submit handler and actions section.\n\nSignature\nform(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\nignore()\n\nA feature that applies ignore=\"true\" by default.\n\nSignature\nignore(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\nisGroupOption()\n\nA helper to determine if an option is a group or an option.\n\nSignature\nisGroupOption(option: FormKitOptionsItem | FormKitOptionsGroupItem | FormKitOptionsGroupItemProp): option is FormKitOptionsGroupItem;\nParameters\noption — An option\nisSchemaObject()\n\nType guard for schema objects.\n\nSignature\nisSchemaObject(schema: Partial<FormKitSchemaNode>): schema is FormKitSchemaDOMNode | FormKitSchemaComponent | FormKitSchemaFormKit;\nParameters\nschema — returns true if the node is a schema node but not a string or conditional.\nReturns\n\nboolean\n\nisSlotCondition()\n\nChecks if the current schema node is a slot condition.\n\nSignature\nisSlotCondition(node: FormKitSchemaNode): node is {\n\n    if: string;\n\n    then: string;\n\n    else: FormKitSchemaNode | FormKitSchemaNode[];\n\n};\nParameters\nnode — A FormKitSchemaNode.\nReturns\n\nboolean\n\nExamples\n{\n\n if: '$slot.name',\n\n then: '$slot.name',\n\n else: []\n\n} // this schema node would return true.\nnormalizeOptions()\n\nA function to normalize an array of objects, array of strings, or object of key-values to use an array of objects with value and label properties.\n\nSignature\nnormalizeOptions<T extends FormKitOptionsPropWithGroups>(options: T): T extends FormKitOptionsProp ? FormKitOptionsList : FormKitOptionsListWithGroups;\nParameters\noptions — An un -normalized FormKitOptionsProp.\nReturns\n\nA list of FormKitOptionsList.\n\nrenamesRadios()\n\nAutomatically rename any radio inputs.\n\nSignature\nrenamesRadios(node: FormKitNode): void;\nParameters\nnode — A formkit node.\nReturns\nselect()\n\nConverts the options prop to usable values.\n\nSignature\nselect(node: FormKitNode): void;\nParameters\nnode — A formkit node.\nuseSchema()\n\nCreates an input schema with all of the wrapping base schema.\n\nSignature\nuseSchema(inputSection: FormKitSection): FormKitSchemaExtendableSection;\nParameters\ninputSection — Content to store in the input section key location.\nReturns\n\nFormKitExtendableSchemaRoot\n\nTypeScript\nFormKitBaseEvents\n\nGeneral input events available to all FormKit inputs.\n\ninterface FormKitBaseEvents<Props extends FormKitInputs<Props>> {\n\n    (event:'input', value: PropType<Props, 'value'>, node: FormKitNode): any;\n\n    (event:'inputRaw', value: PropType<Props, 'value'>, node: FormKitNode): any;\n\n    (event:'input-raw', value: PropType<Props, 'value'>, node: FormKitNode): any;\n\n    (event:'update: modelValue', value: PropType<Props, 'value'>): any;\n\n    (event:'update: model-value', value: PropType<Props, 'value'>): any;\n\n    (event:'node', node: FormKitNode): any;\n\n}\nFormKitBaseProps\n\nBase props that should be applied to all FormKit inputs. These are not actual runtime props and are pulled from the context.attrs object. Many of these are just html attributes that are passed through to the input element.\n\ninterface FormKitBaseProps {\n\n    accept: string;\n\n    action: string;\n\n    actions:'true' | 'false' | boolean;\n\n    dirtyBehavior:'touched' | 'compare';\n\n    disabled:'true' | 'false' | boolean;\n\n    enctype: string;\n\n    help: string;\n\n    ignore:'true' | 'false' | boolean;\n\n    label: string;\n\n    max: string | number;\n\n    method: string;\n\n    min: string | number;\n\n    multiple:'true' | 'false' | boolean;\n\n    placeholder: string;\n\n    preserve:'true' | 'false' | boolean;\n\n    preserveErrors:'true' | 'false' | boolean;\n\n    step: string | number;\n\n}\nFormKitBaseSlots\n\nNearly all inputs in FormKit have a \"base\" set of slots. This is the \"sandwich\" around the input itself, like the wrappers, help text, error messages etc. Several other input’s slots extend this base interface.\n\ninterface FormKitBaseSlots<Props extends FormKitInputs<Props>> {\n\n    help: FormKitSlotData<Props>;\n\n    inner: FormKitSlotData<Props>;\n\n    input: FormKitSlotData<Props>;\n\n    label: FormKitSlotData<Props>;\n\n    message: FormKitSlotData<Props, {\n\n        message: FormKitMessage;\n\n    }>;\n\n    messages: FormKitSlotData<Props>;\n\n    outer: FormKitSlotData<Props>;\n\n    prefix: FormKitSlotData<Props>;\n\n    prefixIcon: FormKitSlotData<Props>;\n\n    suffix: FormKitSlotData<Props>;\n\n    suffixIcon: FormKitSlotData<Props>;\n\n    wrapper: FormKitSlotData<Props>;\n\n}\nFormKitBoxSlots\n\nThe slots available to the radio and checkbox inputs when options are provided.\n\ninterface FormKitBoxSlots<Props extends FormKitInputs<Props>> {\n\n    box: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    decorator: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    decoratorIcon: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    fieldset: FormKitSlotData<Props>;\n\n    help: FormKitSlotData<Props>;\n\n    icon: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    inner: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    input: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    label: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    legend: FormKitSlotData<Props>;\n\n    message: FormKitSlotData<Props, {\n\n        message: FormKitMessage;\n\n    }>;\n\n    messages: FormKitSlotData<Props>;\n\n    option: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    optionHelp: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    options: FormKitSlotData<Props>;\n\n    prefix: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    suffix: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    wrapper: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n}\nFormKitConditionalProps\n\nThese are props that are used as conditionals in one or more inputs, and as such they need to be defined on all input types. These should all be defined explicitly as \"undefined\" here, and then defined as their specific type in the FormKitInputProps interface only on the inputs that use them.\n\ninterface FormKitConditionalProps {\n\n    number: undefined;\n\n    offValue: undefined;\n\n    onValue: undefined;\n\n    options: undefined;\n\n}\nFormKitEventsAsProps\n\nIn a perfect world this interface would not be required at all. However, Vue expects the interfaces to be defined as method overloads. Unfortunately since our events interface uses generics UnionToIntersection is not able to be used meaning that we lose event data if we store the events as a standard interface with property keys. The only way we have found to reliably get Volar (as of June 2023) to properly recognize all defined events is to use a the \"standard\" method overload approach (see FormKitBaseEvents).\n\n(Basically we cannot use the events in this interface to automatically produce the FormKitBaseEvents without Volar loosing event data)\n\nThis means we have no way to get the event names out of the interface so we cannot properly use them in our props. This matters for things like TSX support where the event names need to be available as onEventName props.\n\nThis interface is used to manually patch that gap in the type system. These types should match up 1-1 with the events defined in FormKitBaseEvents as well as FormKitInputEvents.\n\ninterface FormKitEventsAsProps {\n\n    'onUpdate: modelValue': (value: unknown, node: FormKitNode) => any;\n\n    onInput: (value: unknown, node: FormKitNode) => any;\n\n    onInputRaw: (value: unknown, node: FormKitNode) => any;\n\n    onNode: (node: FormKitNode) => any;\n\n}\nFormKitFile\n\nA single file object in FormKit’s synthetic \"FileList\".\n\ninterface FormKitFile {\n\n    file?: File;\n\n    name: string;\n\n}\nFormKitFileSlots\n\nThe slots available to the file input, these extend the base slots.\n\ninterface FormKitFileSlots<Props extends FormKitInputs<Props>> extends FormKitBaseSlots<Props> {\n\n    fileItem: FormKitSlotData<Props>;\n\n    fileItemIcon: FormKitSlotData<Props, {\n\n        file: FormKitFile;\n\n    }>;\n\n    fileList: FormKitSlotData<Props>;\n\n    fileName: FormKitSlotData<Props, {\n\n        file: FormKitFile;\n\n    }>;\n\n    fileRemove: FormKitSlotData<Props, {\n\n        file: FormKitFile;\n\n    }>;\n\n    fileRemoveIcon: FormKitSlotData<Props, {\n\n        file: FormKitFile;\n\n    }>;\n\n    noFiles: FormKitSlotData<Props>;\n\n}\nFormKitInputEvents\n\nUnique events emitted by each FormKit input. The shape of this interface is:\n\ninterface FormKitInputEvents<Props extends Inputs> {\n\n  typeString: { customEvent: (value: PropType<Props, 'value'>) => any } // <-- All unique events\n\n}\n\nAll inputs will also inherit all events from FormKitBaseInputEvents.\n\ninterface FormKitInputEvents<Props extends FormKitInputs<Props>> {\n\n    form:{\n\n        (event:'submit-raw', e: Event, node: FormKitNode): any;\n\n        (event:'submit-invalid', node: FormKitNode): any;\n\n        (event:'submit', data: any, node: FormKitNode): any;\n\n    };\n\n}\nFormKitInputEventsAsProps\n\nSee the comment tome on for why this type is necessary.\n\ninterface FormKitInputEventsAsProps<Props extends FormKitInputs<Props>> {\n\n    form:{\n\n        onSubmitRaw: (e: Event, node: FormKitNode) => any;\n\n        onSubmitInvalid: (node: FormKitNode) => any;\n\n        onSubmit: (data: any, node: FormKitNode) => any;\n\n    };\n\n}\nFormKitInputProps\n\nThis is the base interface for providing prop definitions to the FormKit component. It is used to define the props that are available to the each component in the FormKit library by using a discriminated union type. The structure of this interface is:\n\ninterface FormKitInputProps {\n\n typeString: { type: 'string'; value?: string } // <-- All unique props\n\n}\n\nAll inputs will also inherit all props from FormKitBaseInputProps.\n\nNote: It is important that all inputs provide a type and a value prop.\n\ninterface FormKitInputProps<Props extends FormKitInputs<Props>> {\n\n    _:{\n\n        type?: Props['type']extendskeyofFormKitInputProps<Props>?never: Props['type'];\n\n        value?: string;\n\n    };\n\n    button:{\n\n        type:'button';\n\n        value?: undefined;\n\n    };\n\n    checkbox:{\n\n        type:'checkbox';\n\n        options?: FormKitOptionsProp;\n\n        onValue?: any;\n\n        offValue?: any;\n\n        value?: Props['options']extendsRecord<inferT, string>?T[]: Props['options']extendsFormKitOptionsItem[]?Array<Props['options'][number]['value']>: Props['options']extendsArray<inferT>?T[]: (Props['onValue']extendsAllReals?Props['onValue']: true) | (Props['offValue']extendsAllReals?Props['offValue']: false);\n\n    };\n\n    color:{\n\n        type:'color';\n\n        value?: string;\n\n    };\n\n    date:{\n\n        type:'date';\n\n        value?: string;\n\n    };\n\n    datetimeLocal:{\n\n        type:'datetimeLocal';\n\n        value?: string;\n\n    };\n\n    email:{\n\n        type:'email';\n\n        value?: string;\n\n    };\n\n    file:{\n\n        type:'file';\n\n        value?: FormKitFile[];\n\n    };\n\n    form:{\n\n        type:'form';\n\n        value?: FormKitGroupValue;\n\n        actions?: boolean | string;\n\n        submitAttrs?: Record<string, any>;\n\n        submitBehavior?:'disabled' | 'live';\n\n        incompleteMessage?: false | string;\n\n    };\n\n    group:{\n\n        type:'group';\n\n        value?: FormKitGroupValue;\n\n    };\n\n    hidden:{\n\n        type:'hidden';\n\n        value?: Props['number']extendsAllReals?number: string;\n\n        number?:'integer' | 'float' | 'true' | true;\n\n    };\n\n    list:{\n\n        type:'list';\n\n        value?: unknown[];\n\n        dynamic?: boolean | 'true' | 'false';\n\n        sync?: boolean | 'true' | 'false';\n\n    };\n\n    meta:{\n\n        type:'meta';\n\n        value?: any;\n\n    };\n\n    month:{\n\n        type:'month';\n\n        value?: string;\n\n    };\n\n    number:{\n\n        type:'number';\n\n        value?: Props['number']extendsAllReals?number: string;\n\n        number?:'integer' | 'float' | 'true' | true;\n\n    };\n\n    password:{\n\n        type:'password';\n\n        value?: string;\n\n    };\n\n    radio:{\n\n        type:'radio';\n\n        options: FormKitOptionsProp;\n\n        value?: FormKitOptionsValue<Props['options']>;\n\n    };\n\n    range:{\n\n        type:'range';\n\n        value?: Props['number']extendsAllReals?number: string;\n\n        number?:'integer' | 'float' | 'true' | true;\n\n    };\n\n    search:{\n\n        type:'search';\n\n        value?: Props['number']extendsAllReals?number | string: string;\n\n        number?:'integer' | 'float' | 'true' | true;\n\n    };\n\n    select:{\n\n        type:'select';\n\n        options?: FormKitOptionsPropWithGroups;\n\n        value?: FormKitOptionsValue<Props['options']>;\n\n    };\n\n    submit:{\n\n        type:'submit';\n\n        value?: string;\n\n    };\n\n    tel:{\n\n        type:'tel';\n\n        value?: Props['number']extendsAllReals?number | string: string;\n\n        number?:'integer' | 'float' | 'true' | true;\n\n    };\n\n    text:{\n\n        type:'text';\n\n        value?: Props['number']extendsAllReals?number | string: string;\n\n        number?:'integer' | 'float' | 'true' | true;\n\n    };\n\n    textarea:{\n\n        type:'textarea';\n\n        value?: string;\n\n    };\n\n    time:{\n\n        type:'time';\n\n        value?: string;\n\n    };\n\n    url:{\n\n        type:'url';\n\n        value?: string;\n\n    };\n\n    week:{\n\n        type:'week';\n\n        value?: string;\n\n    };\n\n}\nFormKitInputSlots\n\nSlots provided by each FormKit input. The shape of this interface is:\n\ninterface FormKitInputSlots<Props extends Inputs> {\n\n  typeString: { default: (value: PropType<Props, 'value'>) => any } // <-- All unique slots\n\n}\n\nThere is no automatic inheritance of slots — each slot must be explicitly defined for each input.\n\ninterface FormKitInputSlots<Props extends FormKitInputs<Props>> {\n\n    'datetime-local': FormKitTextSlots<Props>;\n\n    button: FormKitButtonSlots<Props>;\n\n    checkbox: Props['options']extendsAllReals?FormKitBoxSlots<Props>: FormKitBaseSlots<Props>;\n\n    color: FormKitTextSlots<Props>;\n\n    date: FormKitTextSlots<Props>;\n\n    email: FormKitTextSlots<Props>;\n\n    file: FormKitFileSlots<Props>;\n\n    form:{\n\n        form: FormKitSlotData<Props>;\n\n        default: FormKitSlotData<Props>;\n\n        message: FormKitSlotData<Props, {\n\n        message: FormKitMessage;\n\n    }>;\n\n        messages: FormKitSlotData<Props>;\n\n        actions: FormKitSlotData<Props>;\n\n        submit: FormKitSlotData<Props>;\n\n    };\n\n    group:{\n\n        default: FormKitSlotData<Props>;\n\n    };\n\n    hidden:{\n\n        input: FormKitSlotData<Props>;\n\n    };\n\n    list:{\n\n        default: FormKitSlotData<Props>;\n\n    };\n\n    meta:{\n\n        wrapper: FormKitSlotData<Props>;\n\n    };\n\n    month: FormKitTextSlots<Props>;\n\n    number: FormKitTextSlots<Props>;\n\n    password: FormKitTextSlots<Props>;\n\n    radio: Props['options']extendsAllReals?FormKitBoxSlots<Props>: FormKitBaseSlots<Props>;\n\n    range: FormKitTextSlots<Props>;\n\n    search: FormKitTextSlots<Props>;\n\n    select: FormKitSelectSlots<Props>;\n\n    submit: FormKitButtonSlots<Props>;\n\n    tel: FormKitTextSlots<Props>;\n\n    text: FormKitTextSlots<Props>;\n\n    textarea: FormKitTextSlots<Props>;\n\n    time: FormKitTextSlots<Props>;\n\n    url: FormKitTextSlots<Props>;\n\n    week: FormKitTextSlots<Props>;\n\n}\nFormKitOptionsGroupItem\n\nOption groups should always be formatted as an array of objects with group and nested options\n\ninterface FormKitOptionsGroupItem {\n\n    attrs?: Record<string, any>;\n\n    group: string;\n\n    options: FormKitOptionsList;\n\n}\nFormKitOptionsGroupItemProp\n\nOption groups should always be formatted as an array of objects with group and nested options\n\ninterface FormKitOptionsGroupItemProp {\n\n    attrs?: Record<string, any>;\n\n    group: string;\n\n    options: FormKitOptionsProp;\n\n}\nFormKitOptionsItem\n\nOptions should always be formatted as an array of objects with label and value properties.\n\ninterface FormKitOptionsItem<V = unknown> {\n\n    __original?: any;\n\n    [index: string]: any;\n\n    attrs?:{\n\n        disabled?: boolean;\n\n    }&Record<string, any>;\n\n    label: string;\n\n    value: V;\n\n}\nFormKitOptionsPropExtensions\n\nAllows for prop extensions to be defined by using an interface whose keys are ignored, but values are applied to a union type. This allows for any third party code to extend the options prop by using module augmentation to add new values to the union type.\n\ninterface FormKitOptionsPropExtensions {\n\n    arrayOfNumbers: number[];\n\n    arrayOfStrings: string[];\n\n    optionsList: FormKitOptionsList;\n\n    valueLabelPojo: Record<string | number, string>;\n\n}\nFormKitRuntimeProps\n\nTypings for all the built in runtime props.\n\nWarning: As of writing these are only specific to Vue’s runtime prop requirements and should not be used as any kind of external API as they are subject to change.\n\ninterface FormKitRuntimeProps<Props extends FormKitInputs<Props>> {\n\n    classes: Record<string, string | Record<string, boolean> | FormKitClasses>;\n\n    config: Record<string, any>;\n\n    delay: number;\n\n    errors: string[];\n\n    id: string;\n\n    index: number;\n\n    inputErrors: Record<string, string[]>;\n\n    modelValue: PropType<Props, 'value'>;\n\n    name: string;\n\n    parent: FormKitNode;\n\n    plugins: FormKitPlugin[];\n\n    sectionsSchema: Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>;\n\n    sync: boolean | undefined;\n\n    type: string | FormKitTypeDefinition;\n\n    validation: string | Array<[rule: string, ...args: any]>;\n\n    validationLabel: string | ((node: FormKitNode) => string);\n\n    validationMessages: Record<string, string | ((ctx:{\n\n        node: FormKitNode;\n\n        name: string;\n\n        args: any[];\n\n    }) => string)>;\n\n    validationRules: Record<string, (node: FormKitNode) => boolean | Promise<boolean>>;\n\n}\nFormKitSchemaExtendableSection\n\nA function that is called with an extensions argument and returns a valid schema node.\n\ninterface FormKitSchemaExtendableSection {\n\n    _s?: string;\n\n    (extensions: Record<string, Partial<FormKitSchemaNode>>): FormKitSchemaNode;\n\n}\nFormKitSection\n\nA function that when called, returns a function that can in turn be called with an extension parameter.\n\ninterface FormKitSection<T = FormKitSchemaExtendableSection> {\n\n    (...children: Array<FormKitSchemaExtendableSection | string | FormKitSchemaCondition>): T;\n\n}\nFormKitSelectSlots\n\nThe slots available to the sekect input, these extend the base slots.\n\ninterface FormKitSelectSlots<Props extends FormKitInputs<Props>> extends FormKitBaseSlots<Props> {\n\n    default: FormKitSlotData<Props>;\n\n    option: FormKitSlotData<Props, OptionSlotData<Props>>;\n\n    selectIcon: FormKitSlotData<Props>;\n\n}\nFormKitSlotData\n\nThe shape of the context object that is passed to each slot.\n\ninterface FormKitSlotData<Props extends FormKitInputs<Props>, E extends Record<string, any> = {}> {\n\n    (context: FormKitFrameworkContext<PropType<Props, 'value'>>&E): any;\n\n}\nFormKitTextSlots\n\nThe slots available to the FormKitText input, these extend the base slots.\n\ninterface FormKitTextSlots<Props extends FormKitInputs<Props>> extends FormKitBaseSlots<Props> {\n\n}\nOptionSlotData\n\nThe data available to slots that have an option in scope.\n\ninterface OptionSlotData<Props extends FormKitInputs<Props>> {\n\n    option: FormKitOptionsItem<PropType<Props, 'value'>>;\n\n}\nAllReals\n\nAn attempt to capture all non-undefined values. This is used to define various conditionals where undefined is not a concrete type, but all other values need to take one logical branch.\n\nexport type AllReals = number | string | boolean | CallableFunction | Array<any> | null | Record<any, any>;\nFormKitButtonSlots\n\nThe slots available to the button input, these extend the base slots.\n\nexport type FormKitButtonSlots<Props extends FormKitInputs<Props>> = Omit<FormKitBaseSlots<Props>, 'inner'> & {\n\n    default: FormKitSlotData<Props>;\n\n};\nFormKitEvents\n\nAll FormKit events should be included for a given set of props.\n\nexport type FormKitEvents<Props extends FormKitInputs<Props>> = MergedEvents<Props>;\nFormKitFileValue\n\nA synthetic array-based \"FileList\".\n\nexport type FormKitFileValue = FormKitFile[];\nFormKitInputs\n\nAll FormKit inputs should be included for this type.\n\nexport type FormKitInputs<Props extends FormKitInputs<Props>> = MergedProps<Props>[keyof MergedProps<Props>];\nFormKitInputSchema\n\nEither a schema node, or a function that returns a schema node.\n\nexport type FormKitInputSchema = ((children?: FormKitSchemaDefinition) => FormKitSchemaNode) | FormKitSchemaNode;\nFormKitOptionsList\n\nAn array of option items.\n\nexport type FormKitOptionsList = FormKitOptionsItem[];\nFormKitOptionsListWithGroups\n\nAn array of option items with a group.\n\nexport type FormKitOptionsListWithGroups = Array<FormKitOptionsItem | FormKitOptionsGroupItem>;\nFormKitOptionsListWithGroupsProp\n\nAn array of option items with a group support — where the option of the groups can be any valid FormKitOptionsProp type.\n\nexport type FormKitOptionsListWithGroupsProp = Array<FormKitOptionsItem | FormKitOptionsGroupItemProp>;\nFormKitOptionsProp\n\nThe types of options that can be passed to the options prop.\n\nexport type FormKitOptionsProp = FormKitOptionsPropExtensions[keyof FormKitOptionsPropExtensions];\nFormKitOptionsPropWithGroups\n\nThe types of options that can be passed to the options prop.\n\nexport type FormKitOptionsPropWithGroups = FormKitOptionsProp | FormKitOptionsListWithGroupsProp;\nFormKitOptionsValue\n\nThe proper shape of data to be passed to options prop.\n\nexport type FormKitOptionsValue<Options> = Options extends FormKitOptionsProp ? Options extends Record<infer T, string> ? T : Options extends FormKitOptionsItem[] ? Options[number]['value'] : Options extends Array<infer T> ? T : unknown : unknown;\nInputType\n\nSelects the \"type\" from the props if it exists, otherwise it defaults to \"text\".\n\nexport type InputType<Props extends FormKitInputs<Props>> = Props['type'] extends string ? Props['type'] : 'text';\nMergedEvents\n\nMerge all events into a single type. This is then used as the structure for\n\nexport type MergedEvents<Props extends FormKitInputs<Props>> = InputType<Props> extends keyof FormKitInputEvents<Props> ? FormKitBaseEvents<Props> & FormKitInputEvents<Props>[InputType<Props>] : FormKitBaseEvents<Props>;\nMergedProps\n\nA merger of input props, base props, and conditional props. This is then used as the structure for the FormKitInputs type.\n\nexport type MergedProps<Props extends FormKitInputs<Props>> = {\n\n    [K in keyof FormKitInputProps<Props>]: Omit<Partial<FormKitBaseProps>, keyof FormKitInputProps<Props>[K]> & Omit<Partial<FormKitRuntimeProps<Props>>, keyof FormKitInputProps<Props>[K]> & Omit<Partial<FormKitConditionalProps>, keyof FormKitInputProps<Props>[K]> & Partial<K extends keyof FormKitInputEventsAsProps<Props> ? Omit<FormKitEventsAsProps, keyof FormKitInputEventsAsProps<Props>[K]> & FormKitInputEventsAsProps<Props>[K] : FormKitEventsAsProps> & FormKitInputProps<Props>[K];\n\n};\nPropType\n\nExtracts the type from a given prop.\n\nexport type PropType<Props extends FormKitInputs<Props>, T extends keyof FormKitInputs<Props>> = Extract<FormKitInputs<Props>, {\n\n    type: Props['type'] extends string ? Props['type'] : 'text';\n\n}>[T];"
  },
  {
    "title": "formkit/observer ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-observer",
    "html": "@formkit/observer\nIntroduction\nFunctions\ncreateObserver()\ndiffDeps()\nisKilled()\nremoveListeners()\nTypeScript\nFormKitObservedNode\nFormKitWatchable\nFormKitDependencies\nFormKitObserverReceipts\nIntroduction\n\nFormKit Observer is a utility to wrap a FormKitNode in a dependency tracking observer proxy.\n\nFunctions\ncreateObserver()\n\nCreates the observer.\n\nSignature\ncreateObserver(node: FormKitNode, dependencies?: FormKitDependencies): FormKitObservedNode;\nParameters\nnode — The FormKitNode to observe.\ndependencies optional — The dependent nodes and the events that are required to watch for changes.\nReturns\n\nReturns a FormKitObservedNode.\n\ndiffDeps()\n\nDetermines which nodes should be added as dependencies and which should be removed.\n\nSignature\ndiffDeps(previous: FormKitDependencies, current: FormKitDependencies): [FormKitDependencies, FormKitDependencies];\nParameters\nprevious — The previous watcher dependencies.\ncurrent — The new/current watcher dependencies.\nReturns\n\nA tuple of maps: toAdd and toRemove.\n\nisKilled()\n\nChecks if the given node is revoked.\n\nSignature\nisKilled(node: FormKitObservedNode): boolean;\nParameters\nnode — Any observed node to check.\nReturns\n\nA boolean indicating if the node is revoked.\n\nremoveListeners()\n\nRemove all the receipts from the observed node and subtree.\n\nSignature\nremoveListeners(receipts: FormKitObserverReceipts): void;\nParameters\nreceipts — The FormKit observer receipts to remove.\nTypeScript\nFormKitObservedNode\n\nAn API-compatible FormKitNode that is able to determine the full dependency tree of nodes and their values.\n\ninterface FormKitObservedNode extends FormKitNode {\n\n    _node: FormKitNode;\n\n    deps: FormKitDependencies;\n\n    kill: () => undefined;\n\n    observe: () => void;\n\n    receipts: FormKitObserverReceipts;\n\n    stopObserve: () => FormKitDependencies;\n\n    watch:<TextendsFormKitWatchable>(block: T, after?: (value: ReturnType<T>) => void) => void;\n\n}\nFormKitWatchable\n\nA callback to watch for nodes.\n\ninterface FormKitWatchable<T = unknown> {\n\n    (node: FormKitObservedNode): T;\n\n}\nFormKitDependencies\n\nThe dependent nodes and the events that are required to watch for changes.\n\nexport type FormKitDependencies = Map<FormKitNode, Set<string>> & {\n\n    active?: boolean;\n\n};\nFormKitObserverReceipts\n\nA Map of nodes with the values being Maps of eventsName: receipt\n\nexport type FormKitObserverReceipts = Map<FormKitNode, {\n\n    [index: string]: string;\n\n}>;"
  },
  {
    "title": "formkit/themes ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-themes",
    "html": "@formkit/themes\nIntroduction\nFunctions\ncreateIconHandler()\ncreateThemePlugin()\ngenerateClasses()\nTypeScript\nFormKitIconLoader\nFormKitIconLoaderUrl\nIntroduction\n\nThis package contains the official themes for FormKit. Read the installation documentation for more information.\n\nFunctions\ncreateIconHandler()\n\nReturns a function responsible for loading an icon by name.\n\nSignature\ncreateIconHandler(iconLoader?: FormKitIconLoader, iconLoaderUrl?: FormKitIconLoaderUrl): FormKitIconLoader;\nParameters\niconLoader optional — a function for loading an icon when it's not found in the iconRegistry.\niconLoaderUrl optional — a function that returns a remote URL for retrieving an SVG icon by name.\ncreateThemePlugin()\n\nCreates the theme plugin based on a given theme name.\n\nSignature\ncreateThemePlugin(theme?: string, icons?: Record<string, string | undefined>, iconLoaderUrl?: FormKitIconLoaderUrl, iconLoader?: FormKitIconLoader): (node: FormKitNode) => any;\nParameters\ntheme optional — The name or id of the theme to apply.\nicons optional — Icons you want to add to the global icon registry.\niconLoaderUrl optional — A function that returns a remote url for retrieving an SVG icon by name.\niconLoader optional — A function that handles loading an icon when it is not found in the registry.\ngenerateClasses()\n\nA function to generate FormKit class functions from a JavaScript object.\n\nSignature\ngenerateClasses(classes: Record<string, Record<string, string>>): Record<string, string | FormKitClasses | Record<string, boolean>>;\nParameters\nclasses — An object of input types with nested objects of sectionKeys and class lists.\nReturns\n\nAn object of sectionKeys with class functions.\n\nTypeScript\nFormKitIconLoader\n\nA function that returns an icon SVG string.\n\ninterface FormKitIconLoader {\n\n    (iconName: string): string | undefined | Promise<string | undefined>;\n\n}\nFormKitIconLoaderUrl\n\nA function that returns a remote URL for retrieving an SVG icon by name.\n\ninterface FormKitIconLoaderUrl {\n\n    (iconName: string): string | undefined;\n\n}"
  },
  {
    "title": "formkit/i18n ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-i18n",
    "html": "@formkit/i18n\nIntroduction\nFunctions\ncreateI18nPlugin()\ndate()\nlist()\norder()\nsentence()\nTypeScript\nFormKitLocale\nFormKitLocaleMessages\nFormKitLocaleRegistry\nIntroduction\n\nThe official FormKit internationalization (i18n) plugin. This package contains the locales and the plugin that integrates FormKit with these locales. Read the internationalization documentation for usage instructions.\n\nFunctions\ncreateI18nPlugin()\n\nCreate a new internationalization plugin for FormKit.\n\nSignature\ncreateI18nPlugin(registry: FormKitLocaleRegistry): FormKitPlugin;\nParameters\nregistry — The registry of FormKitLocales.\nReturns\n\nFormKitPlugin\n\ndate()\n\nGiven a string or a date, return a nice human-readable version.\n\nSignature\ndate(date: string | Date): string;\nParameters\ndate — A string or a date.\nReturns\n\nstring\n\nlist()\n\nCreates an oxford-comma separated list of items.\n\nSignature\nlist(items: string[], conjunction?: string): string;\nParameters\nitems — the items to list out.\nconjunction optional — in the list \"x, y, and z\", \"and\" is the conjunction. Defaults to \"or\".\nReturns\n\nstring\n\norder()\n\nOrders two variables from smallest to largest.\n\nSignature\norder(first: string | number, second: string | number): [smaller: number | string, larger: number | string];\nParameters\nfirst — The first number or string.\nsecond — The second number or string.\nReturns\n\n[smaller: number | string, larger: number | string]\n\nsentence()\n\nGiven a string, convert it to sentence case.\n\nSignature\nsentence(str: string): string;\nParameters\nstr — The string to sentence case.\nReturns\n\nstring\n\nTypeScript\nFormKitLocale\n\nA locale is just a collection of locale message registries, they are keyed by the type (like a namespace) ex: \"validation\" or \"ui\". Plugin authors can declare their own types too.\n\ninterface FormKitLocale {\n\n    [index: string]: FormKitLocaleMessages;\n\n    ui: FormKitLocaleMessages;\n\n}\nFormKitLocaleMessages\n\nA registry of locale messages — this is simply a keyed/value object with string keys (message name) and either string values (for simple returns) or functions that receive a context object.\n\ninterface FormKitLocaleMessages {\n\n    [index: string]: string | ((...args: any[]) => string);\n\n}\nFormKitLocaleRegistry\n\nThe locale registry is just a key-value pair of locale indexes ('ar', 'en', 'it', etc.) to their respective locales.\n\ninterface FormKitLocaleRegistry {\n\n    [index: string]: FormKitLocale;\n\n}"
  },
  {
    "title": "formkit/core ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-core",
    "html": "@formkit/core\nIntroduction\nFormKitNode\nadd()\naddress\naddProps()\nat()\nchildren\nclearErrors()\nconfig\ndefine()\ndestroy()\neach()\nemit()\nextend()\nfind()\nhook\nindex\ninput()\nisCreated\nisSettled\nledger\nname\noff()\non()\nparent\nprops\nremove()\nreset()\nroot\nsetErrors()\nsettled\nstore\nsubmit()\nt()\ntype\nuse()\nvalue\nwalk()\nFunctions\nbfs()\nclearErrors()\ncompile()\ncreateClasses()\ncreateConfig()\ncreateMessage()\ncreateNode()\ncreateValue()\nderegister()\nerror()\ngenerateClassList()\ngetNode()\nisComponent()\nisConditional()\nisDOM()\nisList()\nisNode()\nisPlaceholder()\nisSugar()\nnames()\nregister()\nreset()\nresetCount()\nresetRegistry()\nsetErrors()\nsubmitForm()\nsugar()\nwarn()\nwatchRegistry()\nTypeScript\nFormKitChildCallback\nFormKitChildValue\nFormKitClasses\nFormKitCompilerOutput\nFormKitConfig\nFormKitContext\nFormKitContextShape\nFormKitCounter\nFormKitCounterCondition\nFormKitDispatcher\nFormKitEvent\nFormKitEventEmitter\nFormKitEventListener\nFormKitExtendableSchemaRoot\nFormKitFrameworkContext\nFormKitFrameworkContextState\nFormKitGroupValue\nFormKitHandlerPayload\nFormKitHooks\nFormKitInputMessages\nFormKitLedger\nFormKitLibrary\nFormKitListContext\nFormKitMessageMeta\nFormKitMessageProps\nFormKitMessageStore\nFormKitNodeExtensions\nFormKitPlaceholderNode\nFormKitPlugin\nFormKitSchemaAttributesCondition\nFormKitSchemaComposable\nFormKitSchemaContext\nFormKitSchemaProps\nFormKitStoreTraps\nFormKitTrap\nKeyedValue\nChildMessageBuffer\nErrorMessages\nFormKitAddress\nFormKitAttributeValue\nFormKitCompilerProvider\nFormKitListContextValue\nFormKitListStatement\nFormKitListValue\nFormKitMessage\nFormKitMiddleware\nFormKitNodeType\nFormKitOptions\nFormKitProps\nFormKitRootConfig\nFormKitSchemaAttributes\nFormKitSchemaComponent\nFormKitSchemaCondition\nFormKitSchemaDefinition\nFormKitSchemaDOMNode\nFormKitSchemaFormKit\nFormKitSchemaMeta\nFormKitSchemaNode\nFormKitSchemaTextNode\nFormKitSearchFunction\nFormKitStore\nFormKitTextFragment\nFormKitTraps\nFormKitTypeDefinition\nMessageClearer\nTrapGetter\nTrapSetter\nIntroduction\n\nThe official FormKit core library. This package is responsible for most of FormKit’s internal functionality. You can read documentation specifically on how it works at formkit.com.\n\nYou can add this package by using npm install @formkit/core or yarn add @formkit/core.\n\nFormKitNode\n\nFormKit's Node object produced by createNode(). Every <FormKit /> input has 1 FormKitNode (\"core node\") associated with it. All inputs, forms, and groups are instances of nodes. Read more about core nodes in the architecture documentation.\n\nadd()\n\nAdd a child to a node. The node must be a group or list.\n\nSignature\nadd: (node: FormKitNode, index?: number) => FormKitNode\nParameters\nnode — A FormKitNode.\nindex optional — A index to where it will added to.\nReturns\n\nThe added FormKitNode.\n\naddress\n\nThe address of the current node from the root of the tree.\n\nSignature\naddress: FormKitAddress\nReturns\n\nA FormKitAddress.\n\naddProps()\n\nAdds props to the given node by removing them from node.props.attrs and moving them to the top-level node.props object.\n\nSignature\naddProps: (props: string[]) => FormKitNode\nParameters\nprops — An array of strings to be added as keys for props.\nReturns\n\nThe FormKitNode.\n\nat()\n\nGets a node at another address. Addresses are dot-syntax paths (or arrays) of node names. For example: form.users.0.first_name. There are a few \"special\" traversal tokens as well:\n\n$root — Selects the root node.\n$parent — Selects the parent node.\n$self — Selects the current node.\nSignature\nat: (address: FormKitAddress | string) => FormKitNode | undefined\nParameters\naddress — An valid string or FormKitAddress.\nReturns\n\nThe found FormKitNode or undefined.\n\nchildren\n\nAn array of child nodes (groups and lists).\n\nSignature\nchildren: Array<FormKitNode>\nReturns\n\nAn array of FormKitNode.\n\nclearErrors()\n\nClears the errors of the node, and optionally all the children.\n\nSignature\nclearErrors: (clearChildren?: boolean, sourceKey?: string) => FormKitNode\nParameters\nclearChildren optional — If it should clear the children.\nsourceKey optional — A source key to use for reset.\nReturns\n\nThe FormKitNode.\n\nconfig\n\nAn object of FormKitConfig that is shared tree -wide with various configuration options that should be applied to the entire tree.\n\nSignature\nconfig: FormKitConfig\nReturns\n\nA FormKitConfig.\n\ndefine()\n\nDefines the current input's library type definition including node type, schema, and props.\n\nSignature\ndefine: (definition: FormKitTypeDefinition) => void\nParameters\ndefinition — A FormKitTypeDefinition.\ndestroy()\n\nRemoves the node from the global registry, its parent, and emits the 'destroying' event.\n\nSignature\ndestroy: () => void\neach()\n\nPerform given callback on each of the given node's children.\n\nSignature\neach: (callback: FormKitChildCallback) => void\nParameters\ncallback — A FormKitChildCallback to be called for each child.\nemit()\n\nEmit an event from the node so it can be listened by on.\n\nSignature\nemit: (event: string, payload?: any, bubble?: boolean, meta: Record<string, unknown>) => FormKitNode\nParameters\nevent — The event name to be emitted.\npayload optional — A value to be passed together with the event.\nbubble optional — If the event should bubble to the parent.\nReturns\n\nThe FormKitNode.\n\nextend()\n\nExtend a FormKitNode by adding arbitrary properties that are accessible via node.{property}().\n\nSignature\nextend: (property: string, trap: FormKitTrap) => FormKitNode\nParameters\nproperty — The property to add the core node (node.{property}).\ntrap — An object with a get and set property.\nReturns\n\nThe FormKitNode.\n\nfind()\n\nWithin a given tree, find a node matching a given selector. Selectors can be simple strings or a function.\n\nSignature\nfind: (\n\n selector: string,\n\n searcher?: keyof FormKitNode | FormKitSearchFunction\n\n) => FormKitNode | undefined\nParameters\nselector — A selector string.\nsearcher optional — A keyof FormKitNode or FormKitSearchFunction.\nReturns\n\nThe found FormKitNode or undefined.\n\nhook\n\nSet of hooks.\n\nSignature\nhook: FormKitHooks\nReturns\n\nThe FormKitHooks.\n\nindex\n\nThe index of a node compared to its siblings. This is only applicable in cases where a node is a child of a list.\n\nSignature\nindex: number\nReturns\n\nA number.\n\ninput()\n\nThe function used to set the value of a node. All changes to a node's value should use this function as it ensures the tree's state is always fully tracked.\n\nSignature\ninput: (value: unknown, async?: boolean) => Promise<unknown>\nParameters\nvalue — Any value to used for the node.\nasync optional — If the input should happen asynchronously.\nReturns\n\nA Promise<unknown>.\n\nisCreated\n\nBegins as false, set to true when the node is finished being created.\n\nSignature\nisCreated: boolean\nReturns\n\nA boolean.\n\nisSettled\n\nBoolean reflecting the settlement state of the node and its subtree.\n\nSignature\nisSettled: boolean\nReturns\n\nA boolean.\n\nledger\n\nA counting ledger for arbitrary message counters.\n\nSignature\nledger: FormKitLedger\nReturns\n\nA FormKitLedger.\n\nname\n\nThe name of the input in the node tree. When a node is a child of a list, this automatically becomes its index.\n\nSignature\nname: string\nReturns\n\nA string.\n\noff()\n\nRemoves an event listener by its token. Receipts can be shared among many event listeners by explicitly declaring the \"receipt\" property of the listener function.\n\nSignature\noff: (receipt: string) => FormKitNode\nParameters\nreceipt — A receipt generated by the on function.\nReturns\n\nA receipt string.\n\non()\n\nAdds an event listener for a given event, and returns a \"receipt\" which is a random string token. This token should be used to remove the listener in the future. Alternatively you can assign a \"receipt\" property to the listener function and that receipt will be used instead. This allows multiple listeners to all be de-registered with a single off() call if they share the same receipt.\n\nSignature\non: (eventName: string, listener: FormKitEventListener) => string\nParameters\neventName — The event name to listen to.\nlistener — A FormKitEventListener to run when the event happens.\nReturns\n\nA receipt string.\n\nparent\n\nThe parent of a node.\n\nSignature\nparent: FormKitNode | null\nReturns\n\nIf found a FormKitNode or null.\n\nprops\n\nAn proxied object of props. These are typically provided by the adapter of choice.\n\nSignature\nprops: Partial<FormKitProps>\nReturns\n\nAn optional list of FormKitProps.\n\nremove()\n\nRemoves a child from the node.\n\nSignature\nremove: (node: FormKitNode) => FormKitNode\nParameters\nnode — A FormKitNode to be removed.\nReturns\n\nThe FormKitNode.\n\nreset()\n\nResets the node’s value back to its original value.\n\nSignature\nreset: () => FormKitNode\nReturns\n\nThe FormKitNode.\n\nroot\n\nRetrieves the root node of a tree. This is accomplished via tree-traversal on-request, and as such should not be used in frequently called functions.\n\nSignature\nroot: FormKitNode\nReturns\n\nThe FormKitNode.\n\nsetErrors()\n\nSets errors on the input, and optionally to child inputs.\n\nSignature\nsetErrors: (localErrors: ErrorMessages, childErrors?: ErrorMessages) => void\nParameters\nlocalErrors — A ErrorMessages to be used.\nchildErrors optional — A ErrorMessages to be used for children.\nsettled\n\nA promise that resolves when a node and its entire subtree is settled. In other words — all the inputs are done committing their values.\n\nSignature\nsettled: Promise<unknown>\nReturns\n\nA Promise<unknown>.\n\nstore\n\nThe internal node store.\n\nSignature\nstore: FormKitStore\nReturns\n\nA FormKitStore.\n\nsubmit()\n\nTriggers a submit event on the nearest form.\n\nSignature\nsubmit: () => void\nt()\n\nA text or translation function that exposes a given string to the \"text\" hook. All text shown to users should be passed through this function before being displayed — especially for core and plugin authors.\n\nSignature\nt: (key: string | FormKitTextFragment) => string\nParameters\nkey — A key or a FormKitTextFragment to find the translation for.\nReturns\n\nThe translated string.\n\ntype\n\nThe type of node, should only be 'input', 'list', or 'group'.\n\nSignature\ntype: FormKitNodeType\nReturns\n\nA FormKitNodeType.\n\nuse()\n\nRegisters a new plugin on the node and its subtree.\n\nSignature\nuse: (\n\n plugin: FormKitPlugin | FormKitPlugin[] | Set<FormKitPlugin>,\n\n run?: boolean,\n\n library?: boolean\n\n) => FormKitNode\nParameters\nplugin — A FormKitPlugin or an Array or Set of FormKitPlugin.\nrun optional — Should the plugin be executed on creation.\nlibrary optional — Should the plugin's library function be executed on creation.\nReturns\n\nThe FormKitNode.\n\nvalue\n\nThe value of the input. This should never be directly modified. Any desired mutations should be made through input.\n\nSignature\nreadonly value: unknown\nwalk()\n\nPerforms a function on every node in its subtree (but not the node itself). This is an expensive operation so it should be done very rarely and only lifecycle events that are relatively rare like boot up and shut down.\n\nSignature\nwalk: (callback: FormKitChildCallback, stopOnFalse?: boolean, recurseOnFalse?: boolean) => void\nParameters\ncallback — A FormKitChildCallback to be executed for each child.\nstopOnFalse optional — If it should stop when the return is false.\nFunctions\nbfs()\n\nPerform a breadth-first search on a node subtree and locate the first instance of a match.\n\nSignature\nbfs(tree: FormKitNode, searchValue: string | number, searchGoal?: keyof FormKitNode | FormKitSearchFunction): FormKitNode | undefined;\nParameters\ntree — A FormKitNode to start from.\nsearchValue — A value to be searched.\nsearchGoal optional — A goal value.\nReturns\n\nA FormKitNode or undefined.\n\nclearErrors()\n\nClears errors on the node and optionally its children.\n\nSignature\nclearErrors(id: string, clearChildren?: boolean): void;\nParameters\nid — The id of the node you want to clear errors for.\nclearChildren optional — Determines if the children of this node should have their errors cleared.\ncompile()\n\nCompiles a logical string like \"a != z || b == c\" into a single function. The return value is an object with a \"provide\" method that iterates over all requirement tokens to use as replacements.\n\nSignature\ncompile(expr: string): FormKitCompilerOutput;\nParameters\nexpr — A string to compile.\nReturns\n\nA FormKitCompilerOutput.\n\nExamples\nlet name = {\n\n  value: 'jon'\n\n}\n\nconst condition = compile(\"$name == 'bob'\").provide((token) => {\n\n return () => name.value // must return a function!\n\n})\n\n\n\ncondition() // false\ncreateClasses()\n\nFunction that produces a standardized object representation of CSS classes.\n\nSignature\ncreateClasses(propertyKey: string, node: FormKitNode, sectionClassList?: FormKitClasses | string | Record<string, boolean>): Record<string, boolean>;\nParameters\npropertyKey — the section key.\nnode — A FormKitNode.\nsectionClassList optional — A string | Record<string, boolean> or a FormKitClasses.\nReturns\n\nRecord<string, boolean>\n\ncreateConfig()\n\nCreates a new instance of a global configuration option. This object is essentially just a FormKitOption object, but it can be used as the root for FormKitConfig's proxy and retain event \"emitting\".\n\nSignature\ncreateConfig(options?: Partial<FormKitConfig>): FormKitRootConfig;\nParameters\noptions optional — An object of optional properties of FormKitConfig.\nReturns\n\nA FormKitRootConfig.\n\ncreateMessage()\n\nCreates a new FormKitMessage object.\n\nSignature\ncreateMessage(conf: Partial<FormKitMessage>, node?: FormKitNode): FormKitMessageProps;\nParameters\nconf — An object of optional properties of FormKitMessage.\nnode optional — A FormKitNode.\nReturns\n\nA FormKitMessageProps.\n\ncreateNode()\n\nCreates a new instance of a FormKit Node. Nodes are the atomic unit of a FormKit graph.\n\nSignature\ncreateNode<V = unknown>(options?: FormKitOptions): FormKitNode<V>;\nParameters\noptions optional — An options object of FormKitOptions to override the defaults.\nReturns\n\nA FormKitNode.\n\nExamples\nimport { createNode } from '@formkit/core'\n\n\n\nconst input = createNode({\n\n  type: 'input', // defaults to 'input' if not specified\n\n  value: 'hello node world',\n\n})\n\n\n\nconsole.log(input.value)\n\n// 'hello node world'\ncreateValue()\n\nCreates the initial value for a node based on the options passed in and the type of the input.\n\nSignature\ncreateValue(options: FormKitOptions): unknown;\nParameters\noptions — A FormKitOptions.\nReturns\n\nunknown\n\nderegister()\n\nDeregister a node from the registry.\n\nSignature\nderegister(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\nerror()\n\nEmits an error. Generally should result in an exception.\n\nSignature\nerror(code: number, data?: any): never;\nParameters\ncode — The integer error code.\ndata optional — Usually an object of information to include.\ngenerateClassList()\n\nCombines multiple class lists into a single list.\n\nSignature\ngenerateClassList(node: FormKitNode, property: string, ...args: Record<string, boolean>[]): string | null;\nParameters\nnode — A FormKitNode.\nproperty — The property key to which the class list will be applied.\nargs — And array of Record<string, boolean> of CSS class list(s).\nReturns\n\nstring | null\n\ngetNode()\n\nGet a node by a particular id.\n\nSignature\ngetNode(id: string): FormKitNode | undefined;\nParameters\nid — Get a node by a given id.\nReturns\n\nA FormKitNode or undefined.\n\nisComponent()\n\nType narrow that a node is a DOM node.\n\nSignature\nisComponent(node: string | Record<PropertyKey, any>): node is FormKitSchemaComponent;\nParameters\nnode — A schema node to check.\nReturns\n\nboolean\n\nisConditional()\n\nDetermines if a node is conditionally rendered or not.\n\nSignature\nisConditional(node: FormKitSchemaNode): node is FormKitSchemaCondition;\n\nisConditional(node: FormKitSchemaAttributesCondition | FormKitSchemaAttributes): node is FormKitSchemaAttributesCondition;\nParameters\nnode — A schema node to check.\nReturns\n\nboolean\n\nisDOM()\n\nType narrow that a node is a DOM node.\n\nSignature\nisDOM(node: string | Record<PropertyKey, any>): node is FormKitSchemaDOMNode;\nParameters\nnode — A schema node to check\nReturns\n\nboolean\n\nisList()\n\nA simple type guard to determine if the context being evaluated is a list type.\n\nSignature\nisList(arg: FormKitContextShape): arg is FormKitListContext;\nParameters\narg — A FormKitContextShape.\nReturns\n\nReturns a boolean.\n\nisNode()\n\nDetermine if a given object is a node.\n\nSignature\nisNode(node: any): node is FormKitNode;\nParameters\nnode — Any value.\nReturns\n\nReturns a boolean.\n\nExamples\nimport { isNode, createNode } from '@formkit/core'\n\n\n\nconst input = createNode({\n\n  type: 'input', // defaults to 'input' if not specified\n\n  value: 'hello node world',\n\n})\n\n\n\nconst obj = {};\n\n\n\nisNode(obj)\n\n// false\n\n\n\nisNode(input)\n\n// true\nisPlaceholder()\n\nDetermines if a node is a placeholder node.\n\nSignature\nisPlaceholder(node: FormKitNode | FormKitPlaceholderNode): node is FormKitPlaceholderNode;\nParameters\nnode — A FormKitNode\nReturns\nisSugar()\n\nDetermines if the node is syntactic sugar or not.\n\nSignature\nisSugar(node: FormKitSchemaNode): node is FormKitSchemaFormKit;\nParameters\nnode — A schema node to check.\nReturns\n\nboolean\n\nnames()\n\nCreate a name-based dictionary of all children in an array.\n\nSignature\nnames(children: FormKitNode[]): {\n\n    [index: string]: FormKitNode;\n\n};\nParameters\nchildren — An array of FormKitNode.\nReturns\n\nA dictionary of named FormKitNode.\n\nregister()\n\nRegisters a node to the registry if the node is a root node, or if the node has an explicit node.props.alias. If these two things are not true, then no node is registered (idempotent).\n\nSignature\nregister(node: FormKitNode): void;\nParameters\nnode — A FormKitNode.\nreset()\n\nResets an input to its \"initial\" value. If the input is a group or list it resets all the children as well.\n\nSignature\nreset(id: string | FormKitNode, resetTo?: unknown): FormKitNode | undefined;\nParameters\nid — The id of an input to reset.\nresetTo optional — A value to reset the node to.\nReturns\n\nA FormKitNode or undefined.\n\nresetCount()\n\nResets the global number of node registrations, useful for deterministic node naming.\n\nSignature\nresetCount(): void;\nresetRegistry()\n\nResets the entire registry. Deregisters all nodes and removes all listeners.\n\nSignature\nresetRegistry(): void;\nsetErrors()\n\nSets errors on a form, group, or input.\n\nSignature\nsetErrors(id: string, localErrors: ErrorMessages, childErrors?: ErrorMessages): void;\nParameters\nid — The id of a form.\nlocalErrors — The errors to set on the form or the form’s inputs in the format of ErrorMessages.\nchildErrors optional — (optional) The errors to set on the form or the form’s inputs in the format of ErrorMessages.\nsubmitForm()\n\nSubmits a FormKit form programmatically.\n\nSignature\nsubmitForm(id: string): void;\nParameters\nid — The id of the form.\nsugar()\n\nConverts syntactic sugar nodes to standard nodes.\n\nSignature\nsugar<T extends FormKitSchemaNode>(node: T): Exclude<FormKitSchemaNode, string | FormKitSchemaFormKit>;\nParameters\nnode — A node to covert.\nReturns\n\nA FormKitSchemaNode without the properties of FormKitSchemaFormKit.\n\nwarn()\n\nGlobally emits a warning.\n\nSignature\nwarn(code: number, data?: any): void;\nParameters\ncode — The integer warning code.\ndata optional — Usually an object of information to include.\nwatchRegistry()\n\nA way of watching changes in the global registry.\n\nSignature\nwatchRegistry(id: string, callback: FormKitEventListener): void;\nParameters\nid — A dot -syntax id where the node is located.\ncallback — A callback in the format of FormKitEventListener to notify when the node is set or removed.\nTypeScript\nFormKitChildCallback\n\nThe callback type for node.each().\n\ninterface FormKitChildCallback {\n\n    (child: FormKitNode): any;\n\n}\nFormKitChildValue\n\nA descriptor of a child value, generally passed up a node tree.\n\ninterface FormKitChildValue {\n\n    from?: number | symbol;\n\n    name: string | number | symbol;\n\n    value: any;\n\n}\nFormKitClasses\n\nDefinition for a function that produces CSS classes.\n\ninterface FormKitClasses {\n\n    (node: FormKitNode, sectionKey: string): string | Record<string, boolean>;\n\n}\nFormKitCompilerOutput\n\nThe compiler output, a function that adds the required tokens.\n\ninterface FormKitCompilerOutput {\n\n    (tokens?: Record<string, any>): boolean | number | string;\n\n    provide: FormKitCompilerProvider;\n\n}\nFormKitConfig\n\nGeneral \"app\" like configuration options, these are automatically inherited by all children — they are not reactive.\n\ninterface FormKitConfig {\n\n    [index: string]: any;\n\n    classes?: Record<string, FormKitClasses | string | Record<string, boolean>>;\n\n    delimiter: string;\n\n    rootClasses: ((sectionKey: string, node: FormKitNode) => Record<string, boolean>) | false;\n\n    rootConfig?: FormKitRootConfig;\n\n}\nFormKitContext\n\nThe interface of a FormKit node's context object. A FormKit node is a proxy of this object.\n\ninterface FormKitContext {\n\n    _d: number;\n\n    _e: FormKitEventEmitter;\n\n    _resolve: ((value: unknown) => void) | false;\n\n    _tmo: number | false;\n\n    _value: unknown;\n\n    children: Array<FormKitNode | FormKitPlaceholderNode>;\n\n    config: FormKitConfig;\n\n    context?: FormKitFrameworkContext;\n\n    hook: FormKitHooks;\n\n    isCreated: boolean;\n\n    isSettled: boolean;\n\n    ledger: FormKitLedger;\n\n    name: string | symbol;\n\n    parent: FormKitNode | null;\n\n    plugins: Set<FormKitPlugin>;\n\n    props: Partial<FormKitProps>;\n\n    settled: Promise<unknown>;\n\n    store: FormKitStore;\n\n    sync: boolean;\n\n    traps: FormKitTraps;\n\n    type: FormKitNodeType;\n\n    uid: symbol;\n\n    value: unknown;\n\n}\nFormKitContextShape\n\nDefine the most basic shape of a context object for type guards trying to reason about a context's value.\n\ninterface FormKitContextShape {\n\n    _value: unknown;\n\n    type: FormKitNodeType;\n\n    value: unknown;\n\n}\nFormKitCounter\n\nThe counter object used to perform instance counting within a tree.\n\ninterface FormKitCounter {\n\n    condition: FormKitCounterCondition;\n\n    count: number;\n\n    name: string;\n\n    node: FormKitNode;\n\n    promise: Promise<void>;\n\n    resolve: () => void;\n\n}\nFormKitCounterCondition\n\nLedger counters require a condition function that determines if a given message applies to it or not.\n\ninterface FormKitCounterCondition {\n\n    (message: FormKitMessage): boolean;\n\n}\nFormKitDispatcher\n\nThe FormKitDispatcher interface is responsible creating/running \"hooks\".\n\ninterface FormKitDispatcher<T> {\n\n    (dispatchable: FormKitMiddleware<T>): number;\n\n    dispatch: (payload: T) => T;\n\n    remove: (dispatchable: FormKitMiddleware<T>) => void;\n\n    unshift: (dispatchable: FormKitMiddleware<T>) => number;\n\n}\nFormKitEvent\n\nThe internal structure of a FormKitEvent.\n\ninterface FormKitEvent {\n\n    bubble: boolean;\n\n    meta?: Record<string, unknown>;\n\n    name: string;\n\n    origin: FormKitNode;\n\n    payload: any;\n\n}\nFormKitEventEmitter\n\nThe FormKitEventEmitter definition.\n\ninterface FormKitEventEmitter {\n\n    (node: FormKitNode, event: FormKitEvent): void;\n\n    flush: () => void;\n\n    off: (receipt: string) => void;\n\n    on: (eventName: string, listener: FormKitEventListener) => string;\n\n    pause: (node?: FormKitNode) => void;\n\n    play: (node?: FormKitNode) => void;\n\n}\nFormKitEventListener\n\nEvent listener functions definition.\n\ninterface FormKitEventListener {\n\n    (event: FormKitEvent): void;\n\n    receipt?: string;\n\n}\nFormKitExtendableSchemaRoot\n\nDefines a function that allows selectively overriding a given schema.\n\ninterface FormKitExtendableSchemaRoot {\n\n    (extensions: Record<string, Partial<FormKitSchemaNode> | FormKitSchemaCondition>): FormKitSchemaDefinition;\n\n    memoKey?: string;\n\n}\nFormKitFrameworkContext\n\nContext object to be created by and used by each respective UI framework. No values are created or output by FormKitCore, but this interface should be followed by each respective plugin.\n\ninterface FormKitFrameworkContext<T = any> {\n\n    __root?: Document | ShadowRoot;\n\n    _value: T;\n\n    [index: string]: unknown;\n\n    attrs: Record<string, any>;\n\n    classes: Record<string, string>;\n\n    defaultMessagePlacement: boolean;\n\n    fns: Record<string, (...args: any[]) => any>;\n\n    handlers:{\n\n        blur: (e?: FocusEvent) => void;\n\n        touch: () => void;\n\n        DOMInput: (e: Event) => void;\n\n    }&Record<string, (...args: any[]) => void>;\n\n    help?: string;\n\n    id: string;\n\n    items: symbol[];\n\n    label?: string;\n\n    messages: Record<string, FormKitMessage>;\n\n    node: FormKitNode;\n\n    options?: Array<Record<string, any>&{\n\n        label: string;\n\n        value: any;\n\n    }>;\n\n    slots: Record<string, CallableFunction>;\n\n    state: FormKitFrameworkContextState;\n\n    type: string;\n\n    ui: Record<string, FormKitMessage>;\n\n    value: T;\n\n}\nFormKitFrameworkContextState\n\nThe state inside a node’s framework context. Usually used to track things like blurred and validity states.\n\ninterface FormKitFrameworkContextState {\n\n    [index: string]: boolean;\n\n    blurred: boolean;\n\n    complete: boolean;\n\n    dirty: boolean;\n\n    errors: boolean;\n\n    rules: boolean;\n\n    settled: boolean;\n\n    submitted: boolean;\n\n    valid: boolean;\n\n    validationVisible: boolean;\n\n}\nFormKitGroupValue\n\nFormKit inputs of type 'group' must have keyed values by default.\n\ninterface FormKitGroupValue {\n\n    __init?: boolean;\n\n    [index: string]: unknown;\n\n}\nFormKitHandlerPayload\n\nDescribes the data passing through the error and warning handlers.\n\ninterface FormKitHandlerPayload {\n\n    code: number;\n\n    data: any;\n\n    message?: string;\n\n}\nFormKitHooks\n\nThe available hooks for middleware.\n\ninterface FormKitHooks {\n\n    classes: FormKitDispatcher<{\n\n        property: string;\n\n        classes: Record<string, boolean>;\n\n    }>;\n\n    commit: FormKitDispatcher<any>;\n\n    error: FormKitDispatcher<string>;\n\n    init: FormKitDispatcher<FormKitNode>;\n\n    input: FormKitDispatcher<any>;\n\n    message: FormKitDispatcher<FormKitMessage>;\n\n    prop: FormKitDispatcher<{\n\n        prop: string | symbol;\n\n        value: any;\n\n    }>;\n\n    schema: FormKitDispatcher<FormKitSchemaNode[] | FormKitSchemaCondition>;\n\n    setErrors: FormKitDispatcher<{\n\n        localErrors: ErrorMessages;\n\n        childErrors?: ErrorMessages;\n\n    }>;\n\n    submit: FormKitDispatcher<Record<string, any>>;\n\n    text: FormKitDispatcher<FormKitTextFragment>;\n\n}\nFormKitInputMessages\n\nA registry of input messages that should be applied to children of the node they are passed to — where the string key of the object is the address of the node to apply the messages on and the value is the message itself.\n\ninterface FormKitInputMessages {\n\n    [address: string]: FormKitMessage[];\n\n}\nFormKitLedger\n\nThe FormKit ledger, a general-purpose message counting service provided by FormKit core for counting messages throughout a tree.\n\ninterface FormKitLedger {\n\n    count: (name: string, condition?: FormKitCounterCondition, increment?: number) => Promise<void>;\n\n    init: (node: FormKitNode) => void;\n\n    merge: (child: FormKitNode) => void;\n\n    settled: (name: string) => Promise<void>;\n\n    unmerge: (child: FormKitNode) => void;\n\n    value: (name: string) => number;\n\n}\nFormKitLibrary\n\nA library of inputs, keyed by the name of the type.\n\ninterface FormKitLibrary {\n\n    [index: string]: FormKitTypeDefinition;\n\n}\nFormKitListContext\n\nThe simplest definition for a context of type \"list\".\n\ninterface FormKitListContext {\n\n    _value: FormKitListContextValue;\n\n    type:'list';\n\n    value: FormKitListContextValue;\n\n}\nFormKitMessageMeta\n\nMessages have can have any arbitrary meta data attached to them.\n\ninterface FormKitMessageMeta {\n\n    [index: string]: any;\n\n    i18nArgs?: any[];\n\n    messageKey?: string;\n\n}\nFormKitMessageProps\n\nThe structure of a core FormKitMessage. These messages are used to store information about the state of a node.\n\ninterface FormKitMessageProps {\n\n    blocking: boolean;\n\n    key: string;\n\n    meta: FormKitMessageMeta;\n\n    type: string;\n\n    value?: string | number | boolean;\n\n    visible: boolean;\n\n}\nFormKitMessageStore\n\nDefines the actual store of messages.\n\ninterface FormKitMessageStore {\n\n    [index: string]: FormKitMessage;\n\n}\nFormKitNodeExtensions\n\nAn empty interface for adding FormKit node extensions.\n\ninterface FormKitNodeExtensions {\n\n}\nFormKitPlaceholderNode\n\nA faux node that is used as a placeholder in the children node array during various node manipulations.\n\ninterface FormKitPlaceholderNode<V = unknown> {\n\n    __FKP: true;\n\n    _value: V;\n\n    input: (value: unknown, async?: boolean) => Promise<unknown>;\n\n    isSettled: boolean;\n\n    name: string;\n\n    type: FormKitNodeType;\n\n    uid: symbol;\n\n    use: (...args: any[]) => void;\n\n    value: V;\n\n}\nFormKitPlugin\n\nThe base interface definition for a FormKitPlugin. It's just a function that accepts a node argument.\n\ninterface FormKitPlugin {\n\n    (node: FormKitNode): false | any | void;\n\n    library?: (node: FormKitNode) => void;\n\n}\nFormKitSchemaAttributesCondition\n\nConditions nested inside attribute declarations.\n\ninterface FormKitSchemaAttributesCondition {\n\n    else?: FormKitAttributeValue;\n\n    if: string;\n\n    then: FormKitAttributeValue;\n\n}\nFormKitSchemaComposable\n\nDefinition for a function that can extend a given schema node.\n\ninterface FormKitSchemaComposable {\n\n    (extendWith?: Partial<FormKitSchemaNode>, children?: string | FormKitSchemaNode[] | FormKitSchemaCondition, ...args: any[]): FormKitSchemaNode;\n\n}\nFormKitSchemaContext\n\nThe context that is passed from one schema render to the next.\n\ninterface FormKitSchemaContext {\n\n    __FK_SCP: Map<symbol, Record<string, any>>;\n\n    [index: string]: any;\n\n}\nFormKitSchemaProps\n\nProperties available in all schema nodes.\n\ninterface FormKitSchemaProps {\n\n    bind?: string;\n\n    children?: string | FormKitSchemaNode[] | FormKitSchemaCondition;\n\n    for?: FormKitListStatement;\n\n    if?: string;\n\n    key?: string;\n\n    meta?: FormKitSchemaMeta;\n\n}\nFormKitStoreTraps\n\nThe available traps on the FormKit store.\n\ninterface FormKitStoreTraps {\n\n    apply: (messages: Array<FormKitMessage> | FormKitInputMessages, clear?: MessageClearer) => void;\n\n    filter: (callback: (message: FormKitMessage) => boolean, type?: string) => FormKitStore;\n\n    reduce:<T>(reducer: (accumulator: T, message: FormKitMessage) => T, accumulator: T) => T;\n\n    release: () => void;\n\n    remove: (key: string) => FormKitStore;\n\n    set: (message: FormKitMessageProps) => FormKitStore;\n\n    touch: () => void;\n\n}\nFormKitTrap\n\nThe definition of a FormKitTrap. These are somewhat like methods on each FormKitNode. They are always symmetrical (get/set) — although it's acceptable for either to throw an Exception.\n\ninterface FormKitTrap {\n\n    get: TrapGetter;\n\n    set: TrapSetter;\n\n}\nKeyedValue\n\nArbitrary data that has properties. Could be a POJO, could be an array.\n\ninterface KeyedValue {\n\n    [index: number]: any;\n\n    [index: string]: any;\n\n}\nChildMessageBuffer\n\nChild messages that were not immediately applied due to the child not existing.\n\nexport type ChildMessageBuffer = Map<string, Array<[FormKitMessage[], MessageClearer | undefined]>>;\nErrorMessages\n\nError messages.\n\nexport type ErrorMessages = string | string[] | Record<string, string | string[]>;\nFormKitAddress\n\nDescribes the path to a particular node from the top of the tree.\n\nexport type FormKitAddress = Array<string | number>;\nFormKitAttributeValue\n\nThe possible value types of attributes (in the schema).\n\nexport type FormKitAttributeValue = string | number | boolean | undefined | FormKitSchemaAttributes | FormKitSchemaAttributesCondition;\nFormKitCompilerProvider\n\nA function that accepts a callback with a token as the only argument, and must return a function that provides the true value of the token.\n\nexport type FormKitCompilerProvider = (callback: (requirements: string[]) => Record<string, () => any>) => FormKitCompilerOutput;\nFormKitListContextValue\n\nFormKit inputs of type 'list' must have array values by default.\n\nexport type FormKitListContextValue<T = any> = Array<T>;\nFormKitListStatement\n\nA full loop statement in tuple syntax. Can be read like \"foreach value, key? in list\".\n\nexport type FormKitListStatement = [value: any, key: number | string, list: FormKitListValue] | [value: any, list: FormKitListValue];\nFormKitListValue\n\nThe value being listed out. Can be an array, an object, or a number.\n\nexport type FormKitListValue = string | Record<string, any> | Array<string | number | Record<string, any>> | number;\nFormKitMessage\n\nA FormKit message is immutable, so all properties should be readonly.\n\nexport type FormKitMessage = Readonly<FormKitMessageProps>;\nFormKitMiddleware\n\nAll FormKitMiddleware conform to the pattern of accepting a payload and a next() function. They can either pass the payload to the next middleware explicitly (as an argument of next), or implicitly (no argument for next).\n\nexport type FormKitMiddleware<T = unknown> = (payload: T, next: (payload: T) => T) => T;\nFormKitNodeType\n\nThese are the types of nodes that can be created. These are different from the type of inputs available and rather describe their purpose in the tree.\n\nexport type FormKitNodeType = 'input' | 'list' | 'group';\nFormKitOptions\n\nOptions that can be used to instantiate a new node via createNode().\n\nexport type FormKitOptions = Partial<Omit<FormKitContext, 'children' | 'plugins' | 'config' | 'hook'> & {\n\n    config: Partial<FormKitConfig>;\n\n    props: Partial<FormKitProps>;\n\n    children: FormKitNode[] | Set<FormKitNode>;\n\n    index?: number;\n\n    sync: boolean;\n\n    plugins: FormKitPlugin[];\n\n    alias: string;\n\n    schemaAlias: string;\n\n}>;\nFormKitProps\n\nThe user-land per-instance \"props\", which are generally akin to the props passed into components on the front end.\n\nexport type FormKitProps = {\n\n    __root?: Document | ShadowRoot;\n\n    delay: number;\n\n    id: string;\n\n    validationLabelStrategy?: (node?: FormKitNode) => string;\n\n    validationRules?: Record<string, (node: FormKitNode) => boolean | Promise<boolean>>;\n\n    validationMessages?: Record<string, ((ctx: {\n\n        name: string;\n\n        args: any[];\n\n        node: FormKitNode;\n\n    }) => string) | string>;\n\n    definition?: FormKitTypeDefinition;\n\n    context?: FormKitFrameworkContext;\n\n    [index: string]: any;\n\n} & FormKitConfig;\nFormKitRootConfig\n\nGlobal configuration options.\n\nexport type FormKitRootConfig = Partial<FormKitConfig> & {\n\n    _add: (node: FormKitNode) => void;\n\n    _rm: (node: FormKitNode) => void;\n\n};\nFormKitSchemaAttributes\n\nDOM attributes are simple string dictionaries.\n\nexport type FormKitSchemaAttributes = {\n\n    [index: string]: FormKitAttributeValue;\n\n} | null | FormKitSchemaAttributesCondition;\nFormKitSchemaComponent\n\nProperties available when defining a generic non-FormKit component.\n\nexport type FormKitSchemaComponent = {\n\n    $cmp: string;\n\n    props?: Record<string, any>;\n\n} & FormKitSchemaProps;\nFormKitSchemaCondition\n\nA schema node that determines which content to render.\n\nexport type FormKitSchemaCondition = {\n\n    if: string;\n\n    then: FormKitSchemaNode | FormKitSchemaNode[];\n\n    else?: FormKitSchemaNode | FormKitSchemaNode[];\n\n};\nFormKitSchemaDefinition\n\nAn entire schema object or subtree from any entry point. Can be a single node, an array of nodes, or a conditional. This is the type that is passed to the FormKitSchema constructor.\n\nexport type FormKitSchemaDefinition = FormKitSchemaNode | FormKitSchemaNode[] | FormKitSchemaCondition;\nFormKitSchemaDOMNode\n\nProperties available when using a DOM node.\n\nexport type FormKitSchemaDOMNode = {\n\n    $el: string | null;\n\n    attrs?: FormKitSchemaAttributes;\n\n} & FormKitSchemaProps;\nFormKitSchemaFormKit\n\nSyntactic sugar for a FormKitSchemaComponent node that uses FormKit.\n\nexport type FormKitSchemaFormKit = {\n\n    $formkit: string;\n\n} & Record<string, any> & FormKitSchemaProps;\nFormKitSchemaMeta\n\nMeta attributes are not used when parsing the schema, but can be used to create tooling.\n\nexport type FormKitSchemaMeta = {\n\n    [key: string]: string | number | boolean | undefined | null | CallableFunction | FormKitSchemaMeta;\n\n};\nFormKitSchemaNode\n\nProperties available then defining a schema node.\n\nexport type FormKitSchemaNode = FormKitSchemaDOMNode | FormKitSchemaComponent | FormKitSchemaTextNode | FormKitSchemaCondition | FormKitSchemaFormKit;\nFormKitSchemaTextNode\n\nA simple text node.\n\nexport type FormKitSchemaTextNode = string;\nFormKitSearchFunction\n\nBreadth and depth-first searches can use a callback of this notation.\n\nexport type FormKitSearchFunction = (node: FormKitNode, searchTerm?: string | number) => boolean;\nFormKitStore\n\nThe message store contains all of the messages that pertain to a given node.\n\nexport type FormKitStore = FormKitMessageStore & {\n\n    _n: FormKitNode;\n\n    _b: Array<[messages: FormKitMessage[], clear?: MessageClearer]>;\n\n    _m: ChildMessageBuffer;\n\n    _r?: string;\n\n    buffer: boolean;\n\n} & FormKitStoreTraps;\nFormKitTextFragment\n\nText fragments are small pieces of text used for things like interface validation messages, or errors that may be exposed for modification or even translation.\n\nexport type FormKitTextFragment = Partial<FormKitMessageProps> & {\n\n    key: string;\n\n    value: string;\n\n    type: string;\n\n};\nFormKitTraps\n\nThe map signature for a node's traps Map.\n\nexport type FormKitTraps = Map<string | symbol, FormKitTrap>;\nFormKitTypeDefinition\n\nDefinition of a library item — when registering a new library item, these are the required and available properties.\n\nexport type FormKitTypeDefinition = {\n\n    type: FormKitNodeType;\n\n    family?: string;\n\n    forceTypeProp?: string;\n\n    props?: string[];\n\n    schema?: FormKitExtendableSchemaRoot | FormKitSchemaNode[] | FormKitSchemaCondition;\n\n    component?: unknown;\n\n    library?: Record<string, unknown>;\n\n    features?: Array<(node: FormKitNode) => void>;\n\n    schemaMemoKey?: string;\n\n};\nMessageClearer\n\nA string or function that allows clearing messages.\n\nexport type MessageClearer = string | ((message: FormKitMessage) => boolean);\nTrapGetter\n\nSignature for any of the node's getter traps. Keep in mind that because these are traps and not class methods, their response types are declared explicitly in the FormKitNode interface.\n\nexport type TrapGetter = ((node: FormKitNode, context: FormKitContext, ...args: any[]) => unknown) | false;\nTrapSetter\n\nThe signature for a node's trap setter — these are more rare than getter traps, but can be useful for blocking access to certain context properties or modifying the behavior of an assignment (ex. see setParent).\n\nexport type TrapSetter = ((node: FormKitNode, context: FormKitContext, property: string | number | symbol, value: any) => boolean | never) | false;"
  },
  {
    "title": "formkit/addons ⚡️ FormKit",
    "url": "https://formkit.com/api-reference/formkit-addons",
    "html": "@formkit/addons\nIntroduction\nFunctions\ncreateAutoAnimatePlugin()\ncreateAutoHeightTextareaPlugin()\ncreateFloatingLabelsPlugin()\ncreateLocalStoragePlugin()\ncreateMultiStepPlugin()\nTypeScript\nBeforeStepChange\nBeforeStepChangeData\nFloatingLabelsOptions\nFormKitMultiStepSlots\nFormKitStepSlots\nLocalStorageOptions\nMultiStepHandlers\nMultiStepNodeAdditions\nMultiStepOptions\nMultiStepSlotData\nStepHandlers\nStepSlotData\nFormKitMultiStepNode\nFormKitMultiStepSlotData\nIntroduction\n\nCommon, optional, first-party add on features for FormKit.\n\nYou can add this package by using npm install @formkit/addons or yarn add @formkit/addons.\n\nFunctions\ncreateAutoAnimatePlugin()\n\nAdds auto-animate to each input automatically:\n\nSignature\ncreateAutoAnimatePlugin(options?: AutoAnimateOptions, animationTargets?: Record<string, string[]>): FormKitPlugin;\nParameters\noptions optional — AutoAnimateOptions\nanimationTargets optional — A map of input types and an array of their sections that should be animated.\nReturns\n\nFormKitPlugin\n\nExamples\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { createAutoAnimatePlugin } from '@formkit/addons'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\n\n\ncreateApp(app).use(plugin, defaultPlugin({\n\n  plugins: [\n\n    createAutoAnimatePlugin({\n\n      // optional config\n\n      duration: 250,\n\n      easing: 'ease-in-out',\n\n      delay: 0,\n\n    },\n\n    {\n\n      // optional animation targets object\n\n      global: ['outer', 'inner'],\n\n      form: ['form'],\n\n      repeater: ['items'],\n\n    })\n\n  ]\n\n}))\ncreateAutoHeightTextareaPlugin()\n\nCreates a new auto-height textarea plugin.\n\nSignature\ncreateAutoHeightTextareaPlugin(): FormKitPlugin;\nReturns\n\nA FormKitPlugin\n\ncreateFloatingLabelsPlugin()\n\nCreates a new floating label plugin.\n\nSignature\ncreateFloatingLabelsPlugin(FloatingLabelsOptions?: FloatingLabelsOptions): FormKitPlugin;\nParameters\nFloatingLabelsOptions optional — The options of FloatingLabelsOptions to pass to the plugin\nReturns\n\nA FormKitPlugin\n\ncreateLocalStoragePlugin()\n\nCreates a new save-to-local-storage plugin.\n\nSignature\ncreateLocalStoragePlugin(localStorageOptions?: LocalStorageOptions): FormKitPlugin;\nParameters\nlocalStorageOptions optional\nReturns\n\nA FormKitPlugin\n\ncreateMultiStepPlugin()\n\nCreates a new multi-step plugin.\n\nSignature\ncreateMultiStepPlugin(options?: MultiStepOptions): FormKitPlugin;\nParameters\noptions optional — The options of MultiStepOptions to pass to the plugin\nReturns\n\nA FormKitPlugin\n\nTypeScript\nBeforeStepChange\n\nThe typing for the beforeStepChange function.\n\ninterface BeforeStepChange {\n\n    (data: BeforeStepChangeData): any;\n\n}\nBeforeStepChangeData\ninterface BeforeStepChangeData<T = unknown> {\n\n    currentStep: FormKitFrameworkContext<T>;\n\n    delta: number;\n\n    nextStep: FormKitFrameworkContext<T>;\n\n}\nFloatingLabelsOptions\n\nThe options to be passed to createFloatingLabelsPlugin\n\ninterface FloatingLabelsOptions {\n\n    useAsDefault?: boolean;\n\n}\nFormKitMultiStepSlots\ninterface FormKitMultiStepSlots<Props extends FormKitInputs<Props>> {\n\n    badge: FormKitSlotData<Props, MultiStepSlotData&{\n\n        step: FormKitFrameworkContext;\n\n        index: number;\n\n    }>;\n\n    default: FormKitSlotData<Props, MultiStepSlotData>;\n\n    multiStepOuter: FormKitSlotData<Props, MultiStepSlotData>;\n\n    steps: FormKitSlotData<Props, MultiStepSlotData>;\n\n    tab: FormKitSlotData<Props, MultiStepSlotData>;\n\n    tabLabel: FormKitSlotData<Props, MultiStepSlotData&{\n\n        step: FormKitFrameworkContext;\n\n        index: number;\n\n    }>;\n\n    tabs: FormKitSlotData<Props, MultiStepSlotData>;\n\n    validStepIcon: FormKitSlotData<Props, MultiStepSlotData&{\n\n        step: FormKitFrameworkContext;\n\n        index: number;\n\n    }>;\n\n    wrapper: FormKitSlotData<Props, MultiStepSlotData>;\n\n}\nFormKitStepSlots\ninterface FormKitStepSlots<Props extends FormKitInputs<Props>> {\n\n    default: FormKitSlotData<Props, StepSlotData>;\n\n    stepActions: FormKitSlotData<Props, StepSlotData>;\n\n    stepInner: FormKitSlotData<Props, StepSlotData>;\n\n    stepNext: FormKitSlotData<Props, StepSlotData>;\n\n    stepPrevious: FormKitSlotData<Props, StepSlotData>;\n\n}\nLocalStorageOptions\n\nThe options to be passed to createLocalStoragePlugin\n\ninterface LocalStorageOptions {\n\n    beforeLoad?: (payload: any) => any;\n\n    beforeSave?: (payload: any) => any;\n\n    control?: string;\n\n    debounce?: number;\n\n    key?: string | number;\n\n    maxAge?: number;\n\n    prefix?: string;\n\n}\nMultiStepHandlers\ninterface MultiStepHandlers {\n\n    incrementStep: (delta: number, currentStep: FormKitFrameworkContext | undefined) => () => void;\n\n    setActiveStep: (step: FormKitFrameworkContext) => (e?: Event) => void;\n\n    showStepErrors: (step: FormKitFrameworkContext) => boolean | undefined;\n\n    triggerStepValidations: (step: FormKitFrameworkContext) => void;\n\n}\nMultiStepNodeAdditions\n\nAdditional arguments that are added to the FormKitNode of a multistep input.\n\ninterface MultiStepNodeAdditions {\n\n    goTo: (target: number | string) => void;\n\n    next: () => void;\n\n    previous: () => void;\n\n}\nMultiStepOptions\n\nThe options to be passed to createMultiStepPlugin\n\ninterface MultiStepOptions {\n\n    allowIncomplete?: boolean;\n\n    hideProgressLabels?: boolean;\n\n    tabStyle?:'tab' | 'progress';\n\n}\nMultiStepSlotData\ninterface MultiStepSlotData {\n\n    activeStep: string;\n\n    allowIncomplete?: boolean;\n\n    beforeStepChange?: BeforeStepChange;\n\n    handlers: FormKitFrameworkContext['handlers']&MultiStepHandlers;\n\n    hideProgressLabels: boolean;\n\n    node: FormKitMultiStepNode;\n\n    steps: Array<FormKitMultiStepSlotData>;\n\n    tabStyle:'tab' | 'progress';\n\n    validStepIcon: string | undefined;\n\n}\nStepHandlers\ninterface StepHandlers {\n\n    incrementStep: (delta: number) => () => void;\n\n    next: () => void;\n\n    previous: () => void;\n\n}\nStepSlotData\n\nSlot data unique to the step input.\n\ninterface StepSlotData {\n\n    beforeStepChange?: BeforeStepChange;\n\n    blockingCount: number;\n\n    errorCount: number;\n\n    handlers: FormKitFrameworkContext['handlers']&StepHandlers;\n\n    hasBeenVisited: true | undefined;\n\n    isActiveStep: boolean;\n\n    isFirstStep: boolean;\n\n    isLastStep: boolean;\n\n    isValid: boolean;\n\n    makeActive: () => void;\n\n    nextAttrs?: Record<string, any>;\n\n    nextLabel?: string;\n\n    ordered: boolean;\n\n    previousAttrs?: Record<string, any>;\n\n    previousLabel?: string;\n\n    showStepErrors: boolean;\n\n    stepIndex: number;\n\n    stepName: string;\n\n    steps: Array<FormKitMultiStepSlotData>;\n\n    totalErrorCount: number;\n\n    validStepIcon?: string;\n\n}\nFormKitMultiStepNode\n\nThe node type that is augmented with next and previous and goTo functions.\n\nexport type FormKitMultiStepNode = FormKitNode & MultiStepNodeAdditions;\nFormKitMultiStepSlotData\n\nThe typing for the slot data for a FormKit multi-step input.\n\nexport type FormKitMultiStepSlotData = FormKitFrameworkContext<Record<string, any>> & StepSlotData;"
  },
  {
    "title": "Optimizing for production ⚡️ FormKit",
    "url": "https://formkit.com/guides/optimizing-for-production",
    "html": "Optimizing for production\n\nFormKit ships with a lot of functionality out of the box. This is great for getting started, but the defaultConfig may include features and inputs you aren’t using. In this guide, we'll learn how to slim down our FormKit installation for production.\n\nExamining the defaultConfig\n\nMost FormKit users get started by using the provided defaultConfig — but what does this actually include?\n\nAdds the @formkit/validation plugin with all rules.\nAdds the @formkit/i18n plugin with the en locale (plus any additional locales you've added).\nAdds the @formkit/inputs plugin with all non-pro inputs.\nAdds the @formkit/theme plugin with CDN-loaded icons, or any explicitly loaded icons.\nAdds the @formkit/vue bindings to allow FormKit to interface with Vue.\nRegisters the @formkit/dev error interpreter (gives human-readable error messages in development).\n\nThe defaultConfig also exposes a convenient object syntax to provide configuration options for all the plugins above. For example, to provide an input to the @formkit/inputs plugin instantiation, the default config allows you to pass an inputs property:\n\napp.use(plugin, defaultConfig({\n\n  inputs: {\n\n    myInput: createInput(/* input options */)\n\n  }\n\n}))\n\nFor more details, check out the source code of the defaultConfig.\n\nA custom configuration\n\nWhen optimizing your FormKit installation for production, you may want to create a custom configuration. This will allow you to only include the features, inputs, rules, and messages you are actually using.\n\nFor example, consider a project with a simple form that only uses a text input and the required rule. Something like this:\n\n<script setup>\n\nasync function submit () {\n\n  // ... submit the things\n\n}\n\n</script>\n\n<template>\n\n  <FormKit\n\n    type=\"form\"\n\n    @submit=\"submit\"\n\n  >\n\n    <FormKit\n\n      type=\"text\"\n\n      name=\"name\"\n\n      label=\"Name\"\n\n      help=\"What do people call you?\"\n\n      validation=\"required\"\n\n    />\n\n  </FormKit>\n\n</template>\n\nIn this case, we only want to use the singular required rule, only the text input, and only the required message in English and German. We can create this tree-shakable custom configuration by not using the defaultConfig and instead performing our own plugin instantiations:\n\nUsing the global plugin:\n// file: main.ts\n\nimport { createApp } from 'vue'\n\nimport App from './App.vue'\n\nimport type { FormKitOptions } from '@formkit/core'\n\nimport { plugin, bindings } from '@formkit/vue'\n\nimport { createValidationPlugin } from '@formkit/validation'\n\nimport { required } from '@formkit/rules'\n\nimport { createI18nPlugin, en, de } from '@formkit/i18n'\n\nimport { createLibraryPlugin, text, form, submit } from '@formkit/inputs'\n\n\n\nconst library = createLibraryPlugin({ text, form, submit })\n\nconst validation = createValidationPlugin({ required })\n\nconst i18n = createI18nPlugin({ en, de })\n\n\n\nconst app = createApp(App)\n\napp.use(plugin, {\n\n  plugins: [library, validation, i18n, bindings]\n\n})\nUsing the Nuxt module:\n\nIf you are using the @formkit/nuxt module, you can opt out of the defaultConfig by providing the defaultConfig: false option to the module:\n\nexport default defineNuxtConfig({\n\n  modules: ['@formkit/nuxt'],\n\n  formkit: {\n\n    autoImport: true,\n\n    defaultConfig: false\n\n  }\n\n})\n\nThen your formkit.config.ts is expected to provide a full custom configuration:\n\nimport type { FormKitOptions } from '@formkit/core'\n\nimport { bindings } from '@formkit/vue'\n\nimport { createValidationPlugin } from '@formkit/validation'\n\nimport { required } from '@formkit/rules'\n\nimport { createI18nPlugin, en, de } from '@formkit/i18n'\n\nimport { createLibraryPlugin, text, form, submit } from '@formkit/inputs'\n\n\n\nconst library = createLibraryPlugin({ text, form, submit })\n\nconst validation = createValidationPlugin({ required })\n\nconst i18n = createI18nPlugin({ en, de })\n\n\n\nexport default {\n\n  plugins: [library, validation, i18n, bindings]\n\n} satisfies FormKitOptions\nCUSTOM MESSAGES\n\nIn the above examples, we import the en and de locales. These include messages that are not used in our example. Instead, we could have provided our own custom messages directly:\n\ncreateI18nPlugin({\n\n  en: {\n\n    validation: {\n\n      required: 'This field is required'\n\n    },\n\n    ui: {\n\n      submit: 'Submit'\n\n    }\n\n  },\n\n  de: {\n\n    validation: {\n\n      required: 'Dieses Feld ist erforderlich'\n\n    },\n\n    ui: {\n\n      submit: 'Einreichen'\n\n    }\n\n  }\n\n})\nConfiguration injection (code splitting)\n\nVue’s plugin architecture is inherently global. The plugin in @formkit/vue is no different; however, this convenience comes with a cost — FormKit will be loaded wherever Vue is loaded, even if it is not used on the page.\n\nFortunately for Nuxt users, the @formkit/nuxt module provides a solution to this problem: autoImport: true. This option will automatically inject FormKit and its configuration only on pages where it is used.\n\nVite users can also leverage automatic injection by using unplugin-formkit.\n\nFor users of other build tools or for use cases that don’t fit well within the supported features of unplugin-formkit, using the <FormKitProvider> component allows you to provide global configuration to your FormKit inputs at the point of use. Simply wrap your components in <FormKitProvider> and provide a config prop:\n\n<script setup>\n\nimport { FormKitProvider } from '@formkit/vue'\n\nimport type { FormKitOptions } from \"@formkit/core\"\n\n\n\nconst formKitConfig: FormKitOptions = {\n\n  // ... your custom config\n\n}\n\n</script>\n\n\n\n<template>\n\n  <FormKitProvider :config=\"formKitConfig\">\n\n    <!-- your FormKit components (can be deeply nested) -->\n\n  </FormKitProvider>\n\n</template>\nRead more about how to configure FormKit.\nConfiguration docs"
  },
  {
    "title": "Multi-Step Input Plugin ⚡️ FormKit",
    "url": "https://formkit.com/plugins/multi-step",
    "html": "Multi-Step Input Plugin\nIntroduction\nInstallation\nUsage\nTab style\nStep labels\nAllow incomplete steps\nValid step icon\nCustomizing step actions\nThe beforeStepChange event\nProps & Attributes (multi-step)\nProps & Attributes (step)\nSections\nIntroduction\n\nFormKit ships with a first-party multi-step input plugin available from the @formkit/addons package. This input allows you to build a wizard or easily break your forms into multiple steps. Breaking forms into multiple steps can improve the user-experience of larger forms by keeping them feeling small and approachable compared to listing all inputs at once.\n\nMulti-step Component Overview\n\n2 mins\n\nInstallation\n\nTo get started, import createMultiStepPlugin from @formkit/addons along with the accompanying styles. The styles are completely standalone and have no dependency on the genesis theme that ships with FormKit. This means that if you are using Tailwind to style your inputs, your input styles will still display as expected when wrapped in the multi-step input type.\n\n// formkit.config.js\n\nimport { defaultConfig } from '@formkit/vue'\n\nimport { createMultiStepPlugin } from '@formkit/addons'\n\nimport '@formkit/addons/css/multistep'\n\n\n\nconst config = defaultConfig({\n\n  plugins: [createMultiStepPlugin()],\n\n})\n\n\n\nexport default config\nA quick demonstration of the multi-step input type in action:\nRender\nHTML\nUsage\n\nThe createMultiStepPlugin function registers two new input types for you to use with the FormKit component.\n\nmulti-step: The wrapping group for the entire multi-step input. This input keeps track of which step is active, validation and errors per step, and should only contain step inputs as its immediate children\nstep: The wrapping group for a given step within your multi-step input. Should only be an immediate child of a multi-step input. Its children will be rendered as the contents of the step.\n\nUsing these inputs together is as simple as wrapping any markup you want to have present within a step in a multi-step form.\n\n<FormKit type=\"multi-step\">\n\n  <FormKit type=\"step\" name=\"stepOne\">\n\n    <!-- content for stepOne goes here! -->\n\n  </FormKit>\n\n</FormKit>\n\nOut-of-the-box the parent multi-step input will track the validity of the inputs contained in each child step input and prevent advancing to the next step until the current step is valid. The count of total blocking validations and errors will be shown next to the current step name if a user attempts to advance to the next step or submit the form before satisfying the current step's input validations.\n\nTab style\n\nThe multi-step input ships with two available tab styles.\n\ntab: The default tab experience. Each step name is show in a tab with an active state. Error count is shown in the top right of the tab.\nprogress: A progress bar style where each step is a \"node\" on a timeline of total steps. With this display mode you can also use the hide-progress-labels prop to hide the step names.\nRender\nHTML\nStep labels\n\nBy default the multi-step input will use the name attribute of its child step inputs to generate labels for steps. If you'd like more control over the display of your step names you can use the label prop. You can also customize the labels that appear in the stepActions section of your step using the previous-label and next-label props.\n\nlabel: An override for the step name that should appear in the multi-step tabs.\nprevious-label: an override for the stepPrevious button label which defaults to Back.\nnext-label: an override for the stepNext button label which defaults to Next.\nRender\nHTML\nAllow incomplete steps\n\nBy default the multi-step input will allow advancing to later steps even if the current step or a step between the current step and the target step has blocking validation messages. To prevent a user from jumping ahead set the allow-incomplete prop to false.\n\nRender\nHTML\nValid step icon\n\nWhen a step has been completed with no validation errors the multi-step input will — by default — render a check icon showing that the step is valid and no more action is required. The valid-step-icon is a FormKit Icon and can be changed via a prop like any other FormKit icon.\n\nYou can either:\n\nChange the valid-step-icon on the multi-step input to change the icon for all steps inside the input.\nChange the valid-step-icon on a step input to change or override the icon just for that step.\nRender\nHTML\nCustomizing step actions\n\nEach step in a multi-step input has default buttons rendered for moving between steps. By default the first step in a multi-step will only have a stepNext action button rendered, and the last step will only have a stepPrevious action button. This allows a multi-step to act as a self-contained group within the context of a larger form.\n\nIf you want to add a custom action such as a form submit to a multi-step — useful if you're using the multi-step as your whole form — you can do so by overriding the stepNext slot on the desired step. In this case we'll add a submit input to the last step in our multi-step input to submit the form.\n\nThe stepNext and stepPrevious sections have access to the incrementStep handler — which returns a callable function — to enable programatic navigation.\n\nTAB NAVIGATION\n\nBy default, the stepNext in a multi-step input uses event listeners to capture tab navigation via keyboard and allow users to cycle through all available steps within a multi-step.\n\nIf you want to preserve this behaviour in your own custom stepNext implementation then be sure to add a data-next=\"true\" attribute to your focusable element that triggers step navigation.\n\nRender\nHTML\nThe beforeStepChange event\n\nSometimes you need to do something with your form data between steps. Maybe you want to submit each step independently to your back-end or you need to log analytics events to determine how far users are making it through your form. In cases such as these you can use the beforeStepChange event. beforeStepChange accepts a function and is provided a context object with the following keys:\n\ncurrentStep: The currently active step node context object that the user is navigating away from.\ntargetStep: The step node context object that the user is navigating to.\ndelta: The distance between steps. Positive integers represent stepping forward, negative integers represent stepping backward.\n\nYour beforeStepChange function should return a Boolean. Returning false will prevent the step change from ocurring.\n\nbeforeStepChange can be used on your multi-step input in which case it will apply to all steps. Additionally you can use beforeStepChange on a specific step input to run your function only when navigating away from the step which has the function assigned. beforeStepChange applied to a step will override any beforeStepChange set on a parent multi-step if one exists.\n\nRender\nHTML\nProps & Attributes (multi-step)\nProp\tType\tDefault\tDescription\nallowIncomplete\tboolean\ttrue\tWhen true, allows users to navigate between steps even if current step is invalid.\ntabStyle\tstring\ttab\tUsed to set a data-attribute for creating tab styles. Default theme ships with support for tab and progress tab styles.\nhideProgressLabels\tboolean\tfalse\tWhen true, hides labels for the progress tab style.\nvalidStepIcon\tstring\tcheck\tSpecifies an icon to put in the badge section when a step is valid. When applied to the multi-step the icon will be applied to all child step inputs.\nbeforeStepChange\tfunction\tundefined\tA function to run before the active step is changed. The function is supplied with a context object containing currentStep and targetStep which are both FormKit node context objects. Additionally, delta is supplied as an integer which reflects the distance between currentStep and targetStep. When supplied to the multi-step this function will fire on every step change.\nShow Universal props\nProps & Attributes (step)\nProp\tType\tDefault\tDescription\nlabel\tstring\t\tUsed to change the tab label of the step. If not custom label is supplied the step's name will be used.\npreviousLabel\tstring\tPrevious\tUsed to change the label of the default previousAction button.\nnextLabel\tstring\tNext\tUsed to change the label of the default nextAction button.\npreviousAttrs\tobject\t[object Object]\tUsed to apply attributes to the default previousAction button input.\nnextAttrs\tobject\t[object Object]\tUsed to apply attributes to the default nextAction button input.\nvalidStepIcon\tstring\tcheck\tSpecifies an icon to put in the badge section when the step is valid. When applied to a step the icon will be applied only to the target step.\nbeforeStepChange\tfunction\tundefined\tA function to run before the active step is changed. The function is supplied with a context object containing currentStep and targetStep which are both FormKit node context objects. Additionally, delta is supplied as an integer which reflects the distance between currentStep and targetStep. When supplied to a step this function will fire only when navigating away from the specified step.\nShow Universal props\nSections\ntabs\ntab\ntabLabel\nsteps\nstep\nstepActions\nstepPrevious\nStep Name\n⚠️\n... Step content ...\nBack\nNext\nouter\nwrapper\nbadge\nstepInner\nstepNext\nSection-key\tDescription\ntabs\tA wrapper around all of the tabs.\ntab\tA button element that contains the tab name and the decorator to reflect validation state.\ntabLabel\tA span element that contains the name of the tab.\nbadge\tA span element used as a decorator for showing current tab validity state.\nsteps\tA wrapper around all steps.\nstep\tA wrapper around step content from the default slot and the step’s action buttons. Each step has visibility styling automatically applied depending on if it is the current active step.\nstepInner\tA wrapper around the default slot content for a step.\nstepActions\tA wrapper around the action buttons for moving between steps.\nstepPrevious\tA wrapper around the action button for navigating to the previous step.\nstepNext\tA wrapper around the action button for navigating to the next step.\nShow Universal section keys"
  },
  {
    "title": "Export and restructure inputs ⚡️ FormKit",
    "url": "https://formkit.com/guides/export-and-restructure-inputs",
    "html": "Export and restructure inputs\nExport via CLI\nRegister input\nModifying schema\nUsing helpers\nNext steps\n\nFormKit inputs ship with a lot of markup. This is useful for ensuring inputs are written in an accessible manner. However, sometimes it makes sense to modify the existing structure of a FormKit input. Using the FormKit CLI, we can export FormKit's open source inputs and modify their original structure — or even their functionality.\n\nIn this guide, we'll export the text input, and restructure it to better support a floating label design.\n\nExport via CLI\n\nFormKit comes with its own CLI to make exporting inputs a breeze. At the base directory of your project, run:\n\nnpx formkit export\n\nRunning this command prompts you to select any of FormKit's open source inputs to export:\n\n? What input do you want to export? ›\n\n❯   button\n\n    submit\n\n    checkbox\n\n    file\n\n    form\n\n    group\n\n    hidden\n\n    list\n\n    radio\n\n  ↓ select\n\nWe're going to select the text input and allow the CLI to create a new /inputs directory within /src:\n\n✔ What input do you want to export? › text\n\n✔ What language should be used? › JavaScript\n\n? Where should the input be exported to (relative to the current directory)? ›\n\n./src/inputs\n\nTaking a look at our exported input, text.js, we can see the underlying sections that make up the FormKit input. These sections are provided as small composable functions. Each section represents a single FormKitSchemaNode and the arguments passed to that section are its children:\n\n// text.js\n\nimport {\n\n  outer,\n\n  inner,\n\n  wrapper,\n\n  label,\n\n  help,\n\n  messages,\n\n  message,\n\n  icon,\n\n  prefix,\n\n  suffix,\n\n  textInput,\n\n} from '@formkit/inputs'\n\n/**\n\n * Input definition for a text.\n\n * @public\n\n */\n\nexport const text = {\n\n  /**\n\n   * The actual schema of the input, or a function that returns the schema.\n\n   */\n\n  schema: outer(\n\n    wrapper(\n\n      label('$label'),\n\n      inner(\n\n        icon('prefix', 'label'),\n\n        prefix(),\n\n        textInput(),\n\n        suffix(),\n\n        icon('suffix')\n\n      )\n\n    ),\n\n    help('$help'),\n\n    messages(message('$message.value'))\n\n  ),\n\n  /**\n\n   * The type of node, can be a list, group, or input.\n\n   */\n\n  type: 'input',\n\n  /**\n\n   * An array of extra props to accept for this input.\n\n   */\n\n  props: [],\n\n  /**\n\n   * Additional features that should be added to your input\n\n   */\n\n  features: [],\n\n}\n\nIn this example, we are not going to overwrite the default FormKit text input, but instead, create a custom text input that is going to use floating labels. Let's go ahead and rename the text file we just exported to floatingLabelTextInput.js:\n\nsrc/\n\n  |inputs/\n\n  |   |- t̶e̶x̶t̶ floatingLabelTextInput.js\n\nIn floatingLabelTextInput.js, let's change the name of the exported variable to floatingLabelTextInput from text.\n\n...\n\nexport const t̶e̶x̶t̶ floatingLabelTextInput = {\n\n  ...\n\n}\nRegister input\n\nTo globally register our \"new\" input, we need add our floatingLabelTextInput to the global config. We can do this wherever we are registering the FormKit plugin:\n\n//main.js\n\nimport { createApp } from 'vue'\n\nimport App from './App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\nimport '@formkit/themes/genesis'\n\nimport { floatingLabelTextInput } from '../src/inputs/floatingLabelTextInput'\n\n\n\nconst config = defaultConfig({\n\n  inputs: {\n\n    floatingLabelTextInput,\n\n  },\n\n})\n\n\n\ncreateApp(App).use(plugin, config).mount('#app')\nModifying schema\n\nNow we're going to modify the schema of floatingLabelTextInput to better support floating labels, which are usually implemented using the CSS sibling selector: ~. In order to use a CSS selector like :focus ~ label, our <label> tag needs to be placed after our <input> tag. With our schema already exported, this change is easy to make:\n\nexport const floatingLabelTextInput = {\n\n  schema: outer(\n\n    wrapper(\n\n      /*\n\n      * Removing label\n\n      */\n\n      l̶a̶b̶e̶l̶(̶'̶$̶l̶a̶b̶e̶l̶'̶)̶, // ❌ removed from here\n\n      inner(\n\n        icon('prefix', 'label'),\n\n        prefix(),\n\n        textInput(),\n\n        label('$label'), // 👈 and now placed here\n\n        suffix(),\n\n        icon('suffix')\n\n      )\n\n    ),\n\n    help('$help'),\n\n    messages(message('$message.value'))\n\n  ),\n\n  ...\n\n}\nUsing helpers\n\nThe @formkit/inputs package exports a number of helper functions that can be easily applied to the composable schema functions. Available helpers are:\n\nimport { $attrs, $if, $for, $extend, $root } from '@formkit/inputs'\n\nImporting the $attrs function from FormKit's input package allows us to extend the schema of any section with additional attributes. In this example, we are using it to modify the label section and change its class from formkit-label to formkit-label-floating. Additionally, we’ll add a data-has-value attribute:\n\nimport {\n\n  outer,\n\n  inner,\n\n  wrapper,\n\n  label,\n\n  help,\n\n  messages,\n\n  message,\n\n  icon,\n\n  prefix,\n\n  suffix,\n\n  textInput,\n\n  /*\n\n   * Importing $attrs\n\n   */\n\n  $attrs,\n\n} from '@formkit/inputs'\n\n\n\nexport const floatingLabelTextInput = {\n\n  schema: outer(\n\n    wrapper(\n\n      inner(\n\n        icon('prefix', 'label'),\n\n        prefix(),\n\n        textInput(),\n\n        /*\n\n        * Using $attrs function to pass attrs object to label section with new\n\n          class definition.\n\n        */\n\n        $attrs(\n\n          {\n\n            class: '$classes.labelFloating',\n\n            'data-has-value': '$_value !== \"\" && $_value !== undefined',\n\n            for: '$id',\n\n          },\n\n          label('$label')\n\n        ),\n\n        suffix(),\n\n        icon('suffix')\n\n      )\n\n    ),\n\n    help('$help'),\n\n    messages(message('$message.value'))\n\n  ),\n\n\n\n  type: 'input',\n\n\n\n  props: [],\n\n\n\n  features: [],\n\n}\n\nAfter adding appropriate styling, we can see that our new custom input has its <label> moved within the HTML structure and uses floating labels:\n\nRender\nHTML\nNext steps\n\nIn this guide we exported the built-in text input using FormKit's CLI tool and used the exported file as a starting point for a new floating label variation. However, the export feature enables developers to do much more than that! Whether replacing FormKit's existing inputs, or adding new custom inputs with modified, added, removed, or moved sections — we look forward to seeing all the ways you use this feature!\n\nLearn more about creating custom inputs.\nRead the guide"
  },
  {
    "title": "Save to LocalStorage ⚡️ FormKit",
    "url": "https://formkit.com/plugins/local-storage",
    "html": "LocalStorage Plugin\nInstallation\nUsage\nBasic example\nRestoring values on failed submit\nWith unique keys\nWith a control\nWith data modification\n\nUsing the createLocalStoragePlugin function from @formkit/addons, you can easily save unsubmitted user form inputs to localStorage which will be restored on page load. This is great for preventing data loss in the event a user's browser crashes, tab is closed, or other unforeseen issue causes your application to reload before the user can submit their data.\n\nLocalStorage data is automatically cleared when a form submit is called.\n\nInstallation\n\nTo install the localStorage plugin, we need to:\n\nimport it from @formkit/addons.\nAdd it to our FormKit config as a plugin.\nAdd the use-local-storage prop to the target form.\n\nThe createLocalStoragePlugin has options you can configure:\n\nprefix - The prefix assigned to your localStorage key. Defaults to formkit.\nkey - An optional key to include in the localStorage key name, useful for keying data to a particular user.\ncontrol - An optional field name for a field in your form you would like to use to enable saving to localStorage when true. The field value must be a boolean.\nmaxAge - The time (in milliseconds) that the saved localStorage should be considered valid. Defaults to 1 hour.\ndebounce - The debounce to apply to saving data to localStorage. Defaults to 200ms\nbeforeSave: — An optional async callback that recieves the form data. Allows modification of form data before saving to localStorage.\nbeforeLoad: — An optional async callback that recives the form data. Allows modification of the localStorage data before applying to the form.\n// formkit.config.js\n\nimport { defaultConfig } from '@formkit/vue'\n\nimport { createLocalStoragePlugin } from '@formkit/addons'\n\n\n\nconst config = defaultConfig({\n\n  plugins: [\n\n    createLocalStoragePlugin({\n\n      // plugin defaults:\n\n      prefix: 'formkit',\n\n      key: undefined,\n\n      control: undefined,\n\n      maxAge: 3600000, // 1 hour\n\n      debounce: 200,\n\n      beforeSave: undefined,\n\n      beforeLoad: undefined\n\n    }),\n\n  ],\n\n})\n\n\n\nexport default config\nUsage\n\nTo enable saving to localStorage add the use-local-storage to your FormKit form. The localStorage key will be your provided prefix (default is formkit) and your form name eg. formkit-contact.\n\nBasic example\nRender\nHTML\n\nThat's it! Your form data will now be saved on every commit event that the form receives. It will remain valid until the maxAge set in your plugin config, and the localStorage data is cleared when the submit event fires on the target form.\n\nRestoring values on failed submit\n\nWhen a user submits your form the matching localStorage entry for the form is deleted. Before deletion the value of the localStorage entry is stored in-memory and can be recovered by calling the node.restoreCache() method in your submit handler. This is useful for restoring user-entered data in the event that you have a failure in your submission process such as a server error.\n\nRender\nHTML\nWith unique keys\n\nIf you are saving data to localStorage in the context of an app where multiple users might share the same device you can provide a key that is unique to the user and each user will then have their own localStorage entry.\n\nRender\nHTML\nWith a control\n\nYou can allow a user to opt-in to saving their form data to localStorage by supplying the name of a field that returns a boolean value. When true, values will be saved.\n\nRender\nHTML\nWith data modification\n\nUsing the beforeSave and beforeLoad async callbacks you can modify the data that is saved to localStorage. This can be useful if you want to run some sort of obfuscation funciton or send the data to your backend to encrypt it. In this examle, we obfuscate the data by base64 encoding the form values.\n\nNote that the form is disabled when loading data from localStorage until our beforeLoad callback resolves.\n\nRender\nHTML\nCLEARING USER DATA\n\nlocalStorage form information should be considered transient and ultimately stored in a database. We recommend clearing localStorage keys related to form data when a user logs out of your applications. You can do this by looping over Object.entries(localStorage) and removing all localStorage entries that start with ${prefix}-${id} from your plugin configuration.\n"
  },
  {
    "title": "Create a custom input ⚡️ FormKit",
    "url": "https://formkit.com/guides/create-a-custom-input",
    "html": "Create a custom input\nCreating a component\nInput & output\nRequirements for our input\nAdding a prop\nInteractivity\nCopy & paste\nRegistration\nNext steps\n\nIn this guide, we’ll walk through the process of creating, registering, and using a custom input. Specifically, we’re going create a \"one-time password\" input (\"OTP\" for short). OTPs are commonly used for two-factor authentication when a user is required to type in a code sent via SMS or authenticator app. Let’s get started!\n\nSFC BUILD TOOL\n\nThis guide assumes you are using a standard Vue 3 build tool like Vite, Nuxt 3, or Vue CLI that will allow you to import .vue single file components.\n\nCreating a component\n\nTo get started, let's create our input’s component file. We'll call it OneTimePassword.vue:\n\n<script setup>\n\n  const props = defineProps({\n\n    context: Object,\n\n  })\n\n</script>\n\n\n\n<template>\n\n  <div>More to come here...</div>\n\n</template>\n\nFormKit provides a lot of input features out-of-the-box that we're going to want to preserve — like labels, help text, and showing error messages. All we really want to modify is the input section of our input. We can preserve these standard FormKit features by using the createInput utility function from the @formkit/vue package.\n\nAs we build out our input, we’ll want to visualize its progress, so let’s create a sample form to:\n\nImport OneTimePassword.vue\nPass that imported component to createInput()\nUse the return value (an input definition) as the type prop of a <FormKit> component.\n\nWe’ll call this sample form Register.vue:\n\nLoad live example\n\nExcellent! Now we can iterate on our OneTimePassword.vue file and see the results. One of the first things to notice is how our input already supports labels, help text, validation, and other universal FormKit props. Those features come courtesy of createInput().\n\nAlso, notice that <pre> tag in the above example? It is outputting the current state of the form’s data. We'll use this visualize the value of our custom input. Since our input currently has no value, it does not appear in the form’s data. Time to change that!\n\nInput & output\n\nLet’s open up OneTimePassword.vue again and change our <div> to an <input> tag. We’ll start with a single text input, and work our way up from there. But how do we actually set and display the value of our custom input?\n\nAll custom inputs are passed the almighty context object as the context prop. In order for our input to set its value, it needs to call context.node.input(value). To properly display the value of our input, we should set the input’s :value attribute to context._value.\n\nLoad live example\n\nOur little baby input is all grown up! It might not look pretty, but it now reads and writes values. As proof, try setting the initial value of the form’s values object to { two_factor_code: '12345' } and you'll see the input gets auto-populated with the value.\n\nRequirements for our input\n\nOk, now that we understand how to create an input, how to use it, and how to read and write values — let’s tackle the actual \"business logic\" of our one-time password input. Here are our requirements:\n\nUsers enter a series of digits, and each digit has its own <input> tag.\nThe value of the input should always be all the digits concatenated.\nWe only want the input to change its value if all digits have been completed (no need to commit and validate on each keystroke if the user is not done).\nIt should allow a user to click on a given digit to edit it.\nWhen a user types a number, it should automatically focus on the next input.\nIt should support copy/paste.\nAdding a prop\n\nFor our first requirement, we need n <input> tags. Perhaps it would be best to expose the number of digits as a prop. To do that, we need to inform our createInput function that we want to accept a new prop:\n\ncreateInput(OneTimePassword, {\n\n  props: ['digits'],\n\n})\n\nWe now have access to context.digits. Back in OneTimePassword.vue, let's use that to output the correct number of <input> tags.\n\nLoad live example\n\nOK — we have multiple inputs! Our first requirement is complete:\n\nUsers enter a series of digits, and each digit has its own <input> tag.\nSTYLING\n\nWe’ve added a touch of CSS in the above example, but in general we’re not going to dive into styling in this guide. It is recommended to use context.classes.yourKey as the class name of elements in your input.\n\nInteractivity\n\nNotice in the above example that when you type into one input all the other inputs are synced to the same value? Kinda neat, but not what we want. This is because we are still using the same input handler and :value. Here's a plan to improve our input:\n\nEach input should only modify the character at its respective index in the final string.\nThe input handler should call focus() on the next input.\nWhen the string is the same length as digits, we update the value of the input by calling context.node.input().\nLoad live example\n\nGreat! This is starting to work like we expect. Let’s check our requirements again:\n\nUsers enter a series of digits, and each digit has its own <input> tag.\nThe value of the input should always be all the digits concatenated.\nWe only want the input to change its value if all digits have been completed (no need to commit and validate on each keystroke if the user is not done).\nIt should allow a user to click on a given digit to edit it.\nWhen a user types a number, it should automatically focus on the next input.\nIt should support copy/paste.\nCopy & paste\n\nLooks like we only have one thing left to do — copy & paste support. Fortunately, browsers have a paste event. To ensure our user experience is top notch, we’ll make an assumption: if a user is copy/pasting they are trying to copy and paste the entire code. Not a single digit of the code. Seems reasonable.\n\nAll we need to do is capture the copy/paste event on any of our input tags, get the text being pasted, and set the tmp value to that string of digits. Let’s whip up another event handler:\n\nhandlePaste(e) {\n\n  const paste = e.clipboardData.getData('text')\n\n  if (typeof paste === 'string') {\n\n    // If it is the right length, paste it.\n\n    this.tmp = paste.substr(0, this.max)\n\n    const inputs = e.target.parentElement.querySelectorAll('input')\n\n    // Focus on the last character\n\n    inputs.item(this.tmp.length - 1).focus()\n\n  }\n\n}\nLoad live example\n\nOur requirements are all complete!\n\nRegistration\n\nNow that we've worked up an excellent input, let’s register it with our application so we can use it anywhere by just using the string otp. Open up your Vue application’s main file (where app.use(formKit) is). We’ll just add to it:\n\nimport { createApp } from 'Vue'\n\nimport App from 'App.vue'\n\nimport OneTimePassword from './OneTimePassword.vue'\n\nimport { plugin, defaultConfig, createInput } from '@formkit/vue'\n\n\n\nconst app = createApp(App)\n\napp.use(\n\n  plugin,\n\n  defaultConfig({\n\n    inputs: {\n\n      otp: createInput(OneTimePassword, {\n\n        props: ['digits'],\n\n      }),\n\n    },\n\n  })\n\n)\n\napp.mount('#app')\n\nDone! Now you can use your input anywhere in your application:\n\n<FormKit type=\"otp\" digits=\"4\" />\nNext steps\n\nOur one-time password input is working great! Here are some ideas for additional features we could flesh out even further:\n\nAn accompanying validation rule to perform a two-factor authentication call to the backend.\nAdditional styles to really make it pop.\nIf the form only contains a one-time password input, you could auto-submit the form!\nComplete the custom input checklist.\nPublish it! If this input (or any others you make) is useful to you, it's probably useful to other people too. You might consider open-sourcing it!\n\nHopefully this guide helped you understand how custom inputs are declared, written, and registered. If you want to dive in deeper, try reading about the core internals of FormKit and creating custom inputs!\n\nWant more? Start by reading about FormKit core.\nDig deeper"
  },
  {
    "title": "Zod Plugin ⚡️ FormKit",
    "url": "https://formkit.com/plugins/zod",
    "html": "Zod Plugin\nInstallation\nUsage\nFor form validation\nIn addition to FormKit validation\nFor setting form errors\n\nWith the @formkit/zod package you can easily enable validation of your FormKit forms with your Zod schema. This provides a convenient way to have isomorphic types and ensure that your front-end and back-end are using the same validation rules.\n\nWhen validating against a Zod schema all validation errors will be mapped to their corresponding inputs, show or hide based on your form / input's validation-visibility prop, and prevent submission when form data does not pass validation with Zod.\n\nInstallation\n\nThe Zod Plugin is intended to run on a FormKit form. Your usage of the plugin will be on a per-form basis and each form that requires validation with a Zod schema will create a new instance of the plugin using the createZodPlugin function.\n\nUsage\n\nTo use the Zod plugin we need to import the createZodPlugin function from @formkit/zod, call the createZodPlugin function to create receive our zodPlugin and submitHandler, and then add them both to our FormKit form.\n\nThe createZodPlugin function takes two arguments:\n\nzodSchema: The Zod schema that you would like to use to validate against the form.\nsubmitCallback: a function you would like to run once validation has succeeded on your form — this is where you would handle posting your data to your backend or other submit-related tasks. You form data will be provided with full TypeScript support based on your Zod schema.\n\nThe createZodPlugin will return a tuple of:\n\nzodPlugin: The plugin that should be applied to your target form's plugins prop.\nsubmitHandler: The submit handler that should be attached to your form's @submit action. When the form data passes validation of your provided Zod schema your submitCallback will fire.\nFor form validation\n\nHere is an example of using a Zod schema to validate a FormKit form. It's important that your FormKit input names match the expected values for your Zod schema.\n\nLoad live example\n\nNow your FormKit form will use your Zod Schema for validation — and all messages will adjacent to each matching FormKit just live native FormKit validation!\n\nIn addition to FormKit validation\n\nUsing Zod to validate your form doesn't mean you have to forgo using FormKit's built-in validation messages. If you add FormKit validation to your FormKit inputs then Zod validation errors will only show if all FormKit validations have been satisfied and there are remaining unsatisfied Zod validations.\n\nThis has a few benefits:\n\nYou can use FormKit's built-in rules such as confirm which don't have easy-to-use equivalents within Zod.\nYour messages can be translated to one of the many existing languges in @formkit/i18n without any additional effort on your part.\nThe built-in FormKit validation messages are written to be contextually aware of your input names and knowing that they will be attached directly to their corresponding inputs — so they are more precise and easier to understand than their generic Zod counterparts.\n\nHere's the same form as before, but now using FormKit validation messages in addition to Zod schema validaiton.\n\nLoad live example\nFor setting form errors\n\nIf you need to set errors on your form you can do so with the node.setZodErrors function that is made available by the zodPlugin. The node.setZodErrors function accepts a ZodError object and will map the errors to each input. Any non-matching errors will be shown as form-level errors.\n\nLoad live example"
  },
  {
    "title": "Barcode input ⚡️ FormKit",
    "url": "https://formkit.com/plugins/barcode",
    "html": "Barcode input\nIntroduction\nInstallation\nUsage\nBasic\nCustomizing target barcodes\nProps & Attributes\nSections\nInput\nOverlay\nIntroduction\n\nThe barcode input type is a standalone input published by FormKit. It is powered by the zxing library and allows scanning of a variety of 1D and 2D barcode types using cameras connected to your browsing device.\n\nOPEN SOURCE\nThe full source code for the barcode input is available on GitHub.\nInstallation\nWARNING\n\nThe barcode input has a dependency on @zxing/library which is rather heavy (about 100kb minified + gzipped). You should only include this input in your project if you specifically need barcode scanning capability via connected cameras. For manual barcode entry please consider using a mask or text input with custom validation rules.\n\nTo install the barcode input add the @formkit/barcode package to your project's dependencies.\n\nnpm install @formkit/barcode\n\nThen, in your FormKit configuration file import the input and its styles. Then add the input to your global FormKit configuration.\n\n// formkit.config\n\n...\n\nimport { barcode } from '@formkit/barcode'\n\nimport '@formkit/barcode/genesis'\n\n\n\n...\n\n\n\nconst config = defaultConfig({\n\n  inputs: {\n\n    barcode\n\n  }\n\n})\n\n\n\n...\nUsage\nBasic\n\nYou can now use the barcode input type in your <FormKit /> components. By interacting with the barcode icon you can open an overlay with a video feed from a connected camera. You will need to approve access to the camera via your browser.\n\nRender\nHTML\nCustomizing target barcodes\n\nBy default the barcode input will scan every supported barcode type. The list of target barcode formats can be changed using the formats prop. A full list of supported formats can be seen in the zxing documentation. All format names will be uppercased with _ separators. So QR Code becomes QR_CODE, UPC-A becomes UPC_A, etc.\n\nRender\nHTML\nProps & Attributes\nProp\tType\tDefault\tDescription\nformats\tArray\t[]\tAn array of available formats in uppercase with _ separators (eg. QR_CODE) from the available set on the zxing documentation. If no formats array is provided then all parsable code formats will be considered valid inputs.\nbarcode-icon\tString\tinline SVG code\tSpecifies an icon to put in the barcodeIcon section. The barcodeIcon section is hidden while the camera interface is loading.\nloader-icon\tString\tspinner\tSpecifies an icon to put in the loaderIcon section. The loaderIcon section is shown while the camera interface is loading.\nclose-icon\tString\tclose\tSpecifies an icon to put in the closeIcon section.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nInput\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nBarcode\n377340003030\n⬜️\n🔄\nScan a code.\nBarcode is required.\nwrapper\ninner\nbarcodeIcon\nloaderIcon\nsuffix\nsuffixIcon\nmessages\nmessage\nOverlay\ndialog\nvideo\noverlayDecorators\noverlayDecoratorTopLeft\noverlayDecoratorTopRight\noverlayDecoratorBottomLeft\noverlayDecoratorBottomRight\nlaser\n✖️\n📺\nscannerContainer\ncloseIcon\noverlay\nSection-key\tDescription\nbarcodeIcon\tAn element for outputting a barcode icon that toggles the camera overlay.\nloaderIcon\tAn element for outputting a loader icon that shows in place of the barcodeIcon while the camera interface is loading.\ndialog\tThe dialog element (by default a native HTML dialog) that contains the camera interface.\nscannerContainer\tA wrapper around the close icon, video stream, and decorative scanning overlay.\ncloseIcon\tAn element for outputting a close icon for the dialog.\nvideo\tA native HTML video element that shows the connected camera feed.\noverlay\tA decorative element that overlays a portion of the video to mimic a scanning interface.\noverlayDecorators\tA container for the overlay decorators that frame a portion of the video feed.\noverlayDecoratorTopLeft\tA decorative element for framing a portion of the video feed.\noverlayDecoratorTopRight\tA decorative element for framing a portion of the video feed.\noverlayDecoratorBottomLeft\tA decorative element for framing a portion of the video feed.\noverlayDecoratorBottomRight\tA decorative element for framing a portion of the video feed.\nlaser\tA decorative element that imitates a scanning laser.\nShow Universal section keys"
  },
  {
    "title": "Floating labels ⚡️ FormKit",
    "url": "https://formkit.com/plugins/floating-labels",
    "html": "Floating Labels Plugin\nInstallation\nUsage\n\nUsing the createFloatingLabelsPlugin function from @formkit/addons you can easily add a floating label treatment to any text family (text, email, url, date, etc) or textarea FormKit input.\n\nInstallation\n\nTo install the floating labels plugin we need to import it from @formkit/addons, add it our FormKit config, and include the supporting CSS styles (or provide your own).\n\nThe createFloatingLabelsPlugin has one option you can configure which controls whether the floating label treatment is the default treatment on applicable inputs.\n\n// formkit.config.js\n\nimport { defaultConfig } from '@formkit/vue'\n\nimport { createFloatingLabelsPlugin } from '@formkit/addons'\n\nimport '@formkit/addons/css/floatingLabels'\n\n\n\nconst config = defaultConfig({\n\n  plugins: [\n\n    createFloatingLabelsPlugin({\n\n      useAsDefault: true, // defaults to false\n\n    }),\n\n  ],\n\n})\n\n\n\nexport default config\nUsage\n\nBy default the floating label plugin only takes effect on a FormKit input if you set the new floating-label prop to true.\n\nRender\nHTML\n\nIf you would like to use floating labels by default then pass the useAsDefault option to the plugin when you install it.\n\n// formkit.config.js\n\n...\n\nplugins: [\n\n  createFloatingLabelsPlugin({\n\n    useAsDefault: true\n\n  }),\n\n],\n\n...\n\nWhen floating labels are set as the default you can still disable them on a FormKit input by setting the floating-label prop to false.\n\nRender\nHTML\n\nThat's It! Floating labels on your FormKit inputs in as little as 3 additional lines of code.\n"
  },
  {
    "title": "Auto-Height Textarea Plugin ⚡️ FormKit",
    "url": "https://formkit.com/plugins/auto-height-textarea",
    "html": "Auto-Height Textarea Plugin\nInstallation\nUsage\n\nUsing the createAutoHeightTextareaPlugin function from @formkit/addons you can use a new prop (auto-height) on your Formkit inputs of type textarea to have them automatically grow and shrink in size based on their content.\n\nInstallation\n\nTo install the auto-height textarea plugin, we need to:\n\nimport it from @formkit/addons.\nAdd it to our FormKit config as a plugin.\nAdd the new auto-height prop to any textarea.\n// formkit.config.js\n\nimport { defaultConfig } from '@formkit/vue'\n\nimport { createAutoHeightTextareaPlugin } from '@formkit/addons'\n\n\n\nconst config = defaultConfig({\n\n  plugins: [\n\n    createAutoHeightTextareaPlugin(),\n\n  ],\n\n})\n\n\n\nexport default config\nUsage\n\nTo enable auto-height on a text area add the auto-height prop to a FormKit input of type textarea.\n\nRender\nHTML"
  },
  {
    "title": "Transfer List Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/transfer-list",
    "html": "Transfer List\nView pricing →\nIntroduction\nGetting started\nBase input\nLabels\nDefining options\nValues\nSearchable\nMax\nTransfer on select\nAsynchrony\nAsynchronous options\nOption loader\nSlots\nSource and target options\nExamples\nRanked order\nProps & Attributes\nSections\nWrapper of transfer list\nSource\nTransfer controls\nTarget\nPro installation quickstart 🚀\nIntroduction\nTransfer List Overview\n\n1 min\n\nThe transfer list input is ideal for situations where the end-user needs to select and sort multiple values from a list of options. In this example, we are allowing the end-user to select from a group of guests and move them to a VIP list:\n\nRender\nHTML\nGetting started\n\nIn this section, we will be covering the basics of how to replicate the 'Guests vs VIPs' example from above.\n\nBase input\n\nBelow is an example of the transfer list input with the minimum required props. As you can see, there are two list boxes: the source list box and the target list box. The source list box will contain the list of options, and the target list box will contain the selected options:\n\nRender\nHTML\nLabels\n\nLet's add some label props to make clear to the end-user how to use the transfer list input. We'll add a label prop to explain the directive to the user, and source-label and target-label props to indicate which list box is the source and which is the target:\n\nRender\nHTML\nSource and target empty messages\n\nIn this state, with no options passed and no values selected, we can display a custom message to the user by setting the source-empty-message and target-empty-message props:\n\nRender\nHTML\nDefining options\n\nThe options prop can accept three different formats of values:\n\nAn array of objects with value and label keys\nAn array of strings 'A', 'B', 'C'\nAn object literal with key-value pairs { a: 'A', b: 'B', c: 'C' }\nA function that returns any of the above\n\nLet's go ahead and populate the transfer list's options with a list of guest names:\n\nRender\nHTML\nValues\n\nThe value of the transfer list input is an array. Selected option values from the source list will be appended to the array. To show the value changing in the example below, let's wrap the transfer list input in a FormKit form, set the name of the transfer list input to vips, and show the value of the form itself in a <pre> tag (if you are unfamiliar with FormKit forms, you can read more here):\n\nRender\nHTML\nInitial values\n\nThe transfer list input can be pre-populated with values by setting the value prop on the transferlist itself or a wrapping form or group. Remember that the values you pass to the value prop need to match the keys of the values in your option list:\n\nRender\nHTML\nSearchable\n\nThe transfer list input can be made searchable by setting the searchable prop. In this example we'll set the searchable prop and also set a placeholder prop for the search input:\n\nRender\nHTML\nONLY THE OPTIONS ARE SEARCHED\nThe search input only searches through the options in the source options list. It does not return options that have already been transferred to the target list.\nFiltering\n\nThe transfer list input will filter options with its own internal search function. You can replace this search function by providing the filter prop a function of your own. Your function will receive two arguments, the option being iterated over and the current search value:\n\nRender\nHTML\nClear on select\n\nBy default, the transfer list input will clear the search input on select. You can change this behavior by setting the clear-on-select prop to false:\n\nMax\n\nThe transfer list input can be limited to a maximum number of selected values by setting the max prop. For just this example, let's set the max prop to 2 to limit the number of VIPs that can be selected:\n\nRender\nHTML\nTransfer on select\n\nBy default, the transfer list input will add or remove options on click. You can change this behavior by setting the transfer-on-select prop to false. Now, the transfer list will behave more like a traditional transfer list:\n\nRender\nHTML\nAsynchrony\nAsynchronous options\n\nHere we have a transfer list input that loads its options from an asynchronous function. The function is called when the component is mounted and the options are subsequently loaded into the source list box:\n\nRender\nHTML\nPagination\n\nNow let's say that our API request does not fetch all the options we need, but instead returns a paginated response. The transfer list input can handle pagination with minor configuration to the asynchronous function.\n\nWhen assigning the options prop to an asynchronous function, the function will be called with the FormKit context object as its first argument. This context object contains a page property (the current page we are attempting to load) that is tracked by the transfer list input, and hasNextPage, which is a callback function we can use to tell the transfer list that there are more options to load:\n\nRender\nHTML\nSearch\n\nThe transfer list input can also load options asynchronously when the user searches. In this example, we'll add back the searchable prop, and change getGuests() to searchGuests(). When the user searches, searchGuests() will now be called with the same context object as before, but this time, we will destructure just the search property. Additionally, we'll modify getGuests() to only return guests when a search value is provided:\n\nRender\nHTML\nOption loader\nRehydrating values\n\nThe transfer list input also provides an optionLoader prop that allows you to rehydrate values that are not in the options list. In this example, we'll provide the transfer list an initial value (a guest ID), and assign the optionLoader to a function that will make a request to the API to fetch the individual guest data:\n\nRender\nHTML\n\nNotice in the example above that the optionLoader function getGuest is passed two arguments: the value of the selected option (in this case, the movie ID) and the cachedOption. The cachedOption is used for preventing unnecessary lookups; if the cachedOption is not null it means the selected option has already been loaded, and you can return the cachedOption directly.\n\nFetching additional data\n\nYou can also use use the optionLoader to fetch additional data on selected values that is not already in the options list. In this example, after selecting an option, we are going to perform a look-up to load the selected guest's age:\n\nRender\nHTML\nSlots\n\nJust like any other FormKit input, the transfer list input allows you to utilize slots to customize its markup.\n\nSource and target options\n\nNow that we are loading additional data on selected values (the age and email address of the selected guest), let's customize the look of the selected values by using the target-option slots:\n\nRender\nHTML\nExamples\nRanked order\n\nThe transfer list input can be used to create a ranked list, let's do that with the greatest NBA players:\n\nRender\nHTML\nProps & Attributes\nProp\tType\tDefault\tDescription\ndebounce\tnumber\t200\tNumber of milliseconds to debounce calls to an options function.\noptions\tany\t[]\tThe list of options the user can select from.\nfilter\tfunction\tnull\tUsed to apply your own custom filter function for static options.\noption-loader\tfunction\tnull\tUsed for hydrating initial value, or performing an additional request to load more information of a selected option.\nsource-empty-message\tstring\tundefined\tRenders a message when there are no options to display.\ntarget-empty-message\tstring\tundefined\tRenders a message when there are no values to display\nmax\tnumber\tundefined\tLimits the number of options that can be selected.\nclear-on-select\tboolean\ttrue\tClears the search input after selecting an option (only for options that are not loaded via function).\nsearchable\tboolean\tfalse\tEnables the search input.\nsource-label\tstring\tundefined\tRenders a label for the source list.\ntarget-label\tstring\tundefined\tRenders a label for the target list.\ntransfer-on-select\tboolean\ttrue\tAutomatically transfers selected options to the target list. If set to false, will render transfer forward and transfer backward buttons.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema), or content (via slots). Read more about sections here.\n\nWrapper of transfer list\nouter\nfieldset\nlegend\nhelp\nwrapper\nsource\ntransferControls\ntarget\nmessages\nmessage\nChoose VIPs for the party\nYou can select up to 3 VIPs.\nSource list\nTransfer controls\nTarget list\nSorry, you may not add more than 3 guests.\nSource\nsource\nsourceHeader\nsourceHeaderLabel\nsourceHeaderItemCount\nsourceControls\nsourceSearch\nsourceSearchInput\nsourceSearchClear\ncloseIcon\nsourceListItems\nsourceEmptyMessage\nemptyMessageInner\nsourceListItem\nselectedIcon\nsourceOption\nsourceLoadMore\nloadMoreInner\nloaderIcon\nGuests\n97\n✕\nNo guests found\n✓\nJohn Doe\n⌛\nTransfer controls\ntransferControls\ntransferButtonForwardAll\nfastForwardIcon\ntransferButtonForward\nforwardIcon\ntransferButtonBackward\nbackwardIcon\ntransferButtonBackwardAll\ncontrolLabel\nrewindIcon\n⇥\n⇒\n⇐\n⇤\nTarget\ntarget\ntargetHeader\ntargetHeaderLabel\ntargetHeaderItemCount\ntargetListItems\ntargetEmptyMessage\nemptyMessageInner\ntargetListItem\nselectedIcon\ntargetOption\ntargetLoadMore\nloadMoreInner\nloaderIcon\nVIPs\n3\nNo VIPs selected\n✓\nJohn Doe\n⌛\nSection-key\tDescription\nfieldset\tA fieldset element that acts as the root element for the transfer list input.\nlegend\tA legend element that renders the label.\nsource\tA div element that contains the sourceHeader, sourceControls, and sourceListItems sections.\nsourceHeader\tA div element that contains the sourceHeaderLabel and sourceHeaderItemCount sections\nsourceHeaderLabel\tA label element that renders the sourceLabel prop.\nsourceHeaderItemCount\tA span element that renders the number of items and number of items selected in the source list.\nsourceControls\tA div element that contains the sourceSearchINput and sourceSearchClear sections\nsourceSearch\tA div element that contains the sourceSearchInput and sourceSearchClear sections\nsourceSearchInput\tA text input element used for searching.\nsourceSearchClear\tA button element that clears the search input.\ncloseIcon\tThe span used containing the icon for the clear search input.\nsourceListItems\tA ul element that contains the sourceListItems.\nsourceEmptyMessage\tA li element that contains the emptyMessageInner section.\nemptyMessageInner\tA span element that renders the provided empty message text.\nsourceListItem\tA li element for the sourceListItems section that contains the sourceOption section.\nselectIcon\tA span elemenet that renders the selected icon when the sourceListItem is set to selected.\nsourceOption\tA div element that renders the option label.\nsourceLoadMore\tA li element that contains the loadMoreInner section.\nloadMoreInner\tA span element that renders the loading icon.\nloaderIcon\tA span element that outputs an icon when loading is occurring.\ntransferControls\tA div element that contains the transferButtonForwardAll, transferButtonForward, transferButtonBackward, and transferButtonBackwardAll sections.\ntransferButtonForwardAll\tA button element that transfers all options to the target list.\ntransferButtonForward\tA button element that transfers selected options to the target list.\ntransferButtonBackward\tA button element that transfers selected options to the source list.\ntransferButtonBackwardAll\tA button element that transfers all options to the source list.\ncontrolLabel\tA span element that renders the control label.\nfastForwardIcon\tA span element that renders the fast forward icon.\nmoveRightIcon\tA span element that renders the move right icon.\nmoveLeftIcon\tA span element that renders the move left icon.\nrewindIcon\tA span element that renders the rewind icon.\ntarget\tA div element that contains the targetHeader, targetControls, and targetListItems sections.\ntargetHeader\tA div element that contains the targetHeaderLabel and targetHeaderItemCount sections\ntargetHeaderLabel\tA label element that renders the targetLabel prop.\ntargetHeaderItemCount\tA span element that renders the number of items and number of items selected in the target list.\ntargetListItems\tA ul element that contains the targetListItems.\ntargetEmptyMessage\tA li element that contains the emptyMessageInner section.\ntargetListItem\tA li element for the targetListItems section that contains the targetOption section.\ntargetLoadMore\tA li element that contains the loadMoreInner section.\nShow Universal section keys"
  },
  {
    "title": "Week Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/week",
    "html": "Week\nBasic example\nProps & Attributes\nSections\n\nThe week input uses the HTML's native week picker to allow users to easily select a week.\n\nBasic example\nRender\nHTML\nCOMPATIBILITY WARNING\n\nWeek inputs are not currently supported in FireFox or Safari.\n\nFORMATTING\n\nThe internal format of all native week pickers is YYYY-Www (for example: 2017-W06). This is true even though the format of the week displayed to the user may be different..\n\nProps & Attributes\n\nThe week input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmin\tNumber\t--\tView on MDN\nmax\tNumber\t--\tView on MDN\nstep\tNumber\tauto\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nInstallation week\n🗓\n2022-W42\nWhich week will work best for your patio installation?\nInstallation week is required.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "AutoAnimate ⚡️ FormKit",
    "url": "https://formkit.com/plugins/auto-animate",
    "html": "AutoAnimate Plugin\nInstallation\nExample\n\nAutoAnimate is a zero-config, drop-in animation utility that adds smooth transitions to any web app. It also works great with FormKit.\n\nFormKit doesn't need much animation, but a small tasteful amount can make it clear when elements pop on and off a page, or move around — such as validation messages.\n\nUsing AutoAnimate with FormKit\n\n1 min\n\nInstallation\n\nTo use AutoAnimate with FormKit, install @formkit/addons:\n\nyarn add @formkit/addons\n\nOnce you've installed the addons package, you'll need to register the AutoAnimate plugin with FormKit:\n\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { createAutoAnimatePlugin } from '@formkit/addons'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\n\n\ncreateApp(App).use(plugin, defaultConfig({\n\n  plugins: [\n\n    createAutoAnimatePlugin(\n\n      { \n\n        /* optional AutoAnimate config */\n\n        // default:\n\n        duration: 250,\n\n        easing: 'ease-in-out',\n\n        delay: 0,\n\n      },\n\n      { \n\n        /* optional animation targets object */\n\n        // default:\n\n        global: ['outer', 'inner'],\n\n        form: ['form'],\n\n        repeater: ['items'],\n\n      }\n\n    )\n\n  ]\n\n}).mount('#app')\n\nIf you've installed it correctly, you should have smooth transitions when showing and hiding validation messages:\n\nExample\nRender\nHTML\n\nThat's pretty much all you need to do! AutoAnimate is intended to be a zero-config drop in utility. However, if you really want to fine tune the plugin a little more, you can provide your own AutoAnimate options or plugins. Read more about this on the AutoAnimate documentation site.\n"
  },
  {
    "title": "URL Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/url",
    "html": "URL\nBasic example\nProps & Attributes\nSections\n\nThe url input uses HTML's native url input. It allows a user to enter a single URL.\n\nBasic example\nRender\nHTML\nCONSIDER USING TEXT INPUT\n\nAlthough FormKit supports the url input type, the primary reason this input is provided in the HTML spec is validation. Since FormKit has its own validation system the utility provided by this input is not significant and can complicate your form submissions. In most cases you are better off using a text input with the url validation rule.\n\nProps & Attributes\n\nThe url input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nminlength\tNumber\tnone\tView on MDN\nmaxlength\tNumber\tnone\tView on MDN\nplaceholder\tString\tnone\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nPersonal website URL\n🌎\nhttps://mywebsite.com\nTell us where to find your personal website.\nPlease include a valid url.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Toggle Buttons ⚡️ FormKit",
    "url": "https://formkit.com/inputs/togglebuttons",
    "html": "Toggle Buttons\nView pricing →\nToggle Buttons\nBehavioral props\nMultiple\nEnforced\nVertical\nStandalone Toggle\nStandalone basic example\nStandalone Toggle On/Off Values\nStandalone On/Off labels\nSlots\nToggle Button Slots\nStandalone Toggle Slots\nAccessibility\nARIA\nKeyboard\nProps & Attributes\nSections\nSingle toggle button diagram\nMultiple toggle button diagram\nPro installation quickstart 🚀\nToggle Buttons\n\nTo output multiple toggle buttons use the options prop. Options can be specified 3 ways:\n\nAn array of strings\nAn object of value/label pairs\nAn array of objects with label and value properties (the same as the select and radio inputs).\nAdditional parameters can be passed to set disabled, help, onLabel, and/or offLabel on a per option basis.\nLoad live example\nBehavioral props\nMultiple\n\nThe togglebuttons input, by default, only allows one option to be selected. You can change this behavior by setting the multiple prop which will then allow the selection of multiple options:\n\nLoad live example\nEnforced\n\nBy default togglebuttons will allow you to select and deselect allowing for an off state. With the enforced prop enabled once a user has interacted with the input, one value will always be set much like that of a radio input.\n\nLoad live example\nVertical\n\nAssuming you are using the default FormKit styles, the vertical prop applies dataset attributes and styling to stack toggle buttons in a vertical orientation.\n\nLoad live example\n\nMore prop examples and combinations:\n\nLoad live example\nStandalone Toggle\nStandalone basic example\n\nThe togglebuttons input offers choices between one or more values; it's a great option when you want the user to toggle a feature on or off, between choices or allow multiple selections.\n\nLoad live example\nStandalone Toggle On/Off Values\n\nThe values for the toggle buttons are undefined if not-interacted with, true if checked, and false if unchecked. You can change these values by passing the onValue and offValue props. In this example, we will set the onValue to the string 'active' and the offValue to the string 'inactive':\n\nLoad live example\nStandalone On/Off labels\n\nAdditionally, you may specify secondary labels by setting the on-label and the off-label props. These values are conditionally shown based on the on/off state of the toggle. The value labels render to the right of the toggle input. The \"primary label\" will be moved to input label position above the toggle when value labels are used:\n\nLoad live example\nSlots\nToggle Button Slots\n\nFor multiple options you can use the default slot to set the toggle's content.\n\nLoad live example\nStandalone Toggle Slots\n\nFor a single toggle you can use the default slot for setting the toggle content. Also available are on and off slots to change the content based on whether the toggle is activated or not.\n\nLoad live example\nAccessibility\nARIA\nThe field's containing unordered list of options has role=\"group\".\nEach option element's button has aria-pressed=\"<bool>\" according to the button state and aria-label is provided by the option's label\nKeyboard\n\nToggle buttons are in DOM order and can navigated with the tab key. The button behavior follows standard keyboard semantics.\n\nProps & Attributes\nProp\tType\tDefault\tDescription\noff-value\tany\tfalse\tThe value when the toggle is unchecked.\nFor use with standalone toggle buttons only.\non-value\tany\ttrue\tThe value when the toggle is checked.\nFor use with standalone toggle buttons only.\noff-label\tString\tundefined\tThe text of the button label when the toggle is unchecked.\nFor use with standalone toggle buttons only.\non-label\tString\tundefined\tThe text of the button label when the toggle is checked.\nFor use with standalone toggle buttons only.\noptions\tArray/Object\t[]\tAn object of value/label pairs or an array of strings, or an array of objects that must contain a label and value property. Additional props include: disabled, help, onLabel and offLabel\nmultiple\tBoolean\tfalse\tAllows for selecting multiple options.\nFor use with multiple toggle buttons only.\nenforced\tBoolean\tfalse\tMakes sure at least one selection remains selected once field is activated.\nFor use with multiple toggle buttons only.\nvertical\tBoolean\tfalse\tApplies data attributes and styling to stack toggle buttons in a vertical orientation.\nFor use with multiple toggle buttons only.\nShow Universal props\nSections\n\nThe toggle buttons input has a different construction depending on if it's a single or multiple configuration.\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nSingle toggle button diagram\nToggle Button Text Here\nAdd some help text about this toggle\nValidation message would be here\nMultiple toggle button diagram\nToggle Button Text Here\nAdd some help text about this toggle\nValidation message would be here\nSection-key\tDescription\nsingleToggle\tButton wrapper for the single toggle button\nmultiToggle\tButton wrapper for a toggle button when multiple toggle buttons exist\ninputInner\tButton inner text for a toggle button\noption\tResponsible for the wrapper around each item in the options.\noptions\tResponsible for the wrapper element around all of the option items.\nShow Universal section keys"
  },
  {
    "title": "Toggle Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/toggle",
    "html": "Toggle\nView pricing →\nBasic example\nValues\nLabels\nPrimary label\nAlt label position\nValue label\nInner value labels\nIcons\nColors\nAccessibility\nProps & Attributes\nSections\nPro installation quickstart 🚀\nBasic example\n\nThe toggle input — sometimes called a \"switch\" — offers a choice between one of two values; it's a great option when you want the user to toggle a feature on or off:\n\nLoad live example\nValues\n\nThe values for the toggle are undefined if not-interacted with, true if checked, and false if unchecked. You can change these values by passing the onValue and offValue props. In this example, we will set the onValue to the string 'active' and the offValue to the string 'inactive':\n\nLoad live example\nLabels\nPrimary label\n\nBy default, the toggle input supports a primary label like the label prop on any other FormKit input. The primary label is displayed to the right of the toggle unless you use a Value label, which will then move it above the toggle:\n\nLoad live example\nAlt label position\n\nIf you would like the label to be displayed above the toggle, you can use the alt-label-position prop:\n\nLoad live example\nValue label\n\nAdditionally, you may specify secondary labels by setting the on-value-label and the off-value-label props. These values are conditionally shown based on the on/off state of the toggle. The value labels render to the right of the toggle input. The \"primary label\" will be moved to the alternative label position above the toggle when value labels are used:\n\nLoad live example\nInner value labels\n\nAdditionally, you can set the value-label-display prop to inner to render the value labels inside the toggle. The Primary label will return to being displayed to the right of the toggle:\n\nLoad live example\nIcons\n\nThe thumb-icon prop allows you to insert an icon into the thumb section of the toggle input. This prop accepts a string that's passed to FormKit's icon plugin:\n\nLoad live example\nColors\n\nThe toggle input supports color props for its various sections for easy styling. Each prop contains on and off states that are applied depending on whether the toggle is on or off. The following example uses some of these color props. See the Props & Attributes section below for a full list of these props:\n\nLoad live example\nAccessibility\n\nThe toggle input is built atop HTML's native checkbox input.\n\nProps & Attributes\nProp\tType\tDefault\tDescription\nalt-label-position\tBoolean\tundefined\tMoves the label above the toggle.\noff-value\tany\tfalse\tThe value when the toggle is unchecked.\non-value\tany\ttrue\tThe value when the toggle is checked.\noff-value-label\tString\tundefined\tThe text of the Value label when the toggle is unchecked.\non-value-label\tString\tundefined\tThe text of the Value label when the toggle is checked.\nvalue-label-display\tString\tundefined\tThe `on` and `off` value labels will always default to being displayed outside and to the right of the toggle. Other accepted values include `inner` to set the value labels inside of the toggle, and `hidden` which hides the value labels.\nvalue-label-color-off\tString\tundefined\tUsed to set the color of the value label when the toggle is unchecked.\nvalue-label-color-on\tString\tundefined\tUsed to set the color of the value label when the toggle is checked.\nthumb-icon\tString\tundefined\tThis prop is used to set the icon that will be placed inside the thumb section.\nthumb-color-off\tString\tundefined\tSets the background color of the thumb section when the toggle is unchecked.\nthumb-color-on\tString\tundefined\tSets the background color of the thumb section when the toggle is checked.\nicon-color-off\tString\tundefined\tThe color the icon should be set to when `toggle-icon` prop is set and the toggle is unchecked.\nicon-color-on\tString\tundefined\tThe color the icon should be set to when `toggle-icon` prop is set and the toggle is checked.\ntrack-color-off\tString\tundefined\tSets the background color of the `track` section when the toggle is unchecked.\ntrack-color-on\tString\tundefined\tSets the background color of the `track` section when toggle is checked.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\n⚫️\nSound effects\nTurn sound effects on and off.\nSomething wrong happened.\nSection-key\tDescription\ntrack\tThe track section is the background of the toggle (the area that the thumb slides on).\nthumb\tThe thumb section is the element that slides on the track.\nthumbIcon\tThe thumbIcon section is the icon that is rendered inside the thumb section (when thumb-icon prop is set).\nvalueLabel\tAn additional label element, rendered when value-label props are used. Displayed to the right of the toggle.\naltLabel\tA label element for the label. This label is rendered when value-label props are being used.\ninnerLabel\tA label element used when value-label props are provided and value-label-display is set to inner.\nShow Universal section keys"
  },
  {
    "title": "Time Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/time",
    "html": "Time\nBasic example\nProps & Attributes\nSections\n\nThe time input uses HTML's native time input. It allows a user to enter a single line of time.\n\nBasic example\nLoad live example\nFORMATTING\n\nThe internal format of all native time pickers is HH:MM. This is true even though the format of the time displayed to the user may be 12 hour or 24 hour.\n\nProps & Attributes\n\nThe time input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmax\tNumber\t--\tView on MDN\nmin\tNumber\t--\tView on MDN\nstep\tNumber\tauto\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nPreferred delivery time\n⏱\n10:00\n👌\nActual delivery time will be your preferred time +- 30 minutes.\nPreferred delivery time is required.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Tel (Telephone) Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/tel",
    "html": "Telephone\nAn example\nProps & Attributes\nSections\n\nThe tel input uses HTML's native tel input and allows a user to enter a telephone number. Telephone numbers can also be entered with standard text inputs but some browsers (especially mobile ones) may improve the experience of entering telephone numbers by showing a different keypad.\n\nPRO ALTERNATIVE\n\nNeed more flexibility than the native HTML tel input provides? Check out the mask input available in FormKit Pro.\n\nAn example\nRender\nHTML\nPHONE NUMBER VALIDATION\n\nPhone number formats vary greatly around the world (some localities even include letters in their phone numbers!) — be cautious validating phone numbers unless you know your audience is exclusively from a given location.\n\nProps & Attributes\n\nThe tel input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmaxlength\tNumber\tnone\tView on MDN\nminlength\tNumber\tnone\tView on MDN\nplaceholder\tString\tnone\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nPhone number\n📞\n444-555-6666\nEnter your phone number using the xxx-xxx-xxxx format.\nPhone number must be of the xxx-xxx-xxxx format.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Textarea Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/textarea",
    "html": "Textarea\nBasic example\nProps & Attributes\nSections\n\nThe textarea input uses HTML's native textarea input. It allows a user to enter multiple lines of text and is resizable in most browsers.\n\nBasic example\nLoad live example\nProps & Attributes\n\nThe textarea input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\ncols\tNumber\t20\tView on MDN\nmaxlength\tNumber\tnone\tView on MDN\nminlength\tNumber\tnone\tView on MDN\nplaceholder\tString\tnone\tView on MDN\nrows\tNumber\tnone\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nBrief biography\n📕\nThe year was 1982. The season was Autumn. My parents were living in Peru at the time...\nTell us a little about yourself.\nBrief biography must be between 300 and 500 characters.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Text Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/text",
    "html": "Text\nBasic example\nCast to number\nProps & Attributes\nSections\n\nThe text input uses HTML's native text input. It allows a user to enter a single line of text.\n\nBasic example\nLoad live example\nCast to number\n\nBy default all native HTML <input> elements return a string value. The number prop allows you to cast the value to a true number type. There are two valid values for the number prop: float and integer.\n\nThese options use parseFloat (default) or parseInt respectively. If the value cannot be parsed by the respective function it will fall back to using the string value. Applying the number prop will expand the value of the input to be number | string | undefined in TypeScript.\n\nLoad live example\nProps & Attributes\n\nThe text input has only one unique prop, number, which can be used to cast the value of the input to a number type. Additionally, the native HTML text input has a few attributes that can be used to control the input.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmaxlength\tNumber\tnone\tView on MDN\nminlength\tNumber\tnone\tView on MDN\nplaceholder\tString\tnone\tView on MDN\nProps\nnumber\tString\tfloat\tSpecifies how to cast a value to a number. Valid values are float and integer.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nFirst name\n👩🏽‍💼\nSunita\nEnter your first name only.\nFirst name is required.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Submit Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/submit",
    "html": "Submit\nBasic Example\nDefault slot\nEvent listeners\nProvided submit button\nDisable your submit while the form is disabled\nIgnored input\nProps & Attributes\nSections\n\nThe submit input uses HTML's native button element. The label prop is used to populate the text of the button — or alternatively you can use the default slot.\n\nBUTTON ELEMENT\n\nType submit input uses a button element instead of an input=type\"submit\" because an input is a void element. As a container element, a button can include content and pseudo elements — making them the more flexible option for developers.\n\nBasic Example\n\nThe easiest way to set the label of a submit button is with the label prop:\n\nLoad live example\nDefault slot\n\nThe default slot can also be used to add text and UI to the button:\n\nLoad live example\nEvent listeners\n\nYou can also bind event listeners:\n\nLoad live example\nProvided submit button\n\nNote that FormKit forms automatically output a submit button. You can opt out of the built-in submit button and use your own, but will need to re-implement features such as the loading spinner (provided by the Genesis theme) or automatic disabling of the button while the form is submitting.\n\nDisable your submit while the form is disabled\n\nIf you use your own submit button, you can dynamically disable it according to the form's disabled status (context.disabled), which you can pull from the #default slot prop:\n\n<FormKit\n\n  type=\"form\"\n\n  :actions=\"false\"\n\n  #default=\"{ disabled }\"\n\n  @submit=\"yourSubmitHandler\"\n\n>\n\n  <FormKit type=\"submit\" :disabled=\"disabled\" />\n\n</FormKit>\n\nYou can also disable your own submit button via schema.\n\nIgnored input\n\nsubmit and button input types have a few unique behaviors because they are \"ignored inputs\" by default — meaning they have their ignoreprop set to true:\n\nPlugins are not inherited - Ignored inputs do not inherit plugins from ancestors.\nTheir values are not included in parent forms - Ignored inputs do not contribute their value to any wrapping groups or forms for submission.\nValidation does not run - Ignored inputs do not run validation.\n\nIf you need plugins to be inherited or validation to run on a buttonor submit, you can change :ignoreto false:\n\n<FormKit type=\"button\" :ignore=\"false\"> Add a section </FormKit>\nProps & Attributes\n\nThe submit input (along with button) is unique in that it does not actively receive input other than a transient click. However, nearly all of the base input props still technically exist on the input.\n\nProp\tType\tDefault\tDescription\nconfig\tObject\t{}\tConfiguration options to provide to the input’s node and any descendent node of this input.\ndelay\tNumber\t20\tNumber of milliseconds to debounce an input’s value before the commit hook is dispatched.\ndirtyBehavior\tstring\ttouched\tDetermines how the \"dirty\" flag of this input is set. Can be set to touched or compare — touched (the default) is more performant, but will not detect when the form is once again matching its initial state.\nerrors\tArray\t[]\tArray of strings to show as error messages on this field.\nhelp\tString\t''\tText for help text associated with the input.\nid\tString\tinput_{n}\tThe unique id of the input. Providing an id also allows the input’s node to be globally accessed.\nignore\tBoolean\tfalse\tPrevents an input from being included in any parent (group, list, form etc). Useful when using inputs for UI instead of actual values.\nindex\tNumber\tundefined\tAllows an input to be inserted at the given index if the parent is a list. If the input’s value is undefined, it inherits the value from that index position. If it has a value it inserts it into the lists’s values at the given index.\nlabel\tString\t''\tText for the label element associated with the input.\nname\tString\tinput_{n}\tThe name of the input as identified in the data object. This should be unique within a group of fields.\nparent\tFormKitNode\tcontextual\tBy default the parent is a wrapping group, list or form — but this props allows explicit assignment of the parent node.\nprefix-icon\tString\t''\tSpecifies an icon to put in the prefixIcon section.\npreserve\tboolean\tfalse\tPreserves the value of the input on a parent group, list, or form when the input unmounts.\npreserve-errors\tboolean\tfalse\tBy default errors set on inputs using setErrors are automatically cleared on input, setting this prop to true maintains the error until it is explicitly cleared.\nsections-schema\tObject\t{}\tAn object of section keys and schema partial values, where each schema partial is applied to the respective section.\nsuffix-icon\tString\t''\tSpecifies an icon to put in the suffixIcon section.\ntype\tString\ttext\tThe type of input to render from the library.\nvalidation\tString, Array\t[]\tThe validation rules to be applied to the input.\nvalidation-visibility\tString\tblur\tDetermines when to show an input's failing validation rules. Valid values are blur, dirty, and live.\nvalidation-label\tString\t{label prop}\tDetermines what label to use in validation error messages, by default it uses the label prop if available, otherwise it uses the name prop.\nvalidation-rules\tObject\t{}\tAdditional custom validation rules to make available to the validation prop.\nvalue\tAny\tundefined\tSeeds the initial value of an input and/or its children. Not reactive. Can seed entire groups (forms) and lists..\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nYou were too slow. Try again.\n🧑‍🦰\nCreate profile\n🚀\nQuick double tap to submit.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Taglist Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/taglist",
    "html": "Taglist\nView pricing →\nBasic example\nFiltering\nAllow new values\nDynamic options\nSearch parameter\nPage and hasNextPage parameters\nLoading Style\nOption loader\nLoading Style\nLoad on created\nTag appearance\nBehavioral props\nEmpty message\nMax\nClose on select\nReload on commit\nOpen on click\nOpen on focus\nOpen on remove\nFull example\nProps & Attributes\nPro installation quickstart 🚀\n\nThe taglist input allows users to search through a list of options and apply any number of tags. Users can also drag and drop tags to re-order:\n\nThe options prop can accept three different formats of values:\n\nAn array of objects with value and label keys (see example above)\nAn array of strings ['A', 'B', 'C']\nAn object literal with key-value pairs { a: 'A', b: 'B', c: 'C' }\nA function that returns any of the above\nEMPTY OPTIONS\n\nIf you assign options as an empty array, the input will be rendered in a disabled state.\n\nBasic example\n\nThe taglist input allows users to search through a list of options and apply any number of tags. Users can also drag and drop tags to re-order:\n\nLoad live example\nFiltering\n\nThe taglist input will filter options with its own internal search function. You can replace this search function by providing the filter prop a function of your own. Your function will receive two arguments, the option being iterated over and the current search value:\n\nLoad live example\nAllow new values\n\nThe taglist input, unlike the dropdown or autocomplete inputs, allows you to enter an arbitrary value (a value not in the list of options). This is useful for creating new tags on the fly. To enable this feature, set the allow-new-values prop to true.\n\nLoad live example\nDynamic options\n\nInstead of passing a static list to the options prop, you can assign it to a function. Doing so is useful when you need to load options from an API or another source.\n\nSearch parameter\n\nIn this example, we'll assign the options prop the searchMovies function. By doing so, searchMovies will receive the context object as an argument. Within this context object is the search property, which is the current search value. To perform our search, we'll use the search value as the query parameter for our API request:\n\nLoad live example\nPage and hasNextPage parameters\n\nA likely scenario you'll encounter is needing to search through a paginated API. This can be done by referencing the same context object as before. Within this object, we can utilize the page and hasNextPage properties. The page property is the current page number, and the hasNextPage property is a function to be called when there are more pages to load:\n\nLoad live example\nLoading Style\n\nInstead of requiring your users to click the Load more button to load additional options, you can set the loadOnScroll prop to true, which will paginate options as you scroll to the bottom of the options list.\n\nOption loader\nRehydrating values\n\nFormKit's taglist input also provides an optionLoader prop that allows you to rehydrate values that are not in the options list. In this example, we'll provide the taglist an initial value (a movie ID), and assign the optionLoader to a function that will make a request to the API to get the movie:\n\nLoad live example\n\nNotice in the example above that the optionLoader function is passed two arguments: the value of the selected option (in this case, the movie ID) and the cachedOption. The cachedOption is used for preventing unnecessary lookups. If the cachedOption is not null it means that the selected option has already been loaded, and you can return the cachedOption directly.\n\nLoading Style\n\nInstead of requiring your users to click the Load more button to load additional options, you can set the loadOnScroll prop to true, which will paginate options as you scroll to the bottom of the options list.\n\nLoad on created\n\nIf you would rather load options when the taglist is created, you can set the load-on-created prop to true, and our function, loadCurrentlyPopularMovies will be called without the user needing to expand the listbox:\n\nLoad live example\nTag appearance\n\nJust like the taglist input or Autocomplete input, the taglist input allows you to utilize slots to customize the look and feel of the options list and the selected option by leveraging the renderless component pattern.\n\nIn this example, we are going to use the tag slot to customize the look of the tags:\n\nLoad live example\nBehavioral props\nEmpty message\n\nThe taglist input, by default, will not expand the listbox when no search results are found while filtering. You can change this behavior by assigning the empty-message prop a message to display when no results are found:\n\nLoad live example\nMax\n\nThe max prop allows you to limit the number of options that can be selected. When the max limit is reached, the taglist input will disable the listbox:\n\nLoad live example\nClose on select\n\nIf you would like the taglist's listbox to remain open in between selections, set the close-on-select prop to false:\n\nLoad live example\nReload on commit\n\nIf you want the options to be reloaded (with static options, this would filter the options with the value of empty string, and with dynamic options, this would make a request to the options loader with the value of empty string) when the user commits a selection, use the reload-on-commit prop:\n\nLoad live example\nOpen on click\n\nTo enable opening the taglist's listbox on click of its search input, set the open-on-click prop to true:\n\nLoad live example\nOpen on focus\n\nIf you would like to open the taglist's listbox anytime its search input is focused, set the open-on-focus prop to true:\n\nLoad live example\nOPEN ON FOCUS VS OPEN ON CLICK\n\nOpen on focus encompasses open on click.\n\nOpen on remove\n\nIf you want the listbox to expand when an selection is removed, use the open-on-remove prop:\n\nLoad live example\nFull example\n\nNow let's combine what we've learned so far by leveraging the tag slot for custom markup, and setting the options prop to a function that will return pages of movies from an API:\n\nLoad live example\nProps & Attributes\nProp\tType\tDefault\tDescription\ndebounce\tnumber\t200\tNumber of milliseconds to debounce calls to an options function.\noptions\tany\t[]\tThe list of options the user can select from.\nload-on-scroll\tboolean\tfalse\tWhen set to `true`, the taglist will try loading more options based on the end-user`s scroll position\nopen-on-click\tboolean\tfalse\tThe autocomplete is expanded upon focus of the input, as opposed to waiting to expand until a search value is entered.\nfilter\tfunction\tnull\tUsed to apply your own custom filter function for static options.\noption-loader\tfunction\tnull\tUsed for hydrating initial value, or performing an additional request to load more information of a selected option.\nallow-new-values\tboolean\tfalse\tAllows end-user to enter a new value that does not exist within the options list.\ndisable-drag-and-drop\tboolean\ttrue\tDisabled end-user from sorting tags by dragging and dropping.\nempty-message\tstring\tundefined\tRenders a message when there are no options to display.\nmax\tnumber\tundefined\tLimits the number of options that can be selected.\nclose-on-select\tboolean\ttrue\tCloses the listbox when an option is selected.\nopen-on-remove\tboolean\tfalse\tWhen the `selection-removable` prop is set to `true`, the taglist will not open after the selected value is removed. You can change this behavior by setting the `open-on-remove` prop to `true`.\nopen-on-focus\tboolean\tfalse\noptions-appearance\tstring\tundefined\tFor multi-select taglists, this prop allows you to customize the look and feel of the selected options. Possible values are `default` (the default) or `checkbox`.\nalways-load-on-open\tboolean\ttrue\tDetermines whether the taglist should always load its options when opened or whether it should reference the options that were previously found when opening.\nload-on-created\tboolean\tfalse\tWhen set to `true`, the taglist will load the options when the node is created.\nShow Universal props\nSection-key\tDescription\nselector\tThe selector section is a button element that opens the taglist options list.\nselections\tContains individual selection sections.\nselection\tContains the selected option.\nlistitem\tA list item element that contains the option section.\noption\tA div that contains the option content.\nlistbox\tThe listbox section is a ul element that contains the options list.\ntaglistWrapper\tWraps the listbox section. A div that handles scrolling the listbox.\noptionLoading\tA span element that is conditionally rendered within the selected option when loading is occurring.\nloaderIcon\tAn element for outputting an icon in the selector element when loading is occurring.\nselectIcon\tAn element for outputting an icon in the selector element when the taglist is closed.\nloadMore\tA list item element that is conditionally rendered at the bottom of the options list when there are more pages to load.\nloadMoreInner\tA span element that acts as a wrapper for the loaderIcon within the loadMore section.\nremoveSelection\tA button element used for removing a specific selection.\ncloseIcon\tAn element for outputting an icon within the removeSelection button.\nlistboxButton\tA button element that is used to open the taglist.\nemptyMessage\tA list item element that is conditionally rendered when there are no options to display.\nemptyMessageInner\tA span element that acts as a wrapper for the emptyMessage section.\nShow Universal section keys"
  },
  {
    "title": "Slider Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/slider",
    "html": "Slider\nView pricing →\nIntroduction\nBasic example\nNative props\nKeyboard modifier keys\nKeyboard number entry\nMulti-value\nCustomizing handles\nCustomizing tooltips\nTooltip visibility\nTooltip formating\nLinked number inputs\nLinked input attributes\nMarks\nBasic usage\nWith labels\nCustom marks\nSnap to marks\nStyling marks\nScaling slider values\nUsing functions\nUsing Intervals\nChart\nFull-featured example\nProps & Attributes\nSections\nPro installation quickstart 🚀\nIntroduction\n\nThe slider input is an advanced and highly configurable version of the native HTML range input. Some notable additions compared to the standard range input are:\n\nSupport for multi-value inputs.\nDisplay tooltips to show selected values.\nShow linked inputs for min and max values.\nRender tick marks for value steps.\nAdd arbitrary tick marks.\nForce selection to snap to tick marks.\nRender bar chart data linked to selection values.\nSlider Overview\n\n7 mins\n\nBasic example\nLoad live example\nNative props\n\nif you're familar with using the native HTML range input you'll find than many of the existing props you're familiar with work as expected with the slider input.\n\nLoad live example\nKeyboard modifier keys\n\nEven in its simplest form the slider input has a few tricks up its sleeve. Just like the native range input you can use your arrow keys to adjust the input value when it is focused — but with the slider input you can hold the shift key to increment by 10x and your system's modifer key (command or ctrl) to jump to the min / max values.\n\nKeyboard number entry\n\nWhenever you have a handle focused on a slider input you can type a value on your keyboard and after a slight debounce your slider handle will be set to the value you provided — or the closest available match.\n\nMulti-value\n\nTo render two value handles on a slider input supply an array as the input's value. Control handles can be dragged through each other and your resulting array value will always be returned sorted in order from smallest to largest.\n\nLoad live example\nCustomizing handles\n\nUsing the maxHandleInner (default) and minHandleInner slots you can customize the appearance of your slider handles. The maxHandleInner slot is used for single-value slider inputs.\n\nLoad live example\nCustomizing tooltips\nTooltip visibility\n\nBy default slider tooltips show on hover and when a selection handle is being dragged. You can force tooltips into an on or off state by using the tooltip prop and providing a boolean value.\n\nLoad live example\nTooltip formating\n\nBy providing a function to the tooltip-format prop you can customize the value of your slider tooltip. Your tooltip-format function will be provided two arguments:\n\nvalue: The current value that would be displayed in the tooltip by default. handle: The current handle being affected by the funciton. Either min or max.\n\nLoad live example\n\nBy using the tooltip-format prop you can introduce variety to your slider inputs — especially when combined with FormKit's section-key class prop system.\n\nLoad live example\nLinked number inputs\n\nSometimes a range-style input is more useful for users if they're also able to directly enter numeric values in linked fields. You can reveal number inputs that are bound to the values of the slider range handles by setting the show-input prop to true.\n\nLoad live example\nLinked input attributes\n\nThe linked number inputs are FormKit inputs. You can apply props to them using the provided props:\n\ninput-attrs: will bind your provided object to both the min and max inputs.\nmin-input-attrs: Object to bind to the linked min input.\nmax-input-attrs: Object to bind to the linked max input.\nLoad live example\nMarks\nBasic usage\n\nThe slider input supports the rendering of marks on the input's track. By setting the marks property to true marks will be rendered at every steps interval.\n\nLoad live example\nWith labels\n\nYou can enable labels for your marks by setting the mark-labels prop to true.\n\nLoad live example\nCustom marks\n\nBy supplying an array of objects to the marks prop instead of a boolean you can place arbirtary marks on the slider's track. Mark objects shold have the folloing properties:\n\nat: The position (value) on the track where the mark should render.\nlabel: The label to render for the mark if the mark-labels prop is enabled.\nclass: A string of classes to apply to the mark element.\nlabelClasses: A string of classes to apply to the mark label element.\nLoad live example\nSnap to marks\n\nWhen supplying custom marks you may want to force the selection to snap to the provided marks. This can be achieved with the snap-to-marks prop. When snap-to-marks is true keyboard events will jump to the next closest mark and entered values through keyboard or linked inputs will snap to the nearest available mark.\n\nLoad live example\nStyling marks\n\nYou can apply custom classes to your marks and mark labels by using the class and labelClasses properties on your mark objects.\n\nLoad live example\nScaling slider values\n\nBy default the slider input scales values linearly across its entire range. However, you can use the provided scaling-function or intervals props to change this behavior.\n\nUsing functions\n\nThe scaling-function prop accepts 3 values:\n\nThe string linear — this is the default behavior\nThe string log which will apply a logarithmic scaling function to your slider\nAn object which consits of two functions named forward and reverse which will apply your own scaling logic.\nLoad live example\nUsing Intervals\n\nThe intervals prop accepts an array of object where each object defines an interval range on the slider. Each obect contains:\n\nvalue: The point on the slider at which the interval begins\nstep: The step size that should be used within the interval\n\nYour last interval will cover the range extending from your specified value to the max prop value on your slider. If your lowest interval does not begin at the minimum possible value of your slider then an interval covering the range from your min slider prop to your first interval will be created for you. Its step value will be the value of the step prop on your slider input.\n\nIt's important to note that the visual representation of intervals on a slider track is based on the total number of possible steps within a given interval and not the interval's raw numeric value.\n\nLoad live example\nChart\n\nYou can render a bar chart above the slider with arbitrary values by suppling an array to the chart prop. The chart array has a similar structure to the marks array. Each nested object should contain:\n\nat: The position (value) on the track where the bar for the chart should render.\nvalue: A numeric value that will be used to calculate the relative height of the bar in the chart.\n\nThe slider input will iterate over you chart array and determine the largest value contained in the array, and then divide all other values by that largest value to determine the relative heights for rendering the bars of the chart.\n\nLoad live example\nFull-featured example\n\nBy combining the provided props for the slider component you can create a robust input to cover a variety of usecases. Here is an example for a price-range slider.\n\nLoad live example\nProps & Attributes\nProp\tType\tDefault\tDescription\nchart\tarray\tnone\tAn array of objects containing at and value keys. Renders a relative-height bar-chart above the slider track.\ninput-attrs\tobject\t{}\tApplies custom attributes to the nested linked FormKit inputs for both min and max values.\nintervals\tarray\tnone\tAn array of interval values consisting of value and step used to define differing scaling for different sections of a slider track.\nmarks\tboolean || array\tfalse\tWhen true, renders marks on the track at every step value. When an Array of objects with at and label keys, renders a mark on the track at every object's at value.\nmark-labels\tboolean\tfalse\tEnables rendering of labels belowe marks on track\nmax\tnumber\t100\tThe maximum possible value of the slider range.\nmax-input-attrs\tobject\t{}\tApplies custom attributes to the nested linked FormKit input for the max value.\nmin\tnumber\t0\tThe minimum possible value of the slider range.\nmin-input-attrs\tobject\t{}\tApplies custom attributes to the nested linked FormKit input for the min value.\nprefix\tstring\tnone\tCharacters that will always appear at the beginning of the input.\nscaling-function\tstring || object\tlinear\tDefines scaling behavior for values on the rendered slider track using either a preset value string or a set of custom functions.\nshow-input\tboolean\tfalse\tRenders FormKit type=\"number\" input(s) that are linked to the slider's value(s)\nsnap-to-marks\tboolean\tfalse\tWhen enabled, forces user selection to snap to marks\nstep\tnumber\t1\tThe minimum value at which the slider value can increment / decrement.\nsuffix\tstring\tnone\tCharacters that will always appear at the end of the input.\ntooltip\tboolean\tnone\tWhen set with a boolean value, forces the display of the slider's handle tooltip(s).\ntooltip-format\tfunction\tnone\tA function that is provided the value and handle for each slider handle which should return a string.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nChoose your price range\nSelect available locations by price\n📊\n...\n⚪\n⚪\nYou must provide a rating.\nSection-key\tDescription\nchart\tA container for the chart bar elements.\nchartBar\tAn individual bar for the chart element.\nfill\tThe fill for the selected range on the slider input.\nhandleMax\tThe maximum value selection handle. This is the default handle for single-value slider inputs.\nhandleMin\tThe minimum value selection handle.\nhandles\tA container for the track selection handles\nlinkedValues\tA wrapper for the linked inputs for the slider’s minimum and maximum values.\nmark\tAn individual mark on the track.\nmarkLabel\tThe label for an individual mark on the track.\nmarks\tA container for all of the marks on the track\nmaxValue\tThe linked FormKit number input for the slider’s maximum value. If the slider only has a single value this is rendered as a direct descendant of the sliderInner section.\nminValue\tThe linked FormKit number input for the slider’s minimum value.\nsliderInner\tThe interior div that contains the slider input content.\ntrack\tA wrapper that contains all of the track markup for the slider input.\ntrackInner\tAn interior wrapper for styling purposes that contains all of the track markup excluding the chart.\ntrackWrapper\tA wrapper that contains all of the track markup excluding the chart.\ntooltipMin\tThe tooltip for the minimum value selection handle\ntooltipMax\tThe tooltip for the maximum value selection handle\nShow Universal section keys"
  },
  {
    "title": "Select Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/select",
    "html": "Select\nSingle selection\nArray of strings\nValue / Label object\nArray of objects\nOption groups (optgroup)\nDefault slot\nMultiple\nProps & Attributes\nSections\n\nThe select input uses HTML's native select input. Select inputs can be single value selections, or multi-value selections by using the multiple attribute. There are 4 ways to provide options to a select input:\n\nAn array of strings\nAn object of value/label pairs\nAn array of objects with label and value properties (the same as the checkbox and radio inputs)\nUsing <option> tags directly inside the default slot.\nPRO ALTERNATIVE\n\nNeed more flexibility than the native HTML select input provides? Check out the dropdown input available in FormKit Pro.\n\nSingle selection\n\nSelect lists are most commonly used to select a single item from a list of options.\n\nArray of strings\n\nThe simplest way to provide options is an array of strings. The provided strings will be used for both the label and the value of the option.\n\nLoad live example\nValue / Label object\n\nYou may also provide the options prop where the keys are values and the values of each property are labels.\n\nLoad live example\nArray of objects\n\nThe most flexible way to define options is by providing an array of objects. The objects must include value and label properties — but may also include a help property as well as an attrs object of additional attributes to apply to each select input tag.\n\nLoad live example\nOPTION ATTRIBUTES\n\nTo pass additional attributes to each <option> element, your object can also contain an attrs property.\n\n\n\n[\n\n  {\n\n    label: 'My Label',\n\n    value: 'a-value',\n\n    attrs: {\n\n      disabled: true\n\n    }\n\n  }\n\n]\nOption groups (optgroup)\n\nUsing the array of objects syntax you can also create option groups (<optgroup> in HTML). To do so provide a group option:\n\nLoad live example\nDefault slot\n\nSometimes it may be desirable to manually output the contents of a select list in order to create specialized structures. This can be done by using the default slot to explicitly output your options.\n\nLoad live example\nWARNING\n\nWhen using the default slot to output options, you should not use the placeholder or options props.\n\nMultiple\n\nThe select input also supports a multiple attribute that allows for multi-selection. When used with FormKit, this option produces an array of values.\n\nLoad live example\nALTERNATIVES\n\nSelect inputs with the multiple attribute can be challenging for some users because they require holding-down the control or command keys to perform multiple selections. Depending on your audience, you may want to consider using a checkbox input with options instead.\n\nMULTIPLE WITH DEFAULT SLOT\n\nWhen using the default slot in conjunction with the multiple attribute you must explicitly assign the selected attribute to each option.\n\nProps & Attributes\nProp\tType\tDefault\tDescription\noptions\tArray/Object\t[]\tAn object of value/label pairs or an array of strings, or an array of objects that must contain a label and value property.\nplaceholder\tString\tnone\tWhen defined, FormKit injects a non-selectable hidden option tag as the first value of the list to serve as a placeholder.\nselect-icon\tString\t’’\tSpecifies an icon to put in the selectIcon section. Defaults to the select icon.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nSmoothie size\n👩🏼‍🦱\nMedium\n⌄\nChoose a smoothie size.\nYou must make a selection.\nSection-key\tDescription\noption\tResponsible for rendering each option. Context includes an option property with the option being rendered. This object includes label and value properties.\nselectIcon\tAn element for outputting an icon for opening the select list. Usually a down arrow.\nShow Universal section keys"
  },
  {
    "title": "Search Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/search",
    "html": "Search\nBasic example\nProps & Attributes\nSections\n\nThe search input uses HTML's native search input. Generally, search inputs are the same as text inputs, but may have different styling or features based on the browser. For example, browsers often add a small \"X\" to clear the input when it has a value.\n\nBasic example\nLoad live example\nProps & Attributes\n\nThe search input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmaxlength\tNumber\tnone\tView on MDN\nminlength\tNumber\tnone\tView on MDN\nplaceholder\tString\tnone\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nSearch everything\n🔍\nBest climate for tomatoes\n→\nEnter search term and press enter to search.\nPlease enter a search term.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Repeater Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/repeater",
    "html": "Repeater\nView pricing →\nBasic example\nSchema example\nAdd button attrs\nMin/max\nEmpty state\nControls\nCustom controls\nSetting errors\nProps & Attributes\nSections\nPro installation quickstart 🚀\nBasic example\n\nThe repeater input is for repeating groups of inputs. You can use any number of FormKit inputs within a repeater, and repeaters themselves can be infinitely nested.\n\nBy default, the repeater input has the ability to shift, add, and remove items:\n\nLoad live example\n\nUnlike most other FormKit input types, the repeater input is of type list. You can see above that the users property (our repeater's value) is an array.\n\nSchema example\n\nLike all other FormKit inputs, the Repeater is able to be used in a form written in FormKit schema.\n\nLoad live example\nAdd button attrs\n\nIn the previous example, the 'Add Users' button is provided by default, and the button label is derived from the repeater's label. We're able to customize the label by using the add-button prop and setting it to a string, or remove it completely by setting it to false. Alternatively, similar to the submit-attrs prop on the FormKit's forms, we can provide an object of attributes to be applied to the button with add-attrs. In this example, we change the label of the repeater from Add Users to My custom label using the add-label prop:\n\nLoad live example\nMin/max\n\nLike many other FormKit inputs, the repeater comes with a min and max prop. You can use these props to limit the number of items to be added or removed.\n\nLoad live example\nEmpty state\n\nWhen a repeater is allowed to be empty by having its min prop set to 0 and having no values, you can control the content rendered in the empty state using the empty slot.\n\nLoad live example\nControls\n\nThe repeater input by default comes with a set of controls that allow you to shift, add, and remove items. You can control the visibility of these controls by setting the upControl, downControl, insertControl, and removeControl props to true or false.\n\nLoad live example\nCustom controls\n\nWith FormKit's repeater, you are not restricted to our default controls. You can manipulate the repeater in anyway you want:\n\nLoad live example\nSetting errors\n\nYou can set errors on a repeater or any repeatable item using dot notation. Here we are using the setErrors helper, but there are other methods as well:\n\n// the 2nd argument of setErrors is input-level errors\n\nformNode.setErrors( null, // no form errors,\n\n  {\n\n    // error on the repeater field:\n\n    'teamMembers': ['There was a problem with 1 of your team members.']\n\n\n\n    // error on a specific repeater item:\n\n    'teamMembers.1.email': ['emily@formkit.com is already on a team.'],\n\n  }\n\n)\n\nRemember, your submit handler is passed the form's core node and can be used to conveniently set errors at depth. Read more about error handling here. Here's an example of a fake backend returning errors for both the repeater and one child:\n\nLoad live example\nProps & Attributes\nProp\tType\tDefault\tDescription\nadd-label\tstring\tnull\tUsed to change the label of the add button.\nadd-attrs\tobject\t[object Object]\tUsed to apply attributes to the add button element.\nadd-button\tboolean\ttrue\tConditional for whether to show the add button.\nup-control\tboolean\ttrue\tConditional for whether to show the up control.\ndown-control\tboolean\ttrue\tConditional for whether to show the down control.\ninsert-control\tboolean\tfalse\tConditional for whether to show the insert control.\nremove-control\tboolean\ttrue\tConditional for whether to show the remove control.\nmin\tNumber\t1\tThe minimum number of children.\nmax\tNumber\tnull\tThe maximum number of children.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nGuests\nNote guests you will bring to the race track.\nRepeated fields here.\n↑\n🗑\n➕\n↓\nAdd guest\nSorry, you may not add more than 3 guests.\nSection-key\tDescription\nfieldset\tA fieldset element that acts as the repeater’s wrapper.\nlegend\tA legend element that renders the label.\nitems\tA ul element that wraps the repeater’s items.\nitem\tA li element that is rendered for each repeater item.\ncontent\tA container for the group section.\ngroup\tDoes not render an element. It structures the default slot into an object data structure.\ncontrols\tA ul element that wraps the repeater’s controls.\ncontrolLabel\tA span element that renders the label of the given control.\nup\tA li element that renders the up control.\nupControl\tA button element that renders the up control.\nmoveUpIcon\tA span element that renders the upControl’s icon.\ndown\tA li element that renders the down control.\ndownControl\tA button element that renders the down control.\nmoveDownIcon\tA span element that renders the downControl’s icon.\ninsert\tA li element that renders the insert control.\ninsertControl\tA button element that renders the insert control.\ninsertIcon\tA span element that renders the insertControl’s icon.\nremove\tA li element that renders the remove control.\nremoveControl\tA button element that renders the remove control.\nremoveIcon\tA span element that renders the removeControl’s icon.\nShow Universal section keys"
  },
  {
    "title": "Range Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/range",
    "html": "Range\nBasic example\nCast to number\nProps & Attributes\nSections\n\nThe range input uses HTML's native range input to let user select a number with a graphic slider.\n\nPRO ALTERNATIVE\n\nNeed more flexibility than the native HTML range input provides? Check out the slider input available in FormKit Pro.\n\nBasic example\nLoad live example\nCast to number\n\nBy default all native HTML <input> elements return a string value. The number prop allows you to cast the value to a true number type. There are two valid values for the number prop: float and integer.\n\nThese options use parseFloat (default) or parseInt respectively. If the value cannot be parsed by the respective function it will set the value to undefined. Additionally applying the number prop will constrain the value of the input to be exclusively number | undefined in TypeScript.\n\nLoad live example\nProps & Attributes\n\nThe range input has only one unique prop, number, which can be used to cast the value of the input to a number type. Additionally, the native HTML range input has a few attributes that can be used to control the input.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmin\tNumber\t--\tView on MDN\nmax\tNumber\t--\tView on MDN\nstep\tNumber\tauto\tView on MDN\nProps\nnumber\tString\tfloat\tSpecifies how to cast a value to a number. Valid values are float and integer.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nNet worth\n😭\n$0\n$1B\n💰\nWhat's your approximate net worth?\nSorry. Our service is only for low-income families.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Rating Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/rating",
    "html": "Rating\nView pricing →\nBasic example\nMin/max\nStep\nIcons\nSlots for icons\nColors\nProps & Attributes\nSections\nPro installation quickstart 🚀\nBasic example\n\nThe rating input allows users to provide feedback based on a numeric scale represented by icons/images:\n\nLoad live example\nMin/max\n\nThe min and max props define the minimum and maximum values an end-user can select. The max determines the number of icons rendered:\n\nLoad live example\nStep\n\nBy default, the rating input will increment by 1. The step prop will allow you to set the step size between each value. For example, if you set step=\"0.5\", the end-user can select any value that is a multiple of 0.5. Steps must be a value between 0.01 and 1:\n\nLoad live example\nIcons\n\nBy default, the rating input uses FormKit's own star icon. You can change which icon is being used by setting the rating-icon prop. This prop accepts a string that will use FormKit's icon plugin:\n\nLoad live example\nSlots for icons\nDefault slot\n\nInstead of specifying an icon via the FormKit icon plugin, you can pass a raw SVG using the default slot:\n\nLoad live example\nNamed slots\n\nLastly, you can use the offItem and onItem slots to pass whatever assets you want.In this example, we'll use different images for the off and on states:\n\nLoad live example\nColors\n\nIn addition to supplying an icon, you can also specify the color via props. Setting the off-color prop will change the color of the icons when they are not selected. The on-color prop will change the color of the icons when they are selected:\n\nLoad live example\nProps & Attributes\nProp\tType\tDefault\tDescription\nmin\tNumber\t0\tThe minimum number of icons that can be selected.\nmax\tNumber\t5\tThe maximum number of icons that are rendered.\nstep\tNumber\t1\tThe step or increment that should be applied to the `rating` icons. Accepted values are between `0.01` and `1`\nhover-highlight\tBoolean\ttrue\tDetermines whether to show the selected state of the icon/image when hovered over.\noff-color\tString\tundefined\tSets the color to be applied on the given icons when they have not been selected.\non-color\tString\tundefined\tSets the color to be applied on the given icons when they have been selected.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nRate your experience at our theater\n⭐️\n✩\nWe will send you a gift card if you give us 5 stars.\nYou must provide a rating.\nSection-key\tDescription\nitemsWrapper\tA wrapper for all of the rating items (both on and off).\noffItems\tA container around all of the off items.\noffItemWrapper\tImmediate parent around each off item.\nonItems\tA container around all of the on items.\nonItemWrapper\tImmediate parent around each on item.\nShow Universal section keys"
  },
  {
    "title": "Radio Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/radio",
    "html": "Radio\nArray of strings\nValue / Label object\nArray of objects\nProps & Attributes\nSections\n\nThe radio input uses HTML's native radio inputs to allow a user to select one value from a series of options. The options prop is required for radio inputs and can be provided in 3 ways:\n\nAn array of strings\nAn object of value/label pairs\nAn array of objects with label and value properties (the same as the checkbox and select inputs)\nArray of strings\n\nThe simplest way to provide options is an array of strings. The provided strings will be used for both the label and the value of the option.\n\nLoad live example\nValue / Label object\n\nYou may also provide the options prop where the keys are values and the values of each property are labels.\n\nLoad live example\nArray of objects\n\nThe most flexible way to define options is by providing an array of objects. The objects must include value and label properties — but may also include a help property as well as an attrs object of additional attributes to apply to each radio input tag.\n\nLoad live example\nProps & Attributes\nProp\tType\tDefault\tDescription\ndecorator-icon\tString\t’’\tSpecifies an icon to put in the decoratorIcon section. Shows when the radio is checked. Defaults to the radioDecorator icon.\noptions\tArray/Object\t[]\tAn object of value/label pairs or an array of strings, or an array of objects that must contain a label and value property.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nMowing time preference\nChoose which time is least disruptive to you.\n🔘\nMorning\nWe`ll come between 7-11 am on Tuesdays.\nYou must make a selection.\nSection-key\tDescription\ndecorator\tResponsible for the element immediately following the input element — usually used for styling.\ndecoratorIcon\tAn element containing the decorator icon.\nlegend\tResponsible for the fieldset’s legend element.\nfieldset\tResponsible for the fieldset when multiple options are available.\noptions\tResponsible for the wrapper element around all of the option items.\noption\tResponsible for the wrapper around each item in the options.\nShow Universal section keys"
  },
  {
    "title": "Mask Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/mask",
    "html": "Mask\nView pricing →\nIntroduction\nBasic example\nMasks\nBuilt-in tokens\nEscaping built-ins\nModes\nShift & replace mode\nSelect mode\nTokens\nCreating new tokens\nModify tokens\nChar tokens\nEnum Tokens\nGroups\nGroup options\nPrefix & suffix\nRunning the mask in reverse\nMask values\nIncomplete values\nUnmasked values\nHiding the mask\nOverlay (colorizing a mask)\nProps & Attributes\nSections\nPro installation quickstart 🚀\nIntroduction\n\nThe mask input automatically transforms user input to match a provided format. Used appropriately, mask inputs can provide an improved user experience by removing any ambiguity for the desired value (for example a phone number or social security number).\n\nMask Input Overview\n\n2 mins\n\nBasic example\n1\n2\n3\n4\n5\n6\n7\n<FormKit\n  type=\"mask\"\n  name=\"phone\"\n  mask=\"+1 (###) ###-####\"\n  label=\"Phone number\"\n  help=\"Please enter a phone number\"\n/>\nRender\nHTML\nMasks\n\nThe mask is the desired format of the input. It is passed to the mask prop where it is parsed for tokens. The mask is comprised of:\n\nTokens - A string representation of a user-editable region. Shown in white below.\nString literals - Any character that is not a token. Not user-editable. Shown in orange below.\nBuilt-in tokens\n\nThe mask input comes with 4 built-in tokens:\n\nh - Accepts a hexadecimal character (0-9a-fA-F).\n# - Accepts a digit character.\na - Accepts an alphabetical character.\n* - Accepts any character.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { ref } from 'vue'\nconst color = ref(null)\n</script>\n<template>\n  <FormKit\n    type=\"mask\"\n    name=\"favorite_color\"\nRender\nHTML\nEscaping built-ins\n\nIf you need to use one of the built-in tokens as a string literal in your mask, you can escape them with \\. Here we are escaping the pound sign # to use in our hex color:\n\n<FormKit mask=\"\\#hhhhhh\" type=\"mask\" />\nModes\n\nThe mask input supports 3 entry modes:\n\nShift (default)\nReplace\nSelect\nShift & replace mode\n\nBy default, the characters of a mask are automatically shifted forward when typing. This is notable when a mask is already populated and you place the cursor at or near the beginning of the input and begin typing. The characters following your cursor are \"shifted\" forward as you type. In replace mode, however, subsequent characters are overwritten with a new value:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit\n  type=\"mask\"\n  mask=\"###-###-####\"\n  value=\"123-456-7890\"\n  label=\"(Shift mode) Social security number\"\n  help=\"Notice when you type new numbers the characters shift to the right.\"\n/>\n<FormKit\n  type=\"mask\"\n  mode=\"replace\"\nRender\nHTML\nSelect mode\n\nIn select mode, equivalent char type tokens are grouped into selectable text ranges. FormKit automatically selects these text ranges when clicking or focusing the input. These selection ranges are maintained as the user is typing. When used tastefully, this produces a clear UX as the user is aware of what value they are expected to enter.\n\nAdditionally, when an input is in select mode, the user can use the arrow or tab keys to shift their focus from one selection range to another:\n\n1\n2\n3\n4\n5\n6\n7\n<FormKit\n  type=\"mask\"\n  mode=\"select\"\n  mask=\"###-###-####\"\n  label=\"(Select mode) Social security number\"\n  help=\"In select mode the active range is always highlighted.\"\n/>\nRender\nHTML\nSELECT MODE OPTIONS\n\nThe selectDirection token property controls which direction new characters flow into the selected range. You can fill \"empty\" selection characters with a predetermined value (like leading zeros \"0\") by using the selectFill property. See token properties.\n\nTokens\nCreating new tokens\n\nWhat if a pattern can accept letters or numbers in the same position? It’s relatively simple to create new tokens. There are 2 types of tokens:\n\nchar accepts a single character.\nenum accepts any strings from an array of possible values.\n\nThe following properties must be defined to create a new token:\n\n{\n\n  /**\n\n   * The type of token. Can be a `char` or `enum`.\n\n   */\n\n  type: 'char',\n\n  /**\n\n   * The token to parse out of the mask.\n\n   */\n\n  token: 'z',\n\n  /**\n\n   * A placeholder character to display in the input when `show-mask` is\n\n   * enabled.\n\n   */\n\n  placeholder: '_',\n\n  /**\n\n   * When using `select` mode, determines which direction do new characters flow\n\n   * in.\n\n   */\n\n  selectDirection: 'left',\n\n  /**\n\n   * (Only for `char` type). A regular expression that describes the types of\n\n   * characters that can appear in this slot. This pattern will be evaluated\n\n   * against individual characters — not in the context of the entire string.\n\n   */\n\n  pattern: /[A-Za-z0-9]/,\n\n  /**\n\n   * (Only for `char` type, optional). An optional character to \"fill\" the\n\n   * selection range with when in select mode. For example, a selectFill set to\n\n   * \"0\" can be helpful with numbers to produce leading zeros like \"001\".\n\n   */\n\n  selectFill: \"0\",\n\n  /**\n\n   * (Only for `enum` type). An array of possible values.\n\n   */\n\n  values: [\n\n    'March',\n\n    'April',\n\n    'May'\n\n  ],\n\n}\n\nFor example, a new token that accepts letters and numbers, and is represented by the letter z in the mask string would look like this:\n\n{\n\n  type: 'char',\n\n  token: 'z',\n\n  pattern: /[A-Za-z0-9]/,\n\n  placeholder: '_',\n\n  selectDirection: 'left',\n\n}\nPLACEHOLDERS SHOULD NOT MATCH PATTERN\n\nAny placeholder you define should not match the Regex pattern provided in the token definition.\n\nAdd tokens via prop\n\nTo pass a new token to the mask input, you can use the tokens prop which expects an object with keys that match the token property. For example, our new token in the above example can be applied directly:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit\n  type=\"mask\"\n  name=\"promo_code\"\n  mask=\"zzz-#### ####\"\n  :tokens=\"{\n    z: {\n      type: 'char',\n      token: 'z',\n      pattern: /[A-Za-z0-9]/,\n      placeholder: '_',\nRender\nHTML\nAdd tokens globally\n\nTo register your mask tokens globally, extend the config property of your global FormKit configuration:\n\ntokens-global.vue\nformkit.config.js\n1\n2\n3\n4\n5\n6\n7\n8\nexport default {\n  config: {\n    tokens: {\n      z: {\n        type: 'char',\n        token: 'z',\n        pattern: /[A-Za-z0-9]/,\n        placeholder: '_',\nRender\nHTML\nModify tokens\n\nIn addition to creating new tokens, the tokens prop can also modify existing tokens. Any value provided to the tokens prop will be merged into the existing tokens for that input. For example, the digit token’s (#) has no selectFill by default. To add one, simply extend it:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit\n  type=\"mask\"\n  mode=\"select\"\n  name=\"year\"\n  mask=\"####\"\n  label=\"What year were you born?\"\n  help=\"You must be at least 21 to enter this site.\"\n  :tokens=\"{\n    '#': {\n      selectFill: '0',\nRender\nHTML\nChar tokens\n\nchar tokens accept a single character. In order for a character to be accepted, it must match the token.pattern regular expression. The four built in tokens (h, #, a, and *) are all char type tokens.\n\nIn select mode, char tokens are grouped together into a selection range.\n\nPLACEHOLDERS\n\nA char token should only ever represent 1 character, and its placeholder should also only be a single character in length.\n\nEnum Tokens\n\nEnum tokens allow for variable length masks within a predefined set of options. As a user begins to type, the enum token’s value will change to the first matching value, and the selection range will reflect the currently unmatched characters. In practice, this operates much like an autocomplete for that specific token. Additionally, users can cycle through available options for a given token by hitting the up/down arrow keys.\n\nA date with auto-completing month names could be well represented with enums:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nconst tokens = {\n  month: {\n    type: 'enum',\n    token: 'month',\n    placeholder: 'month',\n    selectDirection: 'left',\n    values: [\n      'January',\n      'February',\nRender\nHTML\nSELECT MODE REQUIREMENT\n\nEnums are only supported in select mode. When any enum token is found in a mask string, the mode of the input is forcibly set to select.\n\nGroups\n\nGroups are a way to to treat multiple mask characters as a single unit. You create a group by surrounding the desired mask characters in {}:\n\n<FormKit mask=\"id{-a#a}\" type=\"mask\" />\n\n<!-- \"-a#a\" is the group -->\n\nOn their own, groups don't do anything unless you define group options.\n\nGroup options\n\nGroup options allow you to apply functionality to an entire group using a pipe | followed by the option name and any arguments. The available options are:\n\nrepeat — allows a group to be repeated an infinite number of times.\nplaceholder — A character to hold space prior to user input.\nGROUP PLACEHOLDERS\n\nA placeholder defined within a group has a higher specificity than a placeholder defined in the token definition and will override it.\n\nOption parameters\n\nArguments can be passed to a group option by using a colon, such as placeholder:+, where the plus symbol + is passed to the placeholder option.\n\nYou can string group options together:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n<FormKit\n  type=\"mask\"\n  name=\"school_id\"\n  mask=\"id{-a#a|repeat|placeholder:+}\"\n  label=\"Id number\"\n  help=\"Id number in the format: id-b4b-b4b-b4b-b4b\"\n/>\n<!-- \"-a#a\" is the group, \"repeat\" and \"placeholder\" are the options -->\nRender\nHTML\nCAN'T BE USED IN SELECT MODE\n\nGroups cannot be used in select mode. An exception will be thrown.\n\nPrefix & suffix\n\nYou can ensure certain characters always appear at the beginning or end of an input by using the prefix and suffix props, respectively:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit\n  type=\"mask\"\n  name=\"years_old\"\n  prefix=\"I am \"\n  suffix=\" years old.\"\n  mask=\"##\"\n  mode=\"select\"\n  validation=\"required\"\n  :tokens=\"{\n    '#': {\nRender\nHTML\nVALUES CAN'T MATCH THE MASK\n\nYour prefix and suffix content can't match the mask. For instance, if your mask has a digit token #, your prefix/suffix can't contain numbers.\n\nRunning the mask in reverse\n\nIn specific circumstances, you may want to run your mask in reverse. The mask will test if user input fulfills the mask from right to left. This is common in currency-type inputs and can be applied by adding the reverse prop:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit type=\"form\" :actions=\"false\" #default=\"{ value }\">\n  <FormKit\n    type=\"mask\"\n    reverse\n    prefix=\"€\"\n    name=\"bid\"\n    mask=\"{#,##|repeat}#.##\"\n    label=\"Bid\"\n    show-mask=\"false\"\n    allow-incomplete=\"true\"\nRender\nHTML\nSHIFT MODE REQUIREMENT\n\nRunning a mask in reverse only works in shift mode.\n\nMask values\nIncomplete values\n\nA mask’s value is not considered \"complete\" until the user has filled the entire pattern. Until that point, FormKit will consider the value of the input \"empty\". This makes it convenient to use with validation rules like required. However, if you’d like to accept incomplete values, you can via the allow-incomplete prop:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit type=\"form\" #default=\"{ value }\">\n  <FormKit\n    type=\"mask\"\n    name=\"phone\"\n    mask=\"(###) ###-####\"\n    label=\"Phone number\"\n    help=\"Enter a phone number. See the value change as you type.\"\n    allow-incomplete=\"true\"\n  />\n  <pre wrap>{{ value }}</pre>\nRender\nHTML\nUnmasked values\n\nBy default, the value of a mask input includes the formatting provided via the mask prop. However, if you'd like the raw unmasked value with the string literals removed, you can use the unmask-value prop:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit type=\"form\" #default=\"{ value }\">\n  <FormKit\n    type=\"mask\"\n    name=\"phone\"\n    mask=\"(###) ###-####\"\n    label=\"Phone number\"\n    help=\"Enter a full phone number. See the value has no string literals.\"\n    unmask-value=\"true\"\n  />\n  <pre wrap>{{ value }}</pre>\nRender\nHTML\nHiding the mask\n\nBy default, the mask input displays each token’s placeholder character. You can disable this behavior (except in select mode) while still applying formatting automatically via the show-mask prop:\n\n1\n2\n3\n4\n5\n6\n7\n8\n<FormKit\n  type=\"mask\"\n  name=\"phone\"\n  mask=\"+39 ###.######\"\n  label=\"Número de teléfono\"\n  help=\"Inserisci il tuo numero di cellulare.\"\n  show-mask=\"false\"\n/>\nRender\nHTML\nOverlay (colorizing a mask)\n\nBy default, a mask’s value is displayed via the value of its input element. Although this works \"out of the box\" it does now allow for the text be stylistically differentiated. For example it would be nice if the \"literal\" portions of the mask looked different than the \"placeholder\" portions.\n\nTo achieve this effect, you can enable an overlay which renders DOM elements that are positioned directly over the input itself. The text inside the input is still there, but it will be transparent. In general the necessary overlay positioning styles are automatically applied for you.\n\nThe overlay contains 4 possible sections you can target your styles at:\n\nLiteral (.formkit-overlay-literal or overlay-literal-class)\nPlaceholder (.formkit-overlay-placeholder or overlay-placeholder-class)\nEnum (.formkit-overlay-enum or overlay-enum-class)\nChar (.formkit-overlay-char or overlay-char-class)\n\nThe default genesis theme automatically supports the overlay and applies light gray colors to the placeholder. If you are not using Genesis, please ensure the inner section is positioned (like position: relative).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<template>\n  <FormKit\n    type=\"mask\"\n    mode=\"select\"\n    mask=\"month day, year\"\n    :tokens=\"tokens\"\n    label=\"Birthday (with overlay)\"\n    help=\"Notice the placeholder text is a lighter gray color.\"\n    overlay\n  />\nRender\nHTML\nProps & Attributes\nProp\tType\tDefault\tDescription\nallow-incomplete\tboolean\tfalse\tBy default, the value of a mask input is empty until the pattern is complete. This prop allows the input to use incomplete values.\nmask\tstring\tnone\tThe mask to apply. This is a string composed of tokens (like “#”) and literal string values.\nmode\tstring\tshift\tDetermines how the mask input operates. Options are shift, replace and select.\noverlay\tboolean\tfalse\tRenders DOM elements that mimic the text input to allow the differentiation in the stylization of the mask.\nprefix\tstring\tnone\tCharacters that will always appear at the beginning of the input.\nreverse\tboolean\tfalse\tRuns the mask in reverse — from right to left.\nshow-mask\tboolean\ttrue\tDisplays a live representation of the pattern’s placeholder as the internal value of the input.\nsuffix\tstring\tnone\tCharacters that will always appear at the end of the input.\ntokens\tObject\t{}\tAdd new tokens or modify existing ones.\nunmask-value\tboolean\tfalse\tBy default, the value of the input is the same as what is displayed (with formatting). The string literals will removed from the value if this prop is set to true.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nEnter a phone number\n📞\nInput field\n❤️\n🚀\nPlease enter your phone number.\nPhone number is required.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Month Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/month",
    "html": "Month\nBasic example\nProps & Attributes\nSections\n\nThe month input uses HTML's native month picker to allow users to easily select a month.\n\nCOMPATIBILITY WARNING\n\nMonth inputs are not currently supported in FireFox or Safari.\n\nBasic example\nRender\nHTML\nFORMATTING\n\nThe internal format of all native month pickers is YYYY-MM. This is true even though the format of the month displayed to the user may be different. For example, U.S. based browsers display the month format as Month Name YYYY.\n\nProps & Attributes\n\nThe month input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nconfig\tObject\t{}\tConfiguration options to provide to the input’s node and any descendent node of this input.\ndelay\tNumber\t20\tNumber of milliseconds to debounce an input’s value before the commit hook is dispatched.\ndirtyBehavior\tstring\ttouched\tDetermines how the \"dirty\" flag of this input is set. Can be set to touched or compare — touched (the default) is more performant, but will not detect when the form is once again matching its initial state.\nerrors\tArray\t[]\tArray of strings to show as error messages on this field.\nhelp\tString\t''\tText for help text associated with the input.\nid\tString\tinput_{n}\tThe unique id of the input. Providing an id also allows the input’s node to be globally accessed.\nignore\tBoolean\tfalse\tPrevents an input from being included in any parent (group, list, form etc). Useful when using inputs for UI instead of actual values.\nindex\tNumber\tundefined\tAllows an input to be inserted at the given index if the parent is a list. If the input’s value is undefined, it inherits the value from that index position. If it has a value it inserts it into the lists’s values at the given index.\nlabel\tString\t''\tText for the label element associated with the input.\nname\tString\tinput_{n}\tThe name of the input as identified in the data object. This should be unique within a group of fields.\nparent\tFormKitNode\tcontextual\tBy default the parent is a wrapping group, list or form — but this props allows explicit assignment of the parent node.\nprefix-icon\tString\t''\tSpecifies an icon to put in the prefixIcon section.\npreserve\tboolean\tfalse\tPreserves the value of the input on a parent group, list, or form when the input unmounts.\npreserve-errors\tboolean\tfalse\tBy default errors set on inputs using setErrors are automatically cleared on input, setting this prop to true maintains the error until it is explicitly cleared.\nsections-schema\tObject\t{}\tAn object of section keys and schema partial values, where each schema partial is applied to the respective section.\nsuffix-icon\tString\t''\tSpecifies an icon to put in the suffixIcon section.\ntype\tString\ttext\tThe type of input to render from the library.\nvalidation\tString, Array\t[]\tThe validation rules to be applied to the input.\nvalidation-visibility\tString\tblur\tDetermines when to show an input's failing validation rules. Valid values are blur, dirty, and live.\nvalidation-label\tString\t{label prop}\tDetermines what label to use in validation error messages, by default it uses the label prop if available, otherwise it uses the name prop.\nvalidation-rules\tObject\t{}\tAdditional custom validation rules to make available to the validation prop.\nvalue\tAny\tundefined\tSeeds the initial value of an input and/or its children. Not reactive. Can seed entire groups (forms) and lists..\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nMonth you met your significant other\n📅\nInput field\n❤️\n🚀\nWe'll divide groups based on how long you've been together.\nMonth is required.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Password Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/password",
    "html": "Password\nExample\nToggle password visibility\nProps & Attributes\nSections\n\nThe password input uses HTML's native password input. It allows a user to privately enter their password. When creating new passwords, this input is often compiled with the confirm validation rule.\n\nExample\nLoad live example\nToggle password visibility\n\nBy leveraging the icons support built in to FormKit you can easily create a password input where password visibility can be toggled.\n\nLoad live example\nProps & Attributes\n\nThe password input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmaxlength\tNumber\tnone\tView on MDN\nminlength\tNumber\tnone\tView on MDN\nplaceholder\tString\tnone\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nPassword\n🤫\n···········\n🤐\nKeep this hidden in a safe place.\nPassword is required.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Number Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/number",
    "html": "Number\nBasic example\nCast to number\nProps & Attributes\nSections\n\nThe number input uses HTML's native number input. It allows a user to enter a single integer or decimal value.\n\nBasic example\nLoad live example\nCast to number\n\nBy default all native HTML <input> elements return a string value. The number prop allows you to cast the value to a true number type. There are two valid values for the number prop: float and integer.\n\nThese options use parseFloat (default) or parseInt respectively. If the value cannot be parsed by the respective function it will set the value to undefined. Additionally applying the number prop will constrain the value of the input to be exclusively number | undefined in TypeScript.\n\nLoad live example\nProps & Attributes\n\nThe number input has only one unique prop, number, which can be used to cast the value of the input to a number type. Additionally, the native HTML number input has a few attributes that can be used to control the input.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmin\tNumber\t--\tView on MDN\nmax\tNumber\t--\tView on MDN\nstep\tNumber\tauto\tView on MDN\nProps\nnumber\tString\tfloat\tSpecifies how to cast a value to a number. Valid values are float and integer.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nAge you learned Algebra\n=\n13\n✔️\nWe'll incorporate this into our survey data.\nAge you learned Algebra is required.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Meta Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/meta",
    "html": "Meta\nBasic example\nProps & Attributes\nSections\n\nThe meta input is meant to store arbitrary data that is not intended for display to end users. This input is hidden by default and can be used to store data that is not part of the form's schema.\n\nUnlike the hidden input (which renders an <input type=\"hidden\"> element), meta does not render any DOM elements so it’s value is in memory only and as such it can store any value type. In TypeScript its value is defined as any.\n\nBasic example\nLoad live example\nWARNING\n\nSince meta inputs are not intended for display to end users, FormKit does not render common user-facing features such as the label, help text , or messages.\n\nValidation rules can still be applied to a hidden input that will prevent a form from submitting, but please note that the errors will not be displayed on this input.\n\nProps & Attributes\n\nThe meta input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nconfig\tObject\t{}\tConfiguration options to provide to the input’s node and any descendent node of this input.\ndelay\tNumber\t20\tNumber of milliseconds to debounce an input’s value before the commit hook is dispatched.\ndirtyBehavior\tstring\ttouched\tDetermines how the \"dirty\" flag of this input is set. Can be set to touched or compare — touched (the default) is more performant, but will not detect when the form is once again matching its initial state.\nerrors\tArray\t[]\tArray of strings to show as error messages on this field.\nhelp\tString\t''\tText for help text associated with the input.\nid\tString\tinput_{n}\tThe unique id of the input. Providing an id also allows the input’s node to be globally accessed.\nignore\tBoolean\tfalse\tPrevents an input from being included in any parent (group, list, form etc). Useful when using inputs for UI instead of actual values.\nindex\tNumber\tundefined\tAllows an input to be inserted at the given index if the parent is a list. If the input’s value is undefined, it inherits the value from that index position. If it has a value it inserts it into the lists’s values at the given index.\nlabel\tString\t''\tText for the label element associated with the input.\nname\tString\tinput_{n}\tThe name of the input as identified in the data object. This should be unique within a group of fields.\nparent\tFormKitNode\tcontextual\tBy default the parent is a wrapping group, list or form — but this props allows explicit assignment of the parent node.\nprefix-icon\tString\t''\tSpecifies an icon to put in the prefixIcon section.\npreserve\tboolean\tfalse\tPreserves the value of the input on a parent group, list, or form when the input unmounts.\npreserve-errors\tboolean\tfalse\tBy default errors set on inputs using setErrors are automatically cleared on input, setting this prop to true maintains the error until it is explicitly cleared.\nsections-schema\tObject\t{}\tAn object of section keys and schema partial values, where each schema partial is applied to the respective section.\nsuffix-icon\tString\t''\tSpecifies an icon to put in the suffixIcon section.\ntype\tString\ttext\tThe type of input to render from the library.\nvalidation\tString, Array\t[]\tThe validation rules to be applied to the input.\nvalidation-visibility\tString\tblur\tDetermines when to show an input's failing validation rules. Valid values are blur, dirty, and live.\nvalidation-label\tString\t{label prop}\tDetermines what label to use in validation error messages, by default it uses the label prop if available, otherwise it uses the name prop.\nvalidation-rules\tObject\t{}\tAdditional custom validation rules to make available to the validation prop.\nvalue\tAny\tundefined\tSeeds the initial value of an input and/or its children. Not reactive. Can seed entire groups (forms) and lists..\nSections\n\nThe meta input is made up of only\n\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "List Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/list",
    "html": "List\nBasic example\nList types\nStatic lists\nDynamic lists\nValidity of children\nShowing error & validation messages\nProps & Attributes\nSections\n\nThe list input allows you to structure data from child inputs as an array. The list itself outputs no markup (by default) and can be used in conjunction with any other type of input — including nested groups and lists.\n\nThe value of a list input is an array where each item is the value of the input at that index. Sub-inputs do not need to be of the same type. In addition to structuring data, lists can determine the validation state, provide initial values, and supply plugins and configuration to all of its children.\n\nBasic example\nLoad live example\nPERFORMANCE\n\nVue’s handy v-model is fully supported in FormKit with bi-directional data flow even on lists and groups. However, if your form needs extremely high performance consider using the core node to read/write instead of v-model.\n\nList types\n\nThere are 2 flavors of lists:\n\nStatic lists (default) have pre-determined children. They should not be used for iterating over values or adding/removing items.\nDynamic lists allow iteration over the list’s value to create its children. They are useful for creating dynamic-length lists like repeaters.\nStatic lists\n\nStatic lists are the simplest type of list to create. Wrap any inputs in a <FormKit type=\"list\"> and those inputs will automatically be set as values of their array. Immediate children of lists do not have a name (even if specified) instead they are always identified by their index. In a static list, this index is stable and is based on the order of the inputs.\n\nLoad live example\nITERATING OVER THE LIST VALUES\n\nStatic lists should not be used for iterating over their own value. While it is safe to iterate over other arbitrary data iterating over the value of the list itself will cause recursive rendering and infinite loops. Instead use a dynamic list.\n\nDynamic lists\n\nDynamic lists allow you to iterate over the values of the list to create and hydrate the inputs inside the list. Dynamic lists are useful for creating dynamic array structures like repeaters.\n\nYou can mutate the structure of your dynamic list by adding and removing items from the value array. FormKit will automatically update the underlying form structure to match the new value.\n\nIn order for dynamic lists to keep your data in sync, you must use items from the default slot to create your v-for and you must also pass the index of the v-for as the index prop to each item in of the list.\n\nFORMKIT PRO REPEATER\n\nTo use a prebuilt repeater, check out the free FormKit Pro repeater input.\n\nDynamic list example\nLoad live example\nDynamic list with a nested group\nLoad live example\nDynamic list using v-model\nLoad live example\nDynamic list in schema\nLoad live example\nValidity of children\n\nLists (and groups) are always aware of the validation state of their children (including nested children). You can access this data in the context object of the input (context.state.valid).\n\nLoad live example\nShowing error & validation messages\n\nEven though a list can have validation rules and input errors, it does not include any functionality to show validation messages and errors by default. The list ships no HTML at all. If you’d like to display those errors — you can add the <FormKitMessages /> as a child of the list.\n\nCONFIGURATION\n\nFurther documentation on the FormKitMessages component can be found on the form documentation page.\n\nProps & Attributes\nProp\tType\tDefault\tDescription\ndisabled\tBoolean\tfalse\tDisables all the inputs in the list.\ndynamic\tBoolean\tfalse\tEnables dynamic mode for the list and provides items in the default slot creating an iterator (v-for).\nShow Universal props\nSections\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Hidden Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/hidden",
    "html": "Hidden\nBasic example\nCast to number\nProps & Attributes\nSections\n\nThe hidden input uses HTML's native hidden input. It is not a visible element, and should only be used to provide data that is not entered by a user.\n\nBasic example\nLoad live example\nWARNING\n\nSince hidden inputs are not intended for display to end users, FormKit does not render common user-facing features such as the label, help text , or messages.\n\nValidation rules can still be applied to a hidden input that will prevent a form from submitting, but please note that the errors will not be displayed on this hidden input.\n\nCast to number\n\nBy default all native HTML <input> elements return a string value. The number prop allows you to cast the value to a true number type. There are two valid values for the number prop: float and integer.\n\nThese options use parseFloat (default) or parseInt respectively. If the value cannot be parsed by the respective function it will set the value to undefined. Additionally applying the number prop will constrain the value of the input to be exclusively number | undefined in TypeScript.\n\nLoad live example\nProps & Attributes\n\nThe hidden input has only one unique prop, number, which can be used to cast the value of the input to a number type.\n\nProp\tType\tDefault\tDescription\nnumber\tString\tfloat\tSpecifies how to cast a value to a number. Valid values are float and integer.\nShow Universal props\nSections\n\nHidden inputs do not render all of the surrounding markup typical of other inputs. As such, most section keys do not apply.\n\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Form ⚡️ FormKit",
    "url": "https://formkit.com/inputs/form",
    "html": "Form\nProvided submit button\nFull example form\nPopulating\nSubmitting\nSubmitting via XHR/Fetch request\nSubmitting as a page request\nSubmitting forms programmatically\nValidation\nValidation incomplete message\nSubmit invalid event\nValidity state\nDisabling\nResetting\nInitial values\nError handling\nForm errors\nClearing errors\nInput errors\nValidation and error summary\nMoving validation and error messages\nMove messages automatically\nMove messages by node\nFormKitMessages props\nUnmounting inputs\nProps\nSections\n\nWhile you’re free to use FormKit inputs by themselves, you’ll usually want to group them into a form. To do this, simply wrap your inputs in a <FormKit type=\"form\">.\n\nThe form type will actively collect all the values from child inputs, using the name of each input as the property name in the resulting data object (just like groups). You can also read and write to form values using v-model just as you would on any input.\n\nA <FormKit type=\"form\"> tracks the form's validation state and prevents users from submitting the form if any inputs are invalid.\n\nProvided submit button\n\nAs a convenience, the form outputs a submit button automatically, and provided themes also include a loading spinner. You can alter this button with the submit-label and submit-attrs props, or disable with :actions=\"false\". You can pass any FormKit props to submit-attrs. In the example below, we pass classes, data attributes, help text, and even tell the included submit button to be un-ignored:\n\n<FormKit\n\n  type=\"form\"\n\n  submit-label=\"Update\"\n\n  :submit-attrs=\"{\n\n    inputClass: 'my-input-class',\n\n    wrapperClass: 'my-wrapper-class',\n\n    'data-theme': `dark`,\n\n    help: 'My button help text',\n\n    ignore: false\n\n  }\"\n\n></FormKit>\nFull example form\n\nExcluding backend functionality, here is a fully featured form with inputs (form, text, email, password), help text, labels, validation with custom messages, and error and submission handling:\n\n1\n2\n3\n4\n5\n6\n7\n8\n<script setup>\nimport { ref } from 'vue'\nconst submitted = ref(false)\nconst submitHandler = async () => {\n  // Let's pretend this is an ajax request:\n  await new Promise((r) => setTimeout(r, 1000))\n  submitted.value = true\n}\nRender\nHTML\nLoading Example...\nPopulating\nForm Population and Submission - Vue School Course\n\n8 mins\n\nYou can populate an entire form by providing a value prop to the <FormKit type=\"form\">. The value prop should be an object of input name to input value pairs. You may also use v-model to populate a form if you require two-way data binding:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit\n  type=\"form\"\n  :value=\"{\n    location: 'New York City',\n    duration: '2 weeks',\n    price: 'average'\n  }\"\n  submit-label=\"Save\"\n  @submit=\"save\"\n>\nRender\nHTML\nV-MODEL AND REACTIVE OBJECTS\n\nBe sure to either v-model a ref or a property of a reactive object. Do not v-model the reactive object itself as it leads to unexpected behavior.\n\nSubmitting\n\nForms are usually submitted through user actions like clicking a submit button or hitting the enter key on a text node within the form. Upon submission, the form (in sequence):\n\nEnsures all inputs are settled (finished debouncing).\nEmits the @submit-raw event.\nSets the submitted state to true on all inputs — displaying any remaining validation errors (regardless of the validation-visibility).\nIf the form has validation errors the @submit-invalid event is fired.\nIf all inputs are valid it fires the @submit event.\nIf the @submit handler returns a Promise, sets the form’s state to loading until it resolves.\nAVOID V-MODEL FOR COLLECTING AND SUBMITTING FORM DATA\n\nUsing v-model data in your submit handler can lead to unintended form mutations. FormKit automatically collects form data for you, so use the unbound copy of your form’s data that is passed to your submission handler instead.\n\nSubmitting via XHR/Fetch request\n\nThe most common method of form submission in a modern SPA is an XHR request (think axios or fetch). FormKit is well suited to this task:\n\nIt hands your @submit handler 1) the collected form data as a single request-ready object (no v-model needed), and 2) the form input's core node, as a convenience.\nIf you use an async submit handler, it will disable your form’s inputs and apply a loading state to your form (loading becomes true at context.state.loading and a spinner is displayed on the genesis theme).\nIt handles backend errors by placing error messages directly on the failing inputs.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\n// This is just a mock of an actual axios instance.\nconst axios = {\n  post: () => new Promise(r => setTimeout(r, 2000))\n}\nasync function login (credentials) {\n  const res = await axios.post(credentials)\n  // do some login things now\n  alert('Logged in!')\nRender\nHTML\nSubmitting as a page request\n\nTo submit a form via page request, simply leave off the @submit handler. Just like native HTML, you can also provide an action and optionally a method attribute.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<template>\n  <FormKit\n    type=\"form\"\n    submit-label=\"Login\"\n    action=\"https://enpae7aofyxlml7.m.pipedream.net\"\n    method=\"post\"\n  >\n    <FormKit\n      name=\"email\"\n      label=\"Email address\"\nRender\nHTML\nSubmitting forms programmatically\n\nWhile submitting a form using any standard HTML method is valid (like clicking a submit button, or hitting enter on a text input) — you may also submit a form programmatically. There are 2 ways to do this:\n\nUsing this.$formkit.submit('form-id') (submitForm('form-id') for the composition api).\nUsing a core node object.\nSubmitting with $formkit.submit()\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\nexport default {\n  methods: {\n    submitForm() {\n      this.$formkit.submit('newsletter')\n    },\n    submitToMailchimp(data) {\n      alert(`Submitted ${data.email} successfully!`)\n    },\n  },\nRender\nHTML\nSubmitting with node.submit()\n\nYou can also submit a form programmatically by calling node.submit() on the form’s (or any input inside the form) core node. To do this you need to retrieve an instance of the core node.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { ref } from 'vue'\nconst myForm = ref(null)\nfunction submitForm() {\n  // retrieve the core node (several ways to do this):\n  const node = myForm.value.node\n  // submit the form!\n  node.submit()\n}\nRender\nHTML\nValidation\n\nForms will not submit until all the inputs in the form are passing their validation rules.\n\nValidation incomplete message\n\nIn addition to not firing the submit event, a message is displayed above the submit button indicating the form is still incomplete. You can customize this message using the incomplete-message prop or disable it by setting the prop to false.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nconst nextMonday = new Date()\nnextMonday.setDate(\n  nextMonday.getDate() + ((((7 - nextMonday.getDay()) % 7) + 1) % 7)\n)\n</script>\n<template>\n  <FormKit\n    type=\"form\"\nRender\nHTML\nGLOBAL CUSTOMIZATION\n\nIf you want to change the incomplete message across all forms on your project, you can modify the i18n locale message for ui.incomplete.\n\nSubmit invalid event\n\nWhen a user attempts to submit a form containing inputs that have failing validations, the @submit-invalid event is fired.\n\nFor example, we could use this event to alert our users of the failing validation rules.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { getValidationMessages } from '@formkit/validation'\nimport { ref } from 'vue'\nconst messages = ref([])\nfunction showErrors(node) {\n  const validations = getValidationMessages(node)\n  messages.value = []\n  validations.forEach((inputMessages) => {\nRender\nHTML\nValidity state\n\nThe validity of all inputs within a form is tracked automatically in the context object. This can be useful when creating various interfaces. For example, if you wanted a submit button to be disabled until all inputs are valid, you could use the state.valid property to do so.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nconst handleSubmit = () => alert('Password reset!')\n</script>\n<template>\n  <FormKit\n    type=\"form\"\n    :actions=\"false\"\n    @submit=\"handleSubmit\"\n    #default=\"{ state: { valid } }\"\nRender\nHTML\nGETTING THE CONTEXT OBJECT\n\nIn the above example we extract the context object from the #default slot, but there are other ways as well. The context object is available on each input’s core node on the node.context property, and you can fetch an input’s node a number of ways.\n\nDisabling\n\nTo disable all the inputs in a given form, including the submit button, you can use the disabled prop.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<template>\n  <!-- try removing the \"disabled\" attribute below -->\n  <FormKit type=\"form\" disabled>\n    <FormKit\n      label=\"Username\"\n      value=\"@vue-lover\"\n    />\n    <FormKit\n      label=\"Password\"\n      type=\"password\"\nRender\nHTML\nDISABLED AUTOMATICALLY\n\nWhen using an async @submit handler FormKit will automatically disable the form (and set the state to loading) while the submit handler is pending.\n\nResetting\n\nYou can reset your form (or any input) back to it’s initial state by calling $formkit.reset(formId).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\nexport default {\n  data() {\n    return {\n      complete: false,\n    }\n  },\n  methods: {\n    async handleSubmit() {\n      // Our api request:\nRender\nHTML\nCOMPOSITION API\n\nWhen using the composition api you can directly access the reset function by importing it from core: import { reset } from '@formkit/core'.\n\nInitial values\n\nIt’s important to note that the \"initial state\" of a form is not necessarily an empty form. You can have a default :value or v-model on the form and on individual inputs in the form — FormKit automatically merges these together to produce your initial value, and will restore to this merged state on reset.\n\nOptionally you can provide a second argument to reset(formId, initialState) if you would prefer an alternative reset state.\n\nError handling\n\nWith FormKit, adding front end validation to your form is easy — but what about errors produced by your backend framework, or ones you want to manually assign? There are two types of errors you can assign to a form:\n\nForm errors. These are displayed at the bottom of the form above the submit button. An example would be a global message like \"Sorry, our server isn’t working right now”.\nInput errors. Errors to be placed on specific inputs within your form, typically these are validation errors from your backend, like \"Sorry this username is already taken\".\nForm errors\n\nForm errors (ones that apply to the entire form) can be set three ways.\n\nUsing the errors prop on a <FormKit type=\"form\">.\nUsing a core node node.setErrors().\nUsing the $formkit.setErrors() Vue plugin method.\nUsing the errors prop\n\nLike with any FormKit input, you can directly assign errors using the errors prop. These errors are always visible (not subject to validation-visibility).\n\n1\n2\n3\n4\n5\n6\n7\n8\n<FormKit\n  type=\"form\"\n  submit-label=\"Login\"\n  :errors=\"['Our server is not working.', 'But we don’t like you anyway!']\"\n>\n  <FormKit type=\"email\" label=\"Email address\" />\n  <FormKit type=\"password\" label=\"Password\" />\n</FormKit>\nRender\nHTML\nUsing node.setErrors()\n\nSetting your form’s errors using node.setErrors is convenient since your submit handler is passed the form’s node object as its second argument. node.setErrors() takes 2 arguments — an array for form errors, and a keyed object for input errors:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nfunction submitHandler(data, node) {\n  if (data.username !== 'formkit4life') {\n    node.setErrors(\n      // Arg 1 is form-wide errors\n      ['There was an error in this form'],\n      // Arg 2 is field-specific errors\n      {\n        username: 'Sorry, that username is not available.',\n      }\nRender\nHTML\nUsing $formkit.setErrors()\n\nAlternatively, you can set errors directly on a form by giving the form an id and then calling $formkit.setErrors('id', ['Form error here']). The setErrors method must be passed the id of the form, and then can handle 1 or 2 additional arguments — the form errors, and the input errors:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\nexport default {\n  methods: {\n    async order(data) {\n      try {\n        await fakeApiCall(data)\n      } catch (inputErrors) {\n        this.$formkit.setErrors(\n          'order-form', // You must use the ID of the form\n          ['There was an error with your order!'], // (optional) An array of form level errors\nRender\nHTML\nClearing errors\n\nBy default errors that were set on inputs using setErrors() are automatically cleared when a user changes the value of that input. You can change this default behavior by setting the preserve-errors prop.\n\nTo clear all the errors on the form (regardless of the preserve-errors prop) call node.clearErrors().\n\nRender\nHTML\n\nIf you prefer to preserve errors by default, you can change the default behavior by modifying the preserveErrors config option. This can be done globally or for a single form:\n\nRender\nHTML\nCOMPOSITION API\n\nWhen using Vue 3’s composition API, you can access setErrors and clearErrors by importing them directly from @formkit/vue.\n\nimport { setErrors, clearErrors } from '@formkit/vue'\n\nInput errors\n\nInput errors (ones to be displayed with specific inputs in a form) can be applied three ways:\n\nManually using the errors prop on each individual input.\nUsing the input-errors prop on the form (also works with groups and lists).\nUsing the $formkit.setErrors() Vue plugin method (see example above).\nManually using errors prop\n\nThe most basic way to display errors on a form is using the errors prop that is available on each FormKit input.\n\nRender\nHTML\nUsing input-errors prop\n\nYou can also conveniently set error messages for all inputs in your form (or group or list) using the input-errors prop. The prop accepts an object of errors, where the keys are input names (relative node addresses are supported) and the value is an error or array of errors to apply to that input.\n\nRender\nHTML\nValidation and error summary\n\nIt can be helpful for accessibility to provide a summary of validation and error messages at the top of your form. FormKit provides a <FormKitSummary /> component to render this summary for you.\n\nThis component will automatically render all of a form’s validation and error messages with jump links to the inputs they apply to. These errors are only shown after submitting the form but they are wrapped in an aria-live region to ensure screen readers will be notified when the errors present themselves. Additionally the page will automatically be scrolled to the summary box and focused on the first error listed.\n\n<FormKitSummary /> is not a globally registered component — you must import it:\n\nimport { FormKitSummary } from '@formkit/vue'\nRender\nHTML\nMOVING THE SUMMARY\n\nThe summary component should generally be nested in the form it is summarizing. If you would like to move the summary to a different location on the page, you can do so by providing the form’s core node as the node prop.\n\nMoving validation and error messages\n\nBy default, a form’s validation and error messages are placed directly above the form’s actions section. However, you can choose to render these anywhere on your page by using the <FormKitMessages /> component. <FormKitMessages /> is not a globally registered component — you must import it:\n\nimport { FormKitMessages } from '@formkit/vue'\n\nThere are two ways to use <FormKitMessages />:\n\nAutomatically\nManually by node\nMove messages automatically\n\nPlace a <FormKitMessages /> component anywhere inside your form, and the form’s messages will automatically be moved to that location:\n\nRender\nHTML\nMove messages by node\n\nTo move messages anywhere in the DOM — even outside the form — you can pass the form’s core node as a prop to <FormKitMessages />. In this example, we use the messages to create a toast-style popup:\n\nRender\nHTML\nFormKitMessages props\n\nThe <FormKitMessages /> component has a few additional configuration options:\n\nProp\tDefault\tDescription\nnode\tinherited\tThe core node to render messages for. By default this is inherited from the node’s parent (if it exists).\nsectionsSchema\t{}\tOverride the internal messages and message sections (same default structure as other input’s messages section).\ndefaultPosition\tfalse\tBy default, FormKitMessages moves the rendered messages to a new location. If you would like to render the messages in both locations, set this prop to true.\nUnmounting inputs\n\nWhen inputs are unmounted from a form — for example when using v-if — the key and value is removed from the form’s data. However, in some circumstances it may be preferable to keep the key/value pair even after the input has been removed. This can be accomplished by using the preserve prop:\n\nRender\nHTML\nProps\n\nForms are technically considered input types — so they share many of the universal props that standard inputs use.\n\nProp\tType\tDefault\tDescription\ndisabled\tBoolean\tfalse\tDisables the form submit button and all the inputs in the form.\nincomplete-message\tString/Boolean\t{locale}.ui.incomplete\tThe message that is shown to near the submit button when a user attempts to submit a form, but not all inputs are valid.\nsubmit-attrs\tObject\t{}\tAttributes or props that should be passed to the built-in submit button.\nsubmit-behavior\tString\tdisabled\tAsync submit handlers automatically disable the form while pending, you can change this by setting this prop to 'live'.\nsubmit-label\tString\tSubmit\tThe label to use on the built-in submit button.\nactions\tBoolean\ttrue\tWhether or not to include the actions bar at the bottom of the form (ex. you want to remove the submit button and use your own, set this to false).\nShow Universal props\nSections\nSection-key\tDescription\nform\tResponsible for rendering the form tag and listening to submit events.\nactions\tResponsible for a container at the bottom of the form with form actions like the submit button.\nsubmit\tResponsible for a submit button — by default a FormKit input type submit.\nShow Universal section keys"
  },
  {
    "title": "Group Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/group",
    "html": "Group\nAn example\nValidity of children\nShowing error & validation messages\nProps & Attributes\nSections\n\nThe group input allows you to structure data from child inputs as an object. The group itself outputs no markup by default and can be used in conjunction with any other type of input — including nested groups and lists.\n\nThe value of a group input is an object where the keys are the names of the inputs, and the object’s values are each input’s value. In addition to structuring data, groups can determine the validation state, provide initial values, and supply plugins and configuration to all of its children.\n\nAn example\nRender\nHTML\nValidity of children\n\nGroups are always aware of the validation state of their children (including nested children). You can access this data in the context object of the input (context.state.valid).\n\nRender\nHTML\nShowing error & validation messages\n\nEven though a group can have validation rules and input errors, it does not include any functionality to show validation messages and errors by default. The group ships no HTML at all. If you’d like to display those errors — you can add the <FormKitMessages /> as a child of the group.\n\nCONFIGURATION\n\nFurther documentation on the FormKitMessages component can be found on the form documentation page.\n\nProps & Attributes\nProp\tType\tDefault\tDescription\ndisabled\tBoolean\tfalse\tDisables all the inputs in the group.\nShow Universal props\nSections\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "File Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/file",
    "html": "File\nBasic example\nArray value\nUploading files\nProps & Attributes\nSections\nSingle file diagram\nMultiple file diagram\n\nThe file input uses HTML's native file input. It allows users to select files from their device for upload. In addition to native input features, it adds support for:\n\nDrag and drop\nClearing the input\nRepopulating from an array\nBasic example\nRender\nHTML\nArray value\n\nThe value of the file type should always be an array of objects where each object contains a name (string) and optional file (File) property. When selecting new files from a user’s device, FormKit will convert the native FileList to the required array-based structure automatically.\n\nThis structure can be used to pre-populate a file input with previously uploaded file values:\n\nRender\nHTML\nDISPLAY ONLY\n\nPre-populating an input with file names is for display purposes only. It’s an optional feature that provides a consistent interface to convey that a file was previously uploaded — however — a FileList is not attached to the actual <input> tag for upload.\n\nUploading files\n\nThe file upload process is left to your form’s submission handler. When submitting the form via full page request no further processing is necessary, however when submitting via XHR/Fetch request you will need to create an instance of FormData with the files attached. Here is a working example:\n\nRender\nHTML\nProps & Attributes\n\nThe file input has a few unique props. There are also several commonly used native HTML attributes that assist in controlling file uploads.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\naccept\t--\t--\tView on MDN\ncapture\t--\t--\tView on MDN\nmultiple\t--\t--\tView on MDN\nwebkitdirectory\t--\t--\tView on MDN\nProps\nfile-item-icon\tString\t’’\tSpecifies an icon to put in the fileItemIcon section. Only shows when there is a file selected. Defaults to the fileDoc icon.\nfile-remove-icon\tString\t’’\tSpecifies an icon to put in the fileRemoveIcon section. Only shows when a file is selected. Defaults to the close icon.\nno-files-icon\tString\t’’\tSpecifies an icon to put in the noFilesIcon section. Only shows when no file is selected. Defaults to the fileDoc icon.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nSingle file diagram\nouter\ninner\nprefixIcon\nprefix\ninput\nnoFiles\nnoFilesIcon\nfileList\nfileItem\nfileItemIcon\nfileName\nYour resumé\n🗄\n📁\nmy-resume.pdf\nX\nUpload your resumé.\nOnly supports .pdf and .docx extensions.\nwrapper\nlabel\nfileRemove\nfileRemoveIcon\nsuffix\nsuffixIcon\nhelp\nmessages\nmessage\nMultiple file diagram\nouter\ninner\nprefixIcon\nprefix\ninput\nfileList\nfileItem\nfileItemIcon\nfileName\nYour resumé\n🗄\n📁\nmy-resume.pdf\nRemove all\nUpload your resumé.\nOnly supports .pdf and .docx extensions.\nwrapper\nlabel\nfileRemove\nnoFiles\nnoFilesIcon\nsuffix\nsuffixIcon\nhelp\nmessages\nmessage\nSection-key\tDescription\nfileList\tA wrapper for the whole list of files.\nfileItemIcon\tAn element containing an optional fileItem icon.\nfileItem\tAn element containing the fileName and remove action for each file.\nfileName\tThe element containing the name of a file.\nfileRemove\tThe element that removes a file from the list.\nfileRemoveIcon\tAn element containing the fileRemove icon.\nnoFiles\tThe element shown when there are no files selected.\nnoFilesIcon\tAn element containing an icon within the noFiles section.\nShow Universal section keys"
  },
  {
    "title": "Email Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/email",
    "html": "Email\nAn example\nProps & Attributes\nSections\n\nThe email input uses HTML's native email input.\n\nPRO ALTERNATIVE\n\nNeed more flexibility than the native HTML email input provides? Check out the mask input available in FormKit Pro.\n\nAn example\nLoad live example\nProps & Attributes\n\nThe email input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nplaceholder\tString\tnone\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nEmail address\n📧\ntest@example.com\n✈️\nPlease use your school email address.\nPlease provide a valid email.\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Datetime-local Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/datetime-local",
    "html": "Datetime-local\nBasic example\nProps & Attributes\nSections\n\nThe datetime-local input uses HTML's native datetime-local picker to allow users to easily select a date and time based on their browser’s locale.\n\nPRO ALTERNATIVE\n\nNeed more flexibility than the native HTML datetime-local input provides? Check out the datepicker input available in FormKit Pro.\n\nBasic example\nRender\nHTML\nFORMATTING\n\nThe internal format of all native datetime-local pickers is YYYY-MM-DDTHH:MM. This is true even though the format of the datetime-local displayed to the user may be different. For example U.S. based browsers display datetime-local format as MM/DD/YYYY, HH:MM AM/PM.\n\nProps & Attributes\n\nThe datetime-local input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmin\tNumber\t--\tView on MDN\nmax\tNumber\t--\tView on MDN\nstep\tNumber\tauto\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nAppointment time\"\n⏰\"\nJan. 1 1970 12:00:00\"\n👍\"\nPlease choose a date and time for your appointment.\"\nDate and time are required.\"\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Dropdown Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/dropdown",
    "html": "Dropdown\nView pricing →\nBasic examples\nSingle-select\nMulti-select\nDynamic options\nPagination\nOption loader\nOption appearance\nOption slot\nSelection appearance\nSelection appearance prop\nSelection slot\nBehavioral props\nEmpty Message\nSelection Removable\nOpen on remove\nClose on select\nOpen on focus\nOverscroll\nMax\nProps & Attributes\nSections\nSelector structure\nListbox structure\nSelection structure\nPro installation quickstart 🚀\n\nThe dropdown input allows users to select a value from a list of options. Unlike native select elements, the dropdown input allows you to customize both its appearance and behavior.\n\nThe options prop can accept three different formats of values:\n\nAn array of objects with value and label keys (see example above)\nAn array of strings ['A', 'B', 'C']\nAn object literal with key-value pairs { a: 'A', b: 'B', c: 'C' }\nA function that returns any of the above\nEMPTY OPTIONS\n\nIf you assign options as an empty array, the input will be rendered in a disabled state.\n\nBasic examples\nSingle-select\n\nThe dropdown input will render in single-select mode by default.\n\nLoad live example\nMulti-select\n\nDropdown inputs with the prop multiple set will render in multi-select mode.\n\nLoad live example\nMULTI-SELECT INPUT VALUE\n\nNotice in the example above that because the multiple prop is set, the value prop must be an array.\n\nDynamic options\n\nInstead of passing a static list to the options prop, options can be assigned dynamically.\n\nIn this example, the function, loadHorrorMovies, makes a request to the API for TMDB to load a list of horror movies. Assigning the function to the options prop will load the options when the end-user opens the listbox.\n\nLoad live example\nAlways load on open\n\nBy default the dropdown will only load options asynchronously once (upon the listbox being expanded). Setting the prop always-load-on-open will cause the dropdown to load options every time the listbox is expanded.\n\nLoad live example\nLoad on created\n\nThe prop load-on-created will cause the dropdown to load options as soon as it is created.\n\nLoad live example\nPagination\n\nA function assigned the options prop will be passed two arguments: page and hasNextPage. The page argument indicates the current page number, and hasNextPage is a callback function that indicates whether there are more pages to load.\n\nLoad live example\nLoad on scroll\n\nIf you would rather allow the user to load more options without having to click the Load more option at the bottom of the options list, you can set the load-on-scroll prop to true, and our function, loadCurrentlyPopularMovies will be called again:\n\nLoad live example\nOption loader\n\nFormKit's dropdown input also provides an optionLoader prop that allows you to rehydrate values that are not in the options list. In this example the dropdown is provided an initial value (two movie IDs). The optionLoader function is called for each value that is not in the options list.\n\nLoad live example\n\nNotice in the example above that the optionLoader function is passed two arguments: the value of the selected option (in this case, the movie ID) and the cachedOption. The cachedOption prop is used for preventing unnecessary lookups. If the cachedOption is not null it means that the selected option has already been loaded, and you can return the cachedOption directly.\n\nOption appearance\n\nUnlike native select elements, the dropdown input can be customized via. markup.\n\nOption slot\n\nThe dropdown input allows you to customize the look and feel of each option by using the option slot. In this example, we are using the option slot to display each option's asset; logo and name:\n\nLoad live example\nSelection appearance\n\nThe dropdown input allows you to customize the look and feel of the selected option(s).\n\nSelection appearance prop\n\nWhen using the dropdown input as a multi-select, you can customize the look and feel of the selected options by setting the selection-appearance prop to either truncate (the default) or tags.\n\nLoad live example\nSelection slot\n\nIf you only want to customize the display of the selected option, use the selection slot (as opposed to the option slot mentioned above):\n\nLoad live example\nSINGLE-SELECT AND TAGS ONLY\n\nThe selection slot does not exist on the multi-select dropdown with selection appearance truncate.\n\nBehavioral props\n\nThe following props allow you to customize the behavior of the dropdown input.\n\nEmpty Message\n\nThe dropdown input, by default, will be rendered in a disabled state if no options are passed. Optionally, you may pass the empty-message prop a message to display when no options are available:\n\nLoad live example\nSelection Removable\n\nIf you would like to allow users to remove the selected value, set the selection-removable prop to true. This will render a close icon next to the selected value:\n\nSINGLE SELECT ONLY\n\nThe selection-removable prop cannot be used for multi-selects.\n\nLoad live example\nOpen on remove\n\nBy default, when the selection-removable prop is set to true, the dropdown will not open after the selected value is removed. You can change this behavior by setting the open-on-remove prop to true:\n\nLoad live example\nClose on select\n\nBy default, when the multiple prop is set, the dropdown will not close after an option is selected. You can change this behavior by setting the close-on-select prop to true:\n\nLoad live example\nOpen on focus\n\nIf you would like expand the listbox as soon as the dropdown input is focused, you can use the open-on-focus prop:\n\nLoad live example\nOverscroll\n\nWhen using the dropdown with static options, FormKit's dropdown also comes with a feature called overscroll. Setting the behavior prop to overscroll will render the listbox directly over the input to maximize the available size for the list:\n\nLoad live example\nMax\n\nIf you would like to limit the number of options that can be selected, you can use the max prop:\n\nLoad live example\nProps & Attributes\nProp\tType\tDefault\tDescription\noptions\tany\t[]\tThe list of options the user can select from.\nload-on-scroll\tboolean\tfalse\tWhen set to `true`, the dropdown will try loading more options based on the end-user`s scroll position\noption-loader\tfunction\tnull\tUsed for hydrating initial value, or performing an additional request to load more information of a selected option.\nempty-message\tstring\tundefined\tRenders a message when there are no options to display.\nselection-appearance\tstring\ttruncate\tFor multi-select dropdowns, this prop allows you to customize the look and feel of the selected options. Possible values are `truncate` (the default) or `tags`.\nselection-removable\tboolean\tfalse\tFor single-select dropdowns, this prop allows you to remove the selected value.\nopen-on-remove\tboolean\tfalse\tWhen the `selection-removable` prop is set to `true`, the dropdown will not open after the selected value is removed. You can change this behavior by setting the `open-on-remove` prop to `true`.\nclose-on-select\tboolean\tfalse\tWhen the `multiple` prop is set, the dropdown will not close after an option is selected. You can change this behavior by setting the `close-on-select` prop to `true`.\nopen-on-focus\tboolean\tfalse\tIf you would like expand the listbox as soon as the dropdown input is focused, you can use the `open-on-focus` prop.\noptions-appearance\tstring\tundefined\tFor multi-select dropdowns, this prop allows you to customize the look and feel of the selected options. Possible values are `default` (the default) or `checkbox`.\nmultiple\tboolean\tfalse\tWhen set to `true`, the dropdown will allow the user to select multiple options.\nbehavior\tstring\tundefined\tRenders the listbox directly over the input to maximize the available size for the list.\nalways-load-on-open\tboolean\tfalse\tDetermines whether the dropdown should always load its options when opened or whether it should reference the options that were previously found when opening.\nload-on-created\tboolean\tfalse\tWhen set to `true`, the dropdown will load the options when the node is created.\nmax\tnumber | string\tundefined\tIf you would like to limit the number of options that can be selected, you can use the `max` prop (applies only to multi-select).\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nSelector structure\nSelect t-shirt color\nSelect t-shirt color\n⌄\n⌛\n×\nTurn sound effects on and off.\nSomething wrong happened.\nListbox structure\nNo options to display.\n✔️\nGray\n⏳\nSelection structure\nDropdown Single\nGray\nDropdown Truncate\nGray\nBlue\n+1\nDropdown Tags\nGray\n×\nBlue\n×\nSection-key\tDescription\nselector\tThe selector section is a button element that opens the dropdown options list.\nselection\tContains the selected option.\nlistitem\tA list item element that contains the option section.\noption\tA div that contains the option content.\nlistbox\tThe listbox section is a ul element that contains the options list.\ndropdownWrapper\tWraps the listbox section. A div that handles scrolling the listbox.\noptionLoading\tA span element that is conditionally rendered within the selected option when loading is occurring.\nloaderIcon\tAn element for outputting an icon in the selector element when loading is occurring.\nselectIcon\tAn element for outputting an icon in the selector element when the dropdown is closed.\nselectedIcon\tAn element for outputting an icon next to the selected option when inside the listbox.\nloadMore\tA list item element that is conditionally rendered at the bottom of the options list when there are more pages to load.\nloadMoreInner\tA span element that acts as a wrapper for the loaderIcon within the loadMore section.\nemptyMessage\tA list item element that is conditionally rendered when there are no options to display.\nemptyMessageInner\tA span element that acts as a wrapper for the emptyMessage section.\ntagsWrapper\tA div element that wraps the tags section.\ntags\tA div element that contains the tags.\ntagWrapper\tA div element that wraps the tag.\ntag\tA div element that contains the tag label and removeSelection section.\ntagLabel\tA span element that contains the tag label.\nremoveSelection\tA span element that contains the removeSelection icon.\nselectorSelectionsWrapper\tA div element that wraps the selectorSelections section.\nselectorSelections\tA div element that contains the selectorSelectionsItem sections.\nselectorSelectionsItem\tA div element that contains the selectorSelectionsItem content.\ntruncationCount\tA div element that contains the truncationCount content.\nShow Universal section keys"
  },
  {
    "title": "Datepicker Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/datepicker",
    "html": "Datepicker\nView pricing →\nBasic example\nModes\nDual entry\nPicker only\nDate format\nStyled formats\nToken formats\nPanel sequence\nSelecting time\nValues\nDate styles\nToken formats\nSetting values (hydrating)\nValue locale\nTimezones\nA case study\nIndeterminate timezone\nSpecifying a timezone\nDisabling dates\nMin date\nMax date\nDisabled days\nScan for availability\nClearable\nProps & Attributes\nSections\nOverlay\nYears panel\nMonths panel\nDay panel\nTime panel\nSection keys\nPro installation quickstart 🚀\nBasic example\n\nThe datepicker input allows users to select a date from a customizable calendar, and type the date directly into the input with full internationalization support.\n\nDatepicker Overview\n\n5 mins\n\nRender\nHTML\nModes\n\nFormKit uses a unique masking solution to allow users to type dates into the datepicker input (while limiting the available options to only valid values) or select their date via a calendar input.\n\nDual entry\nText entry - By default, users can click or tab into any of the \"parts\" of the displayed date (month, date, year, etc.) in the text input and type their desired value. Matching values will be displayed with automatic completion. In addition to typing, users can hit the up/down arrow keys to cycle through available options for each segment.\nPicker entry - By clicking the \"calendar\" icon to the right of the input, users can also display a calendar popup to select their date visually:\nRender\nHTML\nPLACEHOLDER & OVERLAY\n\nTo show a placeholder when in dual entry mode, you must enable the mask overlay. This is not necessary with picker-only enabled. Learn more about masks and overlays here.\n\nPicker only\n\nYou can disable the text-entry mechanism and ensure someone uses the datepicker dialog to enter their date by adding the picker-only prop. In picker-only mode, clicking on the input will open the dialog immediately. Additionally, using an overlay is not required for placeholder support:\n\nRender\nHTML\nDate format\n\nThe datepicker supports Intl.DateTimeFormat \"styled dates\", as well as token-based date formats. To change the format displayed to the user, modify the format prop.\n\nStyled formats\n\nIf your audience is international, you should consider sticking with \"styled dates\" since they are the most natural date formats in each locale. The default format for a datepicker is long.\n\nThe format prop can accept a simple string like long or medium, in which case it uses the corresponding Intl.DateTimeFormat dateStyle. Alternatively, you can provide an object with date and time properties and their respective Intl.DateTimeFormat styles ({ date: 'long', time: 'short' }).\n\nRender\nHTML\nDate styles\n\nEnable any of the following date styles with the format prop:\n\nFormat Style\tExamples\nfull\tWednesday, March 1, 2023, Mercoledì 1 marzo 2023\nlong\tMarch 1, 2023, 1 marzo 2023\nmedium\tMar 6, 2023, 6 mar 2023\nshort\t3/1/23, 1/3/23\nTime styles\nFormat style\tExamples\nlong\t7:05:00 PM, 19:05:00\nmedium\t7:05:00 PM, 19:05:00\nshort\t7:05 PM, 19:05\nToken formats\n\nYou can use the format prop to explicitly set a tokenized date format. A token format is represented by a string with any arbitrary characters and one or more of the strings in the table below.\n\nFormKit interfaces with the Intl.DateTimeFormat to automatically internationalize tokens based on the current locale. For example, the token MMMM for 2000-01-01 would produce January for the en locale but would produce 一月 for the zh locale.\n\nDATES REQUIRED\n\nIt is possible, when using tokens, to create non-parsable dates. For example, if your input only displays the day of the week (dddd). You can use non-parsable date formats only in picker-only mode. If you’d like to allow your users to type in their date, your format must include at least a month, day, and year token.\n\nToken\tExamples\tDescription\nYY\t99, 23, 00\t2 digit year\nYYYY\t1999, 2023, 2100\t4 digit year\nM\t1, 12\tThe month 1-12\nMM\t01, 12\tThe month 01-12\nMMM\tJan, Feb\tShort name Jan-Dec\nMMMM\tJanuary, February\tFull name January - December\nD\t1, 9, 22\tThe day of the month 1-31\nDD\t01, 09, 22\tThe day of the month 01-31\nd\tM, T, W, T, F, S, S\tSingle digit day \"T\"\nddd\tThu, Sat\tShort day name \"Thu\"\ndddd\tMonday, Tuesday\tFull day name \"Wednesday\"\nH\t0, 13, 23\tMinimum hour digits, 24 hour, 0-23\nHH\t00, 13, 23\t2 hour digits, 24 hour, 00-23\nh\t12, 1, 11\tMinimum hour digits, 12 hour clock, 1-12\nhh\t12, 01, 11\t2 hour digits, 12 hour clock, 01-12\nm\t1, 59\tThe minute 0-59\nmm\t01, 59\tThe minute 00-59\ns\t1, 59\tThe second 0-59\nss\t01, 59\tThe second 00-59\na\tam, pm\tam/pm\nA\tAM, PM\tAM/PM\nINTERNATIONALIZATION\n\nAlthough FormKit will internationalize your tokens automatically — if your form is intended for a broadly international audience consider using date styles instead of tokens as this leads to a more readable date in many locales.\n\nRender\nHTML\nEscaping tokens\n\nTo include letters in the your format that are themselves tokens (like a), you can escape those tokens with a backslash \\ before the character:\n\nRender\nHTML\nPanel sequence\n\nThe datepicker’s calendar popup has four \"panels\":\n\nday — Shows a traditional calendar view of a month with each day selectable.\nmonth — Shows the 12 months of the year.\nyear — Shows a decade of years at a time.\ntime — Shows the time of day.\n\nWhen a user opens the datepicker’s popup, they will be shown one or more of these panels. You can modify which panels are displayed to the user and the sequence those panels should be displayed in by providing a sequence prop. The default sequence value is ['day'] (which allows you to navigate to the month and year panels).\n\nFor example, when selecting a birthday, it is natural to first select the birth year, then the month, then the day. The sequence prop allows this behavior:\n\nRender\nHTML\nSelecting time\n\nThe time panel can be used to allow a user to select a specific time of day. If you choose a format that includes time (like YYYY-MM-DD HH:mm), you’ll likely want to include time panel to your sequence:\n\nRender\nHTML\nValues\n\nLike all inputs, the value of the datepicker is both what is produced by the datepicker, and what is read back into the datepicker for hydration. By default, the format of the value is a UTC-normalized ISO8601 string (example: 2014-11-27T03:59:00.000Z). However, this format can be changed to any of the supported date style or a token formats listed above by using the value-format prop.\n\nA valid question is why not always use ISO8601? Although it’s the most popular way to work with dates — it’s machine and human readable — it’s not very human readable. For example, if your form sends a contact request email to a catering business, then ISO8601 would likely not be the best choice.\n\nCOMPLETE DATES\n\nThe value format must contain all the necessary data to re-constitute a date object, at a minimum this includes month, day, year. If your input requests information from the user that is not represented in your value format, those details will be lost.\n\nDate styles\n\nTo use a date style as the value, simply pass the style you’d like to use to the value-format prop:\n\nRender\nHTML\nToken formats\n\nValues can also be represented in any arbitrary format by using formatting tokens:\n\nRender\nHTML\nSetting values (hydrating)\n\nValues passed to a datepicker must:\n\nMatch the value-format in the current value-locale OR,\nBe a native JavaScript Date object.\n\nAlthough native Date objects are always accepted as valid inputs for a datepicker, they will be immediately transformed into the value-format specified.\n\nMatching the value-format\nRender\nHTML\nUsing a native Date\nRender\nHTML\nValue locale\n\nSince the format of the value needs to be parsed using the same locale it was created with, it is recommended to always specify the value-locale when defining a custom value-format. This ensures that no matter what the locale of the user entering the date is, the value will stay consistent:\n\nTIMEZONE VS LOCALE\n\nChanging the value-locale has no effect on the timezone of the date being picked. See the timezone documentation below for further explanation.\n\nRender\nHTML\nTimezones\n\nTime is a notoriously hard thing to work with in any software environment, but especially browser-based JavaScript. The datepicker provides some options to help work around these challenges.\n\nTimezones, dates, and formats case study\nIndeterminate timezone\n\nBy default, the datepicker uses the client’s local timezone when a selection is made. The value of the output is determined by the value-format (see above) — by default this is a UTC normalized ISO8601 string. However, by specifying a custom format, you can achieve an \"indeterminate\" time (also called \"wall time\"). This is a date and/or time with no specific correlation to a given timezone.\n\nFor example, when you set an alarm on your phone for 8:00 AM — that time is \"indeterminate\" — it has no correlation to timezone. If you live in Rome, and travel to Tokyo, your alarm will ring at 8:00 AM in Tokyo the same as it would ring at 8:00 AM in Rome. It’s impossible to represent a this as UTC.\n\nYou can achieve indeterminate time with the datepicker by providing no timezone or offset information in your value-format — it is up to the interpreter of the date to add that information. The tokens in a value-format always output local client values — so by leaving any timezone or offset (Z) data out of the value, it is inherently \"indeterminate\":\n\nRender\nHTML\nSpecifying a timezone\n\nFor some applications, it is necessary to select the time in a given location — this can be quite challenging. To help ease this pain, the datepicker supports the ability to explicitly specify the timezone of the input.\n\nThe timezone prop lets you specify the \"location\" of the datepicker based on browser supported IANA timezones. This is important when you’d like to allow users to select a date and time in a given geographic location, no matter what the client’s location is. Some example use cases are:\n\nRestaurant reservations\nCar rental pickup time\nHotel check in time\n\nThere are plenty of times where the timezone should not be used (default’s to client time):\n\nScheduling a Zoom meeting\nSetting a reminder notification\nCreating a calendar event\n\nIn the example below, a user needs to pickup a rental car in Kolkata, India after an international flight. The user looks at their ticket — the flight arrives in Kolkata at 1:45 PM. They’d like to pick the car up 45 minutes later at 2:30 PM. These facts are true no matter where in the world the user is booking the trip from. In this case, we should set the timezone to Asia/Kolkata. The offset in Kolkata is +5:30 — so selecting 2:30 PM in Kolkata is equivalent to 09:00 AM UTC:\n\nRender\nHTML\nPOLYFILLING TIMEZONES\n\nMost browsers ship with a comprehensive IANA database built into Intl.DateTimeFormat. This is excellent since FormKit does not need to ship the (quite extensive) timezone database to the client’s browser. However, some older browser may not have the IANA database. This data can be polyfilled easily by using polyfill.io with Intl.DateTimeFormat.~timeZone.all.\n\nDisabling dates\n\nIt is often necessary to disable specific dates in the datepicker. There are three ways to disable dates in the datepicker:\n\nmin-date - a prop to control what the first available date is.\nmax-date - a prop to control what the last available date is.\ndisabled-dates - a prop to control whether or not any arbitrary date should be disabled.\n\nAny date that is disabled cannot be selected in the datepicker’s pop up, however an unavailable date can still be set as the initial value or by typing it into the input (when it isn’t in picker-only mode). To handle these edge cases the datepicker has a built-in validation rule (that cannot be disabled) that ensures only valid dates can be submitted. The validation rule’s key is invalidDate.\n\nMin date\n\nOften it is necessary to disable dates that are prior to a particular date. For example, booking a hotel room should only happen for dates in the future. To do this, use the min-date prop with either an ISO8601 compatible string or a native Date object:\n\nRender\nHTML\nMax date\n\nTo disable all dates after a given date, use the max-date prop. For example, a birthday selector should only allow past dates. To do this, use the max-date prop with either an ISO8601 compatible string or a native Date object:\n\nRender\nHTML\nMIN & MAX DATES TOGETHER\n\nYou can use min-date and max-date at the same time. Not only will this limit the range of dates, but additionally it will limit the available years to only valid years when using text entry.\n\nDisabled days\n\nOften our applications require substantially more granularity when disabling dates than min-date and max-date allows. The datepicker allows fine-grained control by leveraging the disabled-days prop.\n\nThe disabled-days prop expects a function that is passed 2 arguments: the core node and a Date object. The responsibility of the function is to return a boolean indicating if the date is disabled (true is disabled).\n\nThe disabled-days prop supersedes min-date and max-date — you can choose to re-implement the base functionality by accessing node.props.minDate or node.props.maxDate.\n\nFAST AND SYNCHRONOUS\n\nIt’s important that the provided function is fast and synchronous — it will be called frequently and repeatedly. For example, if you need to fetch information from a database, do it outside of this function and use this function to access memoized results.\n\nExample: disabled weekends\nRender\nHTML\nExample: fetch from API\nRender\nHTML\nScan for availability\n\nWhen navigating the calendar pop up via keyboard, the datepicker will not allow you to select a disabled date. However this can be annoying as it can create areas of inaccessibility if some available dates are \"sandwiched\" between unavailable dates.\n\nTo make the user experience better, the datepicker will automatically scan forward or backward (depending on the direction desired) for the next available date to select. The maximum number of days to scan for an available day is controlled by the maxScan prop (7 days by default):\n\nExample: max-scan\nRender\nHTML\nClearable\n\nThe datepicker input can be cleared by clicking the \"clear\" button that appears when the input has a value — this clear button only appears when the clearable prop is added:\n\nRender\nHTML\nProps & Attributes\nProp\tType\tDefault\tDescription\nclearable\tstring\tfalse\tAdds a clear button to the right of the value. This button only appears when the input has a completed value.\ndate-format\tstring\tD\tThe token format to use in the calendar for dates in the month.\ndisabled-days\tfunction\tmin/max date logic\tA function that is passed the core node and a `Date` object and must return if the date is disabled (`true` is disabled).\nformat\tstring/object\tdate: 'long'\tThe format to display to the user in the select input.\nmax-date\tDate | ISO8601\tnone\tThe maximum date the user is allowed to select.\nmax-scan\tnumber\t7\tThe maximum number of days to scan forward or backward when looking for an available date to jump to via keyboard navigation.\nmin-date\tDate | ISO8601\tnone\tThe earliest date the user is allowed to select.\nmonth-button-format\tstring\tMMMM\tThe date format token to use for the month panel button in the calendar popup.\nmonth-format\tstring\tMMMM\tThe date format token to use for each of the 12 months on the month panel.\noverlay\tboolean\tfalse\tWhether or not to display a mask overlay. Read more about overlays in the mask input documentation (has no effect in pickerOnly` mode).\npicker-only\tboolean\tfalse\tWhether or not to allow the date to be entered via text input. When picker-only is enabled, only the picker can be used to select a date.\nshow-months\tnumber\t1\tThe number of months to render in the popup when on the day panel.\nsequence\tarray\t['day']\tThe sequence of panels to walk a user through when they open the datepicker calendar view. Options are `year`, `month`, `day`, `time`.\nvalue-format\tstring/object\tISO8601\tThe format to record as the value of the input. This can be composed with any token format, date style, or `ISO8601`.\nvalue-locale\tstring\t`node.props.locale`\tThe locale to use for the `valueFormat`. When using format tokens in the `valueFormat` prop it is highly recommend to set an explicit `valueFormat`.\nweek-start\tnumber\t0\tThe day of the week to start the `day` panel’s calendar on. 0-6 where 0 = Sunday and 6 = Saturday.\nweek-day-format\tstring\td\tThe date format token used to render the day of the week column headers.\nyear-format\tstring\tYYYY\tThe date format token used to render the years in the `year` panel.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema), or content (via slots). Read more about sections here.\n\nwrapper\nlabel\ninner\nprefixIcon\nprefix\ninput\nmessages\nmessage\nSelect a date\nNovember 26, 2014\n📅\nPick your arrival date.\nSorry, that date is not available.\nouter\nopenButton\ncalendarIcon\nsuffix\nsuffixIcon\nhelp\nOverlay\n\nThis section is located inside the inner section when the overlay prop is added.\n\noverlay\noverlay-parts\noverlayPlaceholder\noverlayLiteral\noverlayChar\noverlayEnum\nYears panel\n\nThe panel appears below the input element inside the inner section when the datepicker popup is open.\n\npanel-header\nprev\nprev-label\nprev-icon\nyears-header\nyears\nyear\nPrev\n👈\n2010 - 2020\nNext\n👉\n2010\n2011\n2012\n2013\n2014\n2015\n2016\n2017\n2018\n2019\npanel-wrapper\nnext\nnext-label\nnext-icon\npanel\nMonths panel\n\nThe panel appears below the input element inside the inner section when the datepicker popup is open.\n\nmonths-header\nmonths\nmonth\n2027\nX\nJan\nFeb\nMar\nApr\nMay\nJun\nJul\nAug\nSep\nOct\nNov\nDec\npanel-wrapper\npanel-header\nyear-button\npanel-close\nclose-icon\npanel\nDay panel\n\nThe panel appears below the input element inside the inner section when the datepicker popup is open.\n\npanel-header\nprev\nprev-label\nprev-icon\ndays-header\ncalendar-header\nweek-day\nweek\nday-cell\nday\nPrev\n👈\nFeb\n2026\nNext\n👉\nX\nS\nM\nT\nW\nT\nF\nS\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\npanel-wrapper\nmonth-button\nyear-button\nnext\nnext-label\nnext-icon\npanel-close\nclose-icon\npanel\ncalendar\nweek-days\ncalendar-weeks\nTime panel\n\nThe panel appears below the input element inside the inner section when the datepicker popup is open.\n\npanel-header\nmonth-button\nday-button\ntime\nFebruary\n17\n2027\nX\n12:00 AM\npanel-wrapper\ntime-header\nyear-button\npanel-close\nclose-icon\npanel\ntime-input\nSection keys\nSection-key\tDescription\ncalendar\tThe wrapper immediately around the calendar on the day panel.\ncalendarHeader\tThe wrapper around the header columns on the day panel.\ncalendarWeeks\tThe wrapper immediately around each row of weeks on the day panel.\nday\tThe content of the day — by default contains the numeric day. In this slot/section you can use context.day ($day in schema) to get the date object for the given day.\ndayButton\tThe button displayed in the header of the time panel which navigates to the day panel.\ndayCell\tThe wrapper immediately around the date section. In this slot/section you can use context.day ($day in schema) to get the date object for the given day.\ndaysHeader\tThe wrapper around the header columns on the date panel.\nmonth\tThe section that renders the actual month names on the month panel. In this slot/section you can use context.month ($month in schema) to get the date object for the given month.\nmonthButton\tThe button in the header of the day and time panels that navigates to the month panel.\nmonths\tThe wrapper immediately around the month sections on the month panel.\nmonthsHeader\tThe wrapper immediately around the header buttons (yearButton) on the month panel.\nnext\tIn the panel header the button responsible for navigating to the next month or decade.\nnextLabel\tThe section responsible for rendering the text content of the next button in the panel header.\npanelClose\tThe section responsible for rendering the close button of the datepicker, shown on small touch devices.\ncloseIcon\tThe icon rendered inside the panelClose section.\nopenButton\tThe button responsible for opening the picker dialog.\noverlay\tThe outer wrapper of the overlay. The overlay is used to mimc the text that is in the text input during text-entry mode to allow for styling.\noverlayChar\tA section containing overlay characters of type char\noverlayEnum\tA section containing overlay characters of type enum\noverlayInner\tAn inner wrapper immediately inside the overlay section.\noverlayLiteral\tA section containing overlay characters of type literal\noverlayParts\tA section containing all the overlay parts as immediate children.\noverlayPlaceholder\tA section containing overlay characters of type placeholder.\npanel\tA wrapper around the currently active panel. This is rendered below the panelHeader as a sibling.\npanelHeader\tA wrapper around the header of each panel where the panel’s navigation buttons are located. This is a sibling of the panel section.\npanelWrapper\tA wrapper around the panel and panelHeader sections, this section is responsible for showing or hiding the picker dialog.\nprev\tIn the panel header the button responsible for navigating to the previous month or decade.\nprevLabel\tThe section responsible for rendering the text content of the prev button in the panel header.\ntime\tThe time panel that contains the timeInput.\ntimeHeader\tThe panel header of the time panel with navigation buttons to the year, month, and day panels.\ntimeInput\tA native HTML time input responsible for setting the time of the selected date.\nweek\tA wrapper around a row of 7 days on the day panel.\nweekDay\tThe cell responsible for rendering the day of the week in the calendar header of the day panel (M, T, W etc...).\nweekDays\tThe wrapper element around the days of the week on the calendar’s header on the day panel.\nyear\tThe element responsible for rendering each of the years available on the year panel.\nyearButton\tThe button in the header of the month, day, and time panels that navigates to the year panel.\nyears\tThe years panel, responsible for rendering a decade of years at a time.\nyearsHeader\tThe panel header when on the years panel, shows the current decade year range.\nShow Universal section keys"
  },
  {
    "title": "Date Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/date",
    "html": "Date\nBasic example\nProps & Attributes\nSections\n\nThe date input uses HTML's native date picker to allow users to easily select a date.\n\nPRO ALTERNATIVE\n\nNeed more flexibility than the native HTML date input provides? Check out the datepicker input available in FormKit Pro.\n\nBasic example\nRender\nHTML\nFORMATTING\n\nThe internal format of all native date pickers is YYYY-MM-DD. This is true even though the format of the date displayed to the user may be different. For example U.S. based browsers display date format as MM/DD/YYYY.\n\nProps & Attributes\n\nThe date input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nCommonly used native attributes\nmin\tNumber\t--\tView on MDN\nmax\tNumber\t--\tView on MDN\nstep\tNumber\tauto\tView on MDN\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nDate of birth\n📅\nJan. 1 1970\n👌\nPlease tell us your date of birth.\nDate is required.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Color Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/color",
    "html": "Color\nBasic example\nProps & Attributes\nSections\n\nThe color input uses HTML's native color picker to allow users to easily select a hexadecimal color.\n\nBasic example\nRender\nHTML\nProps & Attributes\n\nThe color input has no unique props but can make use of the following universal FormKit props.\n\nProp\tType\tDefault\tDescription\nconfig\tObject\t{}\tConfiguration options to provide to the input’s node and any descendent node of this input.\ndelay\tNumber\t20\tNumber of milliseconds to debounce an input’s value before the commit hook is dispatched.\ndirtyBehavior\tstring\ttouched\tDetermines how the \"dirty\" flag of this input is set. Can be set to touched or compare — touched (the default) is more performant, but will not detect when the form is once again matching its initial state.\nerrors\tArray\t[]\tArray of strings to show as error messages on this field.\nhelp\tString\t''\tText for help text associated with the input.\nid\tString\tinput_{n}\tThe unique id of the input. Providing an id also allows the input’s node to be globally accessed.\nignore\tBoolean\tfalse\tPrevents an input from being included in any parent (group, list, form etc). Useful when using inputs for UI instead of actual values.\nindex\tNumber\tundefined\tAllows an input to be inserted at the given index if the parent is a list. If the input’s value is undefined, it inherits the value from that index position. If it has a value it inserts it into the lists’s values at the given index.\nlabel\tString\t''\tText for the label element associated with the input.\nname\tString\tinput_{n}\tThe name of the input as identified in the data object. This should be unique within a group of fields.\nparent\tFormKitNode\tcontextual\tBy default the parent is a wrapping group, list or form — but this props allows explicit assignment of the parent node.\nprefix-icon\tString\t''\tSpecifies an icon to put in the prefixIcon section.\npreserve\tboolean\tfalse\tPreserves the value of the input on a parent group, list, or form when the input unmounts.\npreserve-errors\tboolean\tfalse\tBy default errors set on inputs using setErrors are automatically cleared on input, setting this prop to true maintains the error until it is explicitly cleared.\nsections-schema\tObject\t{}\tAn object of section keys and schema partial values, where each schema partial is applied to the respective section.\nsuffix-icon\tString\t''\tSpecifies an icon to put in the suffixIcon section.\ntype\tString\ttext\tThe type of input to render from the library.\nvalidation\tString, Array\t[]\tThe validation rules to be applied to the input.\nvalidation-visibility\tString\tblur\tDetermines when to show an input's failing validation rules. Valid values are blur, dirty, and live.\nvalidation-label\tString\t{label prop}\tDetermines what label to use in validation error messages, by default it uses the label prop if available, otherwise it uses the name prop.\nvalidation-rules\tObject\t{}\tAdditional custom validation rules to make available to the validation prop.\nvalue\tAny\tundefined\tSeeds the initial value of an input and/or its children. Not reactive. Can seed entire groups (forms) and lists..\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nFavorite color\n🎨\nColor selector here\n👍\nSelect your favorite color.\nOnly primary colors allowed.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Colorpicker Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/colorpicker",
    "html": "Colorpicker\nView pricing →\nBasic example\nColor formats\nSupported formats\nValue format\nSwatches\nSimple swatches\nGrouped swatches\nSwatch-only\nInputting by swatch name\nEyedropper\nPasting values\nProps & Attributes\nSections\nPop-over structure (default)\nInline structure\n\nThe colorpicker input allows for advanced color selection — including alpha channel support. It supports colors in Hex, HSLA and RGBA formats and can be configured to provide a preset list of colors.\n\nMost importantly, unlike the native color input, the colorpicker provides a consistent, predictable, and accessible user experience across browsers and operating systems.\n\nThe colorpicker input is fully keyboard navigable and ships with accessible markup.\n\nBasic example\nLoad live example\nColor formats\nSupported formats\n\nThe colorpicker supports formats in Hex, HSLA and RGBA formats. You can set your desired format with the format prop and color values from the colorpicker will be returned in that format. Your chosen format will also be the default setting for the input field(s) which show up in the colorpicker panel.\n\nLoad live example\nValue format\n\nThere may be times where you wish to show one format to users as a default but return a different format. You can use the value-format prop to specify a return value format independent of the format prop.\n\nLoad live example\nSwatches\n\nSwatches are provided using the options prop and use the same options API as the select, dropdown, autocomplete and taglist inputs from FormKit.\n\nSimple swatches\n\nHere is a simple set of swatches using the options prop and providing it with a flat array of color values. Your provided values can be in any supported color format (Hex, HSLA, and RGBA) and will be automatically converted to the colorpickers speficied format which defaults to Hex.\n\nLoad live example\nGrouped swatches\n\nThe colorpicker also supports grouped options. This allows you to create sets of swatches within the color picker grouped under a common heading.\n\nLoad live example\nSwatch-only\n\nYou can create a \"swatch-only\" color-picker by using the panel-controls and panel-format props and setting them to false.\n\nWhen showing only swatches in pop-over mode (the default) adding the close-on-select prop will close the pop-over when a swatch is selected.\n\nLoad live example\nInputting by swatch name\n\nIf your provided swatches via the options prop have labels then you can call node.input() with a swatch name and the associated color will be set for you.\n\nLoad live example\nEyedropper\n\nThe colorpicker input supports the browser-native EyeDropper API. If the EyeDropper is supported in your browser and you have not disabled the EyeDropper by setting the eye-dropper prop to false then you will see an eyedropper button to the right of the hue and alpha sliders.\n\nLoad live example\nPasting values\n\nBy default a colorpicker input will allow the pasting of any valid color values while user focus is anywhere in the input. Values will be converted immediately to your desired format.\n\nYou can disable the ability to paste a value by setting the allow-paste prop to false.\n\nLoad live example\nProps & Attributes\nProp\tType\tDefault\tDescription\nformat\tstring\thex\tThe format that the colorpicker input should show in the input preview and be the default setting for the picker panel input. Can be set to hex, hsla or rgba.\nvalue-format\tstring\tundefined\tThe format that should be returned from the colorpicker input regardless of the displayed format. If not specified the value of the format prop will be used.\npanel-controls\tboolean\ttrue\tUsed to control the display of the Lightness/Saturation gradient and the Hue and Alpha sliders.\npanel-format\tboolean\ttrue\tUsed to control whether the display of the color input fields and format switcher button.\neye-dropper\tboolean\ttrue\tUsed to control the display of the eye-dropper control. Requires a browser that supports the EyeDropper API. If enabled in an unsupported browser the control will behave as if set to false.\ninline\tboolean\tfalse\tWhen set to true the `colorpicker` will render its panel as an inline element rather than as a pop-over.\noptions\tArray/Object\t[]\tAn object of value/label pairs or an array of strings, or an array of objects that must contain a label and value property. Supports grouped options via an array of objects that contain group and options keys where options is a nested options definition. Grouping is only supported at one level of depth.\nshow-value\tboolean\ttrue\tUsed to control the display of the current color value in the input preview. Uses the format prop to determine which value to display.\nclose-on-select\tboolean\tfalse\tWhen set to true the colorpicker panel will close when a preset swatch option is chosen.\nallow-paste\tboolean\ttrue\tAllows pasting any valid color string of Hex, HSLA, or RGBA format into a colorpicker that contains the user's focus. The pasted string will immediately be set as the value of the colorpicker and converted to the desired format.\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nThe colorpicker input's structure changes depending on the existence of the inline prop:\n\nPop-over structure (default)\nInput Preview\nChoose a color\n⬛️\n#000000\nPick your favorite color.\nColor is required\nPop-over panel\n(panelClose is only shown on small touchscreens when in pop-over mode)\nⓧ\n🖼️\n⊙\n⬛️\n🌈\n⊙\n👻\n⊙\n👁️\n#️⃣\n0️⃣\n0️⃣\n0️⃣\n0️⃣\n0️⃣\n0️⃣\n1️⃣\n↕\n🟦\n🟥\n🟨\nInline structure\nChoose a color\nPick your favorite color.\n🖼️\n⊙\n⬛️\n🌈\n⊙\n👻\n⊙\n👁️\n#️⃣\n0️⃣\n0️⃣\n0️⃣\n0️⃣\n0️⃣\n0️⃣\n1️⃣\n↕\n🟦\n🟥\n🟨\nColor is required\nSection-key\tDescription\nswatchPreview\tA wrapping div around the swatch preview canvas element and the displayed color value string.\ncanvasSwatchPreview\tA canvas element that renders the current color selection.\nvalueString\tA span element that contains the current color value string in the format set via the format prop.\npanel\tThe wrapping element for all of the colorpicker controls\npanelClose\tA prefix seciton of the panel that contains a close button. Only shown on small touchscreen devices where a 'fixed position' treatment is applied.\niconClose\tAn element for outputting an icon within the panelClose section.\ncontrolGroup\tA wrapping element for all of the color control elements within the panel\npreview\tA wrapping element for the current color preview.\ncanvasPreview\tA canvas element that renders the current color selection.\nLS\tA wrapping element for the Lightness/Saturation controls\ncanvasLS\tA canvas element that renders the currently avilable colors given the current hue.\ncontrolLS\tAn element styled as the control for the LS canvas.\nhue\tA wrapping element for the hue controls\ncanvasHue\tA canvas element that renders every available hue at 50% lightness.\ncontrolHue\tAn element styled as the control for the hue canvas.\nalpha\tA wrapping element for the alpha controls\ncanvasAlpha\tA canvas element that renders the currently selected color from 0% to 100% opacity.\ncontrolAlpha\tAn element styled as the control for the alpha canvas.\neyeDropper\tAn element that acts as a trigger for enabling the browser's EyeDropper API. Only displays in supported browsers.\niconEyeDropper\tAn element for outputting an icon within the eyeDropper section.\nformatField\tA wrapping element that contains all of the color format input fields and the format toggle control. Only the field(s) relevant to the currently selected panel format will be displayed.\ncolorInputGroup\tA wrapping element that wraps one or more input fields associated with a given color format.\nhexField\tThe input for a hex color format. Supports #RRGGBBAA format although alpha hex values are not required.\nrField\tThe input for the R value of an RGBA color format.\ngField\tThe input for the G value of an RGBA color format.\nbField\tThe input for the B value of an RGBA color format.\nhField\tThe input for the H value of an HSLA color format.\nsField\tThe input for the S value of an HSLA color format.\nlField\tThe input for the L value of an HSLA color format.\naField\tThe input for the A value of an RGBA or HSLA color format.\nformatSwitcher\tAn element that acts as a trigger for changing the currently displayed color format within the colorpicker panel. Has no effect on the format and value-format settings of the input.\niconSwitch\tAn element for outputting an icon within the formatSwitcher section.\nswatches\tA wrapping element that contains all available swatches made available via the options prop.\nswatch\tAn element that handles the rendering of each option (or option group) provided by the options prop.\nShow Universal section keys"
  },
  {
    "title": "Checkbox Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/checkbox",
    "html": "Checkbox\nSingle checkbox\nMultiple checkboxes\nArray of strings\nValue / Label object\nArray of objects\nProps & Attributes\nSections\nSingle checkbox diagram\nMultiple checkbox diagram\n\nThe checkbox input uses HTML's native checkbox input. It can display one or many options to a user and is a great way to allow users to select multiple items from a list. FormKit supports both single and multiple checkbox inputs.\n\nSingle checkbox\n\nBy default the checkbox type will render a single checkbox and uses boolean values. In order for a single checkbox to be checked — the current value of the input must match the on-value of that input (by default, a single checkbox uses true as the on-value).\n\nRender\nHTML\nCHECKED ATTRIBUTE UNNECESSARY\n\nIn order to improve API consistency across all FormKit inputs — FormKit uses the value as the initial state of the input. The checked prop/attribute should not be used directly.\n\nMultiple checkboxes\n\nTo output multiple checkboxes with a single input use the options prop. Options can be specified 3 ways:\n\nAn array of strings\nAn object of value/label pairs\nAn array of objects with label and value properties (the same as the select and radio inputs)\n\nThe value of a checkbox input with multiple options is an array of the selected values.\n\nArray of strings\n\nThe simplest way to provide options is an array of strings. The provided strings will be used for both the label and the value of the option.\n\nRender\nHTML\nValue / Label object\n\nYou may also provide the options prop where the keys are values and the values of each property are labels.\n\nRender\nHTML\nArray of objects\n\nThe most flexible way to define options is by providing an array of objects. The objects must include value and label properties — but may also include a help property as well as an attrs object of additional attributes to apply to each checkbox input tag.\n\nRender\nHTML\nProps & Attributes\nProp\tType\tDefault\tDescription\ndecorator-icon\tString\t’’\tSpecifies an icon to put in the decoratorIcon section. Shows when the checkbox is checked. Defaults to the checkboxDecorator icon.\noptions\tArray/Object\t[]\tAn object of value/label pairs or an array of strings, or an array of objects that must contain a label and value property.\non-value\tany\ttrue\tThe value when the checkbox is checked (single checkboxes only).\noff-value\tany\tfalse\tThe value when the checkbox is unchecked (single checkboxes only).\nShow Universal props\nSections\n\nThe checkbox input has a different construction depending on if it's a single or multiple checkbox.\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nSingle checkbox diagram\ninner\nprefix\ninput\ndecorator\ndecoratorIcon\nsuffix\n✅\nI would like a free t-shirt\nWe will send a free-shirt if you have this box selected.\nYou must make a selection.\nouter\nwrapper\nlabel\nhelp\nmessages\nmessage\nMultiple checkbox diagram\nouter\nfieldset\ninner\nprefix\ninput\ndecorator\ndecoratorIcon\nsuffix\nTopics\nChoose the topics you`d like to learn this year.\n✅\nGardening\nWe`ll be studying soil, plants, and seasons.\nYou must make a selection.\nlegend\nhelp\noptions\noption\nwrapper\nlabel\noptionHelp\nmessages\nmessage\nSection-key\tDescription\ndecorator\tResponsible for the element immediately following the input element — usually used for styling custom checkboxes.\ndecoratorIcon\tAn element containing the decorator icon.\nlegend\tResponsible for the fieldset’s legend element.\nfieldset\tResponsible for the fieldset when multiple options are available.\noption\tResponsible for the wrapper around each item in the options.\noptions\tResponsible for the wrapper element around all of the option items.\nShow Universal section keys"
  },
  {
    "title": "Button Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/button",
    "html": "Button\nBasic example\nDefault slot\nEvent listeners\nIgnored input\nProps & Attributes\nSections\n\nThe button input uses HTML's native button element. The label prop is used to populate the text of the button — or alternatively you can use the default slot.\n\nBasic example\n\nThe easiest way to set the label of a button is with the label prop:\n\nRender\nHTML\nDefault slot\n\nThe default slot can also be used to add text and UI to the button:\n\nRender\nHTML\nEvent listeners\n\nYou can also bind event listeners:\n\nRender\nHTML\nIgnored input\n\nsubmit and button input types have a few unique behaviors because they are \"ignored inputs\" by default — meaning they have their ignoreprop set to true:\n\nPlugins are not inherited - Ignored inputs do not inherit plugins from ancestors.\nTheir values are not included in parent forms - Ignored inputs do not contribute their value to any wrapping groups or forms for submission.\nValidation does not run - Ignored inputs do not run validation.\n\nIf you need plugins to be inherited or validation to run on a buttonor submit, you can change :ignoreto false:\n\n<FormKit type=\"button\" :ignore=\"false\">\n\n  Add a section\n\n</FormKit>\nProps & Attributes\n\nThe button input is unique in that it does not actively receive input other than a transient click. However, nearly all of the base input props still technically exist on the input.\n\nProp\tType\tDefault\tDescription\nconfig\tObject\t{}\tConfiguration options to provide to the input’s node and any descendent node of this input.\ndelay\tNumber\t20\tNumber of milliseconds to debounce an input’s value before the commit hook is dispatched.\ndirtyBehavior\tstring\ttouched\tDetermines how the \"dirty\" flag of this input is set. Can be set to touched or compare — touched (the default) is more performant, but will not detect when the form is once again matching its initial state.\nerrors\tArray\t[]\tArray of strings to show as error messages on this field.\nhelp\tString\t''\tText for help text associated with the input.\nid\tString\tinput_{n}\tThe unique id of the input. Providing an id also allows the input’s node to be globally accessed.\nignore\tBoolean\tfalse\tPrevents an input from being included in any parent (group, list, form etc). Useful when using inputs for UI instead of actual values.\nindex\tNumber\tundefined\tAllows an input to be inserted at the given index if the parent is a list. If the input’s value is undefined, it inherits the value from that index position. If it has a value it inserts it into the lists’s values at the given index.\nlabel\tString\t''\tText for the label element associated with the input.\nname\tString\tinput_{n}\tThe name of the input as identified in the data object. This should be unique within a group of fields.\nparent\tFormKitNode\tcontextual\tBy default the parent is a wrapping group, list or form — but this props allows explicit assignment of the parent node.\nprefix-icon\tString\t''\tSpecifies an icon to put in the prefixIcon section.\npreserve\tboolean\tfalse\tPreserves the value of the input on a parent group, list, or form when the input unmounts.\npreserve-errors\tboolean\tfalse\tBy default errors set on inputs using setErrors are automatically cleared on input, setting this prop to true maintains the error until it is explicitly cleared.\nsections-schema\tObject\t{}\tAn object of section keys and schema partial values, where each schema partial is applied to the respective section.\nsuffix-icon\tString\t''\tSpecifies an icon to put in the suffixIcon section.\ntype\tString\ttext\tThe type of input to render from the library.\nvalidation\tString, Array\t[]\tThe validation rules to be applied to the input.\nvalidation-visibility\tString\tblur\tDetermines when to show an input's failing validation rules. Valid values are blur, dirty, and live.\nvalidation-label\tString\t{label prop}\tDetermines what label to use in validation error messages, by default it uses the label prop if available, otherwise it uses the name prop.\nvalidation-rules\tObject\t{}\tAdditional custom validation rules to make available to the validation prop.\nvalue\tAny\tundefined\tSeeds the initial value of an input and/or its children. Not reactive. Can seed entire groups (forms) and lists..\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nouter\ninput\nprefixIcon\nprefix\nlabel\nValidation messages about the button.\n🤟\nSubmit application\n🚀\nClick this button to submit your application.\nmessages\nmessage\nwrapper\nsuffix\nsuffixIcon\nhelp\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages."
  },
  {
    "title": "Autocomplete Input ⚡️ FormKit",
    "url": "https://formkit.com/inputs/autocomplete",
    "html": "Autocomplete\nView pricing →\nBasic examples\nSingle-select\nMulti-select\nFiltering\nDynamic options\nSearch parameter\nPage and hasNextPage parameters\nOption loader\nLoading Style\nLoad on created\nOption appearance\nOption slot\nSelection appearance\nSelection appearance prop\nSelection slot\nBehavioral props\nEmpty message\nClose on select\nReload on commit\nOpen on click\nOpen on focus\nClear search on open\nSelection removable\nOpen on remove\nMax\nFull example\nProps & Attributes\nSections\nSelection appearance text-input\nSelection appearance option, single selection\nSelection appearance option, multiple selection\nInner listbox structure\nPro installation quickstart 🚀\n\nThe autocomplete input allows you to search through a list of options.\n\nThe options prop can accept three different formats of values:\n\nAn array of objects with value and label keys (see example above)\nAn array of strings ['A', 'B', 'C']\nAn object literal with key-value pairs { a: 'A', b: 'B', c: 'C' }\nA function that returns any of the above\nEMPTY OPTIONS\n\nIf you assign options as an empty array, the input will be rendered in a disabled state.\n\nBasic examples\nSingle-select\n\nBy default, the autocomplete input will render in single-select mode:\n\nautocomplete-single.vue\ncountries.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n<script setup>\nimport countries from './countries.js'\n</script>\n<template>\n  <FormKit type=\"form\" #default=\"{ value }\" :actions=\"false\">\n    <FormKit\n      type=\"autocomplete\"\n      name=\"country\"\n      label=\"Search for a country\"\n      placeholder=\"Example: United States\"\n      :options=\"countries\"\n    />\n    <pre wrap>{{ value }}</pre>\n  </FormKit>\n</template>\nRender\nHTML\nLoading Example...\nMulti-select\n\nBy setting the multiple prop the autocomplete input will render in multi-select mode:\n\nautocomplete-multiple.vue\ncountries.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n<script setup>\nimport countries from './countries.js'\n</script>\n<template>\n  <FormKit type=\"form\" #default=\"{ value }\" :actions=\"false\">\n    <FormKit\n      type=\"autocomplete\"\n      name=\"country\"\n      label=\"Search for a country\"\n      placeholder=\"Example: United States\"\n      :options=\"countries\"\n      multiple\n    />\n    <pre wrap>{{ value }}</pre>\n  </FormKit>\n</template>\nRender\nHTML\nMULTI-SELECT INPUT VALUE\n\nNotice in the example above that because the multiple prop is set, the value prop must be an array.\n\nFiltering\n\nThe autocomplete input will filter options with its own internal search function. You can replace this search function by providing the filter prop a function of your own. Your function will receive two arguments, the option being iterated over and the current search value:\n\nRender\nHTML\nDynamic options\n\nInstead of passing a static list to the options prop, you can assign it to a function. Doing so is useful when you need to load options from an API or another source.\n\nSearch parameter\n\nIn this example, we'll assign the options prop the searchMovies function. By doing so, searchMovies will receive the context object as an argument. Within this context object is the search property, which is the current search value. To perform our search, we'll use the search value as the query parameter for our API request:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n<script setup>\n// Search movie receives FormKit's context object\n// which we are destructuring to get the search value.\nasync function searchMovies({ search }) {\n  if (!search) return [];\n  const res = await fetch(`https://api.themoviedb.org/3/search/movie?query=${search || ''}&api_key=f48bcc9ed9cbce41f6c28ea181b67e14&language=en-US&page=1&include_adult=false`)\n  if (res.ok) {\n    const data = await res.json()\n    // Iterating over results to set the required\n    // `label` and `value` keys.\n    return data.results.map((result) => {\n      return {\n        label: result.title,\n        value: result.id\n      }\n    })\n  }\n  // If the request fails, we return an empty array.\n  return []\n}\n</script>\n<template>\n  <!--Setting the `options` prop to async function `loadHorrorMovies`-->\n  <FormKit\n    name=\"movie\"\n    type=\"autocomplete\"\nRender\nHTML\nPage and hasNextPage parameters\n\nA likely scenario you'll encounter is needing to search through a paginated API. This can be done by referencing the same context object as before. Within this object, we can utilize the page and hasNextPage properties. The page property is the current page number, and the hasNextPage property is a function to be called when there are more pages to load:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n<script setup>\n// Search movie receives FormKit's context object\n// which we are destructuring to get the search value,\n// the page, and the hasNextPage parameters.\nasync function searchMovies({ search, page, hasNextPage }) {\n  if (!search) return [];\n  const res = await fetch(`https://api.themoviedb.org/3/search/movie?query=${search || ''}&api_key=f48bcc9ed9cbce41f6c28ea181b67e14&language=en-US&page=${page}&include_adult=false`)\n  if (res.ok) {\n    const data = await res.json()\n    if (page !== data.total_pages) hasNextPage()\n    return data.results.map((result) => {\n      return {\n        label: result.title,\n        value: result.id\n      }\n    })\n  }\n  return []\n}\n</script>\n<template>\n  <FormKit\n    name=\"movie\"\n    type=\"autocomplete\"\n    label=\"Search for your favorite movie\"\n    placeholder=\"Example: Lord of the Rings\"\nRender\nHTML\nOption loader\nRehydrating values\n\nFormKit's autocomplete input also provides an optionLoader prop that allows you to rehydrate values that are not in the options list. In this example, we'll provide the autocomplete an initial value (a movie ID), and assign the optionLoader to a function that will make a request to the API to get the movie:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n<script setup>\n// Search movie receives FormKit's context object\n// which we are destructuring to get the search value,\n// the page, and the hasNextPage parameters.\nasync function searchMovies({ search, page, hasNextPage }) {\n  if (!search) return []\n  const res = await fetch(\n    `https://api.themoviedb.org/3/search/movie?query=${\n      search || ''\n    }&api_key=f48bcc9ed9cbce41f6c28ea181b67e14&language=en-US&page=${page}&include_adult=false`\n  )\n  if (res.ok) {\n    const data = await res.json()\n    if (page !== data.total_pages) hasNextPage()\n    return data.results.map((result) => {\n      return {\n        label: result.title,\n        value: result.id,\n      }\n    })\n  }\n  return []\n}\n// The function assigned to the `option-loader` prop will be called with the\n// value of the option as the first argument (in this case, the movie ID), and\n// the cached option as the second argument (if it exists).\nRender\nHTML\n\nNotice in the example above that the optionLoader function is passed two arguments: the value of the selected option (in this case, the movie ID) and the cachedOption. The cachedOption prop is used for preventing unnecessary lookups. If the cachedOption is not null it means that the selected option has already been loaded, and you can return the cachedOption directly.\n\nLoading Style\n\nInstead of requiring your users to click the Load more button to load additional options, you can set the loadOnScroll prop to true, which will paginate options as you scroll to the bottom of the options list.\n\nLoad on created\n\nIf you would rather load options when the autocomplete is created, you can set the load-on-created prop to true, and our function, loadCurrentlyPopularMovies will be called without the user needing to expand the listbox:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n<script setup>\n// Search movie receives FormKit's context object\n// which we are destructuring to get the search value.\nasync function searchMovies({ search }) {\n  await new Promise((resolve) => setTimeout(resolve, 1000))\n  if (!search)\n    // With no search value, lets just return a list of common movies.\n    return [\n      { label: 'Saving Private Ryan', value: 857 },\n      { label: 'Everything Everywhere All at Once', value: 545611 },\n      { label: 'Gone with the Wind', value: 770 },\n    ]\n  const res = await fetch(\n    `https://api.themoviedb.org/3/search/movie?query=${\n      search || ''\n    }&api_key=f48bcc9ed9cbce41f6c28ea181b67e14&language=en-US&page=1&include_adult=false`\n  )\n  if (res.ok) {\n    const data = await res.json()\n    // Iterating over results to set the required\n    // `label` and `value` keys.\n    return data.results.map((result) => {\n      return {\n        label: result.title,\n        value: result.id,\n      }\n    })\nRender\nHTML\nOption appearance\nOption slot\n\nThe autocomplete input allows you to customize the look and feel of each option by using the option slot. In this example, we are using the option slot to display each option's asset; logo and name:\n\nautocomplete-option-slot.vue\ncar-brands.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n<script setup>\nimport carBrands from './car-brands.js'\n</script>\n<template>\n  <FormKit\n    type=\"autocomplete\"\n    name=\"autocomplete\"\n    label=\"Search for and select a car brand\"\n    placeholder=\"Example: Toyota\"\n    :options=\"carBrands\"\n    selection-appearance=\"option\"\n  >\n    <!--OPTION SLOT-->\n      <template #option=\"{ option, classes }\">\n        <div :class=\"classes.option\">\n          <img\n            :src=\"option.logo\"\n            :alt=\"option.label + ' logo'\"\n          />\n          <span>\n            {{ option.label }}\n          </span>\n        </div>\n      </template>\n    <!--/OPTION SLOT-->\n  </FormKit>\nRender\nHTML\nSelection appearance\n\nThe autocomplete input allows you to customize the look and feel of the selected option.\n\nSelection appearance prop\n\nThe autocomplete input allows you to customize the look and feel of the selected option by using the selection-appearance prop. For either the single-select or multi-select autocomplete, you can set the selection-appearance prop to text-input (default) or option:\n\nRender\nHTML\nSelection slot\n\nIf you only want to customize the display of the selected option, set the selection appearance to option.\n\nautocomplete-slot-selection.vue\ncar-brands.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n<script setup>\nconst carBrands = [{ label: 'Audi', value: 'audi', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/audi-logo.png' },{ label: 'BMW', value: 'bmw', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/bmw-logo.png' },{ label: 'Citroen', value: 'citroen', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/citroen-logo.png' },{ label: 'Dacia', value: 'dacia', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/dacia-logo.png' },{ label: 'Fiat', value: 'fiat', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/fiat-logo.png' },{ label: 'Ford', value: 'ford', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/ford-logo.png' },{ label: 'Ferrari', value: 'ferrari', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/ferrari-logo.png' },{ label: 'Honda', value: 'honda', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/honda-logo.png' },{ label: 'Hyundai', value: 'hyundai', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/hyundai-logo.png' },{ label: 'Jaguar', value: 'jaguar', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/jaguar-logo.png' },{ label: 'Jeep', value: 'jeep', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/jeep-logo.png' },{ label: 'Kia', value: 'kia', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/kia-logo.png' },{ label: 'Land Rover', value: 'land rover', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/land-rover-logo.png' },{ label: 'Mazda', value: 'mazda', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/mazda-logo.png' },{ label: 'Mercedes', value: 'mercedes', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/mercedes-logo.png' },{ label: 'Mini', value: 'mini', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/mini-logo.png' },{ label: 'Mitsubishi', value: 'mitsubishi', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/mitsubishi-logo.png' },{ label: 'Nissan', value: 'nissan', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/nissan-logo.png' },{ label: 'Opel', value: 'opel', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/opel-logo.png' },{ label: 'Peugeot', value: 'peugeot', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/peugeot-logo.png' },{ label: 'Porsche', value: 'porsche', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/porsche-logo.png' },{ label: 'Renault', value: 'renault', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/renault-logo.png' },{ label: 'Saab', value: 'saab', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/saab-logo.png' },{ label: 'Skoda', value: 'skoda', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/skoda-logo.png' },{ label: 'Subaru', value: 'subaru', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/subaru-logo.png' },{ label: 'Suzuki', value: 'suzuki', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/suzuki-logo.png' },{ label: 'Toyota', value: 'toyota', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/toyota-logo.png' },{ label: 'Volkswagen', value: 'volkswagen', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/volkswagen-logo.png' },{ label: 'Volvo', value: 'volvo', logo: 'https://s3.amazonaws.com/cdn.formk.it/example-assets/car-brands/volvo-logo.png' }];\n</script>\n<template>\n  <FormKit\n    type=\"autocomplete\"\n    name=\"autocomplete\"\n    label=\"Search and select a car brand\"\n    placeholder=\"Example: Toyota\"\n    :options=\"carBrands\"\n    selection-appearance=\"option\"\n    value=\"audi\"\n  >\n    <!--SELECTION SLOT-->\n      <template #selection=\"{ option, handlers }\">\n        <div class=\"formkit-selection\">\n          <div class=\"formkit-option\">\n            <img\n              :src=\"option.logo\"\n              :alt=\"option.label + ' logo'\"\n            />\n            <span>\n              {{ option.label }}\n            </span>\n          </div>\n        </div>\nRender\nHTML\nBehavioral props\nEmpty message\n\nThe autocomplete input, by default, will not expand the listbox when no search results are found while filtering. You can change this behavior by assigning the empty-message prop a message to display when no results are found:\n\nRender\nHTML\nClose on select\n\nIf you would like the listbox to remain expanded after selecting a value, you can set close-on-select to false.\n\nRender\nHTML\nReload on commit\n\nIf you want the options to be reloaded when the user commits a selection, use the reload-on-commit prop:\n\nRender\nHTML\nOpen on click\n\nTo enable opening the autocomplete's listbox on click of its search input, set the open-on-click prop to true:\n\nRender\nHTML\nOpen on focus\n\nIf you would like to open the autocomplete's listbox anytime the input is clicked, set the open-on-focus prop to true:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n<FormKit\n  type=\"button\"\n  @click=\"focusAutocomplete\"\n>\n  Click me to focus autocomplete\n</FormKit>\n<FormKit\n  id=\"autocomplete\"\n  type=\"autocomplete\"\n  name=\"framework\"\n  label=\"Choose a frontend framework\"\n  placeholder=\"Example placeholder\"\n  :options=\"frameworks\"\n  open-on-focus\n/>\nRender\nHTML\nOPEN ON FOCUS VS OPEN ON CLICK\n\nIf open-on-focus is used, open-on-click will implicitly be set.\n\nClear search on open\n\nFor single-select autocompletes only, if you would like to clear the search input when the listbox is opened, set the clear-search-on-open:\n\nRender\nHTML\nSelection removable\n\nFor a single-select autocomplete, you can set the selection-removable prop. When set to true, a remove button will be displayed next to the selected option. This prop is by default set to true for autocompletes with selection appearance of option.\n\nSINGLE SELECT ONLY\n\nThe selection-removable prop cannot be used for multi-selects.\n\nRender\nHTML\nOpen on remove\n\nIf you want the listbox to expand when an selection is removed, use the open-on-remove prop:\n\nRender\nHTML\nMax\n\nIf you would like to limit the number of options that can be selected, you can use the max prop:\n\nRender\nHTML\nFull example\n\nNow let's combine what we've learned so far by leveraging the option slot for custom markup, and setting the options prop to a function that will return pages of movies from an API:\n\nautocomplete-full.vue\ntopMovies.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n<script setup>\nimport { topMovies } from './topMovies.js'\n// Search movie receives FormKit's context object\n// which we are destructuring to get the search value,\n// the page, and the hasNextPage parameters.\nasync function searchMovies({ search, page, hasNextPage }) {\n  if (!search) {\n    // When there is no search value we return a static list of top movies\n    return topMovies\n  }\n  const res = await fetch(\n    `https://api.themoviedb.org/3/search/movie?query=${\n      search || ''\n    }&api_key=f48bcc9ed9cbce41f6c28ea181b67e14&language=en-US&page=${page}&include_adult=false`\n  )\n  if (res.ok) {\n    const data = await res.json()\n    if (page !== data.total_pages) hasNextPage()\n    return data.results.map((result) => {\n      return {\n        label: result.title,\n        value: result.id,\n        poster_path: result.poster_path,\n        overview: result.overview,\n      }\n    })\n  }\nRender\nHTML\nProps & Attributes\nProp\tType\tDefault\tDescription\ndebounce\tnumber\t200\tNumber of milliseconds to debounce calls to an options function.\noptions\tany\t[]\tThe list of options the user can select from.\nload-on-scroll\tboolean\tfalse\tWhen set to `true`, the autocomplete will try loading more options based on the end-user`s scroll position\nselection-appearance\tstring\ttext-input\tChanges the way the option label is display.\nmultiple\tboolean\tfalse\tAllows for multiple selections.\nopen-on-click\tboolean\tfalse\tThe autocomplete is expanded upon focus of the input, as opposed to waiting to expand until a search value is entered.\nfilter\tfunction\tnull\tUsed to apply your own custom filter function for static options.\noption-loader\tfunction\tnull\tUsed for hydrating initial value, or performing an additional request to load more information of a selected option.\nempty-message\tstring\tundefined\tRenders a message when there are no options to display.\nmax\tnumber\tundefined\tLimits the number of options that can be selected.\nopen-on-remove\tboolean\tfalse\tWhen the `selection-removable` prop is set to `true`, the autocomplete will not open after the selected value is removed. You can change this behavior by setting the `open-on-remove` prop to `true`.\nopen-on-focus\tboolean\tfalse\noptions-appearance\tstring\tundefined\tFor multi-select autocompletes, this prop allows you to customize the look and feel of the selected options. Possible values are `default` (the default) or `checkbox`.\nalways-load-on-open\tboolean\ttrue\tDetermines whether the autocomplete should always load its options when opened or whether it should reference the options that were previously found when opening.\nload-on-created\tboolean\tfalse\tWhen set to `true`, the autocomplete will load the options when the node is created.\nclear-search-on-open\tboolean\tfalse\tWhen set to `true`, the search input will be cleared when the listbox is opened.\nmax\tnumber | string\tundefined\tIf you would like to limit the number of options that can be selected, you can use the `max` prop (applies only to multi-select).\nShow Universal props\nSections\n\nYou can target a specific section of an input using that section's \"key\", allowing you to modify that section's classes, HTML (via :sections-schema, or content (via slots)). Read more about sections here.\n\nThe autocomplete's structure changes depending on a few different scenarios:\n\nWhether selection-appearance has been set to text-input (the default) or option.\nWhether multiple selections are enabled via the multiple attribute.\nSelection appearance text-input\nwrapper\nlabel\ninner\nprefixIcon\nprefix\ninput\nmessages\nmessage\nYour favorite athletes\nSerena, Pelé\n⌄\nTiger Pelé\nSearch for your favorite athletes.\nSorry, that athlete could not be found.\nouter\nloaderIcon\nlistboxButton\nselectIcon\nlistbox\nsuffix\nsuffixIcon\nhelp\nSelection appearance option, single selection\nwrapper\ninner\nprefixIcon\nprefix\ninput\nselections\nselection\noption\noptionLoading\nremoveSelection\ncloseIcon\nYour favorite athlete\nPelé\nX\n⌄\nTiger Pelé\nSearch for your favorite athlete.\nSorry, that athlete could not be found.\nouter\nlabel\nloaderIcon\nlistboxButton\nselectIcon\nlistbox\nsuffix\nsuffixIcon\nhelp\nmessages\nmessage\nSelection appearance option, multiple selection\nwrapper\ninner\nprefixIcon\nprefix\ninput\nselections\nselection\noption\nhelp\nmessages\nmessage\nYour favorite athlete\n⌄\nTiger Pelé\nPelé\nX\nSearch for your favorite athlete.\nSorry, that athlete could not be found.\nouter\nlabel\nloaderIcon\nlistboxButton\nselectIcon\nlistbox\nsuffix\nsuffixIcon\noptionLoading\nremoveSelection\ncloseIcon\nInner listbox structure\n\nBelow is the inner options list (listbox) structure from the diagrams above:\n\nemptyMessage\nemptyMessageInner\nselectedIcon\nloadMore\nloadMoreInner\nloaderIcon\nNo options to display.\n✔️\nSerena\n⏳\ndropdownWrapper\nlistbox\nlistitem\noption\nSection-key\tDescription\nselector\tThe selector section is a button element that opens the dropdown options list.\nselections\tContains individual selection sections.\nselection\tContains the selected option.\nlistitem\tA list item element that contains the option section.\noption\tA div that contains the option content.\nlistbox\tThe listbox section is a ul element that contains the options list.\ndropdownWrapper\tWraps the listbox section. A div that handles scrolling the listbox.\noptionLoading\tA span element that is conditionally rendered within the selected option when loading is occurring.\nloaderIcon\tAn element for outputting an icon in the selector element when loading is occurring.\nselectIcon\tAn element for outputting an icon in the selector element when the dropdown is closed.\nloadMore\tA list item element that is conditionally rendered at the bottom of the options list when there are more pages to load.\nloadMoreInner\tA span element that acts as a wrapper for the loaderIcon within the loadMore section.\nremoveSelection\tA button element used for removing a specific selection.\ncloseIcon\tAn element for outputting an icon within the removeSelection button.\nlistboxButton\tA button element that is used to open the dropdown.\nemptyMessage\tA list item element that is conditionally rendered when there are no options to display.\nemptyMessageInner\tA span element that acts as a wrapper for the emptyMessage section.\nShow Universal section keys"
  },
  {
    "title": "Examples ⚡️ FormKit",
    "url": "https://formkit.com/essentials/examples",
    "html": "Examples\nForms & structure\nSchema\nPlugins\nInputs\nUser interface\n\nA broad collection of examples with working code you can use in your project today.\n\nForms & structure\nAdd classes to the FormKit-provided submit button\n\nThe form type automatically adds a submit button. Add classes so its UI can conform to your project's styles\n\nUsing a list to repeat an input\n\nUsing the list type, we can create repeater inputs that can have multiple values. This example uses a loop to let users add/remove email addresses.\n\nSchema\nConditionally show input based on value of another input\n\nUse the FormKitSchema component to conditionally show an input (with validation rules) based on the value of another input.\n\nMulti-step form built from Schema\n\nUse the FormKitSchema component to render the multi-step form from the multi-step form guide.\n\nCustom schema submit button with disabled state and loading spinner\n\nCreate a custom schema-powered submit button that dynamically disables while the form is submitting and provides a loading spinner.\n\nAdd a maxlength coutdown to a textarea\n\nAdds a simple countdown of characters left in a textarea with a hover tooltip based on the textarea's maxlength prop\n\nPlugins\nAdd an asterisk to the labels of all required inputs\n\nUse a plugin to add an asterisk (*) to the label area of inputs that have the \"required\" rule.\n\nCast number inputs values from strings to numbers\n\nUse a plugin to cast string values to numbers. Useful if you want inputs of type number to return a JS Number primitive.\n\nRemove the inner wrapper on all checkboxes\n\nUse a plugin to modify the HTML of all descendant checkbox inputs.\n\nAdd an icon before validation messages\n\nUse a plugin to append an icon before validation messages by extending the schema definition.\n\nSet initial values to empty strings instead of undefined\n\nUse a plugin to set all initial input values to an empty string \"\" instead of undefined.\n\nAdd a manually toggleable loading spinner to 'button'-type inputs\n\nUse a plugin to allow inputs in the button family to have a loading spinner that can be toggled at-will with a new loading prop.\n\nAutomatically set an input's name, label, and help text based on the id\n\nUse a plugin to automatically set an input's name, label, and help props based on the id. Reduces repetitive prop declarations in your HTML.\n\nAdds attribute for libraries like @testing-library for testing\n\nA plugin that adds the attribute data-testid with the node id for testing libraries.\n\nScroll to the first validation or error on the form.\n\nA plugin that automatically scrolls to the first error on the page on submit or when backend errors are added.\n\nInputs\nNumber input with custom step buttons\n\nA custom input with +1 and -1 step buttons. Made using createInput().\n\nA currency input with currency selector\n\nA simple custom input that allows users to select a currency and enter a value. Made using createInput().\n\nAdd a link (<a> tag) to a label\n\nUse slots or the :sections-schema feature to modify a label's HTML.\n\nConditionally update options of a select input\n\nConditionally update the options of a select input based on the value of another input.\n\nStyle radio input options to look like cards\n\nUsing only new styles (Tailwind Classes in this example) apply a card treatment to the default FormKit Radio input structure.\n\nUser interface\nAdd a loading indicator for async validation rules\n\nAdd a loading spinner to your input when an async validation rule is pending validation.\n\nKeep submit button disabled until a form changes\n\nOnly enable a save/submit button if a user has changed any value inside a form.\n\nAdd transitions to validation messages\n\nAdd transitions to validation messages by injecting a Vue TransitionGroup component using FormKit's :sections-schema.\n\nStarter project with Nuxt, FormKit, and Tailwind\n\nA working starter project on StackBlitz with Nuxt, FormKit and Tailwind CSS.\n\nProduce dynamic classes based on an input's state\n\nUse the rootClasses config function and FormKit props to produce a dynamic classes based on input state. Helpful for Tailwind and other CSS utility libraries.\n\nCreate reactive UI variations of FormKit inputs using “features”\n\nCreate UI variations of FormKit inputs (like buttons) that update based on reactive data in your components.\n"
  },
  {
    "title": "Architecture ⚡️ FormKit",
    "url": "https://formkit.com/essentials/architecture",
    "html": "Architecture\nIntroduction\nArchitecture\nNode\nInput\nList\nGroup\nOptions\nConfig & Props\nProps\nSetting values\nValue settlement\nGetting a component’s node\nTraversal\nDeep traversal\nTraversal tokens\nEvents\nAdd listener\nRemove listener\nCore events\nEmitting events\nHooks\nHook middleware\nPlugins\nLibrary\nMessage store\nRead and write messages\nLedger\nCreating a counter\nIntroduction\n\nAt the heart of the FormKit framework is @formkit/core. This zero-dependency package is responsible for nearly all of FormKit's low-level critical functions, such as:\n\nConfiguration\nValue input/output\nEvent bubbling\nPlugin management\nTree state tracking\nMessage management\nLifecycle hooks\nArchitecture\n\nThe functionality of FormKit core is not exposed to your application via a centralized instance but rather a distributed set of \"nodes\" (FormKitNode) where each node represents a single input.\n\nThis mirrors HTML — in fact DOM structure is actually a general tree and FormKit core nodes reflect this structure. For example, a simple login form could be drawn as the following tree graph:\n\n{}\nE\nP\nHover over each node to see its initial options.\n\nIn this diagram, a form node is a parent to three child nodes — email, password and submit. Each input component in the graph \"owns\" a FormKit core node, and each node contains its own options, configuration, props, events, plugins, lifecycle hooks, etc. This architecture ensures that FormKit’s primary features are decoupled from the rendering framework (Vue) — a key to reducing side effects and maintaining blazing fast performance.\n\nAdditionally, this decentralized architecture allows for tremendous flexibility. For example — one form could use different plugins than other forms in the same app, a group input could modify the configuration of its sub-inputs, and validation rules can even be written to use props from another input.\n\nNode\n\nEvery <FormKit> component owns a single core node, and each node must be one of three types:\n\nInput\nList\nGroup\nINPUT VS NODE TYPES\n\nCore nodes are always one of three types (input, list, or group). These are not the same as input types — of which there can be unlimited variation. Strictly speaking all inputs have 2 types: their node type (like input), and their input type (like checkbox).\n\nInput\n\nMost of FormKit’s native inputs have a node type of input — they operate on a single value. The value itself can be of any type, such as objects, arrays, strings, and numbers — any value is acceptable. However, nodes of type input are always leafs — meaning they cannot have children.\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst input = createNode({\n\n  type: 'input', // defaults to 'input' if not specified\n\n  value: 'hello node world',\n\n})\n\n\n\nconsole.log(input.value)\n\n// 'hello node world'\nList\n\nA list is a node that produces an array value. Children of a list node produce a value in the list’s array value. The names of immediate children are ignored — instead each is assigned an index in the list’s array.\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst list = createNode({\n\n  type: 'list',\n\n  children: [\n\n    createNode({ value: 'paprika@example.com' }),\n\n    createNode({ value: 'bill@example.com' }),\n\n    createNode({ value: 'jenny@example.com' }),\n\n  ],\n\n})\n\n\n\nconsole.log(list.value)\n\n// ['paprika@example.com', 'bill@example.com', 'jenny@example.com']\nGroup\n\nA group is a node that produces an object value. Children of a group node use their name to produce a property of the same name in the group’s value object — <FormKit type=\"form\"> is an instance of a group.\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst group = createNode({\n\n  type: 'group',\n\n  children: [\n\n    createNode({ name: 'meat', value: 'turkey' }),\n\n    createNode({ name: 'greens', value: 'salad' }),\n\n    createNode({ name: 'sweets', value: 'pie' }),\n\n  ],\n\n})\n\n\n\nconsole.log(group.value)\n\n// { meat: 'turkey', greens: 'salad', sweets: 'pie' }\nOptions\n\nIn addition to specifying the type of node when calling createNode(), you can pass any of the following options:\n\nOptions\tDefault\tDescription\nchildren\t[]\tChild FormKitNode instances.\nconfig\t{}\tConfiguration options. These become the defaults of the props object.\nname\t{type}_{n}\tThe name of the node/input.\nparent\tnull\tThe parent FormKitNode instance.\nplugins\t[]\tAn array of plugin functions.\nprops\t{}\tAn object of key/value pairs that represent the current node instance details.\ntype\tinput\tThe type of FormKitNode to create (list, group, or input).\nvalue\tundefined\tThe initial value of the input.\nConfig & Props\n\nFormKit uses an inheritance-based configuration system. Any values declared in the config option are automatically passed to children (and all descendants) of that node, but not passed to siblings or parents. Each node can override its inherited values by providing its own config, and these values will in turn be inherited by any deeper children and descendants. For example:\n\nconst parent = createNode({\n\n  type: 'group',\n\n  config: {\n\n    color: 'yellow',\n\n  },\n\n  children: [\n\n    createNode({\n\n      type: 'list',\n\n      config: { color: 'pink' },\n\n      children: [createNode(), createNode()],\n\n    }),\n\n    createNode(),\n\n  ],\n\n})\n\nThe above code will result in each node having the following configuration:\n\n{}\n[]\n[0]\n[1]\nA\nNotice how the list subtree is pink.\nUSE PROPS TO READ CONFIG\n\nIt is best practice to read configuration values from node.props rather than node.config. The next section details this feature.\n\nProps\n\nThe node.props and node.config objects are closely related. node.config is best thought of as the initial values for node.props. props is an arbitrarily shaped object that contains details about the current instance of the node.\n\nThe best practice is to always read configuration and prop data from node.props even if the original value is defined using node.config. Explicitly defined props take precedence over configuration options.\n\nconst child = createNode({\n\n  props: {\n\n    flavor: 'cherry',\n\n  },\n\n})\n\nconst parent = createNode({\n\n  type: 'group',\n\n  config: {\n\n    size: 'large',\n\n    flavor: 'grape',\n\n  },\n\n  children: [child],\n\n})\n\nconsole.log(child.props.size)\n\n// outputs: 'large'\n\nconsole.log(child.props.flavor)\n\n// outputs: 'cherry'\nFORMKIT COMPONENT PROPS\n\nWhen using the <FormKit> component, any props defined for the input type are automatically set as node.props properties. For example: <FormKit label=\"Email\" /> would result in node.props.label being Email.\n\nSetting values\n\nYou can set the initial value of a node by providing the value option on createNode() — but FormKit is all about interactivity, so how do we update the value of an already defined node? By using node.input(value).\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst username = createNode()\n\nusername.input('jordan-goat98')\n\nconsole.log(username.value)\n\n// undefined  👀 wait — what!?\n\nIn the above example username.value is still undefined immediately after it’s set because node.input() is asynchronous. If you need to read the resulting value after calling node.input() you can await the returned promise.\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst username = createNode()\n\nusername.input('jordan-goat98').then(() => {\n\n  console.log(username.value)\n\n  // 'jordan-goat98'\n\n})\n\nBecause node.input() is asynchronous, the rest of our form does not need to recompute its dependencies on every keystroke. It also provides an opportunity to perform modifications to the unsettled value before it is \"committed\" to the rest of the form. However — for internal node use only — a _value property containing the unsettled value of the input is also available.\n\nDON’T ASSIGN VALUES\n\nYou cannot directly assign the value of an input node.value = 'foo'. Instead, you should always use node.input(value)\n\nValue settlement\n\nNow that we understand node.input() is asynchronous, let's explore how FormKit solves the \"settled tree\" problem. Imagine a user quickly types in their email address and hits \"enter\" very quickly — thus submitting the form. Since node.input() is asynchronous, incomplete data would likely be submitted. We need a mechanism to know when the whole form has \"settled\".\n\nTo solve this, FormKit’s nodes automatically track tree, subtree, and node \"disturbance\". This means the form (usually the root node) always knows the settlement state of all the inputs it contains.\n\nThe following graph illustrates this \"disturbance counting\". Click on any input node (blue) to simulate calling node.input() and notice how the whole form is always aware of how many nodes are \"disturbed\" at any given time. When the root node has a disturbed count of 0 the form is settled and safe to submit.\n\n{}\n0\nA\n0\n{}\n0\n[]\n0\n[0]\n0\n[1]\n0\nA\n0\nA\n0\nClick on the inputs (blue) to simulate calling a user input.\nTo ensure a given tree (form), subtree (group), or node (input) is \"settled\" you can await the `node.settled` property:\nimport { createNode } from '@formkit/node'\n\n\n\nconst form = createNode({\n\n  type: 'group',\n\n  children: [\n\n    createNode()\n\n    createNode()\n\n    createNode()\n\n  ],\n\n})\n\n// ...\n\n// user interaction:\n\nasync function someEvent () {\n\n  await form.settled\n\n  // we now know the form is fully \"settled\"\n\n  // and that form.value is accurate.\n\n}\nTHE FORM TYPE\n\nThe <FormKit type=\"form\"> input already incorporates this await behavior. It will not call your @submit handler until your form is completely settled. However when building advanced inputs it can be useful to understand these underlying principles.\n\nGetting a component’s node\n\nSometimes it can be helpful to get the underlying instance of a node from the Vue <FormKit> component. There are three primary methods of fetching an input’s node.\n\nUsing getNode() (or the Vue plugin’s $formkit.get() for Options API)\nUsing the @node event.\nUsing a template ref.\nUsing getNode()\n\nWhen using FormKit you can access a node by assigning it an id and then accessing it by that property via the getNode() function.\n\nWARNING\n\nYou must assign the input an id to use this method.\n\nRender\nHTML\nOPTIONS API\n\nWhen using Vue’s Options API You can access the same getNode() behavior by using this.$formkit.get().\n\nUsing the node event\n\nAnother way to get the underlying node is to listen to the @node event which is emitted only once when the component first initializes the node.\n\nRender\nHTML\nUsing a template ref\n\nAssigning a <FormKit> component to a ref also allows easy access to the node.\n\nRender\nHTML\nTraversal\n\nTo traverse nodes within a group or list use node.at(address) — where address is the name of the node being accessed (or the relative path to the name). For example:\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst group = createNode({\n\n  type: 'group',\n\n  children: [createNode({ name: 'email' }), createNode({ name: 'password' })],\n\n})\n\n\n\n// Returns the email node\n\ngroup.at('email')\n\nIf the starting node has siblings, it will attempt to locate a match in the siblings (internally, this is what FormKit uses for validation rules like confirm:address).\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst email = createNode({ name: 'email' })\n\nconst password = createNode({ name: 'password' })\n\nconst group = createNode({\n\n  type: 'group',\n\n  children: [email, password],\n\n})\n\n\n\n// Accesses sibling to return the password node\n\nemail.at('password')\nDeep traversal\n\nYou can go deeper than one level by using a dot-syntax relative path. Here's a more complex example:\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst group = createNode({\n\n  type: 'group',\n\n  children: [\n\n    createNode({ name: 'team' }),\n\n    createNode({\n\n      type: 'list',\n\n      name: 'users',\n\n      children: [\n\n        createNode({\n\n          type: 'group',\n\n          children: [\n\n            createNode({ name: 'email' }),\n\n            createNode({ name: 'password', value: 'foo' }),\n\n          ],\n\n        }),\n\n        createNode({\n\n          type: 'group',\n\n          children: [\n\n            createNode({ name: 'email' }),\n\n            createNode({ name: 'password', value: 'fbar' }),\n\n          ],\n\n        }),\n\n      ],\n\n    }),\n\n  ],\n\n})\n\n\n\n// outputs: 'foo'\n\nconsole.log(group.at('users.0.password').value)\n\nNotice how traversing the list uses numeric keys, this is because the list type uses array indexes automatically.\n\n{}\nA\n[]\n[0]\nE\nP\n[1]\nE\nP\nTraversal path of group.at('users.0.password') shown in red.\nARRAY PATHS\n\nNode addresses may also be expressed as arrays. For example node.at('foo.bar') could be expressed as node.at('foo', 'bar').\n\nTraversal tokens\n\nAlso available for use in node.at() are a few special \"tokens\":\n\nToken\tDescription\n$parent\tThe immediate ancestor of the current node.\n$root\tThe root node of the tree (the first node with no parent).\n$self\tThe current node in the traversal.\nfind()\tA function that performs a breadth-first search for a matching value and property. For example: node.at('$root.find(555, value)')\n\nThese tokens are used in dot-syntax addresses just like you would use a node’s name:\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst secondEmail = createNode({ name: 'email' })\n\n\n\ncreateNode({\n\n  type: 'group',\n\n  children: [\n\n    createNode({ name: 'team', value: 'charlie@factory.com' }),\n\n    createNode({\n\n      type: 'list',\n\n      name: 'users',\n\n      children: [\n\n        createNode({\n\n          type: 'group',\n\n          children: [\n\n            createNode({ name: 'email', value: 'james@peach.com' }),\n\n            createNode({ name: 'password', value: 'foo' }),\n\n          ],\n\n        }),\n\n        createNode({\n\n          type: 'group',\n\n          children: [\n\n            secondEmail, // We're going to start here.\n\n            createNode({ name: 'password', value: 'fbar' }),\n\n          ],\n\n        }),\n\n      ],\n\n    }),\n\n  ],\n\n})\n\n\n\n// Navigate from the second email to the first\n\nconsole.log(secondEmail.at('$parent.$parent.0.email').value)\n\n// outputs: charlie@factory.com\n{}\nA\n[]\n[0]\nE\nP\n[1]\nE\nP\nTraversal path of secondEmail.at('$parent.$parent.0.email') shown in red.\nEvents\n\nNodes have their own events which are emitted during the node’s lifecycle (unrelated to Vue’s events).\n\nAdd listener\n\nTo observe a given event, use node.on().\n\n// Listen for any prop being set or changed.\n\nnode.on('prop', ({ payload }) => {\n\n  console.log(`prop ${payload.prop} was set to ${payload.value}`)\n\n})\n\n\n\nnode.props.foo = 'bar'\n\n// outputs: prop foo was set to bar\n\nEvent handler callbacks all receive a single argument of type FormKitEvent, the object shape is:\n\n{\n\n  // The contents of the event — a string, an object, etc.\n\n  payload: { cause: 'ice cream', duration: 200 },\n\n  // The name of the event, this matches the first argument of node.on().\n\n  name: 'brain-freeze',\n\n  // Whether or not this event should bubble to the next parent.\n\n  bubble: true,\n\n  // The original FormKitNode that emitted the event.\n\n  origin: node,\n\n}\n\nNode events (by default) bubble up the node tree, but node.on() will only respond to events emitted by the same node. However, if you would like to also catch events bubbling up from descendants you may append the string .deep to the end of your event name:\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst group = createNode({ type: 'group' })\n\n\n\ngroup.on('created.deep', ({ payload: child }) => {\n\n  console.log('child node created:', child.name)\n\n})\n\n\n\nconst child = createNode({ parent: group, name: 'party-town-usa' })\n\n// outputs: 'child node created: party-town-usa'\nRemove listener\n\nEvery call to register an observer with node.on() returns a “receipt” — a randomly generated key — that can be used later to stop observing that event (similar to setTimeout() and clearTimeout()) using node.off(receipt).\n\nconst receipt = node.on('input', ({ payload }) => {\n\n  console.log('received input: ', payload)\n\n})\n\nnode.input('foobar')\n\n// outputs: 'received input: foobar'\n\nnode.off(receipt)\n\nnode.input('fizz buzz')\n\n// no output\nCore events\n\nThe following is a comprehensive list of all events emitted by @formkit/core. Third-party code may emit additional events not included here.\n\nName\tPayload\tBubbles\tDescription\ncommit\tany\tyes\tEmitted when a node's value is committed but before it has been transmitted to the rest of the form.\nconfig:{property}\tany (the value)\tyes\tEmitted any time a specific configuration option is set or changed.\ncount:{property}\tany (the value)\tno\tEmitted any time a a ledger’s counter value changes.\nchild\tFormKitNode\tyes\tEmitted when a new child node is added, created or assigned to a parent.\ncreated\tFormKitNode\tyes\tEmitted immediately before the node is returned when calling createNode() (plugins and features have already run).\ndefined\tFormKitTypeDefinition\tyes\tEmitted when the node’s \"type\" is defined, this typically happens during createNode().\ndestroying\tFormKitNode\tyes\tEmitted when the node.destroy() is called, after it has been detached from any parents.\ndom-input-event\tEvent\tyes\tEmitted when the DOMInput handler is called, useful for getting the original HTML input event in core.\ninput\tany (the value)\tyes\tEmitted when node.input() is called — after the input hook has run.\nmessage-added\tFormKitMessage\tyes\tEmitted when a new node.store message was added.\nmessage-removed\tFormKitMessage\tyes\tEmitted when a node.store message was removed.\nmessage-updated\tFormKitMessage\tyes\tEmitted when a node.store message was changed.\nprop:{propName}\tany (the value)\tyes\tEmitted any time a specific prop is set or changed.\nprop\t{ prop: string, value: any }\tyes\tEmitted any time a prop is set or changed.\nreset\tFormKitNode\tyes\tEmitted any time a form or group is reset.\nsettled\tboolean\tno\tEmitted anytime a node’s disturbance counting settles or unsettles.\nsettled:{counterName}\tboolean\tno\tEmitted anytime a specific ledger counter settles (returns to zero).\nunsettled:{counterName}\tboolean\tno\tEmitted anytime a specific ledger counter becomes unsettled (goes above zero).\ntext\tstring or FormKitTextFragment\tno\tEmitted after the text hook has run — typically when processing interface text that may have been translated.\nPROP EVENTS ON CONFIG CHANGES\n\nWhen a configuration option changes, any inheriting nodes (including the origin node) will also emit prop and prop:{propName} events, so long as they do not override that property in their own props or config objects.\n\nEmitting events\n\nNode events are emitted with node.emit(). You can leverage this feature to emit your own synthetic events from your own plugins.\n\nnode.emit('myEvent', payloadGoesHere)\n\nAn optional third argument bubble is also available. When set to false, it prevents your event from bubbling up through the form tree.\n\nHooks\n\nHooks are middleware dispatchers that are triggered during pre-defined lifecycle operations. These hooks allow external code to extend the internal functionality of @formkit/core. The following table details all available hooks:\n\nHook\tValue\tDescription\nclasses\t\n{\n property: string,\n classes: Record<string, boolean>\n}\n\tDispatched after all class operations have been run, before final conversion to a string.\ncommit\tany\tDispatched when setting the value of a node after the input and debounce of node.input() is called.\ncommitRaw\tany\tDispatched when setting the value of a node after the input and debounce of node.input() is called.\nerror\tstring\tDispatched when processing a thrown error — errors are generally inputs, and the final output should be a string.\ninit\tFormKitNode\tDispatched after the node is initially created but before it is returned in createNode().\ninput\tany\tDispatched synchronously on every input event (every keystroke) before commit.\nmessage\tFormKitMessage\tDispatched when a message is being set on node.store\nprop\t\n{\n prop: string,\n value: any\n}\n\tDispatched when any prop is being assigned.\nsetErrors\t{ localErrors: ErrorMessages, childErrors?: ErrorMessages }\tDispatched when explicit errors are being set on a node (not validation errors).\nsubmit\tRecord<string, any>\tDispatched when the FormKit form is submitted and passing validation. This hook allows you to modify the (cloned) form values before they are passed to the submit handler\ntext\tFormKitTextFragment\tDispatched when a FormKit-generated string needs to be displayed — allowing i18n or other plugins to intercept.\nHook middleware\n\nTo make use of these hooks, you must register hook middleware. A middleware is simply a function that accepts 2 arguments — the value of the hook and next — a function that calls the next middleware in the stack and returns the value.\n\nTo register a middleware, pass it to the node.hook you want to use:\n\nimport { createNode } from '@formkit/core'\n\n\n\nconst node = createNode()\n\n\n\n// This would transform all labels to \"Different label!\"\n\nnode.hook.prop((payload, next) => {\n\n  if ((payload.prop = 'label')) {\n\n    payload.value = 'Different label!'\n\n  }\n\n  return next(payload)\n\n})\nUSE WITH PLUGINS\n\nHooks can be registered anywhere in your application, but the most common place hooks are used is in a plugin.\n\nPlugins\n\nPlugins are the primary mechanism for extending the functionality of FormKit. The concept is simple — a plugin is just a function that accepts a node. These functions are then automatically called when a node is created, or when the plugin is added to the node. Plugins work similar to configuration options — they are automatically inherited by children and descendants.\n\nimport { createNode } from '@formkit/core'\n\n\n\n// A plugin to change a prop value.\n\nconst myPlugin = (node) => {\n\n  if (node.type === 'group') {\n\n    node.props.color = 'yellow'\n\n  } else {\n\n    node.props.color = 'teal'\n\n  }\n\n}\n\n\n\nconst node = createNode([\n\n  plugins: [myPlugin],\n\n  children: [createNode()]\n\n])\n\nIn the example above, the plugin is only defined on the parent, but the child also inherits the plugin. The function myPlugin will be called twice — once for each node in the graph (which only has two in this example):\n\n{}\nA\nThe plugin is inherited by the child, but executed independently.\nLibrary\n\nIn addition to extending and modifying nodes, plugins serve one additional role — exposing input libraries. A “library” is a function assigned to the library property of a plugin that accepts a node and determines whether it knows how to “define” that node. If it does, it calls node.define() with an input definition.\n\nFor example, if we wanted to create a plugin that exposed a couple new inputs: italy and france we could write a plugin to do this:\n\nRender\nHTML\n\nExperienced developers will notice a few exciting properties of this plugin-library pattern:\n\nMultiple input libraries can be installed on the same project.\nPlugins (and libraries) can be exposed locally, per form, group, or globally.\nA plugin can bundle new inputs along with plugin logic making installation simple for end users.\nThe library function has full control over what conditions result in a call to node.define(). Frequently, this is simply checking node.props.type but you can define different inputs based on other conditions, like if a particular prop is set.\nLearn to create your own custom inputs\nCustom input docs\nMessage store\n\nEach node has its own data store. The objects in these stores are called \"messages\" and these messages are especially valuable for three primary use cases:\n\nDisplaying information about the node to a user with i18n support (the validation plugin uses it).\n\"Blocking\" form submission.\nGeneral data store for plugin authors.\n\nEach message (FormKitMessage in TypeScript) in the store is an object with the following shape:\n\n{\n\n  // Whether or not this message blocks form submission (default: false).\n\n  blocking: true,\n\n  // Must be a unique string value (default: random string).\n\n  key: 'yourkey',\n\n  // (optional) Meta data object about this message (default: {}).\n\n  meta: {\n\n    // (optional) If set, i18n uses this instead of the key to find locale messages.\n\n    messageKey: 'i18nKey',\n\n    // (optional) If set, these arguments will be spread to the i18n locale function.\n\n    i18nArgs: [...any],\n\n    // (optional) If set to false, the message will check for localization.\n\n    localize: true,\n\n    // (optional) The message locale (default: node.config.locale)\n\n    locale: 'en',\n\n    // Any other meta data your heart desires.\n\n    ...any\n\n  },\n\n  // An arbitrary category this message belongs to (for filtering purposes).\n\n  // For example: 'validation' or 'success' (default: 'state')\n\n  type: string,\n\n  // (optional) should be a string, number, or boolean (default: undefined).\n\n  value: 'Woops, our server is broken!',\n\n  // Should this message be shown to end users? (default: true)\n\n  visible: true\n\n}\nCREATE MESSAGE HELPER\n\nA helper function createMessage({}) can be imported from @formkit/core to merge your message data with the above default values to create a new message object.\n\nRead and write messages\n\nTo add or update a message, use node.store.set(FormKitMessage). Messages are then made available on node.store.{messageKey}\n\nimport { createMessage, createNode } from '@formkit/core'\n\n\n\nconst node = createNode()\n\nconst message = createMessage({\n\n  key: 'clickHole',\n\n  value: 'Please click 100 times.',\n\n})\n\n\n\nnode.store.set(message)\n\n\n\nconsole.log(node.store.clickHole.value)\n\n// outputs: 'Please click 100 times.'\nMESSAGE LOCALES\n\nMessages will automatically be translated if the @formkit/i18n plugin is installed and a matching key is available in the active locale. Read the i18n docs.\n\nLedger\n\nOne of the keys to FormKit’s performance is its ability to efficiently count messages matching a given criteria (in the store), and then keep a running tally of those messages as changes are made (including from child nodes). These counters are created using node.ledger.\n\nCreating a counter\n\nLet's say we want to count how many messages are currently being displayed. We could do this by counting messages with the visible property set to true.\n\nRender\nHTML\n\nNotice the second argument of node.ledger.count() is a function. This function accepts a message as an argument and expects the return value to be a boolean, indicating whether that message should be counted or not. This allows you to craft arbitrary counters for any message type.\n\nWhen using a counter on a group or list node, the counter will propagate down the tree summing the value of all messages passing the criteria function and then tracking that count for store changes.\n\nVALIDATION COUNTER\n\nThe validation plugin already declares a counter called blocking which counts the blocking property of all messages. This is how FormKit forms know if all their children are \"valid\".\n"
  },
  {
    "title": "Configuration ⚡️ FormKit",
    "url": "https://formkit.com/essentials/configuration",
    "html": "Configuration\nIntroduction\nWhat are core nodes?\nWhat are node options?\nAvailable node options\nWhat is defaultConfig?\nWhat are node props?\n1. Direct assignment\n2. Component props\n3. Global options\n4. Provider options\nWhat is node config?\nIntroduction\n\nFormKit uses a unique hierarchical configuration system that is well suited for forms. To understand how this configuration works, there are 4 questions we need to answer:\n\nWhat are core nodes?\nWhat are node options?\nWhat are node props?\nWhat is node config?\nWhat are core nodes?\n\nEvery <FormKit> component has its own instance of a core node. This node is responsible for almost all of the component’s functionality. There are 3 types of core nodes: inputs, lists, and groups (forms are just a type of group!).\n\nThere is no global FormKit instance that controls the application. Instead, you can think of each node as its own little application — complete with its own configuration.\n\nOne last thing about nodes — they can all have parent nodes. Groups and lists can also have children. For example, a login form might have two children — the email and password inputs. You can draw this relationship as a simple tree diagram:\n\n{}\nE\nP\nHover over each node to see its initial options.\nWhat are node options?\n\nWhen creating one of these \"mini applications\" that we call core nodes, some options can be passed in. Except in extremely advanced use cases, you won't be creating your own core nodes — this is normally done for you by the <FormKit> component. However, it can be useful to define some of the node options globally. This is done with the @formkit/vue plugin — 💡 core node options are the same as the @formkit/vue plugin options.\n\nFor example, in a typical FormKit Vue registration, we use defaultConfig which is just a function that returns core node options:\n\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\n\n\n// 👀 defaultConfig is just a function that returns core node options!\n\ncreateApp(App).use(plugin, defaultConfig)\nAvailable node options\n\nThe following is a list of all the available options that can be used when registering FormKit or creating a node individually. Options that are passed to the @formkit/vue plugin will be applied to every <FormKit> component’s core node when it is created.\n\ncreateNode({\n\n  /**\n\n   * Used to rename the global \"FormKit\" component.\n\n   */\n\n  alias: 'FormKit',\n\n  /**\n\n   * This array is normally built for you by the FormKit component.\n\n   */\n\n  children: [],\n\n  /**\n\n   * An object of config settings. Keep reading for more on this.\n\n   */\n\n  config: {},\n\n  /**\n\n   * The name of the node — normally this is mapped to the name of your input.\n\n   */\n\n  name: 'inputName',\n\n  /**\n\n   * Parent — this is normally set for you by the FormKit component.\n\n   */\n\n  parent: null,\n\n  /**\n\n   * An array of plugin functions\n\n   */\n\n  plugins: [],\n\n  /**\n\n   * Default prop values, keep reading to learn more.\n\n   */\n\n  props: {},\n\n  /**\n\n   * Used to rename the global \"FormKitSchema\" component.\n\n   */\n\n  schemaAlias: 'FormKitSchema',\n\n  /**\n\n   * All are only 1 of 3 values: 'input', 'group', or 'list'\n\n   */\n\n  type: 'input',\n\n  /**\n\n   * The initial value of the node.\n\n   */\n\n  value: 'foobar',\n\n})\nWhat is defaultConfig?\n\nDevelopers familiar with FormKit will notice that the above list of node options differs slightly from the values that can be passed into the defaultConfig function.\n\nMany of FormKit’s features, like validation, inputs, and Vue support are provided courtesy of first-party plugins. The defaultConfig function configures many of these plugins before they are given over to the Vue plugin as node options. So, defaultConfig can accept any of the above node options, but also a few extras:\n\ndefaultConfig({\n\n  /**\n\n   * Validation rules to add or override.\n\n   * See validation docs.\n\n   */\n\n  rules: {},\n\n  /**\n\n   * Locales to register.\n\n   * See internationalization docs.\n\n   */\n\n  locales: {},\n\n  /**\n\n   * Input definitions to add or override.\n\n   * See docs on custom inputs.\n\n   */\n\n  inputs: {},\n\n  /**\n\n   * Explicit locale messages to override.\n\n   * See internationalization docs.\n\n   */\n\n  messages: {},\n\n  /**\n\n   * The currently active locale. This is actually a config setting, but\n\n   * defaultConfig accepts it as a top-level value to improve the DX.\n\n   */\n\n  locale: 'en',\n\n  /**\n\n   * Any of the above node options are accepted.\n\n   */\n\n  ...nodeOptions,\n\n})\nWhat are node props?\n\nAll core nodes have a props object (node.props). FormKit core, and any third-party plugins or code can read and write values to this object. In fact, nearly every feature of FormKit references node.props to determine how it should operate.\n\nFor example, the validation plugin looks at node.props.validation to determine if there are any rules it needs to run. So the real question is — how are these props being set? There are 3 primary mechanisms for setting props:\n\nDirect assignment\nComponent props\nGlobal options\nProvider options\n\nLet’s see how we can set the validation rules of an input (node.props.validation) these three ways:\n\n1. Direct assignment\n\nIf you have a node instance, you can directly assign it a prop value:\n\nRender\nHTML\n2. Component props\n\nAny props passed to the <FormKit> input are assigned to the node.props object (you know the drill).\n\nRender\nHTML\n3. Global options\n\nWhen registering the @formkit/vue plugin (or using @formkit/nuxt with a formkit.config.ts) you can provide prop values to be injected into to all <FormKit> components.\n\nRender\nHTML\n4. Provider options\n\nSimilar to global options the <FormKitProvider> component allows you to specify what \"global\" configuration options should be injected into its children. This technique can be used to create a \"scoped\" configuration for a specific section of an app, override global options for a specific section of an app, or provide more targeted loading of the FormKit library.\n\nWhen using the <FormKitProvider> component, all globally defined options (from global plugin) are removed and only options provided by the provider are used on any <FormKit> components within its scope.\n\nNUXT MODULE\n\nThe @formkit/nuxt module with autoImport: true enabled automatically wraps your components that use FormKit in a <FormKitProvider> component. This keeps formkit from being included in your entry bundle.\n\nWhat is node config?\n\nProps are pretty powerful, but in addition to node.props, core nodes all have a config object node.config. This is where configuration hierarchy comes in. The node.config object acts like initial values for node.props. If a given prop is requested, like node.props.validation, and that property is not explicitly set using any of the methods discussed above, then FormKit will check the node.config object to see if it has a value. If it does not have a value, then it recursively checks the node parent's config object — then the grandparent's config object — and so on — until a value is found or it reaches a node with no parent.\n\nThis diagram describes how a request for property of node.props resolves.\n\nWhat does this mean in practice? When you combine the tree like structure of forms (and their corresponding core nodes) and this hierarchical configuration you can do some pretty exciting things. For example, here we set the validation visibility of an entire form:\n\nRender\nHTML\n\nIt’s worth noting that plugins have their own inheritance model which differs from config and props, and is described in more detail in the core documentation.\n"
  },
  {
    "title": "FormKit Schema ⚡️ FormKit",
    "url": "https://formkit.com/essentials/schema",
    "html": "Schema\nIntroduction\nForm generation example\nSchema array\nHTML elements ($el)\nComponents ($cmp)\nReferences\nReferencing functions\nDeep references\nExpressions\nConditionals\nThe if property\nThe if/then/else object\nLoops\nSlots\nBinding attrs and props\nRaw values\nFormKit Inputs\nShorthand\nAccessing other inputs\nForms\nIntroduction\n\nFormKit's schema is a JSON-serializable data format for storing DOM structures and component implementations, including FormKit forms. Although created specifically for implementing and generating forms, the format is capable of generating any HTML markup or using any third-party components.\n\nSchemas are rendered using FormKit's <FormKitSchema> component, which is not registered globally by default. You will need to import it:\n\nimport { FormKitSchema } from '@formkit/vue'\nForm generation example\n\nFormKit ships with first-class support for generating forms using schema. This makes it possible to store generated forms in databases, files, or even QR codes! To generate a form, pass your schema array to the <FormKitSchema> component using the :schema prop.\n\n<FormKitSchema :schema=\"yourSchemaArray\" />\n\nLet’s look at a quick example:\n\nRender\nHTML\n\nWe see many features above including the $el and $cmp props, the $formkit prop shorthand, validation, conditional rendering, labels, help text, and multiple types of inputs. We'll unpack all these features in the remainder of this page.\n\nSchema array\n\nA schema is an array of objects or strings (called \"schema nodes\"), where each array item defines a single schema node. There are 3 types of of schema nodes:\n\nText nodes — produced by strings.\nHTML elements — defined by the $el property.\nComponents — defined by the $cmp property.\nFormKit components — defined by the $formkit property. Syntactic sugar for the full $cmp format.\n\nSchemas support advanced features like conditional logic, boolean operators, loops, slots, and data scoping — all guaranteed to serialize to a string.\n\nHTML elements ($el)\n\nHTML elements are defined using the $el property. You can use $el to render any HTML element. Attributes can be added with the attrs property, and content is assigned with the children property:\n\nRender\nHTML\nTIP\n\nNotice in the above example that the style attribute is unique in that it should be defined as an object of style to value pairs rather than a string.\n\nComponents ($cmp)\n\nComponents can be defined with the $cmp property. The $cmp property should be a string that references a globally defined component or a component passed into FormKitSchema with the library prop:\n\nRender\nHTML\nCOMPONENTS AS PROPS\n\nIn order to pass concrete components via the library prop, it's best to wrap your library with Vue’s markRaw signature.\n\nReferences\n\nIn addition to the schema array (and optional library), the FormKitSchema object can also include a data prop. Values from the data object can then be referenced directly in your schema — and your schema will maintain the reactivity of the original data object.\n\nTo reference a value from the data object, you simply use a dollar sign $ followed by the property name from the data object. References can be used in attrs, props, conditionals and as children:\n\nRender\nHTML\nIMPORTANT NOTE\n\nNotice in the above example that we used an array to concatenate \"Hello\" and \"$location\". We did this because data references and logical expressions in the schema must always begin with a dollar sign $ — otherwise they are treated as unparsed string literals.\n\nReferencing functions\n\nSchemas support calling functions that are in your original reference data — and you can even pass data references as arguments of that function!\n\nRender\nHTML\nDeep references\n\nJust like JavaScript — you can access properties of a deeply nested object using dot-syntax object.property:\n\nRender\nHTML\nRESERVED WORDS\n\nSchema references can have any structure or properties, but at the root of the data reference object there are 2 reserved words: $slots and $get.\n\nExpressions\n\nSchemas also support logic in the form of boolean logic, comparison, and arithmetic expressions. These expressions can be used anywhere a data reference can be used (attrs, props, conditionals, and children):\n\nRender\nHTML\nLABELING EXPRESSIONS\n\nExpressions must always begin with a $. If the first element of an expression is a data reference (ex: $count + 2), then it already begins with a $ and no further labeling is required. However, often the first character of an expression is not a dollar sign — these expressions need to be \"labeled\" with $: — for example $: ($count * 3) - 7.\n\nAlthough it looks very much like JavaScript — schema expressions are not JavaScript. They are better thought of as a templating language. Expressions are compiled down to functional JavaScript at setup but the syntax is not 1-1 compatible with JavaScript. This improves performance and provides a critical layer of security as only explicitly exposed data and functionality can be executed.\n\nSchema expressions are limited to the following operators and parenthesis:\n\nOperator\tUse case\n+\tAddition\n-\tSubtraction\n*\tMultiplication\n/\tDivision\n%\tModulus\n&&\tBoolean AND\n||\tBoolean OR\n===\tStrict equals\n!==\tStrict not equals\n==\tLoose equals\n!=\tLoose not equals\n>=\tGreater than or equal\n<=\tLess than or equal\n>\tGreater than\n<\tLess than\nConditionals\n\nFormKit schema can leverage references and expressions to make schema nodes and attributes conditional. These conditionals can be added in two ways:\n\nThe if property on $el and $cmp nodes.\nThe if/then/else object\nThe if property\n\nBoth $el and $cmp schema nodes can leverage an if property that roughly equates to a v-if in Vue. If the expression assigned to the if property is truthy, the node is rendered, otherwise it is not:\n\nRender\nHTML\nENSURE RE-RENDER WITH A KEY\n\nWhen adding an if property to $cmp or $formkit schema nodes that have dynamic values, Vue may reuse un-updated values and components for performance reasons. Adding a unique key property to the schema node will ensure Vue correctly re-renders the component.\n\nThe if/then/else object\n\nThe if/then/else object allows for more complex conditional logic. It can be used to conditionally render nodes, a list of schema nodes, values of the attrs object or values of the props object. It is also possible to nest if/then/else objects to create more complex structures — similar to an else if statement in JavaScript.\n\nUsing if/then/else on schema nodes\n\nYou can use the if/then/else object anywhere you would normally use a schema node. This includes the root schema array, or the children property of another schema node:\n\nRender\nHTML\nUsing if/then/else on attrs and props\n\nYou can also use if/then/else statements to conditionally output the values of attrs or props:\n\nRender\nHTML\nLoops\n\nBoth $el and $cmp schema nodes support looping. The loop syntax is similar to v-for in Vue and expects an object or array to iterate over and a property to assign the current iteration value to. Optionally, you can also capture the index or property of the current iteration:\n\nRender\nHTML\nSlots\n\nSchemas can render the slot content of the <FormKitSchema> component anywhere within the schema that a normal schema node can be rendered. All scoped slots are automatically provided to the schema under the $slots reference object:\n\nRender\nHTML\nFORMKIT INPUT SLOTS\n\nInside of a $formkit schema node, it is also possible to pass content to preexisting FormKit slots like label or prefix inside of the node's __raw__sectionsSchema property. Read more about raw values below, and sectionsSchema in the inputs documentation.\n\nBinding attrs and props\n\nAt times it may be necessary to pass an object of variable or unknown attributes or props to a $cmp or $el. In Vue we would do this using v-bind — in schema land we use the bind property:\n\nRender\nHTML\nRaw values\n\nAt times it may be necessary to prevent a given attribute or prop from being parsed. This can be done by prefixing an attribute or prop with __raw__:\n\n{\n\n  $cmp: 'PriceComponent',\n\n  props: {\n\n    __raw__price: '$2.99'\n\n  }\n\n}\n\nIn the above example, the __raw__ prefix will be removed, and the unparsed value of $2.99 will be passed as the price prop to the PriceComponent.\n\nAnother scenario where this comes into play is rendering FormKit components. The <FormKit> component has a sections-schema prop that allows users to pass down schema partials to merge with various sections of their input. In this edge case, we want to pass the schema chunks to the <FormKit> component as a raw JavaScript object. To do so, we once again prefix the sectionsSchema prop with __raw__:\n\nRender\nHTML\n\nNotice if you remove the __raw__ prefix from the above example, the prefix no longer has effect — this is because the sectionsSchema prop’s value was parsed when creating the component instead of passed as a JavaScript object.\n\nFormKit Inputs\n\nAlthough schemas can be used for almost any purpose — the primary objective is to empower developers to build complex and dynamic forms using a serializable data format. Using the schema with FormKit Inputs covers this use case well.\n\nAssuming you globally registered the FormKit component — you can render your FormKit inputs from schema by using the $cmp type schema node:\n\nRender\nHTML\nShorthand\n\nWhile the cmp syntax is generalized and works for any Vue component, it is somewhat verbose for FormKit Inputs. To make this easier, FormKit supports a fourth node type $formkit, which is syntactic sugar for the full $cmp format.\n\nWhen using the $formkit shorthand, the props object is flattened with the top-level properties (siblings of $formkit) For example:\n\nRender\nHTML\nAccessing other inputs\n\nThe schema format has one built-in function specific to FormKit Inputs: the $get function. This builtin allows the schema to access the context object of any other FormKit Input (even outside the immediate form) — provided the input in question has an explicitly declared id prop. This allows the schema to respond conditionally to the state of your own inputs:\n\nRender\nHTML\nForms\n\nTo render a form element, you can either use the $formkit: 'form' schema node, or wrap your <FormKitSchema> component in a <FormKit type=\"form\"> component:\n\nRender\nHTML"
  },
  {
    "title": "Custom Inputs ⚡️ FormKit",
    "url": "https://formkit.com/essentials/custom-inputs",
    "html": "Custom inputs\nRegistering inputs\nInput definition\nUsing the type prop\nGlobal custom inputs\nPlugin libraries\nSchema vs component\nFuture proofing\nSchema inputs\nComponent inputs\nInput & output values\nReceiving input\nDisplaying values\nAdding props\nAdding features\nTypeScript support\nAdding prop types\nAdding slot types\nExamples\nSimple text input\nAutocomplete input\nInput checklist\nBuilding your first custom input?\nRead the guide\n\nFormKit includes many inputs out of the box, but you can also define your own inputs that automatically inherit FormKit’s value-added features like validation, error messages, data modeling, grouping, labels, help text and others.\n\nMODIFY OR RESTRUCTURE AN EXISTING INPUT\n\nIf your use case requires modifications of an existing input, such as moving sections, changing or restructuring HTML elements, etc., consider using FormKit's input export feature.\n\nInputs are comprised of two essential parts:\n\nAn input definition.\nThe input’s code: a schema or a component.\nSTART WITH THE GUIDE\n\nIf you are just getting started with custom inputs, consider reading the “Create a custom input” guide. The content on this page is intended to explain the intricacies of custom inputs for advanced use cases like authoring a plugin or library and is not required for many common use cases.\n\nRegistering inputs\n\nNew inputs require an input definition. Input definitions can be registered with FormKit three ways:\n\nLocally on a FormKit component with the type prop.\nGlobally using defaultConfig.\nSelectively using plugin libraries.\nInput definition\n\nInput definitions are objects that contain the necessary information to initialize an input — like which props to accept, what schema or component to render, and if any additional feature functions should be included. The shape of the definition object is:\n\n{\n\n  // Node type: input, group, or list.\n\n  type: 'input',\n\n  // Schema to render (schema object or function that returns an object)\n\n  schema: [],\n\n  // A Vue component to render (use schema _OR_ component, but not both)\n\n  component: YourComponent,\n\n  // (optional) Input specific props the <FormKit> component should accept.\n\n  // should be an array of camelCase strings\n\n  props: ['fooBar'],\n\n  // (optional) Array of functions that receive the node.\n\n  features: []\n\n}\nUsing the type prop\n\nLet’s make the simplest possible input — one that only outputs \"Hello world\".\n\nRender\nHTML\n\nEven though this simplistic example doesn’t contain any input/output mechanism, it still qualifies as a full input. It can have a value, run validation rules (they wont be displayed, but they can block form submissions), and execute plugins. Fundamentally, all inputs are core nodes and the input’s definition provides the mechanisms to interact with that node.\n\nGlobal custom inputs\n\nTo use your custom input anywhere in your application via a \"type\" string (ex: <FormKit type=\"foobar\" />) you can add an inputs property to the defaultConfig options. The property names of the inputs object become the \"type\" strings available to the <FormKit> component in your application.\n\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\n\n\nconst helloWorld = {\n\n  type: 'input',\n\n  schema: ['Hello world'],\n\n}\n\n\n\ncreateApp(App)\n\n  .use(\n\n    plugin,\n\n    defaultConfig({\n\n      inputs: {\n\n        // The property will be the “type” in <FormKit type=\"hello\">\n\n        hello: helloWorld,\n\n      },\n\n    })\n\n  )\n\n  .mount('#app')\n\nNow that we’ve defined our input we can use it anywhere in the application:\n\nRender\nHTML\nPlugin libraries\n\nThe above example extends the @formkit/inputs library (via defaultConfig). However, a powerful feature of FormKit is its ability to load input libraries from multiple plugins. These inputs can then be registered anywhere plugins can be defined:\n\nGlobally\nPer group\nPer form\nPer list\nPer input\n\nLet’s refactor our hello world input to use its own plugin:\n\nRender\nHTML\nPLUGIN INHERITANCE\n\nNotice in the above example our plugin was defined on a parent of the element that actually used it! This is thanks to plugin inheritance — a core feature of FormKit plugins.\n\nSchema vs component\n\nYour input can be written using FormKit’s schema or a generic Vue component. There are pros and cons to each approach:\n\nCode\tPros\tCons\nVue\t\nLearning curve (you likely know how to write a Vue component).\nMore mature dev tooling.\nSlightly faster initial render.\n\t\nCannot use the :sections-schema prop to modify structure.\nPlugins cannot modify schema to change rendered output.\nFramework specific (Vue only).\nEasy to write inputs that don’t play well with the FormKit ecosystem.\n\nSchema\t\nStructure can be modified via the :sections-schema prop (if you allow it).\nPlugins can modify/change the rendered output.\nFramework agnostic (future portability to when FormKit supports new frameworks).\nEcosystem compatibility (great for publishing your own open source inputs).\n\t\nLearning curve (need to understand schemas).\nSlightly slower initial render.\nLess mature dev tooling.\nCOMPONENTS IN SCHEMAS\n\nEven if you prefer to write a custom input using a standard Vue Component, you can still use a schema in your input definition. Please read the Using createInput to extend the base schema section.\n\nThe primary takeaway is if you are planning to use a custom input on multiple projects — then consider using the schema-based approach. If your custom input will only be used on a single project and flexibility is not a concern, use a Vue component.\n\nFuture proofing\n\nIn the future, FormKit may expand to support additional frameworks (ex: React or Svelte. If this is something you are interested in, let us know!.) Writing your inputs using schema means your inputs will be compatible (perhaps minimal changes) with those frameworks too.\n\nSchema inputs\n\nAll of FormKit’s core inputs are written using schemas to allow for the greatest flexibility possible. You have two primary options when writing your own schema inputs:\n\nExtend the base schema (recommended).\nWrite your input from scratch.\n\nIt is important to understand the basic structure of a “standard” FormKit input, which is broken down into sections:\n\nouter\nlabel\nprefixIcon\nprefix\ninput\nhelp\nEmail address\n🤟\ntest@example.com\n🚀\nPlease use your school email address.\nPlease provide a valid email.\nwrapper\ninner\nsuffix\nsuffixIcon\nmessages\nmessage\nComposition of a standard FormKit text input.\n\nThe input section in the diagram above is typically what you’ll swap out when creating your own inputs — keeping the wrappers, labels, help text, and messages intact. However, if you want to control these aspects as well, you can also write your own input from scratch.\n\nUsing createInput to extend the base schema\n\nTo create inputs using the base schema you can use the createInput() utility from the @formkit/vue package. This function accepts 2 arguments:\n\n(required) A schema node or a Vue component, which it inserts into the base schema at the input section (see diagram above).\n(optional) An object of input definition properties to merge with an auto-generated one.\n\nThe function returns a ready-to-use input definition.\n\nWhen providing a component as the first argument, createInput will generate a schema object that references your component within the base schema. Your component will be passed a single context prop:\n\n{\n\n  $cmp: 'YourComponent',\n\n  props: {\n\n    context: '$node.context'\n\n  }\n\n}\n\nWhen providing a schema object, your schema is directly injected into the base schema object. Notice that our hello world example now supports outputting \"standard\" FormKit features like labels, help text, and validation:\n\nRender\nHTML\nWriting schema inputs from scratch\n\nIt might make sense to write your inputs completely from scratch without using any of the base schema features. When doing so, just provide the input definition your full schema object.\n\nRender\nHTML\n\nIn the above example, we were able to re-create the same features as the createInput example — namely — label, help text, and validation message output. However, we are still missing a number of \"standard\" FormKit features like slot support. If you are attempting to publish your input or maintain API compatibility with the other FormKit inputs, take a look at the input checklist.\n\nComponent inputs\n\nFor most users, passing a Vue component to createInput provides a good balance between customization and value-added features. If you’d like to completely eject from schema-based inputs all together, you can pass a component directly to an input definition.\n\nComponent inputs receive a single prop — the context object. It’s then up to you to write a component to encompasses the desired features of FormKit (labels, help text, message display, etc.). Checkout the input checklist for a list of what you’ll want to output.\n\nInput & output values\n\nInputs have two critical roles:\n\nReceiving user input.\nDisplaying the current value.\nReceiving input\n\nYou can receive input from any user interaction and the input can set its value to any type of data. Inputs are not limited to strings and numbers — they can happily store Arrays, Objects, or custom data structures.\n\nFundamentally, all an input needs to do is call node.input(value) with a value. The node.input() method is automatically debounced, so feel free to call it frequently — like every keystroke. Typically, this looks like binding to the input event.\n\nThe context object includes an input handler for basic input types: context.handlers.DOMInput. This can be used for text-like inputs where the value of the input is available at event.target.value. If you need a more complex event handler, you can expose it using \"features\".\n\nAny user interaction can be considered an input event. For many native HTML inputs, that interaction is captured with the input event.\n\n// An HTML text input written in schema:\n\n{\n\n  $el: 'input',\n\n  attrs: {\n\n    onInput: '$handlers.DOMInput'\n\n  }\n\n}\n\nThe equivalent in a Vue template:\n\n<template>\n\n  <input @input=\"context.DOMInput\" />\n\n</template>\nDisplaying values\n\nInputs are also responsible for displaying the current value. Typically, you’ll want to use the node._value or $_value in schema to display a value. This is the \"live\" non-debounced value. The currently committed value is node.value ($value). Read more about \"value settlement\" here.\n\n// An HTML text input written in schema:\n\n{\n\n  $el: 'input',\n\n  attrs: {\n\n    onInput: '$handlers.DOMInput',\n\n    value: '$_value'\n\n  }\n\n}\n\nThe equivalent in a Vue template:\n\n<template>\n\n  <input :value=\"context._value\" @input=\"context.handlers.DOMInput\" />\n\n</template>\n_VALUE VS VALUE\n\nThe only time the uncommitted input _value should be used is for displaying the value on the input itself — in all other locations, it is important to use the committed value.\n\nAdding props\n\nThe standard FormKit props that you can pass to the <FormKit> component (like label or type) are available in the root of the context object and in the core node props, and you can use these props in your schema by directly referencing them in expressions (ex: $label). Any props passed to a <FormKit> component that are not node props end up in the context.attrs object (just $attrs in the schema).\n\nIf you need additional props, you can declare them in your input definition. Props can also be used for internal input state (much like a ref in a Vue 3 component). FormKit uses the props namespace for both purposes (see the autocomplete example below for an example of this). Props should always be defined in camelCase and used in your Vue templates with kebab-case.\n\nRender\nHTML\n\nWhen extending the base schema by using the createInput helper, pass a second argument with input definition values to merge:\n\nRender\nHTML\nAdding features\n\nFeatures are the preferred way to add functionality to a custom input type. A \"feature\" is simply a function that receives the core node as an argument. Effectively, they are plugins without inheritance (so they only apply to the current node). You can use features to add input handlers, manipulate values, interact with props, listen to events, and much more.\n\nFeatures are defined in an array to encourage code reuse when possible. For example, we use a feature called “options” on select, checkbox, and radio inputs.\n\nAs an example, let's imagine you want to build an input that allows users to enter two numbers, and the value of the input is the sum of those two numbers:\n\nRender\nHTML\nTypeScript support\n\nFormKit is written in TypeScript and includes type definitions for all of its core inputs. If you are writing your own inputs and would like to provide TypeScript support you can define your own inputs using two module augmentations:\n\nAdding prop types\n\nThe type prop of the <FormKit> component is a string that is used as the key of a discriminated union of props (FormKitInputProps). By augmenting this type your custom inputs can define their own prop types. To do so you must augment the FormKitInputProps type to add your own custom types:\n\ndeclare module '@formkit/inputs' {\n\n  interface FormKitInputProps<Props extends FormKitInputs<Props>> {\n\n    // This key and the `type` should match:\n\n    'my-input': {\n\n      // Define your input `type`:\n\n      type: 'my-input',\n\n      // Define an optional prop. Use camelCase for all prop names:\n\n      myOptionalProp?: string | number\n\n      // Define a required prop\n\n      superImportantProp: number\n\n      // Define the value type, this should always be a optional!\n\n      value?: string | number\n\n      // Use the Prop generic to infer information from another field, notice\n\n      // we a utility \"PropType\" to infer the type of the `value` from the Props\n\n      // generic:\n\n      someOtherProp?: PropType<Props, 'value'>\n\n    }\n\n  }\n\n}\nAdding slot types\n\nIf you define your own sections (slots) in your custom input, you can also add TypeScript support for those too. To do so, you must augment the FormKitInputSlots type to add your own custom slots:\n\ndeclare module '@formkit/inputs' {\n\n  interface FormKitInputProps<Props extends FormKitInputs<Props>> {\n\n    'my-input' {\n\n      type: 'my-input'\n\n      // ... props here\n\n    }\n\n  }\n\n\n\n  interface FormKitInputSlots<Props extends FormKitInputs<Props>> {\n\n    'my-input': FormKitBaseSlots<Props>\n\n  }\n\n}\n\nIn the example above, we use FormKitBaseSlots — a TypeScript utility to add all the \"basic\" slots that most custom inputs implement, like outer, label, help, message, etc. However you could also define your own slots entirely from scratch, or augment FormKitBaseSlots to add additional slots (FormKitBaseSlots<Props> & YourCustomSlots).\n\ndeclare module '@formkit/inputs' {\n\n  // ... props here\n\n  interface FormKitInputSlots<Props extends FormKitInputs<Props>> {\n\n    'my-input': {\n\n      // This will be the *only* slot available on the my-input input\n\n      slotName: FormKitFrameworkContext & {\n\n          // this will be available as slot data in the `slotName` slot\n\n          fooBar: string\n\n        }\n\n      }\n\n    }\n\n  }\n\n}\nAUGMENT PROPS FIRST\n\nIn order to augment the FormKitInputSlots, you must first have written an augmentation for FormKitInputProps that at least includes the type prop.\n\nExamples\n\nBelow are some examples of custom inputs. They are not intended to be comprehensive or production ready, but rather illustrate some custom input features.\n\nSimple text input\n\nThis is the simplest possible input and does not leverage any of FormKit’s built in DOM structure and only outputs a text input — however it is a fully functional member of the group it is nested inside of and able to read and write values.\n\nRender\nHTML\nDOM INPUT\n\nIn the above example the $handlers.DOMInput is a built-in convenience function for (event) => node.input(event.target.value).\n\nAutocomplete input\n\nLet’s take a look at a slightly more complex example that utilizes createInput to provide all the standard FormKit structure while still providing a custom input interface.\n\nRender\nHTML\nInput checklist\n\nFormKit exposes dozens of value-added features to even the most mundane inputs. When writing a custom input for a specific project, you only need to implement the features that will actually be used on that project. However, if you plan to distribute your inputs to others, you will want to ensure these features are available. For example, the standard <FormKit type=\"text\"> input uses the following schema for its input element:\n\n{\n\n  $el: 'input',\n\n  bind: '$attrs',\n\n  attrs: {\n\n    type: '$type',\n\n    disabled: '$disabled',\n\n    class: '$classes.input',\n\n    name: '$node.name',\n\n    onInput: '$handlers.DOMInput',\n\n    onBlur: '$handlers.blur',\n\n    value: '$_value',\n\n    id: '$id',\n\n  }\n\n}\n\nThere are several features in the above schema that may not be immediately obvious like the onBlur handler. The following checklist is intended to help input authors cover all their bases:\n\nHow is your input built?\nBuilt with\ncreateInput()\nBuilt from scratch\nOuter wrapper\nThe outermost wrapper element on all FormKit inputs.\nLabel display\nThe value of the label prop must be displayed and linked for accessibility with the for attribute.\nLabel slot\nUsers can override the label slot.\nLabel section key\nUsers can extend the label section using the label section key.\nHelp display\nThe value of the help prop must be displayed.\nHelp slot\nUsers can override the help slot.\nHelp section key\nUsers can extend the help section using the help section key.\nMessages\nEach message in the context.messages object must displayed if it is set to visible.\nMessages slot\nUsers can override the messages slot.\nMessages section key\nUsers can extend the messages section using the messages section key.\nMessage slot\nUsers can override the message slot.\nMessage section key\nUsers can extend the message section using the message section key..\nInput slot\nUsers can override the input slot.\nInput id attribute\nThe primary input element should include an id attribute (context.id).\nInput name\nThe primary input element should include a name attribute (context.node.name).\nBlur handler\nThe primary input element should call context.handlers.blur when blurred.\nInput handler\nThe primary input element should call node.input(value) when the user provides input. You can use context.handlers.DOMInput for text-like inputs.\nInput value display\nThe primary input element should display the current value of the input using context._value.\nDisabled\nThe primary input element should apply the disabled attribute when context.disabled is true.\nAttribute passthrough\nAll events bindings should be passed through. Use bind: '$attrs' in schemas.\nStandardized classes\nClasses for all DOM elements should be applied using context.classes.{section-key}."
  },
  {
    "title": "Internationalization (i18n) ⚡️ FormKit",
    "url": "https://formkit.com/essentials/internationalization",
    "html": "Internationalization (i18n)\nAvailable languages\nUsing a locale\nChanging the active locale\nUsing setLocale\nUsing root config\nOverriding\nAdding your language\n\nFormKit ships with internationalization support for all of its interfaces and validation messages.\n\nAvailable languages\n\nCurrently, FormKit supports the following languages (in the @formkit/i18n package):\n\n🇱🇾 Arabic (ar) — 🙏 @Ahmedelforjani\n🇦🇿 Azerbaijani (az) — 🙏 @EmrullahKutlar\n🇧🇬 Bulgarian (bg) — 🙏 @ivanov1234159\n🇧🇦 Bosnian (bs) — 🙏 @TarikTz\n Catalan (ca) — 🙏 @petergithubmgw\n🇨🇳 Chinese (zh) — 🙏 @myleslee\n🇨🇳 Chinese Traditional (zh-TW) — 🙏 @actocoa\n🇭🇷 Croatian (hr) — 🙏 @antemarkic\n🇨🇿 Czech (cs) — 🙏 @dfridrich\n🇩🇰 Danish (da) — 🙏 @bjerggaard\n🇳🇱 Dutch (nl) — 🙏 @arjendejong12\n🇺🇸 English (en)\n🇫🇮 Finish - (fi) — 🙏 @mihqusta\n🇫🇷 French (fr) — 🙏 @HoreKk, @pop123123123\n Frisian (fy) — 🙏 @arjendejong12\n🇩🇪 German (de) — 🙏 @digitalkaoz, @tosling\n🇬🇷 Greek (el) — 🙏 @mendrinos\n🇮🇱 Hebrew (he) - 🙏 @Hepi420\n🇭🇺 Hungarian (hu) — 🙏 @KristofKekesi\n🇮🇸 Icelandic (is) - 🙏 @Gunsobal\n🇮🇩 Indonesian (id) - 🙏 @rama-adi\n🇮🇹 Italian (it) - 🙏 @punga78, @Archetipo95\n🇯🇵 Japanese (ja) - 🙏 @wonyx\n🇰🇿 Kazakh (kk) - 🙏 @ilya-raevskiy\n🇰🇷 Korean (ko) - 🙏 @bwp618, @titusdecali\n🇱🇻 Latvian (lv) - 🙏 @Bamslation\n🇱🇹 Lithuanian (lt) - 🙏 @balu-lt\n🇲🇳 Mongolian (mn) - 🙏 @zemunkh\n🇳🇴 Norwegian Bokmål (nb) - 🙏 @hognevevle\n🇮🇷 Persian (fa) - 🙏 @shahabbasian\n🇵🇱 Polish (pl) - 🙏 @xxSkyy\n🇧🇷 Portuguese (pt) 🙏 @r-martins, @dbomfim\n🇷🇴 Romanian (ro) - 🙏 @danve\n🇷🇺 Russian (ru) - 🙏 @andreimakushkin\n🇸🇰 Slovak (sk) - 🙏 @neridev\n🇸🇮 Slovenian (sl) - 🙏 @krisflajs\n🇷🇸 Serbian (sr) - 🙏 @milos5593\n🇦🇷 Spanish (es) - 🙏 @inibg\n🇸🇪 Swedish (sv) - 🙏 @purung\n🇹🇯 Tajik (tg) - 🙏 @devixrootix\n🇹🇱 Tetum (tet) - 🙏 @joshbrooks\n🇹🇭 Thai (th) - 🙏 @pknn\n🇺🇦 Ukrainian (uk) - 🙏 @aresofficial\n🇺🇿 Uzbek (uz) - 🙏 @root5427\n🇹🇷 Turkish (tr) - 🙏 @ragokan, @cemkaan\n🇻🇳 Vietnamese (vi) - 🙏 @oanhnn\n\nAlthough flags are poor representations of languages (flags indicate a geographic nation, while languages can be spoken in many ares of the world), we use the flags in the list above to indicate the location of the contributor who created that particular locale.\n\nHelp others who speak your language!\nContribute a locale\nUsing a locale\n\nFormKit’s defaultConfig includes the english locale by default — to add an additional locale, import it from @formkit/i18n and append it to the locales option when you initialized the FormKit plugin. To set the active locale specify it with the locale option:\n\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\nimport { de, fr, zh } from '@formkit/i18n'\n\n\n\nconst app = createApp(App)\n\napp.use(\n\n  plugin,\n\n  defaultConfig({\n\n    // Define additional locales\n\n    locales: { de, fr, zh },\n\n    // Define the active locale\n\n    locale: 'fr',\n\n  })\n\n)\n\napp.mount('#app')\nChanging the active locale\n\nThere are two ways to change your active locale:\n\nUsing this.$formkit.setLocale() from the Vue plugin (best for options API).\nDirectly modifying the root config object (best for composition API).\nUsing setLocale\n\nWhen using Vue’s options API, you have access to this.$formkit which contains setLocale('de') — a purpose-built method that globally changes the current locale:\n\nRender\nHTML\nUsing root config\n\nWhen using the composition API, you won’t have access to this.$formkit. Instead, you can fetch and modify the root FormKit configuration object. This is made available globally via Vue’s inject mechanism and a unique Symbol:\n\nRender\nHTML\nOverriding\n\nIf you find a phrase in your locale isn’t worded the way you prefer, you can override those individual messages globally in your configuration. You can do this by providing a messages object to the defaultConfig:\n\nimport { createApp } from 'vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\nimport App from 'App.vue'\n\n\n\nconst app = createApp(App)\n\napp.use(\n\n  plugin,\n\n  defaultConfig({\n\n    messages: {\n\n      en: {\n\n        ui: {\n\n          submit: '🚀 Launch',\n\n        },\n\n      },\n\n    },\n\n  })\n\n)\nMESSAGE KEYS\n\nMessages are generally found under a locale’s ui or validation property. To see a full list of keys and messages checkout the english locale.\n\nAdding your language\n\nWriting a locale for a language you know is a great way to contribute to FormKit and an easy way to get started with open source too! We are always eager to see pull requests for new locales. To support this effort, we’ve created a locale builder — a small web app to make the translation process as easy as possible.\n\nHelp others who speak your language!\nContribute a locale\n\nOf course, you are not required to use our locale builder to submit a language, and are more than welcome to submit a standard pull request with your locale included.\n\nLOCALIZATION\n\nIf your language is already on the list (let's say English), but your locality speaks a variation of that language (like 🇬🇧 en-GB), please feel free to submit your localized language.\n"
  },
  {
    "title": "Icons ⚡️ FormKit",
    "url": "https://formkit.com/essentials/icons",
    "html": "Icons\nAvailable icons\nInstallation & setup\nIf your project uses a custom config\nRegistering icons\nHow are icons loaded?\nAdding icons to the iconRegistry\nOutputting icons\nAdding icons to inputs\nUsing custom SVG icons\nUsing the <FormKitIcon /> component\nIcon click handlers\nUsing 3rd-party libraries\nUsing FontAwesome with a custom iconLoaderUrl\nAn example Heroicons iconLoader\n\nFormKit comes with over 130 icons out-of-the-box! With the exception of the brand icons (like YouTube, TikTok, or Visa) all icons are original and MIT-licensed for free use within your project. You can use our icons, add your own, or easily connect to a 3rd-party icon set.\n\nUsing icons in your project is as easy as providing your desired icon name to one of an input's icon props.\n\n<FormKit prefix-icon=\"email\" />\n\n<FormKit suffix-icon=\"settings\" />\n\n<FormKit type=\"select\" select-icon=\"caretDown\" />\n\nIt's that easy! 🎉\n\nA quick demo of icons in action\nRender\nHTML\nAvailable icons\n\nThe @formkit/icons package ships with over 130 common icons to make getting started easy! Use the search below to filter the available icons:\n\nSearch icons\nApplications\nadd\navatarMan\navatarWoman\nbookmark\ncheck\ncircle\nclose\ncompress\nexpand\nexportAction\neye\neyeClosed\nfastForward\nflag\nhappy\nheart\nhelp\ninfo\nlink\nlinkExternal\nmegaphone\nminimize\nopen\npause\npeople\nplay\nplayCircle\nrefresh\nreorder\nreply\nrewind\nsad\nsearch\nsettings\nshare\nspinner\nstar\nstart\nstepBack\nstepForward\nstop\ntag\ntools\ntrash\nvolumeDown\nvolumeUp\nwarning\nBrands\nandroid\napple\nfacebook\ngithub\ngoogle\ninstagram\nlinkedin\nmedium\npinterest\nreddit\nskype\nsnapchat\ntiktok\ntwitter\nvimeo\nwhatsapp\nwordpress\nyoutube\nCrypto\nbitcoin\nbnb\ncardano\ndogecoin\nethereum\nsolana\ntether\nusdc\nCurrency\ndollar\neuro\nfranc\nkrona\nlira\nmultiCurrency\npeso\npound\nruble\nrupee\nshekel\nwon\nyen\nyuan\nDirectional\narrowDown\narrowLeft\narrowRight\narrowUp\ncaretDown\ncaretLeft\ncaretRight\ncaretUp\ndown\nleft\nright\nup\nFiles\ndownload\ndownloadCloud\nfileAudio\nfileDoc\nfileImage\nfilePdf\nfileVideo\nfolder\nupload\nuploadCloud\nzip\nInputs\nbutton\ncheckbox\ncolor\ndate\ndatetime\nemail\nfile\ngroup\nhidden\nlist\nmonth\nnumber\npassword\nradio\nrange\nrepeater\nselect\nsubmit\ntelephone\ntext\ntextarea\ntime\nurl\nweek\nPayments\namex\ndiscover\nmastercard\npaypal\nstripe\nvisa\nInstallation & setup\n\nFor most users no installation is required to use icons (although we recommend adding your icons to the iconRegistry for best performance). Icon support is provided via a 1st-party FormKit plugin called createThemePlugin(). This plugin is enabled by default if you are using FormKit's defaultConfig().\n\nICON FUNCTIONALITY IS INSTALLED BY DEFAULT IN FORMKIT\n\nThe FormKit createThemePlugin() is enabled by default in the FormKit’s defaultConfig(). If your project is using defaultConfig() (this is usually the case), then getting started is as simple as using the ${section}-icon props available on FormKit components — no additional setup required.\n\nWhen using the defaultConfig that ships with FormKit, you can use several top-level configuration options to customize your experience. See the createThemePlugin docs in the next section for expanded explanations of each.\n\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\n\n\ncreateApp(App).use(plugin, defaultConfig({\n\n  ...\n\n  icons: { heart: '<svg...' }, // allows defining icons for use without remote fetching\n\n  iconLoaderUrl: (iconName) => `https://...`, // where to load remote icons\n\n  iconLoader: (iconName) => {}, // function for more direct control than iconLoaderUrl replacement\n\n  ...\n\n}).mount('#app')\nIf your project uses a custom config\n\nIf your project is not using FormKit’s provided defaultConfig then you will need to install the createThemePlugin() in your FormKit project's config:\n\nImport createThemePlugin() from the @formkit/themes package.\nAdd createThemePlugin() to your project's plugin array inside of your FormKit config.\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { createThemePlugin } from '@formkit/themes'\n\nimport { plugin } from '@formkit/vue'\n\n\n\n// IMPORTANT: This is only required for apps NOT using defaultConfig()\n\ncreateApp(App).use(plugin, {\n\n  ...\n\n  plugins: [\n\n    createThemePlugin()\n\n  ]\n\n  ...\n\n}.mount('#app')\n\nThe createThemePlugin takes 4 optional arguments:\n\ntheme: A string representation of a FormKit theme name, eg. 'genesis'. When provided, if a matching FormKit theme is found, it will be loaded via CDN automatically.\nicons: An object of SVG icons to be added to the internal iconRegistry. Keys are icon names and values are SVGs, eg { heart: '<svg ...' }\niconLoaderUrl: A function that receives iconName and returns a URL where the icons can be loaded not found in the iconRegistry. See example\niconLoader: A function that receives iconName and returns a Promise that resolves to a SVG (as a string) or undefined. Use this when you need more control than just overriding the iconLoaderUrl. See example\n\nOnce the theme plugin is installed in your project, your FormKit inputs will have icon props available to use.\n\nRegistering icons\nHow are icons loaded?\n\nFormKit goes through 4 steps when attempting to load an icon. They are, in order:\n\nSVG prop value - If the prop value is an SVG (e.g. prefix-icon=\"<svg ...\"), then the provided SVG will be used.\nThe iconRegistry - If the prop value is a string that is not an SVG, then FormKit will look for the icon in its internal iconRegistry for a matching key.\nYour project's CSS variables - If there is a CSS variable that matches --fk-icon-${yourIconName} defined in your CSS, it will be loaded into the iconRegistry. The value of the CSS variable should be a base64-encoded SVG — it should not be wrapped in quotes. This is how FormKit ships default icons for inputs in its 1st-party themes.\nVia CDN - If no matching icon can be found in your codebase, then a request will be made to the @formkit/icons package via CDN. If a matching icon name is found it will be used. You can override where remote icons are loaded if you'd like to use a 3rd-party icon library as a fallback.\n\nBecause FormKit falls back to CDN requests for icons, you can easily get started in a new project by providing supported icon names to your input’s icon props and they will be loaded for you automatically — no additional setup required! 🪄\n\nRemotely loaded SVGs are added to the internal iconRegistry the first time an icon is fetched. Additional requests for the same icon will be cached until a user reloads your application.\n\nAdding icons to the iconRegistry\n\nMagic CDNs are great — but for the best possible performance you should register icons you know you will be using locally in your project. You can do this by adding icons to your root FormKit config. FormKit's 1st-party icons can be imported from the @formkit/icons package.\n\nyarn add @formkit/icons\nimport { createApp } from 'vue'\n\nimport App from 'App.vue'\n\nimport { applicationIcons, ethereum } from '@formkit/icons'\n\nimport { thirdPartyIcon } from '@some-other-icon-package'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\n\n\ncreateApp(App).use(plugin, defaultConfig({\n\n  ...\n\n  icons: {\n\n    ...applicationIcons, // spread an entire group of icons\n\n    ethereum, // or add single icons\n\n    thirdPartyIcon, // you can import any SVG icon\n\n    formkit: `<svg ...` // or define your own\n\n  }\n\n  ...\n\n}).mount('#app')\nPERFORMANCE\n\nFormKit automatically loads missing icons from its icon package via CDN. This is great for quickly getting up and running, but we recommend registering icons you know you will end up using into the iconRegistry for best performance.\n\nOutputting icons\nAdding icons to inputs\n\nMany FormKit inputs support suffix and prefix icons. You can use the prefix-icon and suffix-icon props on any text-like input such as text, email, search, date, etc. These props are available on the select, color, and range inputs as well.\n\nThe select input has a select-icon prop that allows you to change the icon used for the select input’s control.\n\nThe file input has file-remove-icon and file-item-icon props:\n\nRender\nHTML\nUsing custom SVG icons\n\nSometimes you need to render a one-off icon in your project. You can directly supply an SVG definition to an icon prop and the SVG will be rendered for you:\n\nRender\nHTML\nUsing the <FormKitIcon /> component\n\nFormKit ships with a component called <FormKitIcon /> that allows you to output any icon from the iconRegistry anywhere within your project. Need an icon you're using in FormKit on some other part of your UI? No problem:\n\nRender\nHTML\nIcon click handlers\n\nEvery icon prop registers a click-handler prop. For example, the prefix-icon prop will have a corresponding @prefix-icon-click prop.\n\nEach click-handler prop receives the input's core node and the click event as arguments.\n\nRender\nHTML\nUsing 3rd-party libraries\n\nIf you want to use a 3rd-party icon set in your FormKit project, you can supply a custom iconLoaderUrl or complete iconLoader (either globally, at the node config level, or as a component prop) which is responsible for retrieving icons that do not already exist in the iconRegistry.\n\nLOADERS ARE FOR FALLBACKS\n\nThe iconLoaderUrl and iconLoader functions are only meant to handle missing icons! For the best possible performance you can (and should) load any SVG icons you know you will be using into the iconRegistry by using the icons configuration prop in your FormKit config.\n\nSometimes — in cases such as a form builder or CMS — you don't know in advance which icons you’ll need. That's where remote loading of icons shines.\n\nThe iconLoaderUrl and iconLoader functions each receive the current iconName as an argument\nThe return value of iconLoaderUrl should be a URL to a remote CDN where the icon SVG can be found. This is the easiest way to change the fallback loading behavior.\nif you need more control use iconLoader which allows replacement of all the logic for remote icon fetching. This function should return a Promise that resolves to string (the SVG) or undefined.\nYou only need to use iconLoaderUrl or iconLoader — if you supply both then iconLoader takes precedence.\nUsing FontAwesome with a custom iconLoaderUrl\n\nBelow is an implementation of FormKit loading icons from FontAwesome by replacing the iconLoaderUrl with a different CDN path.\n\nRender\nHTML\nAn example Heroicons iconLoader\n\nBelow is an implementation of FormKit with a fully custom iconLoader that fetches missing icons from Heroicons instead of the FormKit icon set.\n\nRender\nHTML"
  },
  {
    "title": "Validation ⚡️ FormKit",
    "url": "https://formkit.com/essentials/validation",
    "html": "Validation\nDeclaring rules\nString syntax\nArray syntax\nShowing errors\nSetting validation visibility for an entire group\nRule hints\nDebounce (milli)\nEmpty +\nForce *\nOptional ?\nAvailable rules\nAccepted\nAlpha\nAlphanumeric\nAlpha-spaces\nBetween\nConfirm\nContains Alpha\nContains Alphanumeric\nContains Alpha-spaces\nContains Lowercase\nContains Numeric\nContains Symbol\nContains Uppercase\nDate after\nDate before\nDate between\nDate format\nEmail\nEnds with\nIs\nLength\nLowercase\nMatches\nMax\nMin\nNot\nNumber\nRequired\nRequire One\nStarts With\nSymbol\nUppercase\nURL\nCustom rules\nDefining custom rule behaviors\nMulti-input validation rules\nAdding a rule globally\nAdding a rule via prop\nCustom messages\nValidation message prop\nGlobal validation message\nMoving validation messages\nExtracting messages\n\nFormKit makes front end validation simple by letting you declare your validation rules directly on your inputs. It's easy to write custom rules too, but you'll rarely need to with 20+ production-ready rules.\n\nDeclaring rules\nHow to Validate an Input - Vue School Course\n\n8 mins\n\nDeclaring which validation rules apply to a given input is as simple as providing a validation prop. Rules can be declared using two syntaxes:\n\nString syntax\nArray syntax\nString syntax\n\nValidation rules can be declared by specifying each desired rule name separated by pipes |. Some rules may also accept arguments, which can be supplied after a colon :. You can use multiple arguments by comma separating them:\n\nRender\nHTML\nArray syntax\n\nValidation rules can also be declared by providing an array. Each element of the array must be itself an array where the first element is the string name of the validation rule, and the remaining n elements are arguments for that rule.\n\nThis is especially helpful if the arguments being provided need to be actual JavaScript types — for example, a regular expression (regex):\n\nRender\nHTML\nShowing errors\n\nValidation rules are always computed in realtime — meaning a given field will always be either valid or invalid (it is considered invalid while pending async validation rules run). However — the visibility of the validation errors is determined by the validation-visibility prop.\n\nVisibility\tDescription\nblur\t(Default) Errors are shown after a user removes focus from an input.\nlive\tErrors are always visible.\ndirty\tErrors are shown after a user modifies the value of an input.\nsubmit\tErrors are shown only after a user attempts to submit a form.\nFORM SUBMISSION\n\nIf an input is inside a form, then any remaining validation messages will be displayed to the end user when a user attempts to submit the form.\n\nSetting validation visibility for an entire group\n\nDue to FormKit's config inheritance, you can set validation-visibility at a form, group, or list level by using the config prop, which you can still override on an input-by-input basis:\n\nRender\nHTML\nRule hints\nValidation rule hints overview\n\n2 mins\n\nValidation rules operate according to a few default features, which you can change on a case-by-case basis with \"rule hints\":\n\nRun in sequence - rules are run in the order they are declared. When a rule fails, any remaining rules are not run. For example, if you declare the validation rules as required|length:5 then the length rule will not run until the required rule is passing.\nSkipped when empty - Validation rules are not run when the input is empty (within the available rules, the required rule is the only exception).\nSynchronous - all available rules are synchronous and not debounced.\nBlocking - all validation rules produce blocking messages which prevent form submission.\n\nThe above features can be modified when declaring your rules by using \"hinting\". Rule hints are small modifier characters you append to the beginning of a rule declaration to change its default behavior:\n\nHint\tName\tDescription\n(200)\tDebounce\tDebounces the validation rule by the given number of milliseconds.\n+\tEmpty\tRuns the validation rule even if the input is empty (but not force the rule).\n*\tForce\tRuns the validation rule even if a previous rule was failing.\n?\tOptional\tMakes a validation rule optional (it is non-blocking meaning the form can still submit).\nDebounce (milli)\n\nAt times it makes sense to debounce your validation rules. To do this use the debounce hint — a parenthesis containing a duration in milliseconds — before your rule:\n\nRender\nHTML\nEmpty +\n\nSometimes you want a validation rule to run even when an input is empty. You can use the empty + hint to do so:\n\nRender\nHTML\nForce *\n\nThe force hint ensures a validation rule will run even if a rule that is defined before it is failing (note: this does not mean it will run when an input is empty). Notice how this example will display both the length and email messages:\n\nRender\nHTML\nOptional ?\n\nThe optional hint allows a failing validation rule to not prevent form submission. In this example, notice how the form will not submit if the required or confirm rules are failing, but it will submit if the optional-hinted length rule is failing:\n\nRender\nHTML\nCOMBINING HINTS\n\nYou can use rule hints together. To do so, just place multiple hints before the rule declaration: required|*+(200)min:10.\n\nAvailable rules\n\nFormKit ships with over 20 production-ready validation rules, covering most validation needs. If you don’t find one that meets your exact requirement, you can add a custom rule to suit your needs.\n\naccepted\nalpha\nalphanumeric\nalpha_spaces\nbetween\nconfirm\ncontains_alpha\ncontains_alphanumeric\ncontains_alpha_spaces\ncontains_lowercase\ncontains_numeric\ncontains_symbol\ncontains_uppercase\ndate_after\ndate_before\ndate_between\ndate_format\nemail\nends_with\nis\nlength\nlowercase\nmatches\nmax\nmin\nnot\nnumber\nrequired\nrequire_one\nstarts_with\nsymbol\nuppercase\nurl\nAccepted\n\nThe value must be yes, on, 1 or true. Useful for checkbox inputs — often where you need to validate if someone has accepted terms.\n\nRender\nHTML\nAlpha\n\nChecks if a value is only alphabetical characters. There are two character sets: latin and default. Latin characters are strictly [a-zA-Z], while the default set includes most accented characters, such as ä, ù, or ś.\n\nRender\nHTML\nAlphanumeric\n\nChecks if a value is only made of alphabetical characters or numeric digits. For the alphabetical portion you can pass default or latin - see alpha) above.\n\nRender\nHTML\nAlpha-spaces\n\nChecks if a value is only made of alphabetical characters or spaces. For the alphabetical portion you can pass default or latin - see alpha) above.\n\nRender\nHTML\nBetween\n\nChecks if a number is (inclusively) between two other numbers. The input value must be a number, or the validation rule will fail.\n\nRender\nHTML\nConfirm\n\nChecks if the value of one input matches the value of another input — often used for password confirmations. There are two ways to specify which input to match:\n\nAppend _confirm to the name attribute of the second input.\nPass the name of the first input as an argument to the confirm rule in the second input confirm:name_of_input_1 (more specific).\n\nNote: the two inputs must be in the same group or form.\n\nRender\nHTML\nContains Alpha\n\nChecks if a value contains alphabetical characters. There are two character sets: latin and default. Latin characters are strictly [a-zA-Z], while the default set includes most accented characters, such as ä, ù, or ś.\n\nRender\nHTML\nContains Alphanumeric\n\nChecks if a value contains either alphabetical characters or numeric digits. For the alphabetical portion you can pass default or latin - see contains alpha) above.\n\nRender\nHTML\nContains Alpha-spaces\n\nChecks if a value contains alphabetical characters or spaces. For the alphabetical portion you can pass default or latin - see contains alpha) above.\n\nRender\nHTML\nContains Lowercase\n\nChecks if a value contains a lowercase character. There are two character sets: latin and default. Latin characters are strictly [a-zA-Z], while the default set includes most accented characters, such as ä, ù, or ś.\n\nRender\nHTML\nContains Numeric\n\nChecks if a value contains a number.\n\nRender\nHTML\nContains Symbol\n\nChecks if a value contains a symbol.\n\nRender\nHTML\nContains Uppercase\n\nChecks if a value contains a uppercase character. There are two character sets: latin and default. Latin characters are strictly [a-zA-Z], while the default set includes most accented characters, such as ä, ù, or ś.\n\nRender\nHTML\nDate after\n\nDetermines if a date is after the current date or a date supplied as the rule's argument. Dates used can either be JavaScript Date objects or strings that can be parsed by Date.parse().\n\nRender\nHTML\nDate before\n\nDetermines if a date is before the current date or a date supplied as the rule's argument. Dates used can either be JavaScript Date objects or strings that can be parsed by Date.parse().\n\nRender\nHTML\nDate between\n\nDetermines if a date is between (and including) the two dates supplied as the rule's arguments. Dates used can either be JavaScript Date objects or strings that can be parsed by Date.parse().\n\nRender\nHTML\nDate format\n\nEnsures the format of an input’s date matches a specific date format. The format should be specified using the following formatting tokens:\n\nToken\tValid values\nMM\tTwo-digit month representation (01-12)\nM\tSingle-digit month representation (1-12) leading zero allowed\nDD\tTwo-digit day of the month (01-31)\nD\tSingle-digit day of the month (1-31), leading zero allowed\nYY\tTwo-digit year\nYYYY\tFour-digit year\nWARNING\n\nNative date inputs always output the same format YYYY-MM-DD ... even though they display dates according to the browser’s locale. Using this rule to specify a different format would result in an input that can never be valid.\n\nRender\nHTML\nEmail\n\nChecks if the input contains a valid email address.\n\nRender\nHTML\nEnds with\n\nChecks if the input's value ends with a given substring.\n\nRender\nHTML\nIs\n\nChecks that the input's value matches at least one of the provided arguments.\n\nRender\nHTML\nLength\n\nChecks that the input’s value is over a given length, or between two length values. It works to validate arrays (like lists), objects (like groups), or string lengths. Can be used to simulate the native maxlength and minlength as well.\n\nRender\nHTML\nLowercase\n\nChecks if a value consists of only lowercase characters. There are two character sets: latin and default. Latin characters are strictly [a-zA-Z], while the default set includes most accented characters, such as ä, ù, or ś.\n\nRender\nHTML\nMatches\n\nChecks if the input matches a particular value or pattern. If you pass multiple arguments, it checks each until a match is found.\n\nRender\nHTML\n\nInstead of passing in strings within the validation prop for simple matching, you can template your argument with slashes / to pass in your own regular expression.\n\nRender\nHTML\n\nWhen using the string String Syntax you cannot escape characters used to define the validation rules themselves (|,:). To use these characters in your regular expressions you must use the alternative Array Syntax.\n\nRender\nHTML\nMax\n\nChecks that a Number is less than or equal to a maximum value. The maximum value defaults to 10.\n\nRender\nHTML\n\nYou can also use this rule to validate that the length of an Array is less than or equal to a maximum value.\n\nRender\nHTML\nMin\n\nChecks that a Number is greater than or equal to a minimum value. The minimum value defaults to 1.\n\nRender\nHTML\n\nYou can also use this rule to validate that the length of an Array is more than or equal to a minimum value.\n\nRender\nHTML\nNot\n\nChecks to ensure the input data does not match a set of predefined values.\n\nRender\nHTML\nNumber\n\nChecks if the input is a valid number as evaluated by isNaN().\n\nRender\nHTML\nRequired\n\nChecks if the input is empty.\n\nRender\nHTML\n\nIf you don't want whitespace to cause the required rule to pass, you can pass trim as an argument to the rule:\n\nRender\nHTML\nRequire One\n\nChecks multiple inputs and passes if any of them have a value.\n\nRender\nHTML\nStarts With\n\nChecks if the input starts with one of the provided options.\n\nRender\nHTML\nSymbol\n\nChecks if a value consists of only symbols.\n\nRender\nHTML\nUppercase\n\nChecks if a value consists of only uppercase characters. There are two character sets: latin and default. Latin characters are strictly [a-zA-Z], while the default set includes most accented characters, such as ä, ù, or ś.\n\nRender\nHTML\nURL\n\nChecks if the input value appears to be a properly formatted URL including the protocol. This does not check if the URL actually resolves.\n\nRender\nHTML\nCustom rules\n\nValidation rules are functions that accept a core node and return a boolean value — true for passing and false for failing. Additionally, any arguments passed to the validation rule are available as arguments 1-n. Writing your own is straight forward — for example:\n\n/**\n\n * File: my-custom-rules/monday.js\n\n *\n\n * A contrived validation rule that ensures the input’s value is monday or mon.\n\n */\n\nconst monday = function (node) {\n\n  return node.value === 'monday' || node.value === 'mon'\n\n}\n\n\n\nexport default monday\nDefining custom rule behaviors\n\nAs mentioned in the validation rule hints section, validation rules — including your custom rules — operate according to default behaviors: they run in sequence, are skipped when the input's value is empty, are synchronous, and are blocking. If you want your rule's defaults to operate differently, you can override these on your custom validation rule:\n\n/**\n\n * A contrived validation rule that ensures the input’s value is monday or mon.\n\n */\n\nconst monday = function (node) {\n\n  return node.value === 'monday' || node.value === 'mon'\n\n}\n\n\n\n// override default rule behaviors for your custom rule\n\nmonday.blocking = false\n\nmonday.skipEmpty = false\n\nmonday.debounce = 20 // milliseconds\n\nmonday.force = true\n\n\n\nexport default monday\n\nYou can also override these behaviors on a case-by-case basis with rule hints.\n\nOnce you have a validation function written — you need to register the validation rule with FormKit — either globally or specifically on an input.\n\nMulti-input validation rules\n\nValidation rules can depend on values from other inputs in your form’s tree. To do so, use node traversal to locate another node and access its value:\n\nRender\nHTML\nPURE FUNCTIONS\n\nValidation rules should always be pure functions. Use only the arguments passed in and do not perform any side effects.\n\nAdding a rule globally\n\nTo use a validation rule anywhere in your project, you can specify it wherever your FormKit plugin is registered with Vue.\n\nimport { createApp } from 'vue'\n\nimport App from './App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\nimport monday from './my-custom-rules/monday'\n\n\n\n// prettier-ignore\n\ncreateApp(App).use(plugin, defaultConfig({\n\n  rules: { monday },\n\n})).mount('#app')\n\nOnce installed you can use your validation rule in anywhere in your project.\n\n<FormKit validation=\"required|monday\" />\n\nTo customize the error message which shows up when your custom validation fails, follow the instructions here.\n\nAdding a rule via prop\n\nTo add a validation to a specific input use the validation-rules prop.\n\nRender\nHTML\nCUSTOM MESSAGE\n\nYour custom rules probably need a custom message — the next section of the docs will cover that.\n\nCustom messages\n\nThere are several ways to customize your validation message. The most basic of which is to use the validation-label prop — allowing you to change the name of the field as used in the pre-defined validation messages.\n\nRender\nHTML\n\nIf you need to be more specific you have two options:\n\nOverride a rule’s message using a prop.\nOverride a validation rule’s message globally.\nValidation message prop\n\nYou can easily override validation messages directly on your FormKit input by providing an object of strings or functions.\n\nUsing strings\n\nTo override a validation message on a single FormKit input, add the validation-messages prop with an object of rule names and a corresponding message.\n\nRender\nHTML\nUsing functions\n\nIf you need more power for your validation rules, you can use a function instead of a string. The function is passed a context object.\n\nValidation message context object:\nBehavior\tDescription\nargs\tAn array of arguments passed to the rule. For example 'Vue', 'React', 'Angular' from the rule is:Vue,React,Angular.\nname\tThe name of the field (first available from: validation-label, label, then name).\nnode\tThe FormKit core node.\n\nLet’s re-write the above example using a function instead of a string for even more control of the validation-messages prop:\n\nRender\nHTML\nGlobal validation message\n\nIf there are validation rule messages you'd like to override (or add) across your entire project, you can define those message rules when registering FormKit under the language key you'd like to override:\n\nimport { createApp } from 'vue'\n\nimport App from './App.vue'\n\nimport { plugin, defaultConfig } from '@formkit/vue'\n\nimport monday from './my-custom-rules/monday'\n\n\n\n// prettier-ignore\n\ncreateApp(App).use(plugin, defaultConfig({\n\n  messages: {\n\n    en: {\n\n      validation: {\n\n        required({ name }) {\n\n          return `Please fill out the ${name} field.`\n\n        }\n\n      }\n\n    }\n\n  }\n\n})).mount('#app')\nMoving validation messages\n\nIf you would like to render an input’s validation messages outside of the <FormKit /> component, you can leverage the <FormKitMessages /> component by passing the input’s node as a prop. Using this component disables the default display of messages (located beneath the input) and moves them to wherever the <FormKitMessages /> component is located:\n\nRender\nHTML\nExtracting messages\nTHE <FORMKITSUMMARY> COMPONENT\n\nFormKit 1.0.0 introduced the FormKitSummary component which provides an \"out of the box\" solution to for displaying all the validation messages in a given form or subtree.\n\nTo get all the validation messages from an input’s core node, you can use the getValidationMessages function exported from @formkit/validation. This function will recursively check the given node and all children for validation messages and return a Map of core nodes to validation messages, making it ideal for use with forms:\n\nRender\nHTML"
  },
  {
    "title": "Form ⚡️ FormKit",
    "url": "https://formkit.com/inputs/form",
    "html": "Form\nProvided submit button\nFull example form\nPopulating\nSubmitting\nSubmitting via XHR/Fetch request\nSubmitting as a page request\nSubmitting forms programmatically\nValidation\nValidation incomplete message\nSubmit invalid event\nValidity state\nDisabling\nResetting\nInitial values\nError handling\nForm errors\nClearing errors\nInput errors\nValidation and error summary\nMoving validation and error messages\nMove messages automatically\nMove messages by node\nFormKitMessages props\nUnmounting inputs\nProps\nSections\n\nWhile you’re free to use FormKit inputs by themselves, you’ll usually want to group them into a form. To do this, simply wrap your inputs in a <FormKit type=\"form\">.\n\nThe form type will actively collect all the values from child inputs, using the name of each input as the property name in the resulting data object (just like groups). You can also read and write to form values using v-model just as you would on any input.\n\nA <FormKit type=\"form\"> tracks the form's validation state and prevents users from submitting the form if any inputs are invalid.\n\nProvided submit button\n\nAs a convenience, the form outputs a submit button automatically, and provided themes also include a loading spinner. You can alter this button with the submit-label and submit-attrs props, or disable with :actions=\"false\". You can pass any FormKit props to submit-attrs. In the example below, we pass classes, data attributes, help text, and even tell the included submit button to be un-ignored:\n\n<FormKit\n\n  type=\"form\"\n\n  submit-label=\"Update\"\n\n  :submit-attrs=\"{\n\n    inputClass: 'my-input-class',\n\n    wrapperClass: 'my-wrapper-class',\n\n    'data-theme': `dark`,\n\n    help: 'My button help text',\n\n    ignore: false\n\n  }\"\n\n></FormKit>\nFull example form\n\nExcluding backend functionality, here is a fully featured form with inputs (form, text, email, password), help text, labels, validation with custom messages, and error and submission handling:\n\n1\n2\n3\n4\n5\n6\n7\n8\n<script setup>\nimport { ref } from 'vue'\nconst submitted = ref(false)\nconst submitHandler = async () => {\n  // Let's pretend this is an ajax request:\n  await new Promise((r) => setTimeout(r, 1000))\n  submitted.value = true\n}\nRender\nHTML\nLoading Example...\nPopulating\nForm Population and Submission - Vue School Course\n\n8 mins\n\nYou can populate an entire form by providing a value prop to the <FormKit type=\"form\">. The value prop should be an object of input name to input value pairs. You may also use v-model to populate a form if you require two-way data binding:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit\n  type=\"form\"\n  :value=\"{\n    location: 'New York City',\n    duration: '2 weeks',\n    price: 'average'\n  }\"\n  submit-label=\"Save\"\n  @submit=\"save\"\n>\nRender\nHTML\nV-MODEL AND REACTIVE OBJECTS\n\nBe sure to either v-model a ref or a property of a reactive object. Do not v-model the reactive object itself as it leads to unexpected behavior.\n\nSubmitting\n\nForms are usually submitted through user actions like clicking a submit button or hitting the enter key on a text node within the form. Upon submission, the form (in sequence):\n\nEnsures all inputs are settled (finished debouncing).\nEmits the @submit-raw event.\nSets the submitted state to true on all inputs — displaying any remaining validation errors (regardless of the validation-visibility).\nIf the form has validation errors the @submit-invalid event is fired.\nIf all inputs are valid it fires the @submit event.\nIf the @submit handler returns a Promise, sets the form’s state to loading until it resolves.\nAVOID V-MODEL FOR COLLECTING AND SUBMITTING FORM DATA\n\nUsing v-model data in your submit handler can lead to unintended form mutations. FormKit automatically collects form data for you, so use the unbound copy of your form’s data that is passed to your submission handler instead.\n\nSubmitting via XHR/Fetch request\n\nThe most common method of form submission in a modern SPA is an XHR request (think axios or fetch). FormKit is well suited to this task:\n\nIt hands your @submit handler 1) the collected form data as a single request-ready object (no v-model needed), and 2) the form input's core node, as a convenience.\nIf you use an async submit handler, it will disable your form’s inputs and apply a loading state to your form (loading becomes true at context.state.loading and a spinner is displayed on the genesis theme).\nIt handles backend errors by placing error messages directly on the failing inputs.\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\n// This is just a mock of an actual axios instance.\nconst axios = {\n  post: () => new Promise(r => setTimeout(r, 2000))\n}\nasync function login (credentials) {\n  const res = await axios.post(credentials)\n  // do some login things now\n  alert('Logged in!')\nRender\nHTML\nSubmitting as a page request\n\nTo submit a form via page request, simply leave off the @submit handler. Just like native HTML, you can also provide an action and optionally a method attribute.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<template>\n  <FormKit\n    type=\"form\"\n    submit-label=\"Login\"\n    action=\"https://enpae7aofyxlml7.m.pipedream.net\"\n    method=\"post\"\n  >\n    <FormKit\n      name=\"email\"\n      label=\"Email address\"\nRender\nHTML\nSubmitting forms programmatically\n\nWhile submitting a form using any standard HTML method is valid (like clicking a submit button, or hitting enter on a text input) — you may also submit a form programmatically. There are 2 ways to do this:\n\nUsing this.$formkit.submit('form-id') (submitForm('form-id') for the composition api).\nUsing a core node object.\nSubmitting with $formkit.submit()\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\nexport default {\n  methods: {\n    submitForm() {\n      this.$formkit.submit('newsletter')\n    },\n    submitToMailchimp(data) {\n      alert(`Submitted ${data.email} successfully!`)\n    },\n  },\nRender\nHTML\nSubmitting with node.submit()\n\nYou can also submit a form programmatically by calling node.submit() on the form’s (or any input inside the form) core node. To do this you need to retrieve an instance of the core node.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { ref } from 'vue'\nconst myForm = ref(null)\nfunction submitForm() {\n  // retrieve the core node (several ways to do this):\n  const node = myForm.value.node\n  // submit the form!\n  node.submit()\n}\nRender\nHTML\nValidation\n\nForms will not submit until all the inputs in the form are passing their validation rules.\n\nValidation incomplete message\n\nIn addition to not firing the submit event, a message is displayed above the submit button indicating the form is still incomplete. You can customize this message using the incomplete-message prop or disable it by setting the prop to false.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nconst nextMonday = new Date()\nnextMonday.setDate(\n  nextMonday.getDate() + ((((7 - nextMonday.getDay()) % 7) + 1) % 7)\n)\n</script>\n<template>\n  <FormKit\n    type=\"form\"\nRender\nHTML\nGLOBAL CUSTOMIZATION\n\nIf you want to change the incomplete message across all forms on your project, you can modify the i18n locale message for ui.incomplete.\n\nSubmit invalid event\n\nWhen a user attempts to submit a form containing inputs that have failing validations, the @submit-invalid event is fired.\n\nFor example, we could use this event to alert our users of the failing validation rules.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { getValidationMessages } from '@formkit/validation'\nimport { ref } from 'vue'\nconst messages = ref([])\nfunction showErrors(node) {\n  const validations = getValidationMessages(node)\n  messages.value = []\n  validations.forEach((inputMessages) => {\nRender\nHTML\nValidity state\n\nThe validity of all inputs within a form is tracked automatically in the context object. This can be useful when creating various interfaces. For example, if you wanted a submit button to be disabled until all inputs are valid, you could use the state.valid property to do so.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nconst handleSubmit = () => alert('Password reset!')\n</script>\n<template>\n  <FormKit\n    type=\"form\"\n    :actions=\"false\"\n    @submit=\"handleSubmit\"\n    #default=\"{ state: { valid } }\"\nRender\nHTML\nGETTING THE CONTEXT OBJECT\n\nIn the above example we extract the context object from the #default slot, but there are other ways as well. The context object is available on each input’s core node on the node.context property, and you can fetch an input’s node a number of ways.\n\nDisabling\n\nTo disable all the inputs in a given form, including the submit button, you can use the disabled prop.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<template>\n  <!-- try removing the \"disabled\" attribute below -->\n  <FormKit type=\"form\" disabled>\n    <FormKit\n      label=\"Username\"\n      value=\"@vue-lover\"\n    />\n    <FormKit\n      label=\"Password\"\n      type=\"password\"\nRender\nHTML\nDISABLED AUTOMATICALLY\n\nWhen using an async @submit handler FormKit will automatically disable the form (and set the state to loading) while the submit handler is pending.\n\nResetting\n\nYou can reset your form (or any input) back to it’s initial state by calling $formkit.reset(formId).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\nexport default {\n  data() {\n    return {\n      complete: false,\n    }\n  },\n  methods: {\n    async handleSubmit() {\n      // Our api request:\nRender\nHTML\nCOMPOSITION API\n\nWhen using the composition api you can directly access the reset function by importing it from core: import { reset } from '@formkit/core'.\n\nInitial values\n\nIt’s important to note that the \"initial state\" of a form is not necessarily an empty form. You can have a default :value or v-model on the form and on individual inputs in the form — FormKit automatically merges these together to produce your initial value, and will restore to this merged state on reset.\n\nOptionally you can provide a second argument to reset(formId, initialState) if you would prefer an alternative reset state.\n\nError handling\n\nWith FormKit, adding front end validation to your form is easy — but what about errors produced by your backend framework, or ones you want to manually assign? There are two types of errors you can assign to a form:\n\nForm errors. These are displayed at the bottom of the form above the submit button. An example would be a global message like \"Sorry, our server isn’t working right now”.\nInput errors. Errors to be placed on specific inputs within your form, typically these are validation errors from your backend, like \"Sorry this username is already taken\".\nForm errors\n\nForm errors (ones that apply to the entire form) can be set three ways.\n\nUsing the errors prop on a <FormKit type=\"form\">.\nUsing a core node node.setErrors().\nUsing the $formkit.setErrors() Vue plugin method.\nUsing the errors prop\n\nLike with any FormKit input, you can directly assign errors using the errors prop. These errors are always visible (not subject to validation-visibility).\n\n1\n2\n3\n4\n5\n6\n7\n8\n<FormKit\n  type=\"form\"\n  submit-label=\"Login\"\n  :errors=\"['Our server is not working.', 'But we don’t like you anyway!']\"\n>\n  <FormKit type=\"email\" label=\"Email address\" />\n  <FormKit type=\"password\" label=\"Password\" />\n</FormKit>\nRender\nHTML\nUsing node.setErrors()\n\nSetting your form’s errors using node.setErrors is convenient since your submit handler is passed the form’s node object as its second argument. node.setErrors() takes 2 arguments — an array for form errors, and a keyed object for input errors:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nfunction submitHandler(data, node) {\n  if (data.username !== 'formkit4life') {\n    node.setErrors(\n      // Arg 1 is form-wide errors\n      ['There was an error in this form'],\n      // Arg 2 is field-specific errors\n      {\n        username: 'Sorry, that username is not available.',\n      }\nRender\nHTML\nUsing $formkit.setErrors()\n\nAlternatively, you can set errors directly on a form by giving the form an id and then calling $formkit.setErrors('id', ['Form error here']). The setErrors method must be passed the id of the form, and then can handle 1 or 2 additional arguments — the form errors, and the input errors:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script>\nexport default {\n  methods: {\n    async order(data) {\n      try {\n        await fakeApiCall(data)\n      } catch (inputErrors) {\n        this.$formkit.setErrors(\n          'order-form', // You must use the ID of the form\n          ['There was an error with your order!'], // (optional) An array of form level errors\nRender\nHTML\nClearing errors\n\nBy default errors that were set on inputs using setErrors() are automatically cleared when a user changes the value of that input. You can change this default behavior by setting the preserve-errors prop.\n\nTo clear all the errors on the form (regardless of the preserve-errors prop) call node.clearErrors().\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { onMounted } from 'vue'\nimport { setErrors } from '@formkit/core'\nonMounted(() => {\n  setErrors('my-form', ['This form has some errors'], {\n    first_input: 'This error will clear when you type.',\n    second_input: 'This error will remain even after typing.',\n  })\n})\nRender\nHTML\n\nIf you prefer to preserve errors by default, you can change the default behavior by modifying the preserveErrors config option. This can be done globally or for a single form:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit\n  type=\"form\"\n  id=\"register\"\n  :config=\"{ preserveErrors: true }\"\n>\n  <FormKit\n    name=\"username\"\n    label=\"Username\"\n    help=\"Select a new username\"\n  />\nRender\nHTML\nCOMPOSITION API\n\nWhen using Vue 3’s composition API, you can access setErrors and clearErrors by importing them directly from @formkit/vue.\n\nimport { setErrors, clearErrors } from '@formkit/vue'\n\nInput errors\n\nInput errors (ones to be displayed with specific inputs in a form) can be applied three ways:\n\nManually using the errors prop on each individual input.\nUsing the input-errors prop on the form (also works with groups and lists).\nUsing the $formkit.setErrors() Vue plugin method (see example above).\nManually using errors prop\n\nThe most basic way to display errors on a form is using the errors prop that is available on each FormKit input.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<template>\n  <FormKit type=\"form\">\n    <FormKit\n      type=\"checkbox\"\n      label=\"Shirt style\"\n      disabled\n      :options=\"['Hawaiian', 'V-Neck', 'Blouse', 'Chambrey']\"\n      :errors=\"['Sorry, we are out of shirts.']\"\n    />\n  </FormKit>\nRender\nHTML\nUsing input-errors prop\n\nYou can also conveniently set error messages for all inputs in your form (or group or list) using the input-errors prop. The prop accepts an object of errors, where the keys are input names (relative node addresses are supported) and the value is an error or array of errors to apply to that input.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<template>\n  <FormKit\n    type=\"form\"\n    submit-label=\"Send\"\n    :input-errors=\"{\n      to: 'Make sure you use the right address.',\n      value: 'Are you sure you have this much?',\n      gasLimit: 'Just put a giant number in here.',\n    }\"\n  >\nRender\nHTML\nValidation and error summary\n\nIt can be helpful for accessibility to provide a summary of validation and error messages at the top of your form. FormKit provides a <FormKitSummary /> component to render this summary for you.\n\nThis component will automatically render all of a form’s validation and error messages with jump links to the inputs they apply to. These errors are only shown after submitting the form but they are wrapped in an aria-live region to ensure screen readers will be notified when the errors present themselves. Additionally the page will automatically be scrolled to the summary box and focused on the first error listed.\n\n<FormKitSummary /> is not a globally registered component — you must import it:\n\nimport { FormKitSummary } from '@formkit/vue'\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup lang=\"ts\">\nimport { FormKitSummary } from '@formkit/vue'\nfunction submitApplication() {\n  alert('Application submitted!')\n}\n</script>\n<template>\n  <h1>Apply to FormKit University</h1>\nRender\nHTML\nMOVING THE SUMMARY\n\nThe summary component should generally be nested in the form it is summarizing. If you would like to move the summary to a different location on the page, you can do so by providing the form’s core node as the node prop.\n\nMoving validation and error messages\n\nBy default, a form’s validation and error messages are placed directly above the form’s actions section. However, you can choose to render these anywhere on your page by using the <FormKitMessages /> component. <FormKitMessages /> is not a globally registered component — you must import it:\n\nimport { FormKitMessages } from '@formkit/vue'\n\nThere are two ways to use <FormKitMessages />:\n\nAutomatically\nManually by node\nMove messages automatically\n\nPlace a <FormKitMessages /> component anywhere inside your form, and the form’s messages will automatically be moved to that location:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { FormKitMessages } from '@formkit/vue'\nasync function submitHandler(_data, node) {\n  await new Promise((resolve) => setTimeout(resolve, 1000))\n  node.setErrors([\n    'The server doesn’t like your name 😃. Sorry.'\n  ])\n}\n</script>\nRender\nHTML\nMove messages by node\n\nTo move messages anywhere in the DOM — even outside the form — you can pass the form’s core node as a prop to <FormKitMessages />. In this example, we use the messages to create a toast-style popup:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<script setup>\nimport { ref } from 'vue'\nimport { FormKitMessages } from '@formkit/vue'\nconst form = ref(null)\nasync function submitHandler(_data, node) {\n  await new Promise((resolve) => setTimeout(resolve, 1000))\n  node.setErrors([\n    'Gambling is illegal.',\nRender\nHTML\nFormKitMessages props\n\nThe <FormKitMessages /> component has a few additional configuration options:\n\nProp\tDefault\tDescription\nnode\tinherited\tThe core node to render messages for. By default this is inherited from the node’s parent (if it exists).\nsectionsSchema\t{}\tOverride the internal messages and message sections (same default structure as other input’s messages section).\ndefaultPosition\tfalse\tBy default, FormKitMessages moves the rendered messages to a new location. If you would like to render the messages in both locations, set this prop to true.\nUnmounting inputs\n\nWhen inputs are unmounted from a form — for example when using v-if — the key and value is removed from the form’s data. However, in some circumstances it may be preferable to keep the key/value pair even after the input has been removed. This can be accomplished by using the preserve prop:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n<FormKit type=\"form\" #default=\"{ value }\" :actions=\"false\">\n  <FormKit\n    type=\"checkbox\"\n    :value=\"true\"\n    name=\"beverage\"\n    label=\"Include a beverage?\"\n    help=\"Select a beverage, then uncheck me to see if data is preserved.\"\n  />\n  <!-- Try adding/removing preserve -->\n  <FormKit\nRender\nHTML\nProps\n\nForms are technically considered input types — so they share many of the universal props that standard inputs use.\n\nProp\tType\tDefault\tDescription\ndisabled\tBoolean\tfalse\tDisables the form submit button and all the inputs in the form.\nincomplete-message\tString/Boolean\t{locale}.ui.incomplete\tThe message that is shown to near the submit button when a user attempts to submit a form, but not all inputs are valid.\nsubmit-attrs\tObject\t{}\tAttributes or props that should be passed to the built-in submit button.\nsubmit-behavior\tString\tdisabled\tAsync submit handlers automatically disable the form while pending, you can change this by setting this prop to 'live'.\nsubmit-label\tString\tSubmit\tThe label to use on the built-in submit button.\nactions\tBoolean\ttrue\tWhether or not to include the actions bar at the bottom of the form (ex. you want to remove the submit button and use your own, set this to false).\nShow Universal props\nSections\nSection-key\tDescription\nform\tResponsible for rendering the form tag and listening to submit events.\nactions\tResponsible for a container at the bottom of the form with form actions like the submit button.\nsubmit\tResponsible for a submit button — by default a FormKit input type submit.\nShow Universal section keys"
  },
  {
    "title": "Styling ⚡️ FormKit",
    "url": "https://formkit.com/essentials/styling",
    "html": "Styling\nInstalling Genesis theme\nOuter attributes\nCustom classes\nAppending classes\nResetting classes\nRemoving classes\nSection-key class props\nClasses prop\nClasses configuration\nGlobal class configuration\nClass configuration on a group, list, or form\nUsing generateClasses from @formkit/themes\nThe rootClasses function\nModifying classes within schema\nSection-key class props within schema\nClasses prop within schema\nConfig within schema\nTailwind CSS\nBuilding your own Tailwind CSS theme\n\nFormKit ships robust and accessible markup — but with no assumptions about your desired styles. There is an optional base theme (as seen in these docs) called Genesis that you can use in your projects.\n\nInstalling Genesis theme\nCDN Usage\n\nTo load genesis via CDN, supply it to the theme property of your defaultConfig.\n\n...\n\ndefaultConfig({\n\n  theme: 'genesis' // will load from CDN and inject into document head\n\n})\n\n...\nDirect import\n\nTo install Genesis, first install the @formkit/themes package.\n\nnpm install @formkit/themes\n\nThen in your main.js (wherever you boot Vue up) include the Genesis theme.css (this assumes you are using a build tool like Vite, Webpack, Snowpack, or Nuxt):\n\nimport '@formkit/themes/genesis'\nOuter attributes\n\nFor styling purposes some attributes are automatically added to and removed from the outer section of all FormKit inputs:\n\ndata-type — The type of input, text, select, checkbox etc.\ndata-multiple — For inputs that accept the multiple attribute, this will be appended when the input has the multiple attribute (like the select input).\ndata-disabled — Present when an input is disabled.\ndata-complete — Present when the input is \"complete\". Intended to be used for styling the input when a user has completed filling out the input (like a green checkmark). Read about context.state.complete for information what conditions cause this to be true.\ndata-invalid — Present when the input has failing validation rules and the messages for the failing rules are visible.\ndata-errors — Present when the input has explicitly set errors.\n\nYou can use the above attributes to easily provide realtime visual feedback for users filling out your forms:\n\nRender\nHTML\nCustom classes\n\nMost users will want to apply their own styles and classes to FormKit's provided markup. FormKit provides numerous methods to apply classes for your project.\n\nClasses can be modified for all sections using any of the following methods (from highest to lowest specificity):\n\nThe {section-key}-class props. (most specific)\nThe classes prop.\nThe classes configuration option.\nThe rootClasses configuration function. (least specific)\n\nThe classes follow a strict hierarchy. Initially, classes are produced by the rootClasses function. They can then be modified by the classes configuration option, then by the classes prop, and finally by the {section-key}-class prop. At each of these stages classes can be appended, reset, or selectively modified.\n\nAppending classes\n\nTo append a class, simply return the string you want to append, or provide an object of classes with boolean values — true properties will be appended:\n\nHTML\nResetting classes\n\nClasses produced by all earlier hierarchy steps can be completely removed by providing a special (not rendered) class $reset in either string format or object format:\n\nHTML\nRemoving classes\n\nClasses produced by an earlier step in the class hierarchy can be selectively removed by providing an object with the value false for the class you want to remove or by providing a class name to a {section-key}-class prop that starts with $remove: and matches an existing class in the class list. This includes removing formkit's default formkit- prefixed classes:\n\nHTML\nTIP\n\nIn addition to the four methods listed above, more generalized overrides are also available, like overriding an input’s schema, using the classes node hook, or utilizing slots:\n\nSection-key class props\n\nThe simplest way to modify the classes of an element inside a FormKit input is via the {section-key}-class props. To add a class to a specific section element, like label, you simply add the label-class prop:\n\nHTML\nClasses prop\n\nThe classes prop is similar to the section-key class prop except it allows setting classes on all sections at the same time:\n\nHTML\nClasses configuration\n\nThe classes configuration option is similar to the classes prop, except it applies to all inputs the configuration is applied to. FormKit's unique configuration system allows for you to apply classes globally on your project or just inputs within a certain group or form:\n\nGlobal class configuration\nClass configuration on a group, list, or form\nRender\nHTML\nUsing generateClasses from @formkit/themes\n\nFormKit ships with a helper function called generateClasses included in @formkit/themes.\n\nThe generateClasses function takes a javascript object keyed by input type with values of a sub-object keyed by ${sectionKey} with values of strings. With this function you can quickly apply class lists to sections within inputs based on a given inputs' type.\n\nHTML\nThe rootClasses function\n\nrootClasses is a configuration function that is responsible for producing the default classes for each element. This function already has a default value which produces all the default classes (like formkit-outer and formkit-label) that ship with FormKit — so replacing this single function allows you to easily replace all initial classes. This makes it an ideal candidate for writing custom themes when using utility frameworks like Tailwind.\n\nThe rootClasses function is passed 2 arguments (respectively):\n\nThe section key (like label or input).\nThe input’s node.\n\nThe function will be called once for each section and it must return an object of classes with boolean values.\n\nWhile typical usage of rootClasses is at the global config level to apply classes to your entire project - you can also use it with the config prop to override a specific form or input within your project with a class list computed from the logic within your provided function:\n\nHTML\nTIP\n\nBecause rootClasses is a configuration option, you can apply it per input, per group, or globally.\n\nModifying classes within schema\n\nIn addition to modifying classes via config or props on a <FormKit> component, you can use the same techniques within schema:\n\nSection-key class props within schema\n\nWithin schema, you can also modify the classes of an element inside an input via the {section-key}Class properties. For example, to add a class to the label section, you can add the labelClass property:\n\n{\n\n  $formkit: 'text',\n\n  name: 'email',\n\n  // adds 'appended-class' to the \"label\" section\n\n  labelClass: 'appended-class'\n\n},\nClasses prop within schema\n\nMuch like the classes prop on a <FormKit> component, you can modify the class list for any section of an input with the classes property on a schema node:\n\n{\n\n  $formkit: 'text',\n\n  name: 'email',\n\n  // modifies classes on both the \"outer\" and \"inner\" sections of this input\n\n  classes: {\n\n    outer: 'new-outer-class',\n\n    inner: {\n\n      $reset: true, // resets classes on the \"inner\" section\n\n      'new-inner-class': true\n\n    }\n\n  },\n\n},\nConfig within schema\n\nSince config is passed down to descendant inputs, you can alter classes via config on a parent, such as a form, list, or a group, and this will affect all descendants to any depth:\n\nRender\nHTML\nTailwind CSS\n\nIf you have not already, add Tailwind CSS to your project following their installation instructions\n\nFormKit provides a Tailwind version of the Genesis theme you can use as a starting point in your own project. To use this pre-made Tailwind theme copy the following theme into a file (something like tailwind-theme.js) in your project.\n\nNow, import your Tailwind theme into your formkit.config file and add it to your project's configuration.\n\nYou will need to import the generateClasses helper function from the @formkit/themes package as well as the supporting icons from the @formkit/icons package.\n\nnpm install @formkit/themes @formkit/icons\n// formkit.config.js\n\nimport { generateClasses } from '@formkit/themes'\n\nimport { genesisIcons } from '@formkit/icons'\n\nimport myTailwindTheme from './tailwind-theme.js' // change to your theme's path\n\n\n\nexport default {\n\n  icons: {\n\n    ...genesisIcons,\n\n  },\n\n  config: {\n\n    classes: generateClasses(myTailwindTheme),\n\n  },\n\n}\n\nNext, add the path to your theme to your tailwind.config file's content array — this is required so that Tailwind knows which classes you're using in your project.\n\nAdditionally you should add the FormKitVariants plugin to your tailwind.config.js from the @formkit/themes package in order to make use of the FormKit-provided variants such as formkit-invalid: in your project.\n\n// tailwind.config.js\n\nconst FormKitVariants = require('@formkit/themes/tailwindcss')\n\n\n\nmodule.exports = {\n\n  content: [\n\n    ...\n\n    './tailwind-theme.js',\n\n  ],\n\n  plugins: [FormKitVariants],\n\n}\nBuilding your own Tailwind CSS theme\n\nWant to create your own Tailwind theme? We've written a guide walking through the process using both inline class props as well as using the FormKitVariants plugin and the generateClasses helper function from @formkit/themes to create a global Tailwind theme.\n\nThe guide concludes with a complete reproduction of the FormKit Genesis CSS theme written in Tailwind.\n\nGuide: Create a Tailwind CSS theme\nRead now"
  },
  {
    "title": "Inputs ⚡️ FormKit",
    "url": "https://formkit.com/essentials/inputs",
    "html": "Inputs\nIntroduction\nThe Form Input\nSetting values\nUsing value prop\nUsing v-model\nUsing node.input()\nUsing a parent\nSetting attributes\nValidation\nDebouncing\nExplicit errors\nProps & attributes\nEvents\nSections\nRestructure markup\nSlots\nSections schema\nChanging HTML tags\nUnwrapping or removing HTML tags\nSchema logic\nLearn more about schema\nIntroduction\n\nFormKit Inputs are similar to HTML inputs but turbocharged with much needed features like labels, help text, validation, and error messages (and much more). Similar to how HTML’s <input> tag uses various type attributes (i.e., <input type=\"text\"> vs <input type=\"checkbox\">), FormKit uses the type prop for all inputs. In fact, with FormKit, there is only 1 component you have to learn:\n\nRender\nHTML\n\nFormKit Inputs are not confined to what is available in \"native\" HTML. Our seperate FormKit Pro package provides access to \"synthetic\" input types such as repeater, autocomplete, mask, rating and more. Of course, you can write your own inputs too by creating custom inputs.\n\nRender\nHTML\nThe Form Input\n\nWhile you’re free to use FormKit inputs by themselves, you’ll usually want to group them into a form:\n\n<FormKit type=\"form\">\n\n  <!-- ... your form inputs -->\n\n</FormKit>\n\nThe form type provides a host of features including value collection, initial value setting, form submission, error handling, loading states, and more.\n\nSetting values\n\nThere are 4 ways to set the value of an input:\n\nUsing the value prop (Note: only sets initial value).\nUsing v-model.\nUsing FormKit's node node.input() method.\nSetting the value of a parent FormKit component.\nUsing value prop\n\nYou can set the initial value of a single input or a group of inputs using the value prop.\n\nRender\nHTML\nWARNING\n\nThe value prop should only be used for setting the initial value of an input. It will not react to changes after the component has been created.\n\nUsing v-model\n\nUsing v-model allows for two-way reactive data binding with any FormKit input.\n\nRender\nHTML\nUsing node.input()\n\nAt the heart of every FormKit input is an instance of FormKit’s node object, and using the node.input() method is the most efficient mechanism to modify any input’s value (read more about getting an instance of the node object).\n\nRender\nHTML\nTIP\n\nCalls to node.input() are debounced, and thus asynchronous (use the delay prop to change the length of the debounce). You can await node.input(val) to determine when the input has settled.\n\nUsing a parent\n\nParent inputs like list, group, and form are also able to directly set the values of any of their children. In fact, the value of a parent is just the aggregate value of its children. You can use any of the above methods (value prop, v-model, or node.input()) to set the value of the children.\n\nRender\nHTML\nSetting attributes\n\nIn nearly all cases, attributes set on the <FormKit> component will be passed through to the actual <input> element at the heart of the component, rather than any wrapping DOM elements. For example:\n\nHTML\nValidation\n\nWe discuss validation in more detail on its own documentation page — but suffice to say adding validation rules to inputs in FormKit is as easy as adding the validation prop:\n\nRender\nHTML\nLearn more about validation rules\nRead the docs\nDebouncing\n\nFor performance, all FormKit inputs support debouncing as a first-class feature. While the value of an input changes on every keystroke (technically the input event), this newly updated value is only set internally — validation rules, groups, lists, forms, and (most) plugins are not yet “aware” a change has been made.\n\nInternally, FormKit debounces the input event. When the debounce has \"settled\", the new value is “committed” and the rest of the application is then notified via the input node’s commit event. The default debounce delay is 20 milliseconds and can be adjusted with the delay prop or config option.\n\nTo illustrate this, let's get the group's value from the #default slot prop and observe how it is not updated until after our 1000ms delay:\n\nRender\nHTML\nGROUP & LIST DELAY\n\nThe delay prop’s default is 20 milliseconds. However, group and list inputs use 0 milliseconds by default to prevent the debounce delay from “building up” at each level of depth.\n\nExplicit errors\n\nValidation errors are not the only way to set errors on an input. You can also explicitly set error messages on an input by using the errors prop.\n\nRender\nHTML\nNON BLOCKING\n\nExplicitly set errors are non-blocking, meaning they do not prevent the form from submitting the way validation errors do. You can read more about error handling on the form documentation.\n\nProps & attributes\n\nFormKit inputs accept both universal props (ones that apply to all FormKit inputs), and input-specific props. The following table is a comprehensive list of props available to all FormKit inputs.\n\nProp\tType\tDefault\tDescription\nconfig\tObject\t{}\tConfiguration options to provide to the input’s node and any descendent node of this input.\ndelay\tNumber\t20\tNumber of milliseconds to debounce an input’s value before the commit hook is dispatched.\ndirtyBehavior\tstring\ttouched\tDetermines how the \"dirty\" flag of this input is set. Can be set to touched or compare — touched (the default) is more performant, but will not detect when the form is once again matching its initial state.\nerrors\tArray\t[]\tArray of strings to show as error messages on this field.\nhelp\tString\t''\tText for help text associated with the input.\nid\tString\tinput_{n}\tThe unique id of the input. Providing an id also allows the input’s node to be globally accessed.\nignore\tBoolean\tfalse\tPrevents an input from being included in any parent (group, list, form etc). Useful when using inputs for UI instead of actual values.\nindex\tNumber\tundefined\tAllows an input to be inserted at the given index if the parent is a list. If the input’s value is undefined, it inherits the value from that index position. If it has a value it inserts it into the lists’s values at the given index.\nlabel\tString\t''\tText for the label element associated with the input.\nname\tString\tinput_{n}\tThe name of the input as identified in the data object. This should be unique within a group of fields.\nparent\tFormKitNode\tcontextual\tBy default the parent is a wrapping group, list or form — but this props allows explicit assignment of the parent node.\nprefix-icon\tString\t''\tSpecifies an icon to put in the prefixIcon section.\npreserve\tboolean\tfalse\tPreserves the value of the input on a parent group, list, or form when the input unmounts.\npreserve-errors\tboolean\tfalse\tBy default errors set on inputs using setErrors are automatically cleared on input, setting this prop to true maintains the error until it is explicitly cleared.\nsections-schema\tObject\t{}\tAn object of section keys and schema partial values, where each schema partial is applied to the respective section.\nsuffix-icon\tString\t''\tSpecifies an icon to put in the suffixIcon section.\ntype\tString\ttext\tThe type of input to render from the library.\nvalidation\tString, Array\t[]\tThe validation rules to be applied to the input.\nvalidation-visibility\tString\tblur\tDetermines when to show an input's failing validation rules. Valid values are blur, dirty, and live.\nvalidation-label\tString\t{label prop}\tDetermines what label to use in validation error messages, by default it uses the label prop if available, otherwise it uses the name prop.\nvalidation-rules\tObject\t{}\tAdditional custom validation rules to make available to the validation prop.\nvalue\tAny\tundefined\tSeeds the initial value of an input and/or its children. Not reactive. Can seed entire groups (forms) and lists..\nEvents\n\nFormKit inputs emit both universal events (ones that are emitted from all inputs), and input-specific events. The following table is a comprehensive list of events emitted by all FormKit inputs.\n\nEvent\tPayload\tDescription\ninput\tany\tEmitted when the core node’s commit hook is completed. Has it’s own debounce to reduce noise. Includes the core node as the second argument.\ninput-raw\tany\tEmitted on every core node’s commit hook. Includes the core node as the second argument.\nnode\tFormKitNode\tEmitted when the component’s setup is complete. This is the internal FormKitNode object at the heart of the input.\nVUE EVENTS\n\nThe above are Vue events emitted by @formkit/vue. @formkit/core also emits its own events as part of the lifecycle of core nodes.\n\nSections\n\nInputs are composed of chunks of HTML called \"sections\". Each section has a \"key\" that can be used to target the section for a variety of purposes, like:\n\nModifying the section's classes via {section-key}-class=\"your-class\" props\nOverriding the section's structure with slots: <template #{section-key}>\nExtending each sections’s schema\n\nMany section keys are universally available while others are specific to a given input type (you can define your own for custom inputs as well). The following table is a comprehensive list of those that are generally available in all inputs:\n\nSection-key\tDescription\nouter\tThe outermost wrapping element.\nwrapper\tA wrapper around the label and input.\nlabel\tThe label of the input.\nprefix\tHas no output by default, but allows content directly before an input element.\nprefixIcon\tAn element for outputting an icon before the prefix section.\ninner\tA wrapper around the actual input element.\nsuffix\tHas no output by default, but allows content directly after an input element.\nsuffixIcon\tAn element for outputting an icon after the suffix section.\ninput\tThe input element itself.\nhelp\tThe element containing help text.\nmessages\tA wrapper around all the messages.\nmessage\tThe element (or many elements) containing a message — most often validation and error messages.\nRestructure markup\n\nAt times you may find it necessary to restructure the HTML inside a FormKit input, such as adding, editing, moving, or removing sections. This can be done by exporting the input (using the CLI tool), making the desired changes, and then using the modified input in your project. Read the guide on exporting inputs to learn how.\n\nLearn to restructure your inputs\nExport inputs docs\nSlots\n\nInputs can have their structure overridden with slots. You can precisely target where your slot content goes with section keys. Slots are then are passed the context object for use in their template.\n\nFor example, if we wanted to use a slot to define the label of an input, we could use a label slot to do so:\n\nRender\nHTML\nCONSIDER SECTION SCHEMA\n\nA disadvantage of using slots is you often need to re-create unrelated features to make the change you desire. For example, using slots would require you to re-implement any classes applied to those sections (which can be done by using context.classes.sectionName).\n\nTo help address this shortcoming, FormKit is also able to selectively override/extend the underlying schema of each section allowing complex structural modification often with no loss of functionality.\n\nSections schema\n\nFormKit provides an additional mechanism to change the structure of a FormKit input called “sections schema”. Under the hood, all FormKit inputs are powered by FormKit’s schema — a JSON compatible data format for creating and storing DOM structure and logic. This allows tremendous structural flexibility because all inputs can have pieces of their schema extended via section keys without wholesale replacement of the template.\n\nChanging HTML tags\n\nFor example, by default FormKit uses an unordered list (<ul> and <li>) to output validation messages — but perhaps you need to use <div> tags. You can change these tags using the schema prop without having to re-create any functionality:\n\nRender\nHTML\nUnwrapping or removing HTML tags\n\nFor accessibility and flexibility, FormKit uses several wrapper elements like the ones in the wrapper and inner sections. However, perhaps on some inputs you need to remove a wrapper element to ensure other elements are adjacent. You can do this by providing a null value as the schema element:\n\nRender\nHTML\nSchema logic\n\nSection schemas can also change the content being output using advanced schema logic. You could, for example, output a special value when your input’s value matches a particular string:\n\nRender\nHTML\nLearn more about schema\nLearn more about how schemas work\nGimme more schema"
  },
  {
    "title": "Community & support ⚡️ FormKit",
    "url": "https://formkit.com/getting-started/community",
    "html": "Community\nInvolvement\nSponsor\nPlatinum sponsors\nGold sponsors\nSilver sponsors\nBronze sponsors\nBackers\nContribute\nContribute to open source code bases\nOpen issues on GitHub (bugs and features)\nSubmit a locale\nCreate content to share\nJoin the community\nFormKit Discord server (generalized help & discussion)\nStack Overflow\nJoin the FormKit channels\nInvolvement\n\nCommunity involvement and contributions are one of the most important aspects of the FormKit ecosystem. We invite you to actively participate — whether using FormKit, translating validation messages, being an active member of the Discord, or filing bug reports and making pull requests to the FormKit codebase.\n\nSponsor\n\nFormKit will always be free and open source. If you want to help accelerate its development and maintenance, please consider sponsoring the project! In addition to our gratitude and enabling us to spend more time improving FormKit, you'll also get various perks at different tiers of sponsorship!\n\nSponsor FormKit →\nPlatinum sponsors\nGold sponsors\nSilver sponsors\nBronze sponsors\n \nBackers\n\nuscreen, gfenn08, Ryan E, João Bondim\n\nContribute\n\nWe invite you to contribute to FormKit! There are many ways to help — from creating pull requests to our open source code bases, to filing issues so we can improve FormKit for everyone.\n\nContribute to open source code bases\n\nWe encourage contributions to the FormKit open source code bases! When contributing, consider first discussing your desired change with the core team via GitHub issues or Discord.\n\nContributors to formkit/formkit\nContributors to formkit/docs-content\n\nThank you to all contributors and community members who help us improve FormKit every day.\n\nOpen issues on GitHub (bugs and features)\n\nGitHub issues are for feature requests and bug reports. If you've found a bug, please create a GitHub issue by reproducing it in the playground and clicking the share button! Feature requests are always a bit subjective, but if you believe there's a good use case that is currently underserved by FormKit, we want to know.\n\nGitHub issues →\nSubmit a locale\n\nWe are always looking for native speakers to submit a translation of the FormKit validation messages and UI elements. This is a great way to get involved, even with minimal coding experience. The easiest way to provide a translation is by using the locale builder:\n\nCreate a locale →\nCreate content to share\n\nOne of the best ways to enrich the FormKit (and Vue 3) community at large is to create content such as articles, guides, YouTube videos, or other educational content to share with others! We will be happy to include links to high-quality content in our docs.\n\nJoin the community\nFormKit Discord server (generalized help & discussion)\n\nIf you need generalized help or want to make connections within the community, consider joining the official FormKit Discord. Over 1200 developers along with the core team members have active discussion there. If you are not already a member (it's free and open), you'll need to use the following invite link to join the server:\n\nJoin the FormKit Discord server →\nStack Overflow\n\nIf you have a specific question about how to use FormKit, please ask it on Stack Overflow tagged with formkit. Make sure to include code examples and if possible, a link to the playground so the community can further assist you.\n\nAsk a question on Stack Overflow →\nJoin the FormKit channels\nStar on GitHub ⭐️. This helps visibility.\nSubscribe to the email list.\nFollow on Twitter.\nJoin the Discord.\nSubscribe on YouTube."
  },
  {
    "title": "Your first form ⚡️ FormKit",
    "url": "https://formkit.com/getting-started/your-first-form",
    "html": "Your first form\nIntroduction\nOur first input\nBasic props\nSetting an initial value\nAdding validation\nAdding a plugin\nCreating the form\nAdding the submit handler\nChanging the submit button\nGrouping related inputs\nGoing deeper\nUpdating values based on another input\nMake it into a plugin\nAdding group validation\nConditional rendering\nNext steps\nIntroduction\n\nLet's start by creating our first FormKit form! We'll learn some of FormKit's key features and how they benefit you. We'll also pick up some nice tips along the way — like how to manage form state without using v-model.\n\nCOMPOSITION API\n\nThis guide assumes you are are familiar with the Vue Composition API.\n\nRobust Vue.js Forms - Vue School Course\n\n1 hr, 49 mins\n\nOur first input\n\nOne of the main features of FormKit is its single component API — the <FormKit /> component. This one component gives you access to all input types. And while some types may extend and add features, they share the same base functionality. You can learn more about inputs here.\n\nEven without any props, the bare <FormKit /> component has already given our input a great starting point, with accessible markup, a base text input type, and additional features that will be explained in later sections.\n\nBasic props\nThe type\n\nBy default, the <FormKit /> component will use type=\"text\" if no type is specified. The type is how we specify what input we want. Just like native inputs, we have inputs like text, select, checkbox and so on. However, we are not confined to only \"native\" inputs, FormKit Pro adds non-native controls like the repeater, taglist, and autocomplete types, which can handle more complex interactions.\n\nRender\nHTML\nThe name and id\n\nIf you look at the HTML generated by the previous example, you will see that FormKit already created accessible markup. However, as we did not specify the name and id properties, they were auto-generated for us: name: \"text_1\" id=\"input_0\". Even so, as a best practice, we should always at least specify the name as it makes using inputs inside a form easier. The name is used by the form and group types to collect values from, and pass values down to, their children based on the name:\n\nRender\nHTML\nProps for accessibility\n\nOur input is still missing some key accessibility functionality like a label, help, and maybe even a placeholder. FormKit accepts all these as props, and outputs the proper aria attributes. Screen readers will now announce the input name, the help text, and that the input is ready for editing:\n\nRender\nHTML\nSetting an initial value\n\nSometimes you want to add an initial value to an input, such as providing a sensible starting place, or populating pre-saved data from a database. We do this with the value prop.\n\nLet's start building an example that we can add to for this guide. Imagining we are building a \"character creation form\" for a game. Let's assign our character a strength rating. We could use the range input with a predefined value of 5 when the users first opens the form:\n\nRender\nHTML\nAdding validation\n\nValidation is one of the main features of FormKit. It helps the user know if the value they are submitting is correct. Adding validation is a breeze, with many powerful built-in validation rules already implemented for you. We will be using the validation prop to make sure the character is not too strong or too weak. The validation-visibility prop allows us to control when to show validation messages to the user — whether immediately, when the user blurs the input, or on form submit. The actual validity state is calculated real-time and always up to date — we simply choose when to expose the messages:\n\nRender\nHTML\n\nNote that the min and max props above are built-in browser props for a range input, and represent the top and bottom of the range slider .\n\nAdding a plugin\n\nSuppose our \"backend\" requires that data like strength be cast to a number. By default, FormKit follows HTML \"native\" inputs behavior, making all values as \"strings\". To fix that, we can use one of the coolest features of FormKit — plugins — which can be thought of as middleware for inputs. With a plugin, which are just functions, we can change how the value of our input is returned:\n\nRender\nHTML\nCreating the form\n\nFirst, let's create a basic form and add more inputs so we have content to work with. We will add more features to it in each section, like validation, grouping, and changing values based on other inputs.\n\nWe will use one of the inputs called form, which will make grouping and validation of fields much easier. You just need to wrap all your inputs inside a <FormKit type=\"form\">:\n\nFORM VALUES\n\nThe form type will actively collect all the values from child inputs using the name of each input as a data object for you (just like group).\n\nRender\nHTML\nAdding the submit handler\n\nThe first feature of a form that we'll explore is that we have a @submit event ready to make our life easier when the time comes to submit our form. The @submit event gives us as the first argument all the descendant fields the form gathered from the inputs. There is no need to use numerous v-models to collect the form data. Let's add our createCharacter() submit handler:\n\nRender\nHTML\nChanging the submit button\n\nAs a convenience when using type=\"form\", the form outputs a submit button automatically. For our case, a \"Submit\" text does not show the intent of the form correctly. To fix that, we can use the submit-label prop, which is a form-specific feature, simply by adding submit-label=\"Create Character\" to show the intent of the form:\n\n<FormKit type=\"form\" @submit=\"createCharacter\" submit-label=\"Create Character\">\n\n  <!-- Rest of our creation form -->\n\n</FormKit>\nGrouping related inputs\n\nWhile the form works right now, we can see that some related inputs are separated (i.e., the form data is a flat structure where all form data are siblings). Suppose our backend needs all attributes inside an attributes property. We can use the group type to group related inputs together by a common name.\n\nJust like the form type, you can wrap all yours fields inside a <FormKit type=\"group\" name: \"attributes\">. Don't forget to add the name property:\n\nRender\nHTML\nGoing deeper\n\nAnd that is it! We could stop here for an introduction on how forms and inputs work with FormKit. However, let's add some UX enhancements and use that to expose ourselves to additional concepts and features that you can use to take your forms to the next level.\n\nUpdating values based on another input\n\nOne thing we can do to improve this form is to change the character's default attributes based on the selected character class. For that, we will be using some new features:\n\ngetNode: getNode gets an input's core node using their id as an identifier. Each input has an associated core node.\nevents: events listen to changes to a certain input.\nnode.input(): the input function on a node lets us update the value of it.\n\nWith those features combined, we can get an input's core node, listen for and respond to events, and update a value of another field using the input function:\n\nRender\nHTML\nMake it into a plugin\n\nThe code now got a bit less readable, so let's extract the logic to another file to create a plugin instead. Note that we are placing the new updateAttributesPlugin only on the class input, so it will not affect any other input. We will also learn another useful feature called traversal by using the at function of a node:\n\nAT() USES NAME\n\nThe at function uses the name attribute instead of the id that getNode uses.\n\nRender\nHTML\nAdding group validation\n\nLet's assume that while different characters are better at different attributes, none should be too powerful. We can do this by creating a budget of points, and adding group validation to the attributes group to ensure they do not exceed 20 points in totality. We'll learn a new feature — custom rules — to accomplish this:\n\nGROUPS DO NOT DISPLAY MESSAGES BY DEFAULT\n\nBy default, the group type does not output any markup, so to show validation errors we need to manually add it.\n\nRender\nHTML\nConditional rendering\n\nSometimes forms need to show or hide fields depending on the value of another input. We can do this by learning 2 new concepts:\n\nContext object — We can access an input's value (along with other data) inside our form because all FormKit components receive their context object in the #default slot prop.\nThe value of a group - The value of a group (and form) input is an object with the values of its children, keyed by the children's names.\nVUE'S KEY PROPERTY\n\nWhen using conditional rendering, note that Vue needs hints to know that a DOM element needs a re-render, instead of trying to reuse it. We can add a unique key property to the element to help Vue.\n\nSo, let's grab the context object of the group input and extract the value: #default=\"{ value }\". We want to add a small easter egg for our users if they decide to change all attributes to 1:\n\nRender\nHTML\nNext steps\n\nAnd that concludes our introduction to FormKit! You are now ready to start using it!\n\nThere are some topics we recommend you exploring next, which you can read in any order or even later after trying out FormKit for yourself:\n\nStyle your forms: Learn how to add classes to FormKit using sections, or even use Tailwind CSS with the help of our guide.\nMulti-language forms: Learn how FormKit makes i18n easy with dozens of available languages. Or you can add your own!\nExplore FormKit's schema: Learn about FormKit's JSON-compatible schema and how you can use it for form generation, saving forms to a database in a JSON format, or building your own form builder."
  },
  {
    "title": "Installation ⚡️ FormKit",
    "url": "https://formkit.com/getting-started/installation",
    "html": "Installation\nPrerequisites\nInstallation instruction wizard\nQUICK START\n\nWant to quickly try FormKit? You can interact with it directly in our online Playground. Need some inspiration? Check out our Examples for quick demos in the FormKit playground. You can also open any example in the docs in the Playground and modify it to see how it reacts.\n\nPrerequisites\nVue 3 or Nuxt 3: If you're using Vue 2 or Nuxt 2 you can use FormKit's predecessor VueFormulate.\nNode.js: 14.18.0, 16.12.0, or higher.\nTerminal: To run npm/yarn commands.\nTHE @NEXT TAG\n\nYou can install the upcoming version of FormKit (unstable) any time by opting to install the \"next\" version tag: npm install @formkit/vue@next\n\nInstallation instruction wizard\n\nLet’s determine the best way to set up FormKit in your project by answering a few questions:\n\nIs your project a new or existing project?\n✨I’m starting a new project\n🖥️I have an existing project"
  },
  {
    "title": "What is Formkit? ⚡️ FormKit",
    "url": "https://formkit.com/getting-started/what-is-formkit",
    "html": "What is FormKit?\nIntroduction\nWhat is a \"form framework\"?\nWhy FormKit?\nSingle Component\nAccessibility\nValidation\nSchema\nStyles\nExtensibility\nCommunity\nWhy not...?\nVideo course\nFormKit Discord server\nIntroduction\n\nFormKit is far more than a UI library. It is a comprehensive form building framework for Vue developers that makes authoring high-quality production-ready forms faster and more accessible, with better DX, UX, and less code. It is easy to learn, and ships with production-ready features like inputs, validation rules, and submission/error handling.\n\nWhat is a \"form framework\"?\n\nWhy do I need a full-fledged framework for forms? Aren't forms easy? Don't UI libraries and frameworks like Vue already solve all the problems? No — because forms are their own distinct problem set, they represent their own distinct data trees, and they deserve their own framework.\n\nThe best overview of FormKit is Justin Schroeder's (the primary author of FormKit) 2023 VueConf US talk called \"Conquering Forms in Vue\". The video below starts at ~12 minutes into the talk — but if you have the time it's worth watching from the beginning.\n\nVueConf US 2023: Conquering Forms in Vue\n\n30 mins\n\nShort on time? Read the introduction post that explains the goals of FormKit written when the framework first launched.\n\nARTICLE\nRead the full \"Introducing FormKit\" manifesto from core team member Justin Schroeder on DEV.to.\nWhy FormKit?\n\nForms seem simple. After all, a <form> and an <input> tag are all that's required. Yet, experienced engineers know that implementing production-ready forms is tedious and complicated. FormKit's key features were designed to solve these problems, while making form authoring efficient and enjoyable for developers:\n\nKey Features\nSingle component: FormKit was designed with a single component for all inputs.\nAccessibility: We output an opinionated accessible markup by default.\nValidation: Numerous built-in validation rules with instant feedback.\nSchema: Powerful schema format to store and generate forms.\nStyles: Beautifully crafted theme.\nExtensibility: Easy to extend any feature.\nCommunity: Friendly community that will help you solve your questions.\nSingle Component\n\nDevelopers love to learn — but no one enjoys poring over third-party APIs and configuration options. That's why FormKit uses a single component for all of its inputs. <FormKit> is the only component you need to know to get started — and it works just like you would expect an <input> tag to work.\n\nAccessibility\n\nCreating accessible forms is a serious challenge. Especially when accessibility standards are not always clear and most developers are under time pressure. Ideally, all developers would be well versed in accessibility best practices, but unfortunately that is not the case. To address this, FormKit outputs an opinionated accessible DOM structure. This is different than many popular “renderless” form libraries that provide no markup at all and rely on developers to supply the inputs themselves.\n\nValidation\n\nFront-end validation that gives instant feedback is an important part of providing a good experience to your users. Unfortunately, it can be incredibly tedious to implement, even if you're using a great validation library. FormKit takes the pain out of front-end validation by baking the rules directly into the inputs.\n\nSchema\n\nFormKit's schema is a JSON-serializable data format for storing DOM structures and component implementations, including FormKit forms. Schemas support advanced features like form generation, conditional logic, boolean operators, loops, slots, and data scoping — all guaranteed to serialize to a string.\n\nStyles\n\nWith the ability to modify FormKit's classes and even HTML, FormKit provides many ways to style your forms. You can roll your own CSS, use a utility class framework like Tailwind CSS, or use Genesis — our ready-built theme that works great in a variety of design contexts!\n\nExtensibility\n\nFormKit comes with great production-ready defaults, and for many users, the defaults are all they'll need. But FormKit is more than just inputs. It is a form building framework, complete with hooks, events, plugins, libraries, and schemas. Advanced developers can craft their own form systems using FormKit's low-level tooling.\n\nCommunity\n\nFormKit has an active Discord community where help is just a few keystrokes away. Community members and core team members alike spend time there helping users solve their issues.\n\nWhy not...?\n\nWhile FormKit does a lot of things, it is not a UI framework or a layout tool. Want inputs next to each other? Cool! Wrap some inputs in a <div> and sprinkle on some flexbox. While FormKit ships with a default theme, this package assumes you'll still be responsible for most of your form's style and layout. FormKit plays nicely with any UI framework or your own custom styles.\n\nIf you need a full UI framework, you can check these other great tools:\n\nVuetify\n\nVuetify is a full UI framework while FormKit is a focused tool for building forms. Some people prefer not to use large UI frameworks, don’t have them on a pre-existing project, don’t want to learn a new framework, or just prefer writing their own narrowly scoped styles. Also, we think composing forms in FormKit is second-to-none.\n\nBuefy\n\nSimilar to Vuetify, Buefy is a full UI framework. If you’re already using Bulma or you're looking for a comprehensive UI solution, it’s a solid choice. FormKit can live alongside any UI framework and still offers the benefits of slick form composition, validation, and error handling to name a few. Even still, there are plenty of people who don’t want or need a full UI framework that would benefit from FormKit’s focused approach.\n\nVeeValidate\n\nVeeValidate is a great option for Vue form validation, and that’s its primary mission — validation. FormKit makes building high quality forms easier by including validation as a sub-feature of the field composition itself. Building forms with FormKit is super easy and blazing fast — of course if you need the extra validation power, you still have it. You can write any custom validation logic you want.\n\nVuelidate\n\nYet another great option for form validation, but focused solely on validation. FormKit provides additional scaffolding and features such as accessibility, i18n, and input composition, enabling developers to create complex forms with minimal friction with validation and error handling included.\n\nvue-form-generator\n\nGenerating forms from JSON is great — that's why schema is a sub-feature of FormKit. Simply pass your form schema to the FormKitSchema component and voilà! Check out the documentation here. Now you can use the same tool for form composition and generation!\n\nVideo course\n\nPrefer to learn by watching? Vue School has an excellent course to help you get started using FormKit to build robust forms for Vue.js. Learn the basics as well as more advanced topics, then head back here to the docs when you need to fill in the gaps for specific use cases.\n\nRobust Vue.js Forms - Vue School Course\n\n1 hr, 49 mins\n\nFormKit Discord server\n\nIf you need generalized help or want to make connections within the community, consider joining the official FormKit Discord. Over 1200 developers along with the core team members have active discussion there. If you are not already a member (it's free and open), you'll need to use the following invite link to join the server:\n\nJoin the FormKit Discord server →"
  }
]
