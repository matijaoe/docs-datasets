[
  {
    "title": "IDE Integrations | Guide | Vitest",
    "url": "https://vitest.dev/guide/ide",
    "html": "IDE Integrations\n​\nVS Code Offical\n​\n\nGitHub | VS Code Marketplace\n\nJetBrains IDE\n​\n\nWebStorm, PhpStorm, IntelliJ IDEA Ultimate, and other JetBrains IDEs come with built-in support for Vitest.\n\nWebStorm Help | IntelliJ IDEA Ultimate Help | PhpStorm Help\n\nWallaby.js Paid (free for OSS)\n​\n\nCreated by The Wallaby Team\n\nWallaby.js runs your Vitest tests immediately as you type, highlighting results in your IDE right next to your code.\n\nVS Code | JetBrains | Visual Studio | Sublime Text"
  },
  {
    "title": "Common Errors | Guide | Vitest",
    "url": "https://vitest.dev/guide/common-errors",
    "html": "Common Errors\n​\nCannot find module './relative-path'\n​\n\nIf you receive an error that module cannot be found, it might mean several different things:\n\nYou misspelled the path. Make sure the path is correct.\nIt's possible that your rely on baseUrl in your tsconfig.json. Vite doesn't take into account tsconfig.json by default, so you might need to install vite-tsconfig-paths yourself, if you rely on this behaviour.\nts\nimport { defineConfig } from 'vitest/config'\nimport tsconfigPaths from 'vite-tsconfig-paths'\n\nexport default defineConfig({\n  plugins: [tsconfigPaths()]\n})\n\nOr rewrite your path to not be relative to root:\n\ndiff\n- import helpers from 'src/helpers'\n+ import helpers from '../src/helpers'\nMake sure you don't have relative aliases. Vite treats them as relative to the file where the import is instead of the root.\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    alias: {\n      '@/': './src/', \n      '@/': new URL('./src/', import.meta.url).pathname, \n    }\n  }\n})"
  },
  {
    "title": "Migration Guide | Guide | Vitest",
    "url": "https://vitest.dev/guide/migration",
    "html": "Migration Guide\n​\nMigrating from Jest\n​\n\nVitest has been designed with a Jest compatible API, in order to make the migration from Jest as simple as possible. Despite those efforts, you may still run into the following differences:\n\nGlobals as a Default\n​\n\nJest has their globals API enabled by default. Vitest does not. You can either enable globals via the globals configuration setting or update your code to use imports from the vitest module instead.\n\nIf you decide to keep globals disabled, be aware that common libraries like testing-library will not run auto DOM cleanup.\n\nModule Mocks\n​\n\nWhen mocking a module in Jest, the factory argument's return value is the default export. In Vitest, the factory argument has to return an object with each export explicitly defined. For example, the following jest.mock would have to be updated as follows:\n\nts\njest.mock('./some-path', () => 'hello') \nvi.mock('./some-path', () => ({ \n  default: 'hello', \n})) \n\nFor more details please refer to the vi.mock api section.\n\nAuto-Mocking Behaviour\n​\n\nUnlike Jest, mocked modules in <root>/__mocks__ are not loaded unless vi.mock() is called. If you need them to be mocked in every test, like in Jest, you can mock them inside setupFiles.\n\nImporting the Original of a Mocked Package\n​\n\nIf you are only partially mocking a package, you might have previously used Jest's function requireActual. In Vitest, you should replace these calls with vi.importActual.\n\nts\nconst { cloneDeep } = jest.requireActual('lodash/cloneDeep') \nconst { cloneDeep } = await vi.importActual('lodash/cloneDeep') \nEnvs\n​\n\nJust like Jest, Vitest sets NODE_ENV to test, if it wasn't set before. Vitest also has a counterpart for JEST_WORKER_ID called VITEST_POOL_ID (always less than or equal to maxThreads), so if you rely on it, don't forget to rename it. Vitest also exposes VITEST_WORKER_ID which is a unique ID of a running worker - this number is not affected by maxThreads, and will increase with each created worker.\n\nReplace property\n​\n\nIf you want to modify the object, you will use replaceProperty API in Jest, you can use vi.stubEnv or vi.spyOn to do the same also in Vitest.\n\nDone Callback\n​\n\nFrom Vitest v0.10.0, the callback style of declaring tests is deprecated. You can rewrite them to use async/await functions, or use Promise to mimic the callback style.\n\nit('should work', (done) => {  \nit('should work', () => new Promise(done => { \n  // ...\n  done()\n}) \n})) \nHooks\n​\n\nbeforeAll/beforeEach hooks may return teardown function in Vitest. Because of that you may need to rewrite your hooks declarations, if they return something other than undefined or null:\n\nts\nbeforeEach(() => setActivePinia(createTestingPinia())) \nbeforeEach(() => { setActivePinia(createTestingPinia()) }) \n\nIn Jest hooks are called sequentially (one after another). By default, Vitest runs hooks in parallel. To use Jest's behavior, update sequence.hooks option:\n\nts\nexport default defineConfig({\n  test: {\n    sequence: { \n      hooks: 'list', \n    } \n  }\n})\nTypes\n​\n\nVitest doesn't have an equivalent to jest namespace, so you will need to import types directly from vitest:\n\nts\nlet fn: jest.Mock<string, [string]> \nimport type { Mock } from 'vitest' \nlet fn: Mock<[string], string> \n\nAlso, Vitest has Args type as a first argument instead of Returns, as you can see in diff.\n\nTimers\n​\n\nVitest doesn't support Jest's legacy timers.\n\nTimeout\n​\n\nIf you used jest.setTimeout, you would need to migrate to vi.setConfig:\n\nts\njest.setTimeout(5_000) \nvi.setConfig({ testTimeout: 5_000 }) \nVue Snapshots\n​\n\nThis is not a Jest-specific feature, but if you previously were using Jest with vue-cli preset, you will need to install jest-serializer-vue package, and use it inside setupFiles:\n\nvite.config.js\n\njs\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    setupFiles: ['./tests/unit/setup.js']\n  }\n})\n\ntests/unit/setup.js\n\njs\nimport vueSnapshotSerializer from 'jest-serializer-vue'\n\nexpect.addSnapshotSerializer(vueSnapshotSerializer)\n\nOtherwise your snapshots will have a lot of escaped \" characters."
  },
  {
    "title": "Comparisons with Other Test Runners | Guide | Vitest",
    "url": "https://vitest.dev/guide/comparisons",
    "html": "Comparisons with Other Test Runners\n​\nJest\n​\n\nJest took over the Testing Framework space by providing out-of-the-box support for most JavaScript projects, a comfortable API (it and expect), and the full pack of testing features that most setups would require (snapshots, mocks, coverage). We are thankful to the Jest team and community for creating a delightful testing API and pushing forward a lot of the testing patterns that are now a standard in the web ecosystem.\n\nIt is possible to use Jest in Vite setups. @sodatea built vite-jest, which aims to provide first-class Vite integration for Jest. The last blockers in Jest have been solved, so this is a valid option for your unit tests.\n\nHowever, in a world where we have Vite providing support for the most common web tooling (TypeScript, JSX, most popular UI Frameworks), Jest represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same vite.config.js.\n\nEven if your library is not using Vite (for example, if it is built with esbuild or Rollup), Vitest is an interesting option as it gives you a faster run for your unit tests and a jump in DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR). Vitest offers compatibility with most of the Jest API and ecosystem libraries, so in most projects, it should be a drop-in replacement for Jest.\n\nCypress\n​\n\nCypress is a browser-based test runner and a complementary tool to Vitest. If you'd like to use Cypress, we suggest using Vitest for all headless logic in your application and Cypress for all browser-based logic.\n\nCypress is known as an end-to-end testing tool, but their new component test runner has great support for testing Vite components and is an ideal choice to test anything that renders in a browser.\n\nBrowser-based runners, like Cypress, WebdriverIO and Web Test Runner, will catch issues that Vitest cannot because they use the real browser and real browser APIs.\n\nCypress's test driver is focused on determining if elements are visible, accessible, and interactive. Cypress is purpose-built for UI development and testing and its DX is centered around test driving your visual components. You see your component rendered alongside the test reporter. Once the test is complete, the component remains interactive and you can debug any failures that occur using your browser devtools.\n\nIn contrast, Vitest is focused on delivering the best DX possible for lightning fast, headless testing. Node-based runners like Vitest support various partially-implemented browser environments, like jsdom, which implement enough for you to quickly unit test any code that references browser APIs. The tradeoff is that these browser environments have limitations in what they can implement. For example, jsdom is missing a number of features like window.navigation or a layout engine (offsetTop, etc).\n\nLastly, in contrast to the Web Test Runner, the Cypress test runner is more like an IDE than a test runner because you also see the real rendered component in the browser, along with its test results and logs.\n\nCypress has also been integrating Vite in their products: re-building their App's UI using Vitesse and using Vite to test drive their project's development.\n\nWe believe that Cypress isn't a good option for unit testing headless code, but that using Cypress (for E2E and Component Testing) and Vitest (for unit tests) would cover your app's testing needs.\n\nWebdriverIO\n​\n\nWebdriverIO is, similar to Cypress, a browser-based alternative test runner and a complementary tool to Vitest. It can be used as an end-to-end testing tool as well as for testing web components. It even uses components of Vitest under the hood, e.g. for mocking and stubbing within component tests.\n\nWebdriverIO comes with the same advantages as Cypress allowing you to test your logic in real browser. However, it uses actual web standards for automation, which overcomes some of the tradeoffs and limitation when running tests in Cypress. Furthermore, it allows you to run tests on mobile as well, giving you access to test your application in even more environments.\n\nWeb Test Runner\n​\n\n@web/test-runner runs tests inside a headless browser, providing the same execution environment as your web application without the need for mocking out browser APIs or the DOM. This also makes it possible to debug inside a real browser using the devtools, although there is no UI shown for stepping through the test, as there is in Cypress tests.\n\nThere is a watch mode, but it is not as intelligent as that of Vitest, and may not always re-run the tests you want.\n\nTo use @web/test-runner with a Vite project, use @remcovaes/web-test-runner-vite-plugin. @web/test-runner does not include assertion or mocking libraries, so it is up to you to add them.\n\nuvu\n​\n\nuvu is a test runner for Node.js and the browser. It runs tests in a single thread, so tests are not isolated and can leak across files. Vitest, however, uses worker threads to isolate tests and run them in parallel.\n\nFor transforming your code, uvu relies on require and loader hooks. Vitest uses Vite, so files are transformed with the full power of Vite's plugin system. In a world where we have Vite providing support for the most common web tooling (TypeScript, JSX, most popular UI Frameworks), uvu represents a duplication of complexity. If your app is powered by Vite, having two different pipelines to configure and maintain is not justifiable. With Vitest you get to define the configuration for your dev, build and test environments as a single pipeline, sharing the same plugins and the same configuration.\n\nuvu does not provide an intelligent watch mode to rerun the changed tests, while Vitest gives you amazing DX thanks to the default watch mode using Vite instant Hot Module Reload (HMR).\n\nuvu is a fast option for running simple tests, but Vitest can be faster and more reliable for more complex tests and projects."
  },
  {
    "title": "Debugging | Guide | Vitest",
    "url": "https://vitest.dev/guide/debugging",
    "html": "Debugging\n​\n\nTIP\n\nWhen debugging tests you might want to use --test-timeout CLI argument to prevent tests from timing out when stopping at breakpoints.\n\nVS Code\n​\n\nQuick way to debug tests in VS Code is via JavaScript Debug Terminal. Open a new JavaScript Debug Terminal and run npm run test or vitest directly. this works with any code ran in Node, so will work with most JS testing frameworks\n\nYou can also add a dedicated launch configuration to debug a test file in VS Code:\n\njson\n{\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"type\": \"node\",\n      \"request\": \"launch\",\n      \"name\": \"Debug Current Test File\",\n      \"autoAttachChildProcesses\": true,\n      \"skipFiles\": [\"<node_internals>/**\", \"**/node_modules/**\"],\n      \"program\": \"${workspaceRoot}/node_modules/vitest/vitest.mjs\",\n      \"args\": [\"run\", \"${relativeFile}\"],\n      \"smartStep\": true,\n      \"console\": \"integratedTerminal\"\n    }\n  ]\n}\n\nThen in the debug tab, ensure 'Debug Current Test File' is selected. You can then open the test file you want to debug and press F5 to start debugging.\n\nIntelliJ IDEA\n​\n\nCreate a 'Node.js' run configuration. Use the following settings to run all tests in debug mode:\n\nSetting\tValue\nWorking directory\t/path/to/your-project-root\nJavaScript file\t./node_modules/vitest/vitest.mjs\nApplication parameters\trun --pool forks\n\nThen run this configuration in debug mode. The IDE will stop at JS/TS breakpoints set in the editor.\n\nNode Inspector, e.g. Chrome DevTools\n​\n\nVitest also supports debugging tests without IDEs. However this requires that tests are not run parallel. Use one of the following commands to launch Vitest.\n\nsh\n# To run in a single worker\nvitest --inspect-brk --pool threads --poolOptions.threads.singleThread\n\n# To run in a single child process\nvitest --inspect-brk --pool forks --poolOptions.forks.singleFork\n\nOnce Vitest starts it will stop execution and wait for you to open developer tools that can connect to Node.js inspector. You can use Chrome DevTools for this by opening chrome://inspect on browser.\n\nIn watch mode you can keep the debugger open during test re-runs by using the --poolOptions.threads.isolate false options."
  },
  {
    "title": "Extending Matchers | Guide | Vitest",
    "url": "https://vitest.dev/guide/extending-matchers",
    "html": "Extending Matchers\n​\n\nSince Vitest is compatible with both Chai and Jest, you can use either the chai.use API or expect.extend, whichever you prefer.\n\nThis guide will explore extending matchers with expect.extend. If you are interested in Chai's API, check their guide.\n\nTo extend default matchers, call expect.extend with an object containing your matchers.\n\nts\nexpect.extend({\n  toBeFoo(received, expected) {\n    const { isNot } = this\n    return {\n      // do not alter your \"pass\" based on isNot. Vitest does it for you\n      pass: received === 'foo',\n      message: () => `${received} is${isNot ? ' not' : ''} foo`\n    }\n  }\n})\n\nIf you are using TypeScript, since Vitest 0.31.0 you can extend default Assertion interface in an ambient declaration file (e.g: vitest.d.ts) with the code below:\n\nts\nimport type { Assertion, AsymmetricMatchersContaining } from 'vitest'\n\ninterface CustomMatchers<R = unknown> {\n  toBeFoo(): R\n}\n\ndeclare module 'vitest' {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n\nWARNING\n\nDon't forget to include the ambient declaration file in your tsconfig.json.\n\nThe return value of a matcher should be compatible with the following interface:\n\nts\ninterface MatcherResult {\n  pass: boolean\n  message: () => string\n  // If you pass these, they will automatically appear inside a diff when\n  // the matcher does not pass, so you don't need to print the diff yourself\n  actual?: unknown\n  expected?: unknown\n}\n\nWARNING\n\nIf you create an asynchronous matcher, don't forget to await the result (await expect('foo').toBeFoo()) in the test itself.\n\nThe first argument inside a matcher's function is the received value (the one inside expect(received)). The rest are arguments passed directly to the matcher.\n\nMatcher function have access to this context with the following properties:\n\nisNot\n\nReturns true, if matcher was called on not (expect(received).not.toBeFoo()).\n\npromise\n\nIf matcher was called on resolved/rejected, this value will contain the name of modifier. Otherwise, it will be an empty string.\n\nequals\n\nThis is a utility function that allows you to compare two values. It will return true if values are equal, false otherwise. This function is used internally for almost every matcher. It supports objects with asymmetric matchers by default.\n\nutils\n\nThis contains a set of utility functions that you can use to display messages.\n\nthis context also contains information about the current test. You can also get it by calling expect.getState(). The most useful properties are:\n\ncurrentTestName\n\nFull name of the current test (including describe block).\n\ntestPath\n\nPath to the current test."
  },
  {
    "title": "Vitest UI | Guide | Vitest",
    "url": "https://vitest.dev/guide/ui",
    "html": "Vitest UI\n​\n\nPowered by Vite, Vitest also has a dev server under the hood when running the tests. This allows Vitest to provide a beautiful UI to view and interact with your tests. The Vitest UI is optional, so you'll need to install it with:\n\nbash\nnpm i -D @vitest/ui\n\nThen you can start the tests with UI by passing the --ui flag:\n\nbash\nvitest --ui\n\nThen you can visit the Vitest UI at http://localhost:51204/__vitest__/\n\nSince Vitest 0.26.0, UI can also be used as a reporter. Use 'html' reporter in your Vitest configuration to generate HTML output and preview the results of your tests:\n\nts\n// vitest.config.ts\n\nexport default {\n  test: {\n    reporters: ['html']\n  }\n}\n\nSince Vitest 0.31.0, you can check your coverage report in Vitest UI: check Vitest UI Coverage for more details.\n\nWARNING\n\nIf you still want to see how your tests are running in real time in the terminal, don't forget to add default reporter to reporters option: ['default', 'html'].\n\nTIP\n\nTo preview your HTML report, you can use the vite preview command:\n\nsh\nnpx vite preview --outDir ./html\n\nYou can configure output with outputFile config option. You need to specify .html path there. For example, ./html/index.html is the default value."
  },
  {
    "title": "Test Environment | Guide | Vitest",
    "url": "https://vitest.dev/guide/environment",
    "html": "Test Environment\n​\n\nVitest provides environment option to run code inside a specific environment. You can modify how environment behaves with environmentOptions option.\n\nBy default, you can use these environments:\n\nnode is default environment\njsdom emulates browser environment by providing Browser API, uses jsdom package\nhappy-dom emulates browser environment by providing Browser API, and considered to be faster than jsdom, but lacks some API, uses happy-dom package\nedge-runtime emulates Vercel's edge-runtime, uses @edge-runtime/vm package\nEnvironments for Specific Files\n​\n\nWhen setting environment option in your config, it will apply to all the test files in your project. To have more fine-grained control, you can use control comments to specify environment for specific files. Control comments are comments that start with @vitest-environment and are followed by the environment name:\n\nts\n// @vitest-environment jsdom\n\nimport { expect, test } from 'vitest'\n\ntest('test', () => {\n  expect(typeof window).not.toBe('undefined')\n})\n\nOr you can also set environmentMatchGlobs option specifying the environment based on the glob patterns.\n\nCustom Environment\n​\n\nStarting from 0.23.0, you can create your own package to extend Vitest environment. To do so, create package with the name vitest-environment-${name} or specify a path to a valid JS/TS file (supported since 0.34.0). That package should export an object with the shape of Environment:\n\nts\nimport type { Environment } from 'vitest'\n\nexport default <Environment>{\n  name: 'custom',\n  transformMode: 'ssr',\n  // optional - only if you support \"experimental-vm\" pool\n  async setupVM() {\n    const vm = await import('node:vm')\n    const context = vm.createContext()\n    return {\n      getVmContext() {\n        return context\n      },\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  },\n  setup() {\n    // custom setup\n    return {\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  }\n}\n\nWARNING\n\nSince 0.34.0 Vitest requires transformMode option on environment object. It should be equal to ssr or web. This value determines how plugins will transform source code. If it's set to ssr, plugin hooks will receive ssr: true when transforming or resolving files. Otherwise, ssr is set to false.\n\nYou also have access to default Vitest environments through vitest/environments entry:\n\nts\nimport { builtinEnvironments, populateGlobal } from 'vitest/environments'\n\nconsole.log(builtinEnvironments) // { jsdom, happy-dom, node, edge-runtime }\n\nVitest also provides populateGlobal utility function, which can be used to move properties from object into the global namespace:\n\nts\ninterface PopulateOptions {\n  // should non-class functions be bind to the global namespace\n  bindFunctions?: boolean\n}\n\ninterface PopulateResult {\n  // a list of all keys that were copied, even if value doesn't exist on original object\n  keys: Set<string>\n  // a map of original object that might have been overridden with keys\n  // you can return these values inside `teardown` function\n  originals: Map<string | symbol, any>\n}\n\nexport function populateGlobal(global: any, original: any, options: PopulateOptions): PopulateResult"
  },
  {
    "title": "Test Context | Guide | Vitest",
    "url": "https://vitest.dev/guide/test-context",
    "html": "Test Context\n​\n\nInspired by Playwright Fixtures, Vitest's test context allows you to define utils, states, and fixtures that can be used in your tests.\n\nUsage\n​\n\nThe first argument for each test callback is a test context.\n\nts\nimport { it } from 'vitest'\n\nit('should work', (ctx) => {\n  // prints name of the test\n  console.log(ctx.task.name)\n})\nBuilt-in Test Context\n​\ncontext.task\n​\n\nA readonly object containing metadata about the test.\n\ncontext.expect\n​\n\nThe expect API bound to the current test:\n\nts\nimport { it } from 'vitest'\n\nit('math is easy', ({ expect }) => {\n  expect(2 + 2).toBe(4)\n})\n\nThis API is useful for running snapshot tests concurrently because global expect cannot track them:\n\nts\nimport { it } from 'vitest'\n\nit.concurrent('math is easy', ({ expect }) => {\n  expect(2 + 2).toMatchInlineSnapshot()\n})\n\nit.concurrent('math is hard', ({ expect }) => {\n  expect(2 * 2).toMatchInlineSnapshot()\n})\ncontext.skip\n​\n\nSkips subsequent test execution and marks test as skipped:\n\nts\nimport { expect, it } from 'vitest'\n\nit('math is hard', ({ skip }) => {\n  skip()\n  expect(2 + 2).toBe(5)\n})\nExtend Test Context\n​\n\nVitest provides two different ways to help you extend the test context.\n\ntest.extend\n​\n\nWARNING\n\nThis API is available since Vitest 0.32.3.\n\nLike Playwright, you can use this method to define your own test API with custom fixtures and reuse it anywhere.\n\nFor example, we first create myTest with two fixtures, todos and archive.\n\nts\n// my-test.ts\nimport { test } from 'vitest'\n\nconst todos = []\nconst archive = []\n\nexport const myTest = test.extend({\n  todos: async ({}, use) => {\n    // setup the fixture before each test function\n    todos.push(1, 2, 3)\n\n    // use the fixture value\n    await use(todos)\n\n    // cleanup the fixture after each test function\n    todos.length = 0\n  },\n  archive\n})\n\nThen we can import and use it.\n\nts\nimport { expect } from 'vitest'\nimport { myTest } from './my-test.js'\n\nmyTest('add items to todos', ({ todos }) => {\n  expect(todos.length).toBe(3)\n\n  todos.push(4)\n  expect(todos.length).toBe(4)\n})\n\nmyTest('move items from todos to archive', ({ todos, archive }) => {\n  expect(todos.length).toBe(3)\n  expect(archive.length).toBe(0)\n\n  archive.push(todos.pop())\n  expect(todos.length).toBe(2)\n  expect(archive.length).toBe(1)\n})\n\nWe can also add more fixtures or override existing fixtures by extending myTest.\n\nts\nexport const myTest2 = myTest.extend({\n  settings: {\n    // ...\n  }\n})\nFixture initialization\n​\n\nVitest runner will smartly initialize your fixtures and inject them into the test context based on usage.\n\nts\nimport { test } from 'vitest'\n\nasync function todosFn({ task }, use) {\n  await use([1, 2, 3])\n}\n\nconst myTest = test.extend({\n  todos: todosFn,\n  archive: []\n})\n\n// todosFn will not run\nmyTest('', () => {})\nmyTets('', ({ archive }) => {})\n\n// todosFn will run\nmyTest('', ({ todos }) => {})\n\nWARNING\n\nWhen using test.extend() with fixtures, you should always use the object destructuring pattern { todos } to access context both in fixture function and test function.\n\nTypeScript\n​\n\nTo provide fixture types for all your custom contexts, you can pass the fixtures type as a generic.\n\nts\ninterface MyFixtures {\n  todos: number[]\n  archive: number[]\n}\n\nconst myTest = test.extend<MyFixtures>({\n  todos: [],\n  archive: []\n})\n\nmyTest('', (context) => {\n  expectTypeOf(context.todos).toEqualTypeOf<number[]>()\n  expectTypeOf(context.archive).toEqualTypeOf<number[]>()\n})\nbeforeEach and afterEach\n​\n\nThe contexts are different for each test. You can access and extend them within the beforeEach and afterEach hooks.\n\nts\nimport { beforeEach, it } from 'vitest'\n\nbeforeEach(async (context) => {\n  // extend context\n  context.foo = 'bar'\n})\n\nit('should work', ({ foo }) => {\n  console.log(foo) // 'bar'\n})\nTypeScript\n​\n\nTo provide property types for all your custom contexts, you can aggregate the TestContext type by adding\n\nts\ndeclare module 'vitest' {\n  export interface TestContext {\n    foo?: string\n  }\n}\n\nIf you want to provide property types only for specific beforeEach, afterEach, it and test hooks, you can pass the type as a generic.\n\nts\ninterface LocalTestContext {\n  foo: string\n}\n\nbeforeEach<LocalTestContext>(async (context) => {\n  // typeof context is 'TestContext & LocalTestContext'\n  context.foo = 'bar'\n})\n\nit<LocalTestContext>('should work', ({ foo }) => {\n  // typeof foo is 'string'\n  console.log(foo) // 'bar'\n})"
  },
  {
    "title": "In-Source Testing | Guide | Vitest",
    "url": "https://vitest.dev/guide/in-source",
    "html": "In-Source Testing\n​\n\nVitest also provides a way to run tests within your source code along side the implementation, similar to Rust's module tests.\n\nThis makes the tests share the same closure as the implementations and able to test against private states without exporting. Meanwhile, it also brings a closer feedback loop for development.\n\nSetup\n​\n\nTo get started, put a if (import.meta.vitest) block at the end of your source file and write some tests inside it. For example:\n\nts\n// src/index.ts\n\n// the implementation\nexport function add(...args: number[]) {\n  return args.reduce((a, b) => a + b, 0)\n}\n\n// in-source test suites\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('add', () => {\n    expect(add()).toBe(0)\n    expect(add(1)).toBe(1)\n    expect(add(1, 2, 3)).toBe(6)\n  })\n}\n\nUpdate the includeSource config for Vitest to grab the files under src/:\n\nts\n// vite.config.ts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'], \n  },\n})\n\nThen you can start to test!\n\nbash\n$ npx vitest\nProduction Build\n​\n\nFor the production build, you will need to set the define options in your config file, letting the bundler do the dead code elimination. For example, in Vite\n\nts\n// vite.config.ts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    includeSource: ['src/**/*.{js,ts}'],\n  },\n  define: { \n    'import.meta.vitest': 'undefined', \n  }, \n})\nOther Bundlers\n​\nunbuild\nRollup\nTypeScript\n​\n\nTo get TypeScript support for import.meta.vitest, add vitest/importMeta to your tsconfig.json:\n\njson\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"vitest/importMeta\" \n    ]\n  }\n}\n\nReference to test/import-meta for the full example.\n\nNotes\n​\n\nThis feature could be useful for:\n\nUnit testing for small-scoped functions or utilities\nPrototyping\nInline Assertion\n\nIt's recommended to use separate test files instead for more complex tests like components or E2E testing."
  },
  {
    "title": "Browser Mode | Guide | Vitest",
    "url": "https://vitest.dev/guide/browser",
    "html": "Browser Mode Experimental\n​\n\nThis page provides information about the experimental browser mode feature in the Vitest API, which allows you to run your tests in the browser natively, providing access to browser globals like window and document. This feature is currently under development, and APIs may change in the future.\n\nMotivation\n​\n\nWe developed the Vitest browser mode feature to help improve testing workflows and achieve more accurate and reliable test results. This experimental addition to our testing API allows developers to run tests in a native browser environment. In this section, we'll explore the motivations behind this feature and its benefits for testing.\n\nDifferent Ways of Testing\n​\n\nThere are different ways to test JavaScript code. Some testing frameworks simulate browser environments in Node.js, while others run tests in real browsers. In this context, jsdom is an example of a spec implementation that simulates a browser environment by being used with a test runner like Jest or Vitest, while other testing tools such as WebdriverIO or Cypress allow developers to test their applications in a real browser or in case of Playwright provide you a browser engine.\n\nThe Simulation Caveat\n​\n\nTesting JavaScript programs in simulated environments such as jsdom or happy-dom has simplified the test setup and provided an easy-to-use API, making them suitable for many projects and increasing confidence in test results. However, it is crucial to keep in mind that these tools only simulate a browser environment and not an actual browser, which may result in some discrepancies between the simulated environment and the real environment. Therefore, false positives or negatives in test results may occur.\n\nTo achieve the highest level of confidence in our tests, it's crucial to test in a real browser environment. This is why we developed the browser mode feature in Vitest, allowing developers to run tests natively in a browser and gain more accurate and reliable test results. With browser-level testing, developers can be more confident that their application will work as intended in a real-world scenario.\n\nDrawbacks\n​\n\nWhen using Vitest browser, it is important to consider the following drawbacks:\n\nEarly Development\n​\n\nThe browser mode feature of Vitest is still in its early stages of development. As such, it may not yet be fully optimized, and there may be some bugs or issues that have not yet been ironed out. It is recommended that users augment their Vitest browser experience with a standalone browser-side test runner like WebdriverIO, Cypress or Playwright.\n\nLonger Initialization\n​\n\nVitest browser requires spinning up the provider and the browser during the initialization process, which can take some time. This can result in longer initialization times compared to other testing patterns.\n\nConfiguration\n​\n\nTo activate browser mode in your Vitest configuration, you can use the --browser flag or set the browser.enabled field to true in your Vitest configuration file. Here is an example configuration using the browser field:\n\nts\nexport default defineConfig({\n  test: {\n    browser: {\n      enabled: true,\n      name: 'chrome', // browser name is required\n    },\n  }\n})\nBrowser Option Types\n​\n\nThe browser option in Vitest depends on the provider. Vitest will fail, if you pass --browser and don't specify its name in the config file. Available options:\n\nwebdriverio (default) supports these browsers:\nfirefox\nchrome\nedge\nsafari\nplaywright supports these browsers:\nfirefox\nwebkit\nchromium\nCross-Browser Testing\n​\n\nWhen you specify a browser name in the browser option, Vitest will try to run the specified browser using WebdriverIO by default, and then run the tests there. This feature makes cross-browser testing easy to use and configure in environments like a CI. If you don't want to use WebdriverIO, you can configure the custom browser provider by using browser.provider option.\n\nTo specify a browser using the CLI, use the --browser flag followed by the browser name, like this:\n\nsh\nnpx vitest --browser=chrome\n\nOr you can provide browser options to CLI with dot notation:\n\nsh\nnpx vitest --browser.name=chrome --browser.headless\n\nNOTE\n\nWhen using the Safari browser option with WebdriverIO, the safaridriver needs to be activated by running sudo safaridriver --enable on your device.\n\nAdditionally, when running your tests, Vitest will attempt to install some drivers for compatibility with safaridriver.\n\nHeadless\n​\n\nHeadless mode is another option available in the browser mode. In headless mode, the browser runs in the background without a user interface, which makes it useful for running automated tests. The headless option in Vitest can be set to a boolean value to enable or disable headless mode.\n\nHere's an example configuration enabling headless mode:\n\nts\nexport default defineConfig({\n  test: {\n    browser: {\n      enabled: true,\n      headless: true,\n    },\n  }\n})\n\nYou can also set headless mode using the --browser.headless flag in the CLI, like this:\n\nsh\nnpx vitest --browser.name=chrome --browser.headless\n\nIn this case, Vitest will run in headless mode using the Chrome browser.\n\nLimitations\n​\nThread Blocking Dialogs\n​\n\nWhen using Vitest Browser, it's important to note that thread blocking dialogs like alert or confirm cannot be used natively. This is because they block the web page, which means Vitest cannot continue communicating with the page, causing the execution to hang.\n\nIn such situations, Vitest provides default mocks with default returned values for these APIs. This ensures that if the user accidentally uses synchronous popup web APIs, the execution would not hang. However, it's still recommended for the user to mock these web APIs for better experience. Read more in Mocking."
  },
  {
    "title": "Testing Types | Guide | Vitest",
    "url": "https://vitest.dev/guide/testing-types",
    "html": "Testing Types\n​\n\nVitest allows you to write tests for your types, using expectTypeOf or assertType syntaxes. By default all tests inside *.test-d.ts files are considered type tests, but you can change it with typecheck.include config option.\n\nUnder the hood Vitest calls tsc or vue-tsc, depending on your config, and parses results. Vitest will also print out type errors in your source code, if it finds any. You can disable it with typecheck.ignoreSourceErrors config option.\n\nKeep in mind that Vitest doesn't run or compile these files, they are only statically analyzed by the compiler, and because of that you cannot use any dynamic statements. Meaning, you cannot use dynamic test names, and test.each, test.runIf, test.skipIf, test.concurrent APIs. But you can use other APIs, like test, describe, .only, .skip and .todo.\n\nUsing CLI flags, like --allowOnly and -t are also supported for type checking.\n\nts\nimport { assertType, expectTypeOf } from 'vitest'\nimport { mount } from './mount.js'\n\ntest('my types work properly', () => {\n  expectTypeOf(mount).toBeFunction()\n  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()\n\n  // @ts-expect-error name is a string\n  assertType(mount({ name: 42 }))\n})\n\nAny type error triggered inside a test file will be treated as a test error, so you can use any type trick you want to test types of your project.\n\nYou can see a list of possible matchers in API section.\n\nReading Errors\n​\n\nIf you are using expectTypeOf API, refer to the expect-type documentation on its error messages.\n\nWhen types don't match, .toEqualTypeOf and .toMatchTypeOf use a special helper type to produce error messages that are as actionable as possible. But there's a bit of an nuance to understanding them. Since the assertions are written \"fluently\", the failure should be on the \"expected\" type, not the \"actual\" type (expect<Actual>().toEqualTypeOf<Expected>()). This means that type errors can be a little confusing - so this library produces a MismatchInfo type to try to make explicit what the expectation is. For example:\n\nts\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: string }>()\n\nIs an assertion that will fail, since {a: 1} has type {a: number} and not {a: string}. The error message in this case will read something like this:\n\ntest/test.ts:999:999 - error TS2344: Type '{ a: string; }' does not satisfy the constraint '{ a: \\\\\"Expected: string, Actual: number\\\\\"; }'.\n  Types of property 'a' are incompatible.\n    Type 'string' is not assignable to type '\\\\\"Expected: string, Actual: number\\\\\"'.\n\n999 expectTypeOf({a: 1}).toEqualTypeOf<{a: string}>()\n\nNote that the type constraint reported is a human-readable messaging specifying both the \"expected\" and \"actual\" types. Rather than taking the sentence Types of property 'a' are incompatible // Type 'string' is not assignable to type \"Expected: string, Actual: number\" literally - just look at the property name ('a') and the message: Expected: string, Actual: number. This will tell you what's wrong, in most cases. Extremely complex types will of course be more effort to debug, and may require some experimentation. Please raise an issue if the error messages are actually misleading.\n\nThe toBe... methods (like toBeString, toBeNumber, toBeVoid etc.) fail by resolving to a non-callable type when the Actual type under test doesn't match up. For example, the failure for an assertion like expectTypeOf(1).toBeString() will look something like this:\n\ntest/test.ts:999:999 - error TS2349: This expression is not callable.\n  Type 'ExpectString<number>' has no call signatures.\n\n999 expectTypeOf(1).toBeString()\n                    ~~~~~~~~~~\n\nThe This expression is not callable part isn't all that helpful - the meaningful error is the next line, Type 'ExpectString<number> has no call signatures. This essentially means you passed a number but asserted it should be a string.\n\nIf TypeScript added support for \"throw\" types these error messages could be improved significantly. Until then they will take a certain amount of squinting.\n\nConcrete \"expected\" objects vs typeargs\n​\n\nError messages for an assertion like this:\n\nts\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: '' })\n\nWill be less helpful than for an assertion like this:\n\nts\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: string }>()\n\nThis is because the TypeScript compiler needs to infer the typearg for the .toEqualTypeOf({a: ''}) style, and this library can only mark it as a failure by comparing it against a generic Mismatch type. So, where possible, use a typearg rather than a concrete type for .toEqualTypeOf and toMatchTypeOf. If it's much more convenient to compare two concrete types, you can use typeof:\n\nts\nconst one = valueFromFunctionOne({ some: { complex: inputs } })\nconst two = valueFromFunctionTwo({ some: { other: inputs } })\n\nexpectTypeOf(one).toEqualTypeof<typeof two>()\n\nIf you find it hard working with expectTypeOf API and figuring out errors, you can always use more simple assertType API:\n\nts\nconst answer = 42\n\nassertType<number>(answer)\n// @ts-expect-error answer is not a string\nassertType<string>(answer)\n\nTIP\n\nWhen using @ts-expect-error syntax, you might want to make sure that you didn't make a typo. You can do that by including your type files in test.include config option, so Vitest will also actually run these tests and fail with ReferenceError.\n\nThis will pass, because it expects an error, but the word “answer” has a typo, so it's a false positive error:\n\nts\n// @ts-expect-error answer is not a string\nassertType<string>(answr) //\nRun Typechecking\n​\n\nSince Vitest 1.0, to enabled typechecking, just add --typecheck flag to your Vitest command in package.json:\n\njson\n{\n  \"scripts\": {\n    \"test\": \"vitest --typecheck\"\n  }\n}\n\nNow you can run typecheck:\n\nnpm\nyarn\npnpm\nbun\nbash\nnpm run test\n\nVitest uses tsc --noEmit or vue-tsc --noEmit, depending on your configuration, so you can remove these scripts from your pipeline."
  },
  {
    "title": "Mocking | Guide | Vitest",
    "url": "https://vitest.dev/guide/mocking",
    "html": "Mocking\n​\n\nWhen writing tests it's only a matter of time before you need to create a \"fake\" version of an internal — or external — service. This is commonly referred to as mocking. Vitest provides utility functions to help you out through its vi helper. You can import { vi } from 'vitest' or access it globally (when global configuration is enabled).\n\nWARNING\n\nAlways remember to clear or restore mocks before or after each test run to undo mock state changes between runs! See mockReset docs for more info.\n\nIf you wanna dive in head first, check out the API section otherwise keep reading to take a deeper dive into the world of mocking.\n\nDates\n​\n\nSometimes you need to be in control of the date to ensure consistency when testing. Vitest uses @sinonjs/fake-timers package for manipulating timers, as well as system date. You can find more about the specific API in detail here.\n\nExample\n​\njs\nimport { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'\n\nconst businessHours = [9, 17]\n\nfunction purchase() {\n  const currentHour = new Date().getHours()\n  const [open, close] = businessHours\n\n  if (currentHour > open && currentHour < close)\n    return { message: 'Success' }\n\n  return { message: 'Error' }\n}\n\ndescribe('purchasing flow', () => {\n  beforeEach(() => {\n    // tell vitest we use mocked time\n    vi.useFakeTimers()\n  })\n\n  afterEach(() => {\n    // restoring date after each test run\n    vi.useRealTimers()\n  })\n\n  it('allows purchases within business hours', () => {\n    // set hour within business hours\n    const date = new Date(2000, 1, 1, 13)\n    vi.setSystemTime(date)\n\n    // access Date.now() will result in the date set above\n    expect(purchase()).toEqual({ message: 'Success' })\n  })\n\n  it('disallows purchases outside of business hours', () => {\n    // set hour outside business hours\n    const date = new Date(2000, 1, 1, 19)\n    vi.setSystemTime(date)\n\n    // access Date.now() will result in the date set above\n    expect(purchase()).toEqual({ message: 'Error' })\n  })\n})\nFunctions\n​\n\nMocking functions can be split up into two different categories; spying & mocking.\n\nSometimes all you need is to validate whether or not a specific function has been called (and possibly which arguments were passed). In these cases a spy would be all we need which you can use directly with vi.spyOn() (read more here).\n\nHowever spies can only help you spy on functions, they are not able to alter the implementation of those functions. In the case where we do need to create a fake (or mocked) version of a function we can use vi.fn() (read more here).\n\nWe use Tinyspy as a base for mocking functions, but we have our own wrapper to make it jest compatible. Both vi.fn() and vi.spyOn() share the same methods, however only the return result of vi.fn() is callable.\n\nExample\n​\njs\nimport { afterEach, describe, expect, it, vi } from 'vitest'\n\nfunction getLatest(index = messages.items.length - 1) {\n  return messages.items[index]\n}\n\nconst messages = {\n  items: [\n    { message: 'Simple test message', from: 'Testman' },\n    // ...\n  ],\n  getLatest, // can also be a `getter or setter if supported`\n}\n\ndescribe('reading messages', () => {\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n\n  it('should get the latest message with a spy', () => {\n    const spy = vi.spyOn(messages, 'getLatest')\n    expect(spy.getMockName()).toEqual('getLatest')\n\n    expect(messages.getLatest()).toEqual(\n      messages.items[messages.items.length - 1],\n    )\n\n    expect(spy).toHaveBeenCalledTimes(1)\n\n    spy.mockImplementationOnce(() => 'access-restricted')\n    expect(messages.getLatest()).toEqual('access-restricted')\n\n    expect(spy).toHaveBeenCalledTimes(2)\n  })\n\n  it('should get with a mock', () => {\n    const mock = vi.fn().mockImplementation(getLatest)\n\n    expect(mock()).toEqual(messages.items[messages.items.length - 1])\n    expect(mock).toHaveBeenCalledTimes(1)\n\n    mock.mockImplementationOnce(() => 'access-restricted')\n    expect(mock()).toEqual('access-restricted')\n\n    expect(mock).toHaveBeenCalledTimes(2)\n\n    expect(mock()).toEqual(messages.items[messages.items.length - 1])\n    expect(mock).toHaveBeenCalledTimes(3)\n  })\n})\nMore\n​\nJest's Mock Functions\nGlobals\n​\n\nYou can mock global variables that are not present with jsdom or node by using vi.stubGlobal helper. It will put the value of the global variable into a globalThis object.\n\nts\nimport { vi } from 'vitest'\n\nconst IntersectionObserverMock = vi.fn(() => ({\n  disconnect: vi.fn(),\n  observe: vi.fn(),\n  takeRecords: vi.fn(),\n  unobserve: vi.fn(),\n}))\n\nvi.stubGlobal('IntersectionObserver', IntersectionObserverMock)\n\n// now you can access it as `IntersectionObserver` or `window.IntersectionObserver`\nModules\n​\n\nMock modules observe third-party-libraries, that are invoked in some other code, allowing you to test arguments, output or even redeclare its implementation.\n\nSee the vi.mock() API section for a more in-depth detailed API description.\n\nAutomocking Algorithm\n​\n\nIf your code is importing a mocked module, without any associated __mocks__ file or factory for this module, Vitest will mock the module itself by invoking it and mocking every export.\n\nThe following principles apply\n\nAll arrays will be emptied\nAll primitives and collections will stay the same\nAll objects will be deeply cloned\nAll instances of classes and their prototypes will be deeply cloned\nExample\n​\njs\nimport { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'\nimport { Client } from 'pg'\nimport { failure, success } from './handlers.js'\n\n// handlers\nexport function success(data) {}\nexport function failure(data) {}\n\n// get todos\nexport async function getTodos(event, context) {\n  const client = new Client({\n    // ...clientOptions\n  })\n\n  await client.connect()\n\n  try {\n    const result = await client.query('SELECT * FROM todos;')\n\n    client.end()\n\n    return success({\n      message: `${result.rowCount} item(s) returned`,\n      data: result.rows,\n      status: true,\n    })\n  }\n  catch (e) {\n    console.error(e.stack)\n\n    client.end()\n\n    return failure({ message: e, status: false })\n  }\n}\n\nvi.mock('pg', () => {\n  const Client = vi.fn()\n  Client.prototype.connect = vi.fn()\n  Client.prototype.query = vi.fn()\n  Client.prototype.end = vi.fn()\n\n  return { Client }\n})\n\nvi.mock('./handlers.js', () => {\n  return {\n    success: vi.fn(),\n    failure: vi.fn(),\n  }\n})\n\ndescribe('get a list of todo items', () => {\n  let client\n\n  beforeEach(() => {\n    client = new Client()\n  })\n\n  afterEach(() => {\n    vi.clearAllMocks()\n  })\n\n  it('should return items successfully', async () => {\n    client.query.mockResolvedValueOnce({ rows: [], rowCount: 0 })\n\n    await getTodos()\n\n    expect(client.connect).toBeCalledTimes(1)\n    expect(client.query).toBeCalledWith('SELECT * FROM todos;')\n    expect(client.end).toBeCalledTimes(1)\n\n    expect(success).toBeCalledWith({\n      message: '0 item(s) returned',\n      data: [],\n      status: true,\n    })\n  })\n\n  it('should throw an error', async () => {\n    const mError = new Error('Unable to retrieve rows')\n    client.query.mockRejectedValueOnce(mError)\n\n    await getTodos()\n\n    expect(client.connect).toBeCalledTimes(1)\n    expect(client.query).toBeCalledWith('SELECT * FROM todos;')\n    expect(client.end).toBeCalledTimes(1)\n    expect(failure).toBeCalledWith({ message: mError, status: false })\n  })\n})\nRequests\n​\n\nBecause Vitest runs in Node, mocking network requests is tricky; web APIs are not available, so we need something that will mimic network behavior for us. We recommend Mock Service Worker to accomplish this. It will let you mock both REST and GraphQL network requests, and is framework agnostic.\n\nMock Service Worker (MSW) works by intercepting the requests your tests make, allowing you to use it without changing any of your application code. In-browser, this uses the Service Worker API. In Node.js, and for Vitest, it uses node-request-interceptor. To learn more about MSW, read their introduction\n\nConfiguration\n​\n\nYou can use it like below in your setup file\n\njs\nimport { afterAll, afterEach, beforeAll } from 'vitest'\nimport { setupServer } from 'msw/node'\nimport { HttpResponse, graphql, http } from 'msw'\n\nconst posts = [\n  {\n    userId: 1,\n    id: 1,\n    title: 'first post title',\n    body: 'first post body',\n  },\n  // ...\n]\n\nexport const restHandlers = [\n  http.get('https://rest-endpoint.example/path/to/posts', () => {\n    return HttpResponse.json(posts)\n  }),\n]\n\nconst graphqlHandlers = [\n  graphql.query('https://graphql-endpoint.example/api/v1/posts', () => {\n    return HttpResponse.json(\n      {\n        data: { posts },\n      },\n    )\n  }),\n]\n\nconst server = setupServer(...restHandlers, ...graphqlHandlers)\n\n// Start server before all tests\nbeforeAll(() => server.listen({ onUnhandledRequest: 'error' }))\n\n//  Close server after all tests\nafterAll(() => server.close())\n\n// Reset handlers after each test `important for test isolation`\nafterEach(() => server.resetHandlers())\n\nConfiguring the server with onUnhandleRequest: 'error' ensures that an error is thrown whenever there is a request that does not have a corresponding request handler.\n\nExample\n​\n\nWe have a full working example which uses MSW: React Testing with MSW.\n\nMore\n​\n\nThere is much more to MSW. You can access cookies and query parameters, define mock error responses, and much more! To see all you can do with MSW, read their documentation.\n\nTimers\n​\n\nWhen we test code that involves timeouts or intervals, instead of having our tests wait it out or timeout, we can speed up our tests by using \"fake\" timers that mock calls to setTimeout and setInterval.\n\nSee the vi.useFakeTimers API section for a more in depth detailed API description.\n\nExample\n​\njs\nimport { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'\n\nfunction executeAfterTwoHours(func) {\n  setTimeout(func, 1000 * 60 * 60 * 2) // 2 hours\n}\n\nfunction executeEveryMinute(func) {\n  setInterval(func, 1000 * 60) // 1 minute\n}\n\nconst mock = vi.fn(() => console.log('executed'))\n\ndescribe('delayed execution', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  afterEach(() => {\n    vi.restoreAllMocks()\n  })\n  it('should execute the function', () => {\n    executeAfterTwoHours(mock)\n    vi.runAllTimers()\n    expect(mock).toHaveBeenCalledTimes(1)\n  })\n  it('should not execute the function', () => {\n    executeAfterTwoHours(mock)\n    // advancing by 2ms won't trigger the func\n    vi.advanceTimersByTime(2)\n    expect(mock).not.toHaveBeenCalled()\n  })\n  it('should execute every minute', () => {\n    executeEveryMinute(mock)\n    vi.advanceTimersToNextTimer()\n    expect(mock).toHaveBeenCalledTimes(1)\n    vi.advanceTimersToNextTimer()\n    expect(mock).toHaveBeenCalledTimes(2)\n  })\n})\nCheat Sheet\n​\n\nINFO\n\nvi in the examples below is imported directly from vitest. You can also use it globally, if you set globals to true in your config.\n\nI want to…\n\nSpy on a method\nts\nconst instance = new SomeClass()\nvi.spyOn(instance, 'method')\nMock exported variables\njs\n// some-path.js\nexport const getter = 'variable'\nts\n// some-path.test.ts\nimport * as exports from './some-path.js'\n\nvi.spyOn(exports, 'getter', 'get').mockReturnValue('mocked')\nMock exported function\n\nExample with vi.mock:\n\nts\n// ./some-path.js\nexport function method() {}\nts\nimport { method } from './some-path.js'\n\nvi.mock('./some-path.js', () => ({\n  method: vi.fn()\n}))\n\nWARNING\n\nDon't forget that vi.mock call is hoisted to top of the file. Do not put vi.mock calls inside beforeEach, only one of these will actually mock a module.\n\nExample with vi.spyOn:\n\nts\nimport * as exports from './some-path.js'\n\nvi.spyOn(exports, 'method').mockImplementation(() => {})\nMock exported class implementation\n\nExample with vi.mock and prototype:\n\nts\n// some-path.ts\nexport class SomeClass {}\nts\nimport { SomeClass } from './some-path.js'\n\nvi.mock('./some-path.js', () => {\n  const SomeClass = vi.fn()\n  SomeClass.prototype.someMethod = vi.fn()\n  return { SomeClass }\n})\n// SomeClass.mock.instances will have SomeClass\n\nExample with vi.mock and return value:\n\nts\nimport { SomeClass } from './some-path.js'\n\nvi.mock('./some-path.js', () => {\n  const SomeClass = vi.fn(() => ({\n    someMethod: vi.fn()\n  }))\n  return { SomeClass }\n})\n// SomeClass.mock.returns will have returned object\n\nExample with vi.spyOn:\n\nts\nimport * as exports from './some-path.js'\n\nvi.spyOn(exports, 'SomeClass').mockImplementation(() => {\n  // whatever suites you from first two examples\n})\nSpy on an object returned from a function\n\nExample using cache:\n\nts\n// some-path.ts\nexport function useObject() {\n  return { method: () => true }\n}\nts\n// useObject.js\nimport { useObject } from './some-path.js'\n\nconst obj = useObject()\nobj.method()\nts\n// useObject.test.js\nimport { useObject } from './some-path.js'\n\nvi.mock('./some-path.js', () => {\n  let _cache\n  const useObject = () => {\n    if (!_cache) {\n      _cache = {\n        method: vi.fn(),\n      }\n    }\n    // now every time that useObject() is called it will\n    // return the same object reference\n    return _cache\n  }\n  return { useObject }\n})\n\nconst obj = useObject()\n// obj.method was called inside some-path\nexpect(obj.method).toHaveBeenCalled()\nMock part of a module\nts\nimport { mocked, original } from './some-path.js'\n\nvi.mock('./some-path.js', async () => {\n  const mod = await vi.importActual<typeof import('./some-path.js')>('./some-path.js')\n  return {\n    ...mod,\n    mocked: vi.fn()\n  }\n})\noriginal() // has original behaviour\nmocked() // is a spy function\nMock current date\n\nTo mock Date's time, you can use vi.setSystemTime helper function. This value will not automatically reset between different tests.\n\nBeware that using vi.useFakeTimers also changes the Date's time.\n\nts\nconst mockDate = new Date(2022, 0, 1)\nvi.setSystemTime(mockDate)\nconst now = new Date()\nexpect(now.valueOf()).toBe(mockDate.valueOf())\n// reset mocked time\nvi.useRealTimers()\nMock global variable\n\nYou can set global variable by assigning a value to globalThis or using vi.stubGlobal helper. When using vi.stubGlobal, it will not automatically reset between different tests, unless you enable unstubGlobals config option or call vi.unstubAllGlobals.\n\nts\nvi.stubGlobal('__VERSION__', '1.0.0')\nexpect(__VERSION__).toBe('1.0.0')\nMock import.meta.env\n\nTo change environmental variable, you can just assign a new value to it. This value will not automatically reset between different tests.\n\nts\nimport { beforeEach, expect, it } from 'vitest'\n\n// you can reset it in beforeEach hook manually\nconst originalViteEnv = import.meta.env.VITE_ENV\n\nbeforeEach(() => {\n  import.meta.env.VITE_ENV = originalViteEnv\n})\n\nit('changes value', () => {\n  import.meta.env.VITE_ENV = 'staging'\n  expect(import.meta.env.VITE_ENV).toBe('staging')\n})\n\nIf you want to automatically reset value, you can use vi.stubEnv helper with unstubEnvs config option enabled (or call vi.unstubAllEnvs manually in beforeEach hook):\n\nts\nimport { expect, it, vi } from 'vitest'\n\n// before running tests \"VITE_ENV\" is \"test\"\nimport.meta.env.VITE_ENV === 'test'\n\nit('changes value', () => {\n  vi.stubEnv('VITE_ENV', 'staging')\n  expect(import.meta.env.VITE_ENV).toBe('staging')\n})\n\nit('the value is restored before running an other test', () => {\n  expect(import.meta.env.VITE_ENV).toBe('test')\n})\nts\n// vitest.config.ts\nexport default {\n  test: {\n    unstubAllEnvs: true,\n  }\n}"
  },
  {
    "title": "Snapshot | Guide | Vitest",
    "url": "https://vitest.dev/guide/snapshot",
    "html": "Snapshot\n​\nLearn Snapshot by video from Vue School\n\nSnapshot tests are a very useful tool whenever you want to make sure the output of your functions does not change unexpectedly.\n\nWhen using snapshot, Vitest will take a snapshot of the given value, then compares it to a reference snapshot file stored alongside the test. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new version of the result.\n\nUse Snapshots\n​\n\nTo snapshot a value, you can use the toMatchSnapshot() from expect() API:\n\nts\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchSnapshot()\n})\n\nThe first time this test is run, Vitest creates a snapshot file that looks like this:\n\njs\n// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html\n\nexports['toUpperCase 1'] = '\"FOOBAR\"'\n\nThe snapshot artifact should be committed alongside code changes, and reviewed as part of your code review process. On subsequent test runs, Vitest will compare the rendered output with the previous snapshot. If they match, the test will pass. If they don't match, either the test runner found a bug in your code that should be fixed, or the implementation has changed and the snapshot needs to be updated.\n\nWARNING\n\nWhen using Snapshots with async concurrent tests, expect from the local Test Context must be used to ensure the right test is detected.\n\nInline Snapshots\n​\n\nSimilarly, you can use the toMatchInlineSnapshot() to store the snapshot inline within the test file.\n\nts\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchInlineSnapshot()\n})\n\nInstead of creating a snapshot file, Vitest will modify the test file directly to update the snapshot as a string:\n\nts\nimport { expect, it } from 'vitest'\n\nit('toUpperCase', () => {\n  const result = toUpperCase('foobar')\n  expect(result).toMatchInlineSnapshot('\"FOOBAR\"')\n})\n\nThis allows you to see the expected output directly without jumping across different files.\n\nWARNING\n\nWhen using Snapshots with async concurrent tests, expect from the local Test Context must be used to ensure the right test is detected.\n\nUpdating Snapshots\n​\n\nWhen the received value doesn't match the snapshot, the test fails and shows you the difference between them. When the snapshot change is expected, you may want to update the snapshot from the current state.\n\nIn watch mode, you can press the u key in the terminal to update the failed snapshot directly.\n\nOr you can use the --update or -u flag in the CLI to make Vitest update snapshots.\n\nbash\nvitest -u\nFile Snapshots\n​\n\nWhen calling toMatchSnapshot(), we store all snapshots in a formatted snap file. That means we need to escape some characters (namely the double-quote \" and backtick ```) in the snapshot string. Meanwhile, you might lose the syntax highlighting for the snapshot content (if they are in some language).\n\nTo improve this case, we introduce toMatchFileSnapshot() to explicitly snapshot in a file. This allows you to assign any file extension to the snapshot file, and making them more readable.\n\nts\nimport { expect, it } from 'vitest'\n\nit('render basic', async () => {\n  const result = renderHTML(h('div', { class: 'foo' }))\n  await expect(result).toMatchFileSnapshot('./test/basic.output.html')\n})\n\nIt will compare with the content of ./test/basic.output.html. And can be written back with the --update flag.\n\nImage Snapshots\n​\n\nIt's also possible to snapshot images using jest-image-snapshot.\n\nbash\nnpm i -D jest-image-snapshot\nts\ntest('image snapshot', () => {\n  expect(readFileSync('./test/stubs/input-image.png'))\n    .toMatchImageSnapshot()\n})\n\nYou can learn more in the examples/image-snapshot example.\n\nCustom Serializer\n​\n\nYou can add your own logic to alter how your snapshots are serialized. Like Jest, Vitest has default serializers for built-in JavaScript types, HTML elements, ImmutableJS and for React elements.\n\nExample serializer module:\n\nts\nexpect.addSnapshotSerializer({\n  serialize(val, config, indentation, depth, refs, printer) {\n    // `printer` is a function that serializes a value using existing plugins.\n    return `Pretty foo: ${printer(val.foo)}`\n  },\n  test(val) {\n    return val && Object.prototype.hasOwnProperty.call(val, 'foo')\n  },\n})\n\nAfter adding a test like this:\n\nts\ntest('foo snapshot test', () => {\n  const bar = {\n    foo: {\n      x: 1,\n      y: 2,\n    },\n  }\n\n  expect(bar).toMatchSnapshot()\n})\n\nYou will get the following snapshot:\n\nPretty foo: Object {\n  \"x\": 1,\n  \"y\": 2,\n}\n\nWe are using Jest's pretty-format for serializing snapshots. You can read more about it here: pretty-format.\n\nDifference from Jest\n​\n\nVitest provides an almost compatible Snapshot feature with Jest's with a few exceptions:\n\n1. Comment header in the snapshot file is different\n​\ndiff\n- // Jest Snapshot v1, https://goo.gl/fbAQLP\n+ // Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html\n\nThis does not really affect the functionality but might affect your commit diff when migrating from Jest.\n\n2. printBasicPrototype is default to false\n​\n\nBoth Jest and Vitest's snapshots are powered by pretty-format. In Vitest we set printBasicPrototype default to false to provide a cleaner snapshot output, while in Jest <29.0.0 it's true by default.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('snapshot', () => {\n  const bar = [\n    {\n      foo: 'bar',\n    },\n  ]\n\n  // in Jest\n  expect(bar).toMatchInlineSnapshot(`\n    Array [\n      Object {\n        \"foo\": \"bar\",\n      },\n    ]\n  `)\n\n  // in Vitest\n  expect(bar).toMatchInlineSnapshot(`\n    [\n      {\n        \"foo\": \"bar\",\n      },\n    ]\n  `)\n})\n\nWe believe this is a more reasonable default for readability and overall DX. If you still prefer Jest's behavior, you can change your config:\n\nts\n// vitest.config.js\nexport default defineConfig({\n  test: {\n    snapshotFormat: {\n      printBasicPrototype: true\n    }\n  }\n})\n3. Chevron > is used as a separator instead of colon : for custom messages\n​\n\nVitest uses chevron > as a separator instead of colon : for readability, when a custom message is passed during creation of a snapshot file.\n\nFor the following example test code:\n\njs\ntest('toThrowErrorMatchingSnapshot', () => {\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingSnapshot('hint')\n})\n\nIn Jest, the snapshot will be:\n\nconsole\nexports[`toThrowErrorMatchingSnapshot: hint 1`] = `\"error\"`;\n\nIn Vitest, the equivalent snapshot will be:\n\nconsole\nexports[`toThrowErrorMatchingSnapshot > hint 1`] = `[Error: error]`;\n4. default Error snapshot is different for toThrowErrorMatchingSnapshot and toThrowErrorMatchingInlineSnapshot\n​\njs\ntest('snapshot', () => {\n  //\n  // in Jest\n  //\n\n  expect(new Error('error')).toMatchInlineSnapshot(`[Error: error]`)\n\n  // Jest snapshots `Error.message` for `Error` instance\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingInlineSnapshot(`\"error\"`)\n\n  //\n  // in Vitest\n  //\n\n  expect(new Error('error')).toMatchInlineSnapshot(`[Error: error]`)\n\n  expect(() => {\n    throw new Error('error')\n  }).toThrowErrorMatchingInlineSnapshot(`[Error: error]`)\n})"
  },
  {
    "title": "Coverage | Guide | Vitest",
    "url": "https://vitest.dev/guide/coverage",
    "html": "Coverage\n​\n\nVitest supports Native code coverage via v8 and instrumented code coverage via istanbul.\n\nCoverage Providers\n​\n\nTIP\n\nSince Vitest v0.22.0\n\nBoth v8 and istanbul support are optional. By default, v8 will be used.\n\nYou can select the coverage tool by setting test.coverage.provider to v8 or istanbul:\n\nts\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'istanbul' // or 'v8'\n    },\n  },\n})\n\nWhen you start the Vitest process, it will prompt you to install the corresponding support package automatically.\n\nOr if you prefer to install them manually:\n\nbash\n# For v8\nnpm i -D @vitest/coverage-v8\n\n# For istanbul\nnpm i -D @vitest/coverage-istanbul\nCoverage Setup\n​\n\nTo test with coverage enabled, you can pass the --coverage flag in CLI. By default, reporter ['text', 'html', 'clover', 'json'] will be used.\n\njson\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n\nTo configure it, set test.coverage options in your config file:\n\nts\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reporter: ['text', 'json', 'html'],\n    },\n  },\n})\nCustom Coverage Provider\n​\n\nIt's also possible to provide your custom coverage provider by passing 'custom' in test.coverage.provider:\n\nts\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      provider: 'custom',\n      customProviderModule: 'my-custom-coverage-provider'\n    },\n  },\n})\n\nThe custom providers require a customProviderModule option which is a module name or path where to load the CoverageProviderModule from. It must export an object that implements CoverageProviderModule as default export:\n\nts\n// my-custom-coverage-provider.ts\nimport type { CoverageProvider, CoverageProviderModule, ResolvedCoverageOptions, Vitest } from 'vitest'\n\nconst CustomCoverageProviderModule: CoverageProviderModule = {\n  getProvider(): CoverageProvider {\n    return new CustomCoverageProvider()\n  },\n\n  // Implements rest of the CoverageProviderModule ...\n}\n\nclass CustomCoverageProvider implements CoverageProvider {\n  name = 'custom-coverage-provider'\n  options!: ResolvedCoverageOptions\n\n  initialize(ctx: Vitest) {\n    this.options = ctx.config.coverage\n  }\n\n  // Implements rest of the CoverageProvider ...\n}\n\nexport default CustomCoverageProviderModule\n\nPlease refer to the type definition for more details.\n\nChanging the Default Coverage Folder Location\n​\n\nWhen running a coverage report, a coverage folder is created in the root directory of your project. If you want to move it to a different directory, use the test.coverage.reportsDirectory property in the vite.config.js file.\n\njs\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    coverage: {\n      reportsDirectory: './tests/unit/coverage'\n    }\n  }\n})\nIgnoring Code\n​\n\nBoth coverage providers have their own ways how to ignore code from coverage reports:\n\nv8\nìstanbul\n\nWhen using TypeScript the source codes are transpiled using esbuild, which strips all comments from the source codes (esbuild#516). Comments which are considered as legal comments are preserved.\n\nFor istanbul provider you can include a @preserve keyword in the ignore hint. Beware that these ignore hints may now be included in final production build as well.\n\ndiff\n-/* istanbul ignore if */\n+/* istanbul ignore if -- @preserve */\nif (condition) {\n\nFor v8 this does not cause any issues. You can use v8 ignore comments with Typescript as usual:\n\nts\n/* v8 ignore next 3 */\nif (condition) {\nOther Options\n​\n\nTo see all configurable options for coverage, see the coverage Config Reference.\n\nVitest UI\n​\n\nSince Vitest 0.31.0, you can check your coverage report in Vitest UI.\n\nVitest UI will enable coverage report when it is enabled explicitly and the html coverage reporter is present, otherwise it will not be available:\n\nenable coverage.enabled=true in your configuration or run Vitest with --coverage.enabled=true flag\nadd html to the coverage.reporter list: you can also enable subdir option to put coverage report in a subdirectory"
  },
  {
    "title": "Reporters | Guide | Vitest",
    "url": "https://vitest.dev/guide/reporters",
    "html": "Reporters\n​\n\nVitest provides several built-in reporters to display test output in different formats, as well as the ability to use custom reporters. You can select different reporters either by using the --reporter command line option, or by including a reporters property in your configuration file. If no reporter is specified, Vitest will use the default reporter as described below.\n\nUsing reporters via command line:\n\nbash\nnpx vitest --reporter=verbose\n\nUsing reporters via vitest.config.ts:\n\nts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    reporters: ['verbose']\n  },\n})\nReporter Output\n​\n\nBy default, Vitest's reporters will print their output to the terminal. When using the json, html or junit reporters, you can instead write your tests' output to a file by including an outputFile configuration option either in your Vite configuration file or via CLI.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=json --outputFile=./test-output.json\nCombining Reporters\n​\n\nYou can use multiple reporters simultaneously to print your test results in different formats. For example:\n\nbash\nnpx vitest --reporter=json --reporter=default\nts\nexport default defineConfig({\n  test: {\n    reporters: ['json', 'default'],\n    outputFile: './test-output.json'\n  },\n})\n\nThe above example will both print the test results to the terminal in the default style and write them as JSON to the designated output file.\n\nWhen using multiple reporters, it's also possible to designate multiple output files, as follows:\n\nts\nexport default defineConfig({\n  reporters: ['junit', 'json', 'verbose'],\n  outputFile: {\n    junit: './junit-report.xml',\n    json: './json-report.json',\n  },\n})\n\nThis example will write separate JSON and XML reports as well as printing a verbose report to the terminal.\n\nBuilt-in Reporters\n​\nDefault Reporter\n​\n\nBy default (i.e. if no reporter is specified), Vitest will display results for each test suite hierarchically as they run, and then collapse after a suite passes. When all tests have finished running, the final terminal output will display a summary of results and details of any failed tests.\n\nExample output for tests in progress:\n\nbash\n✓ __tests__/file1.test.ts (2) 725ms\n✓ __tests__/file2.test.ts (5) 746ms\n  ✓ second test file (2) 746ms\n    ✓ 1 + 1 should equal 2\n    ✓ 2 - 1 should equal 1\n\nFinal output after tests have finished:\n\nbash\n✓ __tests__/file1.test.ts (2) 725ms\n✓ __tests__/file2.test.ts (2) 746ms\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\nBasic Reporter\n​\n\nThe basic reporter displays the test files that have run and a summary of results after the entire suite has finished running. Individual tests are not included in the report unless they fail.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=basic\n\nExample output using basic reporter:\n\nbash\n✓ __tests__/file1.test.ts (2) 725ms\n✓ __tests__/file2.test.ts (2) 746ms\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\nVerbose Reporter\n​\n\nFollows the same hierarchical structure as the default reporter, but does not collapse sub-trees for passed test suites. The final terminal output displays all tests that have run, including those that have passed.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=verbose\n\nExample of final terminal output for a passing test suite:\n\nbash\n✓ __tests__/file1.test.ts (2) 725ms\n   ✓ first test file (2) 725ms\n     ✓ 2 + 2 should equal 4\n     ✓ 4 - 2 should equal 2\n✓ __tests__/file2.test.ts (2) 746ms\n  ✓ second test file (2) 746ms\n    ✓ 1 + 1 should equal 2\n    ✓ 2 - 1 should equal 1\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\nDot Reporter\n​\n\nPrints a single dot for each completed test to provide minimal output while still showing all tests that have run. Details are only provided for failed tests, along with the basic reporter summary for the suite.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=dot\n\nExample terminal output for a passing test suite:\n\nbash\n....\n\n Test Files  2 passed (2)\n      Tests  4 passed (4)\n   Start at  12:34:32\n   Duration  1.26s (transform 35ms, setup 1ms, collect 90ms, tests 1.47s, environment 0ms, prepare 267ms)\nJUnit Reporter\n​\n\nOutputs a report of the test results in JUnit XML format. Can either be printed to the terminal or written to an XML file using the outputFile configuration option.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=junit\n\nExample of a JUnit XML report:\n\nxml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<testsuites name=\"vitest tests\" tests=\"2\" failures=\"1\" errors=\"0\" time=\"0.503\">\n    <testsuite name=\"__tests__/test-file-1.test.ts\" timestamp=\"2023-10-19T17:41:58.580Z\" hostname=\"My-Computer.local\" tests=\"2\" failures=\"1\" errors=\"0\" skipped=\"0\" time=\"0.013\">\n        <testcase classname=\"__tests__/test-file-1.test.ts\" name=\"first test file &gt; 2 + 2 should equal 4\" time=\"0.01\">\n            <failure message=\"expected 5 to be 4 // Object.is equality\" type=\"AssertionError\">\nAssertionError: expected 5 to be 4 // Object.is equality\n ❯ __tests__/test-file-1.test.ts:20:28\n            </failure>\n        </testcase>\n        <testcase classname=\"__tests__/test-file-1.test.ts\" name=\"first test file &gt; 4 - 2 should equal 2\" time=\"0\">\n        </testcase>\n    </testsuite>\n</testsuites>\n\nThe outputted XML contains nested testsuites and testcase tags. You can use the environment variables VITEST_JUNIT_SUITE_NAME and VITEST_JUNIT_CLASSNAME to configure their name and classname attributes, respectively.\n\nJSON Reporter\n​\n\nOutputs a report of the test results in JSON format. Can either be printed to the terminal or written to a file using the outputFile configuration option.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=json\n\nExample of a JSON report:\n\njson\n{\n  \"numTotalTestSuites\": 1,\n  \"numPassedTestSuites\": 0,\n  \"numFailedTestSuites\": 1,\n  \"numPendingTestSuites\": 0,\n  \"numTotalTests\": 1,\n  \"numPassedTests\": 0,\n  \"numFailedTests\": 1,\n  \"numPendingTests\": 0,\n  \"numTodoTests\": 0,\n  \"startTime\": 1697737019307,\n  \"success\": false,\n  \"testResults\": [\n    {\n      \"assertionResults\": [\n        {\n          \"ancestorTitles\": [\n            \"\",\n            \"first test file\"\n          ],\n          \"fullName\": \" first test file 2 + 2 should equal 4\",\n          \"status\": \"failed\",\n          \"title\": \"2 + 2 should equal 4\",\n          \"duration\": 9,\n          \"failureMessages\": [\n            \"expected 5 to be 4 // Object.is equality\"\n          ],\n          \"location\": {\n            \"line\": 20,\n            \"column\": 28\n          }\n        }\n      ],\n      \"startTime\": 1697737019787,\n      \"endTime\": 1697737019797,\n      \"status\": \"failed\",\n      \"message\": \"\",\n      \"name\": \"/root-directory/__tests__/test-file-1.test.ts\"\n    }\n  ]\n}\nHTML Reporter\n​\n\nGenerates an HTML file to view test results through an interactive GUI. After the file has been generated, Vitest will keep a local development server running and provide a link to view the report in a browser.\n\nOutput file can be specified using the outputFile configuration option. If no outputFile option is provided, a new HTML file will be created.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=html\n\nTIP\n\nThis reporter requires installed @vitest/ui package.\n\nTAP Reporter\n​\n\nOutputs a report following Test Anything Protocol (TAP).\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=tap\n\nExample of a TAP report:\n\nbash\nTAP version 13\n1..1\nnot ok 1 - __tests__/test-file-1.test.ts # time=14.00ms {\n    1..1\n    not ok 1 - first test file # time=13.00ms {\n        1..2\n        not ok 1 - 2 + 2 should equal 4 # time=11.00ms\n            ---\n            error:\n                name: \"AssertionError\"\n                message: \"expected 5 to be 4 // Object.is equality\"\n            at: \"/root-directory/__tests__/test-file-1.test.ts:20:28\"\n            actual: \"5\"\n            expected: \"4\"\n            ...\n        ok 2 - 4 - 2 should equal 2 # time=1.00ms\n    }\n}\nTAP Flat Reporter\n​\n\nOutputs a TAP flat report. Like the tap reporter, test results are formatted to follow TAP standards, but test suites are formatted as a flat list rather than a nested hierarchy.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=tap-flat\n\nExample of a TAP flat report:\n\nbash\nTAP version 13\n1..2\nnot ok 1 - __tests__/test-file-1.test.ts > first test file > 2 + 2 should equal 4 # time=11.00ms\n    ---\n    error:\n        name: \"AssertionError\"\n        message: \"expected 5 to be 4 // Object.is equality\"\n    at: \"/root-directory/__tests__/test-file-1.test.ts:20:28\"\n    actual: \"5\"\n    expected: \"4\"\n    ...\nok 2 - __tests__/test-file-1.test.ts > first test file > 4 - 2 should equal 2 # time=0.00ms\nHanging Process Reporter\n​\n\nDisplays a list of hanging processes, if any are preventing Vitest from exiting safely. The hanging-process reporter does not itself display test results, but can be used in conjunction with another reporter to monitor processes while tests run. Using this reporter can be resource-intensive, so should generally be reserved for debugging purposes in situations where Vitest consistently cannot exit the process.\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=hanging-process\nCustom Reporters\n​\n\nYou can use third-party custom reporters installed from NPM by specifying their package name in the reporters' option:\n\nCLI\nvitest.config.ts\nbash\nnpx vitest --reporter=some-published-vitest-reporter\n\nAdditionally, you can define your own custom reporters and use them by specifying their file path:\n\nbash\nnpx vitest --reporter=./path/to/reporter.ts\n\nCustom reporters should implement the Reporter interface."
  },
  {
    "title": "Test Filtering | Guide | Vitest",
    "url": "https://vitest.dev/guide/filtering",
    "html": "Test Filtering\n​\n\nFiltering, timeouts, concurrent for suite and tests\n\nCLI\n​\n\nYou can use CLI to filter test files by name:\n\nbash\n$ vitest basic\n\nWill only execute test files that contain basic, e.g.\n\nbasic.test.ts\nbasic-foo.test.ts\nbasic/foo.test.ts\n\nYou can also use the -t, --testNamePattern <pattern> option to filter tests by full name. This can be helpful when you want to filter by the name defined within a file rather than the filename itself.\n\nSpecifying a Timeout\n​\n\nYou can optionally pass a timeout in milliseconds as third argument to tests. The default is 5 seconds.\n\nts\nimport { test } from 'vitest'\n\ntest('name', async () => { /* ... */ }, 1000)\n\nHooks also can receive a timeout, with the same 5 seconds default.\n\nts\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => { /* ... */ }, 1000)\nSkipping Suites and Tests\n​\n\nUse .skip to avoid running certain suites or tests\n\nts\nimport { assert, describe, it } from 'vitest'\n\ndescribe.skip('skipped suite', () => {\n  it('test', () => {\n    // Suite skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\ndescribe('suite', () => {\n  it.skip('skipped test', () => {\n    // Test skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\nSelecting Suites and Tests to Run\n​\n\nUse .only to only run certain suites or tests\n\nts\nimport { assert, describe, it } from 'vitest'\n\n// Only this suite (and others marked with only) are run\ndescribe.only('suite', () => {\n  it('test', () => {\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\ndescribe('another suite', () => {\n  it('skipped test', () => {\n    // Test skipped, as tests are running in Only mode\n    assert.equal(Math.sqrt(4), 3)\n  })\n\n  it.only('test', () => {\n    // Only this test (and others marked with only) are run\n    assert.equal(Math.sqrt(4), 2)\n  })\n})\nUnimplemented Suites and Tests\n​\n\nUse .todo to stub suites and tests that should be implemented\n\nts\nimport { describe, it } from 'vitest'\n\n// An entry will be shown in the report for this suite\ndescribe.todo('unimplemented suite')\n\n// An entry will be shown in the report for this test\ndescribe('suite', () => {\n  it.todo('unimplemented test')\n})"
  },
  {
    "title": "Workspace | Guide | Vitest",
    "url": "https://vitest.dev/guide/workspace",
    "html": "Workspace\n​\n\nVitest provides built-in support for monorepos through a workspace configuration file. You can create a workspace to define your project's setups.\n\nDefining a Workspace\n​\n\nA workspace should have a vitest.workspace or vitest.projects file in its root (in the same folder as your config file if you have one). Vitest supports ts/js/json extensions for this file.\n\nWorkspace configuration file should have a default export with a list of files or glob patterns referencing your projects. For example, if you have a folder with your projects named packages, you can define a workspace with this config file:\n\nvitest.workspace.ts\nts\nexport default [\n  'packages/*'\n]\n\nVitest will consider every folder in packages as a separate project even if it doesn't have a config file inside.\n\nWARNING\n\nVitest will not consider the root config as a workspace project (so it will not run tests specified in include) unless it is specified in this config.\n\nYou can also reference projects with their config files:\n\nvitest.workspace.ts\nts\nexport default [\n  'packages/*/vitest.config.{e2e,unit}.ts'\n]\n\nThis pattern will only include projects with vitest.config file that includes e2e and unit before the extension.\n\nWARNING\n\nIf you are referencing filenames with glob pattern, make sure your config file starts with vite.config or vitest.config. Otherwise Vitest will skip it.\n\nYou can also define projects with inline config. Workspace file supports using both syntaxes at the same time.\n\nvitest.workspace.ts\nts\nimport { defineWorkspace } from 'vitest/config'\n\n// defineWorkspace provides a nice type hinting DX\nexport default defineWorkspace([\n  'packages/*',\n  {\n    // add \"extends\" to merge two configs together\n    extends: './vite.config.js',\n    test: {\n      include: ['tests/**/*.{browser}.test.{ts,js}'],\n      // it is recommended to define a name when using inline configs\n      name: 'happy-dom',\n      environment: 'happy-dom',\n    }\n  },\n  {\n    test: {\n      include: ['tests/**/*.{node}.test.{ts,js}'],\n      name: 'node',\n      environment: 'node',\n    }\n  }\n])\n\nWARNING\n\nAll projects should have unique names. Otherwise, Vitest will throw an error. If you do not provide a name inside the inline config, Vitest will assign a number. If you don't provide a name inside a project config defined with glob syntax, Vitest will use the directory name by default.\n\nIf you don't rely on inline configs, you can just create a small json file in your root directory:\n\nvitest.workspace.json\njson\n[\n  \"packages/*\"\n]\n\nWorkspace projects don't support all configuration properties. For better type safety, use defineProject instead of defineConfig method inside project configuration files:\n\npackages/a/vitest.config.ts\nts\nimport { defineProject } from 'vitest/config'\n\nexport default defineProject({\n  test: {\n    environment: 'jsdom',\n    // \"reporters\" is not supported in a project config,\n    // so it will show an error\n    reporters: ['json']\n  }\n})\nRunning tests\n​\n\nTo run tests inside the workspace, define a script in your root package.json:\n\njson\n{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n\nNow tests can be run using your package manager:\n\nnpm\nyarn\npnpm\nbun\nbash\nnpm run test\n\nIf you need to run tests only inside a single project, use the --project CLI option:\n\nbash\nnpm run test --project e2e\n\nTIP\n\nCLI option --project can be used multiple times to filter out several projects:\n\nbash\nnpm run test --project e2e --project unit\nConfiguration\n​\n\nNone of the configuration options are inherited from the root-level config file. You can create a shared config file and merge it with the project config yourself:\n\npackages/a/vitest.config.ts\nts\nimport { defineProject, mergeConfig } from 'vitest/config'\nimport configShared from '../vitest.shared.js'\n\nexport default mergeConfig(\n  configShared,\n  defineProject({\n    test: {\n      environment: 'jsdom',\n    }\n  })\n)\n\nAlso, some of the configuration options are not allowed in a project config. Most notably:\n\ncoverage: coverage is done for the whole workspace\nreporters: only root-level reporters can be supported\nresolveSnapshotPath: only root-level resolver is respected\nall other options that don't affect test runners\n\nTIP\n\nAll configuration options that are not supported inside a project config have * sign next them in \"Config\" page.\n\nCoverage\n​\n\nCoverage for workspace projects works out of the box. But if you have all option enabled and use non-conventional extensions in some of your projects, you will need to have a plugin that handles this extension in your root configuration file.\n\nFor example, if you have a package that uses Vue files and it has its own config file, but some of the files are not imported in your tests, coverage will fail trying to analyze the usage of unused files, because it relies on the root configuration rather than project configuration."
  },
  {
    "title": "Command Line Interface | Guide | Vitest",
    "url": "https://vitest.dev/guide/cli",
    "html": "Command Line Interface\n​\nCommands\n​\nvitest\n​\n\nStart Vitest in the current directory. Will enter the watch mode in development environment and run mode in CI automatically.\n\nYou can pass an additional argument as the filter of the test files to run. For example:\n\nbash\nvitest foobar\n\nWill run only the test file that contains foobar in their paths. This filter only checks inclusion and doesn't support regexp or glob patterns (unless your terminal processes it before Vitest receives the filter).\n\nvitest run\n​\n\nPerform a single run without watch mode.\n\nvitest watch\n​\n\nRun all test suites but watch for changes and rerun tests when they change. Same as calling vitest without an argument. Will fallback to vitest run in CI.\n\nvitest dev\n​\n\nAlias to vitest watch.\n\nvitest related\n​\n\nRun only tests that cover a list of source files. Works with static imports (e.g., import('./index.js') or import index from './index.js), but not the dynamic ones (e.g., import(filepath)). All files should be relative to root folder.\n\nUseful to run with lint-staged or with your CI setup.\n\nbash\nvitest related /src/index.ts /src/hello-world.js\n\nTIP\n\nDon't forget that Vitest runs with enabled watch mode by default. If you are using tools like lint-staged, you should also pass --run option, so that command can exit normally.\n\njs\n// .lintstagedrc.js\nexport default {\n  '*.{js,ts}': 'vitest related --run',\n}\nvitest bench\n​\n\nRun only benchmark tests, which compare performance results.\n\nOptions\n​\nOptions\t\n-v, --version\tDisplay version number\n-r, --root <path>\tDefine the project root\n-c, --config <path>\tPath to config file\n-u, --update\tUpdate snapshots\n-w, --watch\tSmart & instant watch mode\n-t, --testNamePattern <pattern>\tRun tests with full names matching the pattern\n--dir <path>\tBase directory to scan for the test files\n--ui\tEnable UI\n--open\tOpen the UI automatically if enabled (default: true)\n--api [api]\tServe API, available options: --api.port <port>, --api.host [host] and --api.strictPort\n--pool <pool>\tSpecify pool, if not running in the browser (default: threads)\n--poolOptions <options>\tSpecify pool options\n--poolOptions.threads.isolate\tIsolate tests in threads pool (default: true)\n--poolOptions.forks.isolate\tIsolate tests in forks pool (default: true)\n--silent\tSilent console output from tests\n--reporter <name>\tSelect reporter: default, verbose, dot, junit, json, or a path to a custom reporter\n--outputFile <filename/-s>\tWrite test results to a file when the --reporter=json or --reporter=junit option is also specified\nVia cac's dot notation you can specify individual outputs for multiple reporters\n--coverage\tEnable coverage report\n--run\tDo not watch\n--mode\tOverride Vite mode (default: test)\n--mode <name>\tOverride Vite mode (default: test)\n--globals\tInject APIs globally\n--dom\tMock browser API with happy-dom\n--browser [options]\tRun tests in the browser (default: false)\n--environment <env>\tRunner environment (default: node)\n--passWithNoTests\tPass when no tests found\n--logHeapUsage\tShow the size of heap for each test\n--allowOnly\tAllow tests and suites that are marked as only (default: false in CI, true otherwise)\n--dangerouslyIgnoreUnhandledErrors\tIgnore any unhandled errors that occur\n--changed [since]\tRun tests that are affected by the changed files (default: false). See docs\n--shard <shard>\tExecute tests in a specified shard\n--sequence\tDefine in what order to run tests. Use cac's dot notation to specify options (for example, use --sequence.shuffle to run tests in random order or --sequence.shuffle --sequence.seed SEED_ID to run a specific order)\n--no-color\tRemoves colors from the console output\n--inspect\tEnables Node.js inspector\n--inspect-brk\tEnables Node.js inspector with break\n--bail <number>\tStop test execution when given number of tests have failed\n--retry <times>\tRetry the test specific number of times if it fails\n--expand-snapshot-diff\tShow full diff when snapshot fails\n--typecheck [options]\tCustom options for typecheck pool. If passed without options, enables typechecking\n--typecheck.enabled\tEnable typechecking alongside tests (default: false)\n--typecheck.only\tRun only typecheck tests. This automatically enables typecheck (default: false)\n--project\tThe name of the project to run if you are using Vitest workspace feature. This can be repeated for multiple projects: --project=1 --project=2\n-h, --help\tDisplay available CLI options\n\nTIP\n\nVitest supports both camel case and kebab case for CLI arguments. For example, --passWithNoTests and --pass-with-no-tests will both work (--no-color and --inspect-brk are the exceptions).\n\nVitest also supports different ways of specifying the value: --reporter dot and --reporter=dot are both valid.\n\nIf option supports an array of values, you need to pass the option multiple times:\n\nvitest --reporter=dot --reporter=default\n\nBoolean options can be negated with no- prefix. Specifying the value as false also works:\n\nvitest --no-api\nvitest --api=false\nchanged\n​\n\nType: boolean | string\n\nDefault: false\n\nRun tests only against changed files. If no value is provided, it will run tests against uncommitted changes (including staged and unstaged).\n\nTo run tests against changes made in the last commit, you can use --changed HEAD~1. You can also pass commit hash or branch name.\n\nIf paired with the forceRerunTriggers config option it will run the whole test suite if a match is found.\n\nshard\n​\n\nType: string\n\nDefault: disabled\n\nTest suite shard to execute in a format of <index>/<count>, where\n\ncount is a positive integer, count of divided parts\nindex is a positive integer, index of divided part\n\nThis command will divide all tests into count equal parts, and will run only those that happen to be in an index part. For example, to split your tests suite into three parts, use this:\n\nsh\nvitest run --shard=1/3\nvitest run --shard=2/3\nvitest run --shard=3/3\n\nWARNING\n\nYou cannot use this option with --watch enabled (enabled in dev by default)."
  },
  {
    "title": "Features | Guide | Vitest",
    "url": "https://vitest.dev/guide/features",
    "html": "Features\n​\nVite's config, transformers, resolvers, and plugins.\nUse the same setup from your app to run the tests!\nSmart & instant watch mode, like HMR for tests!\nComponent testing for Vue, React, Svelte, Lit, Marko and more\nOut-of-the-box TypeScript / JSX support\nESM first, top level await\nWorkers multi-threading via Tinypool\nBenchmarking support with Tinybench\nFiltering, timeouts, concurrent for suite and tests\nWorkspace support\nJest-compatible Snapshot\nChai built-in for assertions + Jest expect compatible APIs\nTinyspy built-in for mocking\nhappy-dom or jsdom for DOM mocking\nCode coverage via v8 or istanbul\nRust-like in-source testing\nType Testing via expect-type\nLearn how to write your first test by Video\nShared Config between Test, Dev and Build\n​\n\nVite's config, transformers, resolvers, and plugins. Use the same setup from your app to run the tests.\n\nLearn more at Configuring Vitest.\n\nWatch Mode\n​\nbash\n$ vitest\n\nWhen you modify your source code or the test files, Vitest smartly searches the module graph and only reruns the related tests, just like how HMR works in Vite!\n\nvitest starts in watch mode by default in development environment and run mode in CI environment (when process.env.CI presents) smartly. You can use vitest watch or vitest run to explicitly specify the desired mode.\n\nCommon Web Idioms Out-Of-The-Box\n​\n\nOut-of-the-box ES Module / TypeScript / JSX support / PostCSS\n\nThreads\n​\n\nWorkers multi-threading via Tinypool (a lightweight fork of Piscina), allowing tests to run simultaneously. Threads are enabled by default in Vitest, and can be disabled by passing --no-threads in the CLI.\n\nVitest also isolates each file's environment so env mutations in one file don't affect others. Isolation can be disabled by passing --no-isolate to the CLI (trading correctness for run performance).\n\nTest Filtering\n​\n\nVitest provided many ways to narrow down the tests to run in order to speed up testing so you can focus on development.\n\nLearn more about Test Filtering.\n\nRunning Tests Concurrently\n​\n\nUse .concurrent in consecutive tests to run them in parallel.\n\nts\nimport { describe, it } from 'vitest'\n\n// The two tests marked with concurrent will be run in parallel\ndescribe('suite', () => {\n  it('serial test', async () => { /* ... */ })\n  it.concurrent('concurrent test 1', async ({ expect }) => { /* ... */ })\n  it.concurrent('concurrent test 2', async ({ expect }) => { /* ... */ })\n})\n\nIf you use .concurrent on a suite, every test in it will be run in parallel.\n\nts\nimport { describe, it } from 'vitest'\n\n// All tests within this suite will be run in parallel\ndescribe.concurrent('suite', () => {\n  it('concurrent test 1', async ({ expect }) => { /* ... */ })\n  it('concurrent test 2', async ({ expect }) => { /* ... */ })\n  it.concurrent('concurrent test 3', async ({ expect }) => { /* ... */ })\n})\n\nYou can also use .skip, .only, and .todo with concurrent suites and tests. Read more in the API Reference.\n\nWARNING\n\nWhen running concurrent tests, Snapshots and Assertions must use expect from the local Test Context to ensure the right test is detected.\n\nSnapshot\n​\n\nJest-compatible snapshot support.\n\nts\nimport { expect, it } from 'vitest'\n\nit('renders correctly', () => {\n  const result = render()\n  expect(result).toMatchSnapshot()\n})\n\nLearn more at Snapshot.\n\nChai and Jest expect Compatibility\n​\n\nChai is built-in for assertions plus Jest expect-compatible APIs.\n\nNotice that if you are using third-party libraries that add matchers, setting test.globals to true will provide better compatibility.\n\nMocking\n​\n\nTinyspy is built-in for mocking with jest-compatible APIs on vi object.\n\nts\nimport { expect, vi } from 'vitest'\n\nconst fn = vi.fn()\n\nfn('hello', 1)\n\nexpect(vi.isMockFunction(fn)).toBe(true)\nexpect(fn.mock.calls[0]).toEqual(['hello', 1])\n\nfn.mockImplementation(arg => arg)\n\nfn('world', 2)\n\nexpect(fn.mock.results[1].value).toBe('world')\n\nVitest supports both happy-dom or jsdom for mocking DOM and browser APIs. They don't come with Vitest, you might need to install them:\n\nbash\n$ npm i -D happy-dom\n# or\n$ npm i -D jsdom\n\nAfter that, change the environment option in your config file:\n\nts\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    environment: 'happy-dom', // or 'jsdom', 'node'\n  },\n})\n\nLearn more at Mocking.\n\nCoverage\n​\n\nVitest supports Native code coverage via v8 and instrumented code coverage via istanbul.\n\njson\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n\nLearn more at Coverage.\n\nIn-Source Testing\n​\n\nVitest also provides a way to run tests within your source code along with the implementation, similar to Rust's module tests.\n\nThis makes the tests share the same closure as the implementations and able to test against private states without exporting. Meanwhile, it also brings the feedback loop closer for development.\n\nts\n// src/index.ts\n\n// the implementation\nexport function add(...args: number[]) {\n  return args.reduce((a, b) => a + b, 0)\n}\n\n// in-source test suites\nif (import.meta.vitest) {\n  const { it, expect } = import.meta.vitest\n  it('add', () => {\n    expect(add()).toBe(0)\n    expect(add(1)).toBe(1)\n    expect(add(1, 2, 3)).toBe(6)\n  })\n}\n\nLearn more at In-source testing.\n\nBenchmarking Experimental\n​\n\nSince Vitest 0.23.0, you can run benchmark tests with bench function via Tinybench to compare performance results.\n\nts\nimport { bench, describe } from 'vitest'\n\ndescribe('sort', () => {\n  bench('normal', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.sort((a, b) => {\n      return a - b\n    })\n  })\n\n  bench('reverse', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.reverse().sort((a, b) => {\n      return a - b\n    })\n  })\n})\nType Testing Experimental\n​\n\nSince Vitest 0.25.0 you can write tests to catch type regressions. Vitest comes with expect-type package to provide you with a similar and easy to understand API.\n\nts\nimport { assertType, expectTypeOf } from 'vitest'\nimport { mount } from './mount.js'\n\ntest('my types work properly', () => {\n  expectTypeOf(mount).toBeFunction()\n  expectTypeOf(mount).parameter(0).toMatchTypeOf<{ name: string }>()\n\n  // @ts-expect-error name is a string\n  assertType(mount({ name: 42 }))\n})"
  },
  {
    "title": "Why Vitest | Guide | Vitest",
    "url": "https://vitest.dev/guide/why",
    "html": "Why Vitest\n​\n\nNOTE\n\nThis guide assumes that you are familiar with Vite. A good way to start learning more is to read the Why Vite Guide, and Next generation frontend tooling with ViteJS, a stream where Evan You did a demo explaining the main concepts.\n\nThe Need for a Vite Native Test Runner\n​\n\nVite's out-of-the-box support for common web patterns, features like glob imports and SSR primitives, and its many plugins and integrations are fostering a vibrant ecosystem. Its dev and build story are key to its success. For docs, there are several SSG-based alternatives powered by Vite. Vite's Unit Testing story hasn't been clear though. Existing options like Jest were created in a different context. There is a lot of duplication between Jest and Vite, forcing users to configure two different pipelines.\n\nUsing Vite dev server to transform your files during testing, enables the creation of a simple runner that doesn't need to deal with the complexity of transforming source files and can solely focus on providing the best DX during testing. A test runner that uses the same configuration of your App (through vite.config.js), sharing a common transformation pipeline during dev, build, and test time. That is extensible with the same plugin API that lets you and the maintainers of your tools provide first-class integration with Vite. A tool that is built with Vite in mind from the start, taking advantage of its improvements in DX, like its instant Hot Module Reload (HMR). This is Vitest, a next generation testing framework powered by Vite.\n\nGiven Jest's massive adoption, Vitest provides a compatible API that allows you to use it as a drop-in replacement in most projects. It also includes the most common features required when setting up your unit tests (mocking, snapshots, coverage). Vitest cares a lot about performance and uses Worker threads to run as much as possible in parallel. Some ports have seen test running an order of magnitude faster. Watch mode is enabled by default, aligning itself with the way Vite pushes for a dev first experience. Even with all these improvements in DX, Vitest stays lightweight by carefully choosing its dependencies (or directly inlining needed pieces).\n\nVitest aims to position itself as the Test Runner of choice for Vite projects, and as a solid alternative even for projects not using Vite.\n\nContinue reading in the Getting Started Guide\n\nHow is Vitest Different from X?\n​\n\nYou can check out the Comparisons section for more details on how Vitest differs from other similar tools."
  },
  {
    "title": "Getting Started | Guide | Vitest",
    "url": "https://vitest.dev/guide/",
    "html": "Getting Started\n​\nOverview\n​\n\nVitest is a next generation testing framework powered by Vite.\n\nYou can learn more about the rationale behind the project in the Why Vitest section.\n\nTrying Vitest Online\n​\n\nYou can try Vitest online on StackBlitz. It runs Vitest directly in the browser, and it is almost identical to the local setup but doesn't require installing anything on your machine.\n\nAdding Vitest to Your Project\n​\nLearn how to install by Video\nnpm\nyarn\npnpm\nbun\nbash\nnpm install -D vitest\n\nTIP\n\nVitest 1.0 requires Vite >=v5.0.0 and Node >=v18.00\n\nIt is recommended that you install a copy of vitest in your package.json, using one of the methods listed above. However, if you would prefer to run vitest directly, you can use npx vitest (the npx command comes with npm and Node.js).\n\nThe npx command will execute the command either from a local node_modules/.bin installing any packages needed in order for the command to run. By default, npx will check whether command exists in $PATH, or in the local project binaries, and execute that. If command is not found, it will be installed prior to execution.\n\nWriting Tests\n​\n\nAs an example, we will write a simple test that verifies the output of a function that adds two numbers.\n\njs\n// sum.js\nexport function sum(a, b) {\n  return a + b\n}\njs\n// sum.test.js\nimport { expect, test } from 'vitest'\nimport { sum } from './sum'\n\ntest('adds 1 + 2 to equal 3', () => {\n  expect(sum(1, 2)).toBe(3)\n})\n\nNext, in order to execute the test, add the following section to your package.json:\n\njson\n{\n  \"scripts\": {\n    \"test\": \"vitest\"\n  }\n}\n\nFinally, run npm run test, yarn test, or pnpm test, depending on your package manager, and Vitest will print this message:\n\ntxt\n✓ sum.test.js (1)\n  ✓ adds 1 + 2 to equal 3\n\nTest Files  1 passed (1)\n    Tests  1 passed (1)\n  Start at  02:15:44\n  Duration  311ms (transform 23ms, setup 0ms, collect 16ms, tests 2ms, environment 0ms, prepare 106ms)\n\nLearn more about the usage of Vitest, see the API section.\n\nConfiguring Vitest\n​\n\nOne of the main advantages of Vitest is its unified configuration with Vite. If present, vitest will read your root vite.config.ts to match with the plugins and setup as your Vite app. For example, your Vite resolve.alias and plugins configuration will work out-of-the-box. If you want a different configuration during testing, you can:\n\nCreate vitest.config.ts, which will have the higher priority\nPass --config option to CLI, e.g. vitest --config ./path/to/vitest.config.ts\nUse process.env.VITEST or mode property on defineConfig (will be set to test if not overridden) to conditionally apply different configuration in vite.config.ts\n\nVitest supports the same extensions for your configuration file as Vite does: .js, .mjs, .cjs, .ts, .cts, .mts. Vitest does not support .json extension.\n\nIf you are not using Vite as your build tool, you can configure Vitest using the test property in your config file:\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    // ...\n  },\n})\n\nTIP\n\nEven if you do not use Vite yourself, Vitest relies heavily on it for its transformation pipeline. For that reason, you can also configure any property described in Vite documentation.\n\nIf you are already using Vite, add test property in your Vite config. You'll also need to add a reference to Vitest types using a triple slash directive at the top of your config file.\n\nts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ...\n  },\n})\n\nSee the list of config options in the Config Reference\n\nWARNING\n\nIf you decide to have two separate config files for Vite and Vitest, make sure to define the same Vite options in your Vitest config file since it will override your Vite file, not extend it. You can also use mergeConfig method from vite or vitest/config entries to merge Vite config with Vitest config:\n\nvitest.config.mjs\nvite.config.mjs\nts\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config.mjs'\n\nexport default mergeConfig(viteConfig, defineConfig({\n  test: {\n    // ...\n  }\n}))\n\nBut we recommend to use the same file for both Vite and Vitest instead of creating two separate files.\n\nWorkspaces Support\n​\n\nRun different project configurations inside the same project with Vitest Workspaces. You can define a list of files and folders that define your workspace in vitest.workspace file. The file supports js/ts/json extensions. This feature works great with monorepo setups.\n\nts\nimport { defineWorkspace } from 'vitest/config'\n\nexport default defineWorkspace([\n  // you can use a list of glob patterns to define your workspaces\n  // Vitest expects a list of config files\n  // or directories where there is a config file\n  'packages/*',\n  'tests/*/vitest.config.{e2e,unit}.ts',\n  // you can even run the same tests,\n  // but with different configs in the same \"vitest\" process\n  {\n    test: {\n      name: 'happy-dom',\n      root: './shared_tests',\n      environment: 'happy-dom',\n      setupFiles: ['./setup.happy-dom.ts'],\n    },\n  },\n  {\n    test: {\n      name: 'node',\n      root: './shared_tests',\n      environment: 'node',\n      setupFiles: ['./setup.node.ts'],\n    },\n  },\n])\nCommand Line Interface\n​\n\nIn a project where Vitest is installed, you can use the vitest binary in your npm scripts, or run it directly with npx vitest. Here are the default npm scripts in a scaffolded Vitest project:\n\njson\n{\n  \"scripts\": {\n    \"test\": \"vitest\",\n    \"coverage\": \"vitest run --coverage\"\n  }\n}\n\nTo run tests once without watching for file changes, use vitest run. You can specify additional CLI options like --port or --https. For a full list of CLI options, run npx vitest --help in your project.\n\nLearn more about the Command Line Interface\n\nIDE Integrations\n​\n\nWe also provided a official extension for Visual Studio Code to enhance your testing experience with Vitest.\n\nInstall from VS Code Marketplace\n\nLearn more about IDE Integrations\n\nExamples\n​\nExample\tSource\tPlayground\nbasic\tGitHub\tPlay Online\nfastify\tGitHub\tPlay Online\ngraphql\tGitHub\tPlay Online\nimage-snapshot\tGitHub\tPlay Online\nlit\tGitHub\tPlay Online\nmocks\tGitHub\tPlay Online\nnextjs\tGitHub\tPlay Online\nplaywright\tGitHub\t\npreact-testing-lib\tGitHub\tPlay Online\nreact-mui\tGitHub\tPlay Online\nreact-storybook\tGitHub\tPlay Online\nreact-testing-lib-msw\tGitHub\tPlay Online\nreact-testing-lib\tGitHub\tPlay Online\nreact\tGitHub\tPlay Online\nruby\tGitHub\tPlay Online\nsolid\tGitHub\tPlay Online\nsvelte\tGitHub\tPlay Online\nsveltekit\tGitHub\tPlay Online\nmarko\tGitHub\tPlay Online\nvitesse\tGitHub\tPlay Online\nvue-jsx\tGitHub\tPlay Online\nvue\tGitHub\tPlay Online\nProjects using Vitest\n​\nunocss\nunplugin-auto-import\nunplugin-vue-components\nvue\nvite\nvitesse\nvitesse-lite\nfluent-vue\nvueuse\nmilkdown\ngridjs-svelte\nspring-easing\nbytemd\nfaker\nmillion\nVitamin\nneodrag\nsvelte-multiselect\niconify\ntdesign-vue-next\ncz-git\nUsing Unreleased Commits\n​\n\nIf you can't wait for a new release to test the latest features, you will need to clone the vitest repo to your local machine and then build and link it yourself (pnpm is required):\n\nbash\ngit clone https://github.com/vitest-dev/vitest.git\ncd vitest\npnpm install\ncd packages/vitest\npnpm run build\npnpm link --global # you can use your preferred package manager for this step\n\nThen go to the project where you are using Vitest and run pnpm link --global vitest (or the package manager that you used to link vitest globally).\n\nCommunity\n​\n\nIf you have questions or need help, reach out to the community at Discord and GitHub Discussions."
  },
  {
    "title": "Configuring Vitest | Vitest",
    "url": "https://vitest.dev/config/",
    "html": "Configuring Vitest\n​\nConfiguration\n​\n\nvitest will read your root vite.config.ts when it is present to match with the plugins and setup as your Vite app. If you want to have a different configuration for testing or your main app doesn't rely on Vite specifically, you could either:\n\nCreate vitest.config.ts, which will have the higher priority and will override the configuration from vite.config.ts\nPass --config option to CLI, e.g. vitest --config ./path/to/vitest.config.ts\nUse process.env.VITEST or mode property on defineConfig (will be set to test/benchmark if not overridden) to conditionally apply different configuration in vite.config.ts\n\nTo configure vitest itself, add test property in your Vite config. You'll also need to add a reference to Vitest types using a triple slash command at the top of your config file, if you are importing defineConfig from vite itself.\n\nUsing defineConfig from vite you should follow this:\n\nts\n/// <reference types=\"vitest\" />\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n\nUsing defineConfig from vitest/config you should follow this:\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    // ... Specify options here.\n  },\n})\n\nYou can retrieve Vitest's default options to expand them if needed:\n\nts\nimport { configDefaults, defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    exclude: [...configDefaults.exclude, 'packages/template/*'],\n  },\n})\n\nWhen using a separate vitest.config.js, you can also extend Vite's options from another config file if needed:\n\nts\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config'\n\nexport default mergeConfig(viteConfig, defineConfig({\n  test: {\n    exclude: ['packages/template/*'],\n  },\n}))\n\nWARNING\n\nmergeConfig helper is available in Vitest since v0.30.0. You can import it from vite directly, if you use lower version.\n\nIf your Vite config is defined as a function, you can define the config like this:\n\nts\nimport { defineConfig, mergeConfig } from 'vitest/config'\nimport viteConfig from './vite.config'\n\nexport default defineConfig(configEnv => mergeConfig(\n  viteConfig(configEnv),\n  defineConfig({\n    test: {\n      exclude: ['packages/template/*'],\n    },\n  })\n))\nOptions\n​\n\nTIP\n\nIn addition to the following options, you can also use any configuration option from Vite. For example, define to define global variables, or resolve.alias to define aliases.\n\nAll listed options here are located on a test property inside the config:\n\nts\nexport default defineConfig({\n  test: {\n    exclude: [],\n  },\n})\n\nTIP\n\nAll configuration options that are not supported inside a workspace project config have * sign next to them.\n\ninclude\n​\nType: string[]\nDefault: ['**/*.{test,spec}.?(c|m)[jt]s?(x)']\n\nFiles to include in the test run, using glob pattern.\n\nexclude\n​\nType: string[]\nDefault: ['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**', '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*']\n\nFiles to exclude from the test run, using glob pattern.\n\nincludeSource\n​\nType: string[]\nDefault: []\n\nInclude globs for in-source test files.\n\nWhen defined, Vitest will run all matched files with import.meta.vitest inside.\n\nserver\n​\nType: { sourcemap?, deps?, ... }\nVersion: Since Vitest 0.34.0\n\nVite-Node server options.\n\nserver.sourcemap\n​\nType: 'inline' | boolean\nDefault: 'inline'\n\nInject inline source map to modules.\n\nserver.debug\n​\nType: { dumpModules?, loadDumppedModules? }\n\nVite-Node debugger options.\n\nserver.debug.dumpModules\n​\nType: boolean | string\n\nDump the transformed module to filesystem. Passing a string will dump to the specified path.\n\nserver.debug.loadDumppedModules\n​\nType: boolean\n\nRead dumped module from filesystem whenever exists. Useful for debugging by modifying the dump result from the filesystem.\n\nserver.deps\n​\nType: { external?, inline?, ... }\n\nHandling for dependencies resolution.\n\nserver.deps.external\n​\nType: (string | RegExp)[]\nDefault: [/\\/node_modules\\//]\n\nExternalize means that Vite will bypass the package to the native Node. Externalized dependencies will not be applied to Vite's transformers and resolvers, so they do not support HMR on reload. By default, all packages inside node_modules are externalized.\n\nThese options support package names as they are written in node_modules or specified inside deps.moduleDirectories. For example, package @company/some-name located inside packages/some-name should be specified as some-name, and packages should be included in deps.moduleDirectories. Basically, Vitest always checks the file path, not the actual package name.\n\nIf regexp is used, Vitest calls it on the file path, not the package name.\n\nserver.deps.inline\n​\nType: (string | RegExp)[] | true\nDefault: []\n\nVite will process inlined modules. This could be helpful to handle packages that ship .js in ESM format (that Node can't handle).\n\nIf true, every dependency will be inlined. All dependencies, specified in ssr.noExternal will be inlined by default.\n\nserver.deps.fallbackCJS\n​\nType boolean\nDefault: false\n\nWhen a dependency is a valid ESM package, try to guess the cjs version based on the path. This might be helpful, if a dependency has the wrong ESM file.\n\nThis might potentially cause some misalignment if a package has different logic in ESM and CJS mode.\n\nserver.deps.cacheDir\n​\nType string\nDefault: 'node_modules/.vite'\n\nDirectory to save cache files.\n\ndeps\n​\nType: { optimizer?, ... }\n\nHandling for dependencies resolution.\n\ndeps.optimizer\n​\nType: { ssr?, web? }\nVersion: Since Vitest 0.34.0\nSee also: Dep Optimization Options\n\nEnable dependency optimization. If you have a lot of tests, this might improve their performance. Before Vitest 0.34.0, it was named as deps.experimentalOptimizer.\n\nWhen Vitest encounters the external library listed in include, it will be bundled into a single file using esbuild and imported as a whole module. This is good for several reasons:\n\nImporting packages with a lot of imports is expensive. By bundling them into one file we can save a lot of time\nImporting UI libraries is expensive because they are not meant to run inside Node.js\nYour alias configuration is now respected inside bundled packages\nCode in your tests is running closer to how it's running in the browser\n\nBe aware that only packages in deps.optimizer?.[mode].include option are bundled (some plugins populate this automatically, like Svelte). You can read more about available options in Vite docs (Vitest doesn't support disable and noDiscovery options). By default, Vitest uses optimizer.web for jsdom and happy-dom environments, and optimizer.ssr for node and edge environments, but it is configurable by transformMode.\n\nThis options also inherits your optimizeDeps configuration (for web Vitest will extend optimizeDeps, for ssr - ssr.optimizeDeps). If you redefine include/exclude option in deps.optimizer it will extend your optimizeDeps when running tests. Vitest automatically removes the same options from include, if they are listed in exclude.\n\nTIP\n\nYou will not be able to edit your node_modules code for debugging, since the code is actually located in your cacheDir or test.cache.dir directory. If you want to debug with console.log statements, edit it directly or force rebundling with deps.optimizer?.[mode].force option.\n\ndeps.optimizer.{mode}.enabled\n​\nType: boolean\nDefault: true if using >= Vite 4.3.2, false otherwise\n\nEnable dependency optimization.\n\nWARNING\n\nThis option only works with Vite 4.3.2 and higher.\n\ndeps.web\n​\nType: { transformAssets?, ... }\nVersion: Since Vite 0.34.2\n\nOptions that are applied to external files when transform mode is set to web. By default, jsdom and happy-dom use web mode, while node and edge environments use ssr transform mode, so these options will have no affect on files inside those environments.\n\nUsually, files inside node_modules are externalized, but these options also affect files in server.deps.external.\n\ndeps.web.transformAssets\n​\nType: boolean\nDefault: true\n\nShould Vitest process assets (.png, .svg, .jpg, etc) files and resolve them like Vite does in the browser.\n\nThis module will have a default export equal to the path to the asset, if no query is specified.\n\nWARNING\n\nAt the moment, this option only works with vmThreads pool.\n\ndeps.web.transformCss\n​\nType: boolean\nDefault: true\n\nShould Vitest process CSS (.css, .scss, .sass, etc) files and resolve them like Vite does in the browser.\n\nIf CSS files are disabled with css options, this option will just silence ERR_UNKNOWN_FILE_EXTENSION errors.\n\nWARNING\n\nAt the moment, this option only works with vmThreads pool.\n\ndeps.web.transformGlobPattern\n​\nType: RegExp | RegExp[]\nDefault: []\n\nRegexp pattern to match external files that should be transformed.\n\nBy default, files inside node_modules are externalized and not transformed, unless it's CSS or an asset, and corresponding option is not disabled.\n\nWARNING\n\nAt the moment, this option only works with vmThreads pool.\n\ndeps.interopDefault\n​\nType: boolean\nDefault: true\n\nInterpret CJS module's default as named exports. Some dependencies only bundle CJS modules and don't use named exports that Node.js can statically analyze when a package is imported using import syntax instead of require. When importing such dependencies in Node environment using named exports, you will see this error:\n\nimport { read } from 'fs-jetpack';\n         ^^^^\nSyntaxError: Named export 'read' not found. The requested module 'fs-jetpack' is a CommonJS module, which may not support all module.exports as named exports.\nCommonJS modules can always be imported via the default export.\n\nVitest doesn't do static analysis, and cannot fail before your running code, so you will most likely see this error when running tests, if this feature is disabled:\n\nTypeError: createAsyncThunk is not a function\nTypeError: default is not a function\n\nBy default, Vitest assumes you are using a bundler to bypass this and will not fail, but you can disable this behaviour manually, if you code is not processed.\n\ndeps.moduleDirectories\n​\nType: string[]\nDefault: ['node_modules']\n\nA list of directories that should be treated as module directories. This config option affects the behavior of vi.mock: when no factory is provided and the path of what you are mocking matches one of the moduleDirectories values, Vitest will try to resolve the mock by looking for a __mocks__ folder in the root of the project.\n\nThis option will also affect if a file should be treated as a module when externalizing dependencies. By default, Vitest imports external modules with native Node.js bypassing Vite transformation step.\n\nSetting this option will override the default, if you wish to still search node_modules for packages include it along with any other options:\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    deps: {\n      moduleDirectories: ['node_modules', path.resolve('../../packages')],\n    }\n  },\n})\nrunner\n​\nType: VitestRunnerConstructor\nDefault: node, when running tests, or benchmark, when running benchmarks\n\nPath to a custom test runner. This is an advanced feature and should be used with custom library runners. You can read more about it in the documentation.\n\nbenchmark\n​\nType: { include?, exclude?, ... }\n\nOptions used when running vitest bench.\n\nbenchmark.include\n​\nType: string[]\nDefault: ['**/*.{bench,benchmark}.?(c|m)[jt]s?(x)']\n\nInclude globs for benchmark test files\n\nbenchmark.exclude\n​\nType: string[]\nDefault: ['node_modules', 'dist', '.idea', '.git', '.cache']\n\nExclude globs for benchmark test files\n\nbenchmark.includeSource\n​\nType: string[]\nDefault: []\n\nInclude globs for in-source benchmark test files. This option is similar to includeSource.\n\nWhen defined, Vitest will run all matched files with import.meta.vitest inside.\n\nbenchmark.reporters\n​\nType: Arrayable<BenchmarkBuiltinReporters | Reporter>\nDefault: 'default'\n\nCustom reporter for output. Can contain one or more built-in report names, reporter instances, and/or paths to custom reporters.\n\nbenchmark.outputFile\n​\nType: string | Record<string, string>\n\nWrite benchmark results to a file when the --reporter=json option is also specified. By providing an object instead of a string you can define individual outputs when using multiple reporters.\n\nTo provide object via CLI command, use the following syntax: --outputFile.json=./path --outputFile.junit=./other-path.\n\nalias\n​\nType: Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>\n\nDefine custom aliases when running inside tests. They will be merged with aliases from resolve.alias.\n\nglobals\n​\nType: boolean\nDefault: false\nCLI: --globals, --globals=false\n\nBy default, vitest does not provide global APIs for explicitness. If you prefer to use the APIs globally like Jest, you can pass the --globals option to CLI or add globals: true in the config.\n\nts\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    globals: true,\n  },\n})\n\nTo get TypeScript working with the global APIs, add vitest/globals to the types field in your tsconfig.json\n\njson\n// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"types\": [\"vitest/globals\"]\n  }\n}\n\nIf you are already using unplugin-auto-import in your project, you can also use it directly for auto importing those APIs.\n\nts\n// vitest.config.ts\nimport { defineConfig } from 'vitest/config'\nimport AutoImport from 'unplugin-auto-import/vite'\n\nexport default defineConfig({\n  plugins: [\n    AutoImport({\n      imports: ['vitest'],\n      dts: true, // generate TypeScript declaration\n    }),\n  ],\n})\nenvironment\n​\nType: 'node' | 'jsdom' | 'happy-dom' | 'edge-runtime' | string\nDefault: 'node'\nCLI: --environment=<env>\n\nThe environment that will be used for testing. The default environment in Vitest is a Node.js environment. If you are building a web application, you can use browser-like environment through either jsdom or happy-dom instead. If you are building edge functions, you can use edge-runtime environment\n\nBy adding a @vitest-environment docblock or comment at the top of the file, you can specify another environment to be used for all tests in that file:\n\nDocblock style:\n\njs\n/**\n * @vitest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n\nComment style:\n\njs\n// @vitest-environment happy-dom\n\ntest('use happy-dom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n\nFor compatibility with Jest, there is also a @jest-environment:\n\njs\n/**\n * @jest-environment jsdom\n */\n\ntest('use jsdom in this test file', () => {\n  const element = document.createElement('div')\n  expect(element).not.toBeNull()\n})\n\nIf you are running Vitest with --threads=false flag, your tests will be run in this order: node, jsdom, happy-dom, edge-runtime, custom environments. Meaning, that every test with the same environment is grouped together, but is still running sequentially.\n\nStarting from 0.23.0, you can also define custom environment. When non-builtin environment is used, Vitest will try to load package vitest-environment-${name}. That package should export an object with the shape of Environment:\n\nts\nimport type { Environment } from 'vitest'\n\nexport default <Environment>{\n  name: 'custom',\n  transformMode: 'ssr',\n  setup() {\n    // custom setup\n    return {\n      teardown() {\n        // called after all tests with this env have been run\n      }\n    }\n  }\n}\n\nVitest also exposes builtinEnvironments through vitest/environments entry, in case you just want to extend it. You can read more about extending environments in our guide.\n\nenvironmentOptions\n​\nType: Record<'jsdom' | string, unknown>\nDefault: {}\n\nThese options are passed down to setup method of current environment. By default, you can configure only JSDOM options, if you are using it as your test environment.\n\nenvironmentMatchGlobs\n​\nType: [string, EnvironmentName][]\nDefault: []\n\nAutomatically assign environment based on globs. The first match will be used.\n\nFor example:\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    environmentMatchGlobs: [\n      // all tests in tests/dom will run in jsdom\n      ['tests/dom/**', 'jsdom'],\n      // all tests in tests/ with .edge.test.ts will run in edge-runtime\n      ['**\\/*.edge.test.ts', 'edge-runtime'],\n      // ...\n    ]\n  }\n})\npoolMatchGlobs\n​\nType: [string, 'threads' | 'forks' | 'vmThreads' | 'typescript'][]\nDefault: []\nVersion: Since Vitest 0.29.4\n\nAutomatically assign pool in which tests will run based on globs. The first match will be used.\n\nFor example:\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolMatchGlobs: [\n      // all tests in \"worker-specific\" directory will run inside a worker as if you enabled `--threads` for them,\n      ['**/tests/worker-specific/**', 'threads'],\n      // run all tests in \"browser\" directory in an actual browser\n      ['**/tests/browser/**', 'browser'],\n      // all other tests will run based on \"browser.enabled\" and \"threads\" options, if you didn't specify other globs\n      // ...\n    ]\n  }\n})\nupdate *\n​\nType: boolean\nDefault: false\nCLI: -u, --update, --update=false\n\nUpdate snapshot files. This will update all changed snapshots and delete obsolete ones.\n\nwatch *\n​\nType: boolean\nDefault: true\nCLI: -w, --watch, --watch=false\n\nEnable watch mode\n\nroot\n​\nType: string\nCLI: -r <path>, --root=<path>\n\nProject root\n\nreporters *\n​\nType: Reporter | Reporter[]\nDefault: 'default'\nCLI: --reporter=<name>, --reporter=<name1> --reporter=<name2>\n\nCustom reporters for output. Reporters can be a Reporter instance, a string to select built-in reporters, or a path to a custom implementation (e.g. './path/to/reporter.ts', '@scope/reporter').\n\noutputFile *\n​\nType: string | Record<string, string>\nCLI: --outputFile=<path>, --outputFile.json=./path\n\nWrite test results to a file when the --reporter=json, --reporter=html or --reporter=junit option is also specified. By providing an object instead of a string you can define individual outputs when using multiple reporters.\n\npool *\n​\nType: 'threads' | 'forks' | 'vmThreads'\nDefault: 'threads'\nCLI: --pool=threads\nVersion: Since Vitest 1.0.0-beta\n\nPool used to run tests in.\n\nthreads *\n​\n\nEnable multi-threading using tinypool (a lightweight fork of Piscina). When using threads you are unable to use process related APIs such as process.chdir(). Some libraries written in native languages, such as Prisma, bcrypt and canvas, have problems when running in multiple threads and run into segfaults. In these cases it is advised to use forks pool instead.\n\nforks *\n​\n\nSimilar as threads pool but uses child_process instead of worker_threads via tinypool. Communication between tests and main process is not as fast as with threads pool. Process related APIs such as process.chdir() are available in forks pool.\n\nvmThreads *\n​\n\nRun tests using VM context (inside a sandboxed environment) in a threads pool.\n\nThis makes tests run faster, but the VM module is unstable when running ESM code. Your tests will leak memory - to battle that, consider manually editing poolOptions.vmThreads.memoryLimit value.\n\nWARNING\n\nRunning code in a sandbox has some advantages (faster tests), but also comes with a number of disadvantages.\n\nThe globals within native modules, such as (fs, path, etc), differ from the globals present in your test environment. As a result, any error thrown by these native modules will reference a different Error constructor compared to the one used in your code:\nts\ntry {\n  fs.writeFileSync('/doesnt exist')\n}\ncatch (err) {\n  console.log(err instanceof Error) // false\n}\nImporting ES modules caches them indefinitely which introduces memory leaks if you have a lot of contexts (test files). There is no API in Node.js that clears that cache.\nAccessing globals takes longer in a sandbox environment.\n\nPlease, be aware of these issues when using this option. Vitest team cannot fix any of the issues on our side.\n\npoolOptions *\n​\nType: Record<'threads' | 'forks' | 'vmThreads', {}>\nDefault: {}\nVersion: Since Vitest 1.0.0-beta\npoolOptions.threads *\n​\n\nOptions for threads pool.\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      threads: {\n        // Threads related options here\n      }\n    }\n  }\n})\npoolOptions.threads.maxThreads *\n​\nType: number\nDefault: available CPUs\n\nMaximum number of threads. You can also use VITEST_MAX_THREADS environment variable.\n\npoolOptions.threads.minThreads *\n​\nType: number\nDefault: available CPUs\n\nMinimum number of threads. You can also use VITEST_MIN_THREADS environment variable.\n\npoolOptions.threads.singleThread *\n​\nType: boolean\nDefault: false\n\nRun all tests with the same environment inside a single worker thread. This will disable built-in module isolation (your source code or inlined code will still be reevaluated for each test), but can improve test performance.\n\nWARNING\n\nEven though this option will force tests to run one after another, this option is different from Jest's --runInBand. Vitest uses workers not only for running tests in parallel, but also to provide isolation. By disabling this option, your tests will run sequentially, but in the same global context, so you must provide isolation yourself.\n\nThis might cause all sorts of issues, if you are relying on global state (frontend frameworks usually do) or your code relies on environment to be defined separately for each test. But can be a speed boost for your tests (up to 3 times faster), that don't necessarily rely on global state or can easily bypass that.\n\npoolOptions.threads.useAtomics *\n​\nType: boolean\nDefault: false\n\nUse Atomics to synchronize threads.\n\nThis can improve performance in some cases, but might cause segfault in older Node versions.\n\npoolOptions.threads.isolate *\n​\nType: boolean\nDefault: true\n\nIsolate environment for each test file.\n\npoolOptions.threads.execArgv *\n​\nType: string[]\nDefault: []\n\nPass additional arguments to node in the threads. See Command-line API | Node.js for more information.\n\nWARNING\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See https://github.com/nodejs/node/issues/41103.\n\npoolOptions.forks *\n​\n\nOptions for forks pool.\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      forks: {\n        // Forks related options here\n      }\n    }\n  }\n})\npoolOptions.forks.maxForks *\n​\nType: number\nDefault: available CPUs\n\nMaximum number of forks.\n\npoolOptions.forks.minForks *\n​\nType: number\nDefault: available CPUs\n\nMinimum number of forks.\n\npoolOptions.forks.isolate *\n​\nType: boolean\nDefault: true\n\nIsolate environment for each test file.\n\npoolOptions.forks.singleFork *\n​\nType: boolean\nDefault: false\n\nRun all tests with the same environment inside a single child process. This will disable built-in module isolation (your source code or inlined code will still be reevaluated for each test), but can improve test performance.\n\nWARNING\n\nEven though this option will force tests to run one after another, this option is different from Jest's --runInBand. Vitest uses child processes not only for running tests in parallel, but also to provide isolation. By disabling this option, your tests will run sequentially, but in the same global context, so you must provide isolation yourself.\n\nThis might cause all sorts of issues, if you are relying on global state (frontend frameworks usually do) or your code relies on environment to be defined separately for each test. But can be a speed boost for your tests (up to 3 times faster), that don't necessarily rely on global state or can easily bypass that.\n\npoolOptions.forks.execArgv *\n​\nType: string[]\nDefault: []\n\nPass additional arguments to node process in the child processes. See Command-line API | Node.js for more information.\n\nWARNING\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See https://github.com/nodejs/node/issues/41103.\n\npoolOptions.vmThreads *\n​\n\nOptions for vmThreads pool.\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    poolOptions: {\n      vmThreads: {\n        // VM threads related options here\n      }\n    }\n  }\n})\npoolOptions.vmThreads.maxThreads *\n​\nType: number\nDefault: available CPUs\n\nMaximum number of threads. You can also use VITEST_MAX_THREADS environment variable.\n\npoolOptions.vmThreads.minThreads *\n​\nType: number\nDefault: available CPUs\n\nMinimum number of threads. You can also use VITEST_MIN_THREADS environment variable.\n\npoolOptions.vmThreads.memoryLimit *\n​\nType: string | number\nDefault: 1 / CPU Cores\n\nSpecifies the memory limit for workers before they are recycled. This value heavily depends on your environment, so it's better to specify it manually instead of relying on the default.\n\nTIP\n\nThe implementation is based on Jest's workerIdleMemoryLimit.\n\nThe limit can be specified in a number of different ways and whatever the result is Math.floor is used to turn it into an integer value:\n\n<= 1 - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory\n\\> 1 - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use 1.1.\nWith units\n50% - As above, a percentage of total system memory\n100KB, 65MB, etc - With units to denote a fixed memory limit.\nK / KB - Kilobytes (x1000)\nKiB - Kibibytes (x1024)\nM / MB - Megabytes\nMiB - Mebibytes\nG / GB - Gigabytes\nGiB - Gibibytes\n\nWARNING\n\nPercentage based memory limit does not work on Linux CircleCI workers due to incorrect system memory being reported.\n\npoolOptions.vmThreads.useAtomics *\n​\nType: boolean\nDefault: false\n\nUse Atomics to synchronize threads.\n\nThis can improve performance in some cases, but might cause segfault in older Node versions.\n\npoolOptions.vmThreads.execArgv *\n​\nType: string[]\nDefault: []\n\nPass additional arguments to node process in the VM context. See Command-line API | Node.js for more information.\n\nWARNING\n\nBe careful when using, it as some options may crash worker, e.g. --prof, --title. See https://github.com/nodejs/node/issues/41103.\n\ntestTimeout\n​\nType: number\nDefault: 5000\nCLI: --test-timeout=5000\n\nDefault timeout of a test in milliseconds\n\nhookTimeout\n​\nType: number\nDefault: 10000\n\nDefault timeout of a hook in milliseconds\n\nteardownTimeout *\n​\nType: number\nDefault: 10000\n\nDefault timeout to wait for close when Vitest shuts down, in milliseconds\n\nsilent *\n​\nType: boolean\nDefault: false\nCLI: --silent, --silent=false\n\nSilent console output from tests\n\nsetupFiles\n​\nType: string | string[]\n\nPath to setup files. They will be run before each test file.\n\nINFO\n\nChanging setup files will trigger rerun of all tests.\n\nYou can use process.env.VITEST_POOL_ID (integer-like string) inside to distinguish between threads.\n\nTIP\n\nNote, that if you are running --threads=false, this setup file will be run in the same global scope multiple times. Meaning, that you are accessing the same global object before each test, so make sure you are not doing the same thing more than you need.\n\nFor example, you may rely on a global variable:\n\nts\nimport { config } from '@some-testing-lib'\n\nif (!globalThis.defined) {\n  config.plugins = [myCoolPlugin]\n  computeHeavyThing()\n  globalThis.defined = true\n}\n\n// hooks are reset before each suite\nafterEach(() => {\n  cleanup()\n})\n\nglobalThis.resetBeforeEachTest = true\nglobalSetup\n​\nType: string | string[]\n\nPath to global setup files, relative to project root.\n\nA global setup file can either export named functions setup and teardown or a default function that returns a teardown function (example).\n\nINFO\n\nMultiple globalSetup files are possible. setup and teardown are executed sequentially with teardown in reverse order.\n\nWARNING\n\nSince Vitest 1.0.0-beta, global setup runs only if there is at least one running test. This means that global setup might start running during watch mode after test file is changed (the test file will wait for global setup to finish before running).\n\nBeware that the global setup is running in a different global scope, so your tests don't have access to variables defined here. However, since 1.0.0 you can pass down serializable data to tests via provide method:\n\nts\n// globalSetup.js\nexport default function setup({ provide }) {\n  provide('wsPort', 3000)\n}\nts\n// example.test.js\nimport { inject } from 'vitest'\n\ninject('wsPort') === 3000\n\nIf you are using TypeScript, you can extend ProvidedContext type to have type safe access to provide/inject methods:\n\nts\ndeclare module 'vitest' {\n  export interface ProvidedContext {\n    wsPort: number\n  }\n}\nwatchExclude *\n​\nType: string[]\nDefault: ['**/node_modules/**', '**/dist/**']\n\nGlob pattern of file paths to be ignored from triggering watch rerun.\n\nforceRerunTriggers *\n​\nType: string[]\nDefault: ['**/package.json/**', '**/vitest.config.*/**', '**/vite.config.*/**']\n\nGlob pattern of file paths that will trigger the whole suite rerun. When paired with the --changed argument will run the whole test suite if the trigger is found in the git diff.\n\nUseful if you are testing calling CLI commands, because Vite cannot construct a module graph:\n\nts\ntest('execute a script', async () => {\n  // Vitest cannot rerun this test, if content of `dist/index.js` changes\n  await execa('node', ['dist/index.js'])\n})\n\nTIP\n\nMake sure that your files are not excluded by watchExclude.\n\ncoverage *\n​\n\nYou can use v8, istanbul or a custom coverage solution for coverage collection.\n\nYou can provide coverage options to CLI with dot notation:\n\nsh\nnpx vitest --coverage.enabled --coverage.provider=istanbul --coverage.all\n\nWARNING\n\nIf you are using coverage options with dot notation, don't forget to specify --coverage.enabled. Do not provide a single --coverage option in that case.\n\ncoverage.provider\n​\nType: 'v8' | 'istanbul' | 'custom'\nDefault: 'v8'\nCLI: --coverage.provider=<provider>\n\nUse provider to select the tool for coverage collection.\n\ncoverage.enabled\n​\nType: boolean\nDefault: false\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.enabled, --coverage.enabled=false\n\nEnables coverage collection. Can be overridden using --coverage CLI option.\n\ncoverage.include\n​\nType: string[]\nDefault: ['**']\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.include=<path>, --coverage.include=<path1> --coverage.include=<path2>\n\nList of files included in coverage as glob patterns\n\ncoverage.extension\n​\nType: string | string[]\nDefault: ['.js', '.cjs', '.mjs', '.ts', '.mts', '.cts', '.tsx', '.jsx', '.vue', '.svelte', '.marko']\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.extension=<extension>, --coverage.extension=<extension1> --coverage.extension=<extension2>\ncoverage.exclude\n​\nType: string[]\nDefault:\njs\n[\n  'coverage/**',\n  'dist/**',\n  '**/[.]**',\n  'packages/*/test?(s)/**',\n  '**/*.d.ts',\n  '**/virtual:*',\n  '**/__x00__*',\n  '**/\\x00*',\n  'cypress/**',\n  'test?(s)/**',\n  'test?(-*).?(c|m)[jt]s?(x)',\n  '**/*{.,-}{test,spec}.?(c|m)[jt]s?(x)',\n  '**/__tests__/**',\n  '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build}.config.*',\n  '**/vitest.{workspace,projects}.[jt]s?(on)',\n  '**/.{eslint,mocha,prettier}rc.{?(c|m)js,yml}',\n]\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.exclude=<path>, --coverage.exclude=<path1> --coverage.exclude=<path2>\n\nList of files excluded from coverage as glob patterns.\n\ncoverage.all\n​\nType: boolean\nDefault: true (since Vitest 1.0.0)\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.all, --coverage.all=false\n\nWhether to include all files, including the untested ones into report.\n\ncoverage.clean\n​\nType: boolean\nDefault: true\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.clean, --coverage.clean=false\n\nClean coverage results before running tests\n\ncoverage.cleanOnRerun\n​\nType: boolean\nDefault: true\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.cleanOnRerun, --coverage.cleanOnRerun=false\n\nClean coverage report on watch rerun\n\ncoverage.reportsDirectory\n​\nType: string\nDefault: './coverage'\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.reportsDirectory=<path>\n\nDirectory to write coverage report to.\n\ncoverage.reporter\n​\nType: string | string[] | [string, {}][]\nDefault: ['text', 'html', 'clover', 'json']\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.reporter=<reporter>, --coverage.reporter=<reporter1> --coverage.reporter=<reporter2>\n\nCoverage reporters to use. See istanbul documentation for detailed list of all reporters. See @types/istanbul-reporter for details about reporter specific options.\n\nThe reporter has three different types:\n\nA single reporter: { reporter: 'html' }\nMultiple reporters without options: { reporter: ['html', 'json'] }\nA single or multiple reporters with reporter options:\nts\n{\n  reporter: [\n    ['lcov', { 'projectRoot': './src' }],\n    ['json', { 'file': 'coverage.json' }],\n    ['text']\n  ]\n}\n\nSince Vitest 0.31.0, you can check your coverage report in Vitest UI: check Vitest UI Coverage for more details.\n\ncoverage.reportOnFailure\n​\nType: boolean\nDefault: false (since Vitest 0.34.0)\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.reportOnFailure, --coverage.reportOnFailure=false\nVersion: Since Vitest 0.31.2\n\nGenerate coverage report even when tests fail.\n\ncoverage.allowExternal\n​\nType: boolean\nDefault: false\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.allowExternal, --coverage.allowExternal=false\n\nCollect coverage of files outside the project root.\n\ncoverage.skipFull\n​\nType: boolean\nDefault: false\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.skipFull, --coverage.skipFull=false\n\nDo not show files with 100% statement, branch, and function coverage.\n\ncoverage.thresholds\n​\n\nOptions for coverage thresholds\n\ncoverage.thresholds.lines\n​\nType: number\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.thresholds.lines=<number>\n\nGlobal threshold for lines. See istanbul documentation for more information.\n\ncoverage.thresholds.functions\n​\nType: number\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.thresholds.functions=<number>\n\nGlobal threshold for functions. See istanbul documentation for more information.\n\ncoverage.thresholds.branches\n​\nType: number\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.thresholds.branches=<number>\n\nGlobal threshold for branches. See istanbul documentation for more information.\n\ncoverage.thresholds.statements\n​\nType: number\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.thresholds.statements=<number>\n\nGlobal threshold for statements. See istanbul documentation for more information.\n\ncoverage.thresholds.perFile\n​\nType: boolean\nDefault: false\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.thresholds.perFile, --coverage.thresholds.perFile=false\n\nCheck thresholds per file.\n\ncoverage.thresholds.autoUpdate\n​\nType: boolean\nDefault: false\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.thresholds.autoUpdate=<boolean>\n\nUpdate all threshold values lines, functions, branches and statements to configuration file when current coverage is above the configured thresholds. This option helps to maintain thresholds when coverage is improved.\n\ncoverage.thresholds.100\n​\nType: boolean\nDefault: false\nAvailable for providers: 'v8' | 'istanbul'\nCLI: --coverage.thresholds.100, --coverage.thresholds.100=false\n\nSets global thresholds to 100. Shortcut for --coverage.thresholds.lines 100 --coverage.thresholds.functions 100 --coverage.thresholds.branches 100 --coverage.thresholds.statements 100.\n\ncoverage.thresholds[glob-pattern]\n​\nType: { statements?: number functions?: number branches?: number lines?: number }\nDefault: undefined\nAvailable for providers: 'v8' | 'istanbul'\n\nSets thresholds for files matching the glob pattern.\n\nts\n{\n  coverage: {\n    thresholds: {\n      // Thresholds for all files\n      functions: 95,\n      branches: 70,\n\n      // Thresholds for matching glob pattern\n      'src/utils/**.ts': {\n        statements: 95,\n        functions: 90,\n        branches: 85,\n        lines: 80,\n      },\n\n      // Files matching this pattern will only have lines thresholds set.\n      // Global thresholds are not inherited.\n      '**/math.ts': {\n        lines: 100,\n      }\n    }\n  }\n}\ncoverage.ignoreClassMethods\n​\nType: string[]\nDefault: []\nAvailable for providers: 'istanbul'\nCLI: --coverage.ignoreClassMethods=<method>\n\nSet to array of class method names to ignore for coverage. See istanbul documentation for more information.\n\ncoverage.watermarks\n​\nType:\nts\n{\n  statements?: [number, number],\n  functions?: [number, number],\n  branches?: [number, number],\n  lines?: [number, number]\n}\nDefault:\nts\n{\n  statements: [50, 80],\n  functions: [50, 80],\n  branches: [50, 80],\n  lines: [50, 80]\n}\nAvailable for providers: 'v8' | 'istanbul'\n\nWatermarks for statements, lines, branches and functions. See istanbul documentation for more information.\n\ncoverage.customProviderModule\n​\nType: string\nAvailable for providers: 'custom'\nCLI: --coverage.customProviderModule=<path or module name>\n\nSpecifies the module name or path for the custom coverage provider module. See Guide - Custom Coverage Provider for more information.\n\ntestNamePattern *\n​\nType string | RegExp\nCLI: -t <pattern>, --testNamePattern=<pattern>, --test-name-pattern=<pattern>\n\nRun tests with full names matching the pattern. If you add OnlyRunThis to this property, tests not containing the word OnlyRunThis in the test name will be skipped.\n\njs\nimport { expect, test } from 'vitest'\n\n// run\ntest('OnlyRunThis', () => {\n  expect(true).toBe(true)\n})\n\n// skipped\ntest('doNotRun', () => {\n  expect(true).toBe(true)\n})\nopen *\n​\nType: boolean\nDefault: false\nCLI: --open, --open=false\n\nOpen Vitest UI (WIP)\n\napi\n​\nType: boolean | number\nDefault: false\nCLI: --api, --api.port, --api.host, --api.strictPort\n\nListen to port and serve API. When set to true, the default port is 51204\n\nbrowser\n​\nType: { enabled?, name?, provider?, headless?, api?, slowHijackESM? }\nDefault: { enabled: false, headless: process.env.CI, api: 63315 }\nVersion: Since Vitest 0.29.4\nCLI: --browser, --browser=<name>, --browser.name=chrome --browser.headless\n\nRun Vitest tests in a browser. We use WebdriverIO for running tests by default, but it can be configured with browser.provider option.\n\nNOTE\n\nRead more about testing in a real browser in the guide page.\n\nWARNING\n\nThis is an experimental feature. Breaking changes might not follow SemVer, please pin Vitest's version when using it.\n\nbrowser.enabled\n​\nType: boolean\nDefault: false\nCLI: --browser, --browser.enabled=false\n\nRun all tests inside a browser by default. Can be overridden with poolMatchGlobs option.\n\nbrowser.name\n​\nType: string\nCLI: --browser=safari\n\nRun all tests in a specific browser. Possible options in different providers:\n\nwebdriverio: firefox, chrome, edge, safari\nplaywright: firefox, webkit, chromium\ncustom: any string that will be passed to the provider\nbrowser.headless\n​\nType: boolean\nDefault: process.env.CI\nCLI: --browser.headless, --browser.headless=false\n\nRun the browser in a headless mode. If you are running Vitest in CI, it will be enabled by default.\n\nbrowser.isolate\n​\nType: boolean\nDefault: true\nCLI: --browser.isolate, --browser.isolate=false\n\nIsolate test environment after each test.\n\nbrowser.api\n​\nType: number | { port?, strictPort?, host? }\nDefault: 63315\nCLI: --browser.api=63315, --browser.api.port=1234, --browser.api.host=example.com\n\nConfigure options for Vite server that serves code in the browser. Does not affect test.api option.\n\nbrowser.provider\n​\nType: 'webdriverio' | 'playwright' | string\nDefault: 'webdriverio'\nCLI: --browser.provider=playwright\n\nPath to a provider that will be used when running browser tests. Vitest provides two providers which are webdriverio (default) and playwright. Custom providers should be exported using default export and have this shape:\n\nts\nexport interface BrowserProvider {\n  name: string\n  getSupportedBrowsers(): readonly string[]\n  initialize(ctx: Vitest, options: { browser: string; options?: BrowserProviderOptions }): Awaitable<void>\n  openPage(url: string): Awaitable<void>\n  close(): Awaitable<void>\n}\n\nWARNING\n\nThis is an advanced API for library authors. If you just need to run tests in a browser, use the browser option.\n\nbrowser.providerOptions\n​\nType: BrowserProviderOptions\nVersion: Since Vitest 1.0.0-beta.3\n\nOptions that will be passed down to provider when calling provider.initialize.\n\nts\nexport default defineConfig({\n  test: {\n    browser: {\n      providerOptions: {\n        launch: {\n          devtools: true,\n        }\n      }\n    }\n  }\n})\n\nTIP\n\nTo have a better type safety when using built-in providers, you can add one of these types (for provider that you are using) to your tsconfig's compilerOptions.types field:\n\njson\n{\n  \"compilerOptions\": {\n    \"types\": [\n      \"@vitest/browser/providers/webdriverio\",\n      \"@vitest/browser/providers/playwright\"\n    ]\n  }\n}\nbrowser.slowHijackESM\n​\nType: boolean\nDefault: false\nVersion: Since Vitest 0.31.0\n\nWhen running tests in Node.js Vitest can use its own module resolution to easily mock modules with vi.mock syntax. However it's not so easy to replicate ES module resolution in browser, so we need to transform your source files before browser can consume it.\n\nThis option has no effect on tests running inside Node.js.\n\nIf you rely on spying on ES modules with vi.spyOn, you can enable this experimental feature to allow spying on module exports.\n\nclearMocks\n​\nType: boolean\nDefault: false\n\nWill call .mockClear() on all spies before each test. This will clear mock history, but not reset its implementation to the default one.\n\nmockReset\n​\nType: boolean\nDefault: false\n\nWill call .mockReset() on all spies before each test. This will clear mock history and reset its implementation to an empty function (will return undefined).\n\nrestoreMocks\n​\nType: boolean\nDefault: false\n\nWill call .mockRestore() on all spies before each test. This will clear mock history and reset its implementation to the original one.\n\nunstubEnvs\n​\nType: boolean\nDefault: false\nVersion: Since Vitest 0.26.0\n\nWill call vi.unstubAllEnvs before each test.\n\nunstubGlobals\n​\nType: boolean\nDefault: false\nVersion: Since Vitest 0.26.0\n\nWill call vi.unstubAllGlobals before each test.\n\ntestTransformMode\n​\nType: { web?, ssr? }\nVersion: Since Vitest 0.34.0\n\nDetermine the transform method for all modules imported inside a test that matches the glob pattern. By default, relies on the environment. For example, tests with JSDOM environment will process all files with ssr: false flag and tests with Node environment process all modules with ssr: true.\n\ntestTransformMode.ssr\n​\nType: string[]\nDefault: []\n\nUse SSR transform pipeline for all modules inside specified tests.\nVite plugins will receive ssr: true flag when processing those files.\n\ntestTransformMode.web\n​\nType: string[]\nDefault: []\n\nFirst do a normal transform pipeline (targeting browser), then do a SSR rewrite to run the code in Node.\nVite plugins will receive ssr: false flag when processing those files.\n\nsnapshotFormat *\n​\nType: PrettyFormatOptions\n\nFormat options for snapshot testing. These options are passed down to pretty-format.\n\nTIP\n\nBeware that plugins field on this object will be ignored.\n\nIf you need to extend snapshot serializer via pretty-format plugins, please, use expect.addSnapshotSerializer API.\n\nresolveSnapshotPath *\n​\nType: (testPath: string, snapExtension: string) => string\nDefault: stores snapshot files in __snapshots__ directory\n\nOverrides default snapshot path. For example, to store snapshots next to test files:\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    resolveSnapshotPath: (testPath, snapExtension) => testPath + snapExtension,\n  },\n})\nallowOnly\n​\nType: boolean\nDefault: false\nCLI: --allowOnly, --allowOnly=false\n\nAllow tests and suites that are marked as only.\n\ndangerouslyIgnoreUnhandledErrors *\n​\nType: boolean\nDefault: false\nCLI: --dangerouslyIgnoreUnhandledErrors --dangerouslyIgnoreUnhandledErrors=false\n\nIgnore any unhandled errors that occur.\n\npassWithNoTests *\n​\nType: boolean\nDefault: false\nCLI: --passWithNoTests, --passWithNoTests=false\n\nVitest will not fail, if no tests will be found.\n\nlogHeapUsage\n​\nType: boolean\nDefault: false\nCLI: --logHeapUsage, --logHeapUsage=false\n\nShow heap usage after each test. Useful for debugging memory leaks.\n\ncss\n​\nType: boolean | { include?, exclude?, modules? }\n\nConfigure if CSS should be processed. When excluded, CSS files will be replaced with empty strings to bypass the subsequent processing. CSS Modules will return a proxy to not affect runtime.\n\ncss.include\n​\nType: RegExp | RegExp[]\nDefault: []\n\nRegExp pattern for files that should return actual CSS and will be processed by Vite pipeline.\n\nTIP\n\nTo process all CSS files, use /.+/.\n\ncss.exclude\n​\nType: RegExp | RegExp[]\nDefault: []\n\nRegExp pattern for files that will return an empty CSS file.\n\ncss.modules\n​\nType: { classNameStrategy? }\nDefault: {}\ncss.modules.classNameStrategy\n​\nType: 'stable' | 'scoped' | 'non-scoped'\nDefault: 'stable'\n\nIf you decide to process CSS files, you can configure if class names inside CSS modules should be scoped. You can choose one of the options:\n\nstable: class names will be generated as _${name}_${hashedFilename}, which means that generated class will stay the same, if CSS content is changed, but will change, if the name of the file is modified, or file is moved to another folder. This setting is useful, if you use snapshot feature.\nscoped: class names will be generated as usual, respecting css.modules.generateScopeName method, if you have one and CSS processing is enabled. By default, filename will be generated as _${name}_${hash}, where hash includes filename and content of the file.\nnon-scoped: class names will not be hashed.\n\nWARNING\n\nBy default, Vitest exports a proxy, bypassing CSS Modules processing. If you rely on CSS properties on your classes, you have to enable CSS processing using include option.\n\nmaxConcurrency\n​\nType: number\nDefault: 5\n\nA number of tests that are allowed to run at the same time marked with test.concurrent.\n\nTest above this limit will be queued to run when available slot appears.\n\ncache *\n​\nType: false | { dir? }\n\nOptions to configure Vitest cache policy. At the moment Vitest stores cache for test results to run the longer and failed tests first.\n\ncache.dir\n​\nType: string\nDefault: node_modules/.vitest\n\nPath to cache directory.\n\nsequence\n​\nType: { sequencer?, shuffle?, seed?, hooks?, setupFiles? }\n\nOptions for how tests should be sorted.\n\nYou can provide sequence options to CLI with dot notation:\n\nsh\nnpx vitest --sequence.shuffle --sequence.seed=1000\nsequence.sequencer *\n​\nType: TestSequencerConstructor\nDefault: BaseSequencer\n\nA custom class that defines methods for sharding and sorting. You can extend BaseSequencer from vitest/node, if you only need to redefine one of the sort and shard methods, but both should exist.\n\nSharding is happening before sorting, and only if --shard option is provided.\n\nsequence.shuffle\n​\nType: boolean\nDefault: false\nCLI: --sequence.shuffle, --sequence.shuffle=false\n\nIf you want tests to run randomly, you can enable it with this option, or CLI argument --sequence.shuffle.\n\nVitest usually uses cache to sort tests, so long running tests start earlier - this makes tests run faster. If your tests will run in random order you will lose this performance improvement, but it may be useful to track tests that accidentally depend on another run previously.\n\nsequence.concurrent\n​\nType: boolean\nDefault: false\nCLI: --sequence.concurrent, --sequence.concurrent=false\nVersion: Since Vitest 0.32.2\n\nIf you want tests to run in parallel, you can enable it with this option, or CLI argument --sequence.concurrent.\n\nsequence.seed *\n​\nType: number\nDefault: Date.now()\nCLI: --sequence.seed=1000\n\nSets the randomization seed, if tests are running in random order.\n\nsequence.hooks\n​\nType: 'stack' | 'list' | 'parallel'\nDefault: 'parallel'\nCLI: --sequence.hooks=<value>\n\nChanges the order in which hooks are executed.\n\nstack will order \"after\" hooks in reverse order, \"before\" hooks will run in the order they were defined\nlist will order all hooks in the order they are defined\nparallel will run hooks in a single group in parallel (hooks in parent suites will still run before the current suite's hooks)\nsequence.setupFiles\n​\nType: 'list' | 'parallel'\nDefault: 'parallel'\nCLI: --sequence.setupFiles=<value>\nVersion: Since Vitest 0.29.3\n\nChanges the order in which setup files are executed.\n\nlist will run setup files in the order they are defined\nparallel will run setup files in parallel\ntypecheck\n​\n\nOptions for configuring typechecking test environment.\n\ntypecheck.enabled\n​\nType: boolean\nDefault: false\nCLI: --typecheck, --typecheck.enabled\nVersion: Since Vitest 1.0.0-beta.3\n\nEnable typechecking alongside your regular tests.\n\ntypecheck.only\n​\nType: boolean\nDefault: false\nCLI: --typecheck.only\nVersion: Since Vitest 1.0.0-beta.3\n\nRun only typecheck tests, when typechecking is enabled. When using CLI, this option will automatically enable typechecking.\n\ntypecheck.checker\n​\nType: 'tsc' | 'vue-tsc' | string\nDefault: tsc\n\nWhat tools to use for type checking. Vitest will spawn a process with certain parameters for easier parsing, depending on the type. Checker should implement the same output format as tsc.\n\nYou need to have a package installed to use typechecker:\n\ntsc requires typescript package\nvue-tsc requires vue-tsc package\n\nYou can also pass down a path to custom binary or command name that produces the same output as tsc --noEmit --pretty false.\n\ntypecheck.include\n​\nType: string[]\nDefault: ['**/*.{test,spec}-d.?(c|m)[jt]s?(x)']\n\nGlob pattern for files that should be treated as test files\n\ntypecheck.exclude\n​\nType: string[]\nDefault: ['**/node_modules/**', '**/dist/**', '**/cypress/**', '**/.{idea,git,cache,output,temp}/**']\n\nGlob pattern for files that should not be treated as test files\n\ntypecheck.allowJs\n​\nType: boolean\nDefault: false\n\nCheck JS files that have @ts-check comment. If you have it enabled in tsconfig, this will not overwrite it.\n\ntypecheck.ignoreSourceErrors\n​\nType: boolean\nDefault: false\n\nDo not fail, if Vitest found errors outside the test files. This will not show you non-test errors at all.\n\nBy default, if Vitest finds source error, it will fail test suite.\n\ntypecheck.tsconfig\n​\nType: string\nDefault: tries to find closest tsconfig.json\n\nPath to custom tsconfig, relative to the project root.\n\nslowTestThreshold *\n​\nType: number\nDefault: 300\n\nThe number of milliseconds after which a test is considered slow and reported as such in the results.\n\nchaiConfig\n​\nType: { includeStack?, showDiff?, truncateThreshold? }\nDefault: { includeStack: false, showDiff: true, truncateThreshold: 40 }\nVersion: Since Vitest 0.30.0\n\nEquivalent to Chai config.\n\nchaiConfig.includeStack\n​\nType: boolean\nDefault: false\n\nInfluences whether stack trace is included in Assertion error message. Default of false suppresses stack trace in the error message.\n\nchaiConfig.showDiff\n​\nType: boolean\nDefault: true\n\nInfluences whether or not the showDiff flag should be included in the thrown AssertionErrors. false will always be false; true will be true when the assertion has requested a diff to be shown.\n\nchaiConfig.truncateThreshold\n​\nType: number\nDefault: 40\n\nSets length threshold for actual and expected values in assertion errors. If this threshold is exceeded, for example for large data structures, the value is replaced with something like [ Array(3) ] or { Object (prop1, prop2) }. Set it to 0 if you want to disable truncating altogether.\n\nThis config option affects truncating values in test.each titles and inside the assertion error message.\n\nbail\n​\nType: number\nDefault: 0\nCLI: --bail=<value>\nVersion: Since Vitest 0.31.0\n\nStop test execution when given number of tests have failed.\n\nBy default Vitest will run all of your test cases even if some of them fail. This may not be desired for CI builds where you are only interested in 100% successful builds and would like to stop test execution as early as possible when test failures occur. The bail option can be used to speed up CI runs by preventing it from running more tests when failures have occurred.\n\nretry\n​\nType: number\nDefault: 0\nCLI: --retry=<value>\nVersion: Since Vitest 0.32.3\n\nRetry the test specific number of times if it fails.\n\nonConsoleLog\n​\nType: (log: string, type: 'stdout' | 'stderr') => false | void\n\nCustom handler for console.log in tests. If you return false, Vitest will not print the log to the console.\n\nCan be useful for filtering out logs from third-party libraries.\n\nts\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onConsoleLog(log: string, type: 'stdout' | 'stderr'): boolean | void {\n      if (log === 'message from third party library' && type === 'stdout')\n        return false\n    },\n  },\n})\nonStackTrace\n​\nType: (error: Error, frame: ParsedStack) => boolean | void\nVersion: Since Vitest 1.0.0-beta.3\n\nApply a filtering function to each frame of each stack trace when handling errors. The first argument, error, is an object with the same properties as a standard Error, but it is not an actual instance.\n\nCan be useful for filtering out stack trace frames from third-party libraries.\n\nts\nimport type { ParsedStack } from 'vitest'\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  test: {\n    onStackTrace(error: Error, { file }: ParsedStack): boolean | void {\n      // If we've encountered a ReferenceError, show the whole stack.\n      if (error.name === 'ReferenceError')\n        return\n\n      // Reject all frames from third party libraries.\n      if (file.includes('node_modules'))\n        return false\n    },\n  },\n})\ndiff\n​\nType: string\nCLI: --diff=<value>\nVersion: Since Vitest 0.34.5\n\nPath to a diff config that will be used to generate diff interface. Useful if you want to customize diff display.\n\nvitest.diff.ts\nvitest.config.js\nts\nimport type { DiffOptions } from 'vitest'\nimport c from 'picocolors'\n\nexport default {\n  aIndicator: c.bold('--'),\n  bIndicator: c.bold('++'),\n  omitAnnotationLines: true,\n} satisfies DiffOptions\nfakeTimers\n​\nType: FakeTimerInstallOpts\n\nOptions that Vitest will pass down to @sinon/fake-timers when using vi.useFakeTimers().\n\nfakeTimers.now\n​\nType: number | Date\nDefault: Date.now()\n\nInstalls fake timers with the specified Unix epoch.\n\nfakeTimers.toFake\n​\nType: FakeMethod[]\n\nAn array with names of global methods and APIs to fake. By default, Vitest does not replace nextTick() and queueMicrotask().\n\nTo only mock setTimeout() and nextTick(), specify this property as ['setTimeout', 'nextTick'].\n\nMocking nextTick is not supported when running Vitest inside node:child_process by using --pool=forks. NodeJS uses process.nextTick internally in node:child_process and hangs when it is mocked. Mocking nextTick is supported when running Vitest with --pool=threads.\n\nfakeTimers.loopLimit\n​\nType: number\nDefault: 10_000\n\nThe maximum number of timers that will be run when calling vi.runAllTimers().\n\nfakeTimers.shouldAdvanceTime\n​\nType: boolean\nDefault: false\n\nTells @sinonjs/fake-timers to increment mocked time automatically based on the real system time shift (e.g. the mocked time will be incremented by 20ms for every 20ms change in the real system time).\n\nfakeTimers.advanceTimeDelta\n​\nType: number\nDefault: 20\n\nRelevant only when using with shouldAdvanceTime: true. increment mocked time by advanceTimeDelta ms every advanceTimeDelta ms change in the real system time.\n\nfakeTimers.shouldClearNativeTimers\n​\nType: boolean\nDefault: false\n\nTells fake timers to clear \"native\" (i.e. not fake) timers by delegating to their respective handlers. These are not cleared by default, leading to potentially unexpected behavior if timers existed prior to starting fake timers session."
  },
  {
    "title": "assertType | Vitest",
    "url": "https://vitest.dev/api/assert-type",
    "html": "assertType\n​\n\nWARNING\n\nDuring runtime this function doesn't do anything. To enable typechecking, don't forget to pass down --typecheck flag.\n\nType: <T>(value: T): void\n\nYou can use this function as an alternative for expectTypeOf to easily assert that the argument type is equal to the generic provided.\n\nts\nimport { assertType } from 'vitest'\n\nfunction concat(a: string, b: string): string\nfunction concat(a: number, b: number): number\nfunction concat(a: string | number, b: string | number): string | number\n\nassertType<string>(concat('a', 'b'))\nassertType<number>(concat(1, 2))\n// @ts-expect-error wrong types\nassertType(concat('a', 2))"
  },
  {
    "title": "expect | Vitest",
    "url": "https://vitest.dev/api/expect",
    "html": "expect\n​\n\nThe following types are used in the type signatures below\n\nts\ntype Awaitable<T> = T | PromiseLike<T>\n\nexpect is used to create assertions. In this context assertions are functions that can be called to assert a statement. Vitest provides chai assertions by default and also Jest compatible assertions build on top of chai.\n\nFor example, this code asserts that an input value is equal to 2. If it's not, the assertion will throw an error, and the test will fail.\n\nts\nimport { expect } from 'vitest'\n\nconst input = Math.sqrt(4)\n\nexpect(input).to.equal(2) // chai API\nexpect(input).toBe(2) // jest API\n\nTechnically this example doesn't use test function, so in the console you will see Node.js error instead of Vitest output. To learn more about test, please read Test API Reference.\n\nAlso, expect can be used statically to access matcher functions, described later, and more.\n\nWARNING\n\nexpect has no effect on testing types, if the expression doesn't have a type error. If you want to use Vitest as type checker, use expectTypeOf or assertType.\n\nsoft\n​\nType: ExpectStatic & (actual: any) => Assertions\n\nexpect.soft functions similarly to expect, but instead of terminating the test execution upon a failed assertion, it continues running and marks the failure as a test failure. All errors encountered during the test will be displayed until the test is completed.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('expect.soft test', () => {\n  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue\n  expect.soft(1 + 2).toBe(4) // mark the test as fail and continue\n})\n// At the end of the test, the above errors will be output.\n\nIt can also be used with expect. if expect assertion fails, the test will be terminated and all errors will be displayed.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('expect.soft test', () => {\n  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue\n  expect(1 + 2).toBe(3) // failed and terminate the test, all previous errors will be output\n  expect.soft(1 + 2).toBe(4) // do not run\n})\n\nWARNING\n\nexpect.soft can only be used inside the test function.\n\nnot\n​\n\nUsing not will negate the assertion. For example, this code asserts that an input value is not equal to 2. If it's equal, the assertion will throw an error, and the test will fail.\n\nts\nimport { expect, test } from 'vitest'\n\nconst input = Math.sqrt(16)\n\nexpect(input).not.to.equal(2) // chai API\nexpect(input).not.toBe(2) // jest API\ntoBe\n​\nType: (value: any) => Awaitable<void>\n\ntoBe can be used to assert if primitives are equal or that objects share the same reference. It is equivalent of calling expect(Object.is(3, 3)).toBe(true). If the objects are not the same, but you want to check if their structures are identical, you can use toEqual.\n\nFor example, the code below checks if the trader has 13 apples.\n\nts\nimport { expect, test } from 'vitest'\n\nconst stock = {\n  type: 'apples',\n  count: 13,\n}\n\ntest('stock has 13 apples', () => {\n  expect(stock.type).toBe('apples')\n  expect(stock.count).toBe(13)\n})\n\ntest('stocks are the same', () => {\n  const refStock = stock // same reference\n\n  expect(stock).toBe(refStock)\n})\n\nTry not to use toBe with floating-point numbers. Since JavaScript rounds them, 0.1 + 0.2 is not strictly 0.3. To reliably assert floating-point numbers, use toBeCloseTo assertion.\n\ntoBeCloseTo\n​\nType: (value: number, numDigits?: number) => Awaitable<void>\n\nUse toBeCloseTo to compare floating-point numbers. The optional numDigits argument limits the number of digits to check after the decimal point. For example:\n\nts\nimport { expect, test } from 'vitest'\n\ntest.fails('decimals are not equal in javascript', () => {\n  expect(0.2 + 0.1).toBe(0.3) // 0.2 + 0.1 is 0.30000000000000004\n})\n\ntest('decimals are rounded to 5 after the point', () => {\n  // 0.2 + 0.1 is 0.30000 | \"000000000004\" removed\n  expect(0.2 + 0.1).toBeCloseTo(0.3, 5)\n  // nothing from 0.30000000000000004 is removed\n  expect(0.2 + 0.1).not.toBeCloseTo(0.3, 50)\n})\ntoBeDefined\n​\nType: () => Awaitable<void>\n\ntoBeDefined asserts that the value is not equal to undefined. Useful use case would be to check if function returned anything.\n\nts\nimport { expect, test } from 'vitest'\n\nfunction getApples() {\n  return 3\n}\n\ntest('function returned something', () => {\n  expect(getApples()).toBeDefined()\n})\ntoBeUndefined\n​\nType: () => Awaitable<void>\n\nOpposite of toBeDefined, toBeUndefined asserts that the value is equal to undefined. Useful use case would be to check if function hasn't returned anything.\n\nts\nimport { expect, test } from 'vitest'\n\nfunction getApplesFromStock(stock) {\n  if (stock === 'Bill')\n    return 13\n}\n\ntest('mary doesn\\'t have a stock', () => {\n  expect(getApplesFromStock('Mary')).toBeUndefined()\n})\ntoBeTruthy\n​\nType: () => Awaitable<void>\n\ntoBeTruthy asserts that the value is true when converted to boolean. Useful if you don't care for the value, but just want to know it can be converted to true.\n\nFor example, having this code you don't care for the return value of stocks.getInfo - it maybe a complex object, a string, or anything else. The code will still work.\n\nts\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\nstocks.sync('Bill')\nif (stocks.getInfo('Bill'))\n  stocks.sell('apples', 'Bill')\n\nSo if you want to test that stocks.getInfo will be truthy, you could write:\n\nts\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('if we know Bill stock, sell apples to him', () => {\n  stocks.sync('Bill')\n  expect(stocks.getInfo('Bill')).toBeTruthy()\n})\n\nEverything in JavaScript is truthy, except false, null, undefined, NaN, 0, -0, 0n, \"\" and document.all.\n\ntoBeFalsy\n​\nType: () => Awaitable<void>\n\ntoBeFalsy asserts that the value is false when converted to boolean. Useful if you don't care for the value, but just want to know if it can be converted to false.\n\nFor example, having this code you don't care for the return value of stocks.stockFailed - it may return any falsy value, but the code will still work.\n\nts\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\nstocks.sync('Bill')\nif (!stocks.stockFailed('Bill'))\n  stocks.sell('apples', 'Bill')\n\nSo if you want to test that stocks.stockFailed will be falsy, you could write:\n\nts\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('if Bill stock hasn\\'t failed, sell apples to him', () => {\n  stocks.syncStocks('Bill')\n  expect(stocks.stockFailed('Bill')).toBeFalsy()\n})\n\nEverything in JavaScript is truthy, except false, null, undefined, NaN, 0, -0, 0n, \"\" and document.all.\n\ntoBeNull\n​\nType: () => Awaitable<void>\n\ntoBeNull simply asserts if something is null. Alias for .toBe(null).\n\nts\nimport { expect, test } from 'vitest'\n\nfunction apples() {\n  return null\n}\n\ntest('we don\\'t have apples', () => {\n  expect(apples()).toBeNull()\n})\ntoBeNaN\n​\nType: () => Awaitable<void>\n\ntoBeNaN simply asserts if something is NaN. Alias for .toBe(NaN).\n\nts\nimport { expect, test } from 'vitest'\n\nlet i = 0\n\nfunction getApplesCount() {\n  i++\n  return i > 1 ? Number.NaN : i\n}\n\ntest('getApplesCount has some unusual side effects...', () => {\n  expect(getApplesCount()).not.toBeNaN()\n  expect(getApplesCount()).toBeNaN()\n})\ntoBeTypeOf\n​\nType: (c: 'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined') => Awaitable<void>\n\ntoBeTypeOf asserts if an actual value is of type of received type.\n\nts\nimport { expect, test } from 'vitest'\n\nconst actual = 'stock'\n\ntest('stock is type of string', () => {\n  expect(actual).toBeTypeOf('string')\n})\ntoBeInstanceOf\n​\nType: (c: any) => Awaitable<void>\n\ntoBeInstanceOf asserts if an actual value is instance of received class.\n\nts\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('stocks are instance of Stocks', () => {\n  expect(stocks).toBeInstanceOf(Stocks)\n})\ntoBeGreaterThan\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeGreaterThan asserts if actual value is greater than received one. Equal values will fail the test.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have more then 10 apples', () => {\n  expect(getApples()).toBeGreaterThan(10)\n})\ntoBeGreaterThanOrEqual\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeGreaterThanOrEqual asserts if actual value is greater than received one or equal to it.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or more', () => {\n  expect(getApples()).toBeGreaterThanOrEqual(11)\n})\ntoBeLessThan\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeLessThan asserts if actual value is less than received one. Equal values will fail the test.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have less then 20 apples', () => {\n  expect(getApples()).toBeLessThan(20)\n})\ntoBeLessThanOrEqual\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeLessThanOrEqual asserts if actual value is less than received one or equal to it.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or less', () => {\n  expect(getApples()).toBeLessThanOrEqual(11)\n})\ntoEqual\n​\nType: (received: any) => Awaitable<void>\n\ntoEqual asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively). You can see the difference between toEqual and toBe in this example:\n\nts\nimport { expect, test } from 'vitest'\n\nconst stockBill = {\n  type: 'apples',\n  count: 13,\n}\n\nconst stockMary = {\n  type: 'apples',\n  count: 13,\n}\n\ntest('stocks have the same properties', () => {\n  expect(stockBill).toEqual(stockMary)\n})\n\ntest('stocks are not the same', () => {\n  expect(stockBill).not.toBe(stockMary)\n})\n\nWARNING\n\nA deep equality will not be performed for Error objects. To test if something was thrown, use toThrowError assertion.\n\ntoStrictEqual\n​\nType: (received: any) => Awaitable<void>\n\ntoStrictEqual asserts if the actual value is equal to the received one or has the same structure if it is an object (compares them recursively), and of the same type.\n\nDifferences from .toEqual:\n\nKeys with undefined properties are checked. e.g. {a: undefined, b: 2} does not match {b: 2} when using .toStrictEqual.\nArray sparseness is checked. e.g. [, 1] does not match [undefined, 1] when using .toStrictEqual.\nObject types are checked to be equal. e.g. A class instance with fields a and b will not equal a literal object with fields a and b.\nts\nimport { expect, test } from 'vitest'\n\nclass Stock {\n  constructor(type) {\n    this.type = type\n  }\n}\n\ntest('structurally the same, but semantically different', () => {\n  expect(new Stock('apples')).toEqual({ type: 'apples' })\n  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })\n})\ntoContain\n​\nType: (received: string) => Awaitable<void>\n\ntoContain asserts if the actual value is in an array. toContain can also check whether a string is a substring of another string. Since Vitest 1.0, if you are running tests in a browser-like environment, this assertion can also check if class is contained in a classList, or an element is inside another one.\n\nts\nimport { expect, test } from 'vitest'\nimport { getAllFruits } from './stocks.js'\n\ntest('the fruit list contains orange', () => {\n  expect(getAllFruits()).toContain('orange')\n\n  const element = document.querySelector('#el')\n  // element has a class\n  expect(element.classList).toContain('flex')\n  // element is inside another one\n  expect(document.querySelector('#wrapper')).toContain(element)\n})\ntoContainEqual\n​\nType: (received: any) => Awaitable<void>\n\ntoContainEqual asserts if an item with a specific structure and values is contained in an array. It works like toEqual inside for each element.\n\nts\nimport { expect, test } from 'vitest'\nimport { getFruitStock } from './stocks.js'\n\ntest('apple available', () => {\n  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })\n})\ntoHaveLength\n​\nType: (received: number) => Awaitable<void>\n\ntoHaveLength asserts if an object has a .length property and it is set to a certain numeric value.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('toHaveLength', () => {\n  expect('abc').toHaveLength(3)\n  expect([1, 2, 3]).toHaveLength(3)\n\n  expect('').not.toHaveLength(3) // doesn't have .length of 3\n  expect({ length: 3 }).toHaveLength(3)\n})\ntoHaveProperty\n​\nType: (key: any, received?: any) => Awaitable<void>\n\ntoHaveProperty asserts if a property at provided reference key exists for an object.\n\nYou can provide an optional value argument also known as deep equality, like the toEqual matcher to compare the received property value.\n\nts\nimport { expect, test } from 'vitest'\n\nconst invoice = {\n  'isActive': true,\n  'P.O': '12345',\n  'customer': {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  'total_amount': 5000,\n  'items': [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\ntest('John Doe Invoice', () => {\n  expect(invoice).toHaveProperty('isActive') // assert that the key exists\n  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal\n\n  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist\n\n  // Deep referencing using dot notation\n  expect(invoice).toHaveProperty('customer.first_name')\n  expect(invoice).toHaveProperty('customer.last_name', 'Doe')\n  expect(invoice).not.toHaveProperty('customer.location', 'India')\n\n  // Deep referencing using an array containing the key\n  expect(invoice).toHaveProperty('items[0].type', 'apples')\n  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works\n\n  // Deep referencing using an array containing the keyPath\n  expect(invoice).toHaveProperty(['items', 0, 'type'], 'apples')\n  expect(invoice).toHaveProperty(['items', '0', 'type'], 'apples') // string notation also works\n\n  // Wrap your key in an array to avoid the key from being parsed as a deep reference\n  expect(invoice).toHaveProperty(['P.O'], '12345')\n})\ntoMatch\n​\nType: (received: string | regexp) => Awaitable<void>\n\ntoMatch asserts if a string matches a regular expression or a string.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('top fruits', () => {\n  expect('top fruits include apple, orange and grape').toMatch(/apple/)\n  expect('applefruits').toMatch('fruit') // toMatch also accepts a string\n})\n\nTIP\n\nIf the value in the error message is too truncated, you can increase chaiConfig.truncateThreshold in your config file.\n\ntoMatchObject\n​\nType: (received: object | array) => Awaitable<void>\n\ntoMatchObject asserts if an object matches a subset of the properties of an object.\n\nYou can also pass an array of objects. This is useful if you want to check that two arrays match in their number of elements, as opposed to arrayContaining, which allows for extra elements in the received array.\n\nts\nimport { expect, test } from 'vitest'\n\nconst johnInvoice = {\n  isActive: true,\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  total_amount: 5000,\n  items: [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\nconst johnDetails = {\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n}\n\ntest('invoice has john personal details', () => {\n  expect(johnInvoice).toMatchObject(johnDetails)\n})\n\ntest('the number of elements must match exactly', () => {\n  // Assert that an array of object matches\n  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([\n    { foo: 'bar' },\n    { baz: 1 },\n  ])\n})\ntoThrowError\n​\n\nType: (received: any) => Awaitable<void>\n\nAlias: toThrow\n\ntoThrowError asserts if a function throws an error when it is called.\n\nYou can provide an optional argument to test that a specific error is thrown:\n\nregular expression: error message matches the pattern\nstring: error message includes the substring\n\nTIP\n\nYou must wrap the code in a function, otherwise the error will not be caught, and test will fail.\n\nFor example, if we want to test that getFruitStock('pineapples') throws, we could write:\n\nts\nimport { expect, test } from 'vitest'\n\nfunction getFruitStock(type) {\n  if (type === 'pineapples')\n    throw new Error('Pineapples are not in stock')\n\n  // Do some other stuff\n}\n\ntest('throws on pineapples', () => {\n  // Test that the error message says \"stock\" somewhere: these are equivalent\n  expect(() => getFruitStock('pineapples')).toThrowError(/stock/)\n  expect(() => getFruitStock('pineapples')).toThrowError('stock')\n\n  // Test the exact error message\n  expect(() => getFruitStock('pineapples')).toThrowError(\n    /^Pineapples are not in stock$/,\n  )\n})\n\nTIP\n\nTo test async functions, use in combination with rejects.\n\njs\nfunction getAsyncFruitStock() {\n  return Promise.reject(new Error('empty'))\n}\n\ntest('throws on pineapples', async () => {\n  await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')\n})\ntoMatchSnapshot\n​\nType: <T>(shape?: Partial<T> | string, message?: string) => void\n\nThis ensures that a value matches the most recent snapshot.\n\nYou can provide an optional hint string argument that is appended to the test name. Although Vitest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate multiple snapshots in a single it or test block. Vitest sorts snapshots by name in the corresponding .snap file.\n\nTIP\n\nWhen snapshot mismatch and causing the test failing, if the mismatch is expected, you can press u key to update the snapshot for once. Or you can pass -u or --update CLI options to make Vitest always update the tests.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot()\n})\n\nYou can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot({ foo: expect.any(Set) })\n})\ntoMatchInlineSnapshot\n​\nType: <T>(shape?: Partial<T> | string, snapshot?: string, message?: string) => void\n\nThis ensures that a value matches the most recent snapshot.\n\nVitest adds and updates the inlineSnapshot string argument to the matcher in the test file (instead of an external .snap file).\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches inline snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  // Vitest will update following content when updating the snapshot\n  expect(data).toMatchInlineSnapshot(`\n    {\n      \"foo\": Set {\n        \"bar\",\n        \"snapshot\",\n      },\n    }\n  `)\n})\n\nYou can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchInlineSnapshot(\n    { foo: expect.any(Set) },\n    `\n    {\n      \"foo\": Any<Set>,\n    }\n  `\n  )\n})\ntoMatchFileSnapshot\n​\nType: <T>(filepath: string, message?: string) => Promise<void>\nVersion: Since Vitest 0.30.0\n\nCompare or update the snapshot with the content of a file explicitly specified (instead of the .snap file).\n\nts\nimport { expect, it } from 'vitest'\n\nit('render basic', async () => {\n  const result = renderHTML(h('div', { class: 'foo' }))\n  await expect(result).toMatchFileSnapshot('./test/basic.output.html')\n})\n\nNote that since file system operation is async, you need to use await with toMatchFileSnapshot().\n\ntoThrowErrorMatchingSnapshot\n​\nType: (message?: string) => void\n\nThe same as toMatchSnapshot, but expects the same value as toThrowError.\n\ntoThrowErrorMatchingInlineSnapshot\n​\nType: (snapshot?: string, message?: string) => void\n\nThe same as toMatchInlineSnapshot, but expects the same value as toThrowError.\n\ntoHaveBeenCalled\n​\nType: () => Awaitable<void>\n\nThis assertion is useful for testing that a function has been called. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  expect(buySpy).not.toHaveBeenCalled()\n\n  market.buy('apples', 10)\n\n  expect(buySpy).toHaveBeenCalled()\n})\ntoHaveBeenCalledTimes\n​\nType: (amount: number) => Awaitable<void>\n\nThis assertion checks if a function was called a certain amount of times. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function called two times', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledTimes(2)\n})\ntoHaveBeenCalledWith\n​\nType: (...args: any[]) => Awaitable<void>\n\nThis assertion checks if a function was called at least once with certain parameters. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenCalledWith('apples', 20)\n})\ntoHaveBeenLastCalledWith\n​\nType: (...args: any[]) => Awaitable<void>\n\nThis assertion checks if a function was called with certain parameters at it's last invocation. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)\n})\ntoHaveBeenNthCalledWith\n​\nType: (time: number, ...args: any[]) => Awaitable<void>\n\nThis assertion checks if a function was called with certain parameters at the certain time. The count starts at 1. So, to check the second entry, you would write .toHaveBeenNthCalledWith(2, ...).\n\nRequires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('first call of spy function called with right params', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)\n})\ntoHaveReturned\n​\nType: () => Awaitable<void>\n\nThis assertion checks if a function has successfully returned a value at least once (i.e., did not throw an error). Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nfunction getApplesPrice(amount: number) {\n  const PRICE = 10\n  return amount * PRICE\n}\n\ntest('spy function returned a value', () => {\n  const getPriceSpy = vi.fn(getApplesPrice)\n\n  const price = getPriceSpy(10)\n\n  expect(price).toBe(100)\n  expect(getPriceSpy).toHaveReturned()\n})\ntoHaveReturnedTimes\n​\nType: (amount: number) => Awaitable<void>\n\nThis assertion checks if a function has successfully returned a value exact amount of times (i.e., did not throw an error). Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a value two times', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveReturnedTimes(2)\n})\ntoHaveReturnedWith\n​\nType: (returnValue: any) => Awaitable<void>\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters at least once. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a product', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n\n  expect(sell).toHaveReturnedWith({ product: 'apples' })\n})\ntoHaveLastReturnedWith\n​\nType: (returnValue: any) => Awaitable<void>\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters on it's last invoking. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on a last call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })\n})\ntoHaveNthReturnedWith\n​\nType: (time: number, returnValue: any) => Awaitable<void>\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters on a certain call. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on second call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })\n})\ntoSatisfy\n​\nType: (predicate: (value: any) => boolean) => Awaitable<void>\n\nThis assertion checks if a value satisfies a certain predicate.\n\nts\ndescribe('toSatisfy()', () => {\n  const isOdd = (value: number) => value % 2 !== 0\n\n  it('pass with 0', () => {\n    expect(1).toSatisfy(isOdd)\n  })\n\n  it('pass with negotiation', () => {\n    expect(2).not.toSatisfy(isOdd)\n  })\n})\nresolves\n​\nType: Promisify<Assertions>\n\nresolves is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap value from the pending promise and assert its value with usual assertions. If the promise rejects, the assertion will fail.\n\nIt returns the same Assertions object, but all matchers now return Promise, so you would need to await it. Also works with chai assertions.\n\nFor example, if you have a function, that makes an API call and returns some data, you may use this code to assert its return value:\n\nts\nimport { expect, test } from 'vitest'\n\nasync function buyApples() {\n  return fetch('/buy/apples').then(r => r.json())\n}\n\ntest('buyApples returns new stock id', async () => {\n  // toEqual returns a promise now, so you HAVE to await it\n  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API\n  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API\n})\n\nWARNING\n\nIf the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions are actually called, you may use expect.assertions(number).\n\nrejects\n​\nType: Promisify<Assertions>\n\nrejects is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap reason why the promise was rejected, and assert its value with usual assertions. If the promise successfully resolves, the assertion will fail.\n\nIt returns the same Assertions object, but all matchers now return Promise, so you would need to await it. Also works with chai assertions.\n\nFor example, if you have a function that fails when you call it, you may use this code to assert the reason:\n\nts\nimport { expect, test } from 'vitest'\n\nasync function buyApples(id) {\n  if (!id)\n    throw new Error('no id')\n}\n\ntest('buyApples throws an error when no id provided', async () => {\n  // toThrow returns a promise now, so you HAVE to await it\n  await expect(buyApples()).rejects.toThrow('no id')\n})\n\nWARNING\n\nIf the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions were actually called, you can use expect.assertions(number).\n\nexpect.assertions\n​\nType: (count: number) => void\n\nAfter the test has passed or failed verify that a certain number of assertions was called during a test. A useful case would be to check if an asynchronous code was called.\n\nFor example, if we have a function that asynchronously calls two matchers, we can assert that they were actually called.\n\nts\nimport { expect, test } from 'vitest'\n\nasync function doAsync(...cbs) {\n  await Promise.all(\n    cbs.map((cb, index) => cb({ index })),\n  )\n}\n\ntest('all assertions are called', async () => {\n  expect.assertions(2)\n  function callback1(data) {\n    expect(data).toBeTruthy()\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy()\n  }\n\n  await doAsync(callback1, callback2)\n})\n\nWARNING\n\nWhen using assertions with async concurrent tests, expect from the local Test Context must be used to ensure the right test is detected.\n\nexpect.hasAssertions\n​\nType: () => void\n\nAfter the test has passed or failed verify that at least one assertion was called during a test. A useful case would be to check if an asynchronous code was called.\n\nFor example, if you have a code that calls a callback, we can make an assertion inside a callback, but the test will always pass if we don't check if an assertion was called.\n\nts\nimport { expect, test } from 'vitest'\nimport { db } from './db.js'\n\nconst cbs = []\n\nfunction onSelect(cb) {\n  cbs.push(cb)\n}\n\n// after selecting from db, we call all callbacks\nfunction select(id) {\n  return db.select({ id }).then((data) => {\n    return Promise.all(\n      cbs.map(cb => cb(data)),\n    )\n  })\n}\n\ntest('callback was called', async () => {\n  expect.hasAssertions()\n  onSelect((data) => {\n    // should be called on select\n    expect(data).toBeTruthy()\n  })\n  // if not awaited, test will fail\n  // if you don't have expect.hasAssertions(), test will pass\n  await select(3)\n})\nexpect.unreachable\n​\nType: (message?: string) => never\n\nThis method is used to asserting that a line should never be reached.\n\nFor example, if we want to test that build() throws due to receiving directories having no src folder, and also handle each error separately, we could do this:\n\nts\nimport { expect, test } from 'vitest'\n\nasync function build(dir) {\n  if (dir.includes('no-src'))\n    throw new Error(`${dir}/src does not exist`)\n}\n\nconst errorDirs = [\n  'no-src-folder',\n  // ...\n]\n\ntest.each(errorDirs)('build fails with \"%s\"', async (dir) => {\n  try {\n    await build(dir)\n    expect.unreachable('Should not pass build')\n  }\n  catch (err: any) {\n    expect(err).toBeInstanceOf(Error)\n    expect(err.stack).toContain('build')\n\n    switch (dir) {\n      case 'no-src-folder':\n        expect(err.message).toBe(`${dir}/src does not exist`)\n        break\n      default:\n        // to exhaust all error tests\n        expect.unreachable('All error test must be handled')\n        break\n    }\n  }\n})\nexpect.anything\n​\nType: () => any\n\nThis asymmetric matcher, when used with equality check, will always return true. Useful, if you just want to be sure that the property exist.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('object has \"apples\" key', () => {\n  expect({ apples: 22 }).toEqual({ apples: expect.anything() })\n})\nexpect.any\n​\nType: (constructor: unknown) => any\n\nThis asymmetric matcher, when used with an equality check, will return true only if the value is an instance of a specified constructor. Useful, if you have a value that is generated each time, and you only want to know that it exists with a proper type.\n\nts\nimport { expect, test } from 'vitest'\nimport { generateId } from './generators.js'\n\ntest('\"id\" is a number', () => {\n  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })\n})\nexpect.closeTo\n​\nType: (expected: any, precision?: number) => any\nVersion: Since Vitest 1.0.0\n\nexpect.closeTo is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use .toBeCloseTo instead.\n\nThe optional numDigits argument limits the number of digits to check after the decimal point. For the default value 2, the test criterion is Math.abs(expected - received) < 0.005 (that is, 10 ** -2 / 2).\n\nFor example, this test passes with a precision of 5 digits:\n\njs\ntest('compare float in object properties', () => {\n  expect({\n    title: '0.1 + 0.2',\n    sum: 0.1 + 0.2,\n  }).toEqual({\n    title: '0.1 + 0.2',\n    sum: expect.closeTo(0.3, 5),\n  })\n})\nexpect.arrayContaining\n​\nType: <T>(expected: T[]) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value is an array and contains specified items.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('basket includes fuji', () => {\n  const basket = {\n    varieties: [\n      'Empire',\n      'Fuji',\n      'Gala',\n    ],\n    count: 3\n  }\n  expect(basket).toEqual({\n    count: 3,\n    varieties: expect.arrayContaining(['Fuji'])\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.objectContaining\n​\nType: (expected: any) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value has a similar shape.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('basket has empire apples', () => {\n  const basket = {\n    varieties: [\n      {\n        name: 'Empire',\n        count: 1,\n      }\n    ],\n  }\n  expect(basket).toEqual({\n    varieties: [\n      expect.objectContaining({ name: 'Empire' }),\n    ]\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.stringContaining\n​\nType: (expected: any) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value is a string and contains a specified substring.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('variety has \"Emp\" in its name', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringContaining('Emp'),\n    count: 1,\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.stringMatching\n​\nType: (expected: any) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value is a string and contains a specified substring or if the string matches a regular expression.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('variety ends with \"re\"', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringMatching(/re$/),\n    count: 1,\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.addSnapshotSerializer\n​\nType: (plugin: PrettyFormatPlugin) => void\n\nThis method adds custom serializers that are called when creating a snapshot. This is an advanced feature - if you want to know more, please read a guide on custom serializers.\n\nIf you are adding custom serializers, you should call this method inside setupFiles. This will affect every snapshot.\n\nTIP\n\nIf you previously used Vue CLI with Jest, you might want to install jest-serializer-vue. Otherwise, your snapshots will be wrapped in a string, which cases \" to be escaped.\n\nexpect.extend\n​\nType: (matchers: MatchersObject) => void\n\nYou can extend default matchers with your own. This function is used to extend the matchers object with custom matchers.\n\nWhen you define matchers that way, you also create asymmetric matchers that can be used like expect.stringContaining.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('custom matchers', () => {\n  expect.extend({\n    toBeFoo: (received, expected) => {\n      if (received !== 'foo') {\n        return {\n          message: () => `expected ${received} to be foo`,\n          pass: false,\n        }\n      }\n    },\n  })\n\n  expect('foo').toBeFoo()\n  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })\n})\n\nTIP\n\nIf you want your matchers to appear in every test, you should call this method inside setupFiles.\n\nThis function is compatible with Jest's expect.extend, so any library that uses it to create custom matchers will work with Vitest.\n\nIf you are using TypeScript, since Vitest 0.31.0 you can extend default Assertion interface in an ambient declaration file (e.g: vitest.d.ts) with the code below:\n\nts\ninterface CustomMatchers<R = unknown> {\n  toBeFoo(): R\n}\n\ndeclare module 'vitest' {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n\nWARNING\n\nDon't forget to include the ambient declaration file in your tsconfig.json.\n\nTIP\n\nIf you want to know more, checkout guide on extending matchers."
  },
  {
    "title": "expectTypeOf | Vitest",
    "url": "https://vitest.dev/api/expect-typeof",
    "html": "expectTypeOf\n​\n\nWARNING\n\nDuring runtime this function doesn't do anything. To enable typechecking, don't forget to pass down --typecheck flag.\n\nType: <T>(a: unknown) => ExpectTypeOf\nnot\n​\nType: ExpectTypeOf\n\nYou can negate all assertions, using .not property.\n\ntoEqualTypeOf\n​\nType: <T>(expected: T) => void\n\nThis matcher will check if the types are fully equal to each other. This matcher will not fail if two objects have different values, but the same type. It will fail however if an object is missing a property.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })\nexpectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()\ntoMatchTypeOf\n​\nType: <T>(expected: T) => void\n\nThis matcher checks if expect type extends provided type. It is different from toEqual and is more similar to expect's toMatchObject(). With this matcher, you can check if an object “matches” a type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1, b: 1 }).toMatchTypeOf({ a: 1 })\nexpectTypeOf<number>().toMatchTypeOf<string | number>()\nexpectTypeOf<string | number>().not.toMatchTypeOf<number>()\nextract\n​\nType: ExpectTypeOf<ExtractedUnion>\n\nYou can use .extract to narrow down types for further testing.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<{ xs?: any }>() // extracts the last type from a union\n  .toEqualTypeOf<{ xs?: CSSProperties; sm?: CSSProperties; md?: CSSProperties }>()\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<unknown[]>() // extracts an array from a union\n  .toEqualTypeOf<CSSProperties[]>()\n\nWARNING\n\nIf no type is found in the union, .extract will return never.\n\nexclude\n​\nType: ExpectTypeOf<NonExcludedUnion>\n\nYou can use .exclude to remove types from a union for further testing.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .exclude<unknown[]>()\n  .exclude<{ xs?: unknown }>() // or just .exclude<unknown[] | { xs?: unknown }>()\n  .toEqualTypeOf<CSSProperties>()\n\nWARNING\n\nIf no type is found in the union, .exclude will return never.\n\nreturns\n​\nType: ExpectTypeOf<ReturnValue>\n\nYou can use .returns to extract return value of a function type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nparameters\n​\nType: ExpectTypeOf<Parameters>\n\nYou can extract function arguments with .parameters to perform assertions on its value. Parameters are returned as an array.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().parameters.toEqualTypeOf<[]>()\nexpectTypeOf<HasParam>().parameters.toEqualTypeOf<[string]>()\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nTIP\n\nYou can also use .toBeCallableWith matcher as a more expressive assertion.\n\nparameter\n​\nType: (nth: number) => ExpectTypeOf\n\nYou can extract a certain function argument with .parameter(number) call to perform other assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nfunction foo(a: number, b: string) {\n  return [a, b]\n}\n\nexpectTypeOf(foo).parameter(0).toBeNumber()\nexpectTypeOf(foo).parameter(1).toBeString()\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nconstructorParameters\n​\nType: ExpectTypeOf<ConstructorParameters>\n\nYou can extract constructor parameters as an array of values and perform assertions on them with this method.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).constructorParameters.toEqualTypeOf<[] | [string | number | Date]>()\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nTIP\n\nYou can also use .toBeConstructibleWith matcher as a more expressive assertion.\n\ninstance\n​\nType: ExpectTypeOf<ConstructableInstance>\n\nThis property gives access to matchers that can be performed on an instance of the provided class.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).instance.toHaveProperty('toISOString')\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nitems\n​\nType: ExpectTypeOf<T>\n\nYou can get array item type with .items to perform further assertions.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf([1, 2, 3]).items.toEqualTypeOf<number>()\nexpectTypeOf([1, 2, 3]).items.not.toEqualTypeOf<string>()\nresolves\n​\nType: ExpectTypeOf<ResolvedPromise>\n\nThis matcher extracts resolved value of a Promise, so you can perform other assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nasync function asyncFunc() {\n  return 123\n}\n\nexpectTypeOf(asyncFunc).returns.resolves.toBeNumber()\nexpectTypeOf(Promise.resolve('string')).resolves.toBeString()\n\nWARNING\n\nIf used on a non-promise type, it will return never, so you won't be able to chain it with other matchers.\n\nguards\n​\nType: ExpectTypeOf<Guard>\n\nThis matcher extracts guard value (e.g., v is number), so you can perform assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nfunction isString(v: any): v is string {\n  return typeof v === 'string'\n}\nexpectTypeOf(isString).guards.toBeString()\n\nWARNING\n\nReturns never, if the value is not a guard function, so you won't be able to chain it with other matchers.\n\nasserts\n​\nType: ExpectTypeOf<Assert>\n\nThis matcher extracts assert value (e.g., assert v is number), so you can perform assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nfunction assertNumber(v: any): asserts v is number {\n  if (typeof v !== 'number')\n    throw new TypeError('Nope !')\n}\n\nexpectTypeOf(assertNumber).asserts.toBeNumber()\n\nWARNING\n\nReturns never, if the value is not an assert function, so you won't be able to chain it with other matchers.\n\ntoBeAny\n​\nType: () => void\n\nWith this matcher you can check, if provided type is any type. If the type is too specific, the test will fail.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<any>().toBeAny()\nexpectTypeOf({} as any).toBeAny()\nexpectTypeOf('string').not.toBeAny()\ntoBeUnknown\n​\nType: () => void\n\nThis matcher checks, if provided type is unknown type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf().toBeUnknown()\nexpectTypeOf({} as unknown).toBeUnknown()\nexpectTypeOf('string').not.toBeUnknown()\ntoBeNever\n​\nType: () => void\n\nThis matcher checks, if provided type is a never type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<never>().toBeNever()\nexpectTypeOf((): never => {}).returns.toBeNever()\ntoBeFunction\n​\nType: () => void\n\nThis matcher checks, if provided type is a function.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeFunction()\nexpectTypeOf((): never => {}).toBeFunction()\ntoBeObject\n​\nType: () => void\n\nThis matcher checks, if provided type is an object.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeObject()\nexpectTypeOf({}).toBeObject()\ntoBeArray\n​\nType: () => void\n\nThis matcher checks, if provided type is Array<T>.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeArray()\nexpectTypeOf([]).toBeArray()\nexpectTypeOf([1, 2]).toBeArray()\nexpectTypeOf([{}, 42]).toBeArray()\ntoBeString\n​\nType: () => void\n\nThis matcher checks, if provided type is a string.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeString()\nexpectTypeOf('').toBeString()\nexpectTypeOf('a').toBeString()\ntoBeBoolean\n​\nType: () => void\n\nThis matcher checks, if provided type is boolean.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeBoolean()\nexpectTypeOf(true).toBeBoolean()\nexpectTypeOf<boolean>().toBeBoolean()\ntoBeVoid\n​\nType: () => void\n\nThis matcher checks, if provided type is void.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf<void>().toBeVoid()\ntoBeSymbol\n​\nType: () => void\n\nThis matcher checks, if provided type is a symbol.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Symbol(1)).toBeSymbol()\nexpectTypeOf<symbol>().toBeSymbol()\ntoBeNull\n​\nType: () => void\n\nThis matcher checks, if provided type is null.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(null).toBeNull()\nexpectTypeOf<null>().toBeNull()\nexpectTypeOf(undefined).not.toBeNull()\ntoBeUndefined\n​\nType: () => void\n\nThis matcher checks, if provided type is undefined.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(undefined).toBeUndefined()\nexpectTypeOf<undefined>().toBeUndefined()\nexpectTypeOf(null).not.toBeUndefined()\ntoBeNullable\n​\nType: () => void\n\nThis matcher checks, if you can use null or undefined with provided type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<1 | undefined>().toBeNullable()\nexpectTypeOf<1 | null>().toBeNullable()\nexpectTypeOf<1 | undefined | null>().toBeNullable()\ntoBeCallableWith\n​\nType: () => void\n\nThis matcher ensures you can call provided function with a set of parameters.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().toBeCallableWith()\nexpectTypeOf<HasParam>().toBeCallableWith('some string')\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\ntoBeConstructibleWith\n​\nType: () => void\n\nThis matcher ensures you can create a new instance with a set of constructor parameters.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).toBeConstructibleWith(new Date())\nexpectTypeOf(Date).toBeConstructibleWith('01-01-2000')\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\ntoHaveProperty\n​\nType: <K extends keyof T>(property: K) => ExpectTypeOf<T[K>\n\nThis matcher checks if a property exists on the provided object. If it exists, it also returns the same set of matchers for the type of this property, so you can chain assertions one after another.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nconst obj = { a: 1, b: '' }\n\nexpectTypeOf(obj).toHaveProperty('a')\nexpectTypeOf(obj).not.toHaveProperty('c')\n\nexpectTypeOf(obj).toHaveProperty('a').toBeNumber()\nexpectTypeOf(obj).toHaveProperty('b').toBeString()\nexpectTypeOf(obj).toHaveProperty('a').not.toBeString()"
  },
  {
    "title": "Vi | Vitest",
    "url": "https://vitest.dev/api/vi",
    "html": "Vi\n​\n\nVitest provides utility functions to help you out through its vi helper. You can access it globally (when globals configuration is enabled), or import it from vitest directly:\n\njs\nimport { vi } from 'vitest'\nMock Modules\n​\n\nThis section describes the API that you can use when mocking a module. Beware that Vitest doesn't support mocking modules imported using require().\n\nvi.mock\n​\nType: (path: string, factory?: (importOriginal: () => unknown) => unknown) => void\n\nSubstitutes all imported modules from provided path with another module. You can use configured Vite aliases inside a path. The call to vi.mock is hoisted, so it doesn't matter where you call it. It will always be executed before all imports. If you need to reference some variables outside of its scope, you can define them inside vi.hoisted and reference them inside vi.mock.\n\nWARNING\n\nvi.mock works only for modules that were imported with the import keyword. It doesn't work with require.\n\nIn order to hoist vi.mock, Vitest statically analyzes your files. It indicates that vi that was not directly imported from the vitest package (for example, from some utility file) cannot be used. Use vi.mock with vi imported from vitest, or enable globals config option.\n\nVitest will not mock modules that were imported inside a setup file because they are cached by the time a test file is running. You can call vi.resetModules() inside vi.hoisted to clear all module caches before running a test file.\n\nWARNING\n\nThe browser mode does not presently support mocking modules. You can track this feature in the GitHub issue.\n\nIf factory is defined, all imports will return its result. Vitest calls factory only once and caches results for all subsequent imports until vi.unmock or vi.doUnmock is called.\n\nUnlike in jest, the factory can be asynchronous, so you can use vi.importActual or a helper, received as the first argument, inside to get the original module.\n\njs\n// when using JavaScript\n\nvi.mock('./path/to/module.js', async (importOriginal) => {\n  const mod = await importOriginal()\n  return {\n    ...mod,\n    // replace some exports\n    namedExport: vi.fn(),\n  }\n})\nts\n// when using TypeScript\n\nvi.mock('./path/to/module.js', async (importOriginal) => {\n  const mod = await importOriginal<typeof import('./path/to/module.js')>()\n  return {\n    ...mod,\n    // replace some exports\n    namedExport: vi.fn(),\n  }\n})\n\nWARNING\n\nvi.mock is hoisted (in other words, moved) to top of the file. It means that whenever you write it (be it inside beforeEach or test), it will actually be called before that.\n\nThis also means that you cannot use any variables inside the factory that are defined outside the factory.\n\nIf you need to use variables inside the factory, try vi.doMock. It works the same way but isn't hoisted. Beware that it only mocks subsequent imports.\n\nYou can also reference variables defined by vi.hoisted method if it was declared before vi.mock:\n\nts\nimport { namedExport } from './path/to/module.js'\n\nconst mocks = vi.hoisted(() => {\n  return {\n    namedExport: vi.fn(),\n  }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return {\n    namedExport: mocks.namedExport,\n  }\n})\n\nvi.mocked(namedExport).mockReturnValue(100)\n\nexpect(namedExport()).toBe(100)\nexpect(namedExport).toBe(mocks.namedExport)\n\nWARNING\n\nIf you are mocking a module with default export, you will need to provide a default key within the returned factory function object. This is an ES module-specific caveat; therefore, jest documentation may differ as jest uses CommonJS modules. For example,\n\nts\nvi.mock('./path/to/module.js', () => {\n  return {\n    default: { myDefaultKey: vi.fn() },\n    namedExport: vi.fn(),\n    // etc...\n  }\n})\n\nIf there is a __mocks__ folder alongside a file that you are mocking, and the factory is not provided, Vitest will try to find a file with the same name in the __mocks__ subfolder and use it as an actual module. If you are mocking a dependency, Vitest will try to find a __mocks__ folder in the root of the project (default is process.cwd()). You can tell Vitest where the dependencies are located through the deps.moduleDirectories config option.\n\nFor example, you have this file structure:\n\n- __mocks__\n  - axios.js\n- src\n  __mocks__\n    - increment.js\n  - increment.js\n- tests\n  - increment.test.js\n\nIf you call vi.mock in a test file without a factory provided, it will find a file in the __mocks__ folder to use as a module:\n\nts\n// increment.test.js\nimport { vi } from 'vitest'\n\n// axios is a default export from `__mocks__/axios.js`\nimport axios from 'axios'\n\n// increment is a named export from `src/__mocks__/increment.js`\nimport { increment } from '../increment.js'\n\nvi.mock('axios')\nvi.mock('../increment.js')\n\naxios.get(`/apples/${increment(1)}`)\n\nWARNING\n\nBeware that if you don't call vi.mock, modules are not mocked automatically. To replicate Jest's automocking behaviour, you can call vi.mock for each required module inside setupFiles.\n\nIf there is no __mocks__ folder or a factory provided, Vitest will import the original module and auto-mock all its exports. For the rules applied, see algorithm.\n\nvi.doMock\n​\nType: (path: string, factory?: (importOriginal: () => unknown) => unknown) => void\n\nThe same as vi.mock, but it's not hoisted to the top of the file, so you can reference variables in the global file scope. The next dynamic import of the module will be mocked.\n\nWARNING\n\nThis will not mock modules that were imported before this was called. Don't forget that all static imports in ESM are always hoisted, so putting this before static import will not force it to be called before the import:\n\nts\nvi.doMock('./increment.js') // this will be called _after_ the import statement\n\nimport { increment } from './increment.js'\nts\n// ./increment.js\nexport function increment(number) {\n  return number + 1\n}\nts\nimport { beforeEach, test } from 'vitest'\nimport { increment } from './increment.js'\n\n// the module is not mocked, because vi.doMock is not called yet\nincrement(1) === 2\n\nlet mockedIncrement = 100\n\nbeforeEach(() => {\n  // you can access variables inside a factory\n  vi.doMock('./increment.js', () => ({ increment: () => ++mockedIncrement }))\n})\n\ntest('importing the next module imports mocked one', async () => {\n  // original import WAS NOT MOCKED, because vi.doMock is evaluated AFTER imports\n  expect(increment(1)).toBe(2)\n  const { increment: mockedIncrement } = await import('./increment.js')\n  // new dynamic import returns mocked module\n  expect(mockedIncrement(1)).toBe(101)\n  expect(mockedIncrement(1)).toBe(102)\n  expect(mockedIncrement(1)).toBe(103)\n})\nvi.mocked\n​\nType: <T>(obj: T, deep?: boolean) => MaybeMockedDeep<T>\nType: <T>(obj: T, options?: { partial?: boolean; deep?: boolean }) => MaybePartiallyMockedDeep<T>\n\nType helper for TypeScript. Just returns the object that was passed.\n\nWhen partial is true it will expect a Partial<T> as a return value. By default, this will only make TypeScript believe that the first level values are mocked. You can pass down { deep: true } as a second argument to tell TypeScript that the whole object is mocked, if it actually is.\n\nts\nimport example from './example.js'\n\nvi.mock('./example.js')\n\ntest('1 + 1 equals 10', async () => {\n  vi.mocked(example.calc).mockReturnValue(10)\n  expect(example.calc(1, '+', 1)).toBe(10)\n})\nvi.importActual\n​\nType: <T>(path: string) => Promise<T>\n\nImports module, bypassing all checks if it should be mocked. Can be useful if you want to mock module partially.\n\nts\nvi.mock('./example.js', async () => {\n  const axios = await vi.importActual('./example.js')\n\n  return { ...axios, get: vi.fn() }\n})\nvi.importMock\n​\nType: <T>(path: string) => Promise<MaybeMockedDeep<T>>\n\nImports a module with all of its properties (including nested properties) mocked. Follows the same rules that vi.mock does. For the rules applied, see algorithm.\n\nvi.unmock\n​\nType: (path: string) => void\n\nRemoves module from the mocked registry. All calls to import will return the original module even if it was mocked before. This call is hoisted to the top of the file, so it will only unmock modules that were defined in setupFiles, for example.\n\nvi.doUnmock\n​\nType: (path: string) => void\n\nThe same as vi.unmock, but is not hoisted to the top of the file. The next import of the module will import the original module instead of the mock. This will not unmock previously imported modules.\n\nts\n// ./increment.js\nexport function increment(number) {\n  return number + 1\n}\nts\nimport { increment } from './increment.js'\n\n// increment is already mocked, because vi.mock is hoisted\nincrement(1) === 100\n\n// this is hoisted, and factory is called before the import on line 1\nvi.mock('./increment.js', () => ({ increment: () => 100 }))\n\n// all calls are mocked, and `increment` always returns 100\nincrement(1) === 100\nincrement(30) === 100\n\n// this is not hoisted, so other import will return unmocked module\nvi.doUnmock('./increment.js')\n\n// this STILL returns 100, because `vi.doUnmock` doesn't reevaluate a module\nincrement(1) === 100\nincrement(30) === 100\n\n// the next import is unmocked, now `increment` is the original function that returns count + 1\nconst { increment: unmockedIncrement } = await import('./increment.js')\n\nunmockedIncrement(1) === 2\nunmockedIncrement(30) === 31\nvi.resetModules\n​\nType: () => Vitest\n\nResets modules registry by clearing the cache of all modules. This allows modules to be reevaluated when reimported. Top-level imports cannot be re-evaluated. Might be useful to isolate modules where local state conflicts between tests.\n\nts\nimport { vi } from 'vitest'\n\nimport { data } from './data.js' // Will not get reevaluated beforeEach test\n\nbeforeEach(() => {\n  vi.resetModules()\n})\n\ntest('change state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  mod.changeLocalState('new value')\n  expect(mod.getLocalState()).toBe('new value')\n})\n\ntest('module has old state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  expect(mod.getLocalState()).toBe('old value')\n})\n\nWARNING\n\nDoes not reset mocks registry. To clear mocks registry, use vi.unmock or vi.doUnmock.\n\nvi.dynamicImportSettled\n​\n\nWait for all imports to load. Useful, if you have a synchronous call that starts importing a module that you cannot wait otherwise.\n\nts\nimport { expect, test } from 'vitest'\n\n// cannot track import because Promise is not returned\nfunction renderComponent() {\n  import('./component.js').then(({ render }) => {\n    render()\n  })\n}\n\ntest('operations are resolved', async () => {\n  renderComponent()\n  await vi.dynamicImportSettled()\n  expect(document.querySelector('.component')).not.toBeNull()\n})\n\nTIP\n\nIf during a dynamic import another dynamic import is initiated, this method will wait until all of them are resolved.\n\nThis method will also wait for the next setTimeout tick after the import is resolved so all synchronous operations should be completed by the time it's resolved.\n\nMocking Functions and Objects\n​\n\nThis section describes how to work with method mocks and replace environmental and global variables.\n\nvi.fn\n​\nType: (fn?: Function) => Mock\n\nCreates a spy on a function, though can be initiated without one. Every time a function is invoked, it stores its call arguments, returns, and instances. Also, you can manipulate its behavior with methods. If no function is given, mock will return undefined, when invoked.\n\nts\nconst getApples = vi.fn(() => 0)\n\ngetApples()\n\nexpect(getApples).toHaveBeenCalled()\nexpect(getApples).toHaveReturnedWith(0)\n\ngetApples.mockReturnValueOnce(5)\n\nconst res = getApples()\nexpect(res).toBe(5)\nexpect(getApples).toHaveNthReturnedWith(2, 5)\nvi.isMockFunction\n​\nType: (fn: Function) => boolean\n\nChecks that a given parameter is a mock function. If you are using TypeScript, it will also narrow down its type.\n\nvi.clearAllMocks\n​\n\nWill call .mockClear() on all spies. This will clear mock history, but not reset its implementation to the default one.\n\nvi.resetAllMocks\n​\n\nWill call .mockReset() on all spies. This will clear mock history and reset its implementation to an empty function (will return undefined).\n\nvi.restoreAllMocks\n​\n\nWill call .mockRestore() on all spies. This will clear mock history and reset its implementation to the original one.\n\nvi.spyOn\n​\nType: <T, K extends keyof T>(object: T, method: K, accessType?: 'get' | 'set') => MockInstance\n\nCreates a spy on a method or getter/setter of an object similar to vi.fn(). It returns a mock function.\n\nts\nlet apples = 0\nconst cart = {\n  getApples: () => 42,\n}\n\nconst spy = vi.spyOn(cart, 'getApples').mockImplementation(() => apples)\napples = 1\n\nexpect(cart.getApples()).toBe(1)\n\nexpect(spy).toHaveBeenCalled()\nexpect(spy).toHaveReturnedWith(1)\n\nTIP\n\nYou can call vi.restoreAllMocks inside afterEach (or enable test.restoreMocks) to restore all methods to their original implementations. This will restore the original object descriptor, so you won't be able to change method's implementation:\n\nts\nconst cart = {\n  getApples: () => 42,\n}\n\nconst spy = vi.spyOn(cart, 'getApples').mockReturnValue(10)\n\nconsole.log(cart.getApples()) // 10\nvi.restoreAllMocks()\nconsole.log(cart.getApples()) // 42\nspy.mockReturnValue(10)\nconsole.log(cart.getApples()) // still 42!\nvi.stubEnv\n​\nType: (name: string, value: string) => Vitest\nVersion: Since Vitest 0.26.0\n\nChanges the value of environmental variable on process.env and import.meta.env. You can restore its value by calling vi.unstubAllEnvs.\n\nts\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling \"vi.stubEnv\"\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n// doesn't change other envs\nimport.meta.env.MODE === 'development'\n\nTIP\n\nYou can also change the value by simply assigning it, but you won't be able to use vi.unstubAllEnvs to restore previous value:\n\nts\nimport.meta.env.MODE = 'test'\nvi.unstubAllEnvs\n​\nType: () => Vitest\nVersion: Since Vitest 0.26.0\n\nRestores all import.meta.env and process.env values that were changed with vi.stubEnv. When it's called for the first time, Vitest remembers the original value and will store it, until unstubAllEnvs is called again.\n\nts\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling stubEnv\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n\nvi.stubEnv('NODE_ENV', 'staging')\n\nprocess.env.NODE_ENV === 'staging'\nimport.meta.env.NODE_ENV === 'staging'\n\nvi.unstubAllEnvs()\n\n// restores to the value that were stored before the first \"stubEnv\" call\nprocess.env.NODE_ENV === 'development'\nimport.meta.env.NODE_ENV === 'development'\nvi.stubGlobal\n​\nType: (name: string | number | symbol, value: unknown) => Vitest\n\nChanges the value of global variable. You can restore its original value by calling vi.unstubAllGlobals.\n\nts\nimport { vi } from 'vitest'\n\n// `innerWidth` is \"0\" before calling stubGlobal\n\nvi.stubGlobal('innerWidth', 100)\n\ninnerWidth === 100\nglobalThis.innerWidth === 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth === 100\n\nTIP\n\nYou can also change the value by simply assigning it to globalThis or window (if you are using jsdom or happy-dom environment), but you won't be able to use vi.unstubAllGlobals to restore original value:\n\nts\nglobalThis.innerWidth = 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth = 100\nvi.unstubAllGlobals\n​\nType: () => Vitest\nVersion: Since Vitest 0.26.0\n\nRestores all global values on globalThis/global (and window/top/self/parent, if you are using jsdom or happy-dom environment) that were changed with vi.stubGlobal. When it's called for the first time, Vitest remembers the original value and will store it, until unstubAllGlobals is called again.\n\nts\nimport { vi } from 'vitest'\n\nconst Mock = vi.fn()\n\n// IntersectionObserver is \"undefined\" before calling \"stubGlobal\"\n\nvi.stubGlobal('IntersectionObserver', Mock)\n\nIntersectionObserver === Mock\nglobal.IntersectionObserver === Mock\nglobalThis.IntersectionObserver === Mock\n// if you are using jsdom or happy-dom\nwindow.IntersectionObserver === Mock\n\nvi.unstubAllGlobals()\n\nglobalThis.IntersectionObserver === undefined\n'IntersectionObserver' in globalThis === false\n// throws ReferenceError, because it's not defined\nIntersectionObserver === undefined\nFake Timers\n​\n\nThis sections descibes how to work with fake timers.\n\nvi.advanceTimersByTime\n​\nType: (ms: number) => Vitest\n\nThis method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first.\n\nts\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersByTime(150)\n\n// log: 1\n// log: 2\n// log: 3\nvi.advanceTimersByTimeAsync\n​\nType: (ms: number) => Promise<Vitest>\n\nThis method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first. This will include asynchronously set timers.\n\nts\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersByTimeAsync(150)\n\n// log: 1\n// log: 2\n// log: 3\nvi.advanceTimersToNextTimer\n​\nType: () => Vitest\n\nWill call next available timer. Useful to make assertions between each timer call. You can chain call it to manage timers by yourself.\n\nts\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersToNextTimer() // log: 1\n  .advanceTimersToNextTimer() // log: 2\n  .advanceTimersToNextTimer() // log: 3\nvi.advanceTimersToNextTimerAsync\n​\nType: () => Promise<Vitest>\n\nWill call next available timer and wait until it's resolved if it was set asynchronously. Useful to make assertions between each timer call.\n\nts\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 1\nexpect(console.log).toHaveBeenCalledWith(1)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 2\nawait vi.advanceTimersToNextTimerAsync() // log: 3\nvi.getTimerCount\n​\nType: () => number\n\nGet the number of waiting timers.\n\nvi.clearAllTimers\n​\n\nRemoves all timers that are scheduled to run. These timers will never run in the future.\n\nvi.getMockedSystemTime\n​\nType: () => Date | null\n\nReturns mocked current date that was set using setSystemTime. If date is not mocked the method will return null.\n\nvi.getRealSystemTime\n​\nType: () => number\n\nWhen using vi.useFakeTimers, Date.now calls are mocked. If you need to get real time in milliseconds, you can call this function.\n\nvi.runAllTicks\n​\nType: () => Vitest\n\nCalls every microtask that was queued by process.nextTick. This will also run all microtasks scheduled by themselves.\n\nvi.runAllTimers\n​\nType: () => Vitest\n\nThis method will invoke every initiated timer until the timer queue is empty. It means that every timer called during runAllTimers will be fired. If you have an infinite interval, it will throw after 10 000 tries (can be configured with fakeTimers.loopLimit).\n\nts\nlet i = 0\nsetTimeout(() => console.log(++i))\nconst interval = setInterval(() => {\n  console.log(++i)\n  if (i === 3)\n    clearInterval(interval)\n}, 50)\n\nvi.runAllTimers()\n\n// log: 1\n// log: 2\n// log: 3\nvi.runAllTimersAsync\n​\nType: () => Promise<Vitest>\n\nThis method will asynchronously invoke every initiated timer until the timer queue is empty. It means that every timer called during runAllTimersAsync will be fired even asynchronous timers. If you have an infinite interval, it will throw after 10 000 tries (can be configured with fakeTimers.loopLimit).\n\nts\nsetTimeout(async () => {\n  console.log(await Promise.resolve('result'))\n}, 100)\n\nawait vi.runAllTimersAsync()\n\n// log: result\nvi.runOnlyPendingTimers\n​\nType: () => Vitest\n\nThis method will call every timer that was initiated after vi.useFakeTimers call. It will not fire any timer that was initiated during its call.\n\nts\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.runOnlyPendingTimers()\n\n// log: 1\nvi.runOnlyPendingTimersAsync\n​\nType: () => Promise<Vitest>\n\nThis method will asynchronously call every timer that was initiated after vi.useFakeTimers call, even asynchronous ones. It will not fire any timer that was initiated during its call.\n\nts\nsetTimeout(() => {\n  console.log(1)\n}, 100)\nsetTimeout(() => {\n  Promise.resolve().then(() => {\n    console.log(2)\n    setInterval(() => {\n      console.log(3)\n    }, 40)\n  })\n}, 10)\n\nawait vi.runOnlyPendingTimersAsync()\n\n// log: 2\n// log: 3\n// log: 3\n// log: 1\nvi.setSystemTime\n​\nType: (date: string | number | Date) => void\n\nIf fake timers are enabled, this method simulates a user changing the system clock (will affect date related API like hrtime, performance.now or new Date()) - however, it will not fire any timers. If fake timers are not enabled, this method will only mock Date.* calls.\n\nUseful if you need to test anything that depends on the current date - for example Luxon calls inside your code.\n\nts\nconst date = new Date(1998, 11, 19)\n\nvi.useFakeTimers()\nvi.setSystemTime(date)\n\nexpect(Date.now()).toBe(date.valueOf())\n\nvi.useRealTimers()\nvi.useFakeTimers\n​\nType: () => Vitest\n\nTo enable mocking timers, you need to call this method. It will wrap all further calls to timers (such as setTimeout, setInterval, clearTimeout, clearInterval, nextTick, setImmediate, clearImmediate, and Date), until vi.useRealTimers() is called.\n\nMocking nextTick is not supported when running Vitest inside node:child_process by using --pool=forks. NodeJS uses process.nextTick internally in node:child_process and hangs when it is mocked. Mocking nextTick is supported when running Vitest with --pool=threads.\n\nThe implementation is based internally on @sinonjs/fake-timers.\n\nTIP\n\nSince version 0.35.0 vi.useFakeTimers() no longer automatically mocks process.nextTick. It can still be mocked by specifying the option in toFake argument: vi.useFakeTimers({ toFake: ['nextTick'] }).\n\nvi.isFakeTimers\n​\nType: () => boolean\nVersion: Since Vitest 0.34.5\n\nReturns true if fake timers are enabled.\n\nvi.useRealTimers\n​\nType: () => Vitest\n\nWhen timers are run out, you may call this method to return mocked timers to its original implementations. All timers that were scheduled before will be discarded.\n\nMiscellaneous\n​\n\nA set of useful helper functions that Vitest provides.\n\nvi.waitFor\n​\nType: <T>(callback: WaitForCallback<T>, options?: number | WaitForOptions) => Promise<T>\nVersion: Since Vitest 0.34.5\n\nWait for the callback to execute successfully. If the callback throws an error or returns a rejected promise it will continue to wait until it succeeds or times out.\n\nThis is very useful when you need to wait for some asynchronous action to complete, for example, when you start a server and need to wait for it to start.\n\nts\nimport { expect, test, vi } from 'vitest'\nimport { createServer } from './server.js'\n\ntest('Server started successfully', async () => {\n  const server = createServer()\n\n  await vi.waitFor(\n    () => {\n      if (!server.isReady)\n        throw new Error('Server not started')\n\n      console.log('Server started')\n    },\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n  expect(server.isReady).toBe(true)\n})\n\nIt also works for asynchronous callbacks\n\nts\n// @vitest-environment jsdom\n\nimport { expect, test, vi } from 'vitest'\nimport { getDOMElementAsync, populateDOMAsync } from './dom.js'\n\ntest('Element exists in a DOM', async () => {\n  // start populating DOM\n  populateDOMAsync()\n\n  const element = await vi.waitFor(async () => {\n    // try to get the element until it exists\n    const element = await getDOMElementAsync() as HTMLElement | null\n    expect(element).toBeTruthy()\n    expect(element.dataset.initialized).toBeTruthy()\n    return element\n  }, {\n    timeout: 500, // default is 1000\n    interval: 20, // default is 50\n  })\n  expect(element).toBeInstanceOf(HTMLElement)\n})\n\nIf vi.useFakeTimers is used, vi.waitFor automatically calls vi.advanceTimersByTime(interval) in every check callback.\n\nvi.waitUntil\n​\nType: <T>(callback: WaitUntilCallback<T>, options?: number | WaitUntilOptions) => Promise<T>\nVersion: Since Vitest 0.34.5\n\nThis is similar to vi.waitFor, but if the callback throws any errors, execution is immediately interrupted and an error message is received. If the callback returns falsy value, the next check will continue until truthy value is returned. This is useful when you need to wait for something to exist before taking the next step.\n\nLook at the example below. We can use vi.waitUntil to wait for the element to appear on the page, and then we can do something with the element.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('Element render correctly', async () => {\n  const element = await vi.waitUntil(\n    () => document.querySelector('.element'),\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n\n  // do something with the element\n  expect(element.querySelector('.element-child')).toBeTruthy()\n})\nvi.hoisted\n​\nType: <T>(factory: () => T) => T\nVersion: Since Vitest 0.31.0\n\nAll static import statements in ES modules are hoisted to the top of the file, so any code that is defined before the imports will actually be executed after imports are evaluated.\n\nHowever, it can be useful to invoke some side effects like mocking dates before importing a module.\n\nTo bypass this limitation, you can rewrite static imports into dynamic ones like this:\n\ndiff\ncallFunctionWithSideEffect()\n- import { value } from './some/module.js'\n+ const { value } = await import('./some/module.js')\n\nWhen running vitest, you can do this automatically by using vi.hoisted method.\n\ndiff\n- callFunctionWithSideEffect()\nimport { value } from './some/module.js'\n+ vi.hoisted(() => callFunctionWithSideEffect())\n\nThis method returns the value that was returned from the factory. You can use that value in your vi.mock factories if you need easy access to locally defined variables:\n\nts\nimport { expect, vi } from 'vitest'\nimport { originalMethod } from './path/to/module.js'\n\nconst { mockedMethod } = vi.hoisted(() => {\n  return { mockedMethod: vi.fn() }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return { originalMethod: mockedMethod }\n})\n\nmockedMethod.mockReturnValue(100)\nexpect(originalMethod()).toBe(100)\n\nNote that this method can also be called asynchronously even if your environment doesn't support top-level await:\n\nts\nconst promised = await vi.hoisted(async () => {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts')\n  return response.json()\n})\nvi.setConfig\n​\nType: RuntimeConfig\n\nUpdates config for the current test file. This method supports only config options that will affect the current test file:\n\nts\nvi.setConfig({\n  allowOnly: true,\n  testTimeout: 10_000,\n  hookTimeout: 10_000,\n  clearMocks: true,\n  restoreMocks: true,\n  fakeTimers: {\n    now: new Date(2021, 11, 19),\n    // supports the whole object\n  },\n  maxConcurrency: 10,\n  sequence: {\n    hooks: 'stack'\n    // supports only \"sequence.hooks\"\n  }\n})\nvi.resetConfig\n​\nType: RuntimeConfig\n\nIf vi.setConfig was called before, this will reset config to the original state."
  },
  {
    "title": "Mock Functions | Vitest",
    "url": "https://vitest.dev/api/mock",
    "html": "Mock Functions\n​\n\nYou can create a mock function to track its execution with vi.fn method. If you want to track a method on an already created object, you can use vi.spyOn method:\n\njs\nimport { vi } from 'vitest'\n\nconst fn = vi.fn()\nfn('hello world')\nfn.mock.calls[0] === ['hello world']\n\nconst market = {\n  getApples: () => 100\n}\n\nconst getApplesSpy = vi.spyOn(market, 'getApples')\nmarket.getApples()\ngetApplesSpy.mock.calls.length === 1\n\nYou should use mock assertions (e.g., toHaveBeenCalled) on expect to assert mock result. This API reference describes available properties and methods to manipulate mock behavior.\n\ngetMockImplementation\n​\nType: (...args: any) => any\n\nReturns current mock implementation if there is one.\n\nIf mock was created with vi.fn, it will consider passed down method as a mock implementation.\n\nIf mock was created with vi.spyOn, it will return undefined unless a custom implementation was provided.\n\ngetMockName\n​\nType: () => string\n\nUse it to return the name given to mock with method .mockName(name).\n\nmockClear\n​\nType: () => MockInstance\n\nClears all information about every call. After calling it, all properties on .mock will return empty state. This method does not reset implementations. It is useful if you need to clean up mock between different assertions.\n\nIf you want this method to be called before each test automatically, you can enable clearMocks setting in config.\n\nmockName\n​\nType: (name: string) => MockInstance\n\nSets internal mock name. Useful to see the name of the mock if assertion fails.\n\nmockImplementation\n​\nType: (fn: Function) => MockInstance\n\nAccepts a function that will be used as an implementation of the mock.\n\nts\nconst mockFn = vi.fn().mockImplementation(apples => apples + 1)\n// or: vi.fn(apples => apples + 1);\n\nconst NelliesBucket = mockFn(0)\nconst BobsBucket = mockFn(1)\n\nNelliesBucket === 1 // true\nBobsBucket === 2 // true\n\nmockFn.mock.calls[0][0] === 0 // true\nmockFn.mock.calls[1][0] === 1 // true\nmockImplementationOnce\n​\nType: (fn: Function) => MockInstance\n\nAccepts a function that will be used as mock's implementation during the next call. Can be chained so that multiple function calls produce different results.\n\nts\nconst myMockFn = vi\n  .fn()\n  .mockImplementationOnce(() => true)\n  .mockImplementationOnce(() => false)\n\nmyMockFn() // true\nmyMockFn() // false\n\nWhen the mocked function runs out of implementations, it will invoke the default implementation that was set with vi.fn(() => defaultValue) or .mockImplementation(() => defaultValue) if they were called:\n\nts\nconst myMockFn = vi\n  .fn(() => 'default')\n  .mockImplementationOnce(() => 'first call')\n  .mockImplementationOnce(() => 'second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\nwithImplementation\n​\nType: (fn: Function, callback: () => void) => MockInstance\nType: (fn: Function, callback: () => Promise<unknown>) => Promise<MockInstance>\n\nOverrides the original mock implementation temporarily while the callback is being executed.\n\njs\nconst myMockFn = vi.fn(() => 'original')\n\nmyMockFn.withImplementation(() => 'temp', () => {\n  myMockFn() // 'temp'\n})\n\nmyMockFn() // 'original'\n\nCan be used with an asynchronous callback. The method has to be awaited to use the original implementation afterward.\n\nts\ntest('async callback', () => {\n  const myMockFn = vi.fn(() => 'original')\n\n  // We await this call since the callback is async\n  await myMockFn.withImplementation(\n    () => 'temp',\n    async () => {\n      myMockFn() // 'temp'\n    },\n  )\n\n  myMockFn() // 'original'\n})\n\nNote that this method takes precedence over the mockImplementationOnce.\n\nmockRejectedValue\n​\nType: (value: any) => MockInstance\n\nAccepts an error that will be rejected when async function is called.\n\nts\nconst asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))\n\nawait asyncMock() // throws \"Async error\"\nmockRejectedValueOnce\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be rejected during the next function call. If chained, every consecutive call will reject specified value.\n\nts\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValueOnce('first call')\n  .mockRejectedValueOnce(new Error('Async error'))\n\nawait asyncMock() // first call\nawait asyncMock() // throws \"Async error\"\nmockReset\n​\nType: () => MockInstance\n\nDoes what mockClear does and makes inner implementation an empty function (returning undefined when invoked). This also resets all \"once\" implementations. This is useful when you want to completely reset a mock to the default state.\n\nIf you want this method to be called before each test automatically, you can enable mockReset setting in config.\n\nmockRestore\n​\nType: () => MockInstance\n\nDoes what mockReset does and restores inner implementation to the original function.\n\nNote that restoring mock from vi.fn() will set implementation to an empty function that returns undefined. Restoring a vi.fn(impl) will restore implementation to impl.\n\nIf you want this method to be called before each test automatically, you can enable restoreMocks setting in config.\n\nmockResolvedValue\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be resolved when async function is called.\n\nts\nconst asyncMock = vi.fn().mockResolvedValue(42)\n\nawait asyncMock() // 42\nmockResolvedValueOnce\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be resolved during the next function call. If chained, every consecutive call will resolve specified value.\n\nts\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValue('default')\n  .mockResolvedValueOnce('first call')\n  .mockResolvedValueOnce('second call')\n\nawait asyncMock() // first call\nawait asyncMock() // second call\nawait asyncMock() // default\nawait asyncMock() // default\nmockReturnThis\n​\nType: () => MockInstance\n\nUse this if you need to return this context from the method without invoking actual implementation. This is a shorthand for:\n\nts\nspy.mockImplementation(function () {\n  return this\n})\nmockReturnValue\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be returned whenever the mock function is called.\n\nts\nconst mock = vi.fn()\nmock.mockReturnValue(42)\nmock() // 42\nmock.mockReturnValue(43)\nmock() // 43\nmockReturnValueOnce\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be returned during the next function call. If chained, every consecutive call will return the specified value.\n\nWhen there are no more mockReturnValueOnce values to use, mock will fallback to previously defined implementation if there is one.\n\nts\nconst myMockFn = vi\n  .fn()\n  .mockReturnValue('default')\n  .mockReturnValueOnce('first call')\n  .mockReturnValueOnce('second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\nmock.calls\n​\n\nThis is an array containing all arguments for each call. One item of the array is the arguments of that call.\n\njs\nconst fn = vi.fn()\n\nfn('arg1', 'arg2')\nfn('arg3')\n\nfn.mock.calls === [\n  ['arg1', 'arg2'], // first call\n  ['arg3'], // second call\n]\nmock.lastCall\n​\n\nThis contains the arguments of the last call. If mock wasn't called, will return undefined.\n\nmock.results\n​\n\nThis is an array containing all values that were returned from the function. One item of the array is an object with properties type and value. Available types are:\n\n'return' - function returned without throwing.\n'throw' - function threw a value.\n\nThe value property contains the returned value or thrown error. If the function returned a promise, the value will be the resolved value, not the actual Promise, unless it was never resolved.\n\njs\nconst fn = vi.fn()\n  .mockReturnValueOnce('result')\n  .mockImplementationOnce(() => { throw new Error('thrown error') })\n\nconst result = fn() // returned 'result'\n\ntry {\n  fn() // threw Error\n}\ncatch {}\n\nfn.mock.results === [\n  // first result\n  {\n    type: 'return',\n    value: 'result',\n  },\n  // last result\n  {\n    type: 'throw',\n    value: Error,\n  },\n]\nmock.invocationCallOrder\n​\n\nThe order of mock's execution. This returns an array of numbers that are shared between all defined mocks.\n\njs\nconst fn1 = vi.fn()\nconst fn2 = vi.fn()\n\nfn1()\nfn2()\nfn1()\n\nfn1.mock.invocationCallOrder === [1, 3]\nfn2.mock.invocationCallOrder === [2]\nmock.instances\n​\n\nThis is an array containing all instances that were instantiated when mock was called with a new keyword. Note that this is an actual context (this) of the function, not a return value.\n\nWARNING\n\nIf mock was instantiated with new MyClass(), then mock.instances will be an array with one value:\n\njs\nconst MyClass = vi.fn()\nconst a = new MyClass()\n\nMyClass.mock.instances[0] === a\n\nIf you return a value from constructor, it will not be in instances array, but instead inside results:\n\njs\nconst Spy = vi.fn(() => ({ method: vi.fn() }))\nconst a = new Spy()\n\nSpy.mock.instances[0] !== a\nSpy.mock.results[0] === a"
  },
  {
    "title": "Test API Reference | Vitest",
    "url": "https://vitest.dev/api/",
    "html": "Test API Reference\n​\n\nThe following types are used in the type signatures below\n\nts\ntype Awaitable<T> = T | PromiseLike<T>\ntype TestFunction = () => Awaitable<void>\n\ninterface TestOptions {\n  /**\n   * Will fail the test if it takes too long to execute\n   */\n  timeout?: number\n  /**\n   * Will retry the test specific number of times if it fails\n   *\n   * @default 0\n   */\n  retry?: number\n  /**\n   * Will repeat the same test several times even if it fails each time\n   * If you have \"retry\" option and it fails, it will use every retry in each cycle\n   * Useful for debugging random failings\n   *\n   * @default 0\n   */\n  repeats?: number\n}\n\nWhen a test function returns a promise, the runner will wait until it is resolved to collect async expectations. If the promise is rejected, the test will fail.\n\nTIP\n\nIn Jest, TestFunction can also be of type (done: DoneCallback) => void. If this form is used, the test will not be concluded until done is called. You can achieve the same using an async function, see the Migration guide Done Callback section.\n\ntest\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number | TestOptions) => void\nAlias: it\n\ntest defines a set of related expectations. It receives the test name and a function that holds the expectations to test.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with testTimeout\n\nts\nimport { expect, test } from 'vitest'\n\ntest('should work as expected', () => {\n  expect(Math.sqrt(4)).toBe(2)\n})\ntest.extend\n​\nType: <T extends Record<string, any>>(fixtures: Fixtures<T>): TestAPI<ExtraContext & T>\nAlias: it.extend\nVersion: Vitest 0.32.3\n\nUse test.extend to extend the test context with custom fixtures. This will return a new test and it's also extendable, so you can compose more fixtures or override existing ones by extending it as you need. See Extend Test Context for more information.\n\nts\nimport { expect, test } from 'vitest'\n\nconst todos = []\nconst archive = []\n\nconst myTest = test.extend({\n  todos: async ({ task }, use) => {\n    todos.push(1, 2, 3)\n    await use(todos)\n    todos.length = 0\n  },\n  archive\n})\n\nmyTest('add item', ({ todos }) => {\n  expect(todos.length).toBe(3)\n\n  todos.push(4)\n  expect(todos.length).toBe(4)\n})\ntest.skip\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number | TestOptions) => void\nAlias: it.skip\n\nIf you want to skip running certain tests, but you don't want to delete the code due to any reason, you can use test.skip to avoid running them.\n\nts\nimport { assert, test } from 'vitest'\n\ntest.skip('skipped test', () => {\n  // Test skipped, no error\n  assert.equal(Math.sqrt(4), 3)\n})\n\nYou can also skip test by calling skip on its context dynamically:\n\nts\nimport { assert, test } from 'vitest'\n\ntest('skipped test', (context) => {\n  context.skip()\n  // Test skipped, no error\n  assert.equal(Math.sqrt(4), 3)\n})\ntest.skipIf\n​\nType: (condition: any) => Test\nAlias: it.skipIf\n\nIn some cases you might run tests multiple times with different environments, and some of the tests might be environment-specific. Instead of wrapping the test code with if, you can use test.skipIf to skip the test whenever the condition is truthy.\n\nts\nimport { assert, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ntest.skipIf(isDev)('prod only test', () => {\n  // this test only runs in production\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.runIf\n​\nType: (condition: any) => Test\nAlias: it.runIf\n\nOpposite of test.skipIf.\n\nts\nimport { assert, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ntest.runIf(isDev)('dev only test', () => {\n  // this test only runs in development\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.only\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\nAlias: it.only\n\nUse test.only to only run certain tests in a given suite. This is useful when debugging.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with testTimeout.\n\nts\nimport { assert, test } from 'vitest'\n\ntest.only('test', () => {\n  // Only this test (and others marked with only) are run\n  assert.equal(Math.sqrt(4), 2)\n})\n\nSometimes it is very useful to run only tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.\n\nIn order to do that run vitest with specific file containing the tests in question.\n\n# vitest interesting.test.ts\ntest.concurrent\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\nAlias: it.concurrent\n\ntest.concurrent marks consecutive tests to be run in parallel. It receives the test name, an async function with the tests to collect, and an optional timeout (in milliseconds).\n\nts\nimport { describe, test } from 'vitest'\n\n// The two tests marked with concurrent will be run in parallel\ndescribe('suite', () => {\n  test('serial test', async () => { /* ... */ })\n  test.concurrent('concurrent test 1', async () => { /* ... */ })\n  test.concurrent('concurrent test 2', async () => { /* ... */ })\n})\n\ntest.skip, test.only, and test.todo works with concurrent tests. All the following combinations are valid:\n\nts\ntest.concurrent(/* ... */)\ntest.skip.concurrent(/* ... */) // or test.concurrent.skip(/* ... */)\ntest.only.concurrent(/* ... */) // or test.concurrent.only(/* ... */)\ntest.todo.concurrent(/* ... */) // or test.concurrent.todo(/* ... */)\n\nWhen running concurrent tests, Snapshots and Assertions must use expect from the local Test Context to ensure the right test is detected.\n\nts\ntest.concurrent('test 1', async ({ expect }) => {\n  expect(foo).toMatchSnapshot()\n})\ntest.concurrent('test 2', async ({ expect }) => {\n  expect(foo).toMatchSnapshot()\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.sequential\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\n\ntest.sequential marks a test as sequential. This is useful if you want to run tests in sequence within describe.concurrent or with the --sequence.concurrent command option.\n\nts\n// with config option { sequence: { concurrent: true } }\ntest('concurrent test 1', async () => { /* ... */ })\ntest('concurrent test 2', async () => { /* ... */ })\n\ntest.sequential('sequential test 1', async () => { /* ... */ })\ntest.sequential('sequential test 2', async () => { /* ... */ })\n\n// within concurrent suite\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n\n  test.sequential('sequential test 1', async () => { /* ... */ })\n  test.sequential('sequential test 2', async () => { /* ... */ })\n})\ntest.todo\n​\nType: (name: string | Function) => void\nAlias: it.todo\n\nUse test.todo to stub tests to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.\n\nts\n// An entry will be shown in the report for this test\ntest.todo('unimplemented test')\ntest.fails\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\nAlias: it.fails\n\nUse test.fails to indicate that an assertion will fail explicitly.\n\nts\nimport { expect, test } from 'vitest'\n\nfunction myAsyncFunc() {\n  return new Promise(resolve => resolve(1))\n}\ntest.fails('fail test', async () => {\n  await expect(myAsyncFunc()).rejects.toBe(1)\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.each\n​\nType: (cases: ReadonlyArray<T>, ...args: any[]) => void\nAlias: it.each\n\nUse test.each when you need to run the same test with different variables. You can inject parameters with printf formatting in the test name in the order of the test function parameters.\n\n%s: string\n%d: number\n%i: integer\n%f: floating point value\n%j: json\n%o: object\n%#: index of the test case\n%%: single percent sign ('%')\nts\ntest.each([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('add(%i, %i) -> %i', (a, b, expected) => {\n  expect(a + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, 1) -> 2\n// ✓ add(1, 2) -> 3\n// ✓ add(2, 1) -> 3\n\nYou can also access object properties with $ prefix, if you are using objects as arguments:\n\nts\ntest.each([\n  { a: 1, b: 1, expected: 2 },\n  { a: 1, b: 2, expected: 3 },\n  { a: 2, b: 1, expected: 3 },\n])('add($a, $b) -> $expected', ({ a, b, expected }) => {\n  expect(a + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, 1) -> 2\n// ✓ add(1, 2) -> 3\n// ✓ add(2, 1) -> 3\n\nYou can also access Object attributes with ., if you are using objects as arguments:\n\nts\ntest.each`\na               | b      | expected\n${{ val: 1 }}   | ${'b'} | ${'1b'}\n${{ val: 2 }}   | ${'b'} | ${'2b'}\n${{ val: 3 }}   | ${'b'} | ${'3b'}\n`('add($a.val, $b) -> $expected', ({ a, b, expected }) => {\n  expect(a.val + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, b) -> 1b\n// ✓ add(2, b) -> 2b\n// ✓ add(3, b) -> 3b\n\nStarting from Vitest 0.25.3, you can also use template string table.\n\nFirst row should be column names, separated by |;\nOne or more subsequent rows of data supplied as template literal expressions using ${value} syntax.\nts\ntest.each`\n  a               | b      | expected\n  ${1}            | ${1}   | ${2}\n  ${'a'}          | ${'b'} | ${'ab'}\n  ${[]}           | ${'b'} | ${'b'}\n  ${{}}           | ${'b'} | ${'[object Object]b'}\n  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}\n`('returns $expected when $a is added $b', ({ a, b, expected }) => {\n  expect(a + b).toBe(expected)\n})\n\nIf you want to have access to TestContext, use describe.each with a single test.\n\nTIP\n\nVitest processes $values with Chai format method. If the value is too truncated, you can increase chaiConfig.truncateThreshold in your config file.\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\nbench\n​\nType: (name: string | Function, fn: BenchFunction, options?: BenchOptions) => void\n\nbench defines a benchmark. In Vitest terms benchmark is a function that defines a series of operations. Vitest runs this function multiple times to display different performance results.\n\nVitest uses tinybench library under the hood, inheriting all its options that can be used as a third argument.\n\nts\nimport { bench } from 'vitest'\n\nbench('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n}, { time: 1000 })\nts\nexport interface Options {\n  /**\n   * time needed for running a benchmark task (milliseconds)\n   * @default 500\n   */\n  time?: number\n\n  /**\n   * number of times that a task should run if even the time option is finished\n   * @default 10\n   */\n  iterations?: number\n\n  /**\n   * function to get the current timestamp in milliseconds\n   */\n  now?: () => number\n\n  /**\n   * An AbortSignal for aborting the benchmark\n   */\n  signal?: AbortSignal\n\n  /**\n   * warmup time (milliseconds)\n   * @default 100ms\n   */\n  warmupTime?: number\n\n  /**\n   * warmup iterations\n   * @default 5\n   */\n  warmupIterations?: number\n\n  /**\n   * setup function to run before each benchmark task (cycle)\n   */\n  setup?: Hook\n\n  /**\n   * teardown function to run after each benchmark task (cycle)\n   */\n  teardown?: Hook\n}\nbench.skip\n​\nType: (name: string | Function, fn: BenchFunction, options?: BenchOptions) => void\n\nYou can use bench.skip syntax to skip running certain benchmarks.\n\nts\nimport { bench } from 'vitest'\n\nbench.skip('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n})\nbench.only\n​\nType: (name: string | Function, fn: BenchFunction, options?: BenchOptions) => void\n\nUse bench.only to only run certain benchmarks in a given suite. This is useful when debugging.\n\nts\nimport { bench } from 'vitest'\n\nbench.only('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n})\nbench.todo\n​\nType: (name: string | Function) => void\n\nUse bench.todo to stub benchmarks to be implemented later.\n\nts\nimport { bench } from 'vitest'\n\nbench.todo('unimplemented test')\ndescribe\n​\n\nWhen you use test or bench in the top level of file, they are collected as part of the implicit suite for it. Using describe you can define a new suite in the current context, as a set of related tests or benchmarks and other nested suites. A suite lets you organize your tests and benchmarks so reports are more clear.\n\nts\n// basic.spec.ts\n// organizing tests\n\nimport { describe, expect, test } from 'vitest'\n\nconst person = {\n  isActive: true,\n  age: 32,\n}\n\ndescribe('person', () => {\n  test('person is defined', () => {\n    expect(person).toBeDefined()\n  })\n\n  test('is active', () => {\n    expect(person.isActive).toBeTruthy()\n  })\n\n  test('age limit', () => {\n    expect(person.age).toBeLessThanOrEqual(32)\n  })\n})\nts\n// basic.bench.ts\n// organizing benchmarks\n\nimport { bench, describe } from 'vitest'\n\ndescribe('sort', () => {\n  bench('normal', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.sort((a, b) => {\n      return a - b\n    })\n  })\n\n  bench('reverse', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.reverse().sort((a, b) => {\n      return a - b\n    })\n  })\n})\n\nYou can also nest describe blocks if you have a hierarchy of tests or benchmarks:\n\nts\nimport { describe, expect, test } from 'vitest'\n\nfunction numberToCurrency(value) {\n  if (typeof value !== 'number')\n    throw new Error('Value must be a number')\n\n  return value.toFixed(2).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n}\n\ndescribe('numberToCurrency', () => {\n  describe('given an invalid number', () => {\n    test('composed of non-numbers to throw error', () => {\n      expect(() => numberToCurrency('abc')).toThrowError()\n    })\n  })\n\n  describe('given a valid number', () => {\n    test('returns the correct currency format', () => {\n      expect(numberToCurrency(10000)).toBe('10,000.00')\n    })\n  })\n})\ndescribe.skip\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\nUse describe.skip in a suite to avoid running a particular describe block.\n\nts\nimport { assert, describe, test } from 'vitest'\n\ndescribe.skip('skipped suite', () => {\n  test('sqrt', () => {\n    // Suite skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\ndescribe.skipIf\n​\nType: (condition: any) => void\n\nIn some cases, you might run suites multiple times with different environments, and some of the suites might be environment-specific. Instead of wrapping the suite with if, you can use describe.skipIf to skip the suite whenever the condition is truthy.\n\nts\nimport { describe, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ndescribe.skipIf(isDev)('prod only test', () => {\n  // this test only runs in production\n})\n\nWARNING\n\nYou cannot use this syntax when using Vitest as type checker.\n\ndescribe.only\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\nUse describe.only to only run certain suites\n\nts\n// Only this suite (and others marked with only) are run\ndescribe.only('suite', () => {\n  test('sqrt', () => {\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\ndescribe('other suite', () => {\n  // ... will be skipped\n})\n\nSometimes it is very useful to run only tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.\n\nIn order to do that run vitest with specific file containing the tests in question.\n\n# vitest interesting.test.ts\ndescribe.concurrent\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\ndescribe.concurrent in a suite marks every tests as concurrent\n\nts\n// All tests within this suite will be run in parallel\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n  test.concurrent('concurrent test 3', async () => { /* ... */ })\n})\n\n.skip, .only, and .todo works with concurrent suites. All the following combinations are valid:\n\nts\ndescribe.concurrent(/* ... */)\ndescribe.skip.concurrent(/* ... */) // or describe.concurrent.skip(/* ... */)\ndescribe.only.concurrent(/* ... */) // or describe.concurrent.only(/* ... */)\ndescribe.todo.concurrent(/* ... */) // or describe.concurrent.todo(/* ... */)\n\nWhen running concurrent tests, Snapshots and Assertions must use expect from the local Test Context to ensure the right test is detected.\n\nts\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async ({ expect }) => {\n    expect(foo).toMatchSnapshot()\n  })\n  test('concurrent test 2', async ({ expect }) => {\n    expect(foo).toMatchSnapshot()\n  })\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ndescribe.sequential\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\ndescribe.sequential in a suite marks every test as sequential. This is useful if you want to run tests in sequence within describe.concurrent or with the --sequence.concurrent command option.\n\nts\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n\n  describe.sequential('', () => {\n    test('sequential test 1', async () => { /* ... */ })\n    test('sequential test 2', async () => { /* ... */ })\n  })\n})\ndescribe.shuffle\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\nVitest provides a way to run all tests in random order via CLI flag --sequence.shuffle or config option sequence.shuffle, but if you want to have only part of your test suite to run tests in random order, you can mark it with this flag.\n\nts\ndescribe.shuffle('suite', () => {\n  test('random test 1', async () => { /* ... */ })\n  test('random test 2', async () => { /* ... */ })\n  test('random test 3', async () => { /* ... */ })\n})\n// order depends on sequence.seed option in config (Date.now() by default)\n\n.skip, .only, and .todo works with random suites.\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ndescribe.todo\n​\nType: (name: string | Function) => void\n\nUse describe.todo to stub suites to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.\n\nts\n// An entry will be shown in the report for this suite\ndescribe.todo('unimplemented suite')\ndescribe.each\n​\nType: (cases: ReadonlyArray<T>, ...args: any[]): (name: string | Function, fn: (...args: T[]) => void, options?: number | TestOptions) => void\n\nUse describe.each if you have more than one test that depends on the same data.\n\nts\ndescribe.each([\n  { a: 1, b: 1, expected: 2 },\n  { a: 1, b: 2, expected: 3 },\n  { a: 2, b: 1, expected: 3 },\n])('describe object add($a, $b)', ({ a, b, expected }) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected)\n  })\n\n  test(`returned value not be greater than ${expected}`, () => {\n    expect(a + b).not.toBeGreaterThan(expected)\n  })\n\n  test(`returned value not be less than ${expected}`, () => {\n    expect(a + b).not.toBeLessThan(expected)\n  })\n})\n\nStarting from Vitest 0.25.3, you can also use template string table.\n\nFirst row should be column names, separated by |;\nOne or more subsequent rows of data supplied as template literal expressions using ${value} syntax.\nts\ndescribe.each`\n  a               | b      | expected\n  ${1}            | ${1}   | ${2}\n  ${'a'}          | ${'b'} | ${'ab'}\n  ${[]}           | ${'b'} | ${'b'}\n  ${{}}           | ${'b'} | ${'[object Object]b'}\n  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}\n`('describe template string add($a, $b)', ({ a, b, expected }) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected)\n  })\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\nSetup and Teardown\n​\n\nThese functions allow you to hook into the life cycle of tests to avoid repeating setup and teardown code. They apply to the current context: the file if they are used at the top-level or the current suite if they are inside a describe block. These hooks are not called, when you are running Vitest as a type checker.\n\nbeforeEach\n​\nType: beforeEach(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called before each of the tests in the current context runs. If the function returns a promise, Vitest waits until the promise resolve before running the test.\n\nOptionally, you can pass a timeout (in milliseconds) defining how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { beforeEach } from 'vitest'\n\nbeforeEach(async () => {\n  // Clear mocks and add some testing data after before each test run\n  await stopMocking()\n  await addUser({ name: 'John' })\n})\n\nHere, the beforeEach ensures that user is added for each test.\n\nSince Vitest v0.10.0, beforeEach also accepts an optional cleanup function (equivalent to afterEach).\n\nts\nimport { beforeEach } from 'vitest'\n\nbeforeEach(async () => {\n  // called once before each test run\n  await prepareSomething()\n\n  // clean up function, called once after each test run\n  return async () => {\n    await resetSomething()\n  }\n})\nafterEach\n​\nType: afterEach(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called after each one of the tests in the current context completes. If the function returns a promise, Vitest waits until the promise resolve before continuing.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { afterEach } from 'vitest'\n\nafterEach(async () => {\n  await clearTestingData() // clear testing data after each test run\n})\n\nHere, the afterEach ensures that testing data is cleared after each test runs.\n\nbeforeAll\n​\nType: beforeAll(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called once before starting to run all tests in the current context. If the function returns a promise, Vitest waits until the promise resolve before running tests.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => {\n  await startMocking() // called once before all tests run\n})\n\nHere the beforeAll ensures that the mock data is set up before tests run.\n\nSince Vitest v0.10.0, beforeAll also accepts an optional cleanup function (equivalent to afterAll).\n\nts\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => {\n  // called once before all tests run\n  await startMocking()\n\n  // clean up function, called once after all tests run\n  return async () => {\n    await stopMocking()\n  }\n})\nafterAll\n​\nType: afterAll(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called once after all tests have run in the current context. If the function returns a promise, Vitest waits until the promise resolve before continuing.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { afterAll } from 'vitest'\n\nafterAll(async () => {\n  await stopMocking() // this method is called after all tests run\n})\n\nHere the afterAll ensures that stopMocking method is called after all tests run."
  },
  {
    "title": "assertType | Vitest",
    "url": "https://vitest.dev/api/assert-type",
    "html": "assertType\n​\n\nWARNING\n\nDuring runtime this function doesn't do anything. To enable typechecking, don't forget to pass down --typecheck flag.\n\nType: <T>(value: T): void\n\nYou can use this function as an alternative for expectTypeOf to easily assert that the argument type is equal to the generic provided.\n\nts\nimport { assertType } from 'vitest'\n\nfunction concat(a: string, b: string): string\nfunction concat(a: number, b: number): number\nfunction concat(a: string | number, b: string | number): string | number\n\nassertType<string>(concat('a', 'b'))\nassertType<number>(concat(1, 2))\n// @ts-expect-error wrong types\nassertType(concat('a', 2))"
  },
  {
    "title": "expect | Vitest",
    "url": "https://vitest.dev/api/expect",
    "html": "expect\n​\n\nThe following types are used in the type signatures below\n\nts\ntype Awaitable<T> = T | PromiseLike<T>\n\nexpect is used to create assertions. In this context assertions are functions that can be called to assert a statement. Vitest provides chai assertions by default and also Jest compatible assertions build on top of chai.\n\nFor example, this code asserts that an input value is equal to 2. If it's not, the assertion will throw an error, and the test will fail.\n\nts\nimport { expect } from 'vitest'\n\nconst input = Math.sqrt(4)\n\nexpect(input).to.equal(2) // chai API\nexpect(input).toBe(2) // jest API\n\nTechnically this example doesn't use test function, so in the console you will see Node.js error instead of Vitest output. To learn more about test, please read Test API Reference.\n\nAlso, expect can be used statically to access matcher functions, described later, and more.\n\nWARNING\n\nexpect has no effect on testing types, if the expression doesn't have a type error. If you want to use Vitest as type checker, use expectTypeOf or assertType.\n\nsoft\n​\nType: ExpectStatic & (actual: any) => Assertions\n\nexpect.soft functions similarly to expect, but instead of terminating the test execution upon a failed assertion, it continues running and marks the failure as a test failure. All errors encountered during the test will be displayed until the test is completed.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('expect.soft test', () => {\n  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue\n  expect.soft(1 + 2).toBe(4) // mark the test as fail and continue\n})\n// At the end of the test, the above errors will be output.\n\nIt can also be used with expect. if expect assertion fails, the test will be terminated and all errors will be displayed.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('expect.soft test', () => {\n  expect.soft(1 + 1).toBe(3) // mark the test as fail and continue\n  expect(1 + 2).toBe(3) // failed and terminate the test, all previous errors will be output\n  expect.soft(1 + 2).toBe(4) // do not run\n})\n\nWARNING\n\nexpect.soft can only be used inside the test function.\n\nnot\n​\n\nUsing not will negate the assertion. For example, this code asserts that an input value is not equal to 2. If it's equal, the assertion will throw an error, and the test will fail.\n\nts\nimport { expect, test } from 'vitest'\n\nconst input = Math.sqrt(16)\n\nexpect(input).not.to.equal(2) // chai API\nexpect(input).not.toBe(2) // jest API\ntoBe\n​\nType: (value: any) => Awaitable<void>\n\ntoBe can be used to assert if primitives are equal or that objects share the same reference. It is equivalent of calling expect(Object.is(3, 3)).toBe(true). If the objects are not the same, but you want to check if their structures are identical, you can use toEqual.\n\nFor example, the code below checks if the trader has 13 apples.\n\nts\nimport { expect, test } from 'vitest'\n\nconst stock = {\n  type: 'apples',\n  count: 13,\n}\n\ntest('stock has 13 apples', () => {\n  expect(stock.type).toBe('apples')\n  expect(stock.count).toBe(13)\n})\n\ntest('stocks are the same', () => {\n  const refStock = stock // same reference\n\n  expect(stock).toBe(refStock)\n})\n\nTry not to use toBe with floating-point numbers. Since JavaScript rounds them, 0.1 + 0.2 is not strictly 0.3. To reliably assert floating-point numbers, use toBeCloseTo assertion.\n\ntoBeCloseTo\n​\nType: (value: number, numDigits?: number) => Awaitable<void>\n\nUse toBeCloseTo to compare floating-point numbers. The optional numDigits argument limits the number of digits to check after the decimal point. For example:\n\nts\nimport { expect, test } from 'vitest'\n\ntest.fails('decimals are not equal in javascript', () => {\n  expect(0.2 + 0.1).toBe(0.3) // 0.2 + 0.1 is 0.30000000000000004\n})\n\ntest('decimals are rounded to 5 after the point', () => {\n  // 0.2 + 0.1 is 0.30000 | \"000000000004\" removed\n  expect(0.2 + 0.1).toBeCloseTo(0.3, 5)\n  // nothing from 0.30000000000000004 is removed\n  expect(0.2 + 0.1).not.toBeCloseTo(0.3, 50)\n})\ntoBeDefined\n​\nType: () => Awaitable<void>\n\ntoBeDefined asserts that the value is not equal to undefined. Useful use case would be to check if function returned anything.\n\nts\nimport { expect, test } from 'vitest'\n\nfunction getApples() {\n  return 3\n}\n\ntest('function returned something', () => {\n  expect(getApples()).toBeDefined()\n})\ntoBeUndefined\n​\nType: () => Awaitable<void>\n\nOpposite of toBeDefined, toBeUndefined asserts that the value is equal to undefined. Useful use case would be to check if function hasn't returned anything.\n\nts\nimport { expect, test } from 'vitest'\n\nfunction getApplesFromStock(stock) {\n  if (stock === 'Bill')\n    return 13\n}\n\ntest('mary doesn\\'t have a stock', () => {\n  expect(getApplesFromStock('Mary')).toBeUndefined()\n})\ntoBeTruthy\n​\nType: () => Awaitable<void>\n\ntoBeTruthy asserts that the value is true when converted to boolean. Useful if you don't care for the value, but just want to know it can be converted to true.\n\nFor example, having this code you don't care for the return value of stocks.getInfo - it maybe a complex object, a string, or anything else. The code will still work.\n\nts\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\nstocks.sync('Bill')\nif (stocks.getInfo('Bill'))\n  stocks.sell('apples', 'Bill')\n\nSo if you want to test that stocks.getInfo will be truthy, you could write:\n\nts\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('if we know Bill stock, sell apples to him', () => {\n  stocks.sync('Bill')\n  expect(stocks.getInfo('Bill')).toBeTruthy()\n})\n\nEverything in JavaScript is truthy, except false, null, undefined, NaN, 0, -0, 0n, \"\" and document.all.\n\ntoBeFalsy\n​\nType: () => Awaitable<void>\n\ntoBeFalsy asserts that the value is false when converted to boolean. Useful if you don't care for the value, but just want to know if it can be converted to false.\n\nFor example, having this code you don't care for the return value of stocks.stockFailed - it may return any falsy value, but the code will still work.\n\nts\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\nstocks.sync('Bill')\nif (!stocks.stockFailed('Bill'))\n  stocks.sell('apples', 'Bill')\n\nSo if you want to test that stocks.stockFailed will be falsy, you could write:\n\nts\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('if Bill stock hasn\\'t failed, sell apples to him', () => {\n  stocks.syncStocks('Bill')\n  expect(stocks.stockFailed('Bill')).toBeFalsy()\n})\n\nEverything in JavaScript is truthy, except false, null, undefined, NaN, 0, -0, 0n, \"\" and document.all.\n\ntoBeNull\n​\nType: () => Awaitable<void>\n\ntoBeNull simply asserts if something is null. Alias for .toBe(null).\n\nts\nimport { expect, test } from 'vitest'\n\nfunction apples() {\n  return null\n}\n\ntest('we don\\'t have apples', () => {\n  expect(apples()).toBeNull()\n})\ntoBeNaN\n​\nType: () => Awaitable<void>\n\ntoBeNaN simply asserts if something is NaN. Alias for .toBe(NaN).\n\nts\nimport { expect, test } from 'vitest'\n\nlet i = 0\n\nfunction getApplesCount() {\n  i++\n  return i > 1 ? Number.NaN : i\n}\n\ntest('getApplesCount has some unusual side effects...', () => {\n  expect(getApplesCount()).not.toBeNaN()\n  expect(getApplesCount()).toBeNaN()\n})\ntoBeTypeOf\n​\nType: (c: 'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined') => Awaitable<void>\n\ntoBeTypeOf asserts if an actual value is of type of received type.\n\nts\nimport { expect, test } from 'vitest'\n\nconst actual = 'stock'\n\ntest('stock is type of string', () => {\n  expect(actual).toBeTypeOf('string')\n})\ntoBeInstanceOf\n​\nType: (c: any) => Awaitable<void>\n\ntoBeInstanceOf asserts if an actual value is instance of received class.\n\nts\nimport { expect, test } from 'vitest'\nimport { Stocks } from './stocks.js'\n\nconst stocks = new Stocks()\n\ntest('stocks are instance of Stocks', () => {\n  expect(stocks).toBeInstanceOf(Stocks)\n})\ntoBeGreaterThan\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeGreaterThan asserts if actual value is greater than received one. Equal values will fail the test.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have more then 10 apples', () => {\n  expect(getApples()).toBeGreaterThan(10)\n})\ntoBeGreaterThanOrEqual\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeGreaterThanOrEqual asserts if actual value is greater than received one or equal to it.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or more', () => {\n  expect(getApples()).toBeGreaterThanOrEqual(11)\n})\ntoBeLessThan\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeLessThan asserts if actual value is less than received one. Equal values will fail the test.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have less then 20 apples', () => {\n  expect(getApples()).toBeLessThan(20)\n})\ntoBeLessThanOrEqual\n​\nType: (n: number | bigint) => Awaitable<void>\n\ntoBeLessThanOrEqual asserts if actual value is less than received one or equal to it.\n\nts\nimport { expect, test } from 'vitest'\nimport { getApples } from './stocks.js'\n\ntest('have 11 apples or less', () => {\n  expect(getApples()).toBeLessThanOrEqual(11)\n})\ntoEqual\n​\nType: (received: any) => Awaitable<void>\n\ntoEqual asserts if actual value is equal to received one or has the same structure, if it is an object (compares them recursively). You can see the difference between toEqual and toBe in this example:\n\nts\nimport { expect, test } from 'vitest'\n\nconst stockBill = {\n  type: 'apples',\n  count: 13,\n}\n\nconst stockMary = {\n  type: 'apples',\n  count: 13,\n}\n\ntest('stocks have the same properties', () => {\n  expect(stockBill).toEqual(stockMary)\n})\n\ntest('stocks are not the same', () => {\n  expect(stockBill).not.toBe(stockMary)\n})\n\nWARNING\n\nA deep equality will not be performed for Error objects. To test if something was thrown, use toThrowError assertion.\n\ntoStrictEqual\n​\nType: (received: any) => Awaitable<void>\n\ntoStrictEqual asserts if the actual value is equal to the received one or has the same structure if it is an object (compares them recursively), and of the same type.\n\nDifferences from .toEqual:\n\nKeys with undefined properties are checked. e.g. {a: undefined, b: 2} does not match {b: 2} when using .toStrictEqual.\nArray sparseness is checked. e.g. [, 1] does not match [undefined, 1] when using .toStrictEqual.\nObject types are checked to be equal. e.g. A class instance with fields a and b will not equal a literal object with fields a and b.\nts\nimport { expect, test } from 'vitest'\n\nclass Stock {\n  constructor(type) {\n    this.type = type\n  }\n}\n\ntest('structurally the same, but semantically different', () => {\n  expect(new Stock('apples')).toEqual({ type: 'apples' })\n  expect(new Stock('apples')).not.toStrictEqual({ type: 'apples' })\n})\ntoContain\n​\nType: (received: string) => Awaitable<void>\n\ntoContain asserts if the actual value is in an array. toContain can also check whether a string is a substring of another string. Since Vitest 1.0, if you are running tests in a browser-like environment, this assertion can also check if class is contained in a classList, or an element is inside another one.\n\nts\nimport { expect, test } from 'vitest'\nimport { getAllFruits } from './stocks.js'\n\ntest('the fruit list contains orange', () => {\n  expect(getAllFruits()).toContain('orange')\n\n  const element = document.querySelector('#el')\n  // element has a class\n  expect(element.classList).toContain('flex')\n  // element is inside another one\n  expect(document.querySelector('#wrapper')).toContain(element)\n})\ntoContainEqual\n​\nType: (received: any) => Awaitable<void>\n\ntoContainEqual asserts if an item with a specific structure and values is contained in an array. It works like toEqual inside for each element.\n\nts\nimport { expect, test } from 'vitest'\nimport { getFruitStock } from './stocks.js'\n\ntest('apple available', () => {\n  expect(getFruitStock()).toContainEqual({ fruit: 'apple', count: 5 })\n})\ntoHaveLength\n​\nType: (received: number) => Awaitable<void>\n\ntoHaveLength asserts if an object has a .length property and it is set to a certain numeric value.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('toHaveLength', () => {\n  expect('abc').toHaveLength(3)\n  expect([1, 2, 3]).toHaveLength(3)\n\n  expect('').not.toHaveLength(3) // doesn't have .length of 3\n  expect({ length: 3 }).toHaveLength(3)\n})\ntoHaveProperty\n​\nType: (key: any, received?: any) => Awaitable<void>\n\ntoHaveProperty asserts if a property at provided reference key exists for an object.\n\nYou can provide an optional value argument also known as deep equality, like the toEqual matcher to compare the received property value.\n\nts\nimport { expect, test } from 'vitest'\n\nconst invoice = {\n  'isActive': true,\n  'P.O': '12345',\n  'customer': {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  'total_amount': 5000,\n  'items': [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\ntest('John Doe Invoice', () => {\n  expect(invoice).toHaveProperty('isActive') // assert that the key exists\n  expect(invoice).toHaveProperty('total_amount', 5000) // assert that the key exists and the value is equal\n\n  expect(invoice).not.toHaveProperty('account') // assert that this key does not exist\n\n  // Deep referencing using dot notation\n  expect(invoice).toHaveProperty('customer.first_name')\n  expect(invoice).toHaveProperty('customer.last_name', 'Doe')\n  expect(invoice).not.toHaveProperty('customer.location', 'India')\n\n  // Deep referencing using an array containing the key\n  expect(invoice).toHaveProperty('items[0].type', 'apples')\n  expect(invoice).toHaveProperty('items.0.type', 'apples') // dot notation also works\n\n  // Deep referencing using an array containing the keyPath\n  expect(invoice).toHaveProperty(['items', 0, 'type'], 'apples')\n  expect(invoice).toHaveProperty(['items', '0', 'type'], 'apples') // string notation also works\n\n  // Wrap your key in an array to avoid the key from being parsed as a deep reference\n  expect(invoice).toHaveProperty(['P.O'], '12345')\n})\ntoMatch\n​\nType: (received: string | regexp) => Awaitable<void>\n\ntoMatch asserts if a string matches a regular expression or a string.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('top fruits', () => {\n  expect('top fruits include apple, orange and grape').toMatch(/apple/)\n  expect('applefruits').toMatch('fruit') // toMatch also accepts a string\n})\n\nTIP\n\nIf the value in the error message is too truncated, you can increase chaiConfig.truncateThreshold in your config file.\n\ntoMatchObject\n​\nType: (received: object | array) => Awaitable<void>\n\ntoMatchObject asserts if an object matches a subset of the properties of an object.\n\nYou can also pass an array of objects. This is useful if you want to check that two arrays match in their number of elements, as opposed to arrayContaining, which allows for extra elements in the received array.\n\nts\nimport { expect, test } from 'vitest'\n\nconst johnInvoice = {\n  isActive: true,\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n  total_amount: 5000,\n  items: [\n    {\n      type: 'apples',\n      quantity: 10,\n    },\n    {\n      type: 'oranges',\n      quantity: 5,\n    },\n  ],\n}\n\nconst johnDetails = {\n  customer: {\n    first_name: 'John',\n    last_name: 'Doe',\n    location: 'China',\n  },\n}\n\ntest('invoice has john personal details', () => {\n  expect(johnInvoice).toMatchObject(johnDetails)\n})\n\ntest('the number of elements must match exactly', () => {\n  // Assert that an array of object matches\n  expect([{ foo: 'bar' }, { baz: 1 }]).toMatchObject([\n    { foo: 'bar' },\n    { baz: 1 },\n  ])\n})\ntoThrowError\n​\n\nType: (received: any) => Awaitable<void>\n\nAlias: toThrow\n\ntoThrowError asserts if a function throws an error when it is called.\n\nYou can provide an optional argument to test that a specific error is thrown:\n\nregular expression: error message matches the pattern\nstring: error message includes the substring\n\nTIP\n\nYou must wrap the code in a function, otherwise the error will not be caught, and test will fail.\n\nFor example, if we want to test that getFruitStock('pineapples') throws, we could write:\n\nts\nimport { expect, test } from 'vitest'\n\nfunction getFruitStock(type) {\n  if (type === 'pineapples')\n    throw new Error('Pineapples are not in stock')\n\n  // Do some other stuff\n}\n\ntest('throws on pineapples', () => {\n  // Test that the error message says \"stock\" somewhere: these are equivalent\n  expect(() => getFruitStock('pineapples')).toThrowError(/stock/)\n  expect(() => getFruitStock('pineapples')).toThrowError('stock')\n\n  // Test the exact error message\n  expect(() => getFruitStock('pineapples')).toThrowError(\n    /^Pineapples are not in stock$/,\n  )\n})\n\nTIP\n\nTo test async functions, use in combination with rejects.\n\njs\nfunction getAsyncFruitStock() {\n  return Promise.reject(new Error('empty'))\n}\n\ntest('throws on pineapples', async () => {\n  await expect(() => getAsyncFruitStock()).rejects.toThrowError('empty')\n})\ntoMatchSnapshot\n​\nType: <T>(shape?: Partial<T> | string, message?: string) => void\n\nThis ensures that a value matches the most recent snapshot.\n\nYou can provide an optional hint string argument that is appended to the test name. Although Vitest always appends a number at the end of a snapshot name, short descriptive hints might be more useful than numbers to differentiate multiple snapshots in a single it or test block. Vitest sorts snapshots by name in the corresponding .snap file.\n\nTIP\n\nWhen snapshot mismatch and causing the test failing, if the mismatch is expected, you can press u key to update the snapshot for once. Or you can pass -u or --update CLI options to make Vitest always update the tests.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot()\n})\n\nYou can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchSnapshot({ foo: expect.any(Set) })\n})\ntoMatchInlineSnapshot\n​\nType: <T>(shape?: Partial<T> | string, snapshot?: string, message?: string) => void\n\nThis ensures that a value matches the most recent snapshot.\n\nVitest adds and updates the inlineSnapshot string argument to the matcher in the test file (instead of an external .snap file).\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches inline snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  // Vitest will update following content when updating the snapshot\n  expect(data).toMatchInlineSnapshot(`\n    {\n      \"foo\": Set {\n        \"bar\",\n        \"snapshot\",\n      },\n    }\n  `)\n})\n\nYou can also provide a shape of an object, if you are testing just a shape of an object, and don't need it to be 100% compatible:\n\nts\nimport { expect, test } from 'vitest'\n\ntest('matches snapshot', () => {\n  const data = { foo: new Set(['bar', 'snapshot']) }\n  expect(data).toMatchInlineSnapshot(\n    { foo: expect.any(Set) },\n    `\n    {\n      \"foo\": Any<Set>,\n    }\n  `\n  )\n})\ntoMatchFileSnapshot\n​\nType: <T>(filepath: string, message?: string) => Promise<void>\nVersion: Since Vitest 0.30.0\n\nCompare or update the snapshot with the content of a file explicitly specified (instead of the .snap file).\n\nts\nimport { expect, it } from 'vitest'\n\nit('render basic', async () => {\n  const result = renderHTML(h('div', { class: 'foo' }))\n  await expect(result).toMatchFileSnapshot('./test/basic.output.html')\n})\n\nNote that since file system operation is async, you need to use await with toMatchFileSnapshot().\n\ntoThrowErrorMatchingSnapshot\n​\nType: (message?: string) => void\n\nThe same as toMatchSnapshot, but expects the same value as toThrowError.\n\ntoThrowErrorMatchingInlineSnapshot\n​\nType: (snapshot?: string, message?: string) => void\n\nThe same as toMatchInlineSnapshot, but expects the same value as toThrowError.\n\ntoHaveBeenCalled\n​\nType: () => Awaitable<void>\n\nThis assertion is useful for testing that a function has been called. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  expect(buySpy).not.toHaveBeenCalled()\n\n  market.buy('apples', 10)\n\n  expect(buySpy).toHaveBeenCalled()\n})\ntoHaveBeenCalledTimes\n​\nType: (amount: number) => Awaitable<void>\n\nThis assertion checks if a function was called a certain amount of times. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function called two times', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledTimes(2)\n})\ntoHaveBeenCalledWith\n​\nType: (...args: any[]) => Awaitable<void>\n\nThis assertion checks if a function was called at least once with certain parameters. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenCalledWith('apples', 20)\n})\ntoHaveBeenLastCalledWith\n​\nType: (...args: any[]) => Awaitable<void>\n\nThis assertion checks if a function was called with certain parameters at it's last invocation. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('spy function', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).not.toHaveBeenLastCalledWith('apples', 10)\n  expect(buySpy).toHaveBeenLastCalledWith('apples', 20)\n})\ntoHaveBeenNthCalledWith\n​\nType: (time: number, ...args: any[]) => Awaitable<void>\n\nThis assertion checks if a function was called with certain parameters at the certain time. The count starts at 1. So, to check the second entry, you would write .toHaveBeenNthCalledWith(2, ...).\n\nRequires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nconst market = {\n  buy(subject: string, amount: number) {\n    // ...\n  },\n}\n\ntest('first call of spy function called with right params', () => {\n  const buySpy = vi.spyOn(market, 'buy')\n\n  market.buy('apples', 10)\n  market.buy('apples', 20)\n\n  expect(buySpy).toHaveBeenNthCalledWith(1, 'apples', 10)\n})\ntoHaveReturned\n​\nType: () => Awaitable<void>\n\nThis assertion checks if a function has successfully returned a value at least once (i.e., did not throw an error). Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\nfunction getApplesPrice(amount: number) {\n  const PRICE = 10\n  return amount * PRICE\n}\n\ntest('spy function returned a value', () => {\n  const getPriceSpy = vi.fn(getApplesPrice)\n\n  const price = getPriceSpy(10)\n\n  expect(price).toBe(100)\n  expect(getPriceSpy).toHaveReturned()\n})\ntoHaveReturnedTimes\n​\nType: (amount: number) => Awaitable<void>\n\nThis assertion checks if a function has successfully returned a value exact amount of times (i.e., did not throw an error). Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a value two times', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveReturnedTimes(2)\n})\ntoHaveReturnedWith\n​\nType: (returnValue: any) => Awaitable<void>\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters at least once. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns a product', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n\n  expect(sell).toHaveReturnedWith({ product: 'apples' })\n})\ntoHaveLastReturnedWith\n​\nType: (returnValue: any) => Awaitable<void>\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters on it's last invoking. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on a last call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveLastReturnedWith({ product: 'bananas' })\n})\ntoHaveNthReturnedWith\n​\nType: (time: number, returnValue: any) => Awaitable<void>\n\nYou can call this assertion to check if a function has successfully returned a value with certain parameters on a certain call. Requires a spy function to be passed to expect.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('spy function returns bananas on second call', () => {\n  const sell = vi.fn((product: string) => ({ product }))\n\n  sell('apples')\n  sell('bananas')\n\n  expect(sell).toHaveNthReturnedWith(2, { product: 'bananas' })\n})\ntoSatisfy\n​\nType: (predicate: (value: any) => boolean) => Awaitable<void>\n\nThis assertion checks if a value satisfies a certain predicate.\n\nts\ndescribe('toSatisfy()', () => {\n  const isOdd = (value: number) => value % 2 !== 0\n\n  it('pass with 0', () => {\n    expect(1).toSatisfy(isOdd)\n  })\n\n  it('pass with negotiation', () => {\n    expect(2).not.toSatisfy(isOdd)\n  })\n})\nresolves\n​\nType: Promisify<Assertions>\n\nresolves is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap value from the pending promise and assert its value with usual assertions. If the promise rejects, the assertion will fail.\n\nIt returns the same Assertions object, but all matchers now return Promise, so you would need to await it. Also works with chai assertions.\n\nFor example, if you have a function, that makes an API call and returns some data, you may use this code to assert its return value:\n\nts\nimport { expect, test } from 'vitest'\n\nasync function buyApples() {\n  return fetch('/buy/apples').then(r => r.json())\n}\n\ntest('buyApples returns new stock id', async () => {\n  // toEqual returns a promise now, so you HAVE to await it\n  await expect(buyApples()).resolves.toEqual({ id: 1 }) // jest API\n  await expect(buyApples()).resolves.to.equal({ id: 1 }) // chai API\n})\n\nWARNING\n\nIf the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions are actually called, you may use expect.assertions(number).\n\nrejects\n​\nType: Promisify<Assertions>\n\nrejects is intended to remove boilerplate when asserting asynchronous code. Use it to unwrap reason why the promise was rejected, and assert its value with usual assertions. If the promise successfully resolves, the assertion will fail.\n\nIt returns the same Assertions object, but all matchers now return Promise, so you would need to await it. Also works with chai assertions.\n\nFor example, if you have a function that fails when you call it, you may use this code to assert the reason:\n\nts\nimport { expect, test } from 'vitest'\n\nasync function buyApples(id) {\n  if (!id)\n    throw new Error('no id')\n}\n\ntest('buyApples throws an error when no id provided', async () => {\n  // toThrow returns a promise now, so you HAVE to await it\n  await expect(buyApples()).rejects.toThrow('no id')\n})\n\nWARNING\n\nIf the assertion is not awaited, then you will have a false-positive test that will pass every time. To make sure that assertions were actually called, you can use expect.assertions(number).\n\nexpect.assertions\n​\nType: (count: number) => void\n\nAfter the test has passed or failed verify that a certain number of assertions was called during a test. A useful case would be to check if an asynchronous code was called.\n\nFor example, if we have a function that asynchronously calls two matchers, we can assert that they were actually called.\n\nts\nimport { expect, test } from 'vitest'\n\nasync function doAsync(...cbs) {\n  await Promise.all(\n    cbs.map((cb, index) => cb({ index })),\n  )\n}\n\ntest('all assertions are called', async () => {\n  expect.assertions(2)\n  function callback1(data) {\n    expect(data).toBeTruthy()\n  }\n  function callback2(data) {\n    expect(data).toBeTruthy()\n  }\n\n  await doAsync(callback1, callback2)\n})\n\nWARNING\n\nWhen using assertions with async concurrent tests, expect from the local Test Context must be used to ensure the right test is detected.\n\nexpect.hasAssertions\n​\nType: () => void\n\nAfter the test has passed or failed verify that at least one assertion was called during a test. A useful case would be to check if an asynchronous code was called.\n\nFor example, if you have a code that calls a callback, we can make an assertion inside a callback, but the test will always pass if we don't check if an assertion was called.\n\nts\nimport { expect, test } from 'vitest'\nimport { db } from './db.js'\n\nconst cbs = []\n\nfunction onSelect(cb) {\n  cbs.push(cb)\n}\n\n// after selecting from db, we call all callbacks\nfunction select(id) {\n  return db.select({ id }).then((data) => {\n    return Promise.all(\n      cbs.map(cb => cb(data)),\n    )\n  })\n}\n\ntest('callback was called', async () => {\n  expect.hasAssertions()\n  onSelect((data) => {\n    // should be called on select\n    expect(data).toBeTruthy()\n  })\n  // if not awaited, test will fail\n  // if you don't have expect.hasAssertions(), test will pass\n  await select(3)\n})\nexpect.unreachable\n​\nType: (message?: string) => never\n\nThis method is used to asserting that a line should never be reached.\n\nFor example, if we want to test that build() throws due to receiving directories having no src folder, and also handle each error separately, we could do this:\n\nts\nimport { expect, test } from 'vitest'\n\nasync function build(dir) {\n  if (dir.includes('no-src'))\n    throw new Error(`${dir}/src does not exist`)\n}\n\nconst errorDirs = [\n  'no-src-folder',\n  // ...\n]\n\ntest.each(errorDirs)('build fails with \"%s\"', async (dir) => {\n  try {\n    await build(dir)\n    expect.unreachable('Should not pass build')\n  }\n  catch (err: any) {\n    expect(err).toBeInstanceOf(Error)\n    expect(err.stack).toContain('build')\n\n    switch (dir) {\n      case 'no-src-folder':\n        expect(err.message).toBe(`${dir}/src does not exist`)\n        break\n      default:\n        // to exhaust all error tests\n        expect.unreachable('All error test must be handled')\n        break\n    }\n  }\n})\nexpect.anything\n​\nType: () => any\n\nThis asymmetric matcher, when used with equality check, will always return true. Useful, if you just want to be sure that the property exist.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('object has \"apples\" key', () => {\n  expect({ apples: 22 }).toEqual({ apples: expect.anything() })\n})\nexpect.any\n​\nType: (constructor: unknown) => any\n\nThis asymmetric matcher, when used with an equality check, will return true only if the value is an instance of a specified constructor. Useful, if you have a value that is generated each time, and you only want to know that it exists with a proper type.\n\nts\nimport { expect, test } from 'vitest'\nimport { generateId } from './generators.js'\n\ntest('\"id\" is a number', () => {\n  expect({ id: generateId() }).toEqual({ id: expect.any(Number) })\n})\nexpect.closeTo\n​\nType: (expected: any, precision?: number) => any\nVersion: Since Vitest 1.0.0\n\nexpect.closeTo is useful when comparing floating point numbers in object properties or array item. If you need to compare a number, please use .toBeCloseTo instead.\n\nThe optional numDigits argument limits the number of digits to check after the decimal point. For the default value 2, the test criterion is Math.abs(expected - received) < 0.005 (that is, 10 ** -2 / 2).\n\nFor example, this test passes with a precision of 5 digits:\n\njs\ntest('compare float in object properties', () => {\n  expect({\n    title: '0.1 + 0.2',\n    sum: 0.1 + 0.2,\n  }).toEqual({\n    title: '0.1 + 0.2',\n    sum: expect.closeTo(0.3, 5),\n  })\n})\nexpect.arrayContaining\n​\nType: <T>(expected: T[]) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value is an array and contains specified items.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('basket includes fuji', () => {\n  const basket = {\n    varieties: [\n      'Empire',\n      'Fuji',\n      'Gala',\n    ],\n    count: 3\n  }\n  expect(basket).toEqual({\n    count: 3,\n    varieties: expect.arrayContaining(['Fuji'])\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.objectContaining\n​\nType: (expected: any) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value has a similar shape.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('basket has empire apples', () => {\n  const basket = {\n    varieties: [\n      {\n        name: 'Empire',\n        count: 1,\n      }\n    ],\n  }\n  expect(basket).toEqual({\n    varieties: [\n      expect.objectContaining({ name: 'Empire' }),\n    ]\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.stringContaining\n​\nType: (expected: any) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value is a string and contains a specified substring.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('variety has \"Emp\" in its name', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringContaining('Emp'),\n    count: 1,\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.stringMatching\n​\nType: (expected: any) => any\n\nWhen used with an equality check, this asymmetric matcher will return true if the value is a string and contains a specified substring or if the string matches a regular expression.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('variety ends with \"re\"', () => {\n  const variety = {\n    name: 'Empire',\n    count: 1,\n  }\n  expect(variety).toEqual({\n    name: expect.stringMatching(/re$/),\n    count: 1,\n  })\n})\n\nTIP\n\nYou can use expect.not with this matcher to negate the expected value.\n\nexpect.addSnapshotSerializer\n​\nType: (plugin: PrettyFormatPlugin) => void\n\nThis method adds custom serializers that are called when creating a snapshot. This is an advanced feature - if you want to know more, please read a guide on custom serializers.\n\nIf you are adding custom serializers, you should call this method inside setupFiles. This will affect every snapshot.\n\nTIP\n\nIf you previously used Vue CLI with Jest, you might want to install jest-serializer-vue. Otherwise, your snapshots will be wrapped in a string, which cases \" to be escaped.\n\nexpect.extend\n​\nType: (matchers: MatchersObject) => void\n\nYou can extend default matchers with your own. This function is used to extend the matchers object with custom matchers.\n\nWhen you define matchers that way, you also create asymmetric matchers that can be used like expect.stringContaining.\n\nts\nimport { expect, test } from 'vitest'\n\ntest('custom matchers', () => {\n  expect.extend({\n    toBeFoo: (received, expected) => {\n      if (received !== 'foo') {\n        return {\n          message: () => `expected ${received} to be foo`,\n          pass: false,\n        }\n      }\n    },\n  })\n\n  expect('foo').toBeFoo()\n  expect({ foo: 'foo' }).toEqual({ foo: expect.toBeFoo() })\n})\n\nTIP\n\nIf you want your matchers to appear in every test, you should call this method inside setupFiles.\n\nThis function is compatible with Jest's expect.extend, so any library that uses it to create custom matchers will work with Vitest.\n\nIf you are using TypeScript, since Vitest 0.31.0 you can extend default Assertion interface in an ambient declaration file (e.g: vitest.d.ts) with the code below:\n\nts\ninterface CustomMatchers<R = unknown> {\n  toBeFoo(): R\n}\n\ndeclare module 'vitest' {\n  interface Assertion<T = any> extends CustomMatchers<T> {}\n  interface AsymmetricMatchersContaining extends CustomMatchers {}\n}\n\nWARNING\n\nDon't forget to include the ambient declaration file in your tsconfig.json.\n\nTIP\n\nIf you want to know more, checkout guide on extending matchers."
  },
  {
    "title": "expectTypeOf | Vitest",
    "url": "https://vitest.dev/api/expect-typeof",
    "html": "expectTypeOf\n​\n\nWARNING\n\nDuring runtime this function doesn't do anything. To enable typechecking, don't forget to pass down --typecheck flag.\n\nType: <T>(a: unknown) => ExpectTypeOf\nnot\n​\nType: ExpectTypeOf\n\nYou can negate all assertions, using .not property.\n\ntoEqualTypeOf\n​\nType: <T>(expected: T) => void\n\nThis matcher will check if the types are fully equal to each other. This matcher will not fail if two objects have different values, but the same type. It will fail however if an object is missing a property.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1 }).toEqualTypeOf<{ a: number }>()\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 1 })\nexpectTypeOf({ a: 1 }).toEqualTypeOf({ a: 2 })\nexpectTypeOf({ a: 1, b: 1 }).not.toEqualTypeOf<{ a: number }>()\ntoMatchTypeOf\n​\nType: <T>(expected: T) => void\n\nThis matcher checks if expect type extends provided type. It is different from toEqual and is more similar to expect's toMatchObject(). With this matcher, you can check if an object “matches” a type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf({ a: 1, b: 1 }).toMatchTypeOf({ a: 1 })\nexpectTypeOf<number>().toMatchTypeOf<string | number>()\nexpectTypeOf<string | number>().not.toMatchTypeOf<number>()\nextract\n​\nType: ExpectTypeOf<ExtractedUnion>\n\nYou can use .extract to narrow down types for further testing.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<{ xs?: any }>() // extracts the last type from a union\n  .toEqualTypeOf<{ xs?: CSSProperties; sm?: CSSProperties; md?: CSSProperties }>()\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .extract<unknown[]>() // extracts an array from a union\n  .toEqualTypeOf<CSSProperties[]>()\n\nWARNING\n\nIf no type is found in the union, .extract will return never.\n\nexclude\n​\nType: ExpectTypeOf<NonExcludedUnion>\n\nYou can use .exclude to remove types from a union for further testing.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype ResponsiveProp<T> = T | T[] | { xs?: T; sm?: T; md?: T }\n\ninterface CSSProperties { margin?: string; padding?: string }\n\nfunction getResponsiveProp<T>(_props: T): ResponsiveProp<T> {\n  return {}\n}\n\nconst cssProperties: CSSProperties = { margin: '1px', padding: '2px' }\n\nexpectTypeOf(getResponsiveProp(cssProperties))\n  .exclude<unknown[]>()\n  .exclude<{ xs?: unknown }>() // or just .exclude<unknown[] | { xs?: unknown }>()\n  .toEqualTypeOf<CSSProperties>()\n\nWARNING\n\nIf no type is found in the union, .exclude will return never.\n\nreturns\n​\nType: ExpectTypeOf<ReturnValue>\n\nYou can use .returns to extract return value of a function type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf((a: number) => [a, a]).returns.toEqualTypeOf([1, 2])\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nparameters\n​\nType: ExpectTypeOf<Parameters>\n\nYou can extract function arguments with .parameters to perform assertions on its value. Parameters are returned as an array.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().parameters.toEqualTypeOf<[]>()\nexpectTypeOf<HasParam>().parameters.toEqualTypeOf<[string]>()\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nTIP\n\nYou can also use .toBeCallableWith matcher as a more expressive assertion.\n\nparameter\n​\nType: (nth: number) => ExpectTypeOf\n\nYou can extract a certain function argument with .parameter(number) call to perform other assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nfunction foo(a: number, b: string) {\n  return [a, b]\n}\n\nexpectTypeOf(foo).parameter(0).toBeNumber()\nexpectTypeOf(foo).parameter(1).toBeString()\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nconstructorParameters\n​\nType: ExpectTypeOf<ConstructorParameters>\n\nYou can extract constructor parameters as an array of values and perform assertions on them with this method.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).constructorParameters.toEqualTypeOf<[] | [string | number | Date]>()\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nTIP\n\nYou can also use .toBeConstructibleWith matcher as a more expressive assertion.\n\ninstance\n​\nType: ExpectTypeOf<ConstructableInstance>\n\nThis property gives access to matchers that can be performed on an instance of the provided class.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).instance.toHaveProperty('toISOString')\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\nitems\n​\nType: ExpectTypeOf<T>\n\nYou can get array item type with .items to perform further assertions.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf([1, 2, 3]).items.toEqualTypeOf<number>()\nexpectTypeOf([1, 2, 3]).items.not.toEqualTypeOf<string>()\nresolves\n​\nType: ExpectTypeOf<ResolvedPromise>\n\nThis matcher extracts resolved value of a Promise, so you can perform other assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nasync function asyncFunc() {\n  return 123\n}\n\nexpectTypeOf(asyncFunc).returns.resolves.toBeNumber()\nexpectTypeOf(Promise.resolve('string')).resolves.toBeString()\n\nWARNING\n\nIf used on a non-promise type, it will return never, so you won't be able to chain it with other matchers.\n\nguards\n​\nType: ExpectTypeOf<Guard>\n\nThis matcher extracts guard value (e.g., v is number), so you can perform assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nfunction isString(v: any): v is string {\n  return typeof v === 'string'\n}\nexpectTypeOf(isString).guards.toBeString()\n\nWARNING\n\nReturns never, if the value is not a guard function, so you won't be able to chain it with other matchers.\n\nasserts\n​\nType: ExpectTypeOf<Assert>\n\nThis matcher extracts assert value (e.g., assert v is number), so you can perform assertions on it.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nfunction assertNumber(v: any): asserts v is number {\n  if (typeof v !== 'number')\n    throw new TypeError('Nope !')\n}\n\nexpectTypeOf(assertNumber).asserts.toBeNumber()\n\nWARNING\n\nReturns never, if the value is not an assert function, so you won't be able to chain it with other matchers.\n\ntoBeAny\n​\nType: () => void\n\nWith this matcher you can check, if provided type is any type. If the type is too specific, the test will fail.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<any>().toBeAny()\nexpectTypeOf({} as any).toBeAny()\nexpectTypeOf('string').not.toBeAny()\ntoBeUnknown\n​\nType: () => void\n\nThis matcher checks, if provided type is unknown type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf().toBeUnknown()\nexpectTypeOf({} as unknown).toBeUnknown()\nexpectTypeOf('string').not.toBeUnknown()\ntoBeNever\n​\nType: () => void\n\nThis matcher checks, if provided type is a never type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<never>().toBeNever()\nexpectTypeOf((): never => {}).returns.toBeNever()\ntoBeFunction\n​\nType: () => void\n\nThis matcher checks, if provided type is a function.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeFunction()\nexpectTypeOf((): never => {}).toBeFunction()\ntoBeObject\n​\nType: () => void\n\nThis matcher checks, if provided type is an object.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeObject()\nexpectTypeOf({}).toBeObject()\ntoBeArray\n​\nType: () => void\n\nThis matcher checks, if provided type is Array<T>.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeArray()\nexpectTypeOf([]).toBeArray()\nexpectTypeOf([1, 2]).toBeArray()\nexpectTypeOf([{}, 42]).toBeArray()\ntoBeString\n​\nType: () => void\n\nThis matcher checks, if provided type is a string.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeString()\nexpectTypeOf('').toBeString()\nexpectTypeOf('a').toBeString()\ntoBeBoolean\n​\nType: () => void\n\nThis matcher checks, if provided type is boolean.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(42).not.toBeBoolean()\nexpectTypeOf(true).toBeBoolean()\nexpectTypeOf<boolean>().toBeBoolean()\ntoBeVoid\n​\nType: () => void\n\nThis matcher checks, if provided type is void.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(() => {}).returns.toBeVoid()\nexpectTypeOf<void>().toBeVoid()\ntoBeSymbol\n​\nType: () => void\n\nThis matcher checks, if provided type is a symbol.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Symbol(1)).toBeSymbol()\nexpectTypeOf<symbol>().toBeSymbol()\ntoBeNull\n​\nType: () => void\n\nThis matcher checks, if provided type is null.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(null).toBeNull()\nexpectTypeOf<null>().toBeNull()\nexpectTypeOf(undefined).not.toBeNull()\ntoBeUndefined\n​\nType: () => void\n\nThis matcher checks, if provided type is undefined.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(undefined).toBeUndefined()\nexpectTypeOf<undefined>().toBeUndefined()\nexpectTypeOf(null).not.toBeUndefined()\ntoBeNullable\n​\nType: () => void\n\nThis matcher checks, if you can use null or undefined with provided type.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf<1 | undefined>().toBeNullable()\nexpectTypeOf<1 | null>().toBeNullable()\nexpectTypeOf<1 | undefined | null>().toBeNullable()\ntoBeCallableWith\n​\nType: () => void\n\nThis matcher ensures you can call provided function with a set of parameters.\n\nts\nimport { expectTypeOf } from 'vitest'\n\ntype NoParam = () => void\ntype HasParam = (s: string) => void\n\nexpectTypeOf<NoParam>().toBeCallableWith()\nexpectTypeOf<HasParam>().toBeCallableWith('some string')\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\ntoBeConstructibleWith\n​\nType: () => void\n\nThis matcher ensures you can create a new instance with a set of constructor parameters.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nexpectTypeOf(Date).toBeConstructibleWith(new Date())\nexpectTypeOf(Date).toBeConstructibleWith('01-01-2000')\n\nWARNING\n\nIf used on a non-function type, it will return never, so you won't be able to chain it with other matchers.\n\ntoHaveProperty\n​\nType: <K extends keyof T>(property: K) => ExpectTypeOf<T[K>\n\nThis matcher checks if a property exists on the provided object. If it exists, it also returns the same set of matchers for the type of this property, so you can chain assertions one after another.\n\nts\nimport { expectTypeOf } from 'vitest'\n\nconst obj = { a: 1, b: '' }\n\nexpectTypeOf(obj).toHaveProperty('a')\nexpectTypeOf(obj).not.toHaveProperty('c')\n\nexpectTypeOf(obj).toHaveProperty('a').toBeNumber()\nexpectTypeOf(obj).toHaveProperty('b').toBeString()\nexpectTypeOf(obj).toHaveProperty('a').not.toBeString()"
  },
  {
    "title": "Vi | Vitest",
    "url": "https://vitest.dev/api/vi",
    "html": "Vi\n​\n\nVitest provides utility functions to help you out through its vi helper. You can access it globally (when globals configuration is enabled), or import it from vitest directly:\n\njs\nimport { vi } from 'vitest'\nMock Modules\n​\n\nThis section describes the API that you can use when mocking a module. Beware that Vitest doesn't support mocking modules imported using require().\n\nvi.mock\n​\nType: (path: string, factory?: (importOriginal: () => unknown) => unknown) => void\n\nSubstitutes all imported modules from provided path with another module. You can use configured Vite aliases inside a path. The call to vi.mock is hoisted, so it doesn't matter where you call it. It will always be executed before all imports. If you need to reference some variables outside of its scope, you can define them inside vi.hoisted and reference them inside vi.mock.\n\nWARNING\n\nvi.mock works only for modules that were imported with the import keyword. It doesn't work with require.\n\nIn order to hoist vi.mock, Vitest statically analyzes your files. It indicates that vi that was not directly imported from the vitest package (for example, from some utility file) cannot be used. Use vi.mock with vi imported from vitest, or enable globals config option.\n\nVitest will not mock modules that were imported inside a setup file because they are cached by the time a test file is running. You can call vi.resetModules() inside vi.hoisted to clear all module caches before running a test file.\n\nWARNING\n\nThe browser mode does not presently support mocking modules. You can track this feature in the GitHub issue.\n\nIf factory is defined, all imports will return its result. Vitest calls factory only once and caches results for all subsequent imports until vi.unmock or vi.doUnmock is called.\n\nUnlike in jest, the factory can be asynchronous, so you can use vi.importActual or a helper, received as the first argument, inside to get the original module.\n\njs\n// when using JavaScript\n\nvi.mock('./path/to/module.js', async (importOriginal) => {\n  const mod = await importOriginal()\n  return {\n    ...mod,\n    // replace some exports\n    namedExport: vi.fn(),\n  }\n})\nts\n// when using TypeScript\n\nvi.mock('./path/to/module.js', async (importOriginal) => {\n  const mod = await importOriginal<typeof import('./path/to/module.js')>()\n  return {\n    ...mod,\n    // replace some exports\n    namedExport: vi.fn(),\n  }\n})\n\nWARNING\n\nvi.mock is hoisted (in other words, moved) to top of the file. It means that whenever you write it (be it inside beforeEach or test), it will actually be called before that.\n\nThis also means that you cannot use any variables inside the factory that are defined outside the factory.\n\nIf you need to use variables inside the factory, try vi.doMock. It works the same way but isn't hoisted. Beware that it only mocks subsequent imports.\n\nYou can also reference variables defined by vi.hoisted method if it was declared before vi.mock:\n\nts\nimport { namedExport } from './path/to/module.js'\n\nconst mocks = vi.hoisted(() => {\n  return {\n    namedExport: vi.fn(),\n  }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return {\n    namedExport: mocks.namedExport,\n  }\n})\n\nvi.mocked(namedExport).mockReturnValue(100)\n\nexpect(namedExport()).toBe(100)\nexpect(namedExport).toBe(mocks.namedExport)\n\nWARNING\n\nIf you are mocking a module with default export, you will need to provide a default key within the returned factory function object. This is an ES module-specific caveat; therefore, jest documentation may differ as jest uses CommonJS modules. For example,\n\nts\nvi.mock('./path/to/module.js', () => {\n  return {\n    default: { myDefaultKey: vi.fn() },\n    namedExport: vi.fn(),\n    // etc...\n  }\n})\n\nIf there is a __mocks__ folder alongside a file that you are mocking, and the factory is not provided, Vitest will try to find a file with the same name in the __mocks__ subfolder and use it as an actual module. If you are mocking a dependency, Vitest will try to find a __mocks__ folder in the root of the project (default is process.cwd()). You can tell Vitest where the dependencies are located through the deps.moduleDirectories config option.\n\nFor example, you have this file structure:\n\n- __mocks__\n  - axios.js\n- src\n  __mocks__\n    - increment.js\n  - increment.js\n- tests\n  - increment.test.js\n\nIf you call vi.mock in a test file without a factory provided, it will find a file in the __mocks__ folder to use as a module:\n\nts\n// increment.test.js\nimport { vi } from 'vitest'\n\n// axios is a default export from `__mocks__/axios.js`\nimport axios from 'axios'\n\n// increment is a named export from `src/__mocks__/increment.js`\nimport { increment } from '../increment.js'\n\nvi.mock('axios')\nvi.mock('../increment.js')\n\naxios.get(`/apples/${increment(1)}`)\n\nWARNING\n\nBeware that if you don't call vi.mock, modules are not mocked automatically. To replicate Jest's automocking behaviour, you can call vi.mock for each required module inside setupFiles.\n\nIf there is no __mocks__ folder or a factory provided, Vitest will import the original module and auto-mock all its exports. For the rules applied, see algorithm.\n\nvi.doMock\n​\nType: (path: string, factory?: (importOriginal: () => unknown) => unknown) => void\n\nThe same as vi.mock, but it's not hoisted to the top of the file, so you can reference variables in the global file scope. The next dynamic import of the module will be mocked.\n\nWARNING\n\nThis will not mock modules that were imported before this was called. Don't forget that all static imports in ESM are always hoisted, so putting this before static import will not force it to be called before the import:\n\nts\nvi.doMock('./increment.js') // this will be called _after_ the import statement\n\nimport { increment } from './increment.js'\nts\n// ./increment.js\nexport function increment(number) {\n  return number + 1\n}\nts\nimport { beforeEach, test } from 'vitest'\nimport { increment } from './increment.js'\n\n// the module is not mocked, because vi.doMock is not called yet\nincrement(1) === 2\n\nlet mockedIncrement = 100\n\nbeforeEach(() => {\n  // you can access variables inside a factory\n  vi.doMock('./increment.js', () => ({ increment: () => ++mockedIncrement }))\n})\n\ntest('importing the next module imports mocked one', async () => {\n  // original import WAS NOT MOCKED, because vi.doMock is evaluated AFTER imports\n  expect(increment(1)).toBe(2)\n  const { increment: mockedIncrement } = await import('./increment.js')\n  // new dynamic import returns mocked module\n  expect(mockedIncrement(1)).toBe(101)\n  expect(mockedIncrement(1)).toBe(102)\n  expect(mockedIncrement(1)).toBe(103)\n})\nvi.mocked\n​\nType: <T>(obj: T, deep?: boolean) => MaybeMockedDeep<T>\nType: <T>(obj: T, options?: { partial?: boolean; deep?: boolean }) => MaybePartiallyMockedDeep<T>\n\nType helper for TypeScript. Just returns the object that was passed.\n\nWhen partial is true it will expect a Partial<T> as a return value. By default, this will only make TypeScript believe that the first level values are mocked. You can pass down { deep: true } as a second argument to tell TypeScript that the whole object is mocked, if it actually is.\n\nts\nimport example from './example.js'\n\nvi.mock('./example.js')\n\ntest('1 + 1 equals 10', async () => {\n  vi.mocked(example.calc).mockReturnValue(10)\n  expect(example.calc(1, '+', 1)).toBe(10)\n})\nvi.importActual\n​\nType: <T>(path: string) => Promise<T>\n\nImports module, bypassing all checks if it should be mocked. Can be useful if you want to mock module partially.\n\nts\nvi.mock('./example.js', async () => {\n  const axios = await vi.importActual('./example.js')\n\n  return { ...axios, get: vi.fn() }\n})\nvi.importMock\n​\nType: <T>(path: string) => Promise<MaybeMockedDeep<T>>\n\nImports a module with all of its properties (including nested properties) mocked. Follows the same rules that vi.mock does. For the rules applied, see algorithm.\n\nvi.unmock\n​\nType: (path: string) => void\n\nRemoves module from the mocked registry. All calls to import will return the original module even if it was mocked before. This call is hoisted to the top of the file, so it will only unmock modules that were defined in setupFiles, for example.\n\nvi.doUnmock\n​\nType: (path: string) => void\n\nThe same as vi.unmock, but is not hoisted to the top of the file. The next import of the module will import the original module instead of the mock. This will not unmock previously imported modules.\n\nts\n// ./increment.js\nexport function increment(number) {\n  return number + 1\n}\nts\nimport { increment } from './increment.js'\n\n// increment is already mocked, because vi.mock is hoisted\nincrement(1) === 100\n\n// this is hoisted, and factory is called before the import on line 1\nvi.mock('./increment.js', () => ({ increment: () => 100 }))\n\n// all calls are mocked, and `increment` always returns 100\nincrement(1) === 100\nincrement(30) === 100\n\n// this is not hoisted, so other import will return unmocked module\nvi.doUnmock('./increment.js')\n\n// this STILL returns 100, because `vi.doUnmock` doesn't reevaluate a module\nincrement(1) === 100\nincrement(30) === 100\n\n// the next import is unmocked, now `increment` is the original function that returns count + 1\nconst { increment: unmockedIncrement } = await import('./increment.js')\n\nunmockedIncrement(1) === 2\nunmockedIncrement(30) === 31\nvi.resetModules\n​\nType: () => Vitest\n\nResets modules registry by clearing the cache of all modules. This allows modules to be reevaluated when reimported. Top-level imports cannot be re-evaluated. Might be useful to isolate modules where local state conflicts between tests.\n\nts\nimport { vi } from 'vitest'\n\nimport { data } from './data.js' // Will not get reevaluated beforeEach test\n\nbeforeEach(() => {\n  vi.resetModules()\n})\n\ntest('change state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  mod.changeLocalState('new value')\n  expect(mod.getLocalState()).toBe('new value')\n})\n\ntest('module has old state', async () => {\n  const mod = await import('./some/path.js') // Will get reevaluated\n  expect(mod.getLocalState()).toBe('old value')\n})\n\nWARNING\n\nDoes not reset mocks registry. To clear mocks registry, use vi.unmock or vi.doUnmock.\n\nvi.dynamicImportSettled\n​\n\nWait for all imports to load. Useful, if you have a synchronous call that starts importing a module that you cannot wait otherwise.\n\nts\nimport { expect, test } from 'vitest'\n\n// cannot track import because Promise is not returned\nfunction renderComponent() {\n  import('./component.js').then(({ render }) => {\n    render()\n  })\n}\n\ntest('operations are resolved', async () => {\n  renderComponent()\n  await vi.dynamicImportSettled()\n  expect(document.querySelector('.component')).not.toBeNull()\n})\n\nTIP\n\nIf during a dynamic import another dynamic import is initiated, this method will wait until all of them are resolved.\n\nThis method will also wait for the next setTimeout tick after the import is resolved so all synchronous operations should be completed by the time it's resolved.\n\nMocking Functions and Objects\n​\n\nThis section describes how to work with method mocks and replace environmental and global variables.\n\nvi.fn\n​\nType: (fn?: Function) => Mock\n\nCreates a spy on a function, though can be initiated without one. Every time a function is invoked, it stores its call arguments, returns, and instances. Also, you can manipulate its behavior with methods. If no function is given, mock will return undefined, when invoked.\n\nts\nconst getApples = vi.fn(() => 0)\n\ngetApples()\n\nexpect(getApples).toHaveBeenCalled()\nexpect(getApples).toHaveReturnedWith(0)\n\ngetApples.mockReturnValueOnce(5)\n\nconst res = getApples()\nexpect(res).toBe(5)\nexpect(getApples).toHaveNthReturnedWith(2, 5)\nvi.isMockFunction\n​\nType: (fn: Function) => boolean\n\nChecks that a given parameter is a mock function. If you are using TypeScript, it will also narrow down its type.\n\nvi.clearAllMocks\n​\n\nWill call .mockClear() on all spies. This will clear mock history, but not reset its implementation to the default one.\n\nvi.resetAllMocks\n​\n\nWill call .mockReset() on all spies. This will clear mock history and reset its implementation to an empty function (will return undefined).\n\nvi.restoreAllMocks\n​\n\nWill call .mockRestore() on all spies. This will clear mock history and reset its implementation to the original one.\n\nvi.spyOn\n​\nType: <T, K extends keyof T>(object: T, method: K, accessType?: 'get' | 'set') => MockInstance\n\nCreates a spy on a method or getter/setter of an object similar to vi.fn(). It returns a mock function.\n\nts\nlet apples = 0\nconst cart = {\n  getApples: () => 42,\n}\n\nconst spy = vi.spyOn(cart, 'getApples').mockImplementation(() => apples)\napples = 1\n\nexpect(cart.getApples()).toBe(1)\n\nexpect(spy).toHaveBeenCalled()\nexpect(spy).toHaveReturnedWith(1)\n\nTIP\n\nYou can call vi.restoreAllMocks inside afterEach (or enable test.restoreMocks) to restore all methods to their original implementations. This will restore the original object descriptor, so you won't be able to change method's implementation:\n\nts\nconst cart = {\n  getApples: () => 42,\n}\n\nconst spy = vi.spyOn(cart, 'getApples').mockReturnValue(10)\n\nconsole.log(cart.getApples()) // 10\nvi.restoreAllMocks()\nconsole.log(cart.getApples()) // 42\nspy.mockReturnValue(10)\nconsole.log(cart.getApples()) // still 42!\nvi.stubEnv\n​\nType: (name: string, value: string) => Vitest\nVersion: Since Vitest 0.26.0\n\nChanges the value of environmental variable on process.env and import.meta.env. You can restore its value by calling vi.unstubAllEnvs.\n\nts\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling \"vi.stubEnv\"\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n// doesn't change other envs\nimport.meta.env.MODE === 'development'\n\nTIP\n\nYou can also change the value by simply assigning it, but you won't be able to use vi.unstubAllEnvs to restore previous value:\n\nts\nimport.meta.env.MODE = 'test'\nvi.unstubAllEnvs\n​\nType: () => Vitest\nVersion: Since Vitest 0.26.0\n\nRestores all import.meta.env and process.env values that were changed with vi.stubEnv. When it's called for the first time, Vitest remembers the original value and will store it, until unstubAllEnvs is called again.\n\nts\nimport { vi } from 'vitest'\n\n// `process.env.NODE_ENV` and `import.meta.env.NODE_ENV`\n// are \"development\" before calling stubEnv\n\nvi.stubEnv('NODE_ENV', 'production')\n\nprocess.env.NODE_ENV === 'production'\nimport.meta.env.NODE_ENV === 'production'\n\nvi.stubEnv('NODE_ENV', 'staging')\n\nprocess.env.NODE_ENV === 'staging'\nimport.meta.env.NODE_ENV === 'staging'\n\nvi.unstubAllEnvs()\n\n// restores to the value that were stored before the first \"stubEnv\" call\nprocess.env.NODE_ENV === 'development'\nimport.meta.env.NODE_ENV === 'development'\nvi.stubGlobal\n​\nType: (name: string | number | symbol, value: unknown) => Vitest\n\nChanges the value of global variable. You can restore its original value by calling vi.unstubAllGlobals.\n\nts\nimport { vi } from 'vitest'\n\n// `innerWidth` is \"0\" before calling stubGlobal\n\nvi.stubGlobal('innerWidth', 100)\n\ninnerWidth === 100\nglobalThis.innerWidth === 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth === 100\n\nTIP\n\nYou can also change the value by simply assigning it to globalThis or window (if you are using jsdom or happy-dom environment), but you won't be able to use vi.unstubAllGlobals to restore original value:\n\nts\nglobalThis.innerWidth = 100\n// if you are using jsdom or happy-dom\nwindow.innerWidth = 100\nvi.unstubAllGlobals\n​\nType: () => Vitest\nVersion: Since Vitest 0.26.0\n\nRestores all global values on globalThis/global (and window/top/self/parent, if you are using jsdom or happy-dom environment) that were changed with vi.stubGlobal. When it's called for the first time, Vitest remembers the original value and will store it, until unstubAllGlobals is called again.\n\nts\nimport { vi } from 'vitest'\n\nconst Mock = vi.fn()\n\n// IntersectionObserver is \"undefined\" before calling \"stubGlobal\"\n\nvi.stubGlobal('IntersectionObserver', Mock)\n\nIntersectionObserver === Mock\nglobal.IntersectionObserver === Mock\nglobalThis.IntersectionObserver === Mock\n// if you are using jsdom or happy-dom\nwindow.IntersectionObserver === Mock\n\nvi.unstubAllGlobals()\n\nglobalThis.IntersectionObserver === undefined\n'IntersectionObserver' in globalThis === false\n// throws ReferenceError, because it's not defined\nIntersectionObserver === undefined\nFake Timers\n​\n\nThis sections descibes how to work with fake timers.\n\nvi.advanceTimersByTime\n​\nType: (ms: number) => Vitest\n\nThis method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first.\n\nts\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersByTime(150)\n\n// log: 1\n// log: 2\n// log: 3\nvi.advanceTimersByTimeAsync\n​\nType: (ms: number) => Promise<Vitest>\n\nThis method will invoke every initiated timer until the specified number of milliseconds is passed or the queue is empty - whatever comes first. This will include asynchronously set timers.\n\nts\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersByTimeAsync(150)\n\n// log: 1\n// log: 2\n// log: 3\nvi.advanceTimersToNextTimer\n​\nType: () => Vitest\n\nWill call next available timer. Useful to make assertions between each timer call. You can chain call it to manage timers by yourself.\n\nts\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.advanceTimersToNextTimer() // log: 1\n  .advanceTimersToNextTimer() // log: 2\n  .advanceTimersToNextTimer() // log: 3\nvi.advanceTimersToNextTimerAsync\n​\nType: () => Promise<Vitest>\n\nWill call next available timer and wait until it's resolved if it was set asynchronously. Useful to make assertions between each timer call.\n\nts\nlet i = 0\nsetInterval(() => Promise.resolve().then(() => console.log(++i)), 50)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 1\nexpect(console.log).toHaveBeenCalledWith(1)\n\nawait vi.advanceTimersToNextTimerAsync() // log: 2\nawait vi.advanceTimersToNextTimerAsync() // log: 3\nvi.getTimerCount\n​\nType: () => number\n\nGet the number of waiting timers.\n\nvi.clearAllTimers\n​\n\nRemoves all timers that are scheduled to run. These timers will never run in the future.\n\nvi.getMockedSystemTime\n​\nType: () => Date | null\n\nReturns mocked current date that was set using setSystemTime. If date is not mocked the method will return null.\n\nvi.getRealSystemTime\n​\nType: () => number\n\nWhen using vi.useFakeTimers, Date.now calls are mocked. If you need to get real time in milliseconds, you can call this function.\n\nvi.runAllTicks\n​\nType: () => Vitest\n\nCalls every microtask that was queued by process.nextTick. This will also run all microtasks scheduled by themselves.\n\nvi.runAllTimers\n​\nType: () => Vitest\n\nThis method will invoke every initiated timer until the timer queue is empty. It means that every timer called during runAllTimers will be fired. If you have an infinite interval, it will throw after 10 000 tries (can be configured with fakeTimers.loopLimit).\n\nts\nlet i = 0\nsetTimeout(() => console.log(++i))\nconst interval = setInterval(() => {\n  console.log(++i)\n  if (i === 3)\n    clearInterval(interval)\n}, 50)\n\nvi.runAllTimers()\n\n// log: 1\n// log: 2\n// log: 3\nvi.runAllTimersAsync\n​\nType: () => Promise<Vitest>\n\nThis method will asynchronously invoke every initiated timer until the timer queue is empty. It means that every timer called during runAllTimersAsync will be fired even asynchronous timers. If you have an infinite interval, it will throw after 10 000 tries (can be configured with fakeTimers.loopLimit).\n\nts\nsetTimeout(async () => {\n  console.log(await Promise.resolve('result'))\n}, 100)\n\nawait vi.runAllTimersAsync()\n\n// log: result\nvi.runOnlyPendingTimers\n​\nType: () => Vitest\n\nThis method will call every timer that was initiated after vi.useFakeTimers call. It will not fire any timer that was initiated during its call.\n\nts\nlet i = 0\nsetInterval(() => console.log(++i), 50)\n\nvi.runOnlyPendingTimers()\n\n// log: 1\nvi.runOnlyPendingTimersAsync\n​\nType: () => Promise<Vitest>\n\nThis method will asynchronously call every timer that was initiated after vi.useFakeTimers call, even asynchronous ones. It will not fire any timer that was initiated during its call.\n\nts\nsetTimeout(() => {\n  console.log(1)\n}, 100)\nsetTimeout(() => {\n  Promise.resolve().then(() => {\n    console.log(2)\n    setInterval(() => {\n      console.log(3)\n    }, 40)\n  })\n}, 10)\n\nawait vi.runOnlyPendingTimersAsync()\n\n// log: 2\n// log: 3\n// log: 3\n// log: 1\nvi.setSystemTime\n​\nType: (date: string | number | Date) => void\n\nIf fake timers are enabled, this method simulates a user changing the system clock (will affect date related API like hrtime, performance.now or new Date()) - however, it will not fire any timers. If fake timers are not enabled, this method will only mock Date.* calls.\n\nUseful if you need to test anything that depends on the current date - for example Luxon calls inside your code.\n\nts\nconst date = new Date(1998, 11, 19)\n\nvi.useFakeTimers()\nvi.setSystemTime(date)\n\nexpect(Date.now()).toBe(date.valueOf())\n\nvi.useRealTimers()\nvi.useFakeTimers\n​\nType: () => Vitest\n\nTo enable mocking timers, you need to call this method. It will wrap all further calls to timers (such as setTimeout, setInterval, clearTimeout, clearInterval, nextTick, setImmediate, clearImmediate, and Date), until vi.useRealTimers() is called.\n\nMocking nextTick is not supported when running Vitest inside node:child_process by using --pool=forks. NodeJS uses process.nextTick internally in node:child_process and hangs when it is mocked. Mocking nextTick is supported when running Vitest with --pool=threads.\n\nThe implementation is based internally on @sinonjs/fake-timers.\n\nTIP\n\nSince version 0.35.0 vi.useFakeTimers() no longer automatically mocks process.nextTick. It can still be mocked by specifying the option in toFake argument: vi.useFakeTimers({ toFake: ['nextTick'] }).\n\nvi.isFakeTimers\n​\nType: () => boolean\nVersion: Since Vitest 0.34.5\n\nReturns true if fake timers are enabled.\n\nvi.useRealTimers\n​\nType: () => Vitest\n\nWhen timers are run out, you may call this method to return mocked timers to its original implementations. All timers that were scheduled before will be discarded.\n\nMiscellaneous\n​\n\nA set of useful helper functions that Vitest provides.\n\nvi.waitFor\n​\nType: <T>(callback: WaitForCallback<T>, options?: number | WaitForOptions) => Promise<T>\nVersion: Since Vitest 0.34.5\n\nWait for the callback to execute successfully. If the callback throws an error or returns a rejected promise it will continue to wait until it succeeds or times out.\n\nThis is very useful when you need to wait for some asynchronous action to complete, for example, when you start a server and need to wait for it to start.\n\nts\nimport { expect, test, vi } from 'vitest'\nimport { createServer } from './server.js'\n\ntest('Server started successfully', async () => {\n  const server = createServer()\n\n  await vi.waitFor(\n    () => {\n      if (!server.isReady)\n        throw new Error('Server not started')\n\n      console.log('Server started')\n    },\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n  expect(server.isReady).toBe(true)\n})\n\nIt also works for asynchronous callbacks\n\nts\n// @vitest-environment jsdom\n\nimport { expect, test, vi } from 'vitest'\nimport { getDOMElementAsync, populateDOMAsync } from './dom.js'\n\ntest('Element exists in a DOM', async () => {\n  // start populating DOM\n  populateDOMAsync()\n\n  const element = await vi.waitFor(async () => {\n    // try to get the element until it exists\n    const element = await getDOMElementAsync() as HTMLElement | null\n    expect(element).toBeTruthy()\n    expect(element.dataset.initialized).toBeTruthy()\n    return element\n  }, {\n    timeout: 500, // default is 1000\n    interval: 20, // default is 50\n  })\n  expect(element).toBeInstanceOf(HTMLElement)\n})\n\nIf vi.useFakeTimers is used, vi.waitFor automatically calls vi.advanceTimersByTime(interval) in every check callback.\n\nvi.waitUntil\n​\nType: <T>(callback: WaitUntilCallback<T>, options?: number | WaitUntilOptions) => Promise<T>\nVersion: Since Vitest 0.34.5\n\nThis is similar to vi.waitFor, but if the callback throws any errors, execution is immediately interrupted and an error message is received. If the callback returns falsy value, the next check will continue until truthy value is returned. This is useful when you need to wait for something to exist before taking the next step.\n\nLook at the example below. We can use vi.waitUntil to wait for the element to appear on the page, and then we can do something with the element.\n\nts\nimport { expect, test, vi } from 'vitest'\n\ntest('Element render correctly', async () => {\n  const element = await vi.waitUntil(\n    () => document.querySelector('.element'),\n    {\n      timeout: 500, // default is 1000\n      interval: 20, // default is 50\n    }\n  )\n\n  // do something with the element\n  expect(element.querySelector('.element-child')).toBeTruthy()\n})\nvi.hoisted\n​\nType: <T>(factory: () => T) => T\nVersion: Since Vitest 0.31.0\n\nAll static import statements in ES modules are hoisted to the top of the file, so any code that is defined before the imports will actually be executed after imports are evaluated.\n\nHowever, it can be useful to invoke some side effects like mocking dates before importing a module.\n\nTo bypass this limitation, you can rewrite static imports into dynamic ones like this:\n\ndiff\ncallFunctionWithSideEffect()\n- import { value } from './some/module.js'\n+ const { value } = await import('./some/module.js')\n\nWhen running vitest, you can do this automatically by using vi.hoisted method.\n\ndiff\n- callFunctionWithSideEffect()\nimport { value } from './some/module.js'\n+ vi.hoisted(() => callFunctionWithSideEffect())\n\nThis method returns the value that was returned from the factory. You can use that value in your vi.mock factories if you need easy access to locally defined variables:\n\nts\nimport { expect, vi } from 'vitest'\nimport { originalMethod } from './path/to/module.js'\n\nconst { mockedMethod } = vi.hoisted(() => {\n  return { mockedMethod: vi.fn() }\n})\n\nvi.mock('./path/to/module.js', () => {\n  return { originalMethod: mockedMethod }\n})\n\nmockedMethod.mockReturnValue(100)\nexpect(originalMethod()).toBe(100)\n\nNote that this method can also be called asynchronously even if your environment doesn't support top-level await:\n\nts\nconst promised = await vi.hoisted(async () => {\n  const response = await fetch('https://jsonplaceholder.typicode.com/posts')\n  return response.json()\n})\nvi.setConfig\n​\nType: RuntimeConfig\n\nUpdates config for the current test file. This method supports only config options that will affect the current test file:\n\nts\nvi.setConfig({\n  allowOnly: true,\n  testTimeout: 10_000,\n  hookTimeout: 10_000,\n  clearMocks: true,\n  restoreMocks: true,\n  fakeTimers: {\n    now: new Date(2021, 11, 19),\n    // supports the whole object\n  },\n  maxConcurrency: 10,\n  sequence: {\n    hooks: 'stack'\n    // supports only \"sequence.hooks\"\n  }\n})\nvi.resetConfig\n​\nType: RuntimeConfig\n\nIf vi.setConfig was called before, this will reset config to the original state."
  },
  {
    "title": "Mock Functions | Vitest",
    "url": "https://vitest.dev/api/mock",
    "html": "Mock Functions\n​\n\nYou can create a mock function to track its execution with vi.fn method. If you want to track a method on an already created object, you can use vi.spyOn method:\n\njs\nimport { vi } from 'vitest'\n\nconst fn = vi.fn()\nfn('hello world')\nfn.mock.calls[0] === ['hello world']\n\nconst market = {\n  getApples: () => 100\n}\n\nconst getApplesSpy = vi.spyOn(market, 'getApples')\nmarket.getApples()\ngetApplesSpy.mock.calls.length === 1\n\nYou should use mock assertions (e.g., toHaveBeenCalled) on expect to assert mock result. This API reference describes available properties and methods to manipulate mock behavior.\n\ngetMockImplementation\n​\nType: (...args: any) => any\n\nReturns current mock implementation if there is one.\n\nIf mock was created with vi.fn, it will consider passed down method as a mock implementation.\n\nIf mock was created with vi.spyOn, it will return undefined unless a custom implementation was provided.\n\ngetMockName\n​\nType: () => string\n\nUse it to return the name given to mock with method .mockName(name).\n\nmockClear\n​\nType: () => MockInstance\n\nClears all information about every call. After calling it, all properties on .mock will return empty state. This method does not reset implementations. It is useful if you need to clean up mock between different assertions.\n\nIf you want this method to be called before each test automatically, you can enable clearMocks setting in config.\n\nmockName\n​\nType: (name: string) => MockInstance\n\nSets internal mock name. Useful to see the name of the mock if assertion fails.\n\nmockImplementation\n​\nType: (fn: Function) => MockInstance\n\nAccepts a function that will be used as an implementation of the mock.\n\nts\nconst mockFn = vi.fn().mockImplementation(apples => apples + 1)\n// or: vi.fn(apples => apples + 1);\n\nconst NelliesBucket = mockFn(0)\nconst BobsBucket = mockFn(1)\n\nNelliesBucket === 1 // true\nBobsBucket === 2 // true\n\nmockFn.mock.calls[0][0] === 0 // true\nmockFn.mock.calls[1][0] === 1 // true\nmockImplementationOnce\n​\nType: (fn: Function) => MockInstance\n\nAccepts a function that will be used as mock's implementation during the next call. Can be chained so that multiple function calls produce different results.\n\nts\nconst myMockFn = vi\n  .fn()\n  .mockImplementationOnce(() => true)\n  .mockImplementationOnce(() => false)\n\nmyMockFn() // true\nmyMockFn() // false\n\nWhen the mocked function runs out of implementations, it will invoke the default implementation that was set with vi.fn(() => defaultValue) or .mockImplementation(() => defaultValue) if they were called:\n\nts\nconst myMockFn = vi\n  .fn(() => 'default')\n  .mockImplementationOnce(() => 'first call')\n  .mockImplementationOnce(() => 'second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\nwithImplementation\n​\nType: (fn: Function, callback: () => void) => MockInstance\nType: (fn: Function, callback: () => Promise<unknown>) => Promise<MockInstance>\n\nOverrides the original mock implementation temporarily while the callback is being executed.\n\njs\nconst myMockFn = vi.fn(() => 'original')\n\nmyMockFn.withImplementation(() => 'temp', () => {\n  myMockFn() // 'temp'\n})\n\nmyMockFn() // 'original'\n\nCan be used with an asynchronous callback. The method has to be awaited to use the original implementation afterward.\n\nts\ntest('async callback', () => {\n  const myMockFn = vi.fn(() => 'original')\n\n  // We await this call since the callback is async\n  await myMockFn.withImplementation(\n    () => 'temp',\n    async () => {\n      myMockFn() // 'temp'\n    },\n  )\n\n  myMockFn() // 'original'\n})\n\nNote that this method takes precedence over the mockImplementationOnce.\n\nmockRejectedValue\n​\nType: (value: any) => MockInstance\n\nAccepts an error that will be rejected when async function is called.\n\nts\nconst asyncMock = vi.fn().mockRejectedValue(new Error('Async error'))\n\nawait asyncMock() // throws \"Async error\"\nmockRejectedValueOnce\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be rejected during the next function call. If chained, every consecutive call will reject specified value.\n\nts\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValueOnce('first call')\n  .mockRejectedValueOnce(new Error('Async error'))\n\nawait asyncMock() // first call\nawait asyncMock() // throws \"Async error\"\nmockReset\n​\nType: () => MockInstance\n\nDoes what mockClear does and makes inner implementation an empty function (returning undefined when invoked). This also resets all \"once\" implementations. This is useful when you want to completely reset a mock to the default state.\n\nIf you want this method to be called before each test automatically, you can enable mockReset setting in config.\n\nmockRestore\n​\nType: () => MockInstance\n\nDoes what mockReset does and restores inner implementation to the original function.\n\nNote that restoring mock from vi.fn() will set implementation to an empty function that returns undefined. Restoring a vi.fn(impl) will restore implementation to impl.\n\nIf you want this method to be called before each test automatically, you can enable restoreMocks setting in config.\n\nmockResolvedValue\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be resolved when async function is called.\n\nts\nconst asyncMock = vi.fn().mockResolvedValue(42)\n\nawait asyncMock() // 42\nmockResolvedValueOnce\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be resolved during the next function call. If chained, every consecutive call will resolve specified value.\n\nts\nconst asyncMock = vi\n  .fn()\n  .mockResolvedValue('default')\n  .mockResolvedValueOnce('first call')\n  .mockResolvedValueOnce('second call')\n\nawait asyncMock() // first call\nawait asyncMock() // second call\nawait asyncMock() // default\nawait asyncMock() // default\nmockReturnThis\n​\nType: () => MockInstance\n\nUse this if you need to return this context from the method without invoking actual implementation. This is a shorthand for:\n\nts\nspy.mockImplementation(function () {\n  return this\n})\nmockReturnValue\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be returned whenever the mock function is called.\n\nts\nconst mock = vi.fn()\nmock.mockReturnValue(42)\nmock() // 42\nmock.mockReturnValue(43)\nmock() // 43\nmockReturnValueOnce\n​\nType: (value: any) => MockInstance\n\nAccepts a value that will be returned during the next function call. If chained, every consecutive call will return the specified value.\n\nWhen there are no more mockReturnValueOnce values to use, mock will fallback to previously defined implementation if there is one.\n\nts\nconst myMockFn = vi\n  .fn()\n  .mockReturnValue('default')\n  .mockReturnValueOnce('first call')\n  .mockReturnValueOnce('second call')\n\n// 'first call', 'second call', 'default', 'default'\nconsole.log(myMockFn(), myMockFn(), myMockFn(), myMockFn())\nmock.calls\n​\n\nThis is an array containing all arguments for each call. One item of the array is the arguments of that call.\n\njs\nconst fn = vi.fn()\n\nfn('arg1', 'arg2')\nfn('arg3')\n\nfn.mock.calls === [\n  ['arg1', 'arg2'], // first call\n  ['arg3'], // second call\n]\nmock.lastCall\n​\n\nThis contains the arguments of the last call. If mock wasn't called, will return undefined.\n\nmock.results\n​\n\nThis is an array containing all values that were returned from the function. One item of the array is an object with properties type and value. Available types are:\n\n'return' - function returned without throwing.\n'throw' - function threw a value.\n\nThe value property contains the returned value or thrown error. If the function returned a promise, the value will be the resolved value, not the actual Promise, unless it was never resolved.\n\njs\nconst fn = vi.fn()\n  .mockReturnValueOnce('result')\n  .mockImplementationOnce(() => { throw new Error('thrown error') })\n\nconst result = fn() // returned 'result'\n\ntry {\n  fn() // threw Error\n}\ncatch {}\n\nfn.mock.results === [\n  // first result\n  {\n    type: 'return',\n    value: 'result',\n  },\n  // last result\n  {\n    type: 'throw',\n    value: Error,\n  },\n]\nmock.invocationCallOrder\n​\n\nThe order of mock's execution. This returns an array of numbers that are shared between all defined mocks.\n\njs\nconst fn1 = vi.fn()\nconst fn2 = vi.fn()\n\nfn1()\nfn2()\nfn1()\n\nfn1.mock.invocationCallOrder === [1, 3]\nfn2.mock.invocationCallOrder === [2]\nmock.instances\n​\n\nThis is an array containing all instances that were instantiated when mock was called with a new keyword. Note that this is an actual context (this) of the function, not a return value.\n\nWARNING\n\nIf mock was instantiated with new MyClass(), then mock.instances will be an array with one value:\n\njs\nconst MyClass = vi.fn()\nconst a = new MyClass()\n\nMyClass.mock.instances[0] === a\n\nIf you return a value from constructor, it will not be in instances array, but instead inside results:\n\njs\nconst Spy = vi.fn(() => ({ method: vi.fn() }))\nconst a = new Spy()\n\nSpy.mock.instances[0] !== a\nSpy.mock.results[0] === a"
  },
  {
    "title": "Test API Reference | Vitest",
    "url": "https://vitest.dev/api/",
    "html": "Test API Reference\n​\n\nThe following types are used in the type signatures below\n\nts\ntype Awaitable<T> = T | PromiseLike<T>\ntype TestFunction = () => Awaitable<void>\n\ninterface TestOptions {\n  /**\n   * Will fail the test if it takes too long to execute\n   */\n  timeout?: number\n  /**\n   * Will retry the test specific number of times if it fails\n   *\n   * @default 0\n   */\n  retry?: number\n  /**\n   * Will repeat the same test several times even if it fails each time\n   * If you have \"retry\" option and it fails, it will use every retry in each cycle\n   * Useful for debugging random failings\n   *\n   * @default 0\n   */\n  repeats?: number\n}\n\nWhen a test function returns a promise, the runner will wait until it is resolved to collect async expectations. If the promise is rejected, the test will fail.\n\nTIP\n\nIn Jest, TestFunction can also be of type (done: DoneCallback) => void. If this form is used, the test will not be concluded until done is called. You can achieve the same using an async function, see the Migration guide Done Callback section.\n\ntest\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number | TestOptions) => void\nAlias: it\n\ntest defines a set of related expectations. It receives the test name and a function that holds the expectations to test.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with testTimeout\n\nts\nimport { expect, test } from 'vitest'\n\ntest('should work as expected', () => {\n  expect(Math.sqrt(4)).toBe(2)\n})\ntest.extend\n​\nType: <T extends Record<string, any>>(fixtures: Fixtures<T>): TestAPI<ExtraContext & T>\nAlias: it.extend\nVersion: Vitest 0.32.3\n\nUse test.extend to extend the test context with custom fixtures. This will return a new test and it's also extendable, so you can compose more fixtures or override existing ones by extending it as you need. See Extend Test Context for more information.\n\nts\nimport { expect, test } from 'vitest'\n\nconst todos = []\nconst archive = []\n\nconst myTest = test.extend({\n  todos: async ({ task }, use) => {\n    todos.push(1, 2, 3)\n    await use(todos)\n    todos.length = 0\n  },\n  archive\n})\n\nmyTest('add item', ({ todos }) => {\n  expect(todos.length).toBe(3)\n\n  todos.push(4)\n  expect(todos.length).toBe(4)\n})\ntest.skip\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number | TestOptions) => void\nAlias: it.skip\n\nIf you want to skip running certain tests, but you don't want to delete the code due to any reason, you can use test.skip to avoid running them.\n\nts\nimport { assert, test } from 'vitest'\n\ntest.skip('skipped test', () => {\n  // Test skipped, no error\n  assert.equal(Math.sqrt(4), 3)\n})\n\nYou can also skip test by calling skip on its context dynamically:\n\nts\nimport { assert, test } from 'vitest'\n\ntest('skipped test', (context) => {\n  context.skip()\n  // Test skipped, no error\n  assert.equal(Math.sqrt(4), 3)\n})\ntest.skipIf\n​\nType: (condition: any) => Test\nAlias: it.skipIf\n\nIn some cases you might run tests multiple times with different environments, and some of the tests might be environment-specific. Instead of wrapping the test code with if, you can use test.skipIf to skip the test whenever the condition is truthy.\n\nts\nimport { assert, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ntest.skipIf(isDev)('prod only test', () => {\n  // this test only runs in production\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.runIf\n​\nType: (condition: any) => Test\nAlias: it.runIf\n\nOpposite of test.skipIf.\n\nts\nimport { assert, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ntest.runIf(isDev)('dev only test', () => {\n  // this test only runs in development\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.only\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\nAlias: it.only\n\nUse test.only to only run certain tests in a given suite. This is useful when debugging.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds, and can be configured globally with testTimeout.\n\nts\nimport { assert, test } from 'vitest'\n\ntest.only('test', () => {\n  // Only this test (and others marked with only) are run\n  assert.equal(Math.sqrt(4), 2)\n})\n\nSometimes it is very useful to run only tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.\n\nIn order to do that run vitest with specific file containing the tests in question.\n\n# vitest interesting.test.ts\ntest.concurrent\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\nAlias: it.concurrent\n\ntest.concurrent marks consecutive tests to be run in parallel. It receives the test name, an async function with the tests to collect, and an optional timeout (in milliseconds).\n\nts\nimport { describe, test } from 'vitest'\n\n// The two tests marked with concurrent will be run in parallel\ndescribe('suite', () => {\n  test('serial test', async () => { /* ... */ })\n  test.concurrent('concurrent test 1', async () => { /* ... */ })\n  test.concurrent('concurrent test 2', async () => { /* ... */ })\n})\n\ntest.skip, test.only, and test.todo works with concurrent tests. All the following combinations are valid:\n\nts\ntest.concurrent(/* ... */)\ntest.skip.concurrent(/* ... */) // or test.concurrent.skip(/* ... */)\ntest.only.concurrent(/* ... */) // or test.concurrent.only(/* ... */)\ntest.todo.concurrent(/* ... */) // or test.concurrent.todo(/* ... */)\n\nWhen running concurrent tests, Snapshots and Assertions must use expect from the local Test Context to ensure the right test is detected.\n\nts\ntest.concurrent('test 1', async ({ expect }) => {\n  expect(foo).toMatchSnapshot()\n})\ntest.concurrent('test 2', async ({ expect }) => {\n  expect(foo).toMatchSnapshot()\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.sequential\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\n\ntest.sequential marks a test as sequential. This is useful if you want to run tests in sequence within describe.concurrent or with the --sequence.concurrent command option.\n\nts\n// with config option { sequence: { concurrent: true } }\ntest('concurrent test 1', async () => { /* ... */ })\ntest('concurrent test 2', async () => { /* ... */ })\n\ntest.sequential('sequential test 1', async () => { /* ... */ })\ntest.sequential('sequential test 2', async () => { /* ... */ })\n\n// within concurrent suite\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n\n  test.sequential('sequential test 1', async () => { /* ... */ })\n  test.sequential('sequential test 2', async () => { /* ... */ })\n})\ntest.todo\n​\nType: (name: string | Function) => void\nAlias: it.todo\n\nUse test.todo to stub tests to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.\n\nts\n// An entry will be shown in the report for this test\ntest.todo('unimplemented test')\ntest.fails\n​\nType: (name: string | Function, fn: TestFunction, timeout?: number) => void\nAlias: it.fails\n\nUse test.fails to indicate that an assertion will fail explicitly.\n\nts\nimport { expect, test } from 'vitest'\n\nfunction myAsyncFunc() {\n  return new Promise(resolve => resolve(1))\n}\ntest.fails('fail test', async () => {\n  await expect(myAsyncFunc()).rejects.toBe(1)\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ntest.each\n​\nType: (cases: ReadonlyArray<T>, ...args: any[]) => void\nAlias: it.each\n\nUse test.each when you need to run the same test with different variables. You can inject parameters with printf formatting in the test name in the order of the test function parameters.\n\n%s: string\n%d: number\n%i: integer\n%f: floating point value\n%j: json\n%o: object\n%#: index of the test case\n%%: single percent sign ('%')\nts\ntest.each([\n  [1, 1, 2],\n  [1, 2, 3],\n  [2, 1, 3],\n])('add(%i, %i) -> %i', (a, b, expected) => {\n  expect(a + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, 1) -> 2\n// ✓ add(1, 2) -> 3\n// ✓ add(2, 1) -> 3\n\nYou can also access object properties with $ prefix, if you are using objects as arguments:\n\nts\ntest.each([\n  { a: 1, b: 1, expected: 2 },\n  { a: 1, b: 2, expected: 3 },\n  { a: 2, b: 1, expected: 3 },\n])('add($a, $b) -> $expected', ({ a, b, expected }) => {\n  expect(a + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, 1) -> 2\n// ✓ add(1, 2) -> 3\n// ✓ add(2, 1) -> 3\n\nYou can also access Object attributes with ., if you are using objects as arguments:\n\nts\ntest.each`\na               | b      | expected\n${{ val: 1 }}   | ${'b'} | ${'1b'}\n${{ val: 2 }}   | ${'b'} | ${'2b'}\n${{ val: 3 }}   | ${'b'} | ${'3b'}\n`('add($a.val, $b) -> $expected', ({ a, b, expected }) => {\n  expect(a.val + b).toBe(expected)\n})\n\n// this will return\n// ✓ add(1, b) -> 1b\n// ✓ add(2, b) -> 2b\n// ✓ add(3, b) -> 3b\n\nStarting from Vitest 0.25.3, you can also use template string table.\n\nFirst row should be column names, separated by |;\nOne or more subsequent rows of data supplied as template literal expressions using ${value} syntax.\nts\ntest.each`\n  a               | b      | expected\n  ${1}            | ${1}   | ${2}\n  ${'a'}          | ${'b'} | ${'ab'}\n  ${[]}           | ${'b'} | ${'b'}\n  ${{}}           | ${'b'} | ${'[object Object]b'}\n  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}\n`('returns $expected when $a is added $b', ({ a, b, expected }) => {\n  expect(a + b).toBe(expected)\n})\n\nIf you want to have access to TestContext, use describe.each with a single test.\n\nTIP\n\nVitest processes $values with Chai format method. If the value is too truncated, you can increase chaiConfig.truncateThreshold in your config file.\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\nbench\n​\nType: (name: string | Function, fn: BenchFunction, options?: BenchOptions) => void\n\nbench defines a benchmark. In Vitest terms benchmark is a function that defines a series of operations. Vitest runs this function multiple times to display different performance results.\n\nVitest uses tinybench library under the hood, inheriting all its options that can be used as a third argument.\n\nts\nimport { bench } from 'vitest'\n\nbench('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n}, { time: 1000 })\nts\nexport interface Options {\n  /**\n   * time needed for running a benchmark task (milliseconds)\n   * @default 500\n   */\n  time?: number\n\n  /**\n   * number of times that a task should run if even the time option is finished\n   * @default 10\n   */\n  iterations?: number\n\n  /**\n   * function to get the current timestamp in milliseconds\n   */\n  now?: () => number\n\n  /**\n   * An AbortSignal for aborting the benchmark\n   */\n  signal?: AbortSignal\n\n  /**\n   * warmup time (milliseconds)\n   * @default 100ms\n   */\n  warmupTime?: number\n\n  /**\n   * warmup iterations\n   * @default 5\n   */\n  warmupIterations?: number\n\n  /**\n   * setup function to run before each benchmark task (cycle)\n   */\n  setup?: Hook\n\n  /**\n   * teardown function to run after each benchmark task (cycle)\n   */\n  teardown?: Hook\n}\nbench.skip\n​\nType: (name: string | Function, fn: BenchFunction, options?: BenchOptions) => void\n\nYou can use bench.skip syntax to skip running certain benchmarks.\n\nts\nimport { bench } from 'vitest'\n\nbench.skip('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n})\nbench.only\n​\nType: (name: string | Function, fn: BenchFunction, options?: BenchOptions) => void\n\nUse bench.only to only run certain benchmarks in a given suite. This is useful when debugging.\n\nts\nimport { bench } from 'vitest'\n\nbench.only('normal sorting', () => {\n  const x = [1, 5, 4, 2, 3]\n  x.sort((a, b) => {\n    return a - b\n  })\n})\nbench.todo\n​\nType: (name: string | Function) => void\n\nUse bench.todo to stub benchmarks to be implemented later.\n\nts\nimport { bench } from 'vitest'\n\nbench.todo('unimplemented test')\ndescribe\n​\n\nWhen you use test or bench in the top level of file, they are collected as part of the implicit suite for it. Using describe you can define a new suite in the current context, as a set of related tests or benchmarks and other nested suites. A suite lets you organize your tests and benchmarks so reports are more clear.\n\nts\n// basic.spec.ts\n// organizing tests\n\nimport { describe, expect, test } from 'vitest'\n\nconst person = {\n  isActive: true,\n  age: 32,\n}\n\ndescribe('person', () => {\n  test('person is defined', () => {\n    expect(person).toBeDefined()\n  })\n\n  test('is active', () => {\n    expect(person.isActive).toBeTruthy()\n  })\n\n  test('age limit', () => {\n    expect(person.age).toBeLessThanOrEqual(32)\n  })\n})\nts\n// basic.bench.ts\n// organizing benchmarks\n\nimport { bench, describe } from 'vitest'\n\ndescribe('sort', () => {\n  bench('normal', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.sort((a, b) => {\n      return a - b\n    })\n  })\n\n  bench('reverse', () => {\n    const x = [1, 5, 4, 2, 3]\n    x.reverse().sort((a, b) => {\n      return a - b\n    })\n  })\n})\n\nYou can also nest describe blocks if you have a hierarchy of tests or benchmarks:\n\nts\nimport { describe, expect, test } from 'vitest'\n\nfunction numberToCurrency(value) {\n  if (typeof value !== 'number')\n    throw new Error('Value must be a number')\n\n  return value.toFixed(2).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n}\n\ndescribe('numberToCurrency', () => {\n  describe('given an invalid number', () => {\n    test('composed of non-numbers to throw error', () => {\n      expect(() => numberToCurrency('abc')).toThrowError()\n    })\n  })\n\n  describe('given a valid number', () => {\n    test('returns the correct currency format', () => {\n      expect(numberToCurrency(10000)).toBe('10,000.00')\n    })\n  })\n})\ndescribe.skip\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\nUse describe.skip in a suite to avoid running a particular describe block.\n\nts\nimport { assert, describe, test } from 'vitest'\n\ndescribe.skip('skipped suite', () => {\n  test('sqrt', () => {\n    // Suite skipped, no error\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\ndescribe.skipIf\n​\nType: (condition: any) => void\n\nIn some cases, you might run suites multiple times with different environments, and some of the suites might be environment-specific. Instead of wrapping the suite with if, you can use describe.skipIf to skip the suite whenever the condition is truthy.\n\nts\nimport { describe, test } from 'vitest'\n\nconst isDev = process.env.NODE_ENV === 'development'\n\ndescribe.skipIf(isDev)('prod only test', () => {\n  // this test only runs in production\n})\n\nWARNING\n\nYou cannot use this syntax when using Vitest as type checker.\n\ndescribe.only\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\nUse describe.only to only run certain suites\n\nts\n// Only this suite (and others marked with only) are run\ndescribe.only('suite', () => {\n  test('sqrt', () => {\n    assert.equal(Math.sqrt(4), 3)\n  })\n})\n\ndescribe('other suite', () => {\n  // ... will be skipped\n})\n\nSometimes it is very useful to run only tests in a certain file, ignoring all other tests from the whole test suite, which pollute the output.\n\nIn order to do that run vitest with specific file containing the tests in question.\n\n# vitest interesting.test.ts\ndescribe.concurrent\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\ndescribe.concurrent in a suite marks every tests as concurrent\n\nts\n// All tests within this suite will be run in parallel\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n  test.concurrent('concurrent test 3', async () => { /* ... */ })\n})\n\n.skip, .only, and .todo works with concurrent suites. All the following combinations are valid:\n\nts\ndescribe.concurrent(/* ... */)\ndescribe.skip.concurrent(/* ... */) // or describe.concurrent.skip(/* ... */)\ndescribe.only.concurrent(/* ... */) // or describe.concurrent.only(/* ... */)\ndescribe.todo.concurrent(/* ... */) // or describe.concurrent.todo(/* ... */)\n\nWhen running concurrent tests, Snapshots and Assertions must use expect from the local Test Context to ensure the right test is detected.\n\nts\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async ({ expect }) => {\n    expect(foo).toMatchSnapshot()\n  })\n  test('concurrent test 2', async ({ expect }) => {\n    expect(foo).toMatchSnapshot()\n  })\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ndescribe.sequential\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\ndescribe.sequential in a suite marks every test as sequential. This is useful if you want to run tests in sequence within describe.concurrent or with the --sequence.concurrent command option.\n\nts\ndescribe.concurrent('suite', () => {\n  test('concurrent test 1', async () => { /* ... */ })\n  test('concurrent test 2', async () => { /* ... */ })\n\n  describe.sequential('', () => {\n    test('sequential test 1', async () => { /* ... */ })\n    test('sequential test 2', async () => { /* ... */ })\n  })\n})\ndescribe.shuffle\n​\nType: (name: string | Function, fn: TestFunction, options?: number | TestOptions) => void\n\nVitest provides a way to run all tests in random order via CLI flag --sequence.shuffle or config option sequence.shuffle, but if you want to have only part of your test suite to run tests in random order, you can mark it with this flag.\n\nts\ndescribe.shuffle('suite', () => {\n  test('random test 1', async () => { /* ... */ })\n  test('random test 2', async () => { /* ... */ })\n  test('random test 3', async () => { /* ... */ })\n})\n// order depends on sequence.seed option in config (Date.now() by default)\n\n.skip, .only, and .todo works with random suites.\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\ndescribe.todo\n​\nType: (name: string | Function) => void\n\nUse describe.todo to stub suites to be implemented later. An entry will be shown in the report for the tests so you know how many tests you still need to implement.\n\nts\n// An entry will be shown in the report for this suite\ndescribe.todo('unimplemented suite')\ndescribe.each\n​\nType: (cases: ReadonlyArray<T>, ...args: any[]): (name: string | Function, fn: (...args: T[]) => void, options?: number | TestOptions) => void\n\nUse describe.each if you have more than one test that depends on the same data.\n\nts\ndescribe.each([\n  { a: 1, b: 1, expected: 2 },\n  { a: 1, b: 2, expected: 3 },\n  { a: 2, b: 1, expected: 3 },\n])('describe object add($a, $b)', ({ a, b, expected }) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected)\n  })\n\n  test(`returned value not be greater than ${expected}`, () => {\n    expect(a + b).not.toBeGreaterThan(expected)\n  })\n\n  test(`returned value not be less than ${expected}`, () => {\n    expect(a + b).not.toBeLessThan(expected)\n  })\n})\n\nStarting from Vitest 0.25.3, you can also use template string table.\n\nFirst row should be column names, separated by |;\nOne or more subsequent rows of data supplied as template literal expressions using ${value} syntax.\nts\ndescribe.each`\n  a               | b      | expected\n  ${1}            | ${1}   | ${2}\n  ${'a'}          | ${'b'} | ${'ab'}\n  ${[]}           | ${'b'} | ${'b'}\n  ${{}}           | ${'b'} | ${'[object Object]b'}\n  ${{ asd: 1 }}   | ${'b'} | ${'[object Object]b'}\n`('describe template string add($a, $b)', ({ a, b, expected }) => {\n  test(`returns ${expected}`, () => {\n    expect(a + b).toBe(expected)\n  })\n})\n\nWARNING\n\nYou cannot use this syntax, when using Vitest as type checker.\n\nSetup and Teardown\n​\n\nThese functions allow you to hook into the life cycle of tests to avoid repeating setup and teardown code. They apply to the current context: the file if they are used at the top-level or the current suite if they are inside a describe block. These hooks are not called, when you are running Vitest as a type checker.\n\nbeforeEach\n​\nType: beforeEach(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called before each of the tests in the current context runs. If the function returns a promise, Vitest waits until the promise resolve before running the test.\n\nOptionally, you can pass a timeout (in milliseconds) defining how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { beforeEach } from 'vitest'\n\nbeforeEach(async () => {\n  // Clear mocks and add some testing data after before each test run\n  await stopMocking()\n  await addUser({ name: 'John' })\n})\n\nHere, the beforeEach ensures that user is added for each test.\n\nSince Vitest v0.10.0, beforeEach also accepts an optional cleanup function (equivalent to afterEach).\n\nts\nimport { beforeEach } from 'vitest'\n\nbeforeEach(async () => {\n  // called once before each test run\n  await prepareSomething()\n\n  // clean up function, called once after each test run\n  return async () => {\n    await resetSomething()\n  }\n})\nafterEach\n​\nType: afterEach(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called after each one of the tests in the current context completes. If the function returns a promise, Vitest waits until the promise resolve before continuing.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { afterEach } from 'vitest'\n\nafterEach(async () => {\n  await clearTestingData() // clear testing data after each test run\n})\n\nHere, the afterEach ensures that testing data is cleared after each test runs.\n\nbeforeAll\n​\nType: beforeAll(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called once before starting to run all tests in the current context. If the function returns a promise, Vitest waits until the promise resolve before running tests.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => {\n  await startMocking() // called once before all tests run\n})\n\nHere the beforeAll ensures that the mock data is set up before tests run.\n\nSince Vitest v0.10.0, beforeAll also accepts an optional cleanup function (equivalent to afterAll).\n\nts\nimport { beforeAll } from 'vitest'\n\nbeforeAll(async () => {\n  // called once before all tests run\n  await startMocking()\n\n  // clean up function, called once after all tests run\n  return async () => {\n    await stopMocking()\n  }\n})\nafterAll\n​\nType: afterAll(fn: () => Awaitable<void>, timeout?: number)\n\nRegister a callback to be called once after all tests have run in the current context. If the function returns a promise, Vitest waits until the promise resolve before continuing.\n\nOptionally, you can provide a timeout (in milliseconds) for specifying how long to wait before terminating. The default is 5 seconds.\n\nts\nimport { afterAll } from 'vitest'\n\nafterAll(async () => {\n  await stopMocking() // this method is called after all tests run\n})\n\nHere the afterAll ensures that stopMocking method is called after all tests run."
  },
  {
    "title": "Custom Pool | Vitest",
    "url": "https://vitest.dev/advanced/pool",
    "html": "Custom Pool\n​\n\nWARNING\n\nThis is advanced API. If you are just running tests, you probably don't need this. It is primarily used by library authors.\n\nVitest runs tests in pools. By default, there are several pools:\n\nthreads to run tests using node:worker_threads (isolation is provided with a new worker context)\nforks to run tests using node:child_process (isolation is provided with a new child_process.fork process)\nvmThreads to run tests using node:worker_threads (but isolation is provided with vm module instead of a new worker context)\nbrowser to run tests using browser providers\ntypescript to run typechecking on tests\n\nYou can provide your own pool by specifying a file path:\n\nts\nexport default defineConfig({\n  test: {\n    // will run every file with a custom pool by default\n    pool: './my-custom-pool.ts',\n    // you can provide options using `poolOptions` object\n    poolOptions: {\n      myCustomPool: {\n        customProperty: true,\n      },\n    },\n    // you can also specify pool for a subset of files\n    poolMatchGlobs: [\n      ['**/*.custom.test.ts', './my-custom-pool.ts'],\n    ],\n  },\n})\nAPI\n​\n\nThe file specified in pool option should export a function (can be async) that accepts Vitest interface as its first option. This function needs to return an object matching ProcessPool interface:\n\nts\nimport { ProcessPool, WorkspaceProject } from 'vitest/node'\n\nexport interface ProcessPool {\n  name: string\n  runTests: (files: [project: WorkspaceProject, testFile: string][], invalidates?: string[]) => Promise<void>\n  close?: () => Promise<void>\n}\n\nThe function is called only once (unless the server config was updated), and it's generally a good idea to initialize everything you need for tests inside that function and reuse it when runTests is called.\n\nVitest calls runTest when new tests are scheduled to run. It will not call it if files is empty. The first argument is an array of tuples: the first element is a reference to a workspace project and the second one is an absolute path to a test file. Files are sorted using sequencer before runTests is called. It's possible (but unlikely) to have the same file twice, but it will always have a different project - this is implemented via vitest.workspace.ts configuration.\n\nVitest will wait until runTests is executed before finishing a run (i.e., it will emit onFinished only after runTests is resolved).\n\nIf you are using a custom pool, you will have to provide test files and their results yourself - you can reference vitest.state for that (most important are collectFiles and updateTasks). Vitest uses startTests function from @vitest/runner package to do that.\n\nTo communicate between different processes, you can create methods object using createMethodsRPC from vitest/node, and use any form of communication that you prefer. For example, to use WebSockets with birpc you can write something like this:\n\nts\nimport { createBirpc } from 'birpc'\nimport { parse, stringify } from 'flatted'\nimport { WorkspaceProject, createMethodsRPC } from 'vitest/node'\n\nfunction createRpc(project: WorkspaceProject, wss: WebSocketServer) {\n  return createBirpc(\n    createMethodsRPC(project),\n    {\n      post: msg => wss.send(msg),\n      on: fn => wss.on('message', fn),\n      serialize: stringify,\n      deserialize: parse,\n    },\n  )\n}\n\nTo make sure every test is collected, you would call ctx.state.collectFiles and report it to Vitest reporters:\n\nts\nasync function runTests(project: WorkspaceProject, tests: string[]) {\n  // ... running tests, put into \"files\" and \"tasks\"\n  const methods = createMethodsRPC(project)\n  await methods.onCollected(files)\n  // most reporters rely on results being updated in \"onTaskUpdate\"\n  await methods.onTaskUpdate(tasks)\n}\n\nYou can see a simple example in pool/custom-pool.ts."
  },
  {
    "title": "Extending Reporters | Vitest",
    "url": "https://vitest.dev/advanced/reporters",
    "html": "Extending Reporters\n​\n\nYou can import reporters from vitest/reporters and extend them to create your custom reporters.\n\nExtending Built-in Reporters\n​\n\nIn general, you don't need to create your reporter from scratch. vitest comes with several default reporting programs that you can extend.\n\nts\nimport { DefaultReporter } from 'vitest/reporters'\n\nexport default class MyDefaultReporter extends DefaultReporter {\n  // do something\n}\n\nOf course, you can create your reporter from scratch. Just extend the BaseReporter class and implement the methods you need.\n\nAnd here is an example of a custom reporter:\n\nts\n// ./custom-reporter.js\nimport { BaseReporter } from 'vitest/reporters'\n\nexport default class CustomReporter extends BaseReporter {\n  onCollected() {\n    const files = this.ctx.state.getFiles(this.watchFilters)\n    this.reportTestSummary(files)\n  }\n}\n\nOr implement the Reporter interface:\n\nts\n// ./custom-reporter.js\nimport { Reporter } from 'vitest/reporters'\n\nexport default class CustomReporter implements Reporter {\n  onCollected() {\n    // print something\n  }\n}\n\nThen you can use your custom reporter in the vitest.config.ts file:\n\nts\nimport { defineConfig } from 'vitest/config'\nimport CustomReporter from './custom-reporter.js'\n\nexport default defineConfig({\n  test: {\n    reporters: [new CustomReporter()],\n  },\n})\nExported Reporters\n​\n\nvitest comes with a few built-in reporters that you can use out of the box.\n\nBuilt-in reporters:\n​\nBasicReporter\nDefaultReporter\nDotReporter\nJsonReporter\nVerboseReporter\nTapReporter\nJUnitReporter\nTapFlatReporter\nHangingProcessReporter\nBase Abstract reporters:\n​\nBaseReporter\nInterface reporters:\n​\nReporter"
  },
  {
    "title": "Task Metadata | Vitest",
    "url": "https://vitest.dev/advanced/metadata",
    "html": "Task Metadata\n​\n\nWARNING\n\nVitest exposes experimental private API. Breaking changes might not follow SemVer, please pin Vitest's version when using it.\n\nIf you are developing a custom reporter or using Vitest Node.js API, you might find it useful to pass data from tests that are being executed in various contexts to your reporter or custom Vitest handler.\n\nTo accomplish this, relying on the test context is not feasible since it cannot be serialized. However, with Vitest, you can utilize the meta property available on every task (suite or test) to share data between your tests and the Node.js process. It's important to note that this communication is one-way only, as the meta property can only be modified from within the test context. Any changes made within the Node.js context will not be visible in your tests.\n\nYou can populate meta property on test context or inside beforeAll/afterAll hooks for suite tasks.\n\nts\nafterAll((suite) => {\n  suite.meta.done = true\n})\n\ntest('custom', ({ task }) => {\n  task.meta.custom = 'some-custom-handler'\n})\n\nOnce a test is completed, Vitest will send a task including the result and meta to the Node.js process using RPC. To intercept and process this task, you can utilize the onTaskUpdate method available in your reporter implementation:\n\nts\n// custom-reporter.js\nexport default {\n  // you can intercept packs if needed\n  onTaskUpdate(packs) {\n    const [id, result, meta] = packs[0]\n  },\n  // meta is located on every task inside \"onFinished\"\n  onFinished(files) {\n    files[0].meta.done === true\n    files[0].tasks[0].meta.custom === 'some-custom-handler'\n  }\n}\n\nWARNING\n\nVitest can send several tasks at the same time if several tests are completed in a short period of time.\n\nBEWARE\n\nVitest uses different methods to communicate with the Node.js process.\n\nIf Vitest runs tests inside worker threads, it will send data via message port\nIf Vitest uses child process, the data will be send as a serialized Buffer via process.send API\nIf Vitest runs tests in the browser, the data will be stringified using flatted package\n\nThe general rule of thumb is that you can send almost anything, except for functions, Promises, regexp (v8.stringify cannot serialize it, but you can send a string version and parse it in the Node.js process yourself), and other non-serializable data, but you can have cyclic references inside.\n\nAlso, make sure you serialize Error properties before you set them.\n\nYou can also get this information from Vitest state when tests finished running:\n\nts\nconst vitest = await createVitest('test')\nawait vitest.start()\nvitest.state.getFiles()[0].meta.done === true\nvitest.state.getFiles()[0].tasks[0].meta.custom === 'some-custom-handler'\n\nIt's also possible to extend type definitions when using TypeScript:\n\nts\ndeclare module 'vitest' {\n  interface TaskMeta {\n    done?: boolean\n    custom?: string\n  }\n}"
  },
  {
    "title": "Test Runner | Vitest",
    "url": "https://vitest.dev/advanced/runner",
    "html": "Test Runner\n​\n\nWARNING\n\nThis is advanced API. If you are just running tests, you probably don't need this. It is primarily used by library authors.\n\nYou can specify a path to your test runner with the runner option in your configuration file. This file should have a default export with a class implementing these methods:\n\nts\nexport interface VitestRunner {\n  /**\n   * First thing that's getting called before actually collecting and running tests.\n   */\n  onBeforeCollect?(paths: string[]): unknown\n  /**\n   * Called after collecting tests and before \"onBeforeRun\".\n   */\n  onCollected?(files: File[]): unknown\n\n  /**\n   * Called when test runner should cancel next test runs.\n   * Runner should listen for this method and mark tests and suites as skipped in\n   * \"onBeforeRunSuite\" and \"onBeforeRunTask\" when called.\n   */\n  onCancel?(reason: CancelReason): unknown\n\n  /**\n   * Called before running a single test. Doesn't have \"result\" yet.\n   */\n  onBeforeRunTask?(test: TaskPopulated): unknown\n  /**\n   * Called before actually running the test function. Already has \"result\" with \"state\" and \"startTime\".\n   */\n  onBeforeTryTask?(test: TaskPopulated, options: { retry: number; repeats: number }): unknown\n  /**\n   * Called after result and state are set.\n   */\n  onAfterRunTask?(test: TaskPopulated): unknown\n  /**\n   * Called right after running the test function. Doesn't have new state yet. Will not be called, if the test function throws.\n   */\n  onAfterTryTask?(test: TaskPopulated, options: { retry: number; repeats: number }): unknown\n\n  /**\n   * Called before running a single suite. Doesn't have \"result\" yet.\n   */\n  onBeforeRunSuite?(suite: Suite): unknown\n  /**\n   * Called after running a single suite. Has state and result.\n   */\n  onAfterRunSuite?(suite: Suite): unknown\n\n  /**\n   * If defined, will be called instead of usual Vitest suite partition and handling.\n   * \"before\" and \"after\" hooks will not be ignored.\n   */\n  runSuite?(suite: Suite): Promise<void>\n  /**\n   * If defined, will be called instead of usual Vitest handling. Useful, if you have your custom test function.\n   * \"before\" and \"after\" hooks will not be ignored.\n   */\n  runTask?(test: TaskPopulated): Promise<void>\n\n  /**\n   * Called, when a task is updated. The same as \"onTaskUpdate\" in a reporter, but this is running in the same thread as tests.\n   */\n  onTaskUpdate?(task: [string, TaskResult | undefined][]): Promise<void>\n\n  /**\n   * Called before running all tests in collected paths.\n   */\n  onBeforeRunFiles?(files: File[]): unknown\n  /**\n   * Called right after running all tests in collected paths.\n   */\n  onAfterRunFiles?(files: File[]): unknown\n  /**\n   * Called when new context for a test is defined. Useful, if you want to add custom properties to the context.\n   * If you only want to define custom context with a runner, consider using \"beforeAll\" in \"setupFiles\" instead.\n   *\n   * This method is called for both \"test\" and \"custom\" handlers.\n   *\n   * @see https://vitest.dev/advanced/runner.html#your-task-function\n   */\n  extendTaskContext?<T extends Test | Custom>(context: TaskContext<T>): TaskContext<T>\n  /**\n   * Called, when certain files are imported. Can be called in two situations: when collecting tests and when importing setup files.\n   */\n  importFile(filepath: string, source: VitestRunnerImportSource): unknown\n  /**\n   * Publicly available configuration.\n   */\n  config: VitestRunnerConfig\n}\n\nWhen initiating this class, Vitest passes down Vitest config, - you should expose it as a config property.\n\nWARNING\n\nVitest also injects an instance of ViteNodeRunner as __vitest_executor property. You can use it to process files in importFile method (this is default behavior of TestRunner and BenchmarkRunner).\n\nViteNodeRunner exposes executeId method, which is used to import test files in a Vite-friendly environment. Meaning, it will resolve imports and transform file content at runtime so that Node can understand it.\n\nTIP\n\nSnapshot support and some other features depend on the runner. If you don't want to lose it, you can extend your runner from VitestTestRunner imported from vitest/runners. It also exposes BenchmarkNodeRunner, if you want to extend benchmark functionality.\n\nYour Task Function\n​\n\nYou can extend Vitest task system with your tasks. A task is an object that is part of a suite. It is automatically added to the current suite with a suite.task method:\n\njs\n// ./utils/custom.js\nimport { createTaskCollector, getCurrentSuite, setFn } from 'vitest/suite'\n\nexport { describe, beforeAll, afterAll } from 'vitest'\n\n// this function will be called during collection phase:\n// don't call function handler here, add it to suite tasks\n// with \"getCurrentSuite().task()\" method\n// note: createTaskCollector provides support for \"todo\"/\"each\"/...\nexport const myCustomTask = createTaskCollector(\n  function (name, fn, timeout) {\n    getCurrentSuite().task(name, {\n      ...this, // so \"todo\"/\"skip\"/... is tracked correctly\n      meta: {\n        customPropertyToDifferentiateTask: true\n      },\n      handler: fn,\n      timeout,\n    })\n  }\n)\njs\n// ./garden/tasks.test.js\nimport { afterAll, beforeAll, describe, myCustomTask } from '../custom.js'\nimport { gardener } from './gardener.js'\n\ndescribe('take care of the garden', () => {\n  beforeAll(() => {\n    gardener.putWorkingClothes()\n  })\n\n  myCustomTask('weed the grass', () => {\n    gardener.weedTheGrass()\n  })\n  myCustomTask.todo('mow the lawn', () => {\n    gardener.mowerTheLawn()\n  })\n  myCustomTask('water flowers', () => {\n    gardener.waterFlowers()\n  })\n\n  afterAll(() => {\n    gardener.goHome()\n  })\n})\nbash\nvitest ./garden/tasks.test.js\n\nWARNING\n\nIf you don't have a custom runner or didn't define runTest method, Vitest will try to retrieve a task automatically. If you didn't add a function with setFn, it will fail.\n\nTIP\n\nCustom task system supports hooks and contexts. If you want to support property chaining (like, only, skip, and your custom ones), you can import createChainable from vitest/suite and wrap your function with it. You will need to call custom as custom.call(this), if you decide to do this."
  },
  {
    "title": "Node API | Vitest",
    "url": "https://vitest.dev/advanced/api",
    "html": "Node API\n​\n\nWARNING\n\nVitest exposes experimental private API. Breaking changes might not follow SemVer, please pin Vitest's version when using it.\n\nstartVitest\n​\n\nYou can start running Vitest tests using its Node API:\n\njs\nimport { startVitest } from 'vitest/node'\n\nconst vitest = await startVitest('test')\n\nawait vitest?.close()\n\nstartVitest function returns Vitest instance if tests can be started. It returns undefined, if one of the following occurs:\n\nVitest didn't find the vite package (usually installed with Vitest)\nIf coverage is enabled and run mode is \"test\", but the coverage package is not installed (@vitest/coverage-v8 or @vitest/coverage-istanbul)\nIf the environment package is not installed (jsdom/happy-dom/@edge-runtime/vm)\n\nIf undefined is returned or tests failed during the run, Vitest sets process.exitCode to 1.\n\nIf watch mode is not enabled, Vitest will call close method.\n\nIf watch mode is enabled and the terminal supports TTY, Vitest will register console shortcuts.\n\nYou can pass down a list of filters as a second argument. Vitest will run only tests that contain at least one of the passed-down strings in their file path.\n\nAdditionally, you can use the third argument to pass in CLI arguments, which will override any test config options.\n\nAlternatively, you can pass in the complete Vite config as the fourth argument, which will take precedence over any other user-defined options.\n\ncreateVitest\n​\n\nYou can create Vitest instance yourself using createVitest function. It returns the same Vitest instance as startVitest, but it doesn't start tests and doesn't validate installed packages.\n\njs\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test', {\n  watch: false,\n})\nVitest\n​\n\nVitest instance requires the current test mode. It can be either:\n\ntest when running runtime tests\nbenchmark when running benchmarks\nmode\n​\ntest\n​\n\nTest mode will only call functions inside test or it, and throws an error when bench is encountered. This mode uses include and exclude options in the config to find test files.\n\nbenchmark\n​\n\nBenchmark mode calls bench functions and throws an error, when it encounters test or it. This mode uses benchmark.include and benchmark.exclude options in the config to find benchmark files.\n\nstart\n​\n\nYou can start running tests or benchmarks with start method. You can pass an array of strings to filter test files."
  },
  {
    "title": "Node API | Vitest",
    "url": "https://vitest.dev/advanced/api.html",
    "html": "Node API\n​\n\nWARNING\n\nVitest exposes experimental private API. Breaking changes might not follow SemVer, please pin Vitest's version when using it.\n\nstartVitest\n​\n\nYou can start running Vitest tests using its Node API:\n\njs\nimport { startVitest } from 'vitest/node'\n\nconst vitest = await startVitest('test')\n\nawait vitest?.close()\n\nstartVitest function returns Vitest instance if tests can be started. It returns undefined, if one of the following occurs:\n\nVitest didn't find the vite package (usually installed with Vitest)\nIf coverage is enabled and run mode is \"test\", but the coverage package is not installed (@vitest/coverage-v8 or @vitest/coverage-istanbul)\nIf the environment package is not installed (jsdom/happy-dom/@edge-runtime/vm)\n\nIf undefined is returned or tests failed during the run, Vitest sets process.exitCode to 1.\n\nIf watch mode is not enabled, Vitest will call close method.\n\nIf watch mode is enabled and the terminal supports TTY, Vitest will register console shortcuts.\n\nYou can pass down a list of filters as a second argument. Vitest will run only tests that contain at least one of the passed-down strings in their file path.\n\nAdditionally, you can use the third argument to pass in CLI arguments, which will override any test config options.\n\nAlternatively, you can pass in the complete Vite config as the fourth argument, which will take precedence over any other user-defined options.\n\ncreateVitest\n​\n\nYou can create Vitest instance yourself using createVitest function. It returns the same Vitest instance as startVitest, but it doesn't start tests and doesn't validate installed packages.\n\njs\nimport { createVitest } from 'vitest/node'\n\nconst vitest = await createVitest('test', {\n  watch: false,\n})\nVitest\n​\n\nVitest instance requires the current test mode. It can be either:\n\ntest when running runtime tests\nbenchmark when running benchmarks\nmode\n​\ntest\n​\n\nTest mode will only call functions inside test or it, and throws an error when bench is encountered. This mode uses include and exclude options in the config to find test files.\n\nbenchmark\n​\n\nBenchmark mode calls bench functions and throws an error, when it encounters test or it. This mode uses benchmark.include and benchmark.exclude options in the config to find benchmark files.\n\nstart\n​\n\nYou can start running tests or benchmarks with start method. You can pass an array of strings to filter test files."
  }
]
