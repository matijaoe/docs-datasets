[
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/transition",
    "html": "Transition\n\nThe Transition component takes Vue's built-in transition element one step further by letting you coordinate nested child transitions from a single root component.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nAbout this component\n\nVue has a built-in <transition> component that works great with Tailwind's class-based styling approach, as well as alongside other Headless UI components. In fact, most of the demos and code snippets you'll find for the other Vue components on this site rely on this built-in transition exclusively.\n\nBut there's one exception: nested child transitions. This technique is needed when you want to coordinate different animations for different child elements – for example, fading in a Dialog's backdrop, while at the same time sliding in the contents of the Dialog from one side of the screen.\n\nThe only way to achieve this effect using the built-in <transition> element is to manually synchronize each of the child transitions, and even then the approach can be buggy and error-prone.\n\nThat's why we've included a <TransitionRoot /> component in Headless UI. Its API is similar to Vue's own element, but it also provides a means for coordinating multiple transitions via the included <TransitionChild /> component, as described below.\n\nFor all components except Dialog, you may use Vue's built-in <transition> element whenever you're applying a single transition. For animating a Dialog, or coordinating multiple transitions on any other component, use the TransitionRoot component from Headless UI instead.\n\nBasic example\n\nThe TransitionRoot accepts a show prop that controls whether the children should be shown or hidden, and a set of lifecycle props (like enter-from, and leave-to) that let you add CSS classes at specific phases of a transition.\n\n<template>\n  <button @click=\"isShowing = !isShowing\">Toggle</button>\n  <TransitionRoot\n    :show=\"isShowing\"\n    enter=\"transition-opacity duration-75\"\n    enter-from=\"opacity-0\"\n    enter-to=\"opacity-100\"\n    leave=\"transition-opacity duration-150\"\n    leave-from=\"opacity-100\"\n    leave-to=\"opacity-0\"\n  >\n    I will fade in and out\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { TransitionRoot } from '@headlessui/vue'\n\n  const isShowing = ref(true)\n</script>\nShowing and hiding content\n\nWrap the content that should be conditionally rendered in a <TransitionRoot> component, and use the show prop to control whether the content should be visible or hidden.\n\n<template>\n  <button @click=\"isShowing = !isShowing\">Toggle</button>\n\n  <TransitionRoot :show=\"isShowing\">\n    I will appear and disappear.\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { TransitionRoot } from '@headlessui/vue'\n\n  const isShowing = ref(true)\n</script>\n\n\nThe TransitionRoot component will render a div by default, but you can use the as prop to render a different element instead if needed. Any other HTML attributes (like class) can be added directly to the TransitionRoot the same way they would be to regular elements.\n\n<template>\n  <button @click=\"isShowing = !isShowing\">Toggle</button>\n\n  <TransitionRoot :show=\"isShowing\" as=\"a\" href=\"/my-url\" class=\"font-bold\">\n    I will appear and disappear.\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { TransitionRoot } from '@headlessui/vue'\n\n  const isShowing = ref(true)\n</script>\n\nAnimating transitions\n\nBy default, a TransitionRoot will enter and leave instantly, which is probably not what you're looking for if you're using this component.\n\nTo animate your enter/leave transitions, add classes that provide the styling for each phase of the transitions using these props:\n\nenter: Applied the entire time an element is entering. Usually you define your duration and what properties you want to transition here, for example transition-opacity duration-75.\nenter-from: The starting point to enter from, for example opacity-0 if something should fade in.\nenter-to: The ending point to enter to, for example opacity-100 after fading in.\nleave: Applied the entire time an element is leaving. Usually you define your duration and what properties you want to transition here, for example transition-opacity duration-75.\nleave-from: The starting point to leave from, for example opacity-100 if something should fade out.\nleave-to: The ending point to leave to, for example opacity-0 after fading out.\n\nHere's an example:\n\n<template>\n  <button @click=\"isShowing = !isShowing\">Toggle</button>\n  <TransitionRoot\n    :show=\"isShowing\"\n\n    enter=\"transition-opacity duration-75\"\n    enter-from=\"opacity-0\"\n    enter-to=\"opacity-100\"\n    leave=\"transition-opacity duration-150\"\n    leave-from=\"opacity-100\"\n    leave-to=\"opacity-0\"\n  >\n    I will appear and disappear.\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { TransitionRoot } from '@headlessui/vue'\n\n  const isShowing = ref(true)\n</script>\n\n\nIn this example, the transitioning element will take 75ms to enter (that's the duration-75 class), and will transition the opacity property during that time (that's transition-opacity).\n\nIt will start completely transparent before entering (that's opacity-0 in the enter-from phase), and fade in to completely opaque (opacity-100) when finished (that's the enterTo phase).\n\nWhen the element is being removed (the leave phase), it will transition the opacity property, and spend 150ms doing it (transition-opacity duration-150).\n\nIt will start as completely opaque (the opacity-100 in the leave-from phase), and finish as completely transparent (the opacity-0 in the leave-to phase).\n\nAll of these props are optional, and will default to just an empty string.\n\nCo-ordinating multiple transitions\n\nSometimes you need to transition multiple elements with different animations but all based on the same state. For example, say the user clicks a button to open a sidebar that slides over the screen, and you also need to fade-in a background overlay at the same time.\n\nYou can do this by wrapping the related elements with a parent TransitionRoot component, and wrapping each child that needs its own transition styles with a TransitionChild component, which will automatically communicate with the parent TransitionRoot and inherit the parent's show state.\n\n<template>\n  <!-- The `show` prop controls all nested `TransitionChild` components. -->\n  <TransitionRoot :show=\"isShowing\">\n    <!-- Background overlay -->\n    <TransitionChild\n      enter=\"transition-opacity ease-linear duration-300\"\n      enter-from=\"opacity-0\"\n      enter-to=\"opacity-100\"\n      leave=\"transition-opacity ease-linear duration-300\"\n      leave-from=\"opacity-100\"\n      leave-to=\"opacity-0\"\n    >\n      <!-- ... -->\n    </TransitionChild>\n\n    <!-- Sliding sidebar -->\n    <TransitionChild\n      enter=\"transition ease-in-out duration-300 transform\"\n      enter-from=\"-translate-x-full\"\n      enter-to=\"translate-x-0\"\n      leave=\"transition ease-in-out duration-300 transform\"\n      leave-from=\"translate-x-0\"\n      leave-to=\"-translate-x-full\"\n    >\n      <!-- ... -->\n    </TransitionChild>\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { TransitionRoot, TransitionChild } from '@headlessui/vue'\n\n  const isShowing = ref(true)\n</script>\n\nThe TransitionChild component has the exact same API as the TransitionRoot component, but with no show prop, since the show value is controlled by the parent.\n\nParent TransitionRoot components will always automatically wait for all children to finish transitioning before unmounting, so you don't need to manage any of that timing yourself.\n\nTransitioning on initial mount\n\nIf you want an element to transition the very first time it's rendered, set the appear prop to true.\n\nThis is useful if you want something to transition in on initial page load, or when its parent is conditionally rendered.\n\n<template>\n  <TransitionRoot\n\n    appear\n    :show=\"isShowing\"\n    enter=\"transition-opacity duration-75\"\n    enter-from=\"opacity-0\"\n    enter-to=\"opacity-100\"\n    leave=\"transition-opacity duration-150\"\n    leave-from=\"opacity-100\"\n    leave-to=\"opacity-0\"\n  >\n    <!-- Your content goes here -->\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { TransitionRoot } from '@headlessui/vue'\n\n  const isShowing = ref(true)\n</script>\n\nComponent API\nTransitionRoot\nProp\tDefault\tDescription\nshow\t—\t\nBoolean\n\nWhether the children should be shown or hidden.\n\n\nas\tdiv\t\nString | Component\n\nThe element or component to render in place of the Transition itself.\n\n\nappear\tfalse\t\nBoolean\n\nWhether the transition should run on initial mount.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the show state.\n\n\nenter\t—\t\nString\n\nClasses to add to the transitioning element during the entire enter phase.\n\n\nenter-from\t—\t\nString\n\nClasses to add to the transitioning element before the enter phase starts.\n\n\nenter-to\t—\t\nString\n\nClasses to add to the transitioning element immediately after the enter phase starts.\n\n\nentered\t—\t\nString\n\nClasses to add to the transitioning element once the transition is done. These classes will persist after that, until it's time to leave.\n\n\nleave\t—\t\nString\n\nClasses to add to the transitioning element during the entire leave phase.\n\n\nleave-from\t—\t\nString\n\nClasses to add to the transitioning element before the leave phase starts.\n\n\nleave-to\t—\t\nString\n\nClasses to add to the transitioning element immediately after the leave phase starts.\n\nEvent\tDescription\nbefore-enter\t\n\nEmitted before the enter transition starts.\n\n\nafter-enter\t\n\nEmitted after the enter transition finishes.\n\n\nbefore-leave\t\n\nEmitted before the leave transition starts.\n\n\nafter-leave\t\n\nEmitted after the leave transition finishes.\n\nTransitionChild\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component to render in place of the Transition itself.\n\n\nappear\tfalse\t\nBoolean\n\nWhether the transition should run on initial mount.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the show state.\n\n\nenter\t—\t\nString\n\nClasses to add to the transitioning element during the entire enter phase.\n\n\nenter-from\t—\t\nString\n\nClasses to add to the transitioning element before the enter phase starts.\n\n\nenter-to\t—\t\nString\n\nClasses to add to the transitioning element immediately after the enter phase starts.\n\n\nentered\t—\t\nString\n\nClasses to add to the transitioning element once the transition is done. These classes will persist after that, until it's time to leave.\n\n\nleave\t—\t\nString\n\nClasses to add to the transitioning element during the entire leave phase.\n\n\nleave-from\t—\t\nString\n\nClasses to add to the transitioning element before the leave phase starts.\n\n\nleave-to\t—\t\nString\n\nClasses to add to the transitioning element immediately after the leave phase starts.\n\nEvent\tDescription\nbefore-enter\t\n\nEmitted before the enter transition starts.\n\n\nafter-enter\t\n\nEmitted after the enter transition finishes.\n\n\nbefore-leave\t\n\nEmitted before the leave transition starts.\n\n\nafter-leave\t\n\nEmitted after the leave transition finishes.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/tabs",
    "html": "Tabs\n\nEasily create accessible, fully customizable tab interfaces, with robust focus management and keyboard navigation support.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/vue\nBasic example\n\nTabs are built using the TabGroup, TabList, Tab, TabPanels, and TabPanel components. By default the first tab is selected, and clicking on any tab or selecting it with the keyboard will activate the corresponding panel.\n\n<template>\n  <TabGroup>\n    <TabList>\n      <Tab>Tab 1</Tab>\n      <Tab>Tab 2</Tab>\n      <Tab>Tab 3</Tab>\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <TabPanel>Content 2</TabPanel>\n      <TabPanel>Content 3</TabPanel>\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n</script>\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which tab option is currently checked, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Tab component exposes a selected state, which tells you if the tab is currently selected.\n\n<template>\n  <TabGroup>\n    <TabList>\n      <!-- Use the `selected` state to conditionally style the selected tab. -->\n\n      <Tab as=\"template\" v-slot=\"{ selected }\">\n        <button\n\n          :class=\"{ 'bg-blue-500 text-white': selected, 'bg-white text-black': !selected }\"\n        >\n          Tab 1\n        </button>\n      </Tab>\n      <!-- ... -->\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <!-- ... -->\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n</script>\n\n\nFor the complete slot props API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot props API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the TabGroup component with some child Tab components renders when the second tab is selected:\n\n<!-- Rendered `TabGroup` -->\n<div>\n  <button data-headlessui-state=\"\">Tab 1</button>\n  <button data-headlessui-state=\"selected\">Tab 2</button>\n  <button data-headlessui-state=\"\">Tab 3</button>\n</div>\n<div>\n  <div data-headlessui-state=\"\">Content 1</div>\n  <div data-headlessui-state=\"selected\">Content 2</div>\n  <div data-headlessui-state=\"\">Content 3</div>\n</div>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:*:\n\n<template>\n  <TabGroup>\n    <TabList>\n      <Tab\n\n        class=\"ui-selected:bg-blue-500 ui-selected:text-white ui-not-selected:bg-white ui-not-selected:text-black\"\n      >\n        Tab 1\n      </Tab>\n      <!-- ... -->\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <!-- ... -->\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n</script>\n\nDisabling a tab\n\nTo disable a tab, use the disabled prop on the Tab component. Disabled tabs cannot be selected with the mouse, and are also skipped when navigating the tab list using the keyboard.\n\n<template>\n  <TabGroup>\n    <TabList>\n      <Tab>Tab 1</Tab>\n\n      <Tab disabled>Tab 2</Tab>\n      <Tab>Tab 3</Tab>\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <TabPanel>Content 2</TabPanel>\n      <TabPanel>Content 3</TabPanel>\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n</script>\n\nManually activating tabs\n\nBy default, tabs are automatically selected as the user navigates through them using the arrow keys.\n\nIf you'd rather not change the current tab until the user presses Enter or Space, use the manual prop on the TabGroup component. This can be helpful if selecting a tab performs an expensive operation and you don't want to run it unnecessarily.\n\n<template>\n\n  <TabGroup manual>\n    <TabList>\n      <Tab>Tab 1</Tab>\n      <Tab>Tab 2</Tab>\n      <Tab>Tab 3</Tab>\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <TabPanel>Content 2</TabPanel>\n      <TabPanel>Content 3</TabPanel>\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n</script>\n\n\nThe manual prop has no impact on mouse interactions — tabs will still be selected as soon as they are clicked.\n\nVertical tabs\n\nIf you've styled your TabList to appear vertically, use the vertical prop to enable navigating with the up and down arrow keys instead of left and right, and to update the aria-orientation attribute for assistive technologies.\n\n<template>\n\n  <TabGroup vertical>\n    <TabList>\n      <Tab>Tab 1</Tab>\n      <Tab>Tab 2</Tab>\n      <Tab>Tab 3</Tab>\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <TabPanel>Content 2</TabPanel>\n      <TabPanel>Content 3</TabPanel>\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n</script>\n\nSpecifying the default tab\n\nTo change which tab is selected by default, use the :defaultIndex=\"number\" prop on the TabGroup component.\n\n<template>\n\n  <TabGroup :defaultIndex=\"1\">\n    <TabList>\n      <Tab>Tab 1</Tab>\n\n\n      <!-- Selects this tab by default -->\n      <Tab>Tab 2</Tab>\n\n      <Tab>Tab 3</Tab>\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n\n\n      <!-- Displays this tab by default -->\n      <TabPanel>Content 2</TabPanel>\n\n      <TabPanel>Content 3</TabPanel>\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n</script>\n\n\nIf you happen to provide an index that is out of bounds, then the last non-disabled tab will be selected on initial render. (For example, <TabGroup :defaultIndex=\"5\" in the example above would render the third panel as selected.)\n\nListening for changes\n\nTo run a function whenever the selected tab changes, use the @change event on the TabGroup component.\n\n<template>\n\n  <TabGroup @change=\"changeTab\">\n    <TabList>\n      <Tab>Tab 1</Tab>\n      <Tab>Tab 2</Tab>\n      <Tab>Tab 3</Tab>\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <TabPanel>Content 2</TabPanel>\n      <TabPanel>Content 3</TabPanel>\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n\n\n  function changeTab(index) {\n    console.log('Changed active tab to:', index)\n  }\n</script>\n\nControlling the active tab\n\nThe tabs component can also be used as a controlled component. To do this, provide the selectedIndex and manage the state yourself.\n\n<template>\n\n  <TabGroup :selectedIndex=\"selectedTab\" @change=\"changeTab\">\n    <TabList>\n      <Tab>Tab 1</Tab>\n      <Tab>Tab 2</Tab>\n      <Tab>Tab 3</Tab>\n    </TabList>\n    <TabPanels>\n      <TabPanel>Content 1</TabPanel>\n      <TabPanel>Content 2</TabPanel>\n      <TabPanel>Content 3</TabPanel>\n    </TabPanels>\n  </TabGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { TabGroup, TabList, Tab, TabPanels, TabPanel } from '@headlessui/vue'\n\n\n  const selectedTab = ref(0)\n\n\n  function changeTab(index) {\n    selectedTab.value = index\n  }\n</script>\n\nAccessibility notes\nMouse interaction\n\nClicking a Tab will select that tab and display the corresponding TabPanel.\n\nKeyboard interaction\n\nAll interactions apply when a Tab component is focused.\n\nCommand\tDescription\n\n\nArrowLeft\nand\nArrowRight\n\n\t\n\nSelects the previous/next non-disabled tab.\n\n\n\n\nArrowUp\nand\nArrowDown\nwhen vertical is set\n\n\t\n\nSelects the previous/next non-disabled tab.\n\n\n\n\nHome\nor\nPageUp\n\n\t\n\nSelects the first non-disabled tab.\n\n\n\n\nEnd\nor\nPageDown\n\n\t\n\nSelects the last non-disabled tab.\n\n\n\n\nEnter\nor\nSpace when manual is set\n\n\t\n\nActivates the selected tab.\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nFor a full reference on all accessibility features implemented in Tabs, see the ARIA spec on Tabs.\n\nComponent API\nTabGroup\n\nThe main TabGroup component.\n\nProp\tDefault\tDescription\nas\ttemplate\t\nString | Component\n\nThe element or component the TabGroup should render as.\n\n\ndefaultIndex\t0\t\nNumber\n\nThe default selected index\n\n\nselectedIndex\t—\t\nnumber\n\nThe selected index if you want to use the Tabs component as a controlled component.\n\n\nvertical\tfalse\t\nBoolean\n\nWhen true, the orientation of the TabList will be vertical, otherwise it will be horizontal.\n\n\nmanual\tfalse\t\nBoolean\n\nWhen true, the user can only display a panel via the keyboard by first navigating to it using the arrow keys, and then by pressing Enter or Space. By default, panels are automatically displayed when navigated to via the arrow keys. Note that this prop has no affect on mouse behavior.\n\nSlot Prop\tDescription\nselectedIndex\t\n\nNumber\n\nThe currently selected index.\n\nEvent\tDescription\nchange\t\n\nA function called whenever the active tab changes.\n\nTabList\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the TabList should render as.\n\nSlot Prop\tDescription\nselectedIndex\t\n\nNumber\n\nThe currently selected index.\n\nTab\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Tab should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the Tab is currently disabled.\n\nSlot Prop\tDescription\nselected\t\n\nBoolean\n\nWhether or not the Tab is currently selected.\n\nTabPanels\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the TabPanels should render as.\n\nSlot Prop\tDescription\nselectedIndex\t\n\nNumber\n\nThe currently selected index.\n\nTabPanel\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the TabPanel should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the selected index.\n\n_Note: static and unmount can not be used at the same time.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the selected index.\n\n_Note: static and unmount can not be used at the same time.\n\nSlot Prop\tDescription\nselected\t\n\nBoolean\n\nWhether or not the TabPanel is currently selected.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/radio-group",
    "html": "Radio Group\n\nRadio Groups give you the same functionality as native HTML radio inputs, without any of the styling. They're perfect for building out custom UIs for selectors.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nRadio Groups are built using the RadioGroup, RadioGroupLabel, and RadioGroupOption components.\n\nClicking an option will select it, and when the Radio Group is focused, the arrow keys will change the selected option.\n\n<template>\n  <RadioGroup v-model=\"plan\">\n    <RadioGroupLabel>Plan</RadioGroupLabel>\n    <RadioGroupOption v-slot=\"{ checked }\" value=\"startup\">\n      <span :class=\"checked ? 'bg-blue-200' : ''\">Startup</span>\n    </RadioGroupOption>\n    <RadioGroupOption v-slot=\"{ checked }\" value=\"business\">\n      <span :class=\"checked ? 'bg-blue-200' : ''\">Business</span>\n    </RadioGroupOption>\n    <RadioGroupOption v-slot=\"{ checked }\" value=\"enterprise\">\n      <span :class=\"checked ? 'bg-blue-200' : ''\">Enterprise</span>\n    </RadioGroupOption>\n  </RadioGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n\n  const plan = ref('startup')\n</script>\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which radiogroup option is currently selected, whether a popover is open or closed, or which item in a radiogroup is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the RadioGroupOption component exposes an active state, which tells you if the item is currently focused via the mouse or keyboard.\n\n<template>\n  <RadioGroup v-model=\"plan\">\n    <RadioGroupLabel>Plan</RadioGroupLabel>\n    <!-- Use the `active` state to conditionally style the active option. -->\n    <!-- Use the `checked` state to conditionally style the checked option. -->\n    <RadioGroupOption\n      v-for=\"plan in plans\"\n      :key=\"plan\"\n      :value=\"plan\"\n      as=\"template\"\n\n      v-slot=\"{ active, checked }\"\n    >\n      <li\n        :class=\"{\n\n          'bg-blue-500 text-white': active,\n          'bg-white text-black': !active,\n        }\"\n      >\n\n        <CheckIcon v-show=\"checked\" />\n        {{ plan }}\n      </li>\n    </RadioGroupOption>\n  </RadioGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n  import { CheckIcon } from '@heroicons/vue/20/solid'\n\n  const plans = ['Startup', 'Business', 'Enterprise']\n  const plan = ref(plans[0])\n</script>\n\n\nFor a complete list of all the available slot props, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the RadioGroup component with some child RadioGroupOption components renders when the radiogroup is open and the second item is active:\n\n<!-- Rendered `RadioGroup` -->\n<ul data-headlessui-state=\"open\">\n  <li data-headlessui-state=\"\">Wade Cooper</li>\n  <li data-headlessui-state=\"active selected\">Arlene Mccoy</li>\n  <li data-headlessui-state=\"\">Devon Webb</li>\n</ul>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\n<template>\n  <RadioGroup v-model=\"plan\">\n    <RadioGroupLabel>Plan</RadioGroupLabel>\n    <RadioGroupOption\n      v-for=\"plan in plans\"\n      :key=\"plan\"\n      :value=\"plan\"\n      as=\"template\"\n    >\n      <li\n\n        class=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n      >\n\n        <CheckIcon class=\"hidden ui-checked:block\" />\n        {{ plan }}\n      </li>\n    </RadioGroupOption>\n  </RadioGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n  import { CheckIcon } from '@heroicons/vue/20/solid'\n\n  const plans = ['Startup', 'Business', 'Enterprise']\n  const plan = ref(plans[0])\n</script>\n\nBinding objects as values\n\nUnlike native HTML form controls which only allow you to provide strings as values, Headless UI supports binding complex objects as well.\n\n<template>\n\n  <RadioGroup v-model=\"plan\">\n    <RadioGroupLabel>Plan</RadioGroupLabel>\n\n    <RadioGroupOption v-for=\"plan in plans\" :key=\"plan.id\" :value=\"plan\">\n      {{ plan.name }}\n    </RadioGroupOption>\n  </RadioGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n\n\n  const plans = [\n    { id: 1, name: 'Startup' },\n    { id: 2, name: 'Business' },\n    { id: 3, name: 'Enterprise' },\n  ]\n  const plan = ref(plans[1])\n</script>\n\n\nWhen binding objects as values, it's important to make sure that you use the same instance of the object as both the value of the RadioGroup as well as the corresponding RadioGroupOption, otherwise they will fail to be equal and cause the radiogroup to behave incorrectly.\n\nTo make it easier to work with different instances of the same object, you can use the by prop to compare the objects by a particular field instead of comparing object identity:\n\n<template>\n  <RadioGroup\n    :modelValue=\"modelValue\"\n    @update:modelValue=\"value => emit('update:modelValue', value)\"\n\n    by=\"id\"\n  >\n    <RadioGroupLabel>Assignee</RadioGroupLabel>\n    <RadioGroupOption v-for=\"plan in plans\" :key=\"plan.id\" :value=\"plan\">\n      {{ plan.name }}\n    </RadioGroupOption>\n  </RadioGroup>\n</template>\n\n<script setup>\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n\n  const props = defineProps({ modelValue: Object })\n  const emit = defineEmits(['update:modelValue'])\n\n  const plans = [\n    { id: 1, name: 'Startup' },\n    { id: 2, name: 'Business' },\n    { id: 3, name: 'Enterprise' },\n  ]\n</script>\n\n\nYou can also pass your own comparison function to the by prop if you'd like complete control over how objects are compared:\n\n<template>\n  <RadioGroup\n    :modelValue=\"modelValue\"\n    @update:modelValue=\"value => emit('update:modelValue', value)\"\n\n    :by=\"comparePlans\"\n  >\n    <RadioGroupLabel>Assignee</RadioGroupLabel>\n    <RadioGroupOption v-for=\"plan in plans\" :key=\"plan.id\" :value=\"plan\">\n      {{ plan.name }}\n    </RadioGroupOption>\n  </RadioGroup>\n</template>\n\n<script setup>\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n\n  const props = defineProps({ modelValue: Object })\n  const emit = defineEmits(['update:modelValue'])\n\n\n  function comparePlans(a, b) {\n    return a.name.toLowerCase() === b.name.toLowerCase()\n  }\n\n  const plans = [\n    { id: 1, name: 'Startup' },\n    { id: 2, name: 'Business' },\n    { id: 3, name: 'Enterprise' },\n  ]\n</script>\n\nUsing with HTML forms\n\nIf you add the name prop to your listbox, hidden input elements will be rendered and kept in sync with your selected value.\n\n<template>\n  <form action=\"/billing\" method=\"post\">\n\n    <RadioGroup v-model=\"plan\" name=\"plan\">\n      <RadioGroupLabel>Plan</RadioGroupLabel>\n      <RadioGroupOption v-for=\"plan in plans\" :key=\"plan\" :value=\"plan\">\n        {{ plan }}\n      </RadioGroupOption>\n    </RadioGroup>\n    <button>Submit</button>\n  </form>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n\n  const plans = ['startup', 'business', 'enterprise']\n  const plan = ref(plans[0])\n</script>\n\n\nThis lets you use a radio group inside a native HTML <form> and make traditional form submissions as if your radio group was a native HTML form control.\n\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like objects will be encoded into multiple inputs using a square bracket notation for the names.\n\n<input type=\"hidden\" name=\"plan\" value=\"startup\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultValue prop to the RadioGroup instead of a value, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\n<template>\n  <form action=\"/billing\" method=\"post\">\n\n    <RadioGroup name=\"plan\" :defaultValue=\"plans[0]\">\n      <RadioGroupLabel>Plan</RadioGroupLabel>\n      <RadioGroupOption v-for=\"plan in plans\" :key=\"plan\" :value=\"plan\">\n        {{ plan }}\n      </RadioGroupOption>\n    </RadioGroup>\n    <button>Submit</button>\n  </form>\n</template>\n\n<script setup>\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n  } from '@headlessui/vue'\n\n  const plans = ['startup', 'business', 'enterprise']\n</script>\n\n\nThis can simplify your code when using the combobox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny @update:modelValue prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nUsing the Label and Description components\n\nYou can use the RadioGroupLabel and RadioGroupDescription components to mark up each option's contents. Doing so will automatically link each component to its ancestor RadioGroupOption component via the aria-labelledby and aria-describedby attributes and autogenerated ids, improving the semantics and accessibility of your custom selector.\n\nBy default, RatioGroupLabel renders a label element and RadioGroupDescription renders a <div>. These can also be customized using the as prop, as described in the API docs below.\n\nNote also that Labels and Descriptions can be nested. Each one will refer to its nearest ancestor component, whether than ancestor is a RadioGroupOption or the root RadioGroup itself.\n\n<template>\n  <RadioGroup v-model=\"plan\">\n    <!-- This label is for the root `RadioGroup` -->\n\n    <RadioGroupLabel class=\"sr-only\">Plan</RadioGroupLabel>\n    <div class=\"rounded-md bg-white\">\n      <RadioGroupOption value=\"startup\" as=\"template\" v-slot=\"{ checked }\">\n        <div\n          :class='checked ? \"bg-indigo-50 border-indigo-200\" : \"border-gray-200\"'\n          class=\"relative flex border p-4\"\n        >\n          <div class=\"flex flex-col\">\n            <!-- This label is for the `RadioGroupOption` -->\n\n            <RadioGroupLabel as=\"template\">\n              <span\n                :class='checked ? \"text-indigo-900\" : \"text-gray-900\"'\n                class=\"block text-sm font-medium\"\n                >Startup</span\n              >\n            </RadioGroupLabel>\n\n            <!-- This description is for the `RadioGroupOption` -->\n\n            <RadioGroupDescription as=\"template\">\n              <span\n                :class='checked ? \"text-indigo-700\" : \"text-gray-500\"'\n                class=\"block text-sm\"\n                >Up to 5 active job postings</span\n              >\n            </RadioGroupDescription>\n          </div>\n        </div>\n      </RadioGroupOption>\n    </div>\n  </RadioGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    RadioGroup,\n    RadioGroupLabel,\n    RadioGroupOption,\n    RadioGroupDescription,\n  } from '@headlessui/vue'\n\n  const plan = ref('startup')\n</script>\n\nAccessibility notes\nMouse interaction\n\nClicking a RadioGroupOption will select it.\n\nKeyboard interaction\n\nAll interactions apply when a RadioGroup component is focused.\n\nCommand\tDescription\n\n\nArrowDown\nor\nArrowUp\nor\nArrowLeft\nor\nArrowRight\n\n\t\n\nCycles through a RadioGroup's options\n\n\n\n\nSpace when no option is selected yet\n\n\t\n\nSelects the first option\n\n\n\n\nEnter when in a form\n\n\t\n\nSubmits the form\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nRadioGroup\n\nThe main Radio Group component.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the RadioGroup should render as.\n\n\nv-model\t—\t\nT\n\nThe selected value.\n\n\ndefaultValue\t—\t\nT\n\nThe default value when using as an uncontrolled component.\n\n\nby\t—\t\nkeyof T | ((a: T, z: T) => boolean)\n\nUse this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.\n\n\ndisabled\tfalse\t\nboolean\n\nWhether or not the RadioGroup and all of its RadioGroupOption's' are disabled.\n\nRadioGroupOption\n\nThe wrapper component for each selectable option.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the RadioGroupOption should render as.\n\n\nvalue\t—\t\nT | undefined\n\nThe value of the current RadioGroupOption. The type should match the type of the value in the RadioGroup component.\n\n\ndisabled\tfalse\t\nboolean\n\nWhether or not the RadioGroupOption is disabled.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\nSlot Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the option is active (using the mouse or keyboard).\n\n\nchecked\t\n\nBoolean\n\nWhether or not the current option is the checked value.\n\n\ndisabled\t\n\nboolean\n\nWhether or not the current option is disabled.\n\nRadioGroupLabel\n\nRenders an element whose id attribute is automatically generated, and is then linked to its nearest ancestor RadioGroup or RadioGroupOption component via the aria-labelledby attribute.\n\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the RadioGroupLabel should render as.\n\nRadioGroupDescription\n\nRenders an element whose id attribute is automatically generated, and is then linked to its nearest ancestor RadioGroup or RadioGroupOption component via the aria-describedby attribute.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the RadioGroupDescription should render as.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/popover",
    "html": "Popover\n\nPopovers are perfect for floating panels with arbitrary content like navigation menus, mobile menus and flyout menus.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nPopovers are built using the Popover, PopoverButton, and PopoverPanel components.\n\nClicking the PopoverButton will automatically open/close the PopoverPanel. When the panel is open, clicking anywhere outside of its contents, pressing the Escape key, or tabbing away from it will close the Popover.\n\n<template>\n  <Popover class=\"relative\">\n    <PopoverButton>Solutions</PopoverButton>\n\n    <PopoverPanel class=\"absolute z-10\">\n      <div class=\"grid grid-cols-2\">\n        <a href=\"/analytics\">Analytics</a>\n        <a href=\"/engagement\">Engagement</a>\n        <a href=\"/security\">Security</a>\n        <a href=\"/integrations\">Integrations</a>\n      </div>\n\n      <img src=\"/solutions.jpg\" alt=\"\" />\n    </PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n</script>\n\nThese components are completely unstyled, so how you style your Popover is up to you. In our example we're using absolute positioning on the PopoverPanel to position it near the PopoverButton and not disturb the normal document flow.\n\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a popover is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Popover component exposes an open state, which tells you if the popover is currently open.\n\n<template>\n\n  <Popover v-slot=\"{ open }\">\n    <!-- Use the `open` state to conditionally change the direction of the chevron icon. -->\n    <PopoverButton>\n      Solutions\n\n      <ChevronDownIcon :class=\"{ 'rotate-180 transform': open }\" />\n    </PopoverButton>\n\n    <PopoverPanel>\n      <a href=\"/insights\">Insights</a>\n      <a href=\"/automations\">Automations</a>\n      <a href=\"/reports\">Reports</a>\n    </PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n  import { ChevronDownIcon } from '@heroicons/vue/20/solid'\n</script>\n\n\nFor a complete list of all the available slot props, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Popover component renders when the popover is open:\n\n<!-- Rendered `Popover` -->\n<div data-headlessui-state=\"open\">\n  <button data-headlessui-state=\"open\">Solutions</button>\n  <div data-headlessui-state=\"open\">\n    <a href=\"/insights\">Insights</a>\n    <a href=\"/automations\">Automations</a>\n    <a href=\"/reports\">Reports</a>\n  </div>\n</div>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:*:\n\n<template>\n  <Popover>\n    <PopoverButton>\n      Solutions\n\n      <ChevronDownIcon class=\"ui-open:rotate-180 ui-open:transform\" />\n    </PopoverButton>\n\n    <PopoverPanel>\n      <a href=\"/insights\">Insights</a>\n      <a href=\"/automations\">Automations</a>\n      <a href=\"/reports\">Reports</a>\n    </PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n  import { ChevronDownIcon } from '@heroicons/vue/20/solid'\n</script>\n\nShowing/hiding the popover\n\nBy default, your PopoverPanel will be shown/hidden automatically based on the internal open state tracked within the Popover component itself.\n\n<template>\n  <Popover>\n    <PopoverButton>Solutions</PopoverButton>\n    <!--\n      By default, the `PopoverPanel` will automatically show/hide\n      when the `PopoverButton` is pressed.\n    -->\n    <PopoverPanel>\n      <!-- ... -->\n    </PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n</script>\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can pass a static prop to the PopoverPanel to tell it to always render, and then use the open slot prop to control when the panel is shown/hidden yourself.\n\n<template>\n\n  <Popover v-slot=\"{ open }\">\n    <PopoverButton>Solutions</PopoverButton>\n\n    <div v-if=\"open\">\n\n      <!--\n        Using the `static` prop, the `PopoverPanel` is always\n\n        rendered and the `open` state is ignored.\n      -->\n      <PopoverPanel static>\n        <!-- ... -->\n      </PopoverPanel>\n    </div>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n</script>\n\nClosing popovers manually\n\nSince popovers can contain interactive content like form controls, we can't automatically close them when you click something inside of them like we can with Menu components.\n\nTo close a popover manually when clicking a child of its panel, render that child as a PopoverButton. You can use the :as prop to customize which element is being rendered.\n\n<template>\n  <Popover>\n    <PopoverButton>Solutions</PopoverButton>\n\n    <PopoverPanel>\n\n      <PopoverButton :as=\"MyLink\" href=\"/insights\">Insights</PopoverButton>\n      <!-- ... -->\n    </PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n  import MyLink from './MyLink'\n</script>\n\n\nAlternatively, Popover and PopoverPanel expose a close() slot prop which you can use to imperatively close the panel, say after running an async action:\n\n<template>\n  <Popover>\n    <PopoverButton>Solutions</PopoverButton>\n\n\n    <PopoverPanel v-slot=\"{ close }\">\n      <button @click=\"accept(close)\">Read and accept</button>\n    </PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n\n\n  async function accept(close) {\n    await fetch('/accept-terms', { method: 'POST' })\n    close()\n  }\n</script>\n\n\nBy default the PopoverButton receives focus after calling close(), but you can change this by passing a ref into close(ref).\n\nAdding an overlay\n\nIf you'd like to style a backdrop over your application UI whenever you open a Popover, use the PopoverOverlay component:\n\n<template>\n  <Popover v-slot=\"{ open }\">\n    <PopoverButton>Solutions</PopoverButton>\n\n    <PopoverOverlay class=\"fixed inset-0 bg-black opacity-30\" />\n\n    <PopoverPanel>\n      <!-- ... -->\n    </PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import {\n    Popover,\n    PopoverOverlay,\n    PopoverButton,\n    PopoverPanel,\n  } from '@headlessui/vue'\n</script>\n\n\nIn this example, we put the PopoverOverlay before the Panel in the DOM so that it doesn't cover up the panel's contents.\n\nBut like all the other components, PopoverOverlay is completely headless, so how you style it is up to you.\n\nTransitions\n\nTo animate the opening/closing of your Popover's panel, you can use Vue's built-in <transition> element. All you need to do is wrap your PopoverPanel in a <transition>, and the transition will be applied automatically.\n\n<template>\n  <Popover>\n    <PopoverButton>Solutions</PopoverButton>\n\n    <!-- Use the built-in `transition` component to add transitions. -->\n\n    <transition\n      enter-active-class=\"transition duration-200 ease-out\"\n      enter-from-class=\"translate-y-1 opacity-0\"\n      enter-to-class=\"translate-y-0 opacity-100\"\n      leave-active-class=\"transition duration-150 ease-in\"\n      leave-from-class=\"translate-y-0 opacity-100\"\n      leave-to-class=\"translate-y-1 opacity-0\"\n    >\n      <PopoverPanel>\n        <!-- ... -->\n      </PopoverPanel>\n    </transition>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n</script>\n\n\nIf you'd like to coordinate multiple transitions for different children of your Popover, check out the Transition component included in Headless UI.\n\nGrouping related popovers\n\nWhen rendering several related Popovers, for example in a site's header navigation, use the PopoverGroup component. This ensures panels stay open while users are tabbing between Popovers within a group, but closes any open panel once the user tabs outside of the group:\n\n<template>\n\n  <PopoverGroup>\n    <Popover>\n      <PopoverButton>Product</PopoverButton>\n      <PopoverPanel>\n        <!-- ... -->\n      </PopoverPanel>\n    </Popover>\n\n    <Popover>\n      <PopoverButton>Solutions</PopoverButton>\n      <PopoverPanel>\n        <!-- ... -->\n      </PopoverPanel>\n    </Popover>\n\n  </PopoverGroup>\n</template>\n\n<script setup>\n  import {\n    PopoverGroup,\n    Popover,\n    PopoverButton,\n    PopoverPanel,\n  } from '@headlessui/vue'\n</script>\n\nRendering a different element for a component\n\nPopover and its subcomponents each render a default element that is sensible for that component: the Popover, Overlay, Panel and Group components all render a <div>, and the Button component renders a <button>.\n\nThis is easy to change using the as prop, which exists on every component.\n\n<template>\n  <!-- Render a `nav` instead of a `div` -->\n\n  <Popover as=\"nav\">\n    <PopoverButton>Solutions</PopoverButton>\n\n    <!-- Render a `form` instead of a `div` -->\n\n    <PopoverPanel as=\"form\"><!-- ... --></PopoverPanel>\n  </Popover>\n</template>\n\n<script setup>\n  import { Popover, PopoverButton, PopoverPanel } from '@headlessui/vue'\n</script>\n\nAccessibility notes\nFocus management\n\nPressing Tab on an open panel will focus the first focusable element within the panel's contents. If a PopoverGroup is being used, Tab cycles from the end of an open panel's content to the next Popover's button.\n\nMouse interaction\n\nClicking a PopoverButton toggles a panel open and closed. Clicking anywhere outside of an open panel will close that panel.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\nor\nSpacewhen a PopoverButton is focused.\n\n\t\n\nToggle panel\n\n\n\n\nEsc\n\n\t\n\nCloses any open Popovers\n\n\n\n\nTab\n\n\t\n\nCycle through an open panel's contents\n\nTabbing out of an open panel will close that panel, and tabbing from one open panel to a sibling Popover's button (within a PopoverGroup) closes the first panel\n\n\n\n\nShift + Tab\n\n\t\n\nCycle backwards through the focus order\n\nOther\n\nNested Popovers are supported, and all panels will close correctly whenever the root panel is closed.\n\nAll relevant ARIA attributes are automatically managed.\n\nWhen to use a Popover\n\nHere's how Popovers compare to other similar components:\n\n<Menu />. Popovers are more general-purpose than Menus. Menus only support very restricted content and have specific accessibility semantics. Arrow keys also navigate a Menu's items. Menus are best for UI elements that resemble things like the menus you'd find in the title bar of most operating systems. If your floating panel has images or more markup than simple links, use a Popover.\n\n<Disclosure />. Disclosures are useful for things that typically reflow the document, like Accordions. Popovers also have extra behavior on top of Disclosures: they render overlays, and are closed when the user either clicks the overlay (by clicking outside of the Popover's content) or presses the escape key. If your UI element needs this behavior, use a Popover instead of a Disclosure.\n\n<Dialog />. Dialogs are meant to grab the user's full attention. They typically render a floating panel in the center of the screen, and use a backdrop to dim the rest of the application's contents. They also capture focus and prevent tabbing away from the Dialog's contents until the Dialog is dismissed. Popovers are more contextual, and are usually positioned near the element that triggered them.\n\nComponent API\nPopover\n\nThe main Popover component.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Popover should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the popover and refocuses PopoverButton. Optionally pass in a ref or HTMLElement to focus that element instead.\n\nPopoverOverlay\n\nThis can be used to create an overlay for your Popover component. Clicking on the overlay will close the Popover.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the PopoverOverlay should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\nPopoverButton\n\nThis is the trigger component to toggle a Popover. You can also use this PopoverButton component inside a PopoverPanel, if you do so, then it will behave as a close button. We will also make sure to provide the correct aria-* attributes onto the button.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the PopoverButton should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\nPopoverPanel\n\nThis component contains the contents of your Popover.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the PopoverPanel should render as.\n\n\nfocus\tfalse\t\nBoolean\n\nThis will force focus inside the PopoverPanel when the Popover is open. It will also close the Popover if focus left this component.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the popover and refocuses PopoverButton. Optionally pass in a ref or HTMLElement to focus that element instead.\n\nPopoverGroup\n\nLink related sibling popovers by wrapping them in a PopoverGroup. Tabbing out of one PopoverPanel will focus the next popover's PopoverButton, and tabbing outside of the PopoverGroup completely will close all popovers inside the group.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the PopoverGroup should render as.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/dialog",
    "html": "Dialog (Modal)\n\nA fully-managed, renderless dialog component jam-packed with accessibility and keyboard features, perfect for building completely custom modal and dialog windows for your next application.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nDialogs are built using the Dialog, DialogPanel, DialogTitle and DialogDescription components.\n\nWhen the dialog's open prop is true, the contents of the dialog will render. Focus will be moved inside the dialog and trapped there as the user cycles through the focusable elements. Scroll is locked, the rest of your application UI is hidden from screen readers, and clicking outside the DialogPanel or pressing the Escape key will fire the close event and close the dialog.\n\n<template>\n  <Dialog :open=\"isOpen\" @close=\"setIsOpen\">\n    <DialogPanel>\n      <DialogTitle>Deactivate account</DialogTitle>\n      <DialogDescription>\n        This will permanently deactivate your account\n      </DialogDescription>\n\n      <p>\n        Are you sure you want to deactivate your account? All of your data will be\n        permanently removed. This action cannot be undone.\n      </p>\n\n      <button @click=\"setIsOpen(false)\">Deactivate</button>\n      <button @click=\"setIsOpen(false)\">Cancel</button>\n    </DialogPanel>\n  </Dialog>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Dialog,\n    DialogPanel,\n    DialogTitle,\n    DialogDescription,\n  } from '@headlessui/vue'\n\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n    isOpen.value = value\n  }\n</script>\n\nIf your dialog has a title and description, use the DialogTitle and DialogDescription components to provide the most accessible experience. This will link your title and description to the root dialog component via the aria-labelledby and aria-describedby attributes, ensuring their contents are announced to users using screenreaders when your dialog opens.\n\nShowing and hiding your dialog\n\nDialogs have no automatic management of their open/closed state. To show and hide your dialog, pass a ref into the open prop. When open is true the dialog will render, and when it's false the dialog will unmount.\n\nThe close event fires when an open dialog is dismissed, which happens when the user clicks outside your DialogPanel or presses the Escape key. You can use this event to set open back to false and close your dialog.\n\n<template>\n  <!--\n    Pass the `isOpen` ref to the `open` prop, and use the `close` event\n    to set the ref back to `false` when the user clicks outside of\n    the dialog or presses the escape key.\n  -->\n\n  <Dialog :open=\"isOpen\" @close=\"setIsOpen\">\n    <DialogPanel>\n      <DialogTitle>Deactivate account</DialogTitle>\n      <DialogDescription>\n        This will permanently deactivate your account\n      </DialogDescription>\n\n      <p>\n        Are you sure you want to deactivate your account? All of your data will be\n        permanently removed. This action cannot be undone.\n      </p>\n\n      <!--\n        You can render additional buttons to dismiss your dialog by setting your\n        `isOpen` state to `false`.\n      -->\n      <button @click=\"setIsOpen(false)\">Cancel</button>\n      <button @click=\"handleDeactivate\">Deactivate</button>\n\n    </DialogPanel>\n  </Dialog>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Dialog,\n    DialogPanel,\n    DialogTitle,\n    DialogDescription,\n  } from '@headlessui/vue'\n\n  // The open/closed state lives outside of the Dialog and\n  // is managed by you.\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n\n    isOpen.value = value\n  }\n\n  function handleDeactivate() {\n    // ...\n  }\n</script>\n\nStyling the dialog\n\nStyle the Dialog and DialogPanel components using the class or style props like you would with any other element. You can also introduce additional elements if needed to achieve a particular design.\n\n<template>\n  <Dialog :open=\"isOpen\" @close=\"setIsOpen\" class=\"relative z-50\">\n    <div class=\"fixed inset-0 flex w-screen items-center justify-center p-4\">\n      <DialogPanel class=\"w-full max-w-sm rounded bg-white\">\n        <DialogTitle>Complete your order</DialogTitle>\n\n        <!-- ... -->\n      </DialogPanel>\n    </div>\n  </Dialog>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { DialogPanel, DialogTitle, DialogDescription } from '@headlessui/vue'\n\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n    isOpen.value = value\n  }\n</script>\n\nClicking outside the DialogPanel component will close the dialog, so keep that in mind when deciding which element should receive a given style.\n\nAdding a backdrop\n\nIf you'd like to add an overlay or backdrop behind your DialogPanel to bring attention to the panel itself, we recommend using a dedicated element just for the backdrop and making it a sibling to your panel container:\n\n<template>\n  <Dialog :open=\"isOpen\" @close=\"setIsOpen\" class=\"relative z-50\">\n    <!-- The backdrop, rendered as a fixed sibling to the panel container -->\n\n    <div class=\"fixed inset-0 bg-black/30\" aria-hidden=\"true\" />\n\n    <!-- Full-screen container to center the panel -->\n    <div class=\"fixed inset-0 flex w-screen items-center justify-center p-4\">\n      <!-- The actual dialog panel -->\n      <DialogPanel class=\"w-full max-w-sm rounded bg-white\">\n        <DialogTitle>Complete your order</DialogTitle>\n\n        <!-- ... -->\n      </DialogPanel>\n    </div>\n  </Dialog>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Dialog, DialogTitle, DialogDescription } from '@headlessui/vue'\n\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n    isOpen.value = value\n  }\n</script>\n\n\nThis lets you transition the backdrop and panel independently with their own animations, and rendering it as a sibling ensures that it doesn't interfere with your ability to scroll long dialogs.\n\nScrollable dialogs\n\nMaking a dialog scrollable is handled entirely in CSS, and the specific implementation depends on the design you are trying to achieve.\n\nHere's an example where the entire panel container is scrollable, and the panel itself moves as you scroll:\n\n<template>\n  <Dialog :open=\"isOpen\" @close=\"setIsOpen\" class=\"relative z-50\">\n    <!-- The backdrop, rendered as a fixed sibling to the panel container -->\n    <div class=\"fixed inset-0 bg-black/30\" aria-hidden=\"true\" />\n\n    <!-- Full-screen scrollable container -->\n\n    <div class=\"fixed inset-0 w-screen overflow-y-auto\">\n      <!-- Container to center the panel -->\n\n      <div class=\"flex min-h-full items-center justify-center p-4\">\n        <!-- The actual dialog panel -->\n        <DialogPanel class=\"w-full max-w-sm rounded bg-white\">\n          <DialogTitle>Complete your order</DialogTitle>\n\n          <!-- ... -->\n        </DialogPanel>\n      </div>\n    </div>\n  </Dialog>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Dialog, DialogTitle, DialogDescription } from '@headlessui/vue'\n\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n    isOpen.value = value\n  }\n</script>\n\n\nWhen creating a scrollable dialog with a backdrop, make sure the backdrop is rendered behind the scrollable container, otherwise the scroll wheel won't work when hovering over the backdrop, and the backdrop may obscure the scrollbar and prevent users from clicking it with their mouse.\n\nManaging initial focus\n\nFor accessibility reasons, your dialog should contain at least one focusable element. By default, the Dialog component will focus the first focusable element (by DOM order) once it is rendered, and pressing the Tab key will cycle through all additional focusable elements within the contents.\n\nFocus is trapped within the dialog as long as it is rendered, so tabbing to the end will start cycling back through the beginning again. All other application elements outside of the dialog will be marked as inert and thus not focusable.\n\nIf you'd like something other than the first focusable element to receive initial focus when your dialog is initially rendered, you can use the initialFocus ref:\n\n<template>\n\n  <Dialog :initialFocus=\"completeButtonRef\" :open=\"isOpen\" @close=\"setIsOpen\">\n    <DialogPanel>\n      <DialogTitle>Complete your order</DialogTitle>\n\n      <p>Your order is all ready!</p>\n\n      <button @click=\"setIsOpen(false)\">Deactivate</button>\n      <!-- Use `initialFocus` to force initial focus to a specific ref. -->\n\n      <button ref=\"completeButtonRef\" @click=\"completeOrder\">\n        Complete order\n      </button>\n    </DialogPanel>\n  </Dialog>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Dialog,\n    DialogPanel,\n    DialogTitle,\n    DialogDescription,\n  } from '@headlessui/vue'\n\n\n  const completeButtonRef = ref(null)\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n    isOpen.value = value\n  }\n\n  function completeOrder() {\n    // ...\n  }\n</script>\n\nRendering to a portal\n\nIf you've ever implemented a Dialog before, you've probably come across the concept of Portals. Portals let you invoke components from one place in the DOM (for instance deep within your application UI), but actually render to another place in the DOM entirely.\n\nSince Dialogs and their backdrops take up the full page, you typically want to render them as a sibling to the root-most node of your application. That way you can rely on natural DOM ordering to ensure that their content is rendered on top of your existing application UI. This also makes it easy to apply scroll locking to the rest of your application, as well as ensure that your Dialog's contents and backdrop are unobstructed to receive focus and click events.\n\nBecause of these accessibility concerns, Headless UI's Dialog component actually uses a Portal under-the-hood. This way we can provide features like unobstructed event handling and making the rest of your application inert. So, when using our Dialog, there's no need to use a Portal yourself! We've already taken care of it.\n\nTransitions\n\nTo animate the opening/closing of your dialog, wrap it in Headless UI's TransitionRoot component and remove the open prop from your Dialog, passing your open/closed state to the show prop on the TransitionRoot instead.\n\n<template>\n  <!-- Wrap your dialog in a `TransitionRoot` to add transitions. -->\n\n  <TransitionRoot\n    :show=\"isOpen\"\n    as=\"template\"\n    enter=\"duration-300 ease-out\"\n    enter-from=\"opacity-0\"\n    enter-to=\"opacity-100\"\n    leave=\"duration-200 ease-in\"\n    leave-from=\"opacity-100\"\n    leave-to=\"opacity-0\"\n  >\n    <Dialog @close=\"setIsOpen\">\n      <DialogPanel>\n        <DialogTitle>Deactivate account</DialogTitle>\n        <!-- ... -->\n        <button @click=\"isOpen = false\">Close</button>\n      </DialogPanel>\n    </Dialog>\n\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n\n    TransitionRoot,\n    Dialog,\n    DialogPanel,\n    DialogTitle,\n  } from '@headlessui/vue'\n\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n    isOpen.value = value\n  }\n</script>\n\n\nTo animate your backdrop and panel separately, wrap your Dialog with a TransitionRoot and wrap your backdrop and panel each with their own TransitionChild:\n\n<template>\n  <!-- Wrap your dialog in a `TransitionRoot`. -->\n\n  <TransitionRoot :show=\"isOpen\" as=\"template\">\n    <Dialog @close=\"setIsOpen\">\n      <!-- Wrap your backdrop in a `TransitionChild`. -->\n\n      <TransitionChild\n        enter=\"duration-300 ease-out\"\n        enter-from=\"opacity-0\"\n        enter-to=\"opacity-100\"\n        leave=\"duration-200 ease-in\"\n        leave-from=\"opacity-100\"\n        leave-to=\"opacity-0\"\n      >\n        <div class=\"fixed inset-0 bg-black/30\" />\n\n      </TransitionChild>\n\n      <!-- Wrap your panel in a `TransitionChild`. -->\n\n      <TransitionChild\n        enter=\"duration-300 ease-out\"\n        enter-from=\"opacity-0 scale-95\"\n        enter-to=\"opacity-100 scale-100\"\n        leave=\"duration-200 ease-in\"\n        leave-from=\"opacity-100 scale-100\"\n        leave-to=\"opacity-0 scale-95\"\n      >\n        <DialogPanel>\n          <DialogTitle>Deactivate account</DialogTitle>\n          <!-- ... -->\n        </DialogPanel>\n\n      </TransitionChild>\n    </Dialog>\n  </TransitionRoot>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n\n    TransitionRoot,\n    TransitionChild,\n    Dialog,\n    DialogPanel,\n    DialogTitle,\n  } from '@headlessui/vue'\n\n  const isOpen = ref(true)\n\n  function setIsOpen(value) {\n    isOpen.value = value\n  }\n</script>\n\n\nTo learn more about transitions in Headless UI, read the dedicated Transition documentation.\n\nAccessibility notes\nFocus management\n\nWhen the Dialog's open prop is true, the contents of the Dialog will render and focus will be moved inside the Dialog and trapped there. The first focusable element according to DOM order will receive focus, although you can use the initialFocus ref to control which element receives initial focus. Pressing Tab on an open Dialog cycles through all the focusable elements.\n\nMouse interaction\n\nWhen a Dialog is rendered, clicking outside of the DialogPanel will close the Dialog.\n\nNo mouse interaction to open the Dialog is included out-of-the-box, though typically you will wire a <button /> element up with a click handler that toggles the Dialog's open prop to true.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEsc\n\n\t\n\nCloses any open Dialogs\n\n\n\n\nTab\n\n\t\n\nCycles through an open Dialog's contents\n\n\n\n\nShift + Tab\n\n\t\n\nCycles backwards through an open Dialog's contents\n\nOther\n\nWhen a Dialog is open, scroll is locked and the rest of your application UI is hidden from screen readers.\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nDialog\n\nThe main Dialog component.\n\nProp\tDefault\tDescription\nopen\t—\t\nBoolean\n\nWhether the Dialog is open or not.\n\n\ninitialFocus\t—\t\nHTMLElement\n\nA ref to an element that should receive focus first.\n\n\nas\tdiv\t\nString | Component\n\nThe element or component the Dialog should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nEvent\tDescription\nclose\t\n\nEmitted when the Dialog is dismissed (via outside click of the DialogPanel or by pressing the Escape key). Typically used to close the dialog by setting open to false.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialogPanel\n\nThis indicates the panel of your actual Dialog. Clicking outside of this component will emit the close event on the Dialog component.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the DialogPanel should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialogTitle\n\nThis is the title for your Dialog. When this is used, it will set the aria-labelledby on the Dialog.\n\nProp\tDefault\tDescription\nas\th2\t\nString | Component\n\nThe element or component the DialogTitle should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialogDescription\n\nThis is the description for your Dialog. When this is used, it will set the aria-describedby on the Dialog.\n\nProp\tDefault\tDescription\nas\tp\t\nString | Component\n\nThe element or component the DialogDescription should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialogOverlay\n\nAs of Headless UI v1.6, DialogOverlay is deprecated, see the release notes for migration instructions.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the DialogOverlay should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/disclosure",
    "html": "Disclosure\n\nA simple, accessible foundation for building custom UIs that show and hide content, like togglable accordion panels.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nDisclosures are built using the Disclosure, DisclosureButton and DisclosurePanel components.\n\nThe button will automatically open/close the panel when clicked, and all components will receive the appropriate aria-* related attributes like aria-expanded and aria-controls.\n\n<template>\n  <Disclosure>\n    <DisclosureButton class=\"py-2\">\n      Is team pricing available?\n    </DisclosureButton>\n    <DisclosurePanel class=\"text-gray-500\">\n      Yes! You can purchase a license that you can share with your entire team.\n    </DisclosurePanel>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n</script>\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a disclosure is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Disclosure component exposes an open state, which tells you if the disclosure is currently open.\n\n<template>\n\n  <Disclosure v-slot=\"{ open }\">\n    <!-- Use the `open` state to conditionally change the direction of an icon. -->\n    <DisclosureButton class=\"py-2\">\n      <span>Do you offer technical support?</span>\n\n      <ChevronRightIcon :class=\"open && 'rotate-90 transform'\" />\n    </DisclosureButton>\n    <DisclosurePanel>No</DisclosurePanel>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n  import { ChevronRightIcon } from '@heroicons/vue/20/solid'\n</script>\n\n\nFor a complete list of all the available slot props, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Disclosure component renders when the disclosure is open:\n\n<!-- Rendered `Disclosure` -->\n<div data-headlessui-state=\"open\">\n  <button data-headlessui-state=\"open\">Do you offer technical support?</button>\n  <div data-headlessui-state=\"open\">No</div>\n</div>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:*:\n\n<template>\n  <Disclosure>\n    <DisclosureButton class=\"py-2\">\n      <span>Do you offer technical support?</span>\n\n      <ChevronRightIcon class=\"ui-open:rotate-90 ui-open:transform\" />\n    </DisclosureButton>\n    <DisclosurePanel>No</DisclosurePanel>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n  import { ChevronRightIcon } from '@heroicons/vue/20/solid'\n</script>\n\nShowing/hiding the panel\n\nBy default, your DisclosurePanel will be shown/hidden automatically based on the internal open state tracked within the Disclosure component itself.\n\n<template>\n  <Disclosure>\n    <DisclosureButton>Is team pricing available?</DisclosureButton>\n\n    <!--\n      By default, the `DisclosurePanel` will automatically show/hide\n      when the `DisclosureButton` is pressed.\n    -->\n    <DisclosurePanel>\n      Yes! You can purchase a license that you can share with your entire team.\n    </DisclosurePanel>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n</script>\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can pass a static prop to the DisclosurePanel to tell it to always render, and then use the open slot prop to control when the panel is shown/hidden yourself.\n\n<template>\n\n  <Disclosure v-slot=\"{ open }\">\n    <DisclosureButton>Is team pricing available?</DisclosureButton>\n\n\n    <div v-show=\"open\">\n      <!--\n        Using the `static` prop, the `DisclosurePanel` is always\n        rendered and the `open` state is ignored.\n      -->\n\n      <DisclosurePanel static>\n        Yes! You can purchase a license that you can share with your entire\n        team.\n      </DisclosurePanel>\n    </div>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n</script>\n\nClosing disclosures manually\n\nTo close a disclosure manually when clicking a child of its panel, render that child as a DisclosureButton. You can use the :as prop to customize which element is being rendered.\n\n<template>\n  <Disclosure>\n    <DisclosureButton>Open mobile menu</DisclosureButton>\n    <DisclosurePanel>\n\n      <DisclosureButton :as=\"MyLink\" href=\"/home\">Home</DisclosureButton>\n      <!-- ... -->\n    </DisclosurePanel>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n  import MyLink from './MyLink'\n</script>\n\n\nThis is especially useful when using disclosures for things like mobile menus that contain links where you want the disclosure to close when navigating to the next page.\n\nAlternatively, Disclosure and DisclosurePanel expose a close() slot prop which you can use to imperatively close the panel, say after running an async action:\n\n<template>\n  <Disclosure>\n    <DisclosureButton>Terms</DisclosureButton>\n\n    <DisclosurePanel v-slot=\"{ close }\">\n      <button @click=\"accept(close)\">Read and accept</button>\n    </DisclosurePanel>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n\n\n  async function accept(close) {\n    await fetch('/accept-terms', { method: 'POST' })\n    close()\n  }\n</script>\n\n\nBy default the DisclosureButton receives focus after calling close(), but you can change this by passing a ref into close(ref).\n\nTransitions\n\nTo animate the opening/closing of your Disclosure's panel, you can use Vue's built-in <transition> component. All you need to do is wrap your DisclosurePanelin a <transition>, and the transition will be applied automatically.\n\n<template>\n  <Disclosure>\n    <DisclosureButton>Is team pricing available?</DisclosureButton>\n\n    <!-- Use the built-in `transition` component to add transitions. -->\n\n    <transition\n      enter-active-class=\"transition duration-100 ease-out\"\n      enter-from-class=\"transform scale-95 opacity-0\"\n      enter-to-class=\"transform scale-100 opacity-100\"\n      leave-active-class=\"transition duration-75 ease-out\"\n      leave-from-class=\"transform scale-100 opacity-100\"\n      leave-to-class=\"transform scale-95 opacity-0\"\n    >\n      <DisclosurePanel>\n        Yes! You can purchase a license that you can share with your entire\n        team.\n      </DisclosurePanel>\n    </transition>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n</script>\n\n\nIf you'd like to coordinate multiple transitions for different children of your Disclosure, check out the Transition component included in Headless UI.\n\nRendering a different element for a component\n\nDisclosure and its subcomponents each render a default element that is sensible for that component: the Button renders a <button>, Panel renders a <div>. By contrast, the root Disclosure component does not render an element, and instead renders its children directly by default.\n\nThis is easy to change using the as prop, which exists on every component.\n\n<template>\n  <!-- Render a `div` for the root `Disclosure` component -->\n\n  <Disclosure as=\"div\">\n    <!-- Don't render any element (only children) for the `DisclosureButton` component -->\n\n    <DisclosureButton as=\"template\">\n      <button>What languages do you support?</button>\n    </DisclosureButton>\n\n    <!-- Render a `ul` for the `DisclosurePanel` component -->\n\n    <DisclosurePanel as=\"ul\">\n      <li>HTML</li>\n      <li>CSS</li>\n      <li>JavaScript</li>\n    </DisclosurePanel>\n  </Disclosure>\n</template>\n\n<script setup>\n  import {\n    Disclosure,\n    DisclosureButton,\n    DisclosurePanel,\n  } from '@headlessui/vue'\n</script>\n\nAccessibility notes\nMouse interaction\n\nClicking a DisclosureButton toggles the Disclosure's panel open and closed.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\nor\nSpace when a DisclosureButton is focused.\n\n\t\n\nToggles panel\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nDisclosure\n\nThe main Disclosure component.\n\nProp\tDefault\tDescription\nas\ttemplate\t\nString | Component\n\nThe element or component the Disclosure should render as.\n\n\ndefaultOpen\tfalse\t\nBoolean\n\nWhether or not the Disclosure component should be open by default.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the disclosure is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the disclosure and refocuses DisclosureButton. Optionally pass in a ref or HTMLElement to focus that element instead.\n\nDisclosureButton\n\nThe trigger component that toggles a Disclosure.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the DisclosureButton should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the disclosure is open.\n\nDisclosurePanel\n\nThis component contains the contents of your Disclosure.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the DisclosurePanel should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the disclosure is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the disclosure and refocuses DisclosureButton. Optionally pass in a ref or HTMLElement to focus that element instead.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/switch",
    "html": "Switch (Toggle)\n\nSwitches are a pleasant interface for toggling a value between two states, and offer the same semantics and keyboard navigation as native checkbox elements.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nSwitches are built using the Switch component, which takes in a ref via the v-model prop. You can toggle your Switch by clicking directly on the component, or by pressing the spacebar while its focused.\n\nToggling the switch updates your ref to its negated value.\n\n<template>\n  <Switch\n    v-model=\"enabled\"\n    :class=\"enabled ? 'bg-blue-600' : 'bg-gray-200'\"\n    class=\"relative inline-flex h-6 w-11 items-center rounded-full\"\n  >\n    <span class=\"sr-only\">Enable notifications</span>\n    <span\n      :class=\"enabled ? 'translate-x-6' : 'translate-x-1'\"\n      class=\"inline-block h-4 w-4 transform rounded-full bg-white transition\"\n    />\n  </Switch>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch } from '@headlessui/vue'\n\n  const enabled = ref(false)\n</script>\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which switch option is currently selected, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Switch component exposes an checked state, which tells you if the switch is currently checked or not.\n\n<template>\n\n  <!-- Use the `checked` state to conditionally style the button. -->\n  <Switch v-model=\"enabled\" as=\"template\" v-slot=\"{ checked }\">\n    <button\n      class=\"relative inline-flex h-6 w-11 items-center rounded-full\"\n\n      :class=\"checked ? 'bg-blue-600' : 'bg-gray-200'\"\n    >\n      <span class=\"sr-only\">Enable notifications</span>\n      <span\n\n        :class=\"checked ? 'translate-x-6' : 'translate-x-1'\"\n        class=\"inline-block h-4 w-4 transform rounded-full bg-white transition\"\n      />\n    </button>\n  </Switch>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch } from '@headlessui/vue'\n\n  const enabled = ref(false)\n</script>\n\n\nFor a complete list of all the available slot props, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Switch component renders when the switch is checked:\n\n<!-- Rendered `Switch` -->\n<button data-headlessui-state=\"checked\"></button>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-checked:*:\n\n<template>\n  <Switch\n    v-model=\"enabled\"\n\n    class=\"relative inline-flex h-6 w-11 items-center rounded-full ui-checked:bg-blue-600 ui-not-checked:bg-gray-200\"\n  >\n    <span class=\"sr-only\">Enable notifications</span>\n    <span\n\n      class=\"inline-block h-4 w-4 transform rounded-full bg-white transition ui-checked:translate-x-6 ui-not-checked:translate-x-1\"\n    />\n  </Switch>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch } from '@headlessui/vue'\n\n  const enabled = ref(false)\n</script>\n\nUsing a custom label\n\nBy default, a Switch renders a button as well as whatever children you pass into it. This can make it harder to implement certain UIs, since the children will be nested within the button.\n\nIn these situations, you can use the SwitchLabel component for more flexibility.\n\nThis example demonstrates how to use the SwitchGroup, Switch and SwitchLabel components to render a label as a sibling to the button. Note that SwitchLabel works alongside a Switch component, and they both must be rendered within a parent SwitchGroup component.\n\n<template>\n\n  <SwitchGroup>\n    <div class=\"flex items-center\">\n\n      <SwitchLabel class=\"mr-4\">Enable notifications</SwitchLabel>\n      <Switch\n        v-model=\"enabled\"\n        :class='enabled ? \"bg-blue-600\" : \"bg-gray-200\"'\n        class=\"relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2\"\n      >\n        <span\n          :class='enabled ? \"translate-x-6\" : \"translate-x-1\"'\n          class=\"inline-block h-4 w-4 transform rounded-full bg-white transition-transform\"\n        />\n      </Switch>\n    </div>\n\n  </SwitchGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch, SwitchGroup, SwitchLabel } from '@headlessui/vue'\n\n  const enabled = ref(false)\n</script>\n\n\nBy default, clicking a SwitchLabel will toggle the Switch, just like labels in native HTML checkboxes do. If you'd like to make the label non-clickable (which you might if it doesn't make sense for your design), you can add a passive prop to the SwitchLabel component:\n\n<template>\n  <SwitchGroup>\n\n    <SwitchLabel passive>Enable notifications</SwitchLabel>\n    <Switch v-model=\"enabled\">\n      <!-- ... -->\n    </Switch>\n  </SwitchGroup>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch, SwitchGroup, SwitchLabel } from '@headlessui/vue'\n\n  const enabled = ref(false)\n</script>\n\nUsing with HTML forms\n\nIf you add the name prop to your switch, a hidden input element will be rendered and kept in sync with the switch state.\n\n<template>\n  <form action=\"/notification-settings\" method=\"post\">\n\n    <Switch v-model=\"enabled\" name=\"notifications\">\n      <!-- ... -->\n    </Switch>\n  </form>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch } from '@headlessui/vue'\n\n  const enabled = ref(true)\n</script>\n\n\nThis lets you use a switch inside a native HTML <form> and make traditional form submissions as if your switch was a native HTML form control.\n\nBy default, the value will be 'on' when the switch is checked, and not present when the switch is unchecked.\n\n<input type=\"hidden\" name=\"notifications\" value=\"on\" />\n\nYou can customize the value if needed by using the value prop:\n\n<template>\n  <form action=\"/accounts\" method=\"post\">\n\n    <Switch v-model=\"enabled\" name=\"terms\" value=\"accept\">\n      <!-- ... -->\n    </Switch>\n  </form>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch } from '@headlessui/vue'\n\n  const enabled = ref(true)\n</script>\n\n\nThe hidden input will then use your custom value when the switch is checked:\n\n<input type=\"hidden\" name=\"terms\" value=\"accept\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultChecked prop to the Switch instead of a checked prop, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\nYou can access the current state via the checked slot prop on the Switch component.\n\n<template>\n  <form action=\"/accounts\" method=\"post\">\n    <Switch\n      name=\"terms-of-service\"\n\n      :defaultChecked=\"true\"\n      as=\"template\"\n      v-slot=\"{ checked }\"\n    >\n      <button\n        :class=\"checked ? 'bg-blue-600' : 'bg-gray-200'\"\n        class=\"relative inline-flex h-6 w-11 items-center rounded-full\"\n      >\n        <span class=\"sr-only\">Enable notifications</span>\n        <span\n          :class=\"checked ? 'translate-x-6' : 'translate-x-1'\"\n          class=\"inline-block h-4 w-4 transform rounded-full bg-white transition\"\n        />\n      </button>\n    </Switch>\n    <button>Submit</button>\n  </form>\n</template>\n\n<script setup>\n  import { Switch } from '@headlessui/vue'\n</script>\n\n\nThis can simplify your code when using the listbox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny @update:modelValue prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nTransitions\n\nBecause Switches are typically always rendered to the DOM (rather than being mounted/unmounted like other components), simple CSS transitions are often enough to animate your Switch:\n\n<template>\n  <Switch v-model=\"enabled\">\n    <!-- Transition the switch's knob on state change -->\n    <span\n\n      :class=\"enabled ? 'translate-x-9' : 'translate-x-0'\"\n      class=\"transform transition duration-200 ease-in-out\"\n    />\n    <!-- ... -->\n  </Switch>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import { Switch } from '@headlessui/vue'\n\n  const enabled = ref(false)\n</script>\n\nAccessibility notes\nLabels\n\nBy default, the children of a Switch will be used as the label for screen readers. If you're using SwitchLabel, the content of your Switch component will be ignored by assistive technologies.\n\nMouse interaction\n\nClicking a Switch or a SwitchLabel toggles the Switch on and off.\n\nKeyboard interaction\nCommand\tDescription\n\n\nSpace when a Switch is focused\n\n\t\n\nToggles the Switch\n\n\n\n\nEnter when in a form\n\n\t\n\nSubmits the form\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nSwitch\n\nThe main Switch component.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Switch should render as.\n\n\nv-model\t—\t\nBoolean\n\nWhether or not the switch is checked.\n\n\ndefaultChecked\t—\t\nT\n\nThe default checked value when using as an uncontrolled component.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\n\nvalue\t—\t\nString\n\nThe value used when using this component inside a form, if it is checked.\n\nSlot Prop\tDescription\nchecked\t\n\nBoolean\n\nWhether or not the switch is checked.\n\nSwitchLabel\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the SwitchLabel should render as.\n\n\npassive\tfalse\t\nBoolean\n\nWhen true, clicking the label won't toggle the Switch.\n\nSwitchDescription\nProp\tDefault\tDescription\nas\tp\t\nString | Component\n\nThe element or component the Switch.Description should render as.\n\nSwitchGroup\nProp\tDefault\tDescription\nas\ttemplate\t\nString | Component\n\nThe element or component the SwitchGroup should render as.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/combobox",
    "html": "Combobox (Autocomplete)\n\nComboboxes are the foundation of accessible autocompletes and command palettes for your app, complete with robust support for keyboard navigation.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nComboboxes are built using the Combobox, ComboboxInput, ComboboxButton, ComboboxOptions, ComboboxOption and ComboboxLabel components.\n\nThe ComboboxInput will automatically open/close the ComboboxOptions when searching.\n\nYou are completely in charge of how you filter the results, whether it be with a fuzzy search library client-side or by making server-side requests to an API. In this example we will keep the logic simple for demo purposes.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput @change=\"query = $event.target.value\" />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    'Durward Reynolds',\n    'Kenton Towne',\n    'Therese Wunsch',\n    'Benedict Kessler',\n    'Katelyn Rohan',\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nIn the previous example we used a list of string values as data, but you can also use objects with additional information. The only caveat is that you have to provide a displayValue to the input. This is important so that a string based version of your object can be rendered in the ComboboxInput.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n\n      :displayValue=\"(person) => person.name\"\n    />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n        :disabled=\"person.unavailable\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds', unavailable: false },\n    { id: 2, name: 'Kenton Towne', unavailable: false },\n    { id: 3, name: 'Therese Wunsch', unavailable: false },\n    { id: 4, name: 'Benedict Kessler', unavailable: true },\n    { id: 5, name: 'Katelyn Rohan', unavailable: false },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which combobox option is currently selected, whether a popover is open or closed, or which item in a combobox is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the ComboboxOption component exposes an active state, which tells you if the item is currently focused via the mouse or keyboard.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n    <ComboboxOptions>\n      <!-- Use the `active` state to conditionally style the active option. -->\n      <!-- Use the `selected` state to conditionally style the selected option. -->\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n        as=\"template\"\n\n        v-slot=\"{ active, selected }\"\n      >\n        <li\n          :class=\"{\n\n            'bg-blue-500 text-white': active,\n            'bg-white text-black': !active,\n          }\"\n        >\n\n          <CheckIcon v-show=\"selected\" />\n          {{ person.name }}\n        </li>\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n  import { CheckIcon } from '@heroicons/vue/20/solid'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nFor a complete list of all the available slot props, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the ComboboxOptions component with some child ComboboxOption components renders when the combobox is open and the second item is active:\n\n<!-- Rendered `ComboboxOptions` -->\n<ul data-headlessui-state=\"open\">\n  <li data-headlessui-state=\"\">Wade Cooper</li>\n  <li data-headlessui-state=\"active selected\">Arlene Mccoy</li>\n  <li data-headlessui-state=\"\">Devon Webb</li>\n</ul>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n\n        class=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n      >\n\n        <CheckIcon class=\"hidden ui-selected:block\" />\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n  import { CheckIcon } from '@heroicons/vue/20/solid'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nBinding objects as values\n\nUnlike native HTML form controls which only allow you to provide strings as values, Headless UI supports binding complex objects as well.\n\n<template>\n\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n\n        :value=\"person\"\n        :disabled=\"person.unavailable\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds', unavailable: false },\n    { id: 2, name: 'Kenton Towne', unavailable: false },\n    { id: 3, name: 'Therese Wunsch', unavailable: false },\n    { id: 4, name: 'Benedict Kessler', unavailable: true },\n    { id: 5, name: 'Katelyn Rohan', unavailable: false },\n  ]\n  const selectedPerson = ref(people[1])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nWhen binding objects as values, it's important to make sure that you use the same instance of the object as both the value of the Combobox as well as the corresponding ComboboxOption, otherwise they will fail to be equal and cause the combobox to behave incorrectly.\n\nTo make it easier to work with different instances of the same object, you can use the by prop to compare the objects by a particular field instead of comparing object identity:\n\n<template>\n  <Combobox\n    :modelValue=\"modelValue\"\n    @update:modelValue=\"value => emit('update:modelValue', value)\"\n\n    by=\"id\"\n  >\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(department) => department.name\"\n    />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"department in filteredDepartments\"\n        :key=\"department.id\"\n        :value=\"department\"\n      >\n        {{ department.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const props = defineProps({ modelValue: Object })\n  const emit = defineEmits(['update:modelValue'])\n\n  const departments = [\n    { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n    { id: 2, name: 'HR', contact: 'Kenton Towne' },\n    { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n    { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n    { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n  ]\n  const query = ref('')\n\n  const filteredDepartments = computed(() =>\n    query.value === ''\n      ? departments\n      : departments.filter((department) => {\n          return department.name\n            .toLowerCase()\n            .includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nYou can also pass your own comparison function to the by prop if you'd like complete control over how objects are compared:\n\n<template>\n  <Combobox\n    :modelValue=\"modelValue\"\n    @update:modelValue=\"value => emit('update:modelValue', value)\"\n\n    :by=\"compareDepartments\"\n  >\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(department) => department.name\"\n    />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"department in departments\"\n        :key=\"department.id\"\n        :value=\"department\"\n      >\n        {{ department.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const props = defineProps({ modelValue: Object })\n  const emit = defineEmits(['update:modelValue'])\n\n\n  function compareDepartments(a, b) {\n    return a.name.toLowerCase() === b.name.toLowerCase()\n  }\n\n  const departments = [\n    { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n    { id: 2, name: 'HR', contact: 'Kenton Towne' },\n    { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n    { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n    { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n  ]\n  const query = ref('')\n\n  const filteredDepartments = computed(() =>\n    query.value === ''\n      ? departments\n      : departments.filter((department) => {\n          return department.name\n            .toLowerCase()\n            .includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nSelecting multiple values\n\nThe Combobox component allows you to select multiple values. You can enable this by providing an array of values instead of a single value.\n\n<template>\n\n  <Combobox v-model=\"selectedPeople\" multiple>\n    <ul v-if=\"selectedPeople.length > 0\">\n      <li v-for=\"person in selectedPeople\" :key=\"person.id\">\n        {{ person.name }}\n      </li>\n    </ul>\n    <ComboboxInput />\n    <ComboboxOptions>\n      <ComboboxOption v-for=\"person in people\" :key=\"person.id\" :value=\"person\">\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPeople = ref([people[0], people[1]])\n</script>\n\n\nThis will keep the combobox open when you are selecting options, and choosing an option will toggle it in place.\n\nYour v-model binding will be updated with an array containing all selected options any time an option is added or removed.\n\nUsing a custom label\n\nBy default the Combobox will use the input contents as the label for screenreaders. If you'd like more control over what is announced to assistive technologies, use the ComboboxLabel component.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n\n    <ComboboxLabel>Assignee:</ComboboxLabel>\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxLabel,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nUsing with HTML forms\n\nIf you add the name prop to your combobox, hidden input elements will be rendered and kept in sync with your selected value.\n\n<template>\n  <form action=\"/projects/1/assignee\" method=\"post\">\n\n    <Combobox v-model=\"selectedPerson\" name=\"assignee\">\n      <ComboboxInput\n        @change=\"query = $event.target.value\"\n        :displayValue=\"(person) => person.name\"\n      />\n      <ComboboxOptions>\n        <ComboboxOption\n          v-for=\"person in filteredPeople\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ComboboxOption>\n      </ComboboxOptions>\n    </Combobox>\n    <button>Submit</button>\n  </form>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nThis lets you use a combobox inside a native HTML <form> and make traditional form submissions as if your combobox was a native HTML form control.\n\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like objects will be encoded into multiple inputs using a square bracket notation for the names:\n\n<input type=\"hidden\" name=\"assignee[id]\" value=\"1\" />\n<input type=\"hidden\" name=\"assignee[name]\" value=\"Durward Reynolds\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultValue prop to the Combobox instead of a value, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\n<template>\n  <form action=\"/projects/1/assignee\" method=\"post\">\n\n    <Combobox name=\"assignee\" :defaultValue=\"people[0]\">\n      <ComboboxInput\n        @change=\"query = $event.target.value\"\n        :displayValue=\"(person) => person.name\"\n      />\n      <ComboboxOptions>\n        <ComboboxOption\n          v-for=\"person in filteredPeople\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ComboboxOption>\n      </ComboboxOptions>\n    </Combobox>\n    <button>Submit</button>\n  </form>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nThis can simplify your code when using the combobox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny @update:modelValue prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nAllowing custom values\n\nYou can allow users to enter their own value that doesn't exist in the list by including a dynamic ComboboxOption based on the query value.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n    <ComboboxOptions>\n\n      <ComboboxOption v-if=\"queryPerson\" :value=\"queryPerson\">\n        Create \"{{ query }}\"\n      </ComboboxOption>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n\n  const queryPerson = computed(() => {\n    return query.value === '' ? null : { id: null, name: query.value }\n  })\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nRendering the active option on the side\n\nDepending on what you're building it can sometimes make sense to render additional information about the active option outside of the <ComboboxOptions>. For example, a preview of the active option within the context of a command palette. In these situations you can read the activeOption slot prop argument to access this information.\n\n<template>\n\n  <Combobox v-model=\"selectedPerson\" v-slot=\"{ activeOption }\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n\n\n    <div v-if=\"activeOption\">\n      The current active user is: {{ activeOption.name }}\n    </div>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nThe activeOption will be the value of the current active ComboboxOption.\n\nShowing/hiding the combobox\n\nBy default, your ComboboxOptions instance will be shown/hidden automatically based on the internal open state tracked within the Combobox component itself.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n\n    <!--\n      By default, the `ComboboxOptions` will automatically show/hide when\n      typing in the `ComboboxInput`, or when pressing the `ComboboxButton`.\n    -->\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can add a static prop to the ComboboxOptions instance to tell it to always render, and inspect the open slot prop provided by the Combobox to control which element is shown/hidden yourself.\n\n<template>\n\n  <Combobox v-model=\"selectedPerson\" v-slot=\"{ open }\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n\n\n    <div v-show=\"open\">\n      <!--\n        Using the `static` prop, the `ComboboxOptions` are always\n        rendered and the `open` state is ignored.\n      -->\n\n      <ComboboxOptions static>\n        <ComboboxOption\n          v-for=\"person in filteredPeople\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ComboboxOption>\n      </ComboboxOptions>\n    </div>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nDisabling an option\n\nUse the disabled prop to disable a ComboboxOption. This will make it unselectable via mouse and keyboard, and it will be skipped when pressing the up/down arrows.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n\n    <ComboboxOptions>\n      <!-- Disabled options will be skipped by keyboard navigation. -->\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n\n        :disabled=\"person.unavailable\"\n      >\n        <span :class='{ \"opacity-75\": person.unavailable }'>\n          {{ person.name }}\n        </span>\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds', unavailable: true },\n    { id: 2, name: 'Kenton Towne', unavailable: false },\n    { id: 3, name: 'Therese Wunsch', unavailable: false },\n    { id: 4, name: 'Benedict Kessler', unavailable: true },\n    { id: 5, name: 'Katelyn Rohan', unavailable: false },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nAllowing empty values\n\nBy default, once you've selected a value in a combobox there is no way to clear the combobox back to an empty value — when you clear the input and tab away, the value returns to the previously selected value.\n\nIf you want to support empty values in your combobox, use the nullable prop.\n\n<template>\n\n  <Combobox v-model=\"selectedPerson\" nullable>\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n\n      :displayValue=\"(person) => person?.name\"\n    />\n\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds', unavailable: true },\n    { id: 2, name: 'Kenton Towne', unavailable: false },\n    { id: 3, name: 'Therese Wunsch', unavailable: false },\n    { id: 4, name: 'Benedict Kessler', unavailable: true },\n    { id: 5, name: 'Katelyn Rohan', unavailable: false },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nWhen the nullable prop is used, clearing the input and navigating away from the element will update your v-model binding and invoke your displayValue callback with null.\n\nThis prop doesn't do anything when allowing multiple values because options are toggled on and off, resulting in an empty array (rather than null) if nothing is selected.\n\nTransitions\n\nTo animate the opening/closing of your combobox, you can use Vue's built-in <transition> component. All you need to do is wrap your ComboboxOptions instance in a <transition>, and the transition will be applied automatically.\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n\n    <!-- Use Vue's built-in `transition` component to add transitions. -->\n\n    <transition\n      enter-active-class=\"transition duration-100 ease-out\"\n      enter-from-class=\"transform scale-95 opacity-0\"\n      enter-to-class=\"transform scale-100 opacity-100\"\n      leave-active-class=\"transition duration-75 ease-out\"\n      leave-from-class=\"transform scale-100 opacity-100\"\n      leave-to-class=\"transform scale-95 opacity-0\"\n    >\n      <ComboboxOptions>\n        <ComboboxOption\n          v-for=\"person in filteredPeople\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ComboboxOption>\n      </ComboboxOptions>\n\n    </transition>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nIf you'd like to coordinate multiple transitions for different children of your Combobox, check out the Transition component included in Headless UI.\n\nRendering a different element for a component\n\nBy default, the Combobox and its subcomponents each render a default element that is sensible for that component.\n\nFor example, ComboboxLabel renders a label by default, ComboboxInput renders an input, ComboboxButton renders a button, ComboboxOptions renders a ul, and ComboboxOption renders a li. By contrast, Combobox does not render an element, and instead renders its children directly.\n\nThis is easy to change using the as prop, which exists on every component.\n\n<template>\n  <!-- Render a `div` instead of nothing -->\n\n  <Combobox as=\"div\" v-model=\"selectedPerson\">\n    <ComboboxInput\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    />\n\n    <!-- Render a `div` instead of a `ul` -->\n\n    <ComboboxOptions as=\"div\">\n      <!-- Render a `span` instead of a `li` -->\n      <ComboboxOption\n\n        as=\"span\"\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\n\nTo tell an element to render its children directly with no wrapper element, use as=\"template\".\n\n<template>\n  <Combobox v-model=\"selectedPerson\">\n    <!-- Render children directly instead of an `input` -->\n    <ComboboxInput\n\n      as=\"template\"\n      @change=\"query = $event.target.value\"\n      :displayValue=\"(person) => person.name\"\n    >\n      <input />\n    </ComboboxInput>\n\n    <ComboboxOptions>\n      <ComboboxOption\n        v-for=\"person in filteredPeople\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ComboboxOption>\n    </ComboboxOptions>\n  </Combobox>\n</template>\n\n<script setup>\n  import { ref, computed } from 'vue'\n  import {\n    Combobox,\n    ComboboxInput,\n    ComboboxOptions,\n    ComboboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n  const query = ref('')\n\n  const filteredPeople = computed(() =>\n    query.value === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.value.toLowerCase())\n        })\n  )\n</script>\n\nAccessibility notes\nFocus management\n\nWhen a Combobox is toggled open, the ComboboxInput stays focused.\n\nThe ComboboxButton is ignored for the default tab flow, this means that pressing Tab in the ComboboxInput will skip passed the ComboboxButton.\n\nMouse interaction\n\nClicking a ComboboxButton toggles the options list open and closed. Clicking anywhere outside of the options list will close the combobox.\n\nKeyboard interaction\nCommand\tDescription\n\n\nArrowDown\n,\nor\nArrowUp\n when ComboboxInput is focused\n\n\t\n\nOpens combobox and focuses the selected item\n\n\n\n\nEnter\n,\nSpace\n,\nArrowDown\n,\nor\nArrowUp\n when ComboboxButton is focused\n\n\t\n\nOpens combobox, focuses the input and selects the selected item\n\n\n\n\nEsc when combobox is open\n\n\t\n\nCloses combobox and restores the selected item in the input field\n\n\n\n\nArrowDown\nor\nArrowUp\n when combobox is open\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nHome\nor\nPageUp when combobox is open\n\n\t\n\nFocuses first non-disabled item\n\n\n\n\nEnd\nor\nPageDown when combobox is open\n\n\t\n\nFocuses last non-disabled item\n\n\n\n\nEnter when combobox is open\n\n\t\n\nSelects the current item\n\n\n\n\nEnter when combobox is closed and in a form\n\n\t\n\nSubmits the form\n\n\n\n\nTab when combobox is open\n\n\t\n\nSelects the current active item and closes the combobox\n\n\n\n\nA–Z\nor\na–z when combobox is open\n\n\t\n\nCalls the onChange which allows you to filter the list\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nCombobox\n\nThe main Combobox component.\n\nProp\tDefault\tDescription\nas\ttemplate\t\nString | Component\n\nThe element or component the Combobox should render as.\n\n\nv-model\t—\t\nT\n\nThe selected value.\n\n\ndefaultValue\t—\t\nT\n\nThe default value when using as an uncontrolled component.\n\n\nby\t—\t\nkeyof T | ((a: T, z: T) => boolean)\n\nUse this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.\n\n\ndisabled\tfalse\t\nBoolean\n\nUse this to disable the entire combobox component & related children.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\n\nnullable\t—\t\nBoolean\n\nWhether you can clear the combobox or not.\n\n\nmultiple\tfalse\t\nBoolean\n\nWhether multiple options can be selected or not.\n\nSlot Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the combobox is disabled.\n\n\nactiveIndex\t\n\nNumber | null\n\nThe index of the active option or null if none is active.\n\n\nactiveOption\t\n\nT | null\n\nThe active option or null if none is active.\n\nComboboxInput\n\nThe Combobox's input.\n\nProp\tDefault\tDescription\nas\tinput\t\nString | Component\n\nThe element or component the ComboboxInput should render as.\n\n\ndisplayValue\t—\t\n(item: T) => string\n\nThe string representation of your value.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Combobox is disabled.\n\nComboboxButton\n\nThe Combobox's button.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the ComboboxButton should render as.\n\nSlot Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Combobox is disabled.\n\nComboboxLabel\n\nA label that can be used for more control over the text your Combobox will announce to screenreaders. Its id attribute will be automatically generated and linked to the root Combobox component via the aria-labelledby attribute.\n\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the ComboboxLabel should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Combobox is disabled.\n\nComboboxOptions\n\nThe component that directly wraps the list of options in your custom Combobox.\n\nProp\tDefault\tDescription\nas\tul\t\nString | Component\n\nThe element or component the ComboboxOptions should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\n\nhold\tfalse\t\nboolean\n\nWhether or not the active option should stay active even when the mouse leaves the active option.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\nComboboxOption\n\nUsed to wrap each item within your Combobox.\n\nProp\tDefault\tDescription\nvalue\t—\t\nT\n\nThe option value.\n\n\nas\tli\t\nString | Component\n\nThe element or component the ComboboxOption should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the option should be disabled for keyboard navigation and ARIA purposes.\n\nSlot Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the option is the active/focused option.\n\n\nselected\t\n\nBoolean\n\nWhether or not the option is the selected option.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the option is the disabled for keyboard navigation and ARIA purposes.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/listbox",
    "html": "Listbox (Select)\n\nListboxes are a great foundation for building custom, accessible select menus for your app, complete with robust support for keyboard navigation.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nListboxes are built using the Listbox, ListboxButton, ListboxOptions, ListboxOption and ListboxLabel components.\n\nThe ListboxButton will automatically open/close the ListboxOptions when clicked, and when the menu is open, the list of items receives focus and is automatically navigable via the keyboard.\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n    <ListboxOptions>\n      <ListboxOption\n        v-for=\"person in people\"\n        :key=\"person.id\"\n        :value=\"person\"\n        :disabled=\"person.unavailable\"\n      >\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds', unavailable: false },\n    { id: 2, name: 'Kenton Towne', unavailable: false },\n    { id: 3, name: 'Therese Wunsch', unavailable: false },\n    { id: 4, name: 'Benedict Kessler', unavailable: true },\n    { id: 5, name: 'Katelyn Rohan', unavailable: false },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a listbox is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the ListboxOption component exposes an active state, which tells you if the item is currently focused via the mouse or keyboard.\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n    <ListboxOptions>\n      <!-- Use the `active` state to conditionally style the active option. -->\n      <!-- Use the `selected` state to conditionally style the selected option. -->\n      <ListboxOption\n        v-for=\"person in people\"\n        :key=\"person.id\"\n        :value=\"person\"\n        as=\"template\"\n\n        v-slot=\"{ active, selected }\"\n      >\n        <li\n          :class=\"{\n\n            'bg-blue-500 text-white': active,\n            'bg-white text-black': !active,\n          }\"\n        >\n\n          <CheckIcon v-show=\"selected\" />\n          {{ person.name }}\n        </li>\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n  import { CheckIcon } from '@heroicons/vue/20/solid'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\n\nFor a complete list of all the available slot props, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the ListboxOptions component with some child ListboxOption components renders when the listbox is open and the second item is active:\n\n<!-- Rendered `ListboxOptions` -->\n<ul data-headlessui-state=\"open\">\n  <li data-headlessui-state=\"\">Wade Cooper</li>\n  <li data-headlessui-state=\"active selected\">Arlene Mccoy</li>\n  <li data-headlessui-state=\"\">Devon Webb</li>\n</ul>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n    <ListboxOptions>\n      <ListboxOption\n        v-for=\"person in people\"\n        :key=\"person.id\"\n        :value=\"person\"\n\n        class=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n      >\n\n        <CheckIcon class=\"hidden ui-selected:block\" />\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n  import { CheckIcon } from '@heroicons/vue/20/solid'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\nBinding objects as values\n\nUnlike native HTML form controls which only allow you to provide strings as values, Headless UI supports binding complex objects as well.\n\n<template>\n\n  <Listbox v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n    <ListboxOptions>\n      <ListboxOption\n        v-for=\"person in people\"\n        :key=\"person.id\"\n\n        :value=\"person\"\n        :disabled=\"person.unavailable\"\n      >\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds', unavailable: false },\n    { id: 2, name: 'Kenton Towne', unavailable: false },\n    { id: 3, name: 'Therese Wunsch', unavailable: false },\n    { id: 4, name: 'Benedict Kessler', unavailable: true },\n    { id: 5, name: 'Katelyn Rohan', unavailable: false },\n  ]\n  const selectedPerson = ref(people[1])\n</script>\n\n\nWhen binding objects as values, it's important to make sure that you use the same instance of the object as both the value of the Listbox as well as the corresponding ListboxOption, otherwise they will fail to be equal and cause the listbox to behave incorrectly.\n\nTo make it easier to work with different instances of the same object, you can use the by prop to compare the objects by a particular field instead of comparing object identity:\n\n<template>\n  <Listbox\n    :modelValue=\"modelValue\"\n    @update:modelValue=\"value => emit('update:modelValue', value)\"\n\n    by=\"id\"\n  >\n    <ListboxButton>{{ modelValue.name }}</ListboxButton>\n    <ListboxOptions>\n      <ListboxOption\n        v-for=\"department in departments\"\n        :key=\"department.id\"\n        :value=\"department\"\n      >\n        {{ department.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const props = defineProps({ modelValue: Object })\n  const emit = defineEmits(['update:modelValue'])\n\n  const departments = [\n    { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n    { id: 2, name: 'HR', contact: 'Kenton Towne' },\n    { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n    { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n    { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n  ]\n</script>\n\n\nYou can also pass your own comparison function to the by prop if you'd like complete control over how objects are compared:\n\n<template>\n  <Listbox\n    :modelValue=\"modelValue\"\n    @update:modelValue=\"value => emit('update:modelValue', value)\"\n\n    :by=\"compareDepartments\"\n  >\n    <ListboxButton>{{ modelValue.name }}</ListboxButton>\n    <ListboxOptions>\n      <ListboxOption\n        v-for=\"department in departments\"\n        :key=\"department.id\"\n        :value=\"department\"\n      >\n        {{ department.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const props = defineProps({ modelValue: Object })\n  const emit = defineEmits(['update:modelValue'])\n\n\n  function compareDepartments(a, b) {\n    return a.name.toLowerCase() === b.name.toLowerCase()\n  }\n\n  const departments = [\n    { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n    { id: 2, name: 'HR', contact: 'Kenton Towne' },\n    { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n    { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n    { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n  ]\n</script>\n\nSelecting multiple values\n\nTo allow selecting multiple values in your listbox, use the multiple prop and pass an array to v-model instead of a single option.\n\n<template>\n\n  <Listbox v-model=\"selectedPeople\" multiple>\n    <ListboxButton>\n      {{ selectedPeople.map((person) => person.name).join(', ') }}\n    </ListboxButton>\n    <ListboxOptions>\n      <ListboxOption v-for=\"person in people\" :key=\"person.id\" :value=\"person\">\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n\n  const selectedPeople = ref([people[0], people[1]])\n</script>\n\n\nThis will keep the listbox open when you are selecting options, and choosing an option will toggle it in place.\n\nYour v-model binding will be updated with an array containing all selected options any time an option is added or removed.\n\nUsing a custom label\n\nBy default the Listbox will use the button contents as the label for screenreaders. If you'd like more control over what is announced to assistive technologies, use the ListboxLabel component.\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n\n    <ListboxLabel>Assignee:</ListboxLabel>\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n    <ListboxOptions>\n      <ListboxOption v-for=\"person in people\" :key=\"person.id\" :value=\"person\">\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxLabel,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\nUsing with HTML forms\n\nIf you add the name prop to your listbox, hidden input elements will be rendered and kept in sync with your selected value.\n\n<template>\n  <form action=\"/projects/1/assignee\" method=\"post\">\n\n    <Listbox v-model=\"selectedPerson\" name=\"assignee\">\n      <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n      <ListboxOptions>\n        <ListboxOption\n          v-for=\"person in people\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ListboxOption>\n      </ListboxOptions>\n    </Listbox>\n    <button>Submit</button>\n  </form>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\n\nThis lets you use a listbox inside a native HTML <form> and make traditional form submissions as if your listbox was a native HTML form control.\n\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like objects will be encoded into multiple inputs using a square bracket notation for the names:\n\n<input type=\"hidden\" name=\"assignee[id]\" value=\"1\" />\n<input type=\"hidden\" name=\"assignee[name]\" value=\"Durward Reynolds\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultValue prop to the Listbox instead of a value, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\nYou can access the currently selected option via the value slot prop on the Listbox and ListboxButton components.\n\n<template>\n  <form action=\"/projects/1/assignee\" method=\"post\">\n\n    <Listbox name=\"assignee\" :defaultValue=\"people[0]\">\n      <ListboxButton v-slot=\"{ value }\">{{ value.name }}</ListboxButton>\n      <ListboxOptions>\n        <ListboxOption\n          v-for=\"person in people\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ListboxOption>\n      </ListboxOptions>\n    </Listbox>\n    <button>Submit</button>\n  </form>\n</template>\n\n<script setup>\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n</script>\n\n\nThis can simplify your code when using the listbox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny @update:modelValue prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nShowing/hiding the listbox\n\nBy default, your ListboxOptions instance will be shown/hidden automatically based on the internal open state tracked within the Listbox component itself.\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n\n    <!--\n      By default, the `ListboxOptions` will automatically show/hide\n      when the `ListboxButton` is pressed.\n    -->\n    <ListboxOptions>\n      <ListboxOption v-for=\"person in people\" :key=\"person.id\" :value=\"person\">\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { name: 'Durward Reynolds' },\n    { name: 'Kenton Towne' },\n    { name: 'Therese Wunsch' },\n    { name: 'Benedict Kessler' },\n    { name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can add a static prop to the ListboxOptions instance to tell it to always render, and inspect the open slot prop provided by the Listbox to control which element is shown/hidden yourself.\n\n<template>\n\n  <Listbox v-model=\"selectedPerson\" v-slot=\"{ open }\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n\n\n    <div v-show=\"open\">\n      <!--\n        Using the `static` prop, the `ListboxOptions` are always\n        rendered and the `open` state is ignored.\n      -->\n\n      <ListboxOptions static>\n        <ListboxOption\n          v-for=\"person in people\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ListboxOption>\n      </ListboxOptions>\n    </div>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { name: 'Durward Reynolds' },\n    { name: 'Kenton Towne' },\n    { name: 'Therese Wunsch' },\n    { name: 'Benedict Kessler' },\n    { name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\nDisabling an option\n\nUse the disabled prop to disable a ListboxOption. This will make it unselectable via mouse and keyboard, and it will be skipped when pressing the up/down arrows.\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n\n    <ListboxOptions>\n      <!-- Disabled options will be skipped by keyboard navigation. -->\n      <ListboxOption\n        v-for=\"person in people\"\n        :key=\"person.name\"\n        :value=\"person\"\n\n        :disabled=\"person.unavailable\"\n      >\n        <span :class='{ \"opacity-75\": person.unavailable }'>\n          {{ person.name }}\n        </span>\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { name: 'Durward Reynolds', unavailable: true },\n    { name: 'Kenton Towne', unavailable: false },\n    { name: 'Therese Wunsch', unavailable: false },\n    { name: 'Benedict Kessler', unavailable: true },\n    { name: 'Katelyn Rohan', unavailable: false },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\nTransitions\n\nTo animate the opening/closing of your listbox, you can use Vue's built-in <transition> component. All you need to do is wrap your ListboxOptions instance in a <transition>, and the transition will be applied automatically.\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n\n    <!-- Use Vue's built-in `transition` component to add transitions. -->\n\n    <transition\n      enter-active-class=\"transition duration-100 ease-out\"\n      enter-from-class=\"transform scale-95 opacity-0\"\n      enter-to-class=\"transform scale-100 opacity-100\"\n      leave-active-class=\"transition duration-75 ease-out\"\n      leave-from-class=\"transform scale-100 opacity-100\"\n      leave-to-class=\"transform scale-95 opacity-0\"\n    >\n      <ListboxOptions>\n        <ListboxOption\n          v-for=\"person in people\"\n          :key=\"person.id\"\n          :value=\"person\"\n        >\n          {{ person.name }}\n        </ListboxOption>\n      </ListboxOptions>\n    </transition>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\n\nIf you'd like to coordinate multiple transitions for different children of your Listbox, check out the Transition component included in Headless UI.\n\nRendering a different element for a component\n\nBy default, the Listbox and its subcomponents each render a default element that is sensible for that component.\n\nFor example, ListboxLabel renders a label by default, ListboxButton renders a button, ListboxOptions renders a ul, and ListboxOption renders a li. By contrast, Listbox does not render an element, and instead renders its children directly.\n\nThis is easy to change using the as prop, which exists on every component.\n\n<template>\n  <!-- Render a `div` instead of nothing -->\n\n  <Listbox as=\"div\" v-model=\"selectedPerson\">\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n\n    <!-- Render a `div` instead of a `ul` -->\n\n    <ListboxOptions as=\"div\">\n      <!-- Render a `span` instead of a `li` -->\n      <ListboxOption\n\n        as=\"span\"\n        v-for=\"person in people\"\n        :key=\"person.id\"\n        :value=\"person\"\n      >\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\n\nTo tell an element to render its children directly with no wrapper element, use as=\"template\".\n\n<template>\n  <Listbox v-model=\"selectedPerson\">\n    <!-- Render children directly instead of a `ListboxButton` -->\n\n    <ListboxButton as=\"template\">\n      <button>{{ selectedPerson.name }}</button>\n    </ListboxButton>\n\n    <ListboxOptions>\n      <ListboxOption v-for=\"person in people\" :key=\"person.id\" :value=\"person\">\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\nHorizontal options\n\nIf you've styled your ListboxOptions to appear horizontally, use the horizontal prop on the Listbox component to enable navigating the items with the left and right arrow keys instead of up and down, and to update the aria-orientation attribute for assistive technologies.\n\n<template>\n\n  <Listbox v-model=\"selectedPerson\" horizontal>\n    <ListboxButton>{{ selectedPerson.name }}</ListboxButton>\n\n    <ListboxOptions class=\"flex flex-row\">\n      <ListboxOption v-for=\"person in people\" :key=\"person.id\" :value=\"person\">\n        {{ person.name }}\n      </ListboxOption>\n    </ListboxOptions>\n  </Listbox>\n</template>\n\n<script setup>\n  import { ref } from 'vue'\n  import {\n    Listbox,\n    ListboxButton,\n    ListboxOptions,\n    ListboxOption,\n  } from '@headlessui/vue'\n\n  const people = [\n    { id: 1, name: 'Durward Reynolds' },\n    { id: 2, name: 'Kenton Towne' },\n    { id: 3, name: 'Therese Wunsch' },\n    { id: 4, name: 'Benedict Kessler' },\n    { id: 5, name: 'Katelyn Rohan' },\n  ]\n  const selectedPerson = ref(people[0])\n</script>\n\nAccessibility notes\nFocus management\n\nWhen a Listbox is toggled open, the ListboxOptions receives focus. Focus is trapped within the list of items until Escape is pressed or the user clicks outside the options. Closing the Listbox returns focus to the ListboxButton.\n\nMouse interaction\n\nClicking a ListboxButton toggles the options list open and closed. Clicking anywhere outside of the options list will close the listbox.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\n,\nSpace\n,\nArrowDown\n,\nor\nArrowUp\n when ListboxButton is focused\n\n\t\n\nOpens listbox and focuses the selected item\n\n\n\n\nEsc when listbox is open\n\n\t\n\nCloses listbox\n\n\n\n\nArrowDown\nor\nArrowUp\n when listbox is open\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nArrowLeft\nor\nArrowRight\n when listbox is open and horizontal is set\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nHome\nor\nPageUp when listbox is open\n\n\t\n\nFocuses first non-disabled item\n\n\n\n\nEnd\nor\nPageDown when listbox is open\n\n\t\n\nFocuses last non-disabled item\n\n\n\n\nEnter\nor\nSpace when listbox is open\n\n\t\n\nSelects the current item\n\n\n\n\nA–Z\nor\na–z when listbox is open\n\n\t\n\nFocuses first item that matches keyboard input\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nListbox\n\nThe main Listbox component.\n\nProp\tDefault\tDescription\nas\ttemplate\t\nString | Component\n\nThe element or component the Listbox should render as.\n\n\nv-model\t—\t\nT\n\nThe selected value.\n\n\ndefaultValue\t—\t\nT\n\nThe default value when using as an uncontrolled component.\n\n\nby\t—\t\nkeyof T | ((a: T, z: T) => boolean)\n\nUse this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.\n\n\ndisabled\tfalse\t\nBoolean\n\nUse this to disable the entire Listbox component & related children.\n\n\nhorizontal\tfalse\t\nBoolean\n\nWhen true, the orientation of the ListboxOptions will be horizontal, otherwise it will be vertical.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\n\nmultiple\tfalse\t\nBoolean\n\nWhether multiple options can be selected or not.\n\nSlot Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Listbox is disabled.\n\nListboxButton\n\nThe Listbox's button.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the ListboxButton should render as.\n\nSlot Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Listbox is disabled.\n\nListboxLabel\n\nA label that can be used for more control over the text your Listbox will announce to screenreaders. Its id attribute will be automatically generated and linked to the root Listbox component via the aria-labelledby attribute.\n\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the ListboxLabel should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Listbox is disabled.\n\nListboxOptions\n\nThe component that directly wraps the list of options in your custom Listbox.\n\nProp\tDefault\tDescription\nas\tul\t\nString | Component\n\nThe element or component the ListboxOptions should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\nListboxOption\n\nUsed to wrap each item within your Listbox.\n\nProp\tDefault\tDescription\nvalue\t—\t\nT\n\nThe option value.\n\n\nas\tli\t\nString | Component\n\nThe element or component the ListboxOption should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the option should be disabled for keyboard navigation and ARIA purposes.\n\nSlot Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the option is the active/focused option.\n\n\nselected\t\n\nBoolean\n\nWhether or not the option is the selected option.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the option is the disabled for keyboard navigation and ARIA purposes.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/vue/menu",
    "html": "Menu (Dropdown)\n\nMenus offer an easy way to build custom, accessible dropdown components with robust support for keyboard navigation.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm.\n\nPlease note that this library only supports Vue 3.\n\nnpm install @headlessui/vue\nBasic example\n\nMenu Buttons are built using the Menu, MenuButton, MenuItems, and MenuItem components.\n\nThe MenuButton will automatically open/close the MenuItems when clicked, and when the menu is open, the list of items receives focus and is automatically navigable via the keyboard.\n\n<template>\n  <Menu>\n    <MenuButton>More</MenuButton>\n    <MenuItems>\n      <MenuItem v-slot=\"{ active }\">\n        <a :class='{ \"bg-blue-500\": active }' href=\"/account-settings\">\n          Account settings\n        </a>\n      </MenuItem>\n      <MenuItem v-slot=\"{ active }\">\n        <a :class='{ \"bg-blue-500\": active }' href=\"/account-settings\">\n          Documentation\n        </a>\n      </MenuItem>\n      <MenuItem disabled>\n        <span class=\"opacity-75\">Invite a friend (coming soon!)</span>\n      </MenuItem>\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n</script>\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing slots\n\nEach component exposes information about its current state via slot props that you can use to conditionally apply different styles or render different content.\n\nFor example, the MenuItem component exposes an active state, which tells you if the item is currently focused via the mouse or keyboard.\n\n<template>\n  <Menu>\n    <MenuButton>Options</MenuButton>\n    <MenuItems>\n      <!-- Use the `active` state to conditionally style the active item. -->\n      <MenuItem\n        v-for=\"link in links\"\n        :key=\"link.href\"\n        as=\"template\"\n\n        v-slot=\"{ active }\"\n      >\n        <a\n          :href=\"link.href\"\n\n          :class=\"{ 'bg-blue-500 text-white': active, 'bg-white text-black': !active }\"\n        >\n          {{ link.label }}\n        </a>\n      </MenuItem>\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n\n  const links = [\n    { href: '/account-settings', label: 'Account settings' },\n    { href: '/support', label: 'Support' },\n    { href: '/license', label: 'License' },\n    { href: '/sign-out', label: 'Sign out' },\n  ]\n</script>\n\n\nFor a complete list of all the available slot props, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the slot prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the MenuItems component with some child MenuItem components renders when the menu is open and the second item is active:\n\n<!-- Rendered `MenuItems` -->\n<ul data-headlessui-state=\"open\">\n  <li data-headlessui-state=\"\">Account settings</li>\n  <li data-headlessui-state=\"active\">Support</li>\n  <li data-headlessui-state=\"\">License</li>\n</ul>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\n<template>\n  <Menu>\n    <MenuButton>Options</MenuButton>\n    <MenuItems>\n      <!-- Use the `active` state to conditionally style the active item. -->\n      <MenuItem\n        v-for=\"link in links\"\n        :key=\"link.href\"\n        :href=\"link.href\"\n        as=\"a\"\n\n        class=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n      >\n        {{ link.label }}\n      </MenuItem>\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n\n  const links = [\n    { href: '/account-settings', label: 'Account settings' },\n    { href: '/support', label: 'Support' },\n    { href: '/license', label: 'License' },\n    { href: '/sign-out', label: 'Sign out' },\n  ]\n</script>\n\nShowing/hiding the menu\n\nBy default, your MenuItems instance will be shown/hidden automatically based on the internal open state tracked within the Menu component itself.\n\n<template>\n  <Menu>\n    <MenuButton>More</MenuButton>\n\n    <!--\n      By default, the `MenuItems` will automatically show/hide\n      when the `MenuButton` is pressed.\n    -->\n    <MenuItems>\n      <MenuItem><!-- ... --></MenuItem>\n      <!-- ... -->\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n</script>\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can add a static prop to the MenuItems instance to tell it to always render, and inspect the open slot prop provided by the Menu to control which element is shown/hidden yourself.\n\n<template>\n\n  <Menu v-slot=\"{ open }\">\n    <MenuButton>More</MenuButton>\n\n\n    <div v-show=\"open\">\n      <!--\n        Using the `static` prop, the `MenuItems` are always\n        rendered and the `open` state is ignored.\n      -->\n\n      <MenuItems static>\n        <MenuItem><!-- ... --></MenuItem>\n        <!-- ... -->\n      </MenuItems>\n    </div>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n</script>\n\nClosing menus manually\n\nThe menu will already close by default, however it can happen that 3rd party Link components use event.preventDefault(), which prevents the default behaviour and therefore won't close the menu.\n\nThe Menu and MenuItem expose a close() slot prop which you can use to imperatively close the menu:\n\n<template>\n  <Menu>\n    <MenuButton>Terms</MenuButton>\n\n    <MenuItems>\n\n      <MenuItem v-slot=\"{ close }\">\n        <MyCustomLink href=\"/\" @click=\"close\">Read and accept</MyCustomLink>\n      </MenuItem>\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n  import { MyCustomLink } from './MyCustomLink'\n</script>\n\nDisabling an item\n\nUse the disabled prop to disable a MenuItem. This will make it unselectable via keyboard navigation, and it will be skipped when pressing the up/down arrows.\n\n<template>\n  <Menu>\n    <MenuButton>More</MenuButton>\n\n    <MenuItems>\n      <!-- ... -->\n\n      <!-- This item will be skipped by keyboard navigation. -->\n\n      <MenuItem disabled>\n        <span class=\"opacity-75\">Invite a friend (coming soon!)</span>\n      </MenuItem>\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n</script>\n\nTransitions\n\nTo animate the opening/closing of the menu panel, you can use Vue's built-in <transition> component. All you need to do is wrap your MenuItems instance in a <transition>, and the transition will be applied automatically.\n\n<template>\n  <Menu>\n    <MenuButton>More</MenuButton>\n\n    <!-- Use Vue's built-in `transition` element to add transitions. -->\n\n    <transition\n      enter-active-class=\"transition duration-100 ease-out\"\n      enter-from-class=\"transform scale-95 opacity-0\"\n      enter-to-class=\"transform scale-100 opacity-100\"\n      leave-active-class=\"transition duration-75 ease-out\"\n      leave-from-class=\"transform scale-100 opacity-100\"\n      leave-to-class=\"transform scale-95 opacity-0\"\n    >\n      <MenuItems>\n        <MenuItem><!-- ... --></MenuItem>\n\n        <!-- ... -->\n      </MenuItems>\n    </transition>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n</script>\n\n\nIf you'd like to coordinate multiple transitions for different children of your Menu, check out the Transition component included in Headless UI.\n\nRendering additional content\n\nThe accessibility semantics of role=\"menu\" are fairly strict and any children of a Menu that are not MenuItem components will be automatically hidden from assistive technology to make sure the menu works the way screen reader users expect.\n\nFor this reason, rendering any children other than MenuItem components is discouraged as that content will be inaccessible to people using assistive technology.\n\nIf you want to build a dropdown with more flexible content, consider using Popover instead.\n\nRendering a different element for a component\n\nBy default, the Menu and its subcomponents each render a default element that is sensible for that component.\n\nFor example, MenuButton renders a button by default, and MenuItems renders a div. By contrast, Menu and MenuItem do not render an element, and instead render their children directly by default.\n\nThis is easy to change using the as prop, which exists on every component.\n\n<template>\n  <!-- Render a `div` instead of no wrapper element -->\n\n  <Menu as=\"div\">\n    <MenuButton>More</MenuButton>\n\n    <!-- Render a `section` instead of a `div` -->\n\n    <MenuItems as=\"section\">\n      <MenuItem v-slot=\"{ active }\">\n        <a :class='{ \"bg-blue-500\": active }' href=\"/account-settings\">\n          Account settings\n        </a>\n      </MenuItem>\n\n      <!-- ... -->\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n</script>\n\n\nTo tell an element to render its children directly with no wrapper element, use as=\"template\".\n\n<template>\n  <Menu>\n    <!-- Render no wrapper, instead pass in a `button` manually. -->\n\n    <MenuButton as=\"template\">\n      <button>More</button>\n    </MenuButton>\n    <MenuItems>\n      <MenuItem v-slot=\"{ active }\">\n        <a :class='{ \"bg-blue-500\": active }' href=\"/account-settings\">\n          Account settings\n        </a>\n      </MenuItem>\n      <!-- ... -->\n    </MenuItems>\n  </Menu>\n</template>\n\n<script setup>\n  import { Menu, MenuButton, MenuItems, MenuItem } from '@headlessui/vue'\n</script>\n\n\nThis is important if you are using an interactive element like an <a> tag inside the MenuItem. If the MenuItem had an as=\"div\", then the props provided by Headless UI would be forwarded to the div instead of the a, which means that you can't go to the URL provided by the <a> tag anymore via your keyboard.\n\nAccessibility notes\nFocus management\n\nClicking the MenuButton toggles the menu and focuses the MenuItems component. Focus is trapped within the open menu until Escape is pressed or the user clicks outside the menu. Closing the menu returns focus to the MenuButton.\n\nMouse interaction\n\nClicking a MenuButton toggles the menu. Clicking anywhere outside of an open menu will close that menu.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\nor\nSpace when MenuButton is focused\n\n\t\n\nOpens menu and focuses first non-disabled item\n\n\n\n\nArrowDown\nor\nArrowUp\n when MenuButton is focused\n\n\t\n\nOpens menu and focuses first/last non-disabled item\n\n\n\n\nEsc when menu is open\n\n\t\n\nCloses any open Menus\n\n\n\n\nArrowDown\nor\nArrowUp\n when menu is open\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nHome\nor\nPageUp when menu is open\n\n\t\n\nFocuses first non-disabled item\n\n\n\n\nEnd\nor\nPageDown when menu is open\n\n\t\n\nFocuses last non-disabled item\n\n\n\n\nEnter\nor\nSpace when menu is open\n\n\t\n\nActivates/clicks the current menu item\n\n\n\n\nA–Z\nor\na–z when menu is open\n\n\t\n\nFocuses first item that matches keyboard input\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nFor a full reference on all accessibility features implemented in Menu, see the ARIA spec on Menu Buttons.\n\nWhen to use a Menu\n\nMenus are best for UI elements that resemble things like the menus you'd find in the title bar of most operating systems. They have specific accessibility semantics, and their content should be restricted to a list of links or buttons. Focus is trapped in an open menu, so you cannot Tab through the content or away from the menu. Instead, the arrow keys navigate through a Menu's items.\n\nHere's when you might use other similar components from Headless UI:\n\n<Popover />. Popovers are general-purpose floating menus. They appear near the button that triggers them, and you can put arbitrary markup in them like images or non-clickable content. The Tab key navigates the contents of a Popover like it would any other normal markup. They're great for building header nav items with expandable content and flyout panels.\n\n<Disclosure />. Disclosures are useful for elements that expand to reveal additional information, like a toggleable FAQ section. They are typically rendered inline and reflow the document when they're shown or hidden.\n\n<Dialog />. Dialogs are meant to grab the user's full attention. They typically render a floating panel in the center of the screen, and use a backdrop to dim the rest of the application's contents. They also capture focus and prevent tabbing away from the Dialog's contents until the Dialog is dismissed.\n\nComponent API\nMenu\nProp\tDefault\tDescription\nas\ttemplate\t\nString | Component\n\nThe element or component the Menu should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Menu is open.\n\n\nclose\t\n\n() => void\n\nCloses the menu and refocuses MenuButton.\n\nMenuButton\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the MenuButton should render as.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Menu is open.\n\nMenuItems\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the MenuItems should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nSlot Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Menu is open.\n\nMenuItem\nProp\tDefault\tDescription\nas\ttemplate\t\nString | Component\n\nThe element or component the MenuItem should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the item should be disabled for keyboard navigation and ARIA purposes.\n\nSlot Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the item is the active/focused item in the list.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the item is the disabled for keyboard navigation and ARIA purposes.\n\n\nclose\t\n\n() => void\n\nCloses the menu and refocuses MenuButton.\n"
  }
]
