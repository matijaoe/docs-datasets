[
  {
    "title": "Composition Helpers",
    "url": "https://vee-validate.logaretm.com/v4/api/composition-helpers/",
    "html": "Composition Helpers\n\nThe composition helpers are various functions that you can use to craft specialized form components, like a submission indicator component or a custom error messages component.\n\nThese functions expose validation state to child components, most of these functions expose 2 variants of each state. On a form level and a field level.\n\nAPI Reference\n\nTIP\n\nAll of the following code snippets assume you are using them inside a setup function.\n\nuseFieldError(field?: string): ComputedRef<string | undefined>\n\nReturns a computed ref to a single field’s error message, returns undefined if no errors were found for that field or if the field does not exist.\n\njs\nimport { useFieldError } from 'vee-validate';\nconst message = useFieldError('fieldName');\nmessage.value; // string or `undefined`\n\nYou can also use it in a child component that has a parent that used useField, The useFieldError will automatically pick up the field and produce its error messages.\n\njs\nimport { useFieldError } from 'vee-validate';\n// Will look for the first parent that used `useField`\nconst message = useFieldError();\nmessage.value;\n\nuseFormErrors(): ComputedRef<Record<string, string | undefined>>\n\nReturns a computed ref to the error bag of the entire form, fields with no errors will not be included in the error bag object.\n\njs\nimport { useFormErrors } from 'vee-validate';\nconst errors = useFormErrors();\nmessage.value; // {}\n\nuseIsFieldDirty(field?: string): ComputedRef<boolean>\n\nReturns a computed ref to the specified field’s dirty meta state.\n\njs\nimport { useIsFieldDirty } from 'vee-validate';\nconst isDirty = useIsFieldDirty();\nisDirty.value; // true or false\n\nYou can also use it in a child component that has a parent that used useField, The useIsFieldDirty will automatically pick up the field and produce its meta dirty value\n\njs\nimport { useIsFieldDirty } from 'vee-validate';\n// Will look for the first parent that used `useField`\nconst isDirty = useIsFieldDirty();\n\nuseIsFormDirty(): ComputedRef<boolean>\n\nReturns a computed ref to the context form dirty meta state.\n\njs\nimport { useIsFormDirty } from 'vee-validate';\nconst isDirty = useIsFormDirty();\nisDirty.value; // true or false\n\nuseIsFieldTouched(field?: string): ComputedRef<boolean>\n\nReturns a computed ref to the specified field’s touched meta state.\n\njs\nimport { useIsFieldTouched } from 'vee-validate';\nconst isTouched = useIsFieldTouched('fieldName');\nisTouched.value; // true or false\n\nYou can also use it in a child component that has a parent that used useField, The useIsFieldTouched will automatically pick up the field and produce its meta touched value\n\njs\nimport { useIsFieldTouched } from 'vee-validate';\n// Will look for the first parent that used `useField`\nconst isTouched = useIsFieldTouched();\n\nuseIsFormTouched(): ComputedRef<boolean>\n\nReturns a computed ref to the context form touched meta state.\n\njs\nimport { useIsFormTouched } from 'vee-validate';\nconst isTouched = useIsFormTouched();\nisTouched.value; // true or false\n\nuseIsFieldValid(field?: string): ComputedRef<boolean>\n\nReturns a computed ref to the specified field’s valid meta state, inner value will be true if the field has no errors, and false if it has any error message.\n\njs\nimport { useIsFieldValid } from 'vee-validate';\nconst isValid = useIsFieldValid('fieldName');\nisValid.value; // true or false\n\nYou can also use it in a child component that has a parent that used useField, The useIsFieldValid will automatically pick up the field and produce its meta valid value\n\njs\nimport { useIsFieldValid } from 'vee-validate';\n// Will look for the first parent that used `useField`\nconst isValid = useIsFieldValid();\n\nWARN\n\nCreating disabled buttons based on the valid attribute isn’t accurate, because if the field hasn’t been validated yet it, the valid property will be true which isn’t accurate. You should combine valid checks with dirty state to get the most accuracy.\n\nuseIsFormValid(): ComputedRef<boolean>\n\nReturns a computed ref to the context form valid meta state.\n\njs\nimport { useIsFormValid } from 'vee-validate';\nconst isValid = useIsFormValid();\nisValid.value; // true or false\n\nWARN\n\nCreating disabled buttons based on the valid attribute isn’t accurate, because if the form hasn’t been validated yet it, the valid property will be true which isn’t accurate. You should combine valid checks with dirty state to get the most accuracy.\n\nuseValidateField(field?: string): () => Promise<ValidationResult>\n\nReturns a function that validates the field and returns a validation result object containing any errors, if the errors field is empty then it means the field is valid. If a field doesn’t not exist it will return an empty errors field with a warning.\n\njs\nimport { useValidateField } from 'vee-validate';\nconst validate = useValidateField('fieldName');\nawait validate();\n\nYou can also use it in a child component that has a parent that used useField, The useValidateField will automatically pick up the field and will return the function that validates it.\n\njs\nimport { useValidateField } from 'vee-validate';\n// Will look for the first parent that used `useField`\nconst validate = useValidateField();\n\nuseValidateForm(): () => Promise<FormValidationResult>\n\nReturns a function that validates the form and returns a Form.\n\njs\nimport { useValidateForm } from 'vee-validate';\nconst validate = useValidateForm();\nawait validate();\n\nuseIsSubmitting(): ComputedRef<boolean>\n\nReturns a computed ref to the form’s isSubmitting state.\n\njs\nimport { useIsSubmitting } from 'vee-validate';\nconst isSubmitting = useIsSubmitting();\nisSubmitting.value; // true or false\n\nuseIsValidating(): ComputedRef<boolean>\n\nReturns a computed ref to the form’s isValidating state.\n\njs\nimport { useIsValidating } from 'vee-validate';\nconst isValidating = useIsValidating();\nisValidating.value; // true or false\n\nuseSubmitCount(): ComputedRef<number>\n\nReturns a computed ref to the form’s submitCount state.\n\njs\nimport { useSubmitCount } from 'vee-validate';\nconst count = useSubmitCount();\ncount.value;\n\nuseResetForm(): () => void\n\nReturns a function that you can use to reset the form\n\njs\nimport { useResetForm } from 'vee-validate';\nconst resetForm = useResetForm();\nresetForm(); // resets the form\n\nuseSubmitForm(cb: SubmissionHandler): () => void\n\nReturns a function that you can use to validate the form and submit if it turns out valid. It does this by accepting a function that should handle the submission logic like sending data to your API. That function will not run unless the form is valid and it receives all the fields current values packed in an object.\n\njs\nimport { useSubmitForm } from 'vee-validate';\nconst submitForm = useSubmitForm((values, actions) => {\n  // Send data to your api ...\n  alert(JSON.stringify(values, null, 2));\n  // You can perform any of the form actions using the actions object\n  // set a single field value\n  actions.setFieldValue('field', 'hello');\n  // set multiple fields values\n  actions.setValues({ email: 'value', password: 'hi' });\n  // set a single field error\n  actions.setFieldError('field', 'this field is bad');\n  // set multiple fields errors\n  actions.setErrors({ email: 'bad email', password: 'bad password' });\n  // reset the form\n  actions.resetForm();\n});\n\nVirtual Forms\n\nWhile it is recommended to use actual form elements for accessibility, you could still use useSubmitForm to submit any group of data which may or may not be involved with a form element.\n\nuseFieldValue(field?: string): ComputedRef<any>\n\nReturns a computed ref to the specified field’s current value.\n\njs\nimport { useFieldValue } from 'vee-validate';\nconst currentValue = useFieldValue('fieldName');\ncurrentValue.value;\n\nYou can also use it in a child component that has a parent that used useField, The useFieldValue will automatically pick up the field and produce its current value.\n\njs\nimport { useFieldValue } from 'vee-validate';\n// Will look for the first parent that used `useField`\nconst currentValue = useFieldValue();\n\nuseFormValues(): ComputedRef<Record<string, any>>\n\nReturns a computed ref to the context form current values.\n\njs\nimport { useFormValues } from 'vee-validate';\nconst values = useFormValues();\nvalues.value;"
  },
  {
    "title": "useFieldArray",
    "url": "https://vee-validate.logaretm.com/v4/api/use-field-array/",
    "html": "useFieldArray v4.5\n\nuseFieldArray is a custom composition API function that allows you to manage repeatable fields and forms entries and provides common operation helpers.\n\nBasic usage:\n\nvue\n<template>\n  <form @submit=\"onSubmit\" novalidate>\n    <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n      <Field :name=\"`links[${idx}].url`\" type=\"url\" />\n      <button type=\"button\" @click=\"remove(idx)\">Remove</button>\n    </div>\n    <button type=\"button\" @click=\"push({ url: '' })\">Add</button>\n    <button>Submit</button>\n  </form>\n</template>\n<script setup>\nimport { Field, useForm, useFieldArray } from 'vee-validate';\nconst { handleSubmit } = useForm({\n  initialValues: {\n    links: [{ id: 1, url: 'https://github.com/logaretm' }],\n  },\n});\nconst { remove, push, fields } = useFieldArray('links');\nconst onSubmit = handleSubmit(values => {\n  console.log(JSON.stringify(values, null, 2));\n});\n</script>\nAPI Reference\n\nThe full signature of the useFieldArray function looks like this:\n\nts\ninterface FieldEntry<TValue = unknown> {\n  value: Ref<TValue>;\n  key: string | number;\n  isFirst: boolean;\n  isLast: boolean;\n}\ninterface FieldArrayContext<TValue = unknown> {\n  fields: Ref<FieldEntry<TValue>[]>;\n  remove(idx: number): void;\n  replace(newArray: TValue[]): void;\n  update(idx: number, value: TValue): void;\n  push(value: TValue): void;\n  swap(indexA: number, indexB: number): void;\n  insert(idx: number, value: TValue): void;\n  prepend(value: TValue): void;\n  move(oldIdx: number, newIdx: number): void;\n}\nfunction useFieldArray: (arrayPath: string): FieldArrayContext;\nComposable API\n\nThe following sections documents each available property on the useFieldArray composable.\n\nfields: Ref<FieldArrayEntry<TValue>[]>\n\nThis is a read-only version of your array items, wrapped inside a FieldArrayEntry object which has the following interface:\n\nts\ninterface FieldEntry<TValue = unknown> {\n  // The actual value of the item as readonly, this is what exists in the form values\n  value: TValue;\n  // a value you can use as a key for iteration, automatically generated\n  key: string | number;\n  // true if this is the first array item\n  isFirst: boolean;\n  // true if this is the last array item\n  isLast: boolean;\n}\njs\n// call composable in component setup to get readable version of links array\nconst { fields } = useFieldArray('links');\n\npush(item: any)\n\nAdds an item to the end of the array.\n\njs\n// get push function from composable in component setup\nconst { push } = useFieldArray('links');\n// call push function within custom function\nconst myPushFunction = () => {\n  // adds a new item to the array\n  push({ url: '' });\n};\n\nprepend(item: any)\n\nAdds an item to the start of the array.\n\njs\n// get prepend function from composable in component setup\nconst { prepend } = useFieldArray('links');\n// call prepend function within custom function\nconst myPrependFunction = () => {\n  // adds a new item to the array\n  prepend({ url: '' });\n};\n\nremove(idx: number)\n\nRemoves the item at the specified index from the array if it exists.\n\njs\n// get remove function from composable in component setup\nconst { remove } = useFieldArray('links');\n// call remove function within custom function\nconst myRemoveFunction = () => {\n  // removes the second item from the array\n  remove(1);\n};\n\nswap(idxA: number, idxB: number)\n\nSwaps the items at the given indexes with each other. Both indexes must exist in the array or it won’t have an effect.\n\njs\n// get swap function from composable in component setup\nconst { swap } = useFieldArray('links');\n// call swap function within custom function\nconst mySwapFunction = () => {\n  // Swaps the 4th item with the 5th\n  swap(3, 4);\n};\n\ninsert(idx: number, item: any)\n\nAdds an item at the specified index. If the specified index will place the item out of bounds (i.e: larger than length) the operation will be ignored, you still can add items as the last item of the array.\n\njs\n// get insert function from composable in component setup\nconst { insert } = useFieldArray('links');\n// call insert function within custom function\nconst myInsertFunction = () => {\n  // inserts a new item to the array at the second index\n  insert(1, { url: '' });\n};\n\nupdate(idx: number, value: any)\n\nUpdates the value at the specified index, note that it doesn’t merge the values if they are objects. If the specified index is outside the array boundary the operation will be ignored.\n\njs\n// get update function from composable in component setup\nconst { update } = useFieldArray('links');\n// call update function within custom function\nconst myUpdateFunction = () => {\n  // updates the 2nd item value\n  update(1, { url: '' });\n};\n\nreplace(items: any[])\n\nReplaces the entire array of fields.\n\njs\n// get replace function from composable in component setup\nconst { replace } = useFieldArray('links');\n// call replace function within custom function\nconst myReplaceFunction = () => {\n  // replace the entire array with these items\n  replace([{ url: 'https://google.com' }, { url: 'https://vuejs.org' }]);\n};\n\nmove(oldIdx:number, newIdx: number)\n\nMoves an array item to a different position within the array.\n\njs\n// get move function from composable in component setup\nconst { move } = useFieldArray('links');\n// call move function within custom function\nconst myMoveFunction = () => {\n  // move array item to a different position\n  move(2, 1);\n};"
  },
  {
    "title": "Configuration",
    "url": "https://vee-validate.logaretm.com/v4/api/configuration/",
    "html": "Configuration\n\nvee-validate exposes global configs to help with a few repeated or certain behaviors that needs to be set app-wide.\n\nConfig Options\nOption\tType\tDescription\nbails\tboolean\tWhether to run validations to completion or quit on the first, default is true. Doesn’t affect yup schemas\ngenerateMessage\t(ctx: FieldValidationMetaInfo) => string\tA message generator function for i18n libraries and a fallback for rules with no messages. For more information about the FieldValidationMetaInfo type and the purpose of this, see the Global Message Generator Guide\nvalidateOnBlur\tboolean\tIf validation should be triggered on blur event, default is true\nvalidateOnChange\tboolean\tIf validation should be triggered on change event, default is true\nvalidateOnInput\tboolean\tIf validation should be triggered on input event, default is false\nvalidateOnModelUpdate\tboolean\tIf validation should be triggered on update:modelValue (v-model) event, default is true\n\nThis is slightly verbose, but this gives you exact control on which events triggers validation.\n\nUpdating The Config\n\nYou can change the global config using the configure function exposed by vee-validate passing any options that you need to change. You can call that function at any time during runtime but the changes will take effect for new Field and useField afterwards.\n\nHere is an example:\n\njs\nimport { configure } from 'vee-validate';\nconfigure({\n  bails: false,\n});\n\nTIP\n\nNote that the following config do not affect useField, they only apply to the <Field /> component:\n\nvalidateOnBlur\nvalidateOnChange\nvalidateOnInput\nvalidateOnModelUpdate"
  },
  {
    "title": "useForm",
    "url": "https://vee-validate.logaretm.com/v4/api/use-form/",
    "html": "useForm\n\nuseForm is a custom composition API function that allows you to group fields created by useField and aggregates their state. It should be used to create logical forms or custom form components similar to the <Form/> component which is just a consumer of useForm.\n\nField Types\n\nThe useForm function has field typing capabilities if you need it, getting type information for your fields and their values can be very powerful when building complex forms.\n\nBy unlocking the field type you automatically get more strict information for the various properties/methods exposed by useForm like setErrors and setTouched. There are two ways you can get the advanced typing information for your fields, the first is to provide a generic type to useForm.\n\nts\nimport { useForm } from 'vee-validate';\ninterface LoginForm {\n  email: string;\n  password: string;\n}\n// in your setup\nconst { errors } = useForm<LoginForm>();\n\nOr simply provide initial values to useForm and it will automatically pick up the type of initialValues and use it for the field types.\n\nts\nimport { useForm } from 'vee-validate';\nconst { errors, setErrors, setFieldValue } = useForm({\n  initialValues: {\n    email: '',\n    password: '',\n  },\n});\n\nAlternatively, you can use a typed schema to infer the form types from the validation schema if you are using yup or zod.\n\nWhichever approach you prefer, you get full type information for your fields for all the functions exposed by useForm, here are a few examples.\n\nts\nimport { useForm } from 'vee-validate';\ninterface LoginForm {\n  email: string;\n  password: string;\n}\n// in your setup\nconst { errors, setErrors, setFieldValue } = useForm<LoginForm>();\nerrors.value; // typed as { email?: string; password?: string }\nsetErrors({\n  email: 'This field is invalid', // auto-complete for `email` and `password`\n});\nsetFieldValue('email', 'example@gmail.com'); // auto-complete for the field name and its value type\n\nFor example if you were to do this in the previous example:\n\nts\nsetFieldValue('age', 5); // ⛔️ TypeScript error\nsetFieldValue('email', 5); // ⛔️ TypeScript error\n\nIt will error out because age is not defined in the LoginForm type you defined. The second line errors out because the email field is typed as a string.\n\nAPI Reference\nArguments\n\nvalidationSchema?: any\n\nEnables form-level validation, uses the specified schema to validate the fields. The schema can be either valid vee-validate global validators or functions or a yup object schema.\n\ninitialValues?: MaybeRef<Record<string, any>>\n\nThe initial values for the form, can be a reactive object or reference.\n\njs\nconst { ... } = useForm({\n  initialValues: {\n    email: 'example@gmail.com',\n    password: 'p@$$w0rd',\n  }\n});\n\ninitialErrors?: Record<string, string>\n\nThe initial errors for the fields, useful for non hydrated SSR applications like Laravel, errors are applied on mounted.\n\njs\nconst { ... } = useForm({\n  initialErrors: {\n    email: 'This email is invalid',\n    password: 'Password too short',\n  }\n});\n\ninitialTouched?: Record<string, any>\n\nThe initial touched status for the form fields, applied on mounted.\n\njs\nconst { ... } = useForm({\n  initialTouched: {\n    email: true, // touched\n    password: false, // non-touched\n  }\n});\n\nvalidateOnMount?: boolean\n\nIf true, it will trigger validation for all fields once the form component is mounted.\n\nComposable API\n\nThe following sections documents each available property on the useForm composable.\n\nerrors: Ref<Record<string, string>>\n\nAn object that maps field names to their error messages, it only takes the first error message of each field if multiple exists.\n\njs\nconst { errors } = useForm();\nerrors.value; // access the errors value\n\nerrorBag: Ref<Record<string, string>>\n\nAn object that maps field names to all of their error messages.\n\njs\nconst { errorBag } = useForm();\nerrorBag.value.email; // email field errors\n\nHere is an example of its shape:\n\njs\n{\n  email: [\"this field is required\", \"this field must be a valid email\"],\n  password: \"too short\"\n}\n\nAny fields without error messages will not be included in the object. So you can safely iterate over it with Object.keys() knowing all the included fields are invalid.\n\nisSubmitting: Ref<boolean>\n\nIndicates if the submission handler is still running, once it resolves/rejects it will be automatically set to false again.\n\njs\nconst { isSubmitting } = useForm();\nisSubmitting.value; // true or false\n\nisValidating: Ref<boolean>\n\nIndicates if the validate function is still running, once validate function is done it will be automatically set to false again.\n\njs\nconst { isValidating } = useForm();\nisValidating.value; // true or false\n\nmeta: ComputedRef<FormMeta>\n\nA computed property that contains an aggregated meta information/flags reflecting the state of all the fields inside the form.\n\nts\ninterface FormMeta {\n  touched: boolean; // if at least one field is touched (was blurred)\n  dirty: boolean; // if at least one field is dirty (manipulated)\n  valid: boolean; // if the form doesn't have any error messages\n  pending: boolean; // if at least one field is pending validation\n  initialValues?: Record<string, any>; // a map of the form's initial values\n}\n\nusage\n\njs\nconst { meta } = useForm();\nmeta.value; // { valid: false, invalid: true, dirty: true, .... }\n\nvalues: Record<string, any>\n\nA reactive property that contains the current form values, you should not try to mutate it directly.\n\njs\nconst { values } = useForm();\nvalues; // { email: 'something@gmail.com', .... }\n\nsetFieldError: (field: string, message: string | undefined) => void\n\nSets a field’s error message, useful for setting messages form an API or that are not available as a validation rule. Setting the message to undefined or an empty string clears the errors and marks the field as valid.\n\njs\nconst { setFieldError } = useForm();\nsetFieldError('email', 'this email is already taken');\n// Mark field as valid\nsetFieldError('email', undefined);\n\nIf you try to set an error for a field that doesn’t exist, it will be added to the form’s errors object and it will change the form’s valid state\n\nsetErrors: (fields: Record<string, string | undefined>) => void\n\nSets multiple fields error messages, uses setFieldError internally.\n\njs\nconst { setErrors } = useForm();\nsetErrors({\n  email: 'this email is already taken',\n  password: 'someone already has this password 🤪',\n  firstName: undefined, // clears errors and marks the field as valid\n});\n\nTIP\n\nAny missing fields you didn’t pass to setErrors will be unaffected and their state will not change\n\nsetFieldValue: (field: string, value: any) => void\n\nSets a field’s value, if a field does not exist it will not be reflected in the values ref. This will trigger validation on the field whose value changed.\n\njs\nconst { setFieldValue } = useForm();\nsetFieldValue('email', 'example@gmail.com');\n\nIf you try to set a value for a field that doesn’t exist, it will be added to the form’s values object and will stay there until the next resetForm is called.\n\nsetValues: (fields: Record<string, any>) => void\n\nSets all fields values, will trigger validation for the changed fields.\n\njs\nconst { setValues } = useForm();\nsetValues({\n  email: 'example@gmail.com',\n  password: 'p@a$$W0rD',\n});\n\nsetFieldTouched: (field: string, isTouched: boolean) => void\n\nSets a field’s touched meta flag, if you set it for a non-existing field it will have no effect.\n\njs\nconst { setFieldTouched } = useForm();\nsetFieldTouched('email', true);\n\nsetTouched: (fields: Record<string, boolean>) => void\n\nSets multiple fields touched meta flag, does not validate.\n\njs\nconst { setTouched } = useForm();\nsetTouched({\n  email: true,\n  password: false,\n});\n\nvalidate: () => Promise<{ valid: boolean; errors: Record<string, string>}>\n\nValidates all the fields and populates the errors object, returns a promise that resolves to an object containing aggregated validation result of all fields.\n\njs\nconst { validate } = useForm();\nconst { valid, errors } = await validate();\n\nvalidateField: (field: string) => Promise<{ valid: boolean; errors: string[] }>\n\nValidates a specific field inside the form, returns a promise that resolves to an object containing the validation result.\n\njs\nconst { validateField } = useForm();\nconst { valid, errors } = await validateField('email');\n\nhandleSubmit: (cb: SubmissionHandler) => (evt?: Event) => Promise<void>\n\nThis is a higher order function used to create submit event handlers, You shouldn’t use it as a handler for the events directly but rather use it to create those handlers.\n\nThe handlers created using this function will automatically prevent form submission and stop the propagation of the submit event.\n\nIt accepts a function which runs after validating the form and if all fields are valid. The callback you pass will receive the form values as the first argument, which is an object containing the fields’ values.\n\nvue\n<template>\n  <form @submit=\"onSubmit\"></form>\n</template>\n<script setup>\nimport { useForm } from 'vee-validate';\nconst { handleSubmit } = useForm();\n// use `onSubmit` as an event handler for your forms\nconst onSubmit = handleSubmit(values => {\n  // pretty print the values object\n  alert(JSON.stringify(values, null, 2));\n});\n</script>\n\nFor advanced forms, you may need to trigger various actions on the form in the submit handler. Your callback receives a FormActions object as part of the second argument along with the event object that triggered the submission if available.\n\njs\nconst { handleSubmit } = useForm();\nconst onSubmit = handleSubmit((values, actions) => {\n  // Send data to API\n  alert(JSON.stringify(values, null, 2));\n  // the form object contains useful methods\n  // set a single field value\n  actions.setFieldValue('field', 'hello');\n  // set multiple fields values\n  actions.setValues({ email: 'value', password: 'hi' });\n  // set a single field error\n  actions.setFieldError('field', 'this field is bad');\n  // set multiple fields errors\n  actions.setErrors({ email: 'bad email', password: 'bad password' });\n  // reset the form\n  actions.resetForm();\n});\n\nhandleSubmit contains a withControlled function that you can use to only submit fields controlled by useField or useFieldModel. Read the guide for more information.\n\nvue\n<template>\n  <form @submit=\"onSubmit\"></form>\n</template>\n<script setup>\nimport { useForm } from 'vee-validate';\nconst { handleSubmit } = useForm();\nconst onSubmit = handleSubmit.withControlled(values => {\n  // Send only controlled values to the API\n  // Only fields declared with `useField` or `useFieldModel` will be printed\n  alert(JSON.stringify(values, null, 2));\n});\n</script>\n\nVirtual Forms\n\nYou can use handleSubmit to submit virtual forms that may use form elements or not. As you may have noticed the snippet above doesn’t really care if you are using forms or not.\n\nsubmitForm: (evt: Event) => void\n\nUnlike handleSubmit this function can be used as an event handler for form submit event, it will prevent the propagation and submission of the forms using it as long as they are invalid. Once all the fields are valid it will submit the form with the native HTML behavior following the form element’s action and method attributes.\n\nThis is useful if you plan to handle form submissions using a backend API like Laravel or whatever.\n\nvue\n<template>\n  <form @submit=\"submitForm\" action=\"/api/login\" method=\"post\">\n    <!-- ... -->\n  </form>\n</template>\n<script setup>\nimport { useForm } from 'vee-validate';\nconst { submitForm } = useForm();\n</script>\n\nsubmitCount: number\n\nThe number of submission attempts by the user, it increments whenever submitForm or handleSubmit callback are called.\n\nresetForm: (state?: Partial<FormState>, opts?: ResetFormOpts) => void\n\nClears error messages, resets the meta state for all fields and reverts their values to their initial state as well as the submitCount state. Accepts an optional object containing the new form state, useful if you need to reset the form values to different values other than their initial state.\n\nThis is the FormState interface:\n\nts\ntype TouchedFlags = { [k: string]: boolean };\ninterface FormState {\n  // any error messages\n  errors: Record<string, string>;\n  // touched meta flags\n  touched: TouchedFlags;\n  // Form Values\n  values: Record<string, any>;\n  // The form submit attempts count\n  submitCount: number;\n}\n\nIn this example, the resetForm function is updating the fields current values to the ones provided, these values will be used as the new initial values for future resetForm or handleReset calls. This also applies if the Field component or useField used their individual resetField function.\n\njs\nconst { resetForm } = useForm();\n// ...\nfunction onSubmit(values) {\n  // send values to the API\n  // ...\n  // Reset the form values\n  resetForm({\n    values: {\n      firstName: '',\n      lastName: '',\n      email: '',\n      password: '',\n    },\n  });\n}\n\nBy default resetForm merges the previous initial values with the new one provided, meaning only the provided ones will be overwritten. You can overwrite all the fields by passing force: true in the second argument.\n\njs\nconst { values, resetForm } = useForm({\n  initialValues: { fname: '123', lname: '456' },\n});\n// values: { fname: '123', lname: '456' }\nresetForm({ values: { fname: 'test' } });\n// values: { fname: 'test' }\nresetForm({ values: { fname: 'test' } }, { force: true });\n\nhandleReset: () => void\n\nClears error messages, resets the meta state for all fields and reverts their values to their initial state as well as the submitCount state. you can use this function as handler for the reset events on native form elements.\n\nvue\n<template>\n  <form @reset=\"handleReset\">\n    <!-- ... -->\n  </form>\n</template>\n<script setup>\nimport { useForm } from 'vee-validate';\nconst { handleReset } = useForm();\n// you can use it in your code\nhandleReset();\n</script>\n\nuseFieldModel\n\nTIP\n\nThis is deprecated, please use defineInputBinds or defineComponentBinds instead.\n\nThis creates a bindable two-way model value for the specified fields, there are a couple of signatures for useFieldModel. Must be called in the setup function.\n\nuseFieldModel accepts either a single field path or multiple via an array. You can use either root field paths or nested paths like some.user.path with dot notation.\n\nvue\n<template>\n  <input name=\"email\" v-model=\"email\" />\n  <span>{{ errors.email }}</span>\n  <input name=\"password\" v-model=\"password\" type=\"password\" />\n  <span>{{ errors.password }}</span>\n</template>\n<script setup>\nimport { useForm } from 'vee-validate';\nconst { errors, useFieldModel } = useForm();\nconst email = useFieldModel('email');\nconst password = useFieldModel('password');\n// or multiple models at once\nconst [email, password] = useFieldModel(['email', 'password']);\n</script>\n\ndefineInputBinds\n\nThis creates a bindable object for the specified field. The bindable object only works with native HTML input elements, for components use defineComponentBinds instead.\n\nThe defineInputBinds must be called in the setup function.\n\ndefineInputBinds accepts a single field path, You can use either root field paths or nested paths like some.user.path with dot notation.\n\nvue\n<template>\n  <input v-bind=\"email\" />\n  <span>{{ errors.email }}</span>\n  <input v-bind=\"password\" type=\"password\" />\n  <span>{{ errors.password }}</span>\n</template>\n<script setup>\nimport { useForm } from 'vee-validate';\nconst { errors, defineInputBinds } = useForm();\nconst email = defineInputBinds('email');\nconst password = defineInputBinds('password');\n</script>\n\ndefineComponentBinds\n\nThis creates a bindable object for the specified field. The bindable object only works with components, for native HTML input elements use defineInputBinds instead.\n\nThe defineComponentBinds must be called in the setup function.\n\ndefineComponentBinds accepts a single field path, You can use either root field paths or nested paths like some.user.path with dot notation.\n\nvue\n<template>\n  <MyTextInput v-bind=\"email\" />\n  <span>{{ errors.email }}</span>\n  <MyTextInput v-bind=\"password\" type=\"password\" />\n  <span>{{ errors.password }}</span>\n</template>\n<script setup>\nimport { useForm } from 'vee-validate';\nimport MyTextInput from '@/components/MyTextInput.vue';\nconst { errors, defineComponentBinds } = useForm();\nconst email = defineComponentBinds('email');\nconst password = defineComponentBinds('password');\n</script>"
  },
  {
    "title": "useField",
    "url": "https://vee-validate.logaretm.com/v4/api/use-field/",
    "html": "useField\n\nuseField is a custom composition API function that allows you to create data models that’s automatically validated that you can then use to build your own custom input components with validation capabilities. It is very useful if you plan to build a UI component library that needs to have validation capabilities. In other words it acts as a primitive to allow you to compose validation logic into your components.\n\nThe most basic usage looks like this:\n\nvue\n<template>\n  <div>\n    <input v-model=\"value\" />\n    <span>{{ errorMessage }}</span>\n  </div>\n</template>\n<script setup>\nimport { useField } from 'vee-validate';\n// a simple `name` field with basic required validator\nconst { value, errorMessage } = useField('name', inputValue => !!inputValue);\n</script>\n\nWhenever the value ref is updated it will be validated and the errorMessage ref will be automatically filled with the first error message. Usually you would bind the value ref to your inputs using v-model or any other means and whenever you want to validate your field you update the value binding with the new value.\n\nAdditionally you can use yup as a validator:\n\nvue\n<script setup>\nimport { useField } from 'vee-validate';\nimport * as yup from 'yup';\nconst { value, errorMessage } = useField('email', yup.string().email().required());\n</script>\n\nYou are responsible for when the field validates, blurs or when its value changes. This gives you greater control over the Field component which may include or implement sensible defaults for most common use cases.\n\nUsage with TypeScript\n\nYou can use useField with typescript and type the field’s value type to ensure safety when manipulating it’s value. The useField function is a generic function that receives the value type and applies it on the various interactions you have with its API.\n\nts\nconst { value, resetField } = useField<string>('email', yup.string().email());\nvalue.value = 1; // ⛔️  Error\nvalue.value = 'test@example.com'; // ✅\nresetField({\n  value: 1, // ⛔️  Error\n});\nresetField({\n  value: 'test@example.com', // ✅\n});\n\nThe validation rules can be either a string, object, function or a yup schema:\n\njs\n// Globally defined rules with `defineRule`, Laravel-like syntax\nuseField('password', 'required|min:8');\n// Globally defined rules object\nuseField('password', { required: true, min: 8 });\n// Simple validation function\nuseField('password', value => {\n  if (!value) {\n    return 'password is required';\n  }\n  if (value.length < 8) {\n    return 'password must be at least 8 characters long';\n  }\n  return true;\n});\n// Yup validation\nuseField('password', yup.string().required().min(8));\nAPI Reference\nComposable API\n\nThe following sections documents each available property on the useField composable.\n\nname: string\n\nThe field name, this is a static string and cannot be changed.\n\nvalue: Ref<TValue = unknown>\n\nA reactive reference to the field’s current value, can be changed and will trigger validation by default unless disabled by the validateOnValueUpdate option.\n\njs\nconst { value } = useField('field', value => !!value);\nvalue.value = 'hello world'; // sets the value and validates the field\n\nYou can also bind it with v-model to get two-way value binding with validation.\n\nmeta: FieldMeta<TValue = unknown>\n\nContains useful information/flags about the field status, should be treated as read only.\n\nts\ninterface FieldMeta {\n  touched: boolean; // if the field has been blurred (via handleBlur)\n  dirty: boolean; // if the field has been manipulated (via handleChange)\n  valid: boolean; // if the field doesn't have any errors\n  pending: boolean; // if validation is in progress\n  initialValue?: any; // the field's initial value\n}\n\nThe valid flag\n\nThe valid flag on the meta object can be tricky, because by default it stars off with true for a few moments, only then it is updated to its proper state.\n\nCombining your valid flag checks with dirty will yield the expected result based on user interaction.\n\nusage\n\njs\nconst { meta } = useField('field', value => !!value);\nmeta; // { valid: true, dirty: true, .... }\n\nerrors: Ref<string[]>\n\nA reactive reference containing all error messages for the field, should be treated as read only\n\njs\nconst { errors } = useField('field', value => !!value);\nerrors.value; // ['field is not valid']\n\nerrorMessage: ComputedRef<string | undefined>\n\nA computed reference that returns the first error in the errors array, a handy shortcut to display error messages\n\njs\nconst { errorMessage } = useField('field', value => !!value);\nerrorMessage.value; // 'field is not valid' or undefined\n\nresetField: (state?: Partial<FieldState>) => void\n\nResets the field’s validation state, by default it reverts all meta object to their default values and clears out the error messages. It also updates the field value to its initial value without validating them.\n\njs\nconst { resetField } = useField('field', value => !!value);\n// reset the field meta and its initial value and clears errors\nresetField();\n// reset the meta state, clears errors and updates the field value and its initial value\nresetField({\n  value: 'new value',\n});\n// resets the meta state, resets the field to its initial value and sets the errors\nresetField({\n  errors: ['bad field'],\n});\n// Marks the field as touched, while resetting its value and errors.\nresetField({\n  touched: true,\n});\n// Changes the meta, initial and current values and sets the errors for the field\nresetField({\n  value: 'new value',\n  touched: true,\n  errors: ['bad field'],\n});\n\nNote that it is unsafe to use this function as an event handler directly, check the following snippet:\n\nvue\n<!-- ⛔️ Unsafe -->\n<button @click=\"resetField\">Reset</button>\n<!-- ✅  Safe -->\n<button @click=\"resetField()\">Reset</button>\n\nYou can also use handleReset which is a safe alternative for resetField.\n\nsetErrors: (errors: string | string[]) => void\n\nSets then field errors, you can pass a single message string or an array of errors.\n\njs\nconst { setErrors } = useField('field', value => !!value);\n// Sets a the errors to a single error message\nsetErrors('field is required');\n// sets the errors to multiple error messages\nsetErrors(['field is required', 'field must be valid']);\n// clears the errors\nsetErrors([]);\n\nhandleReset: () => void\n\nSimilar to resetField but it doesn’t accept any arguments and can be safely used as an event handler. The values won’t be validated after reset.\n\njs\nconst { handleReset } = useField('field', value => !!value);\n// reset the field validation state and its initial value\nhandleReset();\n\nvalidate: () => Promise<{ errors: string[] }>\n\nValidates the field’s current value and returns a promise that resolves with an object containing the error messages emitted by the various rule(s).\n\njs\nconst { validate } = useField('field', value => !!value);\n// trigger validation\nawait validate();\n\nhandleChange: (evt: Event | any) => void\n\nUpdates the field value, and validates the field. Can be used as an event handler to bind on the field. If the passed argument isn’t an event object it will be used as the new value for that field.\n\nIt sets the dirty meta flag to true\n\nvue\n<template>\n  <input @change=\"handleChange\" type=\"text\" />\n</template>\n<script setup>\nconst { handleChange } = useField('field');\nhandleChange('new value'); // update field value and validate it\nhandleChange('new value 2', false); // update field value without validating it (you have to turn off validateOnValueUpdate)\n</script>\n\nhandleBlur: (evt: Event | any) => void\n\nSets the touched meta flag to true\n\nvue\n<template>\n  <input @blur=\"handleBlur\" type=\"text\" />\n</template>\n<script setup>\nconst { handleBlur } = useField('field');\n</script>\n\nsetTouched: (isTouched: boolean) => void\n\nSets the touched meta flag for this field, useful to create your own blur handlers\n\njs\nconst { setTouched } = useField('field', value => !!value);\n// mark the field as touched\nsetTouched(true);\n\nchecked: ComputedRef<boolean> | undefined\n\nA computed property that indicates if the field should be checked or unchecked, only available if type=checkbox or type=radio in field options. Useful if you are creating custom checkboxes.\n\njs\nconst { checked } = useField('field', ..., {\n  type: 'checkbox',\n  valueProp: 'Checkbox value'\n});\nchecked.value; // true or false\n\nFor more information on how you might use the checked property, check the custom checkboxes example."
  },
  {
    "title": "FieldArray",
    "url": "https://vee-validate.logaretm.com/v4/api/field-array/",
    "html": "FieldArray v4.5\n\nForm Context\n\nThe <FieldArray /> component requires being used inside a Form component or a useForm to be called at its parent tree.\n\nThe <FieldArray /> component is used to manage repeatable array fields. It is a renderless component, meaning it doesn’t render anything of its own.\n\nvue\n<template>\n  <Form @submit=\"onSubmit\" :initial-values=\"initialValues\">\n    <FieldArray name=\"links\" v-slot=\"{ fields, push, remove }\">\n      <div v-for=\"(field, idx) in fields\" :key=\"field.key\">\n        <Field :name=\"`links[${idx}].url`\" type=\"url\" />\n        <button type=\"button\" @click=\"remove(idx)\">Remove</button>\n      </div>\n      <button type=\"button\" @click=\"push({ id: Date.now(), name: '', url: '' })\">Add</button>\n    </FieldArray>\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\n// you can set initial values for those array fields\nconst initialValues = {\n  links: [{ id: 1, url: 'https://github.com/logaretm' }],\n};\nfunction onSubmit(values) {\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\nAPI Reference\nProps\nProp\tType\tRequired/Default\tDescription\narrayPath\tstring\tYes\tThe form array path you wish to manage\nSlots\ndefault\n\nThe default slot gives you access to the following props:\n\nfields: FieldArrayEntry<TValue>\n\nThis is a read-only version of your array items, wrapped inside a FieldArrayEntry object which has the following interface:\n\nts\ninterface FieldEntry<TValue = unknown> {\n  // The actual value of the item, this is what exists in the form values\n  value: TValue;\n  // a value you can use as a key for iteration, automatically generated.\n  key: string | number;\n  // true if this is the first array item\n  isFirst: boolean;\n  // true if this is the last array item\n  isLast: boolean;\n}\n\npush(item: any)\n\nAdds an item to the end of the array.\n\nprepend(item: any)\n\nAdds an item to the start of the array.\n\nremove(idx: number)\n\nRemoves the item at the specified index from the array if it exists.\n\nswap(idxA: number, idxB: number)\n\nSwaps the items at the given indexes with each other. Both indexes must exist in the array or it won’t have an effect.\n\ninsert(idx: number, item: any)\n\nAdds an item at the specified index. If the specified index will place the item out of bounds (i.e: larger than length) the operation will be ignored, you still can add items as the last item of the array.\n\nupdate(idx: number, value: any)\n\nUpdates the value at the specified index, note that it doesn’t merge the values if they are objects. If the specified index is outside the array boundary the operation will be ignored.\n\nreplace(items: any[])\n\nReplaces the entire array of fields.\n\nmove(oldIdx: number, newIdx: number)\n\nMoves an array item to a different position within the array. If one of the indices is outside of the array boundaries the operation will be ignored."
  },
  {
    "title": "ErrorMessage",
    "url": "https://vee-validate.logaretm.com/v4/api/error-message/",
    "html": "ErrorMessage\n\nThe ErrorMessage component is used to conveniently display error messages without resorting to scoped slots on either the Form and Field components. It also renders nothing if there are no messages for the associated field.\n\nThe basic usage looks like this:\n\nvue\n<template>\n  <Form>\n    <Field name=\"email\" type=\"email\" :rules=\"validateEmail\" />\n    <ErrorMessage name=\"email\" />\n  </Form>\n</template>\n<script setup>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst validateEmail = yup.string().required().email();\n</script>\nRendering Messages\n\nThe ErrorMessage component accepts an as prop that allows to control the root node to render for your error messages, by default it will render a span if none provided if there is an error message for the field.\n\nvue\n<ErrorMessage name=\"email\" as=\"p\" />\n\nFor more flexible markup and the ability to render multiple root nodes, you can use the ErrorMessage component’s default scoped slot\n\nvue\n<ErrorMessage name=\"email\" v-slot=\"{ message }\">\n  <p>Error:</p>\n  <p>{{ message }}</p>\n</ErrorMessage>\n\nIf an as prop is not provided while having a slot, it will render the slot contents only. Effectively becoming a renderless-component.\n\nYou can use a combination of both to render a root node with children:\n\nvue\n<ErrorMessage as=\"div\" name=\"email\" v-slot=\"{ message }\">\n  <p>Error:</p>\n  <p>{{ message }}</p>\n</ErrorMessage>\n\nNo Errors Rendering\n\nWhen there are not any error messages for the field the <ErrorMessage /> component will render nothing, even if you used the slot or as prop.\n\nAPI\nProps\nProp\tType\tRequired/Default\tDescription\nas\tstring\t\"span\"\tThe element to render as a root node\nname\tstring\tRequired\tThe field’s name to display messages for\nSlots\ndefault\n\nThe default slot gives you access to the following props:\n\nScoped Prop\tType\tDescription\nmessage\tstring\tThe element’s error message\n\nCheck the sample above for rendering with scoped slots\n\nCaveats\nThe ErrorMessage component must be used inside a Form component otherwise it won’t be able to find the errors.\nErrorMessage component can only display errors for a field that exists within the same form, it cannot reference fields outside its own form."
  },
  {
    "title": "Form",
    "url": "https://vee-validate.logaretm.com/v4/api/form/",
    "html": "Form\nForm Component\n\nThe <Form /> component is like its name, a simple HTML form but with a few adjustments and DX improvements, By default it will render a native HTML form element.\n\nvue\n<Form>\n  <Field name=\"password\" type=\"password\" />\n</Form>\nRendering Forms\n\nJust like the Field component you can pass whatever you want to render in its place, for example a custom v-form component that is registered globally:\n\nvue\n<Form as=\"v-form\">\n  <Field name=\"password\" type=\"password\" />\n</Form>\n\nBy default a submit and reset listeners are added to the rendered tag specified by the as prop.\n\nFor more complex form markup, you can render a div and inline your forms in the Form component’s slots.\n\nvue\n<Form as=\"div\">\n  <h2>Sign up form</h2>\n  <form>\n    <Field name=\"name\" />\n    <Field name=\"email\" type=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n  </form>\n</Form>\n\nHTML Case Insensitivity\n\nNotice the character-case difference between Form and form, the uppercased one is the component provided by vee-validate while the lowercased one is the native form element, you might run into issues when not using Vue compiler workflow like script tags. In these cases it is recommended to rename the Form component to something that will not conflict with native HTML.\n\njs\n// Using named imports\nimport { Form as ValidationForm } from 'vee-validate';\nconst component = {\n  components: {\n    // If you have VeeValidate globally via a CDN script\n    ValidationForm: VeeValidate.Form,\n  },\n};\n\nLastly, you can use the Form component slot props to access various aspects of the form state:\n\nvue\n<Form v-slot=\"{ values }\">\n  <Field name=\"name\" />\n  <Field name=\"email\" type=\"email\" />\n  <Field name=\"password\" type=\"password\" />\n  <!-- prints current form values -->\n  <pre>\n    {{ values }}\n  </pre>\n</Form>\nRenderless Forms\n\nWhile not recommended, you can make the Form component a renderless component by passing an empty string to the as prop, this is useful if you already need to add a form inside the scoped slot:\n\nvue\n<Form as=\"\" v-slot=\"{ values, submitForm }\">\n  <h2>Sign up form</h2>\n  <form @submit=\"submitForm\">\n    <Field name=\"name\" />\n    <Field name=\"email\" type=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <!-- prints current form values -->\n    <pre>\n      {{ values }}\n    </pre>\n  </form>\n</Form>\nAPI Reference\nProps\nProp\tType\tDefault\tDescription\nas\tstring\t\"form\"\tThe element to render as a root node\nvalidationSchema\tRecord<string, string | Function>\tundefined\tAn object describing a schema to validate fields with, can be a plain object or a yup object schema\ninitialValues\tRecord<string, any>\tundefined\tInitial values to fill the fields with, when provided the fields will be validated on mounted\ninitialErrors\tRecord<string, string>\tundefined\tInitial form errors to fill the fields with, the errors will be added when the form component is mounted\ninitialTouched\tRecord<string, boolean>\tundefined\tInitial touched fields, the status will be applied when the form component is mounted\nvalidateOnMount\tboolean\tfalse\tIf true, the fields currently present in the form will be validated when the <Form /> component is mounted\nkeepValues\tboolean\tfalse\tIf the fields values should be deleted when they get unmounted, default is false\nSlots\ndefault\n\nThe default slot gives you access to the following props:\n\nerrors: Record<string, string>\n\nAn object that maps field names to their error messages, it only takes the first error message of each field if multiple exists.\n\nHere is an example of its shape:\n\njs\n{\n  email: \"this field must be a valid email\",\n  password: \"too short\"\n}\n\nAny fields without error messages will not be included in the object. So you can safety iterate over it with Object.keys() knowing all the included fields are invalid.\n\nerrorBag: Record<string, string>\n\nAn object that maps field names to all of their error messages.\n\nHere is an example of its shape:\n\njs\n{\n  email: [\"this field is required\", \"this field must be a valid email\"],\n  password: \"too short\"\n}\n\nAny fields without error messages will not be included in the object. So be careful when accessing the errors array for each field\n\nisSubmitting: boolean\n\nIndicates if the submission handler is still running, once it resolves/rejects it will be automatically set to false again.\n\nisValidating: boolean\n\nIndicates if the validate function is still running, once validate function is done it will be automatically set to false again.\n\nmeta: FormMeta\n\nContains an aggregated meta information/flags reflecting the state of all the fields inside the form.\n\nts\ninterface FormMeta {\n  touched: boolean; // if at least one field is touched (was blurred)\n  dirty: boolean; // if at least one field is dirty (manipulated)\n  valid: boolean; // if all fields are valid\n  pending: boolean; // if at least one field is pending validation\n  initialValues?: Record<string, any>; // a map of the form's initial values\n}\n\nvalues: Record<string, any>\n\nContains the current form values\n\nsetFieldError: (field: string, message: string) => void\n\nSets a field’s error message, useful for setting messages form an API or that are not available as a validation rule.\n\nIf you try to set an error for a field that doesn’t exist, it will be added to the form’s errors object and it will change the form’s valid state\n\nsetErrors: (fields: Record<string, string>) => void\n\nSets multiple fields error messages, uses setFieldError internally.\n\nsetFieldValue: (field: string, value: any) => void\n\nSets a field’s value, if a field does not exist it will not be reflected in the values ref. This will trigger validation on the field whose value changed.\n\nIf you try to set a value for a field that doesn’t exist, it will be added to the form’s values object and will stay there until the next resetForm is called.\n\nsetValues: (fields: Record<string, any>) => void\n\nSets all fields values, will trigger validation for the changed fields.\n\nsetFieldTouched: (field: string, isTouched: boolean) => void\n\nSets a field’s touched meta flag, if you set it for a non-existing field it will have no effect.\n\nsetTouched: (fields: Record<string, boolean>) => void\n\nSets multiple fields touched meta flag, does not validate.\n\nvalidate: () => Promise<{ valid: boolean; errors: Record<string, string>}>\n\nValidates all the fields and populates the errors object, returns a promise that resolves to an object containing aggregated validation result of all fields.\n\nvalidateField: (field: string) => Promise<{ valid: boolean; errors: string[] }>\n\nValidates a specific field inside the form, returns a promise that resolves to an object containing the validation result.\n\nhandleSubmit: (evt: Event, cb: (values: Record<string, any>, ctx: SubmissionContext) => any) => Promise<void>\n\nThis can be used as an event handler for submit events, it accepts the event object and a callback function that will run if the form is valid. If an event object is provided, preventDefault and stopPropagation will be automatically called on it.\n\nNote that this is only useful if you are not rendering a form tag on the <Form /> component. By default the Form component uses this handler to handle any submit events.\n\nsubmitForm: (evt: Event) => void\n\nThis function can also be used as an event handler for form submit event, the different that it will prevent the propagation and submission of the form as long as they are invalid. Once all the fields are valid it will submit the form with the native HTML behavior following the form element’s action and method attributes.\n\nThis is useful if you plan to handle form submissions using a backend API like Laravel.\n\nsubmitCount: number\n\nThe number of submission attempts by the user, it increments whenever submitForm or handleSubmit callback are called.\n\nhandleReset: () => void\n\nClears error messages, resets the meta state for all fields and reverts their values to their initial state and resets the submitCount to 0. You can use this function as handler for the reset events on native form elements.\n\nresetForm: (state?: Partial<FormState>) => void\n\nClears error messages, resets the meta state for all fields and reverts their values to their initial state and resets the submitCount.\n\nAccepts an optional object containing the new form state, useful if you need to reset the form values to different values other than their initial state.\n\nThis is the shape of the state object:\n\nts\ninterface FormState {\n  // any error messages\n  errors: Record<string, string>;\n  // touched meta flags\n  touched: Record<string, boolean>;\n  // Form Values\n  values: Record<string, any>;\n  // The form submit attempts count\n  submitCount: number;\n}\n\nIn the following example the form is resetting the email field value to another value, this will change the field current value as well as it’s initial value. Meaning any future calls of resetForm without arguments or handleReset will use example@example.com as their value. This also applies if fields are reset individually using resetField on either useField return value or <Field /> component’s slot props.\n\nvue\n<Form v-slot=\"{ resetForm }\">\n  ...\n  <button @click=\"resetForm({ values: { email: 'example@example.com' } })\" type=\"button\">Reset</button>\n</Form>"
  },
  {
    "title": "Nuxt integration",
    "url": "https://vee-validate.logaretm.com/v4/integrations/nuxt/",
    "html": "@vee-validate/nuxt\n\nOfficial vee-validate’s Nuxt module\n\nFeatures\nAuto import of vee-validate components\nAuto import of vee-validate composables\nDetecting if you are using zod or yup and exposing the toTypedSchema suitable for either.\n\nWARN\n\nNo types are exposed by default to avoid having conflicts with other libraries, aside from vee-validate’s main API components/composables. You can still import them via vee-validate.\n\nGetting Started\n\nIn your nuxt project install the vee-validate nuxt module:\n\nsh\n# npm\nnpm i @vee-validate/nuxt\n# pnpm\npnpm add @vee-validate/nuxt\n# yarn\nyarn add @vee-validate/nuxt\n\nThen add the module to your modules config in nuxt.config.ts:\n\nts\nexport default defineNuxtConfig({\n  // ...\n  modules: [\n    //...\n    '@vee-validate/nuxt',\n  ],\n});\nConfiguration\n\nYou can configure a few aspects of the @vee-validate/nuxt module. Here is the config interface:\n\nts\nexport default defineNuxtConfig({\n  // ...\n  modules: [\n    //...\n    [\n      '@vee-validate/nuxt',\n      {\n        // disable or enable auto imports\n        autoImports: true,\n        // Use different names for components\n        componentNames: {\n          Form: 'VeeForm',\n          Field: 'VeeField',\n          FieldArray: 'VeeFieldArray',\n          ErrorMessage: 'VeeErrorMessage',\n        },\n      },\n    ],\n  ],\n});\n\nYou can also use the veeValidate config key instead of the array syntax:\n\nts\nexport default defineNuxtConfig({\n  // ...\n  modules: [\n    //...\n    '@vee-validate/nuxt',\n  ],\n  veeValidate: {\n    // disable or enable auto imports\n    autoImports: true,\n    // Use different names for components\n    componentNames: {\n      Form: 'VeeForm',\n      Field: 'VeeField',\n      FieldArray: 'VeeFieldArray',\n      ErrorMessage: 'VeeErrorMessage',\n    },\n  },\n});"
  },
  {
    "title": "Field",
    "url": "https://vee-validate.logaretm.com/v4/api/field/",
    "html": "Field\n\nThe <Field /> component is an extremely flexible component that makes rendering input fields easy and intuitive, By default it renders an HTML input tag. So a simple text input can be rendered like this:\n\nvue\n<template>\n  <Field name=\"field\" type=\"text\" />\n</template>\n<script setup>\nimport { Field } from 'vee-validate';\n</script>\nRendering Fields\n\nThe Field component allows you to render practically anything and gives you complete flexibility and control over how your fields are rendered. The Field component renders an HTML input tag if not specified otherwise. Which can be done in two ways.\n\nRendering simple fields with ‘as’ prop\n\nThe as prop tells the Field component which tag to render in its place, you can pass any additional attributes like type=\"text\" and it will be passed to the rendered input tag as well as any listeners and slots.\n\nFor example you could render a select input like this:\n\nvue\n<Field name=\"field\" as=\"select\">\n  <option>Coffee</option>\n  <option>Tea</option>\n  <option>Coke</option>\n</Field>\n\nTIP\n\nThe Field component has partial support for native select[multiple] element, while it picks up the multiple values correctly, it doesn’t set the initial values UI state on the element itself. You may use v-model here or bind the selected attributes on the options which is straightforward with the value prop exposed on the slot props.\n\nvue\n<Field v-slot=\"{ value }\" name=\"drink\" as=\"select\" multiple>\n  <option value=\"\" disabled>Select a drink</option>\n  <option v-for=\"drink in drinks\" :key=\"drink\" :value=\"drink\" :selected=\"value && value.includes(drink)\">{{ drink }}</option>\n</Field>\n\nYou can also render any globally defined components:\n\nvue\n<Field name=\"field\" as=\"my-text-field\" />\n\nTIP\n\nFor validation to work, the rendered tag with as prop must conform to the events that the Field component listens for, you can view a list of these in the Validation Behavior\n\nRendering Complex Fields with Scoped Slots\n\nThe as prop is very easy to use but also limited as you cannot render a group of markup. Fortunately the Field component makes use of the scoped-slots (v-slot) feature to allow you to render complex markup:\n\nvue\n<Field name=\"password\" v-slot=\"{ field }\">\n  <input v-bind=\"field\" type=\"password\">\n  <p>Hint: Enter a secure password you can remember</p>\n</Field>\n\nThe most crucial part of rendering fields with v-slot is that you bind the field object to your input element/input, the field object contains all the common attributes and listeners required for the field to be validated, this is done automatically if you are using the as prop.\n\nFile Inputs and Custom Components\n\nWhen rendering File inputs and custom components, binding the field object may not be a good idea in these cases as generally you need to pick the suitable attributes that you should bind. In the case of input[type=\"file\"] you could do something like this:\n\nvue\n<Field name=\"file\" v-slot=\"{ handleChange, handleBlur }\">\n  <input type=\"file\" @change=\"handleChange\" @blur=\"handleBlur\" />\n</Field>\n\nThis is because the file input doesn’t work with two-way binding since you cannot really force pick a file from a user’s device. Custom components may emit different events and may have additional requirements for two-way binding to work. You can check the UI Libraries section for a few examples on how to do that.\n\nWhen using v-slot on the Field component you no longer have to provide an as prop and then it will become a renderless component.\n\nPassing Props and Attrs\n\nWhichever element/component you chose to render with <Field /> you can pass also any props or attributes the element/component would normally recieve for example if you render input elements you can pass any of it’s attributes like type or disabled to just name a few.\n\nUsing v-model\n\nThe <Field /> component uses a different way to apply input values to your rendered inputs using the v-bind=\"field\" syntax which adds various listeners and attributes to your rendered inputs.\n\nBecause of this, using v-model will conflict with v-bind=\"field\" because both will attempt to update the input value.\n\nFor simple inputs this is not an issue:\n\nvue\n<!-- ✅  Simple Field -->\n<Field type=\"text\" name=\"name\" v-model=\"name\" />\n\nBut for complex inputs rendered with scoped slots (v-slot), you need to place it on the Field component tag itself, not the rendered input.\n\nvue\n<!-- DONT: ⛔️  v-model on input tag -->\n<Field type=\"text\" name=\"name\" v-slot=\"{ field }\">\n  <!-- Conflict between v-model and `v-bind=field` -->\n  <input v-bind=\"field\" v-model=\"name\">\n</Field>\n<!-- DO: ✅  v-model on field tag -->\n<Field v-model=\"name\" type=\"text\" name=\"name\" v-slot=\"{ field }\">\n  <input v-bind=\"field\">\n</Field>\n\nNote that you no longer should use v-model on your input as v-bind=\"field\" will take care of the rest.\n\nAPI Reference\nProps\nProp\tType\tRequired/Default\tDescription\nas\tstring\t\"span\"\tThe element to render as a root node, defaults to input\nname\tstring\tRequired\tThe field’s name, must be inside <Form />\nrules\tobject | string | Function\tnull\tThe field’s validation rules\nvalidateOnMount\tboolean\tfalse\tIf true, field will be validated when the component is mounted\nvalidateOnInput\tboolean\tfalse\tIf true, field will be validated when input event is dispatched/emitted\nvalidateOnChange\tboolean\ttrue\tIf true, field will be validated when change event is dispatched/emitted\nvalidateOnBlur\tboolean\ttrue\tIf true, field will be validated when blur event is dispatched/emitted\nvalidateOnModelUpdate\tboolean\ttrue\tIf true, field will be validated when update:modelValue event is emitted\nbails\tboolean\ttrue\tStops validating as soon as a rule fails the validation\nlabel\tstring\tundefined\tA different string to override the field name prop in error messages, useful for display better or formatted names. The generated message won’t be updated if this prop changes, you will need to re-validate the input.\nvalue\tany\tundefined\tThe field’s initial value, optional as long as the field type is not checkbox or radio.\ntype\tstring\tundefined\tThe field type, must be provided if you want your field to behave as a checkbox or a radio input.\nunchecked-value\tany\tundefined\tOnly useful when the type=\"checkbox\" and the field is a single checkbox field (not bound to an array value). Controls the input’s value when it’s unchecked.\nstandalone\tboolean\tfalse\tExcludes the field from participating in any Form or useForm contexts, useful for creating inputs that do contribute to the values object. In other words, the form won’t pick up or validate fields marked as standalone\nkeepValue\tboolean\tundefined\tIf the field value should be kept in the form when it gets unmounted, default follows the form’s configuration\nSlots\ndefault\n\nThe default slot gives you access to the following props:\n\nmeta: FieldMeta\n\nContains useful information/flags about the field status.\n\nts\ninterface FieldMeta {\n  touched: boolean; // if the field has been blurred (via handleBlur)\n  dirty: boolean; // if the field has been manipulated (via handleChange)\n  valid: boolean; // if the field doesn't have any errors\n  validated: boolean; // if the field has been validated\n  pending: boolean; // if validation is in progress\n  initialValue?: any; // the field's initial value\n}\n\nThe valid flag\n\nThe valid flag on the meta object can be tricky, because by default it stars off with true for a few moments, only then it is updated to its proper state.\n\nCombining your valid flag checks with dirty will yield the expected result based on user interaction.\n\nerrors: string[]\n\nAn array containing all error messages for the field.\n\nvalue: unknown\n\nThe current value of the field, useful to compare and do conditional rendering based on the field value. You should not use it as a target of v-model or :value binding. Instead use the field prop.\n\nerrorMessage: ComputedRef<string | undefined>\n\nThe first error in the errors array if available, a handy shortcut to display error messages\n\nresetField: (state?: Partial<FieldState>) => void\n\nResets the field’s validation state, reverts all meta object to their default values and clears out the error messages, it will also reset the field value to it’s initial value. Note that no error messages will be generated if the initial value is invalid after reset, the valid flag will be then set to true in that case.\n\nNote that it is unsafe to use this function as an event handler directly, check the following snippet:\n\nvue\n<!-- ⛔️ Unsafe -->\n<button @click=\"resetField\">Reset</button>\n<!-- ✅  Safe -->\n<button @click=\"resetField()\">Reset</button>\n\nYou can use resetField to update the fields’ current value to something other than its initial value,\n\nvue\n<button @click=\"resetField({ value: 'new value' })\">Reset</button>\n\nhandleReset: () => void\n\nSimilar to resetField but it doesn’t accept any arguments and can be safely used as an event handler. The values won’t be validated after reset.\n\nvalidate: () => Promise<{ errors: string[] }>\n\nValidates the field’s current value and returns a promise that resolves with an object containing the error messages emitted by the various rule(s).\n\njs\nconst { validate } = useField('field', value => !!value);\n// trigger validation\nawait validate();\n\nhandleChange: (evt: Event | any, shouldValidate?: boolean) => void\n\nUpdates the field value, and validates the field vt default. Can be used as an event handler to bind on the field. If the passed argument isn’t an event object it will be used as the new value for that field.\n\nYou can update the field value without validation by passing false as a second argument.\n\nhandleBlur: (evt: Event | any) => void\n\nValidates the field by default unless explicitly specified by validation triggers. Can be used as an event handler to bind on the field. If the passed argument isn’t an event object it will be used as the new value for that field.\n\nIt sets the touched meta flag to true\n\nBecause this handler doesn’t set the field value, it might not report validation correctly if other events are unspecified or disabled.\n\nsetTouched: (isTouched: boolean) => void\n\nSets the touched meta flag for this field, useful to create your own blur handlers\n\nfield\n\nContains a few properties that you can use v-bind with to get all vee-validate features on that input. The following is a description of the properties\n\nfield.value: any\n\nThe field’s current value, you can bind it with value prop on your inputs to sync both values. Don’t use it with v-model otherwise your input will freeze.\n\nfield.name: string\n\nThe field name.\n\nfield.onBlur: Function[]\n\nAn array containing a few listeners for the blur event, it involves updating some meta information and triggers validation by default.\n\nfield.onInput: Function[]\n\nAn array containing a few listeners for the input event, it involves updating the field value and some meta information.\n\nfield.onChange: Function[]\n\nAn array containing a few listeners for the change event, it involves updating the field value and triggering validation.\n\ncomponentField\n\nSame as field, but provides value as modelValue to use with components"
  },
  {
    "title": "Dynamic validation triggers",
    "url": "https://vee-validate.logaretm.com/v4/examples/dynamic-validation-triggers/",
    "html": "Dynamic validation triggers\n\nIn previous versions of vee-validate you could configure what events trigger the validation based on the field state. This feature was called “interaction modes”. In vee-validate v4 this feature was removed because it is now possible to implement it with the composition API.\n\nThis example should help you figure out how to migrate this feature from older vee-validate versions."
  },
  {
    "title": "Value formatting and Masks",
    "url": "https://vee-validate.logaretm.com/v4/examples/value-formatting/",
    "html": "Value Formatting and Masks\n\nSome inputs may have a mask applied to them, that is their value is displayed in a different way than the actual value to make it more friendly towards the user.\n\nFor example, a currency input could insert a thousand separator to make it easier for the user to enter and read large numbers.\n\nsh\n# hard to read\n10000000\n# Much easier\n10,000,000\n\nIt can be confusing as to how would you run your numeric validation rules on such inputs. The following examples show you how to handle such inputs by separating the “display value” from the actual value.\n\nCurrency Format Example\n\nThe following example integrates vue-currency-input using the composition API. While it is still possible to do it with the <Field /> component, it is significantly easier to work with the composition API in this case.\n\nThe main key to getting this right is to sync the value in multiple formats, the formatted one, and the non-formatted value.\n\nIdeally, vee-validate should be synced with the non-formatted one, you can do this by updating the value manually using setValue or handleChange."
  },
  {
    "title": "Formvuelate Integration",
    "url": "https://vee-validate.logaretm.com/v4/integrations/formvuelate/",
    "html": "Formvuelate Integration\n\nFormvuelate is an excellent schema-driven form generator that’s very flexible, it also allows you to use your own components to generate your forms.\n\nFormvuelate supports vee-validate very well and both of vee-validate’s and formvuelate features play together nicely.\n\nCheck Formvuelate documentation for more information."
  },
  {
    "title": "Zod Schema Validation",
    "url": "https://vee-validate.logaretm.com/v4/integrations/zod-schema-validation/",
    "html": "Zod Schema Validation\n\nIf you prefer to use zod for schema validation instead of yup, you can do so with the @vee-validate/zod package.\n\nWith @vee-validate/zod you can use Zod typed schemas as drop-in replacements for yup schemas.\n\nInstall\n\nTo use this plugin, make sure to install these packages vee-validate, zod, and @vee-validate/zod.\n\nsh\nyarn add vee-validate zod @vee-validate/zod\n# or with NPM\nnpm install vee-validate zod @vee-validate/zod\n# or with Pnpm\npnpm add vee-validate zod @vee-validate/zod\nValidating with Zod\n\nYou can create validation schemas for either field-level validation or form-level validation, the @vee-validate/zod exposes a toTypedSchema function that transform Zod’s schemas into something that can be understood by vee-validate main core and use them to perform validation. It also allows vee-validate to figure out the types for both the input values and the submitted values.\n\nField-level Validation\n\nThe toTypedSchema function accepts a Zod schema. You can use the converted schema by passing it to the rules prop present on the <Field /> component:\n\nvue\n<template>\n  <Form>\n    <Field name=\"email\" type=\"email\" :rules=\"fieldSchema\" />\n    <ErrorMessage name=\"email\" />\n  </Form>\n</template>\n<script setup>\nimport { Field, Form, ErrorMessage } from 'vee-validate';\nimport { toTypedSchema } from '@vee-validate/zod';\nimport * as zod from 'zod';\nconst fieldSchema = toTypedSchema(zod.string().nonempty('Field is required').email('Must be a valid email'));\n</script>\n\nIf you prefer to use the Composition API, then you can pass the converted schema to the useField function:\n\nvue\n<template>\n  <input name=\"email\" v-model=\"value\" type=\"email\" />\n  <span>{{ errorMessage }}</span>\n</template>\n<script setup>\nimport { useField } from 'vee-validate';\nimport { toTypedSchema } from '@vee-validate/zod';\nimport * as zod from 'zod';\nconst fieldSchema = toTypedSchema(\n  zod.string().nonempty('Field is required').email({ message: 'Must be a valid email' })\n);\nconst { value, errorMessage } = useField('email', fieldSchema);\n</script>\nForm-Level Validation\n\nYou can also use Zod’s zod.object to create validation schemas for your forms instead of individually passing it for each field, this is covered in general in the form-level validation section.\n\nTo be able to use zod.object to define form schemas, you will be using the same toTypedSchema function.\n\nYou can pass the converted schema to the validation-schema prop present on the <Form /> component:\n\nvue\n<template>\n  <Form :validation-schema=\"validationSchema\" @submit=\"onSubmit\">\n    <Field name=\"email\" type=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nimport { toTypedSchema } from '@vee-validate/zod';\nimport * as zod from 'zod';\nconst validationSchema = toTypedSchema(\n  zod.object({\n    email: zod.string().nonempty('This is required').email({ message: 'Must be a valid email' }),\n    password: zod.string().nonempty('This is required').min(8, { message: 'Too short' }),\n  })\n);\nfunction onSubmit(values) {\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\n\nAlternatively, if you prefer to use the composition API, you can pass the converted schema as the validationSchema option accepted by the useForm function:\n\nvue\n<template>\n  <form @submit=\"onSubmit\">\n    <input name=\"email\" v-model=\"email\" type=\"email\" />\n    <span>{{ errors.email }}</span>\n    <input name=\"password\" v-model=\"password\" type=\"password\" />\n    <span>{{ errors.password }}</span>\n    <button>Submit</button>\n  </form>\n</template>\n<script setup>\nimport { useField, useForm } from 'vee-validate';\nimport { toTypedSchema } from '@vee-validate/zod';\nimport * as zod from 'zod';\nconst validationSchema = toTypedSchema(\n  zod.object({\n    email: zod.string().nonempty('This is required').email({ message: 'Must be a valid email' }),\n    password: zod.string().nonempty('This is required').min(8, { message: 'Too short' }),\n  })\n);\nconst { handleSubmit, errors } = useForm({\n  validationSchema,\n});\nconst { value: email } = useField('email');\nconst { value: password } = useField('password');\nconst onSubmit = handleSubmit(values => {\n  alert(JSON.stringify(values, null, 2));\n});\n</script>\n\nTypeScript Form Values Inference\n\nYou can find more information on how typed schemas work in vee-validate here\n\nrefine/superRefine\n\nThere is a known issue with Zod’s refine and superRefine not executing whenever some object keys are missing which is common with forms. This is not an issue with vee-validate as it is a design choice in Zod at the moment. Refer to this issue for explanations and further reading."
  },
  {
    "title": "Popular UI Libraries",
    "url": "https://vee-validate.logaretm.com/v4/examples/ui-libraries/",
    "html": "UI Libraries Examples\n\nMost popular Vue.js UI libraries come with their own built-in form logic and some may tackle a lot of what vee-validate tackles. If you find yourself not satisfied with said library’s logic, you can add vee-validate power up these components.\n\nvee-validate is UI-agnostic, it doesn’t offer any special treatment for the elements/components as long as they emit the right events.\n\nIntegrating vee-validate can be different for each UI library, it mostly depends on the library’s ability to outsource the form logic to 3rd party logic and how it tracks the form field values.\n\nIn the next few examples you will find examples on how to do that in various ways with the most popular Vue.js libraries in no particular order.\n\nVuetify\n\nVuetify is a no design skills required UI Library with beautifully handcrafted Vue Components.\n\nCheck their official example here.\n\nPrimeVue\n\nPrimeVue is a rich set of open source UI Components for Vue.\n\nCheck their official example here.\n\nQuasar\n\nQuasar framework aims to:\n\nEffortlessly build high-performance & high-quality Vue 3 user interfaces in record time\n\nElement Plus\n\nElement Plus, a Vue 3.0 based component library for developers, designers and product managers\n\nHeadless UI\n\nHeadless UI, a completely unstyled, fully accessible UI components, designed to integrate beautifully with Tailwind CSS.\n\nIonic Framework\n\nIonic Framework, An open source mobile toolkit for building high quality, cross-platform native and web app experiences.\n\nThis example is originally forked from another example created by Aaron Saunders.\n\nAnt Design\n\nAnt Design provides plenty of UI components to enrich your web applications, and we will improve components experience consistently.\n\nNuxt UI\n\nNuxt UI is a Fully styled and customizable components for Nuxt.js\n\nNaive UI\n\nNaïve UI Fairly Complete, Theme Customizable, Uses TypeScript, Fast, Kinda Interesting\n\nBootstrap Vue\n\nWith BootstrapVue you can build responsive, mobile-first, and ARIA accessible projects on the web using Vue.js and the world’s most popular front-end CSS library\n\nRequest a UI library\n\nCan’t find your favorite UI library here? You can request adding an example for it by creating an issue here and we will consider adding it here."
  },
  {
    "title": "State Stores",
    "url": "https://vee-validate.logaretm.com/v4/examples/using-stores/",
    "html": "Stores\n\nIf you want to integrate vee-validate with state management solutions you can do that with the composition API.\n\nPinia\n\nPinia is a data store for Vue.js and it is the recommended solution to your Vue.js state management.\n\nThe example integrates a form state into the store by utilizing a setup function when defining a store. This makes vee-validate act as a state provider for the form where the form values become your store state and submit function becomes your store action."
  },
  {
    "title": "Multi-step Form Wizard",
    "url": "https://vee-validate.logaretm.com/v4/examples/multistep-form-wizard/",
    "html": "Multi-step Form Wizard\n\nThese examples showcases a simple multi-step form (form wizard), with next and previous step navigation.\n\nHigher Order Components\n\nThis example uses the higher-order components only.\n\nComposition API\n\nThis example uses the composition API to construct a system of <FormStep> and <FormWizard> components to make building form steps easier."
  },
  {
    "title": "Custom Checkboxes",
    "url": "https://vee-validate.logaretm.com/v4/examples/custom-checkboxes/",
    "html": "Custom Checkboxes\n\nCheckboxes are more complex than regular text inputs, because there is always two states to keep track of which can be confusing at first. Mainly you should keep track of:\n\nEach individual input’s value\nWhich inputs are current selected\n\nTo make this easier, remember that native checkboxes behave as a group while each input maintains it’s own value. Then a checkbox said to be checked when either:\n\nIt’s value is the one currently selected\nIt’s value is included in the ones selected\n\nThis is because of the nature of checkboxes behaving as “multi-value” form inputs, so you need to keep track of each input’s value and the currently selected one(s).\n\nWith all of that in mind, vee-validate offers simple abstractions for checkboxes. You can build your own checkboxes with vee-validate’s useField function which gives you the full capabilities of validation in a composable fashion.\n\nBecause useField isn’t aware of what kind of input will be composed with it, you will need to specify that the input is of type checkbox and pass a checkedValue as well which represents that single field’s value. By doing so, you gain access to checked prop which tells you if the checkbox should be selected.\n\njs\nimport { useField } from 'vee-validate';\nexport default {\n  props: {\n    // The group's value\n    modelValue: {\n      type: null,\n    },\n    // Field's own value\n    value: {\n      type: null,\n    },\n    name: {\n      type: String,\n    },\n    rules: {\n      type: String,\n      default: undefined,\n    },\n  },\n  setup(props) {\n    // We pass a function to make sure the name stays reactive\n    const { checked, handleChange } = useField(() => props.name, props.rules, {\n      // 👇 These are important\n      type: 'checkbox',\n      checkedValue: props.value,\n    });\n    // select/unselect the input\n    handleChange(props.value);\n    return {\n      checked, // readonly\n      handleChange,\n    };\n  },\n};\n\nvee-validate handles some of the complexities of the checkbox inputs nature, by default if a checkbox field is registered it will be treated as a single input until another checkbox with the same name is registered. Then they will be treated as a group, and their values will affect the group value when they are selected or not.\n\nHere is a live example of a custom checkbox input:\n\nTIP\n\nYou can also specify a custom uncheckedValue which sets the input value to when it is unchecked.\n\njs\nconst { checked, handleChange } = useField('toa', undefined, {\n  // Will make the checkbox set its value to true/false if it was checked or not\n  type: 'checkbox',\n  checkedValue: true,\n  uncheckedValue: false,\n});"
  },
  {
    "title": "Cross-Field Validation",
    "url": "https://vee-validate.logaretm.com/v4/examples/cross-field-validation/",
    "html": "Cross-Field Validation\n\nThis example shows how to create a password-confirmation-like rules using either yup or global validators."
  },
  {
    "title": "Array Fields",
    "url": "https://vee-validate.logaretm.com/v4/examples/array-fields/",
    "html": "Array Fields\n\nThis example shows how to implement array fields in vee-validate"
  },
  {
    "title": "Async Validation",
    "url": "https://vee-validate.logaretm.com/v4/examples/async-validation/",
    "html": "Async Validation\n\nThis is an example of field that uses an async rule to check if an email is available."
  },
  {
    "title": "Handling Forms",
    "url": "https://vee-validate.logaretm.com/v4/guide/components/handling-forms/",
    "html": "Handling Forms\n\nvee-validate offers many helpers to handle form submissions, resets, and DX to make your forms much easier to reason about and less of a burden to maintain. The Form component handles the following form cases:\n\nSubmitting forms with JavaScript listeners (AJAX)\nSubmitting forms using the classic/native approach (page reload)\nHandling form resets\nForm Values\n\nSo far you probably noticed we didn’t use v-model once in the examples. This is because in most cases you don’t need the model values until you submit them to your API or not at all if you are submitting an HTML form without JavaScript.\n\nHaving to create models just to be able to reference them later is redundant and vee-validate goes around this by creating an internal model for the <Field /> field component instances and tracks them and keeps them in sync with the input. You can still use v-model if you need it but vee-validate doesn’t require it.\n\nYou may access your form’s values using the values scoped slot prop on the Form component:\n\nvue\n<template>\n  <Form v-slot=\"{ values }\">\n    <Field name=\"email\" type=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <!-- print form values -->\n    <pre>{{ values }}</pre>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field } from 'vee-validate';\n</script>\n\nYou will rarely need to access the form values inside the template, but it is there if you ever need it. What’s interesting is that vee-validate follows the assumption that most likely you will need the form values at the submission phase.\n\nSo if you were to add a submit handler on the <Form /> component, vee-validate will automatically pass the form values to your handler as the first argument.\n\nvue\n<template>\n  <Form @submit=\"onSubmit\" :validation-schema=\"schema\">\n    <Field name=\"email\" type=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  password: yup.string().required().min(8),\n});\nfunction onSubmit(values) {\n  // Submit values to API...\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\nHandling Submissions\n\nvee-validate exposes useful defaults to help you handle form submissions whether you submit them using JavaScript or native HTML submissions, in most cases, you would like to make sure all your fields are valid before you submit the form, this is done for you by default.\n\nConsider the last example, if you tried submitting the form, it won’t be submitted unless all fields are valid. When rendering a form using the as prop, vee-validate will automatically listen for the submit event and prevent the execution of any submit listener you may have on the form.\n\nIf you have a submit listener on the Form component, vee-validate assumes you will be handling submissions via JavaScript (AJAX) and automatically calls event.preventDefault() for you and once the form is finished validating and turned out to be valid it will pass all the values of the <Field /> components.\n\nBut in the case when you don’t have a submit listener on your form, vee-validate assumes that the form will be submitted using the native HTML submission that causes the page to “reload”. However vee-validate will make sure the form is not submitted unless all fields are valid, here is an example:\n\nvue\n<Form method=\"post\" action=\"/api/users\" :validation-schema=\"schema\" />\n  <Field name=\"email\" />\n  <Field name=\"name\" type=\"email\" />\n  <Field name=\"password\" type=\"password\" />\n  <button>Submit</button>\n</Form>\nManually Handling Submissions\n\nIf you have complex markup requirements in your forms, you can use any of those <Form /> component slot props:\n\nhandleSubmit: automatically prevents native submission at all times, use for AJAX submissions\nsubmitForm: prevents native submissions as long as the form is invalid, use for native submissions\nvalidate: triggers validation on all fields belonging to the form\nUsing handleSubmit\n\nThe handleSubmit slot prop is probably the most common method you will use to handle form submissions manually, it accepts a callback that will be executed with the form values if the form is valid.\n\nvue\n<template>\n  <VeeForm v-slot=\"{ handleSubmit }\" :validation-schema=\"schema\" as=\"div\">\n    <form @submit=\"handleSubmit($event, onSubmit)\">\n      <Field name=\"email\" type=\"email\" />\n      <ErrorMessage name=\"email\" />\n      <Field name=\"password\" type=\"password\" />\n      <ErrorMessage name=\"password\" />\n      <button>Submit</button>\n    </form>\n  </VeeForm>\n</template>\n<script setup>\nimport { Form as VeeForm, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  password: yup.string().required().min(8),\n});\nfunction onSubmit(values) {\n  // Submit values to API...\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\nUsing submitForm\n\nAlternatively if you plan to submit forms natively which will cause a page “reload” then use submitForm as an event handler:\n\nvue\n<template>\n  <VeeForm v-slot=\"{ submitForm }\" :validation-schema=\"schema\" as=\"div\">\n    <form @submit=\"submitForm\" method=\"post\" action=\"/api/users/\">\n      <Field name=\"email\" type=\"email\" />\n      <ErrorMessage name=\"email\" />\n      <Field name=\"password\" type=\"password\" />\n      <ErrorMessage name=\"password\" />\n      <button>Submit</button>\n    </form>\n  </VeeForm>\n</template>\n<script setup>\nimport { Form as VeeForm, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  password: yup.string().required().min(8),\n});\n</script>\n\nThis will prevent submitting the form until all fields are valid.\n\nUsing validate()\n\nYou can validate the form without submissions using the validate() slot prop function:\n\nvue\n<Form v-slot=\"{ validate }\" :validation-schema=\"schema\">\n  <Field name=\"email\" type=\"email\" />\n  <ErrorMessage name=\"email\" />\n  <Field name=\"password\" type=\"password\" />\n  <ErrorMessage name=\"password\" />\n  <button type=\"button\" @click=\"validate\">Submit</button>\n</Form>\n\nThat form doesn’t render a form tag, so vee-validate doesn’t handle submissions for that group of fields. But you can still validate them using the validate function present on the Form component slot props.\n\nSubmission Progress\n\nQuite often you need to show your users a submission indicator, or you might want to disable the submit button entirely until the submission attempt is done. The Form component offers an isSubmitting slot prop that you can use to show such UI indicators.\n\nThe isSubmitting state will be set to true once the validation of the form starts (as a result of a submit event) and will keep track of the submission handler you passed to either onSubmit or until it calls submitForm. If the submission handler throws any errors or completes successfully it will be set to false afterward.\n\nHere is small example:\n\nSee the Pen vee-validate v4 isSubmitting by Abdelrahman Awad ( @logaretm) on CodePen.\n\nisSubmitting and validate()\n\nNote that calling validate from the Form slot props will not cause the isSubmitting state to change, it will only change if either submitForm or handleSubmit are called or when a submit event is triggered.\n\nsubmitCount\n\nThe Form component exposes a submitCount state that you can use to track the number of submission attempts done by the user. For more information check the API Reference.\n\nHandling Invalid Submissions\n\nIn case you want to perform some logic after a form fails to submit due to validation errors (e.g: focusing the first invalid field), you can listen for the onInvalidSubmit event emitted by the <Form /> component.\n\nvue\n<template>\n  <Form @submit=\"onSubmit\" :validation-schema=\"schema\" @invalid-submit=\"onInvalidSubmit\">\n    <Field name=\"email\" type=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  password: yup.string().required().min(8),\n});\nfunction onSubmit(values) {\n  // Submit values to API...\n  alert(JSON.stringify(values, null, 2));\n}\nfunction onInvalidSubmit({ values, errors, results }) {\n  console.log(values); // current form values\n  console.log(errors); // a map of field names and their first error message\n  console.log(results); // a detailed map of field names and their validation results\n}\n</script>\n\nSpecifying a onInvalidSubmit prop or @invalid-submit will run your handler if you submit your form using either handleSubmit or the regular form submit event but not the submitForm function.\n\nInitial Values\n\nSince with vee-validate you don’t have to use v-model to track your values, the Form component allows you to define the starting values for your fields, by default all fields start with undefined as a value.\n\nUsing the initialValues prop you can send an object that contains the field names as keys and their values:\n\nvue\n<template>\n  <Form :validation-schema=\"schema\" :initial-values=\"formValues\">\n    <Field name=\"email\" type=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button type=\"Submit\">Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  password: yup.string().required().min(8),\n});\n// Initial values\nconst formValues = {\n  email: 'example@example.com',\n  password: 'P@$$w0Rd',\n};\n</script>\n\nDoing so will trigger initial validation on the form and it will generate messages for fields that fail the initial validation. You can still use v-model on your fields to define model-based initial values.\n\nYou can use validateOnMount prop present on the <Form /> component to force an initial validation when the component is mounted.\n\nNote that only the non-dirty fields will be updated. In other words, only the fields that were not manipulated by the user will be updated. For information on how to set the values for all fields regardless of their dirty status check the following Setting Form Values section\n\nTIP\n\nIt’s generally recommended that you provide the initialValues, this is because vee-validate cannot assume a reasonable initial value for your fields other than undefined which may cause unexpected behavior when using a 3rd-party validator that does not deal with undefined.\n\nSetting Form Values\n\nYou can set any field’s value using either setFieldValue or setValues, both methods are exposed on the <Form /> component scoped slot props, and as component instance methods.\n\nYou can call them with template $refs and for an added convenience you can call them in the submit handler callback.\n\nUsing scoped slot props\n\nvue\n<Form v-slot=\"{ setFieldValue, setValues }\">\n  <Field name=\"email\"  />\n  <ErrorMessage name=\"email\" />\n  <Field name=\"password\"  />\n  <ErrorMessage name=\"password\" />\n  <button type=\"button\" @click=\"setFieldValue('email', 'test')\">Set Field Value</button>\n  <button type=\"button\" @click=\"setValues({ email: 'test', password: 'test12' })\">\n    Set Multiple Values\n  </button>\n</Form>\n\nUsing submit callback\n\nvue\n<template>\n  <Form @submit=\"onSubmit\">\n    <Field name=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nfunction onSubmit(values, actions) {\n  // Submit the values...\n  // set single field value\n  actions.setFieldValue('email', 'ummm@example.com');\n  // set multiple values\n  actions.setValues({\n    email: 'ummm@example.com',\n    password: 'P@$$w0Rd',\n  });\n}\n</script>\n\nUsing template $refs\n\nvue\n<template>\n  <Form @submit=\"onSubmit\" ref=\"myForm\">\n    <Field name=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nfunction onSubmit(values) {\n  // Submit the values...\n  // set single field value\n  this.$refs.myForm.setFieldValue('email', 'ummm@example.com');\n  // set multiple values\n  this.$refs.myForm.setValues({\n    email: 'ummm@example.com',\n    password: 'P@$$w0Rd',\n  });\n}\n</script>\n\nNote that setting any field’s value using this way will trigger validation\n\nSubmission Behavior\n\nvee-validate does the following when you submit a form rendered by <Form /> or when calling either handleSubmit or submitForm:\n\nBefore validation stage\nSets all fields touched meta to true\nSets isSubmitting form state to true\nIncrements the submitCount form state by 1\nValidation stage\nSets form and individual fields meta pending to true to indicate validation is in progress\nRuns the validation function/schema/rule against the current form values asynchronously\nChecks for any errors in the validation result\nIf there are errors then it will skip the next stage and update the validation state (meta, errors) for the form and fields\nIf there aren’t any errors then it will set the pending meta flag to false and proceed to the next stage\nAfter validation stage\nCalls the @submit handler you specified, or calls the handleSubmit callback you provided.\nAfter the callbacks in either method finish (it will wait if the result is asynchronous), then it will set isSubmitting to false\n\nNote that there isn’t a need to have isSubmitting set back to false if you’ve used submitForm, as this submission method will perform a full-page refresh (native forms behavior).\n\nHandling Resets\n\nvee-validate also handles form resets in a similar way to submissions. When resetting the form, all fields’ errors and meta flags will be reset to their original state, including the fields’ values.\n\nForm reset is handled automatically if you are using the as prop to render a form element, like shown in this example:\n\nvue\n<template>\n  <Form :validation-schema=\"schema\">\n    <Field name=\"email\" type=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button type=\"Submit\">Submit</button>\n    <button type=\"reset\">Reset</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  password: yup.string().required().min(8),\n});\n</script>\n\nAlternatively if you plan to use the scoped slot for complex markup, you can use the handleReset slot prop function to trigger the reset manually:\n\nvue\n<Form v-slot=\"{ handleReset }\" :validation-schema=\"schema\">\n  <Field name=\"email\" type=\"email\" />\n  <ErrorMessage name=\"email\" />\n  <Field name=\"password\" type=\"password\" />\n  <ErrorMessage name=\"password\" />\n  <button type=\"button\" @click=\"handleReset\">Reset</button>\n</Form>\nResetting Forms After Submit\n\nUsually you will reset your forms after a successful submission, the onSubmit handler receives an additional FormActions object in the second argument that allows you do some actions on the form after submissions, this is the shape of the FormActions object:\n\nts\nexport interface FormActions {\n  setFieldValue: (field: T, value: any) => void;\n  setFieldError: (field: string, message: string | undefined) => void;\n  setErrors: (fields: Partial<Record<string, string | undefined>>) => void;\n  setValues: (fields: Partial<Record<T, any>>) => void;\n  setFieldTouched: (field: string, isTouched: boolean) => void;\n  setTouched: (fields: Partial<Record<string, boolean>>) => void;\n  resetForm: (state?: Partial<FormState>) => void;\n}\n\nThis is an example of using the form actions object to reset the form:\n\nvue\n<template>\n  <Form @submit=\"onSubmit\" :validation-schema=\"schema\">\n    <!-- fields ... -->\n  </Form>\n</template>\n<script setup>\nimport { Form, Field } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  // ...\n});\nfunction onSubmit(values, { resetForm }) {\n  console.log(values); // send data to API\n  // reset the form and the field values to their initial values\n  resetForm();\n}\n</script>\n\nThe resetForm accepts an optional state object that allows you to specify the new initial values for any of the fields state, this is the shape of the FormState object:\n\nts\ninterface FormState {\n  // any error messages\n  errors: Record<string, string>;\n  // dirty meta flags\n  dirty: Record<string, boolean>;\n  // touched meta flags\n  touched: Record<string, boolean>;\n  // Form Values\n  values: Record<string, any>;\n}\n\nIn the following snippet, resetForm is used to update the form values to specific ones other than their original values. This is useful if your receive your form state asynchronously\n\njs\nresetForm({\n  values: {\n    email: 'example@example.com',\n    password: '',\n  },\n});\n\nYou can also use template $refs to reset the form whenever you need:\n\nvue\n<template>\n  <Form ref=\"form\" @submit=\"onSubmit\" :validation-schema=\"schema\">\n    <!-- fields ... -->\n    <button type=\"Submit\">Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  // ...\n});\nfunction onSubmit(values) {\n  console.log(values); // send data to API\n  // reset the form\n  this.$refs.form.resetForm();\n}\n</script>\nInitial Errors\n\nIf you are building a non-SPA application it is very common to pre-fill form errors using server-side rendering, frameworks like Laravel make this very easy to do. vee-validate supports filling the errors initially before any validation is done using the initialErrors prop which is present on the <Form /> component scoped slot props.\n\nThe initialErrors property accepts an object containing the field names as keys with their corresponding error message string.\n\nvue\n<template>\n  <Form :initial-errors=\"initialErrors\">\n    <Field name=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nconst initialErrors = {\n  email: 'This email is already taken',\n  password: 'The password is too short',\n};\n</script>\n\nTIP\n\ninitialErrors are applied once the Form component is mounted and is ignored after, so any changes to the initialErrors props won’t affect the messages.\n\nSee the next section for setting errors manually.\n\nSetting Errors Manually\n\nQuite often you will find yourself unable to replicate some validation rules on the client-side due to natural limitations. For example, unique email validation is complex to implement on the client-side, which is why the <Form /> component allows you to set errors manually.\n\nYou can set messages for fields by using either setFieldError which sets an error message for one field at a time, and the setErrors function which allows you to set error messages for multiple fields at once.\n\nBoth functions are available on the Form component scoped slot props, and also on the Form component instance which enables you to use it with template $refs, and also for added convenience on the submit event handler since it would be the most common place for its usage.\n\nHere are a few snippets showcasing its usage in these various scenarios:\n\nUsing scoped slot props (recommended)\n\nvue\n<Form v-slot=\"{ setFieldError, setErrors }\">\n  <Field name=\"email\"  />\n  <ErrorMessage name=\"email\" />\n  <Field name=\"password\"  />\n  <ErrorMessage name=\"password\" />\n  <button type=\"button\" @click=\"setFieldError('email', 'nope')\">Set Single Error</button>\n  <button type=\"button\" @click=\"setErrors({ email: 'nope', password: 'wrong' })\">\n    Set Multiple Errors\n  </button>\n</Form>\n\nUsing submit callback (recommended)\n\nvue\n<template>\n  <Form @submit=\"onSubmit\">\n    <Field name=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nfunction onSubmit(values, actions) {\n  // Submit the values...\n  // set single field error\n  actions.setFieldError('email', 'this email is already taken');\n  // set multiple errors\n  actions.setErrors({\n    email: 'this field is already taken',\n    password: 'someone already has this password',\n  });\n}\n</script>\n\nUsing template $refs\n\nvue\n<template>\n  <Form @submit=\"onSubmit\" ref=\"myForm\">\n    <Field name=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nfunction onSubmit(values) {\n  // Submit the values...\n  // if API returns errors\n  this.$refs.myForm.setFieldError('email', 'this email is already taken');\n  this.$refs.myForm.setErrors({\n    email: 'this field is already taken',\n    password: 'someone already has this password',\n  });\n}\n</script>\n\nAvoid Template $refs\n\nAlways try to avoid using the template $refs to gain access to the <Form /> component methods, template $refs are designed to be an escape hatch of sorts when all else fails.\n\nSo treat them as such and don’t reach out for template $refs if you can help it."
  },
  {
    "title": "Custom Inputs",
    "url": "https://vee-validate.logaretm.com/v4/examples/custom-inputs/",
    "html": "Custom Inputs\n\nMore often than not, you will have complex requirements for your inputs. Like a custom design, multiple UI states, validation and more. You can easily build your custom components with useField() composable function. While it is possible to build your inputs with <Field /> component it is not recommended as you won’t have access to many of the underlying features to manage your UI state and you would rely on scoped slot props which is only available in the template.\n\nuseField allows you to hook into the many underlying features of the Field component in a composable manner that you can easily integrate it in your UI, and on top of that your custom components will work seamlessly with <Form /> component or useForm without any intervention on your part.\n\nIn the following example we have a complex TextInput component that we use for many types of fields."
  },
  {
    "title": "Checkbox and Radio Inputs",
    "url": "https://vee-validate.logaretm.com/v4/examples/checkboxes-and-radio/",
    "html": "Checkbox and Radio Inputs\n\nThe documentation has so far avoided using type=\"radio\" and type=\"checkbox\" inputs because of their complex nature, however vee-validate supports both HTML checkboxes and radio inputs as well as your custom components that act as such (with caveats).\n\nThe only requirements are that the fields:\n\nMust be inside a Form component or a derivative (using useForm)\nMust Have the same name prop\nShould have a type attribute\n\nSlot props and custom components\n\nWhen using Field slot props with checkbox/radio components, you still need to provide the type and value props to the Field node itself.\n\nvue\n<Field v-slot=\"{ field }\" name=\"terms\" type=\"checkbox\" :value=\"true\">\n  <label>\n    <input type=\"checkbox\" name=\"terms\" v-bind=\"field\" :value=\"true\" />\n    I agree\n  </label>\n</Field>\n\nThe same caveat applies if you are rendering another component with as prop:\n\nvue\n<Field as=\"my-checkbox\" name=\"terms\" type=\"checkbox\" :value=\"true\" />\nValidating Radio Inputs\n\nvee-validate handles radio input groups as long as they have the type=\"radio\" and the same name prop value. The selected value will be present in the values object.\n\nValidating Checkbox Inputs\n\nvee-validate handles checkboxes as long as they have the type=\"checkbox\" prop and the same name prop value. The selected values will be collected in an array similar to what v-model does.\n\nIf there is only one checkbox then its value will be directly assigned in the values object without binding it in an array."
  },
  {
    "title": "Best Practices",
    "url": "https://vee-validate.logaretm.com/v4/guide/best-practices/",
    "html": "Best Practices\nDisplaying Errors\n\nvee-validate may choose to display form errors if they already existed before the form is mounted, at any case it is a good practice to explicitly define when should an error message appear.\n\nFor example it could a good idea to display the message if the field is touched:\n\nvue\n<template>\n  <div>\n    <input name=\"fieldName\" v-model=\"value\" />\n    <span v-if=\"errorMessage && meta.touched\">\n      {{ errorMessage }}\n    </span>\n  </div>\n</template>\n<script setup>\nimport { useField } from 'vee-validate';\nconst { errorMessage, meta, value } = useField('fieldName');\n</script>\n\nThis ensures the fields are not aggressive towards the user.\n\nYup Bundle Size\n\nvee-validate’s entire core size is very small, but the same can’t be said about the validators you import. Most examples use the following snippet to import everything yup has to offer:\n\njs\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().email(),\n  // ...\n});\n\nYou should leverage your bundler’s tree-shaking capabilities and only import what you need:\n\njs\nimport { object, string } from 'yup';\nconst schema = object({\n  email: string().email(),\n  // ...\n});\n\nThis will keep your app bundle size and routes to a minimum, ensuring faster load and interaction experiences for your users.\n\nYup schemas in data\n\nIn most examples, you probably noticed something like this:\n\njs\n{\n  data() {\n    const schema = yup.object({\n      email: yup.string().required().email(),\n      password: yup.string().required().min(8),\n    });\n    return {\n      schema,\n    };\n  },\n}\n\nThis is fine for most cases, but the way Vue makes data items reactive is by recursively traveling the object tree and marking each object as reactive, this is an unnecessary overhead as you don’t really need yup schemas to be reactive.\n\nInstead you could either use setup instead of your data or markRaw to prevent Vue from marking the yup schemas as reactive which eliminates the deep reactive conversion overhead.\n\njs\n{\n  setup() {\n    // Non-reactive because it was not explicitly defined with `reactive` or `ref`\n    const schema = yup.object({\n      email: yup.string().required().email(),\n      password: yup.string().required().min(8),\n    });\n    return {\n      schema,\n    };\n  },\n}\njs\nimport { markRaw } from 'vue';\n{\n  data() {\n    // Non-reactive because it was explicitly defined with `markRaw`\n    const schema = markRaw(yup.object({\n      email: yup.string().required().email(),\n      password: yup.string().required().min(8),\n    }));\n    return {\n      schema,\n    };\n  },\n}\n\nThe performance implications for this might be negligible for most cases, however, for large form schemas, this can be helpful to avoid the default behavior of deep reactive conversion."
  },
  {
    "title": "Devtools Plugin",
    "url": "https://vee-validate.logaretm.com/v4/guide/devtools/",
    "html": "Devtools Plugin v4.5\n\nvee-validate ships with a Vue.js devtools plugin that allows you to inspect your forms. The terms “devtools plugin” or “plugin” in this page will refer to vee-validate’s devtools plugin from now on.\n\nThe devtools plugin is useful for debugging and inspecting your forms. A common situation is not having any clues on why a form isn’t submitting, the devtools plugin exposes to you all of the validation state giving you insight for your forms behavior.\n\nSince vee-validate doesn’t require any app configuration, the devtools plugin is auto installed when you use useField or useForm or their component counterpart <Field /> and <Form />.\n\nWARN\n\nNote that the plugin won’t be installed in the following cases:\n\nYou are using the umd builds via CDN\nYour process.env.NODE_ENV is set to production or test\n\nThat means the plugin is only available to the workflows that employ either webpack or vite where process.env.NODE_ENV is available.\n\nThe Inspector\n\nThe devtools plugin adds a new “vee-validate” inspector that allows you to view your form state, at the moment all the properties are read only.\n\nTo use the vee-validate inspector, switch from the components inspector to the vee-validate inspector:\n\nDisabling the plugin\n\nIf the plugin is causing you issues, you can disable it explicitly from the vue-devtools plugin page.\n\nAlso please don’t forget to report the issue here.\n\nThis short video shows how to disable the vee-validate devtools plugin:"
  },
  {
    "title": "Testing",
    "url": "https://vee-validate.logaretm.com/v4/guide/testing/",
    "html": "Testing\n\nvee-validate has many tests of its own that cover almost every functionality, but if you find yourself needing to test vee-validate integration with your forms and fields, this guide should offer some guidance into the best practices and the caveats of doing that.\n\nWaiting for async validation\n\nvee-validate does all of the work asynchronously. This means whenever you trigger a validation using explicit validate() calls or form submissions or change events, you still need to “flush” the promises to assert the state you expect.\n\nFor example, the following test will fail\n\njs\nimport { useField } from 'useField';\nconst SomeComponent = {\n  template: `\n    <input v-model=\"value\" type=\"text\">\n    <span>{{ errorMessage }}</span>\n  `,\n  setup() {\n    const { value, errorMessage } = useField('name', value => {\n      return value ? true : 'field is required';\n    });\n    return {\n      value,\n      errorMessage,\n    };\n  },\n};\ntest('it validates', async () => {\n  // assuming you have a mounting helper\n  mount(SomeComponent);\n  const input = document.querySelector('input');\n  input.value = '';\n  input.dispatchEvent(new Event('change'));\n  // ❌ Fails\n  expect(document.querySelector('span').textContent).toBe('Field is required');\n});\n\nTo wait for the validation to execute and render the error message, you can use the flush-promises npm package to wait for all promises to fulfill and also coupled with wait-for-expect.\n\njs\nimport flushPromises from 'flush-promises';\nimport waitForExpect from 'wait-for-expect';\ntest('it validates', async () => {\n  // assuming you have a mounting helper\n  mount(SomeComponent);\n  const input = document.querySelector('input');\n  input.value = '';\n  input.dispatchEvent(new Event('change'));\n  // wait for the promises to fulfill\n  await flushPromises();\n  await waitForExpect(() => {\n    // ✅ Now passes\n    expect(document.querySelector('span').textContent).toBe('Field is required');\n  });\n});\n\nvee-validate may run validation in batches to improve performance which isn’t always detected by flush-promises, so using both is recommended here.\n\nTesting error messages\n\nMessages can change for the simplest of reasons, for example, grammar or punctuation changes could break your tests if you test against the literal contents of the message.\n\nIdeally, you shouldn’t rely on validation messages staying the same for your tests to pass, in any of the iterations when you work on your product you don’t want your tests to fail just because of that.\n\nSo instead of testing the literal messages, you want to test if they get any kind of validation message regardless of their content. There are a few suggestions to remedy that:\n\nTesting message existence\n\nYou can test if the error field contains any message at all, this is useful if you rely on error messages from 3rd party, like the @vee-validate/i18n package which changes its messages frequently due to constant updates and fixes by the awesome contributors from all over the world.\n\njs\n// ❌ Breaks easily\nexpect(errorElement.textContent).toBe('Field is required');\n// ✅\nexpect(errorElement.textContent).toBeTruthy();\nTesting partial contents\n\nAnother approach is to test that the messages contain the critical information needed for the user to understand how to fix their input. This assumes you have some idea of the contents of the message:\n\njs\n// ❌ Breaks easily\nexpect(errorElement.textContent).toBe('Field is required');\n// ✅ use `toContain` or similar matching assertions\nexpect(errorElement.textContent).toContain('required');\n\nOf course, this can break easily but still is more flexible than the full literal check.\n\nTesting actual contents\n\nThis approach relies on the fact that you organize your app user-facing strings in dictionary files, meaning messages are deterministic and not sprinkled across your component’s code.\n\njs\nimport messages from 'strings/validation.js';\n// ✅\nexpect(errorElement.textContent).toBe(messages.required);\nMocking Form and Field Contexts\n\nWhile this is extremely rare you may need to mock the FormContext object or the FieldContext object, one of the reasons is to unit test some component that relies on those objects being provided with the provide/inject API.\n\nYou can import the injection keys for those objects from vee-validate and manually inject your fields/forms.\n\njs\nimport { provide } from 'vue';\nimport { FormContextKey, FieldContextKey } from 'vee-validate';\nprovide(FormContextKey, MockedForm);\nprovide(FieldContextKey, MockedField);\n\nTo learn more about the mock details you should check the source code and see the typescript interfaces for FormContext and FieldContext objects and implement them as mocks."
  },
  {
    "title": "Localization (i18n)",
    "url": "https://vee-validate.logaretm.com/v4/guide/i18n/",
    "html": "Localization (i18n)\n\nThis guide only addresses generating error messages for globally defined validators using vee-validate’s own @vee-validate/i18n plugin.\n\nIf you are using vee-validate with yup, then you should check out yup’s localization guide. If you are using another library for data validation, check their i18n capabilities.\n\nGlobal Message Generator\n\nvee-validate exposes a global config called generateMessage which is a function that should return a string. Whenever any globally defined rule returns a falsy value the generateMessage will be called and its result will be used as an error message for that rule.\n\nThe message generator function has the following type:\n\nts\ninterface FieldContext {\n  field: string; // The field's name or label (see next section)\n  value: any; // the field's current value\n  form: Record<string, any>; // other values in the form\n  rule: {\n    name: string; //the rule name\n    params?: any[]; // any params sent to it\n  };\n}\ntype ValidationgenerateMessage = (ctx: FieldContext) => string;\n\nWith this information, you could create message handlers with any kind of 3rd party libraries. To register a message generator use the configure function exposed by vee-validate:\n\njs\nimport { configure } from 'vee-validate';\nconfigure({\n  generateMessage: context => {\n    return `The field ${context.field} is invalid`;\n  },\n});\nCustom Labels\n\nIf you want to display different field names in your error messages, the <Field /> component accepts a label prop which allows you to display better names for your fields in their generated messages. Here is an example:\n\nvue\n<Form>\n  <Field name=\"_bad_field_name\" label=\"nice name\" rules=\"required|email\" />\n  <ErrorMessage name=\"_bad_field_name\" />\n</Form>\n\nThe generated message will use nice name instead of the badly formatted one.\n\nUsing @vee-validate/i18n\nOverview\n\nThe @vee-validate/i18n contains a simple message generator function that you can use to generate localized messages from JSON objects:\n\nFirst, you need to install the @vee-validate/i18n package:\n\nsh\nyarn add @vee-validate/i18n\n# or with npm\nnpm install @vee-validate/i18n\n\n\\import the localize() function from @vee-validate/i18n which returns a message generator function:\n\njs\nimport { defineRule, configure } from 'vee-validate';\nimport { required } from '@vee-validate/rules';\nimport { localize } from '@vee-validate/i18n';\n// Define the rule globally\ndefineRule('required', required);\nconfigure({\n  // Generates an English message locale generator\n  generateMessage: localize('en', {\n    messages: {\n      required: 'This field is required',\n    },\n  }),\n});\n\nIf you have multiple locales in your application, you can add them like this:\n\njs\nimport { defineRule, configure } from 'vee-validate';\nimport { required } from '@vee-validate/rules';\nimport { localize } from '@vee-validate/i18n';\n// Define the rule globally\ndefineRule('required', required);\nconfigure({\n  generateMessage: localize({\n    en: {\n      messages: {\n        required: 'This field is required',\n      },\n    },\n    ar: {\n      messages: {\n        required: 'هذا الحقل مطلوب',\n      },\n    },\n  }),\n});\n\nYou can change the locale using setLocale function exported by the @vee-validate/i18n anywhere in your application:\n\njs\nimport { setLocale } from '@vee-validate/i18n';\nsetLocale('ar');\n\nTo save you a lot of time translating @vee-validate/rules messages to your language, the awesome community around vee-validate already contributed over 40+ languages that you can use directly in your application and get started quickly. The localized files include localized messages for all the global rules provided by @vee-validate/rules package.\n\nYou can import the needed locale from the @vee-validate/i18n/dist/locale/{localeCode}.json and they can be passed directly to the localize function. This snippet adds the English and Arabic localized messages for all the rules of @vee-validate/rules package into the message generator function:\n\njs\nimport { configure } from 'vee-validate';\nimport { localize } from '@vee-validate/i18n';\nimport en from '@vee-validate/i18n/dist/locale/en.json';\nimport ar from '@vee-validate/i18n/dist/locale/ar.json';\nconfigure({\n  generateMessage: localize({\n    en,\n    ar,\n  }),\n});\nLocalizing Field Names\n\nTo localize the field name with the @vee-validate/i18n package, you can add a names property to your dictionaries containing the translated names of the fields.\n\njs\nimport { configure } from 'vee-validate';\nimport { localize } from '@vee-validate/i18n';\nconfigure({\n  generateMessage: localize({\n    en: {\n      names: {\n        age: 'Age',\n      },\n    },\n    ar: {\n      age: 'السن',\n    },\n  }),\n});\n\nThen whenever a message is generated for a global rule, vee-validate will try to match the field name with the names property found in the active locale.\n\nThis is such an example:\n\nCustom messages for specific fields\n\nYou may want to override specific rule messages for specific fields, you can do this by calling localize with the specific messages object:\n\njs\nimport { localize } from '@vee-validate/i18n';\nlocalize('en', {\n  fields: {\n    password: {\n      required: 'Hey! Password cannot be empty',\n    },\n  },\n});\n// Or update multiple languages\nlocalize({\n  en: {\n    fields: {\n      password: {\n        required: 'Hey! Password cannot be empty',\n      },\n    },\n  },\n});\n\nYou can call localize anywhere in your component initialization, ideally before any error is generated so either mounted or setup should be safe to call localize.\n\nPlaceholder Interpolation\n\nYour messages can be more complex than required, for example a between rule would need access to the params values to be able to produce a meaningful error message, the @vee-validate/i18n plugin comes with interpolation support for various placeholders, consider this example:\n\njs\nimport { defineRule, configure } from 'vee-validate';\nimport { between } from '@vee-validate/rules';\nimport { localize } from '@vee-validate/i18n';\n// Define the rule globally\ndefineRule('between', between);\nconfigure({\n  // Generates an English message locale generator\n  generateMessage: localize('en', {\n    messages: {\n      between: 'The {field} value must be between 0:{min} and 1:{max}',\n    },\n  }),\n});\n\nThe {field} placeholder will be replaced with the field name, and 0:{min} and 1:{max} will be replaced with the rule arguments. Note that the indices that prefix each param name are recommended because the interpolation will need to know the order of the arguments because you may define your global rules in one of object or array or string formats, and thus the interpolation process needs to know both argument names and their order if array params or strings are used.\n\nYou can also interpolate the other fields in the form by using their names as placeholders.\n\nHere is an example that show cases interpolation for different cases:\n\nLoading Locale From CDN\n\nIf you are using Vue.js over CDN, you can still load the locale files without having to copy them to your code, the @vee-validate/i18n library exposes a loadLocaleFromURL function that accepts a URL to a locale file.\n\nhtml\n<script src=\"path/to/vee-validate.js\"></script>\n<script src=\"path/to/@vee-validate/rules.js\"></script>\n<script src=\"path/to/@vee-validate/i18n.js\"></script>\n<script>\n  // Install all rules\n  Object.keys(VeeValidateRules).forEach(rule => {\n    VeeValidate.defineRule(rule, VeeValidateRules[rule]);\n  });\n  // Downloads and merges the locale from URL\n  VeeValidateI18n.loadLocaleFromURL('https://unpkg.com/@vee-validate/i18n@4.0.2/dist/locale/ar.json');\n  // Activate the locale\n  VeeValidate.configure({\n    generateMessage: VeeValidateI18n.localize('ar'),\n  });\n</script>\n\nHere is an example of the previous snippet:"
  },
  {
    "title": "Global Validators",
    "url": "https://vee-validate.logaretm.com/v4/guide/global-validators/",
    "html": "Global Validators\n\nSometimes you are building an application that is form-heavy and needs to validate forms frequently, like an admin dashboard or a form-based application. importing validation rules every time you need them can be quite tedious.\n\nVeeValidate allows you to define validation rules globally on the app-level which in turn can allow you to express your rules in a minimal syntax that is inspired by the Laravel framework’s validation syntax.\n\nDefining Global Validators\n\nYou can define a global validator using the defineRule function exported by vee-validate:\n\njs\nimport { defineRule } from 'vee-validate';\n\nThe defineRule function accepts a rule name that acts as an identifier for that validation rule, the second argument is the validator function that will verify the field value. Here is an example of a simple required and an email rule:\n\njs\nimport { defineRule } from 'vee-validate';\ndefineRule('required', value => {\n  if (!value || !value.length) {\n    return 'This field is required';\n  }\n  return true;\n});\ndefineRule('email', value => {\n  // Field is empty, should pass\n  if (!value || !value.length) {\n    return true;\n  }\n  // Check if email\n  if (!/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}/.test(value)) {\n    return 'This field must be a valid email';\n  }\n  return true;\n});\n\nThe validator function is a simple function that receives the current field value as the first argument, and it should return:\n\ntrue if the validation passed\nstring if the validation failed and there is an error message to display\nfalse if validation fails, in that case, vee-validate will try to generate an error message using config.defaultMessage\nPromise if you have an asynchronous rule, the promise must either resolve to string or true\n\nRules Placement\n\nYou should make the defineRule calls in your application entry-point file to make sure your forms have access to them, otherwise, you may risk a form not being able to use some global rules because they weren’t defined then. Here are some common entry points:\n\nIn vue-cli applications that would be the src/main.js file\nIn a Nuxt application, you need to create a plugins/vee-validate.js file and register it in nuxt.config.js\nUsing Global Validators\n\nNow that you’ve defined your validators, for example, the email and required rules. You can pass them directly to <Field /> component’s rules prop like this:\n\nvue\n<Field name=\"name\" rules=\"required\" />\n<Field name=\"email\" rules=\"required|email\" />\n\nNotice that to define multiple rules you have to place a | (pipe) character between your rules as a separator.\n\nConfiguring Global Validators\n\nSometimes your rules require more information to work properly, for example, if we want to define a minLength rule it won’t be very useful to hard code the character limit, instead, it should receive it per field.\n\nVeeValidate passes rules arguments or (configuration) as the second argument to the validator function which is often an array containing the arguments in the same order they were passed in. Here is an example defining a minLength rule:\n\njs\nimport { defineRule } from 'vee-validate';\ndefineRule('minLength', (value, [limit]) => {\n  // The field is empty so it should pass\n  if (!value || !value.length) {\n    return true;\n  }\n  if (value.length < limit) {\n    return `This field must be at least ${limit} characters`;\n  }\n  return true;\n});\n\nAnd then you can use it on the Field component like this:\n\nvue\n<Field name=\"password\" type=\"password\" rules=\"required|minLength:8\" />\n\nNote that to pass arguments to rules, you need to place a colon : character to signify the beginning of rules. You can pass multiple arguments as a comma-separated list. Here is an example for a minMax rule:\n\njs\nimport { defineRule } from 'vee-validate';\ndefineRule('minMax', (value, [min, max]) => {\n  // The field is empty so it should pass\n  if (!value || !value.length) {\n    return true;\n  }\n  const numericValue = Number(value);\n  if (numericValue < min) {\n    return `This field must be greater than ${min}`;\n  }\n  if (numericValue > max) {\n    return `This field must be less than ${max}`;\n  }\n  return true;\n});\n\nThen you can use it like this:\n\nvue\n<Field name=\"longitude\" type=\"number\" rules=\"required|minMax:-180,180\" />\nSchema Validation\n\nThe Form-level validation feature isn’t limited to yup validators, you can define your global validators and define them in the same way as the previous examples in the Form component validation-schema prop.\n\nHere is an example that uses all the rules we’ve defined prior in this page in a form validation schema:\n\nvue\n<template>\n  <Form @submit=\"submit\" :validation-schema=\"schema\" v-slot=\"{ errors }\">\n    <Field name=\"email\" />\n    <span>{{ errors.email }}</span>\n    <Field name=\"password\" type=\"password\" />\n    <span>{{ errors.password }}</span>\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field } from 'vee-validate';\nconst schema = {\n  email: 'required|email',\n  password: 'required|minLength:8',\n};\n</script>\n\nThis makes vee-validate extremely compatible with Laravel’s Request validation and potentially opens the door to make your forms completely API-driven, eliminating the maintenance burden of syncing validation rules between frontend and backend.\n\nCross-Field Validation\n\nAssuming you want to create a rule that verifies that a field matches another, like a password confirmation scenario. Because globally defined rules do not have scope access to other values you may have in the component, vee-validate sends a third argument to your global validators which is a ValidationContext that carries useful information about the form and field being validated.\n\nSo assuming you want to build a confirmed rule, you would make it configurable by accepting the target field name and you can use the ValidationContext.form object to access its value:\n\njs\nimport { defineRule } from 'vee-validate';\ndefineRule('confirmed', (value, [target], ctx) => {\n  if (value === ctx.form[target]) {\n    return true;\n  }\n  return 'Passwords must match';\n});\n\nHere is an example of the two fields using that rule:\n\nvue\n<Field name=\"password\" rules=\"required\" />\n<Field name=\"confirmation\" rules=\"required|confirmed:password\" />\n\nThere is a shorthand for this using @ prefix before specifying arguments, this tells vee-validate to automatically swap the specified field value in the arguments array:\n\njs\nimport { defineRule } from 'vee-validate';\ndefineRule('confirmed', (value, [target]) => {\n  if (value === target) {\n    return true;\n  }\n  return 'Passwords must match';\n});\nvue\n<Form>\n  <Field name=\"password\" type=\"password\" />\n  <Field name=\"confirmation\" type=\"password\" rules=\"confirmed:@password\" />\n</Form>\n\nThis allows you to create more concise rules, you can reference any number of fields using this way.\n\nObject Expressions\n\nThere is another way to use global validators which is more expressive by using JavaScript objects to describe the validation for your fields. For example this:\n\njs\n'required|between:0,10';\n\nCould be rewritten as an object like this\n\njs\n{ required: true, between: [0, 10] }\n\nThis makes defining rules more expressive and less limited by the string format.\n\nFor dynamic expressions, you can use computed properties in the same way to define dynamic validation rules.\n\n@vee-validate/rules\n\nVeeValidate offers a wide range of common validators that you can use as global validators, they are packed in a separate package under the @vee-validate/rules namespace\n\nsh\nyarn add @vee-validate/rules\n# or with npm\nnpm install @vee-validate/rules\n\nYou can then start importing and defining rules globally:\n\njs\nimport { defineRule } from 'vee-validate';\nimport { required, email, min } from '@vee-validate/rules';\ndefineRule('required', required);\ndefineRule('email', email);\ndefineRule('min', min);\n\nOr you can globally define all the available rules in the @vee-validate/rules package:\n\njs\nimport { defineRule } from 'vee-validate';\nimport * as AllRules from '@vee-validate/rules';\nObject.keys(AllRules).forEach(rule => {\n  defineRule(rule, AllRules[rule]);\n});\nCaveats\nBe careful of having too many global rules as this can slow down your initial website load time due to the large initial bundle size\nIt is recommended to treat your validation rules as pure functions, meaning they only operate with the information given to them\nHaving small, pure global validations is preferable to allow reusing them across the app\nYou could possibly trigger an infinite render-loop when using the object expressions to define your validations for a field, read the linked section for a workaround\nAvailable Rules\nalpha\nalpha_dash\nalpha_num\nalpha_spaces\nbetween\nconfirmed\ndigits\ndimensions\nemail\nnot_one_of\next\nimage\none_of\ninteger\nis\nis_not\nlength\nmax\nmax_value\nmimes\nmin\nmin_value\nnumeric\nregex\nrequired\nsize\nurl\nPlayground\n\nHere is a live demo where you can view and test all the global validators live\n\nalpha\n\nThe field under validation may only contain alphabetic characters.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"alpha\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ alpha: true }\" />\nalpha_dash\n\nThe field under validation may contain alphabetic characters, numbers, dashes, or underscores.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"alpha_dash\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ alpha_dash: true }\" />\nalpha_num\n\nThe field under validation may contain alphabetic characters or numbers.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"alpha_num\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ alpha_num: true }\" />\nalpha_spaces\n\nThe field under validation may contain alphabetic characters or spaces.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"alpha_spaces\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ alpha_spaces: true }\" />\nbetween\n\nThe field under validation must have a numeric value bounded by a minimum value and a maximum value.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"between:1,10\" />\n<!-- object format with shorthand array -->\n<Field name=\"field\" :rules=\"{ between: [1, 10] }\" />\n<!-- object format with named arguments -->\n<Field name=\"field\" :rules=\"{ between: { min: 1, max: 10 } }\" />\nParam Name\tRequired?\tDescription\nmin\tyes\tThe minimum value.\nmax\tyes\tThe maximum value.\nconfirmed\n\nThe field under validation must have the same value as the confirmation field.\n\nvue\n<Form>\n  <Field name=\"password\" type=\"password\" />\n  <Field name=\"confirmation\" type=\"password\" rules=\"confirmed:@password\" />\n</Form>\nParam Name\tRequired?\tDescription\ntarget\tyes\tThe other field’s name value, must use @ to prefix the target field name\n\nDANGER\n\nAny fields defined to have this rule must have a <Form /> parent in their hierarchy or useForm() called on their parent hierarchy.\n\ndigits\n\nThe field under validation must be numeric and have the specified number of digits.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"digits:3\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ digits: 3 }\" />\nParam Name\tRequired?\tDescription\nlength\tyes\tThe number of digits allowed.\ndimensions\n\nThe file added to the field under validation must be an image (jpg,svg,jpeg,png,bmp,gif) having the exact specified dimension.\n\nvue\n<!-- string format -->\n<Field name=\"field\" type=\"file\" rules=\"dimensions:120,120\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ dimensions: [120, 120] }\" />\n<!-- object format with named arguments -->\n<Field name=\"field\" :rules=\"{ dimensions: { width: 120, height: 120 } }\" />\nParam Name\tRequired?\tDescription\nwidth\tyes\tThe width in pixels.\nheight\tyes\tThe height in pixels.\nemail\n\nThe field under validation must be a valid email.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"email\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ email: true }\" />\nnot_one_of\n\nThe field under validation must have a value that is not in the specified list. Uses double equals for checks.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"not_one_of:1,3\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ not_one_of: [1, 3] }\" />\n\nnot_one_of accepts an infinite number of params, each is a value that is disallowed.\n\next\n\nThe file added to the field under validation must have one of the extensions specified.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"ext:jpg,png\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ ext: ['jpg', 'png'] }\" />\n\next accepts an infinite number of arguments representing extensions. ex: ext:jpg,png,bmp,svg.\n\nimage\n\nThe file added to the field under validation must have an image mime type (image/*).\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"image\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ image: true }\" />\ninteger\n\nThe field under validation must be a valid integer value. Doesn’t accept exponential notation.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"integer\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ integer: true }\" />\nis\n\nThe field under validation must match the given value, uses strict equality.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"is:hello\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ is: 'hello' }\" />\nParam Name\tRequired?\tDescription\nvalue\tyes\tA value of any type to be compared against the field value.\nis_not\n\nThe field under validation must not match the given value, uses strict equality.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"is_not:world\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ is_not: 'world' }\" />\nParam Name\tRequired?\tDescription\nvalue\tyes\tA value of any type to be compared against the field value.\nlength\n\nThe field under validation must exactly have the specified number of items, only works for iterables.\n\nAllowed Iterable values are string, array, and any object that can be used with Array.from.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"length:5\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ length: 5 }\" />\nParam Name\tRequired?\tDescription\nlength\tyes\tA numeric value representing the exact number of items the value can contain.\nmax\n\nThe field under validation length may not exceed the specified length.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"max:10\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ max: 10 }\" />\nParam Name\tRequired?\tDescription\nlength\tyes\tA numeric value representing the maximum number of characters.\nmax_value\n\nThe field under validation must be a numeric value and must not be greater than the specified value.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"max_value:10\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ max_value: 10 }\" />\nParam Name\tRequired?\tDescription\nmax\tyes\tA numeric value representing the greatest value allowed.\nmimes\n\nThe file type added to the field under validation should have one of the specified mime types.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"mimes:image/jpeg\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ mimes: ['image/jpeg'] }\" />\n\nmimes accepts an infinite number of arguments that are formatted as file types. EG: mimes:image/jpeg,image/png.\n\nTIP\n\nYou can use ’*’ to specify a wild card, something like mimes:image/* will accept all image types.\n\nmin\n\nThe field under validation length should not be less than the specified length.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"min:3\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ min: 3 }\" />\nParam Name\tRequired?\tDescription\nlength\tyes\tA numeric value representing the minimum number of characters.\nmin_value\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"min_value:5\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ min_value: 5 }\" />\n\nThe field under validation must be a numeric value and must not be less than the specified value.\n\nParam Name\tRequired?\tDescription\nmin\tyes\tA numeric value representing the smallest value allowed.\nnumeric\n\nThe field under validation must only consist of numbers.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"numeric\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ numeric: true }\" />\none_of\n\nThe field under validation must have a value that is in the specified list. Uses double equals for checks.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"one_of:1,2,3\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ one_of: [1, 2, 3] }\" />\n\none_of takes an infinite number of params, each is a value that is allowed.\n\nregex\n\nThe field under validation must match the specified regular expression.\n\nvue\n<!-- string format: NOT RECOMMENDED -->\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ regex: /^[0-9]+$/ }\" />\nParam Name\tRequired?\tDescription\npattern\tyes\tA regular expression instance or string representing one.\n\nWARN\n\nYou should not use the pipe ’|’ or commas ’,’ within your regular expression when using the string rules format as it will cause a conflict with how validators parsing works. You should use the object format of the rules instead as shown in the last snippet\n\nThe g flag\n\nWhen using the regex rule, using the g flag may result in unexpected falsy validations. This is because vee-validate uses the same instance across validation attempts.\n\nrequired\n\nThe field under validation must have a non-empty value. By default, all validators pass the validation if they have “empty values” unless they are required. Those empty values are empty strings, undefined, null, false, and empty arrays.\n\nvue\n<!-- string format -->\n<Field name=\"field\" rules=\"required\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ required: true }\" />\nsize\n\nThe file size added to the field under validation must not exceed the specified size in kilobytes.\n\nvue\n<!-- string format -->\n<Field name=\"field\" type=\"file\" rules=\"size:250\" />\n<!-- object format -->\n<Field name=\"field\" :rules=\"{ size: 250 }\" />\nParam Name\tRequired?\tDescription\nsize\tyes\tThe maximum file size in kilobytes.\nurl\n\nThe field under validation must be a valid url. You can pass a pattern if you need the url to be more restricted.\n\nvue\n<!-- string format -->\n<Field name=\"field\" type=\"url\" rules=\"url\" />\n<!-- object format -->\n<Field name=\"field\" type=\"text\" :rules=\"{ url: 'https://.*' }\" />\nParam Name\tRequired?\tDescription\npattern\tno\tA regular expression instance or string representing one."
  },
  {
    "title": "Caveats and best practices",
    "url": "https://vee-validate.logaretm.com/v4/guide/composition-api/caveats/",
    "html": "Composition API Caveats\n\nWhen using the composition API, there are a few things that are not clear when first starting to use it. This page will contain these topics and help you understand how to workaround or address them.\n\nFunction Field Names with useField\n\nYou might’ve noticed that some examples in the docs pass the field name as a function to useField:\n\njs\nimport { useField } from 'vee-validate';\nexport default {\n  props: {\n    name: String,\n  },\n  setup(props) {\n    const { value, errorMessage } = useField(() => props.name);\n  },\n};\n\nThis is mainly because the props in Vue.js is a reactive object, meaning if you access or destruct any of its properties they will lose the reactivity aspect. Let’s say you did the following:\n\njs\nimport { useField } from 'vee-validate';\nexport default {\n  props: {\n    name: String,\n  },\n  setup(props) {\n    // ❌ Don't do this in custom input components\n    const { value, errorMessage } = useField(props.name);\n  },\n};\n\nThe implications are that vee-validate is no longer able to tell when the field name changes, which is crucial for syncing values when they do.\n\nA common example where field names change frequently is in a array field where v-for loops field names use the index or the iterated value to generate the field name\n\nvue\n<CustomTextField\n  v-for=\"(user, idx) in users\"\n  :key=\"user.id\"\n  :name=\"`users[${idx}].name`\"\n></CustomTextField>\n\nTo address this issue, you need to get a reactive reference to the name property. Vue offers a few ways to do this, so you can use any of the following methods:\n\njs\nimport { toRef, toRefs, computed } from 'vue';\n// ✅ using a function that returns the name\nconst { value, errorMessage } = useField(() => props.name);\n// ✅ using `toRef`\nconst { value, errorMessage } = useField(toRef(props, 'name'));\n// ✅ using `toRefs`\nconst { name } = toRefs(props);\nconst { value, errorMessage } = useField(name);\n// ✅ using `computed`\nconst name = computed(() => props.name);\nconst { value, errorMessage } = useField(name);\nDestructing composable\n\nThe composition API examples in the docs have always used the left-hand side destructing syntax when assigning component data with any of the composable functions vee-validate offers. To quickly refresh your memory:\n\njs\nconst { value } = useField('field');\nconst { handleChange } = useForm();\nconst { fields } = useFieldArray('users');\n\nThis is required by default, because each of these functions assumes you might never need the entire features each one provides and such each state/function is exposed independently as a Ref or a Function.\n\nThis means if you try the following, it won’t work as expected when used in your template:\n\nvue\n<script setup>\nimport { useField, useForm, useFieldArray } from 'vee-validate';\nexport default {\n  setup() {\n    const form = useForm();\n    const field = useField('field');\n    const fieldArray = useFieldArray('users');\n    return {\n      form,\n      field,\n      fieldArray,\n    };\n  },\n};\n</script>\n<template>\n  <!-- ❌ Doesn't work -->\n  <input v-model=\"field.value\" />\n  <!-- ❌ Doesn't work -->\n  <pre>{{ form.meta.valid }}</pre>\n  <!-- ❌ Doesn't work -->\n  <div v-for=\"item in fieldArray.fields\"></div>\n</template>\n\nThis is because the setup function doesn’t recursively expose the refs inside of these objects. If you prefer to use the composition API like shown above, then you can fix most of the issues by wrapping the function calls with reactive().\n\nvue\n<script setup>\nimport { reactive } from 'vue';\nimport { useField, useForm, useFieldArray } from 'vee-validate';\nconst form = reactive(useForm());\nconst field = reactive(useField('field'));\nconst fieldArray = reactive(useFieldArray('users'));\n</script>\n<template>\n  <!-- ❌  Still Doesn't work because it is a writeable computed ref -->\n  <input v-model=\"field.value\" />\n  <!-- ✅  Works if unwrapped manually -->\n  <input v-model=\"field.value.value\" />\n  <!-- ✅  Works -->\n  <pre>{{ form.meta.valid }}</pre>\n  <!-- ✅  Works -->\n  <div v-for=\"item in fieldArray.fields\"></div>\n</template>\n\nYou can read more on that behavior in Vue.js docs. Note that once you wrap the composable calls with reactive you no longer can destruct them and preserve the reactivity."
  },
  {
    "title": "Typed Schemas",
    "url": "https://vee-validate.logaretm.com/v4/guide/composition-api/typed-schema/",
    "html": "Typed Schemas\n\nWARN\n\nThis guide is aimed towards TypeScript usage with vee-validate’s composition API. If you are using the components API or JavaScript then there isn’t much to learn here.\n\nInput and Output types\n\nConsider the following form:\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, string } from 'yup';\nconst { values, handleSubmit } = useForm({\n  validationSchema: object({\n    email: string().required(),\n    password: string().required(),\n    name: string(),\n  }),\n});\n\nWhen attempting to interact with the values you will notice that it is untyped. Meaning you don’t get any type hints or checks which makes it less safe to use.\n\nts\n// 💥 Blows up because `email` is undefined\nvalues.email.endsWith('@gmail.com');\n\nProviding an initialValues or an interface to useForm could help:\n\nts\ninterface MyForm {\n  email?: string | null;\n  password?: string | null;\n}\nconst { values, handleSubmit } = useForm<MyForm>({\n  validationSchema: object({\n    email: string().required(),\n    password: string().required(),\n    name: string(),\n  }),\n});\n// ❌ Type error, which means `values` is type-safe\nvalues.email.endsWith('@gmail.com');\n\nBut then you will find another problem when using handleSubmit:\n\nts\nhandleSubmit(values => {\n  // Must be checked, this means submmited values are innacurate\n  if (values.email) {\n    values.email.endsWith('@gmail.com');\n  }\n});\n\nEven though you marked your field as required, it still uses the same type you provider earlier which will keep the email field as nullable. This is what we mean by the “dual nature” of form values.\n\nForm values can exist in two types/versions:\n\nThe “input” type which is the one the user is filling/interacting with, it is the one that captures the user input.\nThe “output” type which is the one the user ends up submitting.\n\nYou can tell vee-validate about this information by using the typed schema resolvers available in compainion packages.\n\nYup\n\nYou can use yup as a typed schema with the @vee-validate/yup package:\n\nsh\n# npm\nnpm install @vee-validate/yup\n# yarn\nyarn add @vee-validate/yup\n# pnpm\npnpm add @vee-validate/yup\n\nThe @vee-valdiate/yup package exposes a toTypedSchema function that accepts any yup schema. Which then you can pass along to validationSchema option on useForm.\n\nThis makes the form values and submitted values typed automatically and caters for both input and output types of that schema.\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, string } from 'yup';\nimport { toTypedSchema } from '@vee-validate/yup';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      email: string().required(),\n      password: string().required(),\n      name: string(),\n    }),\n  ),\n});\n// ❌ Type error, which means `values` is type-safe\nvalues.email.endsWith('@gmail.com');\nhandleSubmit(submitted => {\n  // No errors, because email is required!\n  submitted.email.endsWith('@gmail.com');\n  // ❌ Type error, because `name` is not required so it could be undefined\n  // Means that your fields are now type safe!\n  submitted.name.length;\n});\nYup default values\n\nYou can also define default values on your schema directly and it will be picked up by the form:\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, string } from 'yup';\nimport { toTypedSchema } from '@vee-validate/yup';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      email: string().required().default('something@email.com'),\n      password: string().required().default(''),\n      name: string().default(''),\n    }),\n  ),\n});\n\nYour initial values will be using the schema defaults, and also the defaults will be used if the values submitted is missing these fields.\n\nYup transforms\n\nYou can also define transforms to cast your fields before submission:\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, number } from 'yup';\nimport { toTypedSchema } from '@vee-validate/yup';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      age: number()\n        .transform(val => Number(val))\n        .required(),\n    }),\n  ),\n});\n\nBut note that this does not change the input or output types of the casted fields. The cast will only occur when setting the initial value and when the values are submitted in the submission handler.\n\nZod\n\nZod is an excellent library for value validation which mirrors static typing APIs.\n\nIn their own words it is a:\n\nTypeScript-first schema validation with static type inference\n\nYou can use zod as a typed schema with the @vee-validate/zod package:\n\nsh\n# npm\nnpm install @vee-validate/zod\n# yarn\nyarn add @vee-validate/zod\n# pnpm\npnpm add @vee-validate/zod\n\nThe @vee-valdiate/zod package exposes a toTypedSchema function that accepts any zod schema. Which then you can pass along to validationSchema option on useForm.\n\nThis makes the form values and submitted values typed automatically and caters for both input and output types of that schema.\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, string } from 'zod';\nimport { toTypedSchema } from '@vee-validate/zod';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      email: string().min(1, 'required'),\n      password: string().min(1, 'required'),\n      name: string().optional(),\n    }),\n  ),\n});\n// ❌ Type error, which means `values` is type-safe\nvalues.email.endsWith('@gmail.com');\nhandleSubmit(submitted => {\n  // No errors, because email is required!\n  submitted.email.endsWith('@gmail.com');\n  // ❌ Type error, because `name` is not required so it could be undefined\n  // Means that your fields are now type safe!\n  submitted.name.length;\n});\n\nrefine/superRefine\n\nThere is a known issue with Zod’s refine and superRefine not executing whenever some object keys are missing or not filled which is common with forms. This is not an issue with vee-validate as it is a design choice in Zod at the moment. Refer to this issue for explanations and further reading.\n\nZod default values\n\nYou can also define default values on your zod schema directly and it will be picked up by the form:\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, string } from 'zod';\nimport { toTypedSchema } from '@vee-validate/zod';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      email: string().default('something@email.com'),\n      password: string().default(''),\n    }),\n  ),\n});\n\nYour initial values will be using the schema defaults, and also the defaults will be used if the values submitted is missing these fields.\n\nZod preprocess\n\nYou can also define preprocessors to cast your fields before submission:\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, number, preprocess } from 'zod';\nimport { toTypedSchema } from '@vee-validate/zod';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      age: preprocess(val => Number(val), number()),\n    }),\n  ),\n});\n// typed as `unknown` since the source value can be anything\nvalues.age;\nhandleSubmit(submitted => {\n  // will be typed as number because zod made sure it is!\n  values.age;\n});\nValibot\n\nValibot is a schema library with bundle size, type safety and developer experience in mind. It is a great alternative to Yup and Zod if bundle size is a concern.\n\nYou can use valibot as a typed schema with the @vee-validate/valibot package:\n\nsh\n# npm\nnpm install @vee-validate/valibot\n# yarn\nyarn add @vee-validate/valibot\n# pnpm\npnpm add @vee-validate/valibot\n\nThe @vee-valdiate/valibot package exposes a toTypedSchema function that accepts any valibot schema. Which then you can pass along to validationSchema option on useForm.\n\nThis makes the form values and submitted values typed automatically and caters for both input and output types of that schema.\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, string, minLength } from 'valibot';\nimport { toTypedSchema } from '@vee-validate/valibot';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      email: string([minLength(1, 'required')]),\n      password: string([minLength(1, 'required')]),\n      name: string(),\n    }),\n  ),\n});\n// ❌ Type error, which means `values` is type-safe\nvalues.email.endsWith('@gmail.com');\nhandleSubmit(submitted => {\n  // No errors, because email is required!\n  submitted.email.endsWith('@gmail.com');\n  // ❌ Type error, because `name` is not required so it could be undefined\n  // Means that your fields are now type safe!\n  submitted.name.length;\n});\nValibot default values\n\nYou can also define default values on your schema directly and it will be picked up by the form:\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, string, withDefault, minLength } from 'valibot';\nimport { toTypedSchema } from '@vee-validate/valibot';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      email: withDefault(string([minLength(1, 'required')]), 'something@email.com'),\n      password: withDefault(string([minLength(1, 'required')]), ''),\n      name: withDefault(string(), ''),\n    }),\n  ),\n});\n\nYour initial values will be using the schema defaults, and also the defaults will be used if the values submitted is missing these fields.\n\nValibot transforms\n\nYou can also define transforms to cast your fields before submission:\n\nts\nimport { useForm } from 'vee-validate';\nimport { object, number, coerce, any } from 'valibot';\nimport { toTypedSchema } from '@vee-validate/valibot';\nconst { values, handleSubmit } = useForm({\n  validationSchema: toTypedSchema(\n    object({\n      age: coerce(any(), arg => Number(arg)),\n    }),\n  ),\n});\n\nBut note that this does not change the input or output types of the casted fields. The cast will only occur when setting the initial value and when the values are submitted in the submission handler."
  },
  {
    "title": "Composition Helpers",
    "url": "https://vee-validate.logaretm.com/v4/guide/composition-api/helpers/",
    "html": "Aside from useField and useForm and useFieldArray, these are a collection of simple functions that you can use to opt-in specific parts of vee-validate features like form state and various actions you can perform on fields and forms.\n\nHere are a few examples of what you can build with these functions:\n\nA custom submission progress component\nA custom error message component.\nA form validity indicators\nreset buttons or submit buttons\n\nHere is a list of the functions available that you can use:\n\nuseFieldError Gives access to a single field’s first error message\nuseFormErrors Gives access to the entire error bag of the form\nuseIsFieldDirty If a field is dirty\nuseIsFormDirty If the form is dirty (form contains at least one dirty field)\nuseIsFieldTouched If a field is touched\nuseIsFormTouched If the form is touched (form contains at least one touched field)\nuseIsFieldValid If a field is valid\nuseIsFormValid If all fields are validated and valid\nuseValidateField Returns a function that validates a specific field\nuseValidateForm Returns a function that validates the entire form\nuseResetForm Resets the form to its initial state\nuseSubmitForm Creates a submission function that validates and submits the form (even if no form element is involved)\nuseIsSubmitting If the form is currently submitting\nuseIsValidating If the form is currently validating by validate function\nuseSubmitCount The number of times the user attempted to submit the form\nuseFieldValue Returns a specific fields’ current value\nuseFormValues Returns the current form field values\n\nFor more information about the functions, you can head over to the API reference and check them out."
  },
  {
    "title": "Custom inputs",
    "url": "https://vee-validate.logaretm.com/v4/guide/composition-api/custom-inputs/",
    "html": "Building Custom inputs\nImperative vs Declarative\n\nSo far we’ve been using useForm to create forms and use defineField to create field-binding objects to integrate them with our fields. However, that usually requires a lot of boilerplate code to create the binding object and the field component.\n\nFor example, this is how a 5-field form looks like with useForm and defineField:\n\njs\nconst { defineField } = useForm();\nconst email = defineField('email');\nconst firstName = defineField('firstName');\nconst lastName = defineField('lastName');\nconst password = defineField('password');\nconst passwordConfirm = defineField('passwordConfirm');\n\nThis can get ugly very quickly especially if you have a lot of field arrays or nested fields involved. This is one of the downsides of using an imperative API, but with useField you can switch to declarative API and get rid of all that boilerplate code.\n\nuseField is a composition function that is similar to useForm. it makes it easier to create and manage input components. You should use it when creating custom input components and that means you’ve made the choice that vee-validate will be an integral part of your input component system.\n\nCreating a custom input component\n\nLet’s start with a simple example, we will create a InputText component that represents a text field. It can be as simple as this:\n\nvue\n<template>\n  <input v-model=\"value\" />\n  {{ errorMessage }}\n</template>\n<script setup>\nimport { useField } from 'vee-validate';\nconst props = defineProps({\n  name: String,\n});\n// The `name` is returned in a function because we want to make sure it stays reactive\n// If the name changes you want `useField` to be able to pick it up\nconst { value, errorMessage } = useField(() => props.name);\n</script>\n\nThis works exactly the same way as with defineField, but now since you have a vee-validate field component, you can use it directly in any component with a form context and it will just work:\n\nHere is a live example:\n\nNotice how much of the burden of defining fields went away as soon as switched to the declarative approach. This is where useField really shines, but that’s just us getting started. Follow along in this guide to make the most out of useField.\n\nValidation\n\nAll previous examples have used the form’s validation schema to validate the individual fields, however, you can also define a validation schema for each field individually. The same types of validation libraries are supported.\n\nYup Typed Schema\n\nYou can only validate using field-level validation or form-level validation, you cannot mix the two approaches here.\n\nValidating with yup\n\nYou can use Yup schemas to validate fields individually by passing the schema as the second argument to useField.\n\nValidating with Zod\n\nYou can use Zod, however, you will need to add @vee-validate/zod to your dependencies.\n\nsh\n# with npm\nnpm i @vee-validate/zod\n# with pnpm\npnpm add @vee-validate/zod\n# with yarn\nyarn add @vee-validate/zod\n\nThen you can wrap your zod field schemas with toTypedSchema function. More on that here.\n\nValidating with Valibot\n\nYou can use Valibot to validate your fields, however, you will need to add @vee-validate/valibot to your dependencies.\n\nsh\n# with npm\nnpm i @vee-validate/valibot\n# with pnpm\npnpm add @vee-validate/valibot\n# with yarn\nyarn add @vee-validate/valibot\n\nThen you can wrap your valibot field schemas with toTypedSchema function. More on that here.\n\nOther validation providers\nValidating with global validators\n\nAnother option is using @vee-validate/rules which have been historically bundled with past versions of vee-validate. It includes rules that can be defined globally and then used anywhere using Laravel-like string expressions.\n\nYou can refer to the full guide on global rules here.\n\nValidating with functions\n\nAnother option is to just use any 3rd party validation tool you prefer.\n\nTriggers\nDefault Behavior\n\nBy default, vee-validate runs validation whenever the value ref changes whether it was bound by a v-model or changed in your code:\n\njs\nconst { value } = useField('fieldName', yup.string().required());\n// validation WILL be triggered\nvalue.value = 'something';\n\nYou can disable that behavior by passing a validateOnValueUpdate option set to false:\n\njs\nconst { value } = useField('fieldName', yup.string().required(), {\n  validateOnValueUpdate: false,\n});\n// validation WILL NOT trigger\nvalue.value = 'something';\nHandling Events\n\nuseField() composition function is not concerned with any events, it only validates whenever the value ref changes. However, it gives you everything you need to set up your own validation experience.\n\nThe useField function exposes some handler functions, each handling a specific aspect of the validation experience:\n\nhandleChange: Updates the field value, can be configured to trigger validation or silently update the value\nhandleBlur: Updates the meta.touched flag, doesn’t trigger validation.\njs\nconst { handleChange, handleBlur } = useField('someField');\n\nIn this example, we are validating on the input event (when the user types), which would make the validation aggressive:\n\nWith a slight adjustment we can make our validation lazy by changing the listener to @change (validates when the user leaves the control):\n\nvue\n<div>\n  <input @change=\"handleChange\" :value=\"value\" type=\"text\" />\n  <span>{{ errorMessage }}</span>\n</div>\n\nNote that handleChange can be called anywhere, not just in the template, and not as just an event handler. You can use it to mutate the field value whenever you want, as an added bonus you can choose if handleChange should trigger a validation or not.\n\njs\nconst { handleChange } = useField('someField');\n// validates by default\nhandleChange('new value');\n// validates\nhandleChange('new value', true);\n// Doesn't validate\nhandleChange('new value', false);\n\nLet’s say you want to validate on blur instead. You can use the handleBlur in a similar way. The main differences are:\n\nhandleBlur doesn’t mutate the value of the field. It only sets the meta.touched to true.\nhandleBlur does not validate the current value by default, you have to pass true as a second argument to trigger validation.\n\nWith that info in mind, you can validate on blur like so:\n\nvue\n<div>\n  <input\n    :value=\"value\"\n    type=\"text\"\n    @change=\"handleChange\"\n    @blur=\"handleBlur($event, true)\"\n  />\n  <span>{{ errorMessage }}</span>\n</div>\n\nAs you can see, the useField doesn’t care which events you use handleChange for. This allows for greater flexibility that’s not possible with the <Field> component, not as straightforward at least.\n\nConsider this validation experience:\n\nValidate on Change/Blur initially (when the user leaves the control), let’s call this lazy mode.\nIf the field is invalid, switch the validation to validate on input (when the user types), let’s call this aggressive mode.\nIf the field is valid, go back to “lazy” mode, otherwise, be “aggressive”.\n\nImplementing this requires some knowledge about how the v-on (we can bind objects on it) handler works.\n\njs\nconst { errorMessage, value, handleChange } = useField(() => props.name, undefined, {\n  validateOnValueUpdate: false,\n});\nconst validationListeners = {\n  blur: evt => handleBlur(evt, true),\n  change: handleChange,\n  input: evt => handleChange(evt, !!errorMessage.value),\n};\n\nThen in your template, you can use v-on to add your listener object:\n\nvue\n<input :value=\"value\" v-on=\"validationListeners\" type=\"text\" />\n\nHere is a full example:\n\nv-model Support\n\nThe useField function can automatically manage v-model integration for you. Usually, you will need to do this in every component you create:\n\njs\nconst props = defineProps({\n  modelValue: String,\n});\nconst emit = defineEmits(['update:modelValue']);\n\nInstead, you can let useField do that for you by telling it to enable v-model syncing:\n\njs\nconst props = defineProps({\n  modelValue: String,\n});\nconst { value, errorMessage } = useField('fieldName', undefined, {\n  syncVModel: true,\n});\n\nNow whenever value changes, you will emit an update:modelValue event with the new value. This is useful when you want to use v-model with your custom input component:\n\nYou can also use different prop names for the modelValue, for example, v-model:text can be implemented by passing the model name directly to syncVModel.\n\njs\nconst props = defineProps({\n  text: String,\n});\nconst { value, errorMessage } = useField('fieldName', undefined, {\n  syncVModel: 'text',\n});\n\nThis will emit onUpdate:text instead of onUpdate:modelValue whenever the value changes.\n\nDisplaying Error Messages\n\nYou’ve already seen how to display errors with useForm. With useField you can use errorMessage ref:\n\njs\nconst { errorMessage, value } = useField('fieldName', yup.string().required());\n// contains the error message if available\nerrorMessage.value;\n\nIn addition to this, you can get all errors for the field using the errors ref which contains multiple error messages if applicable:\n\njs\nconst { errors, value } = useField('fieldName', yup.string().required());\n// contains an array of error messages, otherwise empty array\nerrors.value;\n\nHere is an example where each field displays its entire range of error messages:\n\nCustom Field Labels\n\nMore often than not, your fields will have names with underscores or shorthands which isn’t very nice when showing in error messages, for example, you might have specific encoding to your field names because they might be generated by the backend. Ideally, you want to avoid having messages like:\n\ntxt\nThe down_p is required\n\nAnd instead show something more meaningful to the user\n\ntxt\nThe down payment is required\n\nYou can do this in two ways depending on which validators you are using (yup or global validators).\n\nCustom Labels with Yup\n\nWith yup it is very straightforward, you just need to call label() after defining your field’s validations either at the field level or form level:\n\njs\nconst schema = Yup.object({\n  email_addr: Yup.string().email().required().label('Email Address'),\n  acc_password: Yup.string().min(5).required().label('Your Password'),\n});\nCustom Labels with Zod\n\nWith Zod it is similar, you call the label function and give it the name you want to use in the generated message.\n\njs\nconst schema = z.object({\n  email_addr: z.string().email().label('Email Address'),\n  acc_password: z.string().min(5).label('Your Password'),\n});\n\nIf you are interested in how to do the same for global validators check the i18n guide\n\nField-level Meta\n\nEach field has metadata associated with it, the meta property returned from useField contains information about the field:\n\nvalid: The current field validity, is automatically updated for you.\ntouched: If the field was touched, can be updated with setTouched on useField’s return value.\ndirty: If the field value was updated, you cannot change its value.\npending: If the field’s validations are still running, useful for long-running async validation.\ninitialValue: The field’s initial value, is undefined if you didn’t specify any.\njs\nconst { meta } = useField('fieldName');\nmeta.dirty;\nmeta.pending;\nmeta.touched;\nmeta.valid;\nmeta.initialValue;\n\nThis is the typescript interface for a field’s meta value\n\nts\ninterface FieldMeta {\n  dirty: boolean;\n  pending: boolean;\n  touched: boolean;\n  valid: boolean;\n  initialValue: any;\n}\n\nJust like how the form’s meta is read-only, this is also read-only and you cannot change it directly. Actually, only the touched meta value can be mutated using handleBlur, all other meta values are automatically updated for you as the field validates or when it changes its value.\n\njs\nconst { meta, handleBlur } = useField('fieldName');\n// updates meta.touched = true\nhandleBlur();\n\nValid Flag Combinations\n\nSince the meta.valid flag is initially true (because it just means there are no errors yet), it would cause problems if you have a “success” UI state as an indicator.\n\nTo avoid this case you should combine the valid flag with either meta.dirty or meta.touched to get an accurate representation. You will see that in action in the next example.\n\nIn the following example, we the various meta information flags to style the input with some styling.\n\nField Dirty Flag and Initial Values\n\nNotice in the previous example, we passed an initialValue, this is because the default field value is undefined which may cause unexpected meta.dirty results.\n\nTo get accurate results for the meta.dirty flag, you must provide an initial value to your field even if the values are empty.\n\nTo reduce the verbosity of adding an initialValue prop to each field, you could provide the initialValues prop to your useForm call instead.\n\nBuilding checkboxes\n\nCheckboxes are a hard type of input to implement, mainly because of the expectations about how it should mutate the form’s value. For example, a checkbox can be used to toggle between true or false values which is common with single checkboxes. But it can also be used in a group to act as a multi-select between multiple options. In that case, it adds or removes its own “checked” value to the group value.\n\nThis means checkboxes have three states to maintain:\n\nIt’s own checked value. In HTML this is done with the value attribute for native input[type=\"checkbox\"] elements.\nThe current from value and if it is a checkbox group or a single checkbox. This is usually the modelValue prop for components.\nIf it is checked or not, if the checked value equals or is in the form value then it is checked. This should be computed based on the previous fact.\n\nAll of this can be hard to wrap your head around. However, useField makes this as it already handles the nuances of checkboxes.\n\nThe useField function accepts a type option that you can use to tell vee-validate that the input type is a checkbox and also accepts a checkedValue option.\n\nts\nconst { handleChange, checked } = useField('myCheckbox', undefined, {\n  type: 'checkbox',\n  checkedValue: 'opt1',\n});\n\nA simple integration with an input element would look like this:\n\nNote that we are not using v-model with the value returned from useField here. This is because handleChange is better suited for checkboxes as it handles toggling the value on or off and is also aware of the form has other checkboxes so it also handles whether the value should be an array or a single value.\n\nYou can find a more advanced example of checkboxes on this page."
  },
  {
    "title": "Nested Objects and Arrays",
    "url": "https://vee-validate.logaretm.com/v4/guide/composition-api/nested-objects-and-arrays/",
    "html": "Nested Objects and Arrays\n\nvee-validate supports nested objects and arrays by using field path syntax to indicate a field’s path. This allows you to structure forms easily to make data mapping straightforward without having to deal with flat form values.\n\nNested Objects\n\nYou can specify a field to be nested in an object using dot paths, like what you would normally do in JavaScript to access a nested property. The field’s name acts as the path for that field in the form values:\n\njs\nconst { defineInputBinds } = useForm();\nconst twitterLink = defineInputBinds('links.twitter');\nconst githubLink = defineInputBinds('links.github');\n\nSubmitting the previous form would result in the following values being passed to your handler:\n\njs\n{\n  \"links\": {\n    \"twitter\": \"https://twitter.com/logaretm\",\n    \"github\": \"https://github.com/logaretm\"\n  }\n}\n\nHere is a live example so you can see it in action.\n\nYou are not limited to a specific depth, you can nest as much as you like.\n\nNested Arrays\n\nSimilar to objects, you can also nest your values in an array, using square brackets just like how you would do it in JavaScript.\n\njs\nconst { defineInputBinds } = useForm();\nconst twitterLink = defineInputBinds('links[0]');\nconst githubLink = defineInputBinds('links[1]');\n\nHere is the same example as above but in array format:\n\nSubmitting the previous form would result in the following values being passed to your handler:\n\njs\n{\n  \"links\": [\n    \"https://twitter.com/logaretm\",\n    \"https://github.com/logaretm\"\n  ]\n}\n\nWARN\n\nvee-validate will only create nested arrays if the path expression is a complete number, for example, paths like some.nested[0path] will not create any arrays because the 0path key is not a number. However some.nested[0].path will create the array with an object as the first item.\n\nAvoiding Nesting\n\nIf your fields’ names are using the dot notation and you want to avoid the nesting behavior which is enabled by default, all you need to do is wrap your field names in square brackets ([]) to disable nesting for those fields.\n\njs\nconst { defineInputBinds } = useForm();\nconst twitter = defineInputBinds('[links.twitter]');\nconst github = defineInputBinds('[links.github]');\n\nSubmitting the previous form would result in the following values being passed to your handler:\n\njs\n{\n  \"links.twitter\": \"https://twitter.com/logaretm\",\n  \"links.github\": \"https://github.com/logaretm\"\n}\n\nHere is a live example on that:\n\nField Arrays\n\nField arrays are a special type of nested array fields, they are often used to collect repeatable pieces of data or repeatable forms. They are often called “repeatable fields”.\n\nTo set up a repeatable block of the form, you can use useFieldArray to help you manage the array values and operations. It requires a form context to be present so useForm must be called before you use useFieldArray either in parent component or in the same component.\n\njs\nimport { useForm, useFieldArray } from 'vee-validate';\nuseForm();\nconst { remove, push, fields } = useFieldArray('users');\n\nThe useFieldArray exposes a few properties and functions to help you manage the array fields, the most special one is the fields array which contains the array items and represents their current value in the form. You will use fields as an iteration source to render the array items.\n\nHere is an example of a repeatable block of fields, we mutate the field value with v-model directly on the iteration item value.\n\nNotice that we used field.key as the key of the iteration, this is because vee-validate generates a unique key for each array item so you can rely it on without having to generate them yourself.\n\nWARN\n\nThe key property generated on array items is not an index. It is a unique identifier for the array item that is independent of the array index, so you should not be using it to reference field names.\n\nField Array Paths\n\nWhen calling useFieldArray you need to provide a name prop which is the path of the array starting from the root form value, you can use dot notation for object paths or indices for array paths.\n\nHere are a few examples:\n\nIterate over the users array:\n\njs\nconst { remove, push, fields } = useFieldArray('users');\n\nIterate over the domains inside settings.dns object:\n\njs\nconst { remove, push, fields } = useFieldArray('settings.dns.domains');\nArray Helpers\n\nThe <useFieldArray /> function provides the following properties and functions:\n\nfields: a read-only version of your array field items, it includes some useful properties like key, isFirst and isLast, the actual item value is inside .value property. You should use it to iterate with v-for.\npush(item: any): adds an item to the end of the array.\nprepend(item: any): adds an item to the start of the array.\ninsert(idx: number, item: any): Inserts an array item at the specified index.\nremove(idx: number): removes the item with the given index from the array.\nswap(idxA: number, idxB: number): Swaps two array elements by their indexes.\nreplace(items: any[]): Replaces the entire array values with the given items.\nupdate(idx: number, value: any): Updates an array item value at the specified index.\nmove(oldIdx: number, newIdx: number): Moves an array item to a different position within the array.\n\nRead the API reference for more information.\n\nCaveats\nPaths creation and destruction\n\nvee-validate creates the paths inside the form data automatically but lazily, so initially, your form values won’t contain the values of the fields unless you provide initial values for them. It might be worthwhile to provide initial data for your forms with nested paths.\n\nWhen fields get unmounted like in the case of conditional rendered fields with v-if or v-for, their path will be destroyed just as it was created if they are the last field in that path. So you need to be careful while accessing the nested field in values inside your submission handler.\n\nPath destruction can be annoying when dealing with multi-step forms or tabbed forms where you want all the values to be available even when the fields are unmounted. You can control this behavior by passing keepValueOnUnmount prop to the useField function or you can do it for all the fields by passing keepValuesOnUnmount to the useForm function.\n\nNote that the priority of this configuration follows the field config first then it fallbacks to the form’s config.\n\njs\nimport { useForm } from 'vee-validate';\n// keep all values when their fields get unmounted\nconst { values } = useForm({\n  keepValuesOnUnmount: true,\n});\njs\nimport { useField } from 'vee-validate';\n// this field value will be removed\nconst field = useField('field', undefined, {\n  keepValueOnUnmount: false,\n});\nReferencing Errors\n\nWhen referencing errors using errors object returned from the useForm function. Make sure to reference the field name in the same way you set it on the name argument for that field. So even if you avoid nesting you should always include the square brackets. In other words errors do not get nested, they are always flat.\n\nSince vee-validate supports yup and zod schemas, referencing the nested fields may vary depending on how you are specifying the schema.\n\nIf you are using yup, you can utilize the nested yup.object or yup.array schemas to provide validation for your nested fields, here is an example:\n\nYou can visit this link for a practical example using nested arrays."
  },
  {
    "title": "Handling Forms",
    "url": "https://vee-validate.logaretm.com/v4/guide/composition-api/handling-forms/",
    "html": "Handling Forms\n\nvee-validate makes it easy to handle form submissions, resets, and DX to make your forms much easier to reason about and less of a burden to maintain. The useForm function allows you to easily handle:\n\nForm state (valid/dirty/touched/pending).\nSubmitting forms and handling invalid submissions.\nHandling form resets.\nForm Metadata\n\nForms have a meta object value containing useful information about the form, it acts as an aggregation of the metadata for the fields inside that form.\n\njs\nconst { meta } = useForm();\nmeta.value.dirty;\nmeta.value.pending;\nmeta.value.touched;\nmeta.value.valid;\nmeta.value.initialValues;\nvalid: The form’s validity status, will be true if the errors array is empty initially, but will be updated once the form is mounted.\ntouched: If at least one field was blurred (unfocused) inside the form.\ndirty: If at least one field’s value was updated.\npending: If at least one field’s validation is still pending.\ninitialValues: All fields’ initial values, this is an object where the keys are the field names.\n\nHere is a simple example where we disable the form’s submit button unless a field was touched.\n\nHandling Submissions\n\nvee-validate exposes useful defaults to help you handle form submissions whether you submit them using JavaScript or native HTML submissions.\n\nJavaScript Submissions (AJAX)\n\nTo handle submissions, you can use the handleSubmit function to create submission handlers for your forms, the handleSubmit function accepts a callback that receives the final form values.\n\njs\nconst { handleSubmit } = useForm({\n  validationSchema: yup.object({\n    email: yup.string().email().required(),\n    password: yup.string().min(6).required(),\n  }),\n});\n// Creates a submission handler\n// It validates all fields and doesn't call your function unless all fields are valid\n// You can bind `onSubmit` to a form element's submit event, or call it directly to submit the current data.\nconst onSubmit = handleSubmit(values => {\n  alert(JSON.stringify(values, null, 2));\n});\n\nHere is an example that makes use of handleSubmit to validate before submitting the form.\n\nThe handleSubmit function will only execute your callback once the returned function (onSubmit in the example) if all fields are valid, meaning you don’t have to handle if the form is invalid in your logic.\n\nYou can call the returned function either manually or via an event like @submit and it will validate all the fields and execute the callback if everything passes validation.\n\nAs a bonus, when the returned function is used as an event handler (like in the previous example) it will automatically prevent the default submission of the form so you don’t need to use the prevent modifier like you normally would.\n\nFull-Page Submissions (non-AJAX)\n\nFor non-ajax submissions that trigger a full page reload, you can use the submitForm function instead of handleSubmit. You normally would use this if you are not building a single-page application. In the following example, we submit the form to another tab using the get form method.\n\nIn that case YOU MUST use submitForm as an event handler for the submit event for a native form element, otherwise, it would have no effect.\n\nHandling Invalid Submissions\n\nSometimes you want to perform some logic after a form fails to submit due to validation errors (e.g. focusing the first invalid field), you can pass a callback as the second argument to the handleSubmit function.\n\njs\nconst { handleSubmit } = useForm();\nfunction onSuccess(values) {\n  alert(JSON.stringify(values, null, 2));\n}\nfunction onInvalidSubmit({ values, errors, results }) {\n  console.log(values); // current form values\n  console.log(errors); // a map of field names and their first error message\n  console.log(results); // a detailed map of field names and their validation results\n}\n// This handles both valid and invalid submissions\nconst onSubmit = handleSubmit(onSuccess, onInvalidSubmit);\n\nHere is a quick example of how to scroll to and focus the first invalid field after a failed submission attempt.\n\nSubmission Progress\n\nQuite often you need to show your users a submission indicator, or you might want to disable the submit button entirely until the submission attempt is done. The useForm function exposes an isSubmitting ref that you can use.\n\nThe isSubmitting state will be set to true once the validation of the form starts (as a result of a submit event) and will keep track of the submission handler you passed to either onSubmit or until it calls submitForm. If the submission handler throws any errors or completes successfully it will be set to false afterward.\n\njs\nconst { isSubmitting } = useForm();\nSubmit Count\n\nThe useForm function also exposes a submitCount ref that you can use to track the number of submissions attempted by the user. The count is incremented regardless of the validation result.\n\njs\nconst { submitCount } = useForm();\n\nMaybe you want to lock the form if too many attempts were made, or you want to show a message after the first submission attempt.\n\nSubmission Behavior\n\nvee-validate does the following when calling submission handlers created by handleSubmit or when calling submitForm as a result of the user submitting the form.\n\nBefore validation stage\nSets all fields touched meta to true\nSets isSubmitting form state to true\nIncrements the submitCount form state by 1\nValidation stage\nSets form and individual fields meta pending to true to indicate validation is in progress\nRuns the validation function/schema/rule against the current form values asynchronously\nChecks for any errors in the validation result\nIf there are errors then it will skip the next stage and update the validation state (meta, errors) for the form and fields\nIf there aren’t any errors then it will set the pending meta flag to false and proceed to the next stage\nAfter validation stage\nCalls the handleSubmit handler you passed\nAfter the callback finishes (it will wait if the result is asynchronous), then it will set isSubmitting to false\n\nNote that there isn’t a need to have isSubmitting set back to false if you’ve used submitForm, as this submission method will perform a full-page refresh (native forms behavior).\n\nForm Values\n\nYou may have noticed in the earlier examples that you can access all fields’ values using the values reactive object returned by useForm.\n\njs\nconst { values } = useForm();\n\nThe values object is read-only and should not be mutated with a v-model or by assigning a value to it. This is because all mutations are done through the vee-validate API, this is because mutations to form state need to have a context.\n\nFor example:\n\njs\nconst { values } = useForm();\n// ❌ Do not do that!\nvalues.email = '';\n\nIn order for the form UX to be stable, we need to understand why the email value was set to ''. Was it being reset? should we run validation again? This is the type of small differences that are a result of vee-validate’s design choice based on fields and forms, not values.\n\nInitial Values\n\nSince you don’t have to use v-model to track your values, the useForm function allows you to define the starting values for your fields, by default all fields start with undefined as a value.\n\nUsing the initialValues option you can send an object that contains the field names as keys and their values:\n\njs\nconst { defineInputBinds } = useForm({\n  initialValues: {\n    email: 'test@example.com',\n    password: 'p@$$w0rd',\n  },\n});\n\nTIP\n\nIt’s generally recommended that you provide the initialValues, this is because vee-validate cannot assume a reasonable initial value for your fields other than undefined which may cause unexpected behavior when using a 3rd-party validator that does not deal with undefined.\n\nTIP\n\nIf you are using zod or yup with Typed schemas, you can define the initial values on the validation schema directly with .default instead of having to specify initialValues.\n\nYou can reset initial values at any time using the resetForm function returned by useForm.\n\nManually Setting Form Values\n\nYou can set any field’s value using either setFieldValue or setValues returned by useForm.\n\njs\nconst { setFieldValue, setValues } = useForm();\n// Sets a value of a specific field in the form values\nsetFieldValue('fieldName', 'value');\n// Merges the given object with the current form values\nsetValues({\n  fieldName: 'value',\n});\nControlled Values\n\nThe form values can be categorized into two categories:\n\nControlled values: values that have a form input controlling them via defineInputBinds or defineComponentBinds or useField or <Field />.\nUncontrolled values: values that are inserted dynamically with setFieldValue or inserted initially with initial values.\n\nSometimes you maybe only interested in controlled values. For example, your initial data contains noisy extra properties from your API and you wish to ignore them when submitting them back to your API.\n\nWhen accessing values from useForm result or the submission handler you get all the values, both controlled and uncontrolled values. To get access to only the controlled values you can use controlledValues from the useForm result:\n\njs\nconst { handleSubmit, controlledValues } = useForm();\nconst onSubmit = handleSubmit(async () => {\n  // Send only controlled values to the API\n  const response = await client.post('/users/', controlledValues.value);\n});\n\nAlternatively, for less verbosity, you can create submission handlers with only the controlled values with handleSubmit.withControlled which has the same API as handleSubmit:\n\njs\nconst { handleSubmit } = useForm();\nconst onSubmit = handleSubmit.withControlled(async values => {\n  // Send only controlled values to the API\n  const response = await client.post('/users/', values);\n});\n\nHere is an example that filters out some noisy initial values when submitting the form using the withControlled modifier.\n\nSetting initial values asynchronously\n\nSometimes your data is fetched asynchronously from an API and you want to set the initial values or the current values after the data is fetched. You can do that by using resetForm to set both current and initial data.\n\nYou could alternatively use setValues but note that setValues can trigger validation and do not reset the meta state for the fields like dirty or touched.\n\nHandling Resets\n\nvee-validate also handles form resets in a similar way to submissions. When resetting the form, all fields’ errors will be cleared, meta info will be reset to defaults and the values will be reset to their original or initial values.\n\nTo reset forms you can use the resetForm function returned by useForm. You can also reset the form to a new state by passing a FormState object to the resetForm function. You can then set errors, touched meta, and the values.\n\njs\nconst { resetForm } = useForm();\n// Rests the form\nresetForm();\n//\nresetForm({\n  touched: {\n    email: false,\n  },\n  errors: {\n    email: 'custom error',\n  },\n  values: {\n    email: 'newvalue@email.com',\n  },\n});\n\nThis is the shape of the FormState object:\n\nts\ninterface FormState {\n  // any error messages\n  errors: Record<string, string>;\n  // touched meta flags\n  touched: Record<string, boolean>;\n  // Form Values\n  values: Record<string, any>;\n}\n\nHere is an example where a full form is being reset:\n\nResetting Forms After Submit\n\nUsually, you will reset your forms after successful submission. For convenience, the onSubmit handler receives an additional FormActions object in the second argument that allows you to do some actions on the form after submissions, this is the shape of the FormActions object:\n\nts\nexport interface FormActions {\n  setFieldValue: (field: T, value: any) => void;\n  setFieldError: (field: string, message: string | undefined) => void;\n  setErrors: (fields: Partial<Record<string, string | undefined>>) => void;\n  setValues: (fields: Partial<Record<T, any>>) => void;\n  setFieldTouched: (field: string, isTouched: boolean) => void;\n  setTouched: (fields: Partial<Record<string, boolean>>) => void;\n  resetForm: (state?: Partial<FormState>) => void;\n}\n\nThis is an example of using the form actions object to reset the form:\n\nErrors\n\nAs you have previously seen in some examples, you have access to errors with useForm that contains a mapping of each field’s path and its error message.\n\njs\nconst { errors } = useForm();\n\nHowever, if you want to display multiple errors for your fields then you can use errorBag which is a mapping of each field’s path and an array of error messages for that field.\n\njs\nconst { errorBag } = useForm();\n\nHere is an example that displays multiple errors for a field:\n\nInitial Errors\n\nIf you are building a non-SPA application it is very common to pre-fill form errors using server-side rendering, frameworks like Laravel and Rails make this very easy to do. vee-validate supports filling the errors initially before any validation is done using the initialErrors option.\n\nThe initialErrors option accepts an object containing the field names as keys with their corresponding error message string.\n\njs\nuseForm({\n  initialErrors: {\n    email: 'This email is already taken',\n    password: 'The password is too short',\n  },\n});\n\nTIP\n\ninitialErrors are applied once the component that called useForm is mounted and is ignored after, so any changes to the initialErrors props won’t affect the messages.\n\nSetting Errors Manually\n\nQuite often you will find yourself unable to replicate some validation rules on the client-side due to natural limitations. For example, unique email validation is complex to implement on the client side. So the ability to set errors manually can be useful.\n\nYou can set messages for fields by using either setFieldError which sets an error message for one field at a time, or by using the setErrors function which allows you to set error messages for multiple fields at once.\n\nBoth functions are available as a return value from useForm. In the following example, we check if the server response contains any validation errors and we set them on the fields:\n\njs\nconst { handleSubmit, setFieldError, setErrors } = useForm();\nconst onSubmit = handleSubmit(async values => {\n  // Send data to the API\n  const response = await client.post('/users/', values);\n  // all good\n  if (!response.errors) {\n    return;\n  }\n  // set single field error\n  if (response.errors.email) {\n    setFieldError('email', response.errors.email);\n  }\n  // set multiple errors, assuming the keys are the names of the fields\n  // and the key's value is the error message\n  setErrors(response.errors);\n});\n\nAlternatively, you can use the FormActions passed as the second argument to the handleSubmit callback which contains both functions for convenience:\n\njs\nconst onSubmit = handleSubmit(async (values, actions) => {\n  // Send data to the API\n  const response = await client.post('/users/', values);\n  // ...\n  // set single field error\n  if (response.errors.email) {\n    actions.setFieldError('email', response.errors.email);\n  }\n  // set multiple errors, assuming the keys are the names of the fields\n  // and the values is the error message\n  actions.setErrors(response.errors);\n});\n\nHere is an example that sets form errors after submission, usually you will have a backend API that returns the errors:"
  },
  {
    "title": "Getting started",
    "url": "https://vee-validate.logaretm.com/v4/guide/composition-api/getting-started/",
    "html": "Getting started\n\nvee-validate is built from the ground up with the composition API through a collection of functions, mainly the useField and useForm functions. Internally the <Form /> and <Field /> components actually use the composition functions under the hood.\n\nMeaning you can create your own custom input and form components and they will be treated the same as <Form /> and <Field /> components. You can mix them together and use a Form component with any other custom component that uses useField and vice versa.\n\nvee-validate supports synchronous and asynchronous validation and allows defining rules on the field level or the form level using validation schemas. vee-validate has first-class support for:\n\nyup through @vee-validate/yup package.\nzod through @vee-validate/zod package.\nGlobal validators (Laravel-like syntax) through @vee-validate/rules.\n\nvee-validate has historically been a declarative validation library, and while the composition API changes things a bit, it still follows the same mindset of declarative validation. vee-validate optimizes for building fields and forms, not values.\n\nWhen to use composition API\n\nWhile vee-validate offers both declarative components and composition functions to supercharge your forms, it is always up to you to decide which one to use. However, the composition API is easier to integrate and more flexible. You can build custom components with it or integrate it with any UI library. It is generally recommended to use the composition API.\n\nOn this page, you will learn how to declare forms and how to hook your elements and components into vee-validate forms and achieve value tracking, validation, and more.\n\nDeclaring Forms\nForm context\n\nYou can declare forms with the useForm function exported from the vee-validate core package. This is a composition API function that marks the current component as a form.\n\nvue\n<script setup>\nimport { useForm } from 'vee-validate';\n// Creates a form context\n// This component now acts as a form\n// Usually you will destruct the form context to get what you need\nconst { values } = useForm();\n</script>\n<template>\n  <pre>{{ values }}</pre>\n</template>\n\nCalling useForm creates a form context in the component and provides it for any child component that injects it. This means you should stick to calling useForm once in a component.\n\nCreating a form context does a few things:\n\nActs as a value collector for all the fields you will declare as child components.\nValidates the fields and aggregates the errors.\nAggregates the validity, touched, and dirty states of all the fields.\nField binds\n\nWith useForm declared, you are now ready to integrate the form with your elements and components. vee-validate is agnostic to the UI you are using.\n\nYou will learn how to associate your components and elements with the form and how to get value collection, validation, and error messages working.\n\nHTML Inputs\n\nuseForm provides a function called defineField. This function accepts a field path and returns a value model and an object containing the bindings for the input element. The field path is a string that represents the path to the field in the form context.\n\nFor example, if you have a field called email in the form context, the field path will be email.\n\nts\nconst { defineField } = useForm();\nconst [email, emailAttrs] = defineField('email');\n\nNote that defineField generates a pair of values, the first one is the value model and the second one is the attributes/props object. The props object contain attributes or event listeners that are useful to have on the input control or component which enables custom validation triggers and more.\n\nHere is a basic example of how to use defineField with a simple input element:\n\nNotice that as you type in the input, the values are automatically updated with the value changes.\n\nLet’s quickly add a validation schema on the form to see some errors on the form. We will be using yup throughout the examples, but you can use zod or any other supported validation library you want.\n\nTo add a yup schema or any kind of form schema, you pass it to the validationSchema option when calling useForm. Naturally, form schemas are almost always an object or a shape schema.\n\nts\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n});\nconst { defineField } = useForm({\n  validationSchema: schema,\n});\nconst [email, emailAttrs] = defineField('email');\n\nHere is a full running example:\n\nNotice as you type into the input, the validation is then triggered and the errors are populated. By default defineField optimizes for aggressive validation, meaning the validation will be triggered whenever the model changes.\n\nYou can change that behavior. For example, you can make it “lazy” by passing a configuration to defineField to disable validation on model updates with validateOnModelUpdate config.\n\nNow as you type in the field, the input is immediately validated. You can do more with dynamic configurations.\n\nComponents\n\nSimilarly to HTML inputs, you can achieve the same results with the same defineField function.\n\nFollowing the previous examples we can achieve value tracking like this:\n\nAs you type into the input, notice that the values are being updated.\n\nLet’s add validation to the previous example:\n\nNotice that for components, validations are executed immediately. This is intended because component implementations are not standardized across the Vue ecosystem as there is no guarantee it will emit the same range of events as the native HTML elements. However, you can customize the validation trigger if you know the components you are using are emitting the right events to support the behavior.\n\nMapping attributes and props\n\nBut aside from the attributes and listeners that vee-validate adds to those binding objects, you can also map the attributes and props of the in. This is useful when you want to:\n\nWhen you want to map the attributes/props to a different name.\nPass new attributes/props to the component/element based on the field state.\n\nYou can use props to include any additional props or attributes you need to add to the component/element.\n\nts\nconst { defineField } = useForm({\n  // ...\n});\nconst [email, emailProps] = defineField('email', { props: state => ({ error: state.errors[0] }) });\n\nIn the following example, we have a component that accepts an error string prop and shows that message if it is not empty. This is common in many UI libraries as they try not to lock you into a specific validation library.\n\nTIP\n\nThe state object contains a lot of useful information about the field, it is fully typed so you can explore it with your IDE or visit the source reference for more information.\n\nNotice that form also gives you access to errors so you can reference them anywhere in the component.\n\nDynamic configuration\n\nInstead of passing a static configuration object defineField, you could pass a function that returns different configuration values. This is useful when you want the configuration to be dynamic based on the field state.\n\nHere is an example that shows how to make the validation behavior “eager”. Meaning if the field does not have any errors then it will only validate on change.\n\nBut once it is invalid, it validates on each input event, making it “eager” for success.\n\nForm Schema\n\nAs you have seen in the previous examples, the useForm function accepts a validationSchema that is used to validate the form. We’ve been using yup to define the schema however you can use zod or any 3rd-party validators.\n\nValidating with Yup\n\nYou can pass yup schemas directly as you’ve seen previously, but it is recommended that you use the @vee-validate/yup package. It will enable better support of yup features and unlock full typescript support for your schemas.\n\nsh\n# with npm\nnpm i @vee-validate/yup\n# with pnpm\npnpm add @vee-validate/yup\n# with yarn\nyarn add @vee-validate/yup\n\nThe package exposes a toTypedSchema function that you can use to wrap your yup schemas, this allows vee-validate to infer form input and output types. More on that here.\n\nts\nimport { useForm } from 'vee-validate';\nimport { toTypedSchema } from '@vee-validate/yup';\nimport * as yup from 'yup';\n// Creates a typed schema for vee-validate\nconst schema = toTypedSchema(\n  yup.object({\n    email: yup.string().required().email(),\n  }),\n);\nconst { errors, values } = useForm({\n  validationSchema: schema,\n});\n\nYup Schema Optimizations\n\nThere are a couple of optimization caveats when it comes to using yup schemas to validate your forms, be sure to check the best practices guide.\n\nValidating with Zod\n\nYou can use Zod in a very similar manner to how we’ve been using yup in the past examples. However, you will need to add @vee-validate/zod to your dependencies.\n\nsh\n# with npm\nnpm i @vee-validate/zod\n# with pnpm\npnpm add @vee-validate/zod\n# with yarn\nyarn add @vee-validate/zod\n\nThen you can wrap your zod schemas with toTypedSchema function which allows vee-validate to infer form input and output types. More on that here.\n\nts\nimport { useForm } from 'vee-validate';\nimport { toTypedSchema } from '@vee-validate/zod';\nimport { z } from 'zod';\n// Creates a typed schema for vee-validate\nconst schema = toTypedSchema(\n  z.object({\n    email: z.string().nonempty().email(),\n  }),\n);\nconst { errors, values } = useForm({\n  validationSchema: schema,\n});\n\nHere is a full example using zod with useForm:\n\nrefine/superRefine\n\nThere is a known issue with Zod’s refine and superRefine not executing whenever some object keys are missing which is common with forms. This is not an issue with vee-validate as it is a design choice in Zod at the moment. Refer to this issue for explanations and further reading.\n\nValidating with Valibot\n\nYou can also use Valibot which is is a schema library with bundle size, type safety and developer experience in mind. It is a great alternative to Yup and Zod if bundle size is a concern. You will need to use the @vee-validate/valibot package to use valibot schemas.\n\nsh\n# with npm\nnpm i @vee-validate/valibot\n# with pnpm\npnpm add @vee-validate/valibot\n# with yarn\nyarn add @vee-validate/valibot\n\nThen you can wrap your Valibot schemas with toTypedSchema function which allows vee-validate to infer form input and output types. More on that here.\n\nts\nimport { useForm } from 'vee-validate';\nimport { string, object, email, minLength } from 'valibot';\nimport { toTypedSchema } from '@vee-validate/valibot';\n// Creates a typed schema for vee-validate\nconst schema = toTypedSchema(\n  object({\n    email: string([minLength(1, 'required'), email()]),\n  }),\n);\nconst { errors, values } = useForm({\n  validationSchema: schema,\n});\n\nHere is a full example using valibot with useForm:\n\nOther validation providers and options\nGlobal Rules\n\nAnother option is using @vee-validate/rules which have been historically bundled with past versions of vee-validate. It includes rules that can be defined globally and then used anywhere using Laravel-like string expressions.\n\nYou can refer to the full guide on global rules here.\n\nValidating with functions\n\nAnother option is to just use any 3rd party validation tool you prefer, something like validator.js. Here is a quick example:\n\nOr you could use any custom function.\n\nTIP\n\nBoth zod and yup are very good at defining schemas especially nested values so it is recommended that you use either. As an added bonus, you get full typescript support with either of them. You can refer to the Typed schemas guide to learn more about how to maximize the type safety of your schemas.\n\nDynamic Form Schemas\n\nThere are a few ways you can create dynamic schemas (reactive) where it changes the validation rules based on some state. The first way to do that is with computed.\n\nWhen the validation schema value changes, only the fields that were validated at least once will be re-validated, the other fields won’t be validated to avoid aggressive validation behavior.\n\nThere are other ways depending on which validation library you are using. For example, with yup you can achieve the same with yup.lazy or zod.lazy:"
  },
  {
    "title": "Validation",
    "url": "https://vee-validate.logaretm.com/v4/guide/components/validation/",
    "html": "Validation\n\nvee-validate handles complex validations in a very easy way, it supports synchronous and asynchronous validation and allows defining rules on the field-level or the form level using validation schemas with built-in support for yup.\n\nYou will be using the following components to validate your forms:\n\nA Field component represents a single form input and can be used to render any kind of HTML elements or Vue components.\nA Form component that renders a form. Do not confuse the <Form> tag with the HTML <form> tag.\nAn ErrorMessage component that displays an error message for a field, you don’t have to use it as there are many ways to render error messages.\n\nHere is the most simple example in action:\n\nSee the Pen Basic Example by Abdelrahman Awad ( @logaretm) on CodePen.\n\nTIP\n\nFrom this point forwards, the docs will assume basic knowledge of Vue’s SFC components and will demonstrate examples as such and will be using ES6+ code snippets. So be sure to brush up on these if you haven’t already.\n\nField-level Validation\n\nYou can define validation rules for your fields using the Field component, your rules can be as simple as a function that accepts the current value and returns an error message.\n\nvue\n<template>\n  <Form>\n    <Field name=\"field\" :rules=\"isRequired\" />\n    <ErrorMessage name=\"field\" />\n  </Form>\n</template>\n<script setup>\nimport { Field, Form, ErrorMessage } from 'vee-validate';\nfunction isRequired(value) {\n  if (value && value.trim()) {\n    return true;\n  }\n  return 'This is required';\n}\n</script>\nValidating fields with yup\n\nyup is a very popular, simple and powerful data validation library for JavaScript, you can use it in combination with vee-validate, You can use yup to define your validation rules for that field:\n\nvue\n<template>\n  <Form>\n    <Field name=\"password\" type=\"password\" :rules=\"passwordRules\" />\n    <ErrorMessage name=\"password\" />\n  </Form>\n</template>\n<script setup>\nimport { Field, Form, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst passwordRules = yup.string().required().min(8);\n</script>\n\nFor more information on the Field component, read the API reference.\n\nForm-level Validation\n\nvee-validate supports using a validation schema to define all your validations on your fields beforehand so you don’t have to define them individually on your fields. Form-level validation is convenient if you are building large forms and want to keep your templates cleaner.\n\nA simple validation schema can be an object containing field names as keys and validation functions as the value for those keys:\n\nvue\n<template>\n  <Form @submit=\"submit\" :validation-schema=\"simpleSchema\">\n    <Field name=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nconst simpleSchema = {\n  email(value) {\n    // validate email value...\n  },\n  name(value) {\n    // validate name value...\n  },\n  // If you defined global rules you can also use them\n  password: 'required|min:8',\n  // ...\n};\n</script>\nValidation schemas with yup\n\nFortunately there is already a very neat way to build validation schemas for your forms by using yup, it allows you create validation objects like this:\n\njs\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  name: yup.string().required(),\n  password: yup.string().required().min(8),\n});\n\nvee-validate has built-in support for yup schemas, You can pass your schemas to the <Form /> component using the validation-schema prop:\n\nvue\n<template>\n  <Form @submit=\"submit\" :validation-schema=\"schema\">\n    <Field name=\"email\" />\n    <ErrorMessage name=\"email\" />\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nconst schema = yup.object({\n  email: yup.string().required().email(),\n  password: yup.string().required().min(8),\n});\n</script>\n\nFor more information on the Form component, read the API reference.\n\nYup Schema Optimizations\n\nThere are a couple of optimization caveats when it comes to using yup schemas to validate your forms, be sure to check the best practices guide.\n\nZod Schema Plugin\n\nThere is an official integration available for Zod validation that you can use as a drop-in replacement for yup. Check the zod integration page.\n\nReactive Form Schema\n\nYou can have reactive form schemas using computed if you are looking to create dynamic schemas using either yup or a validation object.\n\njs\nimport * as yup from 'yup';\nexport default {\n  data: () => ({\n    min: 6,\n  }),\n  computed: {\n    schema() {\n      return yup.object({\n        password: yup.string().min(this.min),\n      });\n    },\n  },\n};\nvue\n<template>\n  <Form @submit=\"submit\" :validation-schema=\"schema\">\n    <Field name=\"password\" type=\"password\" />\n    <ErrorMessage name=\"password\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nimport * as yup from 'yup';\nexport default {\n  components: {\n    Form,\n    Field,\n    ErrorMessage,\n  },\n  data: () => ({\n    min: 6,\n  }),\n  computed: {\n    schema() {\n      return yup.object({\n        password: yup.string().min(this.min),\n      });\n    },\n  },\n};\n</script>\n\nWhen the validation schema changes, only the fields that were validated at least once will be re-validated, the other fields won’t be validated to avoid aggressive validation behavior.\n\nValidation Behavior\n\nBy default vee-validate runs validation in these scenarios:\n\nAfter field value change\n\nWhen a change event is dispatched/emitted\nvalue changed externally (model update or others)\n\nNote that input event is not considered to be a trigger because it would make it too aggressive, you can configure the triggers in the next section to suit your needs.\n\nAfter Rules change\n\nOnly if the field was validated before via user interaction\n\nAfter field is blurred\n\nField has been blurred (blur event was emitted)\n\nAfter form submissions\n\nWhen the form has been submitted with either handleSubmit or submitForm on the <Form /> component slot props\nCustomizing Validation Triggers\n\nBy default vee-validate adds multiple event listeners to your fields:\n\ninput: Adds a handleChange handler that updates the field value, and it may validate if configured to do so (may update meta.dirty flag if the value changed).\nchange: Adds a handleChange handler that updates the field value and validates the field (may update meta.dirty flag if the value changed).\nblur: Adds a handleBlur handler that updates the meta.touched flag.\nupdate:modelValue Adds a handleChange handler to components emitting the update:modelValue event\n\nNotice that in all of these, the handleChange handler is the only one that triggers validation. You can configure if a handler should validate by using the configure helper:\n\njs\nimport { configure } from 'vee-validate';\n// Default values\nconfigure({\n  validateOnBlur: true, // controls if `blur` events should trigger validation with `handleChange` handler\n  validateOnChange: true, // controls if `change` events should trigger validation with `handleChange` handler\n  validateOnInput: false, // controls if `input` events should trigger validation with `handleChange` handler\n  validateOnModelUpdate: true, // controls if `update:modelValue` events should trigger validation with `handleChange` handler\n});\n\nNote that configuring any of these options to false will not remove all the events, they only control if each event triggers a validation check or not.\n\nThis might not be flexible enough for your needs, which is why you can define the same config per Field component instance:\n\nvue\n<!-- Turns off validation events -->\n<Field name=\"email\" :validateOnBlur=\"false\" :validateOnChange=\"false\" :validateOnInput=\"false\" />\n\nAdditionally if you need to use different events or have specific needs in mind, you can control which events to listen to by using the scoped-slot handleChange prop of the <Field /> component and binding it to the desired event:\n\nvue\n<!-- Listen to all events, this is the default behavior -->\n<Field v-slot=\"{ field }\">\n  <input v-bind=\"field\" />\n</Field>\n<!-- Only validate when the change event is dispatched -->\n<Field v-slot=\"{ field, handleChange }\">\n  <input @change=\"handleChange\" :value=\"field.value\" />\n</Field>\n\nIn addition to those events, you can also validate when the <Field /> or <Form /> components are mounted with validateOnMount prop present on both components:\n\nvue\n<!-- Trigger validation when this field is mounted (initial validation) -->\n<Field name=\"name\" validate-on-mount />\n<!-- Trigger validation on all fields inside this form when the form is mounted -->\n<Form validate-on-mount>\n  <Field name=\"email\" />\n  <Field name=\"password\" />\n</Form>\n\nYou can also specify if a handleChange call should trigger validation or not by providing the second argument:\n\nvue\n<!-- Only update field value without validating it -->\n<Field v-slot=\"{ field, handleChange }\">\n  <input @change=\"$event => handleChange($event, false)\" :value=\"field.value\" />\n</Field>\n\nVue components validation triggers\n\nWhen applying v-bind=\"field\" to a Vue component, be careful that the listeners will both be applied for Vue and native DOM events, meaning you might trigger validation unintentionally.\n\nAn example of that could be input[type=\"file\"] inputs, because you cannot bind the value attribute to a file instance which means two-way binding won’t work there. In that case, only listing to handful of events makes more sense:\n\nvue\n<Field name=\"file\" v-slot=\"{ handleChange, handleBlur }\">\n  <input type=\"file\" @change=\"handleChange\" @blur=\"handleBlur\" />\n</Field>\n\nFor custom components, it is recommended that you listen to the proper events when using v-bind with custom components, the following sample uses modelValue events.\n\nvue\n<Field name=\"custom\" v-slot=\"{ handleChange, value }\">\n  <CustomInput :modelValue=\"value\" @update:modelValue=\"handleChange\" />\n</Field>\n\nFor 3rd party components you may consult their documentation to figure which events to trigger validation for. Here are a few examples for the common UI frameworks here.\n\nDisplaying Error Messages\nUsing the Field slot-props\n\nIf you intend to use the scoped slot on the Field component, you can access errors or errorMessage on the scoped slot props to render your messages:\n\nvue\n<Field name=\"field\" :rules=\"rules\" v-slot=\"{ field, errors, errorMessage }\">\n  <input v-bind=\"field\" type=\"text\" />\n  <span>{{ errors[0] }}</span>\n  <!-- Or -->\n  <span>{{ errorMessage }}</span>\n</Field>\n\nThis is convenient if you have a complex markup for your input and would like to keep everything contained within, it also allows you to create input components with built-in validation.\n\nUsing the Form slot-props\n\nAs you noticed the <Form /> component gives you access to the errors on its scoped-slot props which you can use to display any error messages for any <Field /> within that form:\n\nvue\n<Form v-slot=\"{ errors }\">\n  <Field name=\"field\" :rules=\"rules\" />\n  {{ errors.field }}\n</Form>\n\nand if you would like, you could display all error messages for your fields by iterating over the errors object:\n\nvue\n<Form v-slot=\"{ errors }\">\n  <template v-if=\"Object.keys(errors).length\">\n    <p>Please correct the following errors</p>\n    <ul>\n      <li v-for=\"(message, field) in errors\" :key=\"field\">\n        {{ message }}\n      </li>\n    </ul>\n  </template>\n  <Field name=\"name\" :rules=\"rules\" />\n  <Field name=\"email\" :rules=\"rules\" />\n  <Field name=\"password\" :rules=\"rules\" />\n</Form>\nUsing ErrorMessage component\n\nYou’ve seen how the ErrorMessage works in the previous examples, by default the ErrorMessage component renders a span but you can specify any kind of HTML element or global component to the as prop.\n\nvue\n<Form>\n  <Field name=\"field\" :rules=\"rules\" />\n  <!-- Render the error message as a div element -->\n  <ErrorMessage name=\"field\" as=\"div\" />\n</Form>\n\nThe <ErrorMessage /> component is very flexible and you can customize its render output with scoped slots to build complex messages markup, read the ErrorMessage API reference for more information.\n\nCustom Field Labels\n\nMore often than not, your fields will have names with underscores or shorthands which isn’t very nice when showing in error messages, for example, you might have specific encoding to your field names because they might be generated by the backend. Ideally, you want to avoid having messages like:\n\ntxt\nThe down_p is required\n\nAnd instead, show something more meaningful to the user\n\ntxt\nThe down payment is required\n\nYou can do this in two ways depending on which validators you are using (yup or global validators).\n\nWith yup it is very straightforward, you just need to call label() after defining your field’s validations either in field level or form level:\n\njs\nconst schema = Yup.object({\n  email_addr: Yup.string().email().required().label('Email Address'),\n  acc_pazzword: Yup.string().min(5).required().label('Your Password'),\n});\n\nHere is a live example:\n\nIf you are interested in how to do the same for global validators check the i18n guide\n\nValidation Metadata\nField-level Meta\n\nEach field has metadata associated with it, the meta property available on the <Field /> component contains additional information about the field:\n\nvalid: The current field validity, automatically updated for you.\ntouched: If the field was blurred (unfocused), can be updated with the handleBlur function or setTouched on the field’s slot scope props.\ndirty: If the field value was updated, you cannot change its value.\npending: If the field’s validations are still running, useful for long-running async validation.\ninitialValue: The field’s initial value, is undefined if you didn’t specify any.\nvue\n<Field name=\"email\" type=\"email\" :rules=\"validateEmail\" v-slot=\"{ field, meta }\">\n  <input v-bind=\"field\" />\n  <pre>{{ meta }}</pre>\n</Field>\n\nThis is the typescript interface for a field’s meta-object value\n\nts\ninterface FieldMeta {\n  dirty: boolean;\n  pending: boolean;\n  touched: boolean;\n  valid: boolean;\n  initialValue: any;\n}\n\nField Dirty Flag and Initial Values\n\nThe default value is undefined unless specified which may cause unexpected meta.dirty results. To get accurate results for the meta.dirty flag, you must provide an initial value to your field even if the values are empty.\n\nvue\n<Field name=\"email\" value=\"\" type=\"email\" v-slot=\"{ field, meta }\">\n  <input v-bind=\"field\" />\n  <pre>{{ meta }}</pre>\n</Field>\n\nTo reduce the verbosity of adding a value prop to each field, you could provide the initial-values prop to your <Form /> component instead.\n\nValid Flag Combinations\n\nSince the meta.valid flag is initially true (because it just means there are no errors yet), it would cause problems if you have a “success” UI state an indicator.\n\nTo avoid this case you could combine the valid flag with either meta.dirty or meta.touched to get accurate representation:\n\nvue\n<Field name=\"email\" type=\"email\" :rules=\"validateEmail\" v-slot=\"{ field, errorMessage, meta }\">\n  <input v-bind=\"field\" />\n  <span v-if=\"errorMessage\">⛔️ {{ errorMessage }}</span>\n  <span v-if=\"meta.valid && meta.touched\">✅ Field is valid</span>\n</Field>\nForm-level Meta\n\nForms also have their own meta value containing useful information about the form, it is an aggregation of the metadata for the fields inside that form.\n\nThe form’s metadata properties are:\n\nvalid: The form’s validity status, will be true if the errors array is empty. After the form is mounted, vee-validate will update the flag to its accurate state\ntouched: If at least one field was blurred (unfocused) inside the form.\ndirty: If at least one field’s value was updated.\npending: If at least one field’s validation is still pending.\ninitialValues: All fields’ initial values, packed into an object where the keys are the field names.\nvue\n<Form v-slot=\"{ meta }\">\n  <!-- Some fields -->\n  <pre>{{ meta }}</pre>\n</Form>\n\nHere is a similar example where we disable the form’s submit button if no value was changed, we will check the dirty flag on the form’s scoped slot props which should tell us if the form values have changed or not.\n\nvue\n<template>\n  <Form v-slot=\"{ meta }\" :initial-values=\"initialValues\">\n    <Field name=\"email\" />\n    <button :disabled=\"!meta.dirty\">Submit</button>\n  </Form>\n</template>\n<script>\nimport { Field, Form } from 'vee-validate';\nexport default {\n  components: {\n    Field,\n    Form,\n  },\n  data() {\n    return {\n      initialValues: { email: '' },\n    };\n  },\n};\n</script>\n\nForm Dirty Flag and Initial Values\n\nNotice that the initial-values in the previous example were provided, like mentioned for the meta.dirty accuracy for fields, to get accurate results for the meta.dirty flag, you must provide initial values to your forms even if the values are empty.\n\nValid Flag Combinations\n\nForms meta.valid flag is also initially true (because it just means there are no errors yet), it would cause problems if you have a “success” UI state or an indicator.\n\nTo avoid this case you could combine the form’s valid flag with either meta.dirty or meta.touched to get accurate representation:\n\nvue\n<Form v-slot=\"{ meta, errors }\">\n  <Field name=\"email\" type=\"email\" :rules=\"validateEmail\" />\n  <span v-if=\"errors.email\">⛔️ {{ errors.email }}</span>\n  <span v-if=\"meta.valid && meta.touched\">✅ Form is valid</span>\n</Form>"
  },
  {
    "title": "Nested Objects and Arrays",
    "url": "https://vee-validate.logaretm.com/v4/guide/components/nested-objects-and-arrays/",
    "html": "Nested Objects and Arrays\n\nvee-validate supports nested objects and arrays, using field name syntax to indicate a field’s path. This allows you to structure forms easily to make data mapping straightforward without having to deal with flat form values.\n\nNested Objects\n\nYou can specify a field to be nested in an object using dot paths, like what you would normally do in JavaScript to access a nested property. The field name prop acts as the path for that field:\n\nvue\n<template>\n  <Form @submit=\"onSubmit\">\n    <Field name=\"links.twitter\" type=\"url\" />\n    <Field name=\"links.github\" type=\"url\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nfunction onSubmit(values) {\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\n\nSubmitting the previous form would result in the following values being passed to your handler:\n\njs\n{\n  \"links\": {\n    \"twitter\": \"https://twitter.com/logaretm\",\n    \"github\": \"https://github.com/logaretm\"\n  }\n}\n\nYou are not limited to a specific depth, you can nest as much as you like.\n\nNested Arrays\n\nSimilar to objects, you can also nest your values in an array, using square brackets just like how you would do it in JavaScript.\n\nHere is the same example as above but in array format:\n\nvue\n<template>\n  <Form @submit=\"onSubmit\">\n    <Field name=\"links[0]\" type=\"url\" />\n    <Field name=\"links[1]\" type=\"url\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nfunction onSubmit(values) {\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\n\nSubmitting the previous form would result in the following values being passed to your handler:\n\njs\n{\n  \"links\": [\n    \"https://twitter.com/logaretm\",\n    \"https://github.com/logaretm\"\n  ]\n}\n\nWARN\n\nvee-validate will only create nested arrays if the path expression is a complete number, for example, paths like some.nested[0path] will not create any arrays because the 0path key is not a number. However some.nested[0].path will create the array with an object as the first item.\n\nAvoiding Nesting\n\nIf your fields’ names are using the dot notation and you want to avoid the nesting behavior which is enabled by default, all you need to do is wrap your field names in square brackets ([]) to disable nesting for those fields.\n\nvue\n<template>\n  <Form @submit=\"onSubmit\">\n    <Field name=\"[links.twitter]\" type=\"url\" />\n    <Field name=\"[links.github]\" type=\"url\" />\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nfunction onSubmit(values) {\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\n\nSubmitting the previous form would result in the following values being passed to your handler:\n\njs\n{\n  \"links.twitter\": \"https://twitter.com/logaretm\",\n  \"links.github\": \"https://github.com/logaretm\"\n}\nField Arrays v4.5\n\nField arrays are a special type of nested array fields, they are often used to collect repeatable pieces of data or repeatable forms. They are often called “repeatable fields”.\n\nWhen dealing with those fields it is better to use <FieldArray /> component which gives you a few helpers you can use to manage the array fields.\n\nHere is a small example that shows how easy it is to create a repeatable URL field:\n\nvue\n<template>\n  <Form @submit=\"onSubmit\" :initial-values=\"initialValues\">\n    <FieldArray name=\"links\" v-slot=\"{ fields, push, remove }\">\n      <div v-for=\"(entry, idx) in fields\" :key=\"entry.key\">\n        <Field :name=\"`links[${idx}]`\" type=\"url\" />\n        <button type=\"button\" @click=\"remove(idx)\">Remove</button>\n      </div>\n      <button type=\"button\" @click=\"push('')\">Add</button>\n    </FieldArray>\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nconst initialValues = {\n  links: ['https://github.com/logaretm'],\n};\nfunction onSubmit(values) {\n  alert(JSON.stringify(values, null, 2));\n}\n</script>\n\nForm Context\n\nThe <FieldArray /> component requires being used inside a Form component or a useForm to be called at its parent tree.\n\nField Array Paths\n\nWhen planning to use <FieldArray /> you need to provide a name prop which is the path of the array starting from the root form value, you can use dot notation for object paths or indices for array paths.\n\nHere are a few examples:\n\nIterate over the users array:\n\nvue\n<Form>\n  <FieldArray name=\"users\" v-slot=\"{ fields }\">\n    <div v-for=\"(entry, idx) in fields\" :key=\"entry.key\">\n      <Field :name=\"`users[${idx}].name`\" />\n    </div>\n  </FieldArray>\n</Form>\n\nIterate over the domains inside settings.dns object:\n\nvue\n<Form>\n  <FieldArray name=\"settings.dns.domains\" v-slot=\"{ fields }\">\n    <div v-for=\"(entry, idx) in fields\" :key=\"entry.key\">\n      <Field :name=\"`settings.dns.domains[${idx}]`\" />\n    </div>\n  </FieldArray>\n</Form>\n\nIterate over both users and links:\n\nvue\n<Form>\n  <FieldArray name=\"users\" v-slot=\"{ fields: users }\">\n    <div v-for=\"(userEntry, userIdx) in users\">\n      <FieldArray :name=\"`users[${userIdx}].links`\" v-slot=\"{ fields: links }\">\n        <div v-for=\"(entry, idx) in fields\" :key=\"entry.key\">\n          <Field :name=\"`users[${userIdx}].links[idx]`\" />\n        </div>\n      </FieldArray>\n    </div>\n  </FieldArray>\n</Form>\nIteration Keys\n\nThe FieldArrayEntry item exposes a key property, this property is unique and is auto-generated for you so you can use it as an iteration key.\n\nvue\n<FieldArray name=\"users\" v-slot=\"{ fields }\">\n  <div v-for=\"(entry, idx) in fields\" :key=\"entry.key\">\n    <Field :name=\"`users[${idx}].name`\" />\n  </div>\n</FieldArray>\n\nThis auto-generated key property is very convenient as you no longer have to provide your own unique key for each item.\n\nWARN\n\nThe key property is not an index. It is a unique identifier for the array item that is independent of the array index, so you should not be using it to reference field names.\n\nArray Helpers\n\nThe <FieldArray /> slot provides the following properties and functions:\n\nfields: a read-only version of your array field items, it includes some useful properties like key, isFirst and isLast, the actual item value is inside .value property. You should use it to iterate with v-for.\npush(item: any): adds an item to the end of the array.\ninsert(idx: number, item: any): Inserts an array item at the specified index.\nprepend(item: any): adds an item to the start of the array.\nremove(idx: number): removes the item with the given index from the array.\nswap(idxA: number, idxB: number): Swaps two array elements by their indexes.\nreplace(items: any[]): Replaces the entire array values with the given items.\nupdate(idx: number, value: any): Updates an array item value at the specified index.\nmove(oldIdx: number, newIdx: number): Moves an array item to a different position within the array.\n\nRead the API reference for more information.\n\nCaveats\nPaths creation and destruction\n\nvee-validate creates the paths inside the form data automatically but lazily, so initially, your form values won’t contain the values of the fields unless you provide initial values for them. It might be worthwhile to provide initial data for your forms with nested paths.\n\nWhen fields get unmounted like in the case of conditional rendered fields with v-if or v-for, their path will be destroyed just as it was created if they are the last field in that path. So you need to be careful while accessing the nested field in values inside your submission handler or the Form component values slot prop.\n\nPath destruction can be annoying when dealing with multi-step forms or tabbed forms where you want all the values to be available even when the fields are unmounted. You can control this behavior by passing keepValue prop to the <Field /> component or you can do it for all the fields by passing keepValues to the <Form /> component.\n\nNote that the priority of this configuration follows the field config first then it fallbacks to the form’s config.\n\nvue\n<template>\n  <!-- All fields values will be kept -->\n  <Form keep-values v-slot=\"{ values }\">\n    <!-- This field value will be kept -->\n    <Field v-if=\"showFields\" name=\"email\" />\n    <!-- This field value will be removed -->\n    <Field v-if=\"showFields\" name=\"name\" :keep-value=\"false\" />\n    <button @click=\"showFields = !showFields\" type=\"button\">Show/Hide fields</button>\n    <button>Submit</button>\n    <pre>{{ values }}</pre>\n  </Form>\n</template>\n<script>\nexport default {\n  data: () => ({\n    showFields: true,\n  }),\n};\n</script>\nReferencing Errors\n\nWhen referencing errors using errors object on the Form slot props or the ErrorMessage component, make sure to reference the field name in the same way you set it on the name prop for that field. So even if you avoid nesting you should always include the square brackets. In other words errors do not get nested, they are always flat.\n\nNested Fields With Validation Schema\n\nSince vee-validate supports form-level validation, referencing the nested fields may vary depending on how you are specifying the schema.\n\nIf you are using yup, you can utilize the nested yup.object or yup.array schemas to provide validation for your nested fields, here is a quick example:\n\nvue\n<template>\n  <Form v-slot=\"{ errors }\" :validation-schema=\"schema\" @submit=\"onSubmit\">\n    <Field name=\"user.name\" />\n    <span>{{ errors['user.name'] }}</span>\n    <Field name=\"user.addresses[0]\" />\n    <span>{{ errors['user.addresses[0]'] }}</span>\n    <button>Submit</button>\n  </Form>\n</template>\n<script setup>\nimport * as yup from 'yup';\nconst schema = yup.object({\n  user: yup.object({\n    name: yup.string().required(),\n    addresses: yup.array().of(yup.string().required()),\n  }),\n});\nfunction onSubmit(values: any) {\n  fn(values);\n}\n</script>\n\nYou can visit this link for a practical example using nested arrays."
  },
  {
    "title": "Build a Form Generator",
    "url": "https://vee-validate.logaretm.com/v4/tutorials/dynamic-form-generator/",
    "html": "Build a Form Generator\n\nBuilding forms is often a repetitive task and requires a lot of back and forth to maintain. Maybe your client asked to add a field, maybe they asked to remove a field.\n\nFor most cases using static markup is good enough for your form needs but in some cases, it would be great if you had a dynamic form generator that would quickly render your fields based on some javascript object schema.\n\nIn this tutorial, you will learn how to use vee-validate to build a form-generator without external libraries.\n\nLet’s quickly recap what you will be building, the component we will be building should:\n\nAccept a form schema specifying the fields\nRender the given schema\nUse yup to validate our form\nShow error messages\n\nTIP\n\nThis guide will cover how to build a basic form generator.\n\nIf you are looking for a more robust solution for form generation, take a look at Formvuelate, and it has first-party vee-validate support.\n\nPrerequisites\n\nThis tutorial assumes you know:\n\nModern JavaScript like arrow functions and ES modules.\nVue’s SFC file syntax.\nVue’s list rendering with v-for.\nVue’s dynamic components.\n\nThis tutorial also assumes you already have an empty Vue-cli project that you will edit as you follow along and that you have installed vee-validate already.\n\nLaying The Foundation\n\nBefore getting to the implementation details to implement a dynamic form generator, you need to have an overview of how it would work.\n\nSo let’s assume we have already implemented a component called DynamicForm that accepts a schema prop that has all the information needed to render the form.\n\nWe have a few requirements to fulfill:\n\nShould be able to provide the fields.\nShould be able to specify types (elements) for those fields\nShould be able to specify validation either on field-level or form-level\n\nAssuming we have such a component, we can imagine using it to be like this:\n\nApp.vue\nvue\n<template>\n  <DynamicForm :schema=\"formSchema\" />\n</template>\n<script>\nimport DynamicForm from '@/components/DynamicForm.vue';\nexport default {\n  components: {\n    DynamicForm,\n  },\n  data: () => {\n    const formSchema = {\n      fields: [\n        {\n          label: 'Your Name',\n          name: 'name',\n          as: 'input',\n        },\n        {\n          label: 'Your Email',\n          name: 'email',\n          as: 'input',\n        },\n        {\n          label: 'Your Password',\n          name: 'password',\n          as: 'input',\n        },\n      ],\n    };\n    return {\n      formSchema,\n    };\n  },\n};\n</script>\n\nThe form schema will contain fields property which is an array of the fields we want to render, each field entry will have these properties:\n\nlabel: a friendly label to display with the input.\nname: a unique name for the field to identify it.\nas: the name of the input element to render, it can be any native HTML element.\nRendering Fields\n\nThe initial implementation will follow these generic steps:\n\nUse Form component from vee-validate to render the form\nIterate over each field in schema.fields\nRender each field as a Field component passing all props to it\n\nLet’s put that into some code.\n\ncomponents/DynamicForm.vue\nvue\n<template>\n  <Form>\n    <div\n      v-for=\"field in schema.fields\" :key=\"field.name\">\n      <label :for=\"field.name\">{{ field.label }}</label>\n      <Field :as=\"field.as\" :id=\"field.name\" :name=\"field.name\" />\n    </div>\n    <button>Submit</button>\n  </Form>\n</template>\n<script>\nimport { Form, Field } from 'vee-validate';\nexport default {\n  name: 'DynamicForm',\n  components: {\n    Form,\n    Field,\n  },\n  props: {\n    schema: {\n      type: Object,\n      required: true,\n    },\n  },\n};\n</script>\n\nNotice that when you run the example, the password field is being rendered as a text field which isn’t ideal. We would like to be able to pass the type property to the input element as well.\n\nIn the App.vue component, add highlighted line:\n\nApp.vue\nvue\n<template>\n  <DynamicForm :schema=\"formSchema\" />\n</template>\n<script>\nimport DynamicForm from '@/components/DynamicForm.vue';\nexport default {\n  components: {\n    DynamicForm,\n  },\n  data: () => {\n    const formSchema = {\n      fields: [\n        {\n          label: 'Your Name',\n          name: 'name',\n          as: 'input',\n        },\n        {\n          label: 'Your Email',\n          name: 'email',\n          as: 'input',\n        },\n        {\n          label: 'Your Password',\n          name: 'password',\n          as: 'input',\n          type: 'password'\n        },\n      ],\n    };\n    return {\n      formSchema,\n    };\n  },\n};\n</script>\n\nIn the DynamicForm.vue component, update the iteration with v-for portion to extract the known keys that we expect and collecting the rest in another object using ES6 object rest operator.\n\ncomponents/DynamicForm.vue\nvue\n<template>\n  <Form>\n    <div\n      v-for=\"{ as, name, label, ...attrs } in schema.fields\"\n      :key=\"name\"\n    >\n      <label :for=\"name\">{{ label }}</label>\n      <Field :as=\"as\" :id=\"name\" :name=\"name\" v-bind=\"attrs\" />\n    </div>\n    <button>Submit</button>\n  </Form>\n</template>\n<script>\nimport { Form, Field } from 'vee-validate';\nexport default {\n  name: 'DynamicForm',\n  components: {\n    Form,\n    Field,\n  },\n  props: {\n    schema: {\n      type: Object,\n      required: true,\n    },\n  },\n};\n</script>\n\nThe v-bind there allows us to bind everything in the attrs object which is all the other props we didn’t extract explicitly and bind them to the Field component.\n\nThe Field component will pass down any props that it doesn’t accept to whatever gets rendered in its place, effectively passing down other attributes to our input tags.\n\nBonus: Adding support for slotted inputs\nHandling Validation\n\nWe would like each field to have its own validation rules defined on the schema. We will use yup for those validation rules.\n\nIn App.vue, update the form’s schema so that each field has a new rules property with sensible validation rules\n\nApp.vue\nvue\n<template>\n  <DynamicForm :schema=\"formSchema\" />\n</template>\n<script>\nimport DynamicForm from '@/components/DynamicForm.vue';\nimport * as Yup from 'yup';\nexport default {\n  components: {\n    DynamicForm,\n  },\n  data: () => {\n    const formSchema = {\n      fields: [\n        {\n          label: 'Your Name',\n          name: 'name',\n          as: 'input',\n          rules: Yup.string().required(),\n        },\n        {\n          label: 'Your Email',\n          name: 'email',\n          as: 'input',\n          rules: Yup.string().email().required(),\n        },\n        {\n          label: 'Your Password',\n          name: 'password',\n          as: 'input',\n          type: 'password',\n          rules: Yup.string().min(6).required(),\n        },\n      ],\n    };\n    return {\n      formSchema,\n    };\n  },\n};\n</script>\n\nNow that each field has its own validation rules, we will need to display the error messages.\n\nImport and register the ErrorMessage component inside the DynamicForm.vue component, and add it to the template after the <Field />.\n\ncomponents/DynamicForm.vue\nvue\n<template>\n  <Form>\n    <div\n      v-for=\"{ as, name, label, children, ...attrs } in schema.fields\"\n      :key=\"name\"\n    >\n      <label :for=\"name\">{{ label }}</label>\n      <Field :as=\"as\" :id=\"name\" :name=\"name\" v-bind=\"attrs\">\n        <template v-if=\"children && children.length\">\n          <component v-for=\"({ tag, text, ...childAttrs }, idx) in children\"\n            :key=\"idx\"\n            :is=\"tag\"\n            v-bind=\"childAttrs\"\n          >\n            {{ text }}\n          </component>\n        </template>\n      </Field>\n      <ErrorMessage :name=\"name\" />\n    </div>\n    <button>Submit</button>\n  </Form>\n</template>\n<script>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nexport default {\n  name: 'DynamicForm',\n  components: {\n    Form,\n    Field,\n    ErrorMessage\n  },\n  props: {\n    schema: {\n      type: Object,\n      required: true,\n    },\n  },\n};\n</script>\n\nAnd that’s it, you should have validation working now 🎉\n\nDemo\n\nYou can check a live sample of what we did here.\n\nConclusion\n\nIn this guide, you learned how to use the dynamic rendering capabilities of Vue.js combined with the flexible nature of the vee-validate components. You created a form that renders fields and validates them based on javascript object schema.\n\nWhile the finished product is far from being complete, you can add features as needed to your form generator.\n\nTIP\n\nIf you are looking for a more robust solution for form generation, take a look at Formvuelate, and it has first-party vee-validate support."
  },
  {
    "title": "Resources",
    "url": "https://vee-validate.logaretm.com/v4/resources/",
    "html": "Resources\nTalks\nWhat’s new in vee-validate v4 by Abdelrahman Awad - Jul 18, 2020\nVue Form Validation w/ VeeValidate by Aaron Saunders - Apr 30, 2021\nCommunity Videos\nManaging Form Validation with Custom Form Components And Vee-Validate Composition API by Aaron Saunders\nProducts\n\nCreative-Tim are using vee-validate in their Vue dashboards, head over to creative-tim and check their offerings.\n\nVue Argon Dashboard Pro\n\nVue White Dashboard Pro\n\nVue Light Bootstrap Dashboard PRO\n\nVue Black Dashboard Pro\n\nVue Now UI Dashboard PRO"
  },
  {
    "title": "Overview",
    "url": "https://vee-validate.logaretm.com/v4/guide/overview",
    "html": "Why vee-validate\n\n“Forms” is a difficult subject in frontend development. Not only do you have to deal with ensuring that correct values are submitted, but you should also provide a pleasant UX for your users.\n\nBuilding forms from scratch is a lot of work and you probably won’t cover all your future needs as your requirements change over time, and as you add more features.\n\nThe time you spend working on a custom form solution is better spent building your application logic.\n\nMost form libraries will save you a lot of time, but vee-validate tackles the major pain points of forms and then gets out of your way, some of those are:\n\nForm state and value tracking\nUX\nSynchronous and Asynchronous Validation\nHandling submissions\n\nvee-validate tries to handle all of the above and more by providing abstractions to these problems without any UI. This could be viewed as a double-edged sword, however, overriding UI and styles was the downfall of many component libraries and design languages.\n\nBecause of that, vee-validate abstracts away the hard parts into pure logic compositions that you can add to your existing UI and component. There is nothing to override, there is no hidden cost. You can also use vee-validate to power your components internally, and as a result you can build up your form library without having to think about the hard parts.\n\nA great showcase of this approach is how vee-validate seamlessly integrate with almost every component UI library for Vue.js out there without any special treatment or hacks.\n\nGetting Started\n\nvee-validate makes use of two flavors to add validation to your forms.\n\nComposition API: This is the best way to use vee-validate as it allows seamless integrations with your existing UI, or any 3rd party component library.\nHigher-order components (HOC): This approach is easy to use and is strictly used within the template, you can use it if you have simple forms and don’t want to write a lot of JavaScript.\n\nWhichever approach you prefer to use, both flavors can be used interchangeably. So you can mix and match between the two approaches as needed.\n\nSetup SFC\n\nMost examples in the docs use the new script setup SFC syntax for brevity. In case you’re having difficulty following along, take some time to learn about it.\n\nUsing a package manager\n\nFor a more modern workflow with a bundler, you can install vee-validate using a package manager like yarn, npm or pnpm:\n\nsh\nyarn add vee-validate\n# or\nnpm i vee-validate --save\n# or\npnpm add vee-validate\nUsing a script tag\n\nYou can use vee-validate with a script tag and a CDN, import the library like this:\n\nhtml\n<script src=\"https://unpkg.com/vee-validate\"></script>\n\nThis will inject a VeeValidate global object, which you will use to access the various components and functions exposed by vee-validate."
  },
  {
    "title": "Validation Basics",
    "url": "https://vee-validate.logaretm.com/v4/tutorials/basics/",
    "html": "Validation Basics\n\nVeeValidate offers many ways to do form validation, this tutorial will teach you how to do basic form validation using the simplest approach.\n\nWhat are we building\n\nIn this tutorial, we will be building a “sign up newsletter” form where the user would have to fill a field to complete their sign-up.\n\nPrerequisites\n\nThis tutorial assumes you know:\n\nModern JavaScript features like arrow functions and ES modules.\nVue’s SFC file syntax.\nSetup\n\nIt is preferable to use a local development environment to follow along, make sure to have the following:\n\nPrepare a Vue 3.x project using the vue-cli\nDetailed Steps\nAdd vee-validate to your project\nsh\nyarn add vee-validate\n# or\nnpm install vee-validate --save\nCleanup the contents of App.vue, it should look like the following:\nvue\n<template>\n  <div id=\"app\"></div>\n</template>\n<script>\nexport default {};\n</script>\n\nAnd that’s it, now you have an empty Vue project and vee-validate installed.\n\nBuilding the Form\n\nFirst, start by adding some markup, you can start by having a form wrapping a few input elements.\n\nvue\n<template>\n  <div id=\"app\">\n    <form novalidate>\n      <input type=\"email\" name=\"email\" />\n      <button>Sign up for newsletter</button>\n    </form>\n  </div>\n</template>\n<script>\nexport default {};\n</script>\n\nSo far so good, try filling the email field with a dummy value like hello. Then click the submit button once and see what happens.\n\nYou will notice that the form submits and you should see ?email= added in your URL in the address bar, it should have the same value that you entered in the email field.\n\nThis is the native HTML form submission behavior. Usually, in modern applications, you don’t want that and you prefer to handle submission with JavaScript.\n\nThe novalidate attribute on the <form> element is meant to disable the native HTML form validation, we will get to validating the form by the end of this tutorial.\n\nAdd a submit event handler that prevents the native form submission, we will use onSubmit function to handle our form submission.\n\nvue\n<template>\n  <div id=\"app\">\n    <form novalidate @submit.prevent=\"onSubmit\">\n      <input type=\"email\" name=\"email\" />\n      <button>Sign up for newsletter</button>\n    </form>\n  </div>\n</template>\n<script>\nexport default {\n  methods: {\n    onSubmit() {\n      console.log('Submitted');\n    },\n  },\n};\n</script>\n\nNow type anything in the email field and click submit. You will notice a couple of things:\n\nThe word “Submitted” being logged to the console.\nThe value you entered wasn’t added to the address bar, this means you’ve prevented the default submission behavior.\n\nSo far so good, but the form isn’t that useful unless it takes the correct data from the user. So let’s add validation to the form.\n\nAdding Validation\n\nVeeValidate exposes 2 components that you will be using regularly, the <Field> and <Form> are components that will help you validate your forms and inputs.\n\nImport them and register them on the Vue component, then replace the following elements with the vee-validate component:\n\nReplace <input> with <Field /> while keeping the same attributes.\nReplace <form> with <Form /> but remove both the .prevent modifier and the novalidate attribute.\nvue\n<template>\n  <div id=\"app\">\n    <Form @submit=\"onSubmit\">\n      <Field name=\"email\" type=\"email\" />\n      <button>Sign up for newsletter</button>\n    </Form>\n  </div>\n</template>\n<script>\nimport { Form, Field } from 'vee-validate';\nexport default {\n  components: {\n    Form,\n    Field,\n  },\n  methods: {\n    onSubmit() {\n      console.log('Submitting :(');\n    },\n  },\n};\n</script>\n\nChange the onSubmit method so it receives an argument called values and logs it\n\njs\nexport default {\n  components: {\n    Form,\n    Field,\n  },\n  methods: {\n    onSubmit(values) {\n      console.log(values);\n    },\n  },\n};\n\nTry typing anything into the email field and click submit. You will see form values being logged into the console with the value you entered, this means vee-validate extracted the form values for you and passed it to your onSubmit handler. Now all that remains is to add the validation rules.\n\nThere are multiple ways to define rules with VeeValidate, the most straightforward way is to use regular Vue methods.\n\nCreate a function called validateEmail that receives 1 argument called value.\n\nIt should look like this:\n\nvue\n<template>\n  <div id=\"app\">\n    <Form @submit=\"onSubmit\">\n      <Field name=\"email\" type=\"email\" />\n      <button>Sign up</button>\n    </Form>\n  </div>\n</template>\n<script>\nimport { Form, Field } from 'vee-validate';\nexport default {\n  components: {\n    Form,\n    Field,\n  },\n  methods: {\n    onSubmit(values) {\n      console.log(JSON.stringify(values, null, 2));\n    },\n    validateEmail(value) {\n      // if the field is empty\n      if (!value) {\n        return 'This field is required';\n      }\n      // if the field is not a valid email\n      const regex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i;\n      if (!regex.test(value)) {\n        return 'This field must be a valid email';\n      }\n      // All is good\n      return true;\n    },\n  },\n};\n</script>\n\nThe validateEmail function makes sure the email field is both required and is a valid email.\n\nNow you need to tell the <Field name=\"email /> component to use that function as a validation rule.\n\nYou can do that by passing the validateEmail function to the rules prop on the Field component:\n\nvue\n<template>\n  <div id=\"app\">\n    <Form @submit=\"onSubmit\">\n      <Field name=\"email\" type=\"email\" :rules=\"validateEmail\" />\n      <button>Sign up</button>\n    </Form>\n  </div>\n</template>\n<script>\nimport { Form, Field } from 'vee-validate';\nexport default {\n  components: {\n    Form,\n    Field,\n  },\n  methods: {\n    onSubmit(values) {\n      console.log(JSON.stringify(values, null, 2));\n    },\n    validateEmail(value) {\n      // if the field is empty\n      if (!value) {\n        return 'This field is required';\n      }\n      // if the field is not a valid email\n      const regex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i;\n      if (!regex.test(value)) {\n        return 'This field must be a valid email';\n      }\n      // All is good\n      return true;\n    },\n  },\n};\n</script>\n\nTry testing these scenarios:\n\nType a random non-email value like example into the email field and try clicking submit.\nType a valid email like hello@example.com into the email field and try clicking submit.\n\nIn the first case, you will notice that nothing was logged to the console, while in the second case you will see your form values being logged into the console the same as before.\n\nThis means validation is working and vee-validate is not executing your onSubmit handler until the email field validation passes.\n\nThe last step is to show error messages that you already return in the validateEmail so that your users have a better understanding of what is going on and why the form isn’t submitting.\n\nDisplaying Error Messages\n\nTo display the error message, you will use the ErrorMessage component.\n\nImport the ErrorMessage component from vee-validate and register it in your component:\n\njs\nimport { Field, Form, ErrorMessage } from 'vee-validate';\nexport default {\n  components: {\n    Field,\n    Form,\n    ErrorMessage,\n  },\n};\n\nAdd the <ErrorMessage /> component to your template, passing a name prop that matches the <Field /> name prop which is \"email\".\n\nvue\n<template>\n  <div id=\"app\">\n    <Form @submit=\"onSubmit\">\n      <Field name=\"email\" type=\"email\" :rules=\"validateEmail\" />\n      <ErrorMessage name=\"email\" />\n      <button>Sign up</button>\n    </Form>\n  </div>\n</template>\n<script>\nimport { Form, Field, ErrorMessage } from 'vee-validate';\nexport default {\n  components: {\n    Form,\n    Field,\n    ErrorMessage,\n  },\n  methods: {\n    onSubmit(values) {\n      console.log(values, null, 2);\n    },\n    validateEmail(value) {\n      // if the field is empty\n      if (!value) {\n        return 'This field is required';\n      }\n      // if the field is not a valid email\n      const regex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}$/i;\n      if (!regex.test(value)) {\n        return 'This field must be a valid email';\n      }\n      // All is good\n      return true;\n    },\n  },\n};\n</script>\n\nIf you try the form now without entering anything you will see the required error message appear. Try filling anything that’s not an email and notice the invalid email message appearing instead.\n\nNow you have successfully created a simple form and implemented validation and submission.\n\nYou can check out the finished code in action:\n\nThere is a lot more you can do with vee-validate, there are other ways and features you can use to clean up your form validation logic. Here are a few things that you can do with vee-validate:\n\nDeclare rules globally and use them in a Laravel-like syntax\nUsing 3rd-party libraries like yup to validate\nDoing form-level validation using a validation schema\nAdvanced rendering of your inputs and forms using scoped-slots\nComponent-less validation with the composition API\nGenerating localized messages\n\nYou can visit the guide section to begin learning more about vee-validate."
  }
]