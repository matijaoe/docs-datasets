[
  {
    "title": "Installation | Vue Router",
    "url": "https://router.vuejs.org/installation",
    "html": "Installation\n​\nGet the Vue Router Cheat Sheet from Vue Mastery\nDirect Download / CDN\n​\n\nhttps://unpkg.com/vue-router@4\n\nUnpkg.com provides npm-based CDN links. The above link will always point to the latest release on npm. You can also use a specific version/tag via URLs like https://unpkg.com/vue-router@4.0.15/dist/vue-router.global.js.\n\nnpm\n​\nbash\nnpm install vue-router@4\nyarn\n​\nbash\nyarn add vue-router@4"
  },
  {
    "title": "Getting Started | Vue Router",
    "url": "https://router.vuejs.org/guide/",
    "html": "Getting Started\n​\nWatch a Free Vue Router Video Course\n\nCreating a Single-page Application with Vue + Vue Router feels natural: with Vue.js, we are already composing our application with components. When adding Vue Router to the mix, all we need to do is map our components to the routes and let Vue Router know where to render them. Here's a basic example:\n\nHTML\n​\nhtml\n<script src=\"https://unpkg.com/vue@3\"></script>\n<script src=\"https://unpkg.com/vue-router@4\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- use the router-link component for navigation. -->\n    <!-- specify the link by passing the `to` prop. -->\n    <!-- `<router-link>` will render an `<a>` tag with the correct `href` attribute -->\n    <router-link to=\"/\">Go to Home</router-link>\n    <router-link to=\"/about\">Go to About</router-link>\n  </p>\n  <!-- route outlet -->\n  <!-- component matched by the route will render here -->\n  <router-view></router-view>\n</div>\nrouter-link\n​\n\nNote how instead of using regular a tags, we use a custom component router-link to create links. This allows Vue Router to change the URL without reloading the page, handle URL generation as well as its encoding. We will see later how to benefit from these features.\n\nrouter-view\n​\n\nrouter-view will display the component that corresponds to the URL. You can put it anywhere to adapt it to your layout.\n\nGet the Vue Router Cheat Sheet from Vue Mastery\nJavaScript\n​\njs\n// 1. Define route components.\n// These can be imported from other files\nconst Home = { template: '<div>Home</div>' }\nconst About = { template: '<div>About</div>' }\n\n// 2. Define some routes\n// Each route should map to a component.\n// We'll talk about nested routes later.\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n]\n\n// 3. Create the router instance and pass the `routes` option\n// You can pass in additional options here, but let's\n// keep it simple for now.\nconst router = VueRouter.createRouter({\n  // 4. Provide the history implementation to use. We are using the hash history for simplicity here.\n  history: VueRouter.createWebHashHistory(),\n  routes, // short for `routes: routes`\n})\n\n// 5. Create and mount the root instance.\nconst app = Vue.createApp({})\n// Make sure to _use_ the router instance to make the\n// whole app router-aware.\napp.use(router)\n\napp.mount('#app')\n\n// Now the app has started!\n\nBy calling app.use(router), we are triggering the initial navigation and giving access to this.$router as well as the current route as this.$route inside of any component:\n\njs\n// Home.vue\nexport default {\n  computed: {\n    username() {\n      // We will see what `params` is shortly\n      return this.$route.params.username\n    },\n  },\n  methods: {\n    goToDashboard() {\n      if (isAuthenticated) {\n        this.$router.push('/dashboard')\n      } else {\n        this.$router.push('/login')\n      }\n    },\n  },\n}\n\nTo access the router or the route inside the setup function, call the useRouter or useRoute functions. We will learn more about this in the Composition API\n\nThroughout the docs, we will often use the router instance. Keep in mind that this.$router is exactly the same as directly using the router instance created through createRouter. The reason we use this.$router is because we don't want to import the router in every single component that needs to manipulate routing."
  },
  {
    "title": "Introduction | Vue Router",
    "url": "https://router.vuejs.org/introduction",
    "html": "Introduction\n​\nWatch a Free Vue Router Video Course\n\nVue Router is the official router for Vue.js. It deeply integrates with Vue.js core to make building Single Page Applications with Vue.js a breeze. Features include:\n\nNested routes mapping\nDynamic Routing\nModular, component-based router configuration\nRoute params, query, wildcards\nView transition effects powered by Vue.js' transition system\nFine-grained navigation control\nLinks with automatic active CSS classes\nHTML5 history mode or hash mode\nCustomizable Scroll Behavior\nProper encoding for URLs\n\nGet started or play with the playground (see README.md to run them).\n\nSilver Sponsors\n\nBecome a Sponsor!"
  },
  {
    "title": "API Documentation | Vue Router",
    "url": "https://router.vuejs.org/api/",
    "html": "API Documentation\n\nAPI Documentation\n​\nEnumerations\n​\nNavigationFailureType\nInterfaces\n​\nHistoryState\nNavigationFailure\nNavigationGuard\nNavigationGuardNext\nNavigationGuardWithThis\nNavigationHookAfter\nRouteLocation\nRouteLocationMatched\nRouteLocationNormalized\nRouteLocationNormalizedLoaded\nRouteLocationOptions\nRouteMeta\nRouteRecordMultipleViews\nRouteRecordMultipleViewsWithChildren\nRouteRecordNormalized\nRouteRecordRedirect\nRouteRecordSingleView\nRouteRecordSingleViewWithChildren\nRouter\nRouterHistory\nRouterLinkProps\nRouterOptions\nRouterScrollBehavior\nRouterViewProps\n_RouteRecordBase\nType Aliases\n​\nLocationQuery\n​\n\nƬ LocationQuery: Record<string, LocationQueryValue | LocationQueryValue[]>\n\nNormalized query object that appears in RouteLocationNormalized\n\nLocationQueryRaw\n​\n\nƬ LocationQueryRaw: Record<string | number, LocationQueryValueRaw | LocationQueryValueRaw[]>\n\nLoose LocationQuery object that can be passed to functions like Router.push and Router.replace or anywhere when creating a RouteLocationRaw\n\nPathParserOptions\n​\n\nƬ PathParserOptions: Pick<_PathParserOptions, \"end\" | \"sensitive\" | \"strict\">\n\nRouteComponent\n​\n\nƬ RouteComponent: Component | DefineComponent\n\nAllowed Component in RouteLocationMatched\n\nRouteLocationRaw\n​\n\nƬ RouteLocationRaw: string | RouteLocationPathRaw | RouteLocationNamedRaw\n\nUser-level route location\n\nRouteParams\n​\n\nƬ RouteParams: Record<string, RouteParamValue | RouteParamValue[]>\n\nRouteParamsRaw\n​\n\nƬ RouteParamsRaw: Record<string, RouteParamValueRaw | Exclude<RouteParamValueRaw, null | undefined>[]>\n\nRouteRecord\n​\n\nƬ RouteRecord: RouteRecordNormalized\n\nNormalized version of a route record.\n\nRouteRecordName\n​\n\nƬ RouteRecordName: string | symbol\n\nPossible values for a user-defined route record's name\n\nRouteRecordRaw\n​\n\nƬ RouteRecordRaw: RouteRecordSingleView | RouteRecordSingleViewWithChildren | RouteRecordMultipleViews | RouteRecordMultipleViewsWithChildren | RouteRecordRedirect\n\nUseLinkOptions\n​\n\nƬ UseLinkOptions: VueUseOptions<RouterLinkOptions>\n\nVariables\n​\nRouterLink\n​\n\n• Const RouterLink: _RouterLinkI\n\nComponent to render a link that triggers a navigation on click.\n\nRouterView\n​\n\n• Const RouterView: () => { $props: AllowedComponentProps & ComponentCustomProps & VNodeProps & RouterViewProps ; $slots: { default?: (__namedParameters: { Component: VNode<RendererNode, RendererElement, { [key: string]: any; }> ; route: RouteLocationNormalizedLoaded }) => VNode<RendererNode, RendererElement, { [key: string]: any; }>[] } }\n\nType declaration\n​\n\n• new RouterView(): Object\n\nComponent to display the current route the user is at.\n\nReturns\n​\n\nObject\n\nName\tType\n$props\tAllowedComponentProps & ComponentCustomProps & VNodeProps & RouterViewProps\n$slots\t{ default?: (__namedParameters: { Component: VNode<RendererNode, RendererElement, { [key: string]: any; }> ; route: RouteLocationNormalizedLoaded }) => VNode<RendererNode, RendererElement, { [key: string]: any; }>[] }\n$slots.default?\t(__namedParameters: { Component: VNode<RendererNode, RendererElement, { [key: string]: any; }> ; route: RouteLocationNormalizedLoaded }) => VNode<RendererNode, RendererElement, { [key: string]: any; }>[]\nSTART_LOCATION\n​\n\n• Const START_LOCATION: RouteLocationNormalizedLoaded\n\nInitial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\n\nExample\n\njs\nimport { START_LOCATION } from 'vue-router'\n\nrouter.beforeEach((to, from) => {\n  if (from === START_LOCATION) {\n    // initial navigation\n  }\n})\nFunctions\n​\ncreateMemoryHistory\n​\n\n▸ createMemoryHistory(base?): RouterHistory\n\nCreates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. It's up to the user to replace that location with the starter location by either calling router.push or router.replace.\n\nParameters\n​\nName\tType\tDefault value\tDescription\nbase\tstring\t''\tBase applied to all urls, defaults to '/'\nReturns\n​\n\nRouterHistory\n\na history object that can be passed to the router constructor\n\ncreateRouter\n​\n\n▸ createRouter(options): Router\n\nCreates a Router instance that can be used by a Vue app.\n\nParameters\n​\nName\tType\tDescription\noptions\tRouterOptions\tRouterOptions\nReturns\n​\n\nRouter\n\ncreateWebHashHistory\n​\n\n▸ createWebHashHistory(base?): RouterHistory\n\nCreates a hash history. Useful for web applications with no host (e.g. file://) or when configuring a server to handle any URL is not possible.\n\nParameters\n​\nName\tType\tDescription\nbase?\tstring\toptional base to provide. Defaults to location.pathname + location.search If there is a <base> tag in the head, its value will be ignored in favor of this parameter but note it affects all the history.pushState() calls, meaning that if you use a <base> tag, it's href value has to match this parameter (ignoring anything after the #).\nReturns\n​\n\nRouterHistory\n\nExample\n\njs\n// at https://example.com/folder\ncreateWebHashHistory() // gives a url of `https://example.com/folder#`\ncreateWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n// if the `#` is provided in the base, it won't be added by `createWebHashHistory`\ncreateWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n// you should avoid doing this because it changes the original url and breaks copying urls\ncreateWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n\n// at file:///usr/etc/folder/index.html\n// for locations with no `host`, the base is ignored\ncreateWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\ncreateWebHistory\n​\n\n▸ createWebHistory(base?): RouterHistory\n\nCreates an HTML5 history. Most common history for single page applications.\n\nParameters\n​\nName\tType\nbase?\tstring\nReturns\n​\n\nRouterHistory\n\nisNavigationFailure\n​\n\n▸ isNavigationFailure(error, type?): error is NavigationRedirectError\n\nCheck if an object is a NavigationFailure.\n\nParameters\n​\nName\tType\tDescription\nerror\tany\tpossible NavigationFailure\ntype?\tNAVIGATION_GUARD_REDIRECT\toptional types to check for\nReturns\n​\n\nerror is NavigationRedirectError\n\nExample\n\njs\nimport { isNavigationFailure, NavigationFailureType } from 'vue-router'\n\nrouter.afterEach((to, from, failure) => {\n  // Any kind of navigation failure\n  if (isNavigationFailure(failure)) {\n    // ...\n  }\n  // Only duplicated navigations\n  if (isNavigationFailure(failure, NavigationFailureType.duplicated)) {\n    // ...\n  }\n  // Aborted or canceled navigations\n  if (isNavigationFailure(failure, NavigationFailureType.aborted | NavigationFailureType.canceled)) {\n    // ...\n  }\n})\n\n▸ isNavigationFailure(error, type?): error is NavigationFailure\n\nParameters\n​\nName\tType\nerror\tany\ntype?\tErrorTypes | NavigationFailureType\nReturns\n​\n\nerror is NavigationFailure\n\nloadRouteLocation\n​\n\n▸ loadRouteLocation(route): Promise<RouteLocationNormalizedLoaded>\n\nEnsures a route is loaded, so it can be passed as o prop to <RouterView>.\n\nParameters\n​\nName\tType\tDescription\nroute\tRouteLocationNormalized\tresolved route to load\nReturns\n​\n\nPromise<RouteLocationNormalizedLoaded>\n\nonBeforeRouteLeave\n​\n\n▸ onBeforeRouteLeave(leaveGuard): void\n\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to beforeRouteLeave but can be used in any component. The guard is removed when the component is unmounted.\n\nParameters\n​\nName\tType\tDescription\nleaveGuard\tNavigationGuard\tNavigationGuard\nReturns\n​\n\nvoid\n\nonBeforeRouteUpdate\n​\n\n▸ onBeforeRouteUpdate(updateGuard): void\n\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to beforeRouteUpdate but can be used in any component. The guard is removed when the component is unmounted.\n\nParameters\n​\nName\tType\tDescription\nupdateGuard\tNavigationGuard\tNavigationGuard\nReturns\n​\n\nvoid\n\nuseLink\n​\n\n▸ useLink(props): Object\n\nParameters\n​\nName\tType\nprops\tVueUseOptions<RouterLinkOptions>\nReturns\n​\n\nObject\n\nName\tType\nhref\tComputedRef<string>\nisActive\tComputedRef<boolean>\nisExactActive\tComputedRef<boolean>\nnavigate\t(e: MouseEvent) => Promise<void | NavigationFailure>\nroute\tComputedRef<RouteLocation & { href: string }>\nuseRoute\n​\n\n▸ useRoute(): RouteLocationNormalizedLoaded\n\nReturns the current route location. Equivalent to using $route inside templates.\n\nReturns\n​\n\nRouteLocationNormalizedLoaded\n\nuseRouter\n​\n\n▸ useRouter(): Router\n\nReturns the router instance. Equivalent to using $router inside templates.\n\nReturns\n​\n\nRouter"
  },
  {
    "title": "Introduction | Vue Router",
    "url": "https://router.vuejs.org/introduction.html",
    "html": "Introduction\n​\nWatch a Free Vue Router Video Course\n\nVue Router is the official router for Vue.js. It deeply integrates with Vue.js core to make building Single Page Applications with Vue.js a breeze. Features include:\n\nNested routes mapping\nDynamic Routing\nModular, component-based router configuration\nRoute params, query, wildcards\nView transition effects powered by Vue.js' transition system\nFine-grained navigation control\nLinks with automatic active CSS classes\nHTML5 history mode or hash mode\nCustomizable Scroll Behavior\nProper encoding for URLs\n\nGet started or play with the playground (see README.md to run them).\n\nSilver Sponsors\n\nBecome a Sponsor!"
  },
  {
    "title": "Migrating from Vue 2 | Vue Router",
    "url": "https://router.vuejs.org/guide/migration/",
    "html": "Migrating from Vue 2\n​\n\nMost of Vue Router API has remained unchanged during its rewrite from v3 (for Vue 2) to v4 (for Vue 3) but there are still a few breaking changes that you might encounter while migrating your application. This guide is here to help you understand why these changes happened and how to adapt your application to make it work with Vue Router 4.\n\nBreaking Changes\n​\n\nChanges are ordered by their usage. It is therefore recommended to follow this list in order.\n\nnew Router becomes createRouter\n​\n\nVue Router is no longer a class but a set of functions. Instead of writing new Router(), you now have to call createRouter:\n\njs\n// previously was\n// import Router from 'vue-router'\nimport { createRouter } from 'vue-router'\n\nconst router = createRouter({\n  // ...\n})\nNew history option to replace mode\n​\n\nThe mode: 'history' option has been replaced with a more flexible one named history. Depending on which mode you were using, you will have to replace it with the appropriate function:\n\n\"history\": createWebHistory()\n\"hash\": createWebHashHistory()\n\"abstract\": createMemoryHistory()\n\nHere is a full snippet:\n\njs\nimport { createRouter, createWebHistory } from 'vue-router'\n// there is also createWebHashHistory and createMemoryHistory\n\ncreateRouter({\n  history: createWebHistory(),\n  routes: [],\n})\n\nOn SSR, you need to manually pass the appropriate history:\n\njs\n// router.js\nlet history = isServer ? createMemoryHistory() : createWebHistory()\nlet router = createRouter({ routes, history })\n// somewhere in your server-entry.js\nrouter.push(req.url) // request url\nrouter.isReady().then(() => {\n  // resolve the request\n})\n\nReason: enable tree shaking of non used histories as well as implementing custom histories for advanced use cases like native solutions.\n\nMoved the base option\n​\n\nThe base option is now passed as the first argument to createWebHistory (and other histories):\n\njs\nimport { createRouter, createWebHistory } from 'vue-router'\ncreateRouter({\n  history: createWebHistory('/base-directory/'),\n  routes: [],\n})\nRemoval of the fallback option\n​\n\nThe fallback option is no longer supported when creating the router:\n\ndiff\n-new VueRouter({\n+createRouter({\n-  fallback: false,\n// other options...\n})\n\nReason: All browsers supported by Vue support the HTML5 History API, allowing us to avoid hacks around modifying location.hash and directly use history.pushState().\n\nRemoved * (star or catch all) routes\n​\n\nCatch all routes (*, /*) must now be defined using a parameter with a custom regex:\n\njs\nconst routes = [\n  // pathMatch is the name of the param, e.g., going to /not/found yields\n  // { params: { pathMatch: ['not', 'found'] }}\n  // this is thanks to the last *, meaning repeated params and it is necessary if you\n  // plan on directly navigating to the not-found route using its name\n  { path: '/:pathMatch(.*)*', name: 'not-found', component: NotFound },\n  // if you omit the last `*`, the `/` character in params will be encoded when resolving or pushing\n  { path: '/:pathMatch(.*)', name: 'bad-not-found', component: NotFound },\n]\n// bad example if using named routes:\nrouter.resolve({\n  name: 'bad-not-found',\n  params: { pathMatch: 'not/found' },\n}).href // '/not%2Ffound'\n// good example:\nrouter.resolve({\n  name: 'not-found',\n  params: { pathMatch: ['not', 'found'] },\n}).href // '/not/found'\n\nTIP\n\nYou don't need to add the * for repeated params if you don't plan to directly push to the not found route using its name. If you call router.push('/not/found/url'), it will provide the right pathMatch param.\n\nReason: Vue Router doesn't use path-to-regexp anymore, instead it implements its own parsing system that allows route ranking and enables dynamic routing. Since we usually add one single catch-all route per project, there is no big benefit in supporting a special syntax for *. The encoding of params is encoding across routes, without exception to make things easier to predict.\n\nThe currentRoute property is now a ref()\n​\n\nPreviously the properties of the currentRoute object on a router instance could be accessed directly.\n\nWith the introduction of vue-router v4, the underlying type of the currentRoute object on the router instance has changed to Ref<RouteLocationNormalizedLoaded>, which comes from the newer reactivity fundamentals introduced in Vue 3.\n\nWhile this doesn't change anything if you're reading the route with useRoute() or this.$route, if you're accessing it directly on the router instance, you will need to access the actual route object via currentRoute.value:\n\nts\nconst { page } = router.currentRoute.query \nconst { page } = router.currentRoute.value.query \nReplaced onReady with isReady\n​\n\nThe existing router.onReady() function has been replaced with router.isReady() which doesn't take any argument and returns a Promise:\n\njs\n// replace\nrouter.onReady(onSuccess, onError)\n// with\nrouter.isReady().then(onSuccess).catch(onError)\n// or use await:\ntry {\n  await router.isReady()\n  // onSuccess\n} catch (err) {\n  // onError\n}\nscrollBehavior changes\n​\n\nThe object returned in scrollBehavior is now similar to ScrollToOptions: x is renamed to left and y is renamed to top. See RFC.\n\nReason: making the object similar to ScrollToOptions to make it feel more familiar with native JS APIs and potentially enable future new options.\n\n<router-view>, <keep-alive>, and <transition>\n​\n\ntransition and keep-alive must now be used inside of RouterView via the v-slot API:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <transition>\n    <keep-alive>\n      <component :is=\"Component\" />\n    </keep-alive>\n  </transition>\n</router-view>\n\nReason: This was a necessary change. See the related RFC.\n\nRemoval of append prop in <router-link>\n​\n\nThe append prop has been removed from <router-link>. You can manually concatenate the value to an existing path instead:\n\ntemplate\nreplace\n<router-link to=\"child-route\" append>to relative child</router-link>\nwith\n<router-link :to=\"append($route.path, 'child-route')\">\n  to relative child\n</router-link>\n\nYou must define a global append function on your App instance:\n\njs\napp.config.globalProperties.append = (path, pathToAppend) =>\n  path + (path.endsWith('/') ? '' : '/') + pathToAppend\n\nReason: append wasn't used very often, is easy to replicate in user land.\n\nRemoval of event and tag props in <router-link>\n​\n\nBoth event, and tag props have been removed from <router-link>. You can use the v-slot API to fully customize <router-link>:\n\ntemplate\nreplace\n<router-link to=\"/about\" tag=\"span\" event=\"dblclick\">About Us</router-link>\nwith\n<router-link to=\"/about\" custom v-slot=\"{ navigate }\">\n  <span @click=\"navigate\" @keypress.enter=\"navigate\" role=\"link\">About Us</span>\n</router-link>\n\nReason: These props were often used together to use something different from an <a> tag but were introduced before the v-slot API and are not used enough to justify adding to the bundle size for everybody.\n\nRemoval of the exact prop in <router-link>\n​\n\nThe exact prop has been removed because the caveat it was fixing is no longer present so you should be able to safely remove it. There are however two things you should be aware of:\n\nRoutes are now active based on the route records they represent instead of the generated route location objects and their path, query, and hash properties\nOnly the path section is matched, query, and hash aren't taken into account anymore\n\nIf you wish to customize this behavior, e.g. take into account the hash section, you should use the v-slot API to extend <router-link>.\n\nReason: See the RFC about active matching changes for more details.\n\nNavigation guards in mixins are ignored\n​\n\nAt the moment navigation guards in mixins are not supported. You can track its support at vue-router#454.\n\nRemoval of router.match and changes to router.resolve\n​\n\nBoth router.match, and router.resolve have been merged together into router.resolve with a slightly different signature. Refer to the API for more details.\n\nReason: Uniting multiple methods that were used for the same purpose.\n\nRemoval of router.getMatchedComponents()\n​\n\nThe method router.getMatchedComponents is now removed as matched components can be retrieved from router.currentRoute.value.matched:\n\njs\nrouter.currentRoute.value.matched.flatMap(record =>\n  Object.values(record.components)\n)\n\nReason: This method was only used during SSR and is a one liner that can be done by the user.\n\nRedirect records cannot use special paths\n​\n\nPreviously, a non documented feature allowed to set a redirect record to a special path like /events/:id and it would reuse an existing param id. This is no longer possible and there are two options:\n\nUsing the name of the route without the param: redirect: { name: 'events' }. Note this won't work if the param :id is optional\nUsing a function to recreate the new location based on the target: redirect: to => ({ name: 'events', params: to.params })\n\nReason: This syntax was rarely used and another way of doing things that wasn't shorter enough compared to the versions above while introducing some complexity and making the router heavier.\n\nAll navigations are now always asynchronous\n​\n\nAll navigations, including the first one, are now asynchronous, meaning that, if you use a transition, you may need to wait for the router to be ready before mounting the app:\n\njs\napp.use(router)\n// Note: on Server Side, you need to manually push the initial location\nrouter.isReady().then(() => app.mount('#app'))\n\nOtherwise there will be an initial transition as if you provided the appear prop to transition because the router displays its initial location (nothing) and then displays the first location.\n\nNote that if you have navigation guards upon the initial navigation, you might not want to block the app render until they are resolved unless you are doing Server Side Rendering. In this scenario, not waiting the router to be ready to mount the app would yield the same result as in Vue 2.\n\nRemoval of router.app\n​\n\nrouter.app used to represent the last root component (Vue instance) that injected the router. Vue Router can now be safely used by multiple Vue applications at the same time. You can still add it when using the router:\n\njs\napp.use(router)\nrouter.app = app\n\nYou can also extend the TypeScript definition of the Router interface to add the app property.\n\nReason: Vue 3 applications do not exist in Vue 2 and now we properly support multiple applications using the same Router instance, so having an app property would have been misleading because it would have been the application instead of the root instance.\n\nPassing content to route components' <slot>\n​\n\nBefore you could directly pass a template to be rendered by a route components' <slot> by nesting it under a <router-view> component:\n\ntemplate\n<router-view>\n  <p>In Vue Router 3, I render inside the route component</p>\n</router-view>\n\nBecause of the introduction of the v-slot api for <router-view>, you must pass it to the <component> using the v-slot API:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <component :is=\"Component\">\n    <p>In Vue Router 3, I render inside the route component</p>\n  </component>\n</router-view>\nRemoval of parent from route locations\n​\n\nThe parent property has been removed from normalized route locations (this.$route and object returned by router.resolve). You can still access it via the matched array:\n\njs\nconst parent = this.$route.matched[this.$route.matched.length - 2]\n\nReason: Having parent and children creates unnecessary circular references while the properties could be retrieved already through matched.\n\nRemoval of pathToRegexpOptions\n​\n\nThe pathToRegexpOptions and caseSensitive properties of route records have been replaced with sensitive and strict options for createRouter(). They can now also be directly passed when creating the router with createRouter(). Any other option specific to path-to-regexp has been removed as path-to-regexp is no longer used to parse paths.\n\nRemoval of unnamed parameters\n​\n\nDue to the removal of path-to-regexp, unnamed parameters are no longer supported:\n\n/foo(/foo)?/suffix becomes /foo/:_(foo)?/suffix\n/foo(foo)? becomes /foo:_(foo)?\n/foo/(.*) becomes /foo/:_(.*)\n\nTIP\n\nNote you can use any name instead of _ for the param. The point is to provide one.\n\nUsage of history.state\n​\n\nVue Router saves information on the history.state. If you have any code manually calling history.pushState(), you should likely avoid it or refactor it with a regular router.push() and a history.replaceState():\n\njs\n// replace\nhistory.pushState(myState, '', url)\n// with\nawait router.push(url)\nhistory.replaceState({ ...history.state, ...myState }, '')\n\nSimilarly, if you were calling history.replaceState() without preserving the current state, you will need to pass the current history.state:\n\njs\n// replace\nhistory.replaceState({}, '', url)\n// with\nhistory.replaceState(history.state, '', url)\n\nReason: We use the history state to save information about the navigation like the scroll position, previous location, etc.\n\nroutes option is required in options\n​\n\nThe property routes is now required in options.\n\njs\ncreateRouter({ routes: [] })\n\nReason: The router is designed to be created with routes even though you can add them later on. You need at least one route in most scenarios and this is written once per app in general.\n\nNon existent named routes\n​\n\nPushing or resolving a non existent named route throws an error:\n\njs\n// Oops, we made a typo in name\nrouter.push({ name: 'homee' }) // throws\nrouter.resolve({ name: 'homee' }) // throws\n\nReason: Previously, the router would navigate to / but display nothing (instead of the home page). Throwing an error makes more sense because we cannot produce a valid URL to navigate to.\n\nMissing required params on named routes\n​\n\nPushing or resolving a named route without its required params will throw an error:\n\njs\n// given the following route:\nconst routes = [{ path: '/users/:id', name: 'user', component: UserDetails }]\n\n// Missing the `id` param will fail\nrouter.push({ name: 'user' })\nrouter.resolve({ name: 'user' })\n\nReason: Same as above.\n\nNamed children routes with an empty path no longer appends a slash\n​\n\nGiven any nested named route with an empty path:\n\njs\nconst routes = [\n  {\n    path: '/dashboard',\n    name: 'dashboard-parent',\n    component: DashboardParent,\n    children: [\n      { path: '', name: 'dashboard', component: DashboardDefault },\n      {\n        path: 'settings',\n        name: 'dashboard-settings',\n        component: DashboardSettings,\n      },\n    ],\n  },\n]\n\nNavigating or resolving to the named route dashboard will now produce a URL without a trailing slash:\n\njs\nrouter.resolve({ name: 'dashboard' }).href // '/dashboard'\n\nThis has an important side effect about children redirect records like these:\n\njs\nconst routes = [\n  {\n    path: '/parent',\n    component: Parent,\n    children: [\n      // this would now redirect to `/home` instead of `/parent/home`\n      { path: '', redirect: 'home' },\n      { path: 'home', component: Home },\n    ],\n  },\n]\n\nNote this will work if path was /parent/ as the relative location home to /parent/ is indeed /parent/home but the relative location of home to /parent is /home.\n\nReason: This is to make trailing slash behavior consistent: by default all routes allow a trailing slash. It can be disabled by using the strict option and manually appending (or not) a slash to the routes.\n\n$route properties Encoding\n​\n\nDecoded values in params, query, and hash are now consistent no matter where the navigation is initiated (older browsers will still produce unencoded path and fullPath). The initial navigation should yield the same results as in-app navigations.\n\nGiven any normalized route location:\n\nValues in path, fullPath are not decoded anymore. They will appear as provided by the browser (most browsers provide them encoded). e.g. directly writing on the address bar https://example.com/hello world will yield the encoded version: https://example.com/hello%20world and both path and fullPath will be /hello%20world.\nhash is now decoded, that way it can be copied over: router.push({ hash: $route.hash }) and be used directly in scrollBehavior's el option.\nWhen using push, resolve, and replace and providing a string location or a path property in an object, it must be encoded (like in the previous version). On the other hand, params, query and hash must be provided in its unencoded version.\nThe slash character (/) is now properly decoded inside params while still producing an encoded version on the URL: %2F.\n\nReason: This allows to easily copy existing properties of a location when calling router.push() and router.resolve(), and make the resulting route location consistent across browsers. router.push() is now idempotent, meaning that calling router.push(route.fullPath), router.push({ hash: route.hash }), router.push({ query: route.query }), and router.push({ params: route.params }) will not create extra encoding.\n\nTypeScript changes\n​\n\nTo make typings more consistent and expressive, some types have been renamed:\n\nvue-router@3\tvue-router@4\nRouteConfig\tRouteRecordRaw\nLocation\tRouteLocation\nRoute\tRouteLocationNormalized\nNew Features\n​\n\nSome of new features to keep an eye on in Vue Router 4 include:\n\nDynamic Routing\nComposition API"
  },
  {
    "title": "Waiting for the result of a Navigation | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/navigation-failures",
    "html": "Waiting for the result of a Navigation\n​\nWatch a free video lesson on Vue School\n\nWhen using router-link, Vue Router calls router.push to trigger a navigation. While the expected behavior for most links is to navigate a user to a new page, there are a few situations where users will remain on the same page:\n\nUsers are already on the page that they are trying to navigate to.\nA navigation guard aborts the navigation by doing return false.\nA new navigation guard takes place while the previous one not finished.\nA navigation guard redirects somewhere else by returning a new location (e.g. return '/login').\nA navigation guard throws an Error.\n\nIf we want to do something after a navigation is finished, we need a way to wait after calling router.push. Imagine we have a mobile menu that allows us to go to different pages and we only want to hide the menu once we have navigated to the new page, we might want to do something like this:\n\njs\nrouter.push('/my-profile')\nthis.isMenuOpen = false\n\nBut this will close the menu right away because navigations are asynchronous, we need to await the promise returned by router.push:\n\njs\nawait router.push('/my-profile')\nthis.isMenuOpen = false\n\nNow the menu will close once the navigation is finished but it will also close if the navigation was prevented. We need a way to detect if we actually changed the page we are on or not.\n\nDetecting Navigation Failures\n​\n\nIf a navigation is prevented, resulting in the user staying on the same page, the resolved value of the Promise returned by router.push will be a Navigation Failure. Otherwise, it will be a falsy value (usually undefined). This allows us to differentiate the case where we navigated away from where we are or not:\n\njs\nconst navigationResult = await router.push('/my-profile')\n\nif (navigationResult) {\n  // navigation prevented\n} else {\n  // navigation succeeded (this includes the case of a redirection)\n  this.isMenuOpen = false\n}\n\nNavigation Failures are Error instances with a few extra properties that gives us enough information to know what navigation was prevented and why. To check the nature of a navigation result, use the isNavigationFailure function:\n\njs\nimport { NavigationFailureType, isNavigationFailure } from 'vue-router'\n\n// trying to leave the editing page of an article without saving\nconst failure = await router.push('/articles/2')\n\nif (isNavigationFailure(failure, NavigationFailureType.aborted)) {\n  // show a small notification to the user\n  showToast('You have unsaved changes, discard and leave anyway?')\n}\n\nTIP\n\nIf you omit the second parameter: isNavigationFailure(failure), it will only check if failure is a Navigation Failure.\n\nGlobal navigation failures\n​\n\nYou can detect global navigation failures globally by using the router.afterEach() navigation guard:\n\nts\nrouter.afterEach((to, from, failure) => {\n  if (failure) {\n    sendToAnalytics(to, from, failure)\n  }\n})\nDifferentiating Navigation Failures\n​\n\nAs we said at the beginning, there are different situations aborting a navigation, all of them resulting in different Navigation Failures. They can be differentiated using the isNavigationFailure and NavigationFailureType. There are three different types:\n\naborted: false was returned inside of a navigation guard to the navigation.\ncancelled: A new navigation took place before the current navigation could finish. e.g. router.push was called while waiting inside of a navigation guard.\nduplicated: The navigation was prevented because we are already at the target location.\nNavigation Failures's properties\n​\n\nAll navigation failures expose to and from properties to reflect the current location as well as the target location for the navigation that failed:\n\njs\n// trying to access the admin page\nrouter.push('/admin').then(failure => {\n  if (isNavigationFailure(failure, NavigationFailureType.aborted)) {\n    failure.to.path // '/admin'\n    failure.from.path // '/'\n  }\n})\n\nIn all cases, to and from are normalized route locations.\n\nDetecting Redirections\n​\n\nWhen returning a new location inside of a Navigation Guard, we are triggering a new navigation that overrides the ongoing one. Differently from other return values, a redirection doesn't prevent a navigation, it creates a new one. It is therefore checked differently, by reading the redirectedFrom property in a Route Location:\n\njs\nawait router.push('/my-profile')\nif (router.currentRoute.value.redirectedFrom) {\n  // redirectedFrom is resolved route location like to and from in navigation guards\n}"
  },
  {
    "title": "Dynamic Routing | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/dynamic-routing",
    "html": "Dynamic Routing\n​\nWatch a free video lesson on Vue School\n\nAdding routes to your router is usually done via the routes option but in some situations, you might want to add or remove routes while the application is already running. Application with extensible interfaces like Vue CLI UI can use this to make the application grow.\n\nAdding routes\n​\n\nDynamic routing is achieved mainly via two functions: router.addRoute() and router.removeRoute(). They only register a new route, meaning that if the newly added route matches the current location, it would require you to manually navigate with router.push() or router.replace() to display that new route. Let's take a look at an example:\n\nImagine having the following router with one single route:\n\njs\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [{ path: '/:articleName', component: Article }],\n})\n\nGoing to any page, /about, /store, or /3-tricks-to-improve-your-routing-code ends up rendering the Article component. If we are on /about and we add a new route:\n\njs\nrouter.addRoute({ path: '/about', component: About })\n\nThe page will still show the Article component, we need to manually call router.replace() to change the current location and overwrite where we were (instead of pushing a new entry, ending up in the same location twice in our history):\n\njs\nrouter.addRoute({ path: '/about', component: About })\n// we could also use this.$route or route = useRoute() (inside a setup)\nrouter.replace(router.currentRoute.value.fullPath)\n\nRemember you can await router.replace() if you need to wait for the new route to be displayed.\n\nAdding routes inside navigation guards\n​\n\nIf you decide to add or remove routes inside of a navigation guard, you should not call router.replace() but trigger a redirection by returning the new location:\n\njs\nrouter.beforeEach(to => {\n  if (!hasNecessaryRoute(to)) {\n    router.addRoute(generateRoute(to))\n    // trigger a redirection\n    return to.fullPath\n  }\n})\n\nThe example above assumes two things: first, the newly added route record will match the to location, effectively resulting in a different location from the one we were trying to access. Second, hasNecessaryRoute() returns false after adding the new route to avoid an infinite redirection.\n\nBecause we are redirecting, we are replacing the ongoing navigation, effectively behaving like the example shown before. In real world scenarios, adding is more likely to happen outside of navigation guards, e.g. when a view component mounts, it register new routes.\n\nRemoving routes\n​\n\nThere are few different ways to remove existing routes:\n\nBy adding a route with a conflicting name. If you add a route that has the same name as an existing route, it will remove the route first and then add the route:\n\njs\nrouter.addRoute({ path: '/about', name: 'about', component: About })\n// this will remove the previously added route because they have\n// the same name and names are unique across all routes\nrouter.addRoute({ path: '/other', name: 'about', component: Other })\n\nBy calling the callback returned by router.addRoute():\n\njs\nconst removeRoute = router.addRoute(routeRecord)\nremoveRoute() // removes the route if it exists\n\nThis is useful when the routes do not have a name\n\nBy using router.removeRoute() to remove a route by its name:\n\njs\nrouter.addRoute({ path: '/about', name: 'about', component: About })\n// remove the route\nrouter.removeRoute('about')\n\nNote you can use Symbols for names in routes if you wish to use this function but want to avoid conflicts in names.\n\nWhenever a route is removed, all of its aliases and children are removed with it.\n\nAdding nested routes\n​\n\nTo add nested routes to an existing route, you can pass the name of the route as its first parameter to router.addRoute(), this will effectively add the route as if it was added through children:\n\njs\nrouter.addRoute({ name: 'admin', path: '/admin', component: Admin })\nrouter.addRoute('admin', { path: 'settings', component: AdminSettings })\n\nThis is equivalent to:\n\njs\nrouter.addRoute({\n  name: 'admin',\n  path: '/admin',\n  component: Admin,\n  children: [{ path: 'settings', component: AdminSettings }],\n})\nLooking at existing routes\n​\n\nVue Router gives you two functions to look at existing routes:\n\nrouter.hasRoute(): check if a route exists\nrouter.getRoutes(): get an array with all the route records."
  },
  {
    "title": "Extending RouterLink | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/extending-router-link",
    "html": "Extending RouterLink\n​\nWatch a free video lesson on Vue School\n\nThe RouterLink component exposes enough props to suffice most basic applications but it doesn't try to cover every possible use case and you will likely find yourself using v-slot for some advanced cases. In most medium to large sized applications, it's worth creating one if not multiple custom RouterLink components to reuse them across your application. Some examples are Links in a Navigation Menu, handling external links, adding an inactive-class, etc.\n\nLet's extend RouterLink to handle external links as well and adding a custom inactive-class in an AppLink.vue file:\n\nvue\n<template>\n  <a v-if=\"isExternalLink\" v-bind=\"$attrs\" :href=\"to\" target=\"_blank\">\n    <slot />\n  </a>\n  <router-link\n    v-else\n    v-bind=\"$props\"\n    custom\n    v-slot=\"{ isActive, href, navigate }\"\n  >\n    <a\n      v-bind=\"$attrs\"\n      :href=\"href\"\n      @click=\"navigate\"\n      :class=\"isActive ? activeClass : inactiveClass\"\n    >\n      <slot />\n    </a>\n  </router-link>\n</template>\n\n<script>\nimport { RouterLink } from 'vue-router'\n\nexport default {\n  name: 'AppLink',\n  inheritAttrs: false,\n\n  props: {\n    // add @ts-ignore if using TypeScript\n    ...RouterLink.props,\n    inactiveClass: String,\n  },\n\n  computed: {\n    isExternalLink() {\n      return typeof this.to === 'string' && this.to.startsWith('http')\n    },\n  },\n}\n</script>\n\nIf you prefer using a render function or create computed properties, you can use the useLink from the Composition API:\n\njs\nimport { RouterLink, useLink } from 'vue-router'\n\nexport default {\n  name: 'AppLink',\n\n  props: {\n    // add @ts-ignore if using TypeScript\n    ...RouterLink.props,\n    inactiveClass: String,\n  },\n\n  setup(props) {\n    // `props` contains `to` and any other prop that can be passed to <router-link>\n    const { navigate, href, route, isActive, isExactActive } = useLink(props)\n\n    // profit!\n\n    return { isExternalLink }\n  },\n}\n\nIn practice, you might want to use your AppLink component for different parts of your application. e.g. using Tailwind CSS, you could create a NavLink.vue component with all the classes:\n\nvue\n<template>\n  <AppLink\n    v-bind=\"$attrs\"\n    class=\"inline-flex items-center px-1 pt-1 border-b-2 border-transparent text-sm font-medium leading-5 text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:outline-none focus:text-gray-700 focus:border-gray-300 transition duration-150 ease-in-out\"\n    active-class=\"border-indigo-500 text-gray-900 focus:border-indigo-700\"\n    inactive-class=\"text-gray-500 hover:text-gray-700 hover:border-gray-300 focus:text-gray-700 focus:border-gray-300\"\n  >\n    <slot />\n  </AppLink>\n</template>"
  },
  {
    "title": "Typed Routes (v4.1.0+) | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/typed-routes",
    "html": "Typed Routes (v4.1.0+)\n​\n\n‼️ Experimental feature\n\nStarting from v4.1.0, we are introducing a new feature called Typed Routes. This experimental feature is enabled through a Vite/webpack/Rollup plugin.\n\nCheck the v4.1 release notes for more information about this feature. Check out the plugin GitHub repository for installation instructions and documentation."
  },
  {
    "title": "Scroll Behavior | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/scroll-behavior",
    "html": "Scroll Behavior\n​\nWatch a free video lesson on Vue School\n\nWhen using client-side routing, we may want to scroll to top when navigating to a new route, or preserve the scrolling position of history entries just like real page reload does. Vue Router allows you to achieve these and even better, allows you to completely customize the scroll behavior on route navigation.\n\nNote: this feature only works if the browser supports history.pushState.\n\nWhen creating the router instance, you can provide the scrollBehavior function:\n\njs\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [...],\n  scrollBehavior (to, from, savedPosition) {\n    // return desired position\n  }\n})\n\nThe scrollBehavior function receives the to and from route objects, like Navigation Guards. The third argument, savedPosition, is only available if this is a popstate navigation (triggered by the browser's back/forward buttons).\n\nThe function can return a ScrollToOptions position object:\n\njs\nconst router = createRouter({\n  scrollBehavior(to, from, savedPosition) {\n    // always scroll to top\n    return { top: 0 }\n  },\n})\n\nYou can also pass a CSS selector or a DOM element via el. In that scenario, top and left will be treated as relative offsets to that element.\n\njs\nconst router = createRouter({\n  scrollBehavior(to, from, savedPosition) {\n    // always scroll 10px above the element #main\n    return {\n      // could also be\n      // el: document.getElementById('main'),\n      el: '#main',\n      // 10px above the element\n      top: 10,\n    }\n  },\n})\n\nIf a falsy value or an empty object is returned, no scrolling will happen.\n\nReturning the savedPosition will result in a native-like behavior when navigating with back/forward buttons:\n\njs\nconst router = createRouter({\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return { top: 0 }\n    }\n  },\n})\n\nIf you want to simulate the \"scroll to anchor\" behavior:\n\njs\nconst router = createRouter({\n  scrollBehavior(to, from, savedPosition) {\n    if (to.hash) {\n      return {\n        el: to.hash,\n      }\n    }\n  },\n})\n\nIf your browser supports scroll behavior, you can make it smooth:\n\njs\nconst router = createRouter({\n  scrollBehavior(to, from, savedPosition) {\n    if (to.hash) {\n      return {\n        el: to.hash,\n        behavior: 'smooth',\n      }\n    }\n  }\n})\nDelaying the scroll\n​\n\nSometimes we need to wait a bit before scrolling in the page. For example, when dealing with transitions, we want to wait for the transition to finish before scrolling. To do this you can return a Promise that returns the desired position descriptor. Here is an example where we wait 500ms before scrolling:\n\njs\nconst router = createRouter({\n  scrollBehavior(to, from, savedPosition) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve({ left: 0, top: 0 })\n      }, 500)\n    })\n  },\n})\n\nIt's possible to hook this up with events from a page-level transition component to make the scroll behavior play nicely with your page transitions, but due to the possible variance and complexity in use cases, we simply provide this primitive to enable specific userland implementations."
  },
  {
    "title": "Lazy Loading Routes | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/lazy-loading",
    "html": "Lazy Loading Routes\n​\nWatch a free video lesson on Vue School\n\nWhen building apps with a bundler, the JavaScript bundle can become quite large, and thus affect the page load time. It would be more efficient if we can split each route's components into separate chunks, and only load them when the route is visited.\n\nVue Router supports dynamic imports out of the box, meaning you can replace static imports with dynamic ones:\n\njs\n// replace\n// import UserDetails from './views/UserDetails'\n// with\nconst UserDetails = () => import('./views/UserDetails.vue')\n\nconst router = createRouter({\n  // ...\n  routes: [\n    { path: '/users/:id', component: UserDetails }\n    // or use it directly in the route definition\n    { path: '/users/:id', component: () => import('./views/UserDetails.vue') },\n  ],\n})\n\nThe component (and components) option accepts a function that returns a Promise of a component and Vue Router will only fetch it when entering the page for the first time, then use the cached version. Which means you can also have more complex functions as long as they return a Promise:\n\njs\nconst UserDetails = () =>\n  Promise.resolve({\n    /* component definition */\n  })\n\nIn general, it's a good idea to always use dynamic imports for all your routes.\n\nNote\n\nDo not use Async components for routes. Async components can still be used inside route components but route component themselves are just dynamic imports.\n\nWhen using a bundler like webpack, this will automatically benefit from code splitting\n\nWhen using Babel, you will need to add the syntax-dynamic-import plugin so that Babel can properly parse the syntax.\n\nGrouping Components in the Same Chunk\n​\nWith webpack\n​\n\nSometimes we may want to group all the components nested under the same route into the same async chunk. To achieve that we need to use named chunks by providing a chunk name using a special comment syntax (requires webpack > 2.4):\n\njs\nconst UserDetails = () =>\n  import(/* webpackChunkName: \"group-user\" */ './UserDetails.vue')\nconst UserDashboard = () =>\n  import(/* webpackChunkName: \"group-user\" */ './UserDashboard.vue')\nconst UserProfileEdit = () =>\n  import(/* webpackChunkName: \"group-user\" */ './UserProfileEdit.vue')\n\nwebpack will group any async module with the same chunk name into the same async chunk.\n\nWith Vite\n​\n\nIn Vite you can define the chunks under the rollupOptions:\n\njs\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      // https://rollupjs.org/guide/en/#outputmanualchunks\n      output: {\n        manualChunks: {\n          'group-user': [\n            './src/UserDetails',\n            './src/UserDashboard',\n            './src/UserProfileEdit',\n          ],\n        },\n      },\n    },\n  },\n})"
  },
  {
    "title": "Transitions | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/transitions",
    "html": "Transitions\n​\nWatch a free video lesson on Vue School\n\nIn order to use transitions on your route components and animate navigations, you need to use the <RouterView> slot:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <transition name=\"fade\">\n    <component :is=\"Component\" />\n  </transition>\n</router-view>\n\nAll transition APIs work the same here.\n\nPer-Route Transition\n​\n\nThe above usage will apply the same transition for all routes. If you want each route's component to have different transitions, you can instead combine meta fields and a dynamic name on <transition>:\n\njs\nconst routes = [\n  {\n    path: '/custom-transition',\n    component: PanelLeft,\n    meta: { transition: 'slide-left' },\n  },\n  {\n    path: '/other-transition',\n    component: PanelRight,\n    meta: { transition: 'slide-right' },\n  },\n]\ntemplate\n<router-view v-slot=\"{ Component, route }\">\n  <!-- Use any custom transition and  to `fade` -->\n  <transition :name=\"route.meta.transition || 'fade'\">\n    <component :is=\"Component\" />\n  </transition>\n</router-view>\nRoute-Based Dynamic Transition\n​\n\nIt is also possible to determine the transition to use dynamically based on the relationship between the target route and current route. Using a very similar snippet to the one just before:\n\ntemplate\n<!-- use a dynamic transition name -->\n<router-view v-slot=\"{ Component, route }\">\n  <transition :name=\"route.meta.transition\">\n    <component :is=\"Component\" />\n  </transition>\n</router-view>\n\nWe can add an after navigation hook to dynamically add information to the meta field based on the depth of the route\n\njs\nrouter.afterEach((to, from) => {\n  const toDepth = to.path.split('/').length\n  const fromDepth = from.path.split('/').length\n  to.meta.transition = toDepth < fromDepth ? 'slide-right' : 'slide-left'\n})\nForcing a transition between reused views\n​\n\nVue might automatically reuse components that look alike, avoiding any transition. Fortunately, it is possible to add a key attribute to force transitions. This also allows you to trigger transitions while staying on the same route with different params:\n\ntemplate\n<router-view v-slot=\"{ Component, route }\">\n  <transition name=\"fade\">\n    <component :is=\"Component\" :key=\"route.path\" />\n  </transition>\n</router-view>"
  },
  {
    "title": "RouterView slot | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/router-view-slot",
    "html": "RouterView slot\n​\n\nThe RouterView component exposes a slot that can be used to render the route component:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <component :is=\"Component\" />\n</router-view>\n\nThe code above is equivalent to using <router-view /> without the slot, but the slot provides extra flexibility when we want to work with other features.\n\nKeepAlive & Transition\n​\n\nWhen working with the KeepAlive component, we would usually want it to keep the route components alive, not the RouterView itself. We can achieve that by putting the KeepAlive inside the slot:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <keep-alive>\n    <component :is=\"Component\" />\n  </keep-alive>\n</router-view>\n\nSimilarly, the slot allows us to use a Transition component to transition between route components:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <transition>\n    <component :is=\"Component\" />\n  </transition>\n</router-view>\n\nWe can also use KeepAlive inside a Transition:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <transition>\n    <keep-alive>\n      <component :is=\"Component\" />\n    </keep-alive>\n  </transition>\n</router-view>\n\nFor more information about using RouterView with the Transition component, see the Transitions guide.\n\nPassing props and slots\n​\n\nWe can use the slot to pass props or slots to the route component:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <component :is=\"Component\" some-prop=\"a value\">\n    <p>Some slotted content</p>\n  </component>\n</router-view>\n\nIn practice, this usually isn't something you would want to do, as the route components would all need to use the same props and slots. See Passing Props to Route Components for other ways to pass props.\n\nTemplate refs\n​\n\nUsing the slot allows us to put a template ref directly on the route component:\n\ntemplate\n<router-view v-slot=\"{ Component }\">\n  <component :is=\"Component\" ref=\"mainContent\" />\n</router-view>\n\nIf we put the ref on the <router-view> instead then the ref would be populated with the RouterView instance, rather than the route component."
  },
  {
    "title": "Vue Router and the Composition API | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/composition-api",
    "html": "Vue Router and the Composition API\n​\nWatch a free video lesson on Vue School\n\nThe introduction of setup and Vue's Composition API, open up new possibilities but to be able to get the full potential out of Vue Router, we will need to use a few new functions to replace access to this and in-component navigation guards.\n\nAccessing the Router and current Route inside setup\n​\n\nBecause we don't have access to this inside of setup, we cannot directly access this.$router or this.$route anymore. Instead we use the useRouter and useRoute functions:\n\njs\nimport { useRouter, useRoute } from 'vue-router'\n\nexport default {\n  setup() {\n    const router = useRouter()\n    const route = useRoute()\n\n    function pushWithQuery(query) {\n      router.push({\n        name: 'search',\n        query: {\n          ...route.query,\n          ...query,\n        },\n      })\n    }\n  },\n}\n\nThe route object is a reactive object, so any of its properties can be watched and you should avoid watching the whole route object. In most scenarios, you should directly watch the param you are expecting to change\n\njs\nimport { useRoute } from 'vue-router'\nimport { ref, watch } from 'vue'\n\nexport default {\n  setup() {\n    const route = useRoute()\n    const userData = ref()\n\n    // fetch the user information when params change\n    watch(\n      () => route.params.id,\n      async newId => {\n        userData.value = await fetchUser(newId)\n      }\n    )\n  },\n}\n\nNote we still have access to $router and $route in templates, so there is no need to return router or route inside of setup.\n\nNavigation Guards\n​\n\nWhile you can still use in-component navigation guards with a setup function, Vue Router exposes update and leave guards as Composition API functions:\n\njs\nimport { onBeforeRouteLeave, onBeforeRouteUpdate } from 'vue-router'\nimport { ref } from 'vue'\n\nexport default {\n  setup() {\n    // same as beforeRouteLeave option with no access to `this`\n    onBeforeRouteLeave((to, from) => {\n      const answer = window.confirm(\n        'Do you really want to leave? you have unsaved changes!'\n      )\n      // cancel the navigation and stay on the same page\n      if (!answer) return false\n    })\n\n    const userData = ref()\n\n    // same as beforeRouteUpdate option with no access to `this`\n    onBeforeRouteUpdate(async (to, from) => {\n      // only fetch the user if the id changed as maybe only the query or the hash changed\n      if (to.params.id !== from.params.id) {\n        userData.value = await fetchUser(to.params.id)\n      }\n    })\n  },\n}\n\nComposition API guards can also be used in any component rendered by <router-view>, they don't have to be used directly on the route component like in-component guards.\n\nuseLink\n​\n\nVue Router exposes the internal behavior of RouterLink as a composable. It accepts a reactive object like the props of RouterLink and exposes low-level properties to build your own RouterLink component or generate custom links:\n\njs\nimport { RouterLink, useLink } from 'vue-router'\nimport { computed } from 'vue'\n\nexport default {\n  name: 'AppLink',\n\n  props: {\n    // add @ts-ignore if using TypeScript\n    ...RouterLink.props,\n    inactiveClass: String,\n  },\n\n  setup(props) {\n    const {\n      // the resolved route object\n      route,\n      // the href to use in a link\n      href,\n      // boolean ref  indicating if the link is active\n      isActive,\n      // boolean ref  indicating if the link is exactly active\n      isExactActive,\n      // function to navigate to the link\n      navigate\n      } = useLink(props)\n\n    const isExternalLink = computed(\n      () => typeof props.to === 'string' && props.to.startsWith('http')\n    )\n\n    return { isExternalLink, href, navigate, isActive }\n  },\n}\n\nNote that the RouterLink's v-slot gives access to the same properties as the useLink composable."
  },
  {
    "title": "Data Fetching | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/data-fetching",
    "html": "Data Fetching\n​\n\nSometimes you need to fetch data from the server when a route is activated. For example, before rendering a user profile, you need to fetch the user's data from the server. We can achieve this in two different ways:\n\nFetching After Navigation: perform the navigation first, and fetch data in the incoming component's lifecycle hook. Display a loading state while data is being fetched.\n\nFetching Before Navigation: Fetch data before navigation in the route enter guard, and perform the navigation after data has been fetched.\n\nTechnically, both are valid choices - it ultimately depends on the user experience you are aiming for.\n\nFetching After Navigation\n​\n\nWhen using this approach, we navigate and render the incoming component immediately, and fetch data in the component's created hook. It gives us the opportunity to display a loading state while the data is being fetched over the network, and we can also handle loading differently for each view.\n\nLet's assume we have a Post component that needs to fetch the data for a post based on $route.params.id:\n\nhtml\n<template>\n  <div class=\"post\">\n    <div v-if=\"loading\" class=\"loading\">Loading...</div>\n\n    <div v-if=\"error\" class=\"error\">{{ error }}</div>\n\n    <div v-if=\"post\" class=\"content\">\n      <h2>{{ post.title }}</h2>\n      <p>{{ post.body }}</p>\n    </div>\n  </div>\n</template>\njs\nexport default {\n  data() {\n    return {\n      loading: false,\n      post: null,\n      error: null,\n    }\n  },\n  created() {\n    // watch the params of the route to fetch the data again\n    this.$watch(\n      () => this.$route.params,\n      () => {\n        this.fetchData()\n      },\n      // fetch the data when the view is created and the data is\n      // already being observed\n      { immediate: true }\n    )\n  },\n  methods: {\n    fetchData() {\n      this.error = this.post = null\n      this.loading = true\n      // replace `getPost` with your data fetching util / API wrapper\n      getPost(this.$route.params.id, (err, post) => {\n        this.loading = false\n        if (err) {\n          this.error = err.toString()\n        } else {\n          this.post = post\n        }\n      })\n    },\n  },\n}\nFetching Before Navigation\n​\n\nWith this approach we fetch the data before actually navigating to the new route. We can perform the data fetching in the beforeRouteEnter guard in the incoming component, and only call next when the fetch is complete. The callback passed to next will be called after the component is mounted:\n\njs\nexport default {\n  data() {\n    return {\n      post: null,\n      error: null,\n    }\n  },\n  beforeRouteEnter(to, from, next) {\n    getPost(to.params.id, (err, post) => {\n      // `setData` is a method defined below\n      next(vm => vm.setData(err, post))\n    })\n  },\n  // when route changes and this component is already rendered,\n  // the logic will be slightly different.\n  async beforeRouteUpdate(to, from) {\n    this.post = null\n    try {\n      this.post = await getPost(to.params.id)\n    } catch (error) {\n      this.error = error.toString()\n    }\n  },\n  methods: {\n    setData(error, post) {\n      if (error) {\n        this.error = error\n      } else {\n        this.post = post\n      }\n    }\n  }\n}\n\nThe user will stay on the previous view while the resource is being fetched for the incoming view. It is therefore recommended to display a progress bar or some kind of indicator while the data is being fetched. If the data fetch fails, it's also necessary to display some kind of global warning message."
  },
  {
    "title": "Navigation Guards | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/navigation-guards",
    "html": "Navigation Guards\n​\nWatch a free video lesson on Vue School\n\nAs the name suggests, the navigation guards provided by Vue router are primarily used to guard navigations either by redirecting it or canceling it. There are a number of ways to hook into the route navigation process: globally, per-route, or in-component.\n\nGlobal Before Guards\n​\n\nYou can register global before guards using router.beforeEach:\n\njs\nconst router = createRouter({ ... })\n\nrouter.beforeEach((to, from) => {\n  // ...\n  // explicitly return false to cancel the navigation\n  return false\n})\n\nGlobal before guards are called in creation order, whenever a navigation is triggered. Guards may be resolved asynchronously, and the navigation is considered pending before all hooks have been resolved.\n\nEvery guard function receives two arguments:\n\nto: the target route location in a normalized format being navigated to.\nfrom: the current route location in a normalized format being navigated away from.\n\nAnd can optionally return any of the following values:\n\nfalse: cancel the current navigation. If the browser URL was changed (either manually by the user or via back button), it will be reset to that of the from route.\n\nA Route Location: Redirect to a different location by passing a route location as if you were calling router.push(), which allows you to pass options like replace: true or name: 'home'. The current navigation is dropped and a new one is created with the same from.\n\njs\nrouter.beforeEach(async (to, from) => {\n  if (\n    // make sure the user is authenticated\n    !isAuthenticated &&\n    // ❗️ Avoid an infinite redirect\n    to.name !== 'Login'\n  ) {\n    // redirect the user to the login page\n    return { name: 'Login' }\n  }\n})\n\nIt's also possible to throw an Error if an unexpected situation was met. This will also cancel the navigation and call any callback registered via router.onError().\n\nIf nothing, undefined or true is returned, the navigation is validated, and the next navigation guard is called.\n\nAll of the things above work the same way with async functions and Promises:\n\njs\nrouter.beforeEach(async (to, from) => {\n  // canUserAccess() returns `true` or `false`\n  const canAccess = await canUserAccess(to)\n  if (!canAccess) return '/login'\n})\nOptional third argument next\n​\n\nIn previous versions of Vue Router, it was also possible to use a third argument next, this was a common source of mistakes and went through an RFC to remove it. However, it is still supported, meaning you can pass a third argument to any navigation guard. In that case, you must call next exactly once in any given pass through a navigation guard. It can appear more than once, but only if the logical paths have no overlap, otherwise the hook will never be resolved or produce errors. Here is a bad example of redirecting the user to /login if they are not authenticated:\n\njs\n// BAD\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  // if the user is not authenticated, `next` is called twice\n  next()\n})\n\nHere is the correct version:\n\njs\n// GOOD\nrouter.beforeEach((to, from, next) => {\n  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })\n  else next()\n})\nGlobal Resolve Guards\n​\n\nYou can register a global guard with router.beforeResolve. This is similar to router.beforeEach because it triggers on every navigation, but resolve guards are called right before the navigation is confirmed, after all in-component guards and async route components are resolved. Here is an example that ensures the user has given access to the Camera for routes that have defined a custom meta property requiresCamera:\n\njs\nrouter.beforeResolve(async to => {\n  if (to.meta.requiresCamera) {\n    try {\n      await askForCameraPermission()\n    } catch (error) {\n      if (error instanceof NotAllowedError) {\n        // ... handle the error and then cancel the navigation\n        return false\n      } else {\n        // unexpected error, cancel the navigation and pass the error to the global handler\n        throw error\n      }\n    }\n  }\n})\n\nrouter.beforeResolve is the ideal spot to fetch data or do any other operation that you want to avoid doing if the user cannot enter a page.\n\nGlobal After Hooks\n​\n\nYou can also register global after hooks, however unlike guards, these hooks do not get a next function and cannot affect the navigation:\n\njs\nrouter.afterEach((to, from) => {\n  sendToAnalytics(to.fullPath)\n})\n\nThey are useful for analytics, changing the title of the page, accessibility features like announcing the page and many other things.\n\nThey also reflect navigation failures as the third argument:\n\njs\nrouter.afterEach((to, from, failure) => {\n  if (!failure) sendToAnalytics(to.fullPath)\n})\n\nLearn more about navigation failures on its guide.\n\nGlobal injections within guards\n​\n\nSince Vue 3.3, it is possible to use inject() within navigation guards. This is useful for injecting global properties like the pinia stores. Anything that is provided with app.provide() is also accessible within router.beforeEach(), router.beforeResolve(), router.afterEach():\n\nts\n// main.ts\nconst app = createApp(App)\napp.provide('global', 'hello injections')\n\n// router.ts or main.ts\nrouter.beforeEach((to, from) => {\n  const global = inject('global') // 'hello injections'\n  // a pinia store\n  const userStore = useAuthStore()\n  // ...\n})\nPer-Route Guard\n​\n\nYou can define beforeEnter guards directly on a route's configuration object:\n\njs\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: (to, from) => {\n      // reject the navigation\n      return false\n    },\n  },\n]\n\nbeforeEnter guards only trigger when entering the route, they don't trigger when the params, query or hash change e.g. going from /users/2 to /users/3 or going from /users/2#info to /users/2#projects. They are only triggered when navigating from a different route.\n\nYou can also pass an array of functions to beforeEnter, this is useful when reusing guards for different routes:\n\njs\nfunction removeQueryParams(to) {\n  if (Object.keys(to.query).length)\n    return { path: to.path, query: {}, hash: to.hash }\n}\n\nfunction removeHash(to) {\n  if (to.hash) return { path: to.path, query: to.query, hash: '' }\n}\n\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams, removeHash],\n  },\n  {\n    path: '/about',\n    component: UserDetails,\n    beforeEnter: [removeQueryParams],\n  },\n]\n\nNote it is possible to achieve a similar behavior by using route meta fields and global navigation guards.\n\nIn-Component Guards\n​\n\nFinally, you can directly define route navigation guards inside route components (the ones passed to the router configuration)\n\nUsing the options API\n​\n\nYou can add the following options to route components:\n\nbeforeRouteEnter\nbeforeRouteUpdate\nbeforeRouteLeave\njs\nconst UserDetails = {\n  template: `...`,\n  beforeRouteEnter(to, from) {\n    // called before the route that renders this component is confirmed.\n    // does NOT have access to `this` component instance,\n    // because it has not been created yet when this guard is called!\n  },\n  beforeRouteUpdate(to, from) {\n    // called when the route that renders this component has changed, but this component is reused in the new route.\n    // For example, given a route with params `/users/:id`, when we navigate between `/users/1` and `/users/2`,\n    // the same `UserDetails` component instance will be reused, and this hook will be called when that happens.\n    // Because the component is mounted while this happens, the navigation guard has access to `this` component instance.\n  },\n  beforeRouteLeave(to, from) {\n    // called when the route that renders this component is about to be navigated away from.\n    // As with `beforeRouteUpdate`, it has access to `this` component instance.\n  },\n}\n\nThe beforeRouteEnter guard does NOT have access to this, because the guard is called before the navigation is confirmed, thus the new entering component has not even been created yet.\n\nHowever, you can access the instance by passing a callback to next. The callback will be called when the navigation is confirmed, and the component instance will be passed to the callback as the argument:\n\njs\nbeforeRouteEnter (to, from, next) {\n  next(vm => {\n    // access to component public instance via `vm`\n  })\n}\n\nNote that beforeRouteEnter is the only guard that supports passing a callback to next. For beforeRouteUpdate and beforeRouteLeave, this is already available, so passing a callback is unnecessary and therefore not supported:\n\njs\nbeforeRouteUpdate (to, from) {\n  // just use `this`\n  this.name = to.params.name\n}\n\nThe leave guard is usually used to prevent the user from accidentally leaving the route with unsaved edits. The navigation can be canceled by returning false.\n\njs\nbeforeRouteLeave (to, from) {\n  const answer = window.confirm('Do you really want to leave? you have unsaved changes!')\n  if (!answer) return false\n}\nUsing the composition API\n​\n\nIf you are writing your component using the composition API and a setup function, you can add update and leave guards through onBeforeRouteUpdate and onBeforeRouteLeave respectively. Please refer to the Composition API section for more details.\n\nThe Full Navigation Resolution Flow\n​\nNavigation triggered.\nCall beforeRouteLeave guards in deactivated components.\nCall global beforeEach guards.\nCall beforeRouteUpdate guards in reused components.\nCall beforeEnter in route configs.\nResolve async route components.\nCall beforeRouteEnter in activated components.\nCall global beforeResolve guards.\nNavigation is confirmed.\nCall global afterEach hooks.\nDOM updates triggered.\nCall callbacks passed to next in beforeRouteEnter guards with instantiated instances."
  },
  {
    "title": "Route Meta Fields | Vue Router",
    "url": "https://router.vuejs.org/guide/advanced/meta",
    "html": "Route Meta Fields\n​\nWatch a free video lesson on Vue School\n\nSometimes, you might want to attach arbitrary information to routes like： transition names, or roles to control who can access the route, etc. This can be achieved through the meta property which accepts an object of properties and can be accessed on the route location and navigation guards. You can define meta properties like this:\n\njs\nconst routes = [\n  {\n    path: '/posts',\n    component: PostsLayout,\n    children: [\n      {\n        path: 'new',\n        component: PostsNew,\n        // only authenticated users can create posts\n        meta: { requiresAuth: true },\n      },\n      {\n        path: ':id',\n        component: PostsDetail,\n        // anybody can read a post\n        meta: { requiresAuth: false },\n      },\n    ],\n  },\n]\n\nSo how do we access this meta field?\n\nFirst, each route object in the routes configuration is called a route record. Route records may be nested. Therefore when a route is matched, it can potentially match more than one route record.\n\nFor example, with the above route config, the URL /posts/new will match both the parent route record (path: '/posts') and the child route record (path: 'new').\n\nAll route records matched by a route are exposed on the $route object (and also route objects in navigation guards) as the $route.matched Array. We could loop through that array to check all meta fields, but Vue Router also provides you a $route.meta that is a non-recursive merge of all meta fields from parent to child. Meaning you can simply write\n\njs\nrouter.beforeEach((to, from) => {\n  // instead of having to check every route record with\n  // to.matched.some(record => record.meta.requiresAuth)\n  if (to.meta.requiresAuth && !auth.isLoggedIn()) {\n    // this route requires auth, check if logged in\n    // if not, redirect to login page.\n    return {\n      path: '/login',\n      // save the location we were at to come back later\n      query: { redirect: to.fullPath },\n    }\n  }\n})\nTypeScript\n​\n\nIt is possible to type the meta field by extending the RouteMeta interface from vue-router:\n\nts\n// This can be directly added to any of your `.ts` files like `router.ts`\n// It can also be added to a `.d.ts` file. Make sure it's included in\n// project's tsconfig.json \"files\"\nimport 'vue-router'\n\n// To ensure it is treated as a module, add at least one `export` statement\nexport {}\n\ndeclare module 'vue-router' {\n  interface RouteMeta {\n    // is optional\n    isAdmin?: boolean\n    // must be declared by every route\n    requiresAuth: boolean\n  }\n}"
  },
  {
    "title": "Different History modes | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/history-mode",
    "html": "Different History modes\n​\nWatch a free video lesson on Vue School\n\nThe history option when creating the router instance allows us to choose among different history modes.\n\nHash Mode\n​\n\nThe hash history mode is created with createWebHashHistory():\n\njs\nimport { createRouter, createWebHashHistory } from 'vue-router'\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    //...\n  ],\n})\n\nIt uses a hash character (#) before the actual URL that is internally passed. Because this section of the URL is never sent to the server, it doesn't require any special treatment on the server level. It does however have a bad impact in SEO. If that's a concern for you, use the HTML5 history mode.\n\nHTML5 Mode\n​\n\nThe HTML5 mode is created with createWebHistory() and is the recommended mode:\n\njs\nimport { createRouter, createWebHistory } from 'vue-router'\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    //...\n  ],\n})\n\nWhen using createWebHistory(), the URL will look \"normal,\" e.g. https://example.com/user/id. Beautiful!\n\nHere comes a problem, though: Since our app is a single page client side app, without a proper server configuration, the users will get a 404 error if they access https://example.com/user/id directly in their browser. Now that's ugly.\n\nNot to worry: To fix the issue, all you need to do is add a simple catch-all fallback route to your server. If the URL doesn't match any static assets, it should serve the same index.html page that your app lives in. Beautiful, again!\n\nMemory mode\n​\n\nThe memory history mode doesn't assume a browser environment and therefore doesn't interact with the URL nor automatically triggers the initial navigation. This makes it perfect for Node environment and SSR. It is created with createMemoryHistory() and requires you to push the initial navigation after calling app.use(router).\n\njs\nimport { createRouter, createMemoryHistory } from 'vue-router'\n\nconst router = createRouter({\n  history: createMemoryHistory(),\n  routes: [\n    //...\n  ],\n})\n\nWhile it's not recommended, you can use this mode inside Browser applications but note there will be no history, meaning you won't be able to go back or forward.\n\nExample Server Configurations\n​\n\nNote: The following examples assume you are serving your app from the root folder. If you deploy to a subfolder, you should use the publicPath option of Vue CLI and the related base property of the router. You also need to adjust the examples below to use the subfolder instead of the root folder (e.g. replacing RewriteBase / with RewriteBase /name-of-your-subfolder/).\n\nApache\n​\n<IfModule mod_negotiation.c>\n  Options -MultiViews\n</IfModule>\n\n<IfModule mod_rewrite.c>\n  RewriteEngine On\n  RewriteBase /\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteRule . /index.html [L]\n</IfModule>\n\nInstead of mod_rewrite, you could also use FallbackResource.\n\nnginx\n​\nnginx\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\nNative Node.js\n​\njs\nconst http = require('http')\nconst fs = require('fs')\nconst httpPort = 80\n\nhttp\n  .createServer((req, res) => {\n    fs.readFile('index.html', 'utf-8', (err, content) => {\n      if (err) {\n        console.log('We cannot open \"index.html\" file.')\n      }\n\n      res.writeHead(200, {\n        'Content-Type': 'text/html; charset=utf-8',\n      })\n\n      res.end(content)\n    })\n  })\n  .listen(httpPort, () => {\n    console.log('Server listening on: http://localhost:%s', httpPort)\n  })\nExpress with Node.js\n​\n\nFor Node.js/Express, consider using connect-history-api-fallback middleware.\n\nInternet Information Services (IIS)\n​\nInstall IIS UrlRewrite\nCreate a web.config file in the root directory of your site with the following:\nxml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration>\n  <system.webServer>\n    <rewrite>\n      <rules>\n        <rule name=\"Handle History Mode and custom 404/500\" stopProcessing=\"true\">\n          <match url=\"(.*)\" />\n          <conditions logicalGrouping=\"MatchAll\">\n            <add input=\"{REQUEST_FILENAME}\" matchType=\"IsFile\" negate=\"true\" />\n            <add input=\"{REQUEST_FILENAME}\" matchType=\"IsDirectory\" negate=\"true\" />\n          </conditions>\n          <action type=\"Rewrite\" url=\"/\" />\n        </rule>\n      </rules>\n    </rewrite>\n  </system.webServer>\n</configuration>\nCaddy v2\n​\ntry_files {path} /\nCaddy v1\n​\nrewrite {\n    regexp .*\n    to {path} /\n}\nFirebase hosting\n​\n\nAdd this to your firebase.json:\n\njson\n{\n  \"hosting\": {\n    \"public\": \"dist\",\n    \"rewrites\": [\n      {\n        \"source\": \"**\",\n        \"destination\": \"/index.html\"\n      }\n    ]\n  }\n}\nNetlify\n​\n\nCreate a _redirects file that is included with your deployed files:\n\n/* /index.html 200\n\nIn vue-cli, nuxt, and vite projects, this file usually goes under a folder named static or public.\n\nYou can read more about the syntax on Netlify documentation. You can also create a netlify.toml to combine redirections with other Netlify features.\n\nVercel\n​\n\nCreate a vercel.json file under the root directory of your project with the following:\n\njson\n{\n  \"rewrites\": [{ \"source\": \"/:path*\", \"destination\": \"/index.html\" }]\n}\nCaveat\n​\n\nThere is a caveat to this: Your server will no longer report 404 errors as all not-found paths now serve up your index.html file. To get around the issue, you should implement a catch-all route within your Vue app to show a 404 page:\n\njs\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [{ path: '/:pathMatch(.*)', component: NotFoundComponent }],\n})\n\nAlternatively, if you are using a Node.js server, you can implement the fallback by using the router on the server side to match the incoming URL and respond with 404 if no route is matched. Check out the Vue server side rendering documentation for more information."
  },
  {
    "title": "Passing Props to Route Components | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/passing-props",
    "html": "Passing Props to Route Components\n​\nWatch a free video lesson on Vue School\n\nUsing $route in your component creates a tight coupling with the route which limits the flexibility of the component as it can only be used on certain URLs. While this is not necessarily a bad thing, we can decouple this behavior with a props option:\n\nWe can replace\n\njs\nconst User = {\n  template: '<div>User {{ $route.params.id }}</div>'\n}\nconst routes = [{ path: '/user/:id', component: User }]\n\nwith\n\njs\nconst User = {\n  // make sure to add a prop named exactly like the route param\n  props: ['id'],\n  template: '<div>User {{ id }}</div>'\n}\nconst routes = [{ path: '/user/:id', component: User, props: true }]\n\nThis allows you to use the component anywhere, which makes the component easier to reuse and test.\n\nBoolean mode\n​\n\nWhen props is set to true, the route.params will be set as the component props.\n\nNamed views\n​\n\nFor routes with named views, you have to define the props option for each named view:\n\njs\nconst routes = [\n  {\n    path: '/user/:id',\n    components: { default: User, sidebar: Sidebar },\n    props: { default: true, sidebar: false }\n  }\n]\nObject mode\n​\n\nWhen props is an object, this will be set as the component props as-is. Useful for when the props are static.\n\njs\nconst routes = [\n  {\n    path: '/promotion/from-newsletter',\n    component: Promotion,\n    props: { newsletterPopup: false }\n  }\n]\nFunction mode\n​\n\nYou can create a function that returns props. This allows you to cast parameters into other types, combine static values with route-based values, etc.\n\njs\nconst routes = [\n  {\n    path: '/search',\n    component: SearchUser,\n    props: route => ({ query: route.query.q })\n  }\n]\n\nThe URL /search?q=vue would pass {query: 'vue'} as props to the SearchUser component.\n\nTry to keep the props function stateless, as it's only evaluated on route changes. Use a wrapper component if you need state to define the props, that way Vue can react to state changes.\n\nVia RouterView\n​\n\nYou can also pass any props via the <RouterView> slot:\n\ntemplate\n<RouterView v-slot=\"{ Component }\">\n  <component\n    :is=\"Component\"\n    view-prop=\"value\"\n   />\n</RouterView>\n\nWARNING\n\nIn this case, all view components will receive view-prop. This is usually not a good idea as it means that all of the view components have declared a view-prop prop, which is not necessarily true. If possible, use any of the options above."
  },
  {
    "title": "Redirect and Alias | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/redirect-and-alias",
    "html": "Redirect and Alias\n​\nWatch a free video lesson on Vue School\nRedirect\n​\n\nRedirecting is also done in the routes configuration. To redirect from /home to /:\n\njs\nconst routes = [{ path: '/home', redirect: '/' }]\n\nThe redirect can also be targeting a named route:\n\njs\nconst routes = [{ path: '/home', redirect: { name: 'homepage' } }]\n\nOr even use a function for dynamic redirecting:\n\njs\nconst routes = [\n  {\n    // /search/screens -> /search?q=screens\n    path: '/search/:searchText',\n    redirect: to => {\n      // the function receives the target route as the argument\n      // we return a redirect path/location here.\n      return { path: '/search', query: { q: to.params.searchText } }\n    },\n  },\n  {\n    path: '/search',\n    // ...\n  },\n]\n\nNote that Navigation Guards are not applied on the route that redirects, only on its target. e.g. In the above example, adding a beforeEnter guard to the /home route would not have any effect.\n\nWhen writing a redirect, you can omit the component option because it is never directly reached so there is no component to render. The only exception are nested routes: if a route record has children and a redirect property, it should also have a component property.\n\nRelative redirecting\n​\n\nIt's also possible to redirect to a relative location:\n\njs\nconst routes = [\n  {\n    // will always redirect /users/123/posts to /users/123/profile\n    path: '/users/:id/posts',\n    redirect: to => {\n      // the function receives the target route as the argument\n      // a relative location doesn't start with `/`\n      // or { path: 'profile'}\n      return 'profile'\n    },\n  },\n]\nAlias\n​\n\nA redirect means when the user visits /home, the URL will be replaced by /, and then matched as /. But what is an alias?\n\nAn alias of / as /home means when the user visits /home, the URL remains /home, but it will be matched as if the user is visiting /.\n\nThe above can be expressed in the route configuration as:\n\njs\nconst routes = [{ path: '/', component: Homepage, alias: '/home' }]\n\nAn alias gives you the freedom to map a UI structure to an arbitrary URL, instead of being constrained by the configuration's nesting structure. Make the alias start with a / to make the path absolute in nested routes. You can even combine both and provide multiple aliases with an array:\n\njs\nconst routes = [\n  {\n    path: '/users',\n    component: UsersLayout,\n    children: [\n      // this will render the UserList for these 3 URLs\n      // - /users\n      // - /users/list\n      // - /people\n      { path: '', component: UserList, alias: ['/people', 'list'] },\n    ],\n  },\n]\n\nIf your route has parameters, make sure to include them in any absolute alias:\n\njs\nconst routes = [\n  {\n    path: '/users/:id',\n    component: UsersByIdLayout,\n    children: [\n      // this will render the UserDetails for these 3 URLs\n      // - /users/24\n      // - /users/24/profile\n      // - /24\n      { path: 'profile', component: UserDetails, alias: ['/:id', ''] },\n    ],\n  },\n]\n\nNote about SEO: when using aliases, make sure to define canonical links."
  },
  {
    "title": "Named Views | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/named-views",
    "html": "Named Views\n​\nWatch a free video lesson on Vue School\n\nSometimes you need to display multiple views at the same time instead of nesting them, e.g. creating a layout with a sidebar view and a main view. This is where named views come in handy. Instead of having one single outlet in your view, you can have multiple and give each of them a name. A router-view without a name will be given default as its name.\n\ntemplate\n<router-view class=\"view left-sidebar\" name=\"LeftSidebar\"></router-view>\n<router-view class=\"view main-content\"></router-view>\n<router-view class=\"view right-sidebar\" name=\"RightSidebar\"></router-view>\n\nA view is rendered by using a component, therefore multiple views require multiple components for the same route. Make sure to use the components (with an s) option:\n\njs\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    {\n      path: '/',\n      components: {\n        default: Home,\n        // short for LeftSidebar: LeftSidebar\n        LeftSidebar,\n        // they match the `name` attribute on `<router-view>`\n        RightSidebar,\n      },\n    },\n  ],\n})\n\nA working demo of this example can be found here.\n\nNested Named Views\n​\n\nIt is possible to create complex layouts using named views with nested views. When doing so, you will also need to give nested router-view a name. Let's take a Settings panel example:\n\n/settings/emails                                       /settings/profile\n+-----------------------------------+                  +------------------------------+\n| UserSettings                      |                  | UserSettings                 |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n| | Nav | UserEmailsSubscriptions | |  +------------>  | | Nav | UserProfile        | |\n| |     +-------------------------+ |                  | |     +--------------------+ |\n| |     |                         | |                  | |     | UserProfilePreview | |\n| +-----+-------------------------+ |                  | +-----+--------------------+ |\n+-----------------------------------+                  +------------------------------+\nNav is just a regular component\nUserSettings is the parent view component\nUserEmailsSubscriptions, UserProfile, UserProfilePreview are nested view components\n\nNote: Let's forget about how the HTML/CSS should look like to represent such layout and focus on the components used.\n\nThe <template> section for UserSettings component in the above layout would look something like this:\n\ntemplate\n<!-- UserSettings.vue -->\n<div>\n  <h1>User Settings</h1>\n  <NavBar />\n  <router-view />\n  <router-view name=\"helper\" />\n</div>\n\nThen you can achieve the layout above with this route configuration:\n\njs\n{\n  path: '/settings',\n  // You could also have named views at the top\n  component: UserSettings,\n  children: [{\n    path: 'emails',\n    component: UserEmailsSubscriptions\n  }, {\n    path: 'profile',\n    components: {\n      default: UserProfile,\n      helper: UserProfilePreview\n    }\n  }]\n}\n\nA working demo of this example can be found here."
  },
  {
    "title": "Named Routes | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/named-routes",
    "html": "Named Routes\n​\nWatch a free video lesson on Vue School\n\nAlongside the path, you can provide a name to any route. This has the following advantages:\n\nNo hardcoded URLs\nAutomatic encoding/decoding of params\nPrevents you from having a typo in the url\nBypassing path ranking (e.g. to display a )\njs\nconst routes = [\n  {\n    path: '/user/:username',\n    name: 'user',\n    component: User\n  }\n]\n\nTo link to a named route, you can pass an object to the router-link component's to prop:\n\ntemplate\n<router-link :to=\"{ name: 'user', params: { username: 'erina' }}\">\n  User\n</router-link>\n\nThis is the exact same object used programmatically with router.push():\n\njs\nrouter.push({ name: 'user', params: { username: 'erina' } })\n\nIn both cases, the router will navigate to the path /user/erina.\n\nFull example here.\n\nEach name must be unique across all routes. If you add the same name to multiple routes, the router will only keep the last one. You can read more about this in the Dynamic Routing section."
  },
  {
    "title": "Programmatic Navigation | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/navigation",
    "html": "Programmatic Navigation\n​\nWatch a free video lesson on Vue School\n\nAside from using <router-link> to create anchor tags for declarative navigation, we can do this programmatically using the router's instance methods.\n\nNavigate to a different location\n​\n\nNote: Inside of a Vue instance, you have access to the router instance as $router. You can therefore call this.$router.push.\n\nTo navigate to a different URL, use router.push. This method pushes a new entry into the history stack, so when the user clicks the browser back button they will be taken to the previous URL.\n\nThis is the method called internally when you click a <router-link>, so clicking <router-link :to=\"...\"> is the equivalent of calling router.push(...).\n\nDeclarative\tProgrammatic\n<router-link :to=\"...\">\trouter.push(...)\n\nThe argument can be a string path, or a location descriptor object. Examples:\n\njs\n// literal string path\nrouter.push('/users/eduardo')\n\n// object with path\nrouter.push({ path: '/users/eduardo' })\n\n// named route with params to let the router build the url\nrouter.push({ name: 'user', params: { username: 'eduardo' } })\n\n// with query, resulting in /register?plan=private\nrouter.push({ path: '/register', query: { plan: 'private' } })\n\n// with hash, resulting in /about#team\nrouter.push({ path: '/about', hash: '#team' })\n\nNote: params are ignored if a path is provided, which is not the case for query, as shown in the example above. Instead, you need to provide the name of the route or manually specify the whole path with any parameter:\n\njs\nconst username = 'eduardo'\n// we can manually build the url but we will have to handle the encoding ourselves\nrouter.push(`/user/${username}`) // -> /user/eduardo\n// same as\nrouter.push({ path: `/user/${username}` }) // -> /user/eduardo\n// if possible use `name` and `params` to benefit from automatic URL encoding\nrouter.push({ name: 'user', params: { username } }) // -> /user/eduardo\n// `params` cannot be used alongside `path`\nrouter.push({ path: '/user', params: { username } }) // -> /user\n\nWhen specifying params, make sure to either provide a string or number (or an array of these for repeatable params). Any other type (like objects, booleans, etc) will be automatically stringified. For optional params, you can provide an empty string (\"\") or null as the value to remove it.\n\nSince the prop to accepts the same kind of object as router.push, the exact same rules apply to both of them.\n\nrouter.push and all the other navigation methods return a Promise that allows us to wait till the navigation is finished and to know if it succeeded or failed. We will talk more about that in Navigation Handling.\n\nReplace current location\n​\n\nIt acts like router.push, the only difference is that it navigates without pushing a new history entry, as its name suggests - it replaces the current entry.\n\nDeclarative\tProgrammatic\n<router-link :to=\"...\" replace>\trouter.replace(...)\n\nIt's also possible to directly add a property replace: true to the to argument that is passed to router.push:\n\njs\nrouter.push({ path: '/home', replace: true })\n// equivalent to\nrouter.replace({ path: '/home' })\nTraverse history\n​\nWatch a free video lesson on Vue School\n\nThis method takes a single integer as parameter that indicates by how many steps to go forward or go backward in the history stack, similar to window.history.go(n).\n\nExamples\n\njs\n// go forward by one record, the same as router.forward()\nrouter.go(1)\n\n// go back by one record, the same as router.back()\nrouter.go(-1)\n\n// go forward by 3 records\nrouter.go(3)\n\n// fails silently if there aren't that many records\nrouter.go(-100)\nrouter.go(100)\nHistory Manipulation\n​\n\nYou may have noticed that router.push, router.replace and router.go are counterparts of window.history.pushState, window.history.replaceState and window.history.go, and they do imitate the window.history APIs.\n\nTherefore, if you are already familiar with Browser History APIs, manipulating history will feel familiar when using Vue Router.\n\nIt is worth mentioning that Vue Router navigation methods (push, replace, go) work consistently no matter the history option passed when creating the router instance."
  },
  {
    "title": "Nested Routes | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/nested-routes",
    "html": "Nested Routes\n​\nWatch a free video lesson on Vue School\n\nSome applications' UIs are composed of components that are nested multiple levels deep. In this case, it is very common that the segments of a URL correspond to a certain structure of nested components, for example:\n\n/user/johnny/profile                     /user/johnny/posts\n+------------------+                  +-----------------+\n| User             |                  | User            |\n| +--------------+ |                  | +-------------+ |\n| | Profile      | |  +------------>  | | Posts       | |\n| |              | |                  | |             | |\n| +--------------+ |                  | +-------------+ |\n+------------------+                  +-----------------+\n\nWith Vue Router, you can express this relationship using nested route configurations.\n\nGiven the app we created in the last chapter:\n\nhtml\n<div id=\"app\">\n  <router-view></router-view>\n</div>\njs\nconst User = {\n  template: '<div>User {{ $route.params.id }}</div>',\n}\n\n// these are passed to `createRouter`\nconst routes = [{ path: '/user/:id', component: User }]\n\nThe <router-view> here is a top-level router-view. It renders the component matched by a top level route. Similarly, a rendered component can also contain its own, nested <router-view>. For example, if we add one inside the User component's template:\n\njs\nconst User = {\n  template: `\n    <div class=\"user\">\n      <h2>User {{ $route.params.id }}</h2>\n      <router-view></router-view>\n    </div>\n  `,\n}\n\nTo render components into this nested router-view, we need to use the children option in any of the routes:\n\njs\nconst routes = [\n  {\n    path: '/user/:id',\n    component: User,\n    children: [\n      {\n        // UserProfile will be rendered inside User's <router-view>\n        // when /user/:id/profile is matched\n        path: 'profile',\n        component: UserProfile,\n      },\n      {\n        // UserPosts will be rendered inside User's <router-view>\n        // when /user/:id/posts is matched\n        path: 'posts',\n        component: UserPosts,\n      },\n    ],\n  },\n]\n\nNote that nested paths that start with / will be treated as root paths. This allows you to leverage the component nesting without having to use a nested URL.\n\nAs you can see, the children option is just another Array of routes like routes itself. Therefore, you can keep nesting views as much as you need.\n\nAt this point, with the above configuration, when you visit /user/eduardo, nothing will be rendered inside User's router-view, because no nested route is matched. Maybe you do want to render something there. In such case you can provide an empty nested path:\n\njs\nconst routes = [\n  {\n    path: '/user/:id',\n    component: User,\n    children: [\n      // UserHome will be rendered inside User's <router-view>\n      // when /user/:id is matched\n      { path: '', component: UserHome },\n\n      // ...other sub routes\n    ],\n  },\n]\n\nA working demo of this example can be found here.\n\nNested Named Routes\n​\n\nWhen dealing with Named Routes, you usually name the children routes:\n\njs\nconst routes = [\n  {\n    path: '/user/:id',\n    component: User,\n    // notice how only the child route has a name\n    children: [{ path: '', name: 'user', component: UserHome }],\n  },\n]\n\nThis will ensure navigating to /user/:id will always display the nested route.\n\nIn some scenarios, you may want to navigate to a named route without navigating to the nested route. For example, if you want to navigate to /user/:id without displaying the nested route. In that case, you can also name the parent route but note that reloading the page will always display the nested child as it's considered a navigation to the path /users/:id instead of the named route:\n\njs\nconst routes = [\n  {\n    path: '/user/:id',\n    name: 'user-parent',\n    component: User,\n    children: [{ path: '', name: 'user', component: UserHome }],\n  },\n]"
  },
  {
    "title": "Routes' Matching Syntax | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/route-matching-syntax",
    "html": "Routes' Matching Syntax\n​\nWatch a free video lesson on Vue School\n\nMost applications will use static routes like /about and dynamic routes like /users/:userId like we just saw in Dynamic Route Matching, but Vue Router has much more to offer!\n\nTIP\n\nFor the sake of simplicity, all route records are omitting the component property to focus on the path value.\n\nCustom regex in params\n​\n\nWhen defining a param like :userId, we internally use the following regex ([^/]+) (at least one character that isn't a slash /) to extract params from URLs. This works well unless you need to differentiate two routes based on the param content. Imagine two routes /:orderId and /:productName, both would match the exact same URLs, so we need a way to differentiate them. The easiest way would be to add a static section to the path that differentiates them:\n\njs\nconst routes = [\n  // matches /o/3549\n  { path: '/o/:orderId' },\n  // matches /p/books\n  { path: '/p/:productName' },\n]\n\nBut in some scenarios we don't want to add that static section /o/p. However, orderId is always a number while productName can be anything, so we can specify a custom regex for a param in parentheses:\n\njs\nconst routes = [\n  // /:orderId -> matches only numbers\n  { path: '/:orderId(\\\\d+)' },\n  // /:productName -> matches anything else\n  { path: '/:productName' },\n]\n\nNow, going to /25 will match /:orderId while going to anything else will match /:productName. The order of the routes array doesn't even matter!\n\nTIP\n\nMake sure to escape backslashes (\\) like we did with \\d (becomes \\\\d) to actually pass the backslash character in a string in JavaScript.\n\nRepeatable params\n​\n\nIf you need to match routes with multiple sections like /first/second/third, you should mark a param as repeatable with * (0 or more) and + (1 or more):\n\njs\nconst routes = [\n  // /:chapters -> matches /one, /one/two, /one/two/three, etc\n  { path: '/:chapters+' },\n  // /:chapters -> matches /, /one, /one/two, /one/two/three, etc\n  { path: '/:chapters*' },\n]\n\nThis will give you an array of params instead of a string and will also require you to pass an array when using named routes:\n\njs\n// given { path: '/:chapters*', name: 'chapters' },\nrouter.resolve({ name: 'chapters', params: { chapters: [] } }).href\n// produces /\nrouter.resolve({ name: 'chapters', params: { chapters: ['a', 'b'] } }).href\n// produces /a/b\n\n// given { path: '/:chapters+', name: 'chapters' },\nrouter.resolve({ name: 'chapters', params: { chapters: [] } }).href\n// throws an Error because `chapters` is empty\n\nThese can also be combined with a custom regex by adding them after the closing parentheses:\n\njs\nconst routes = [\n  // only match numbers\n  // matches /1, /1/2, etc\n  { path: '/:chapters(\\\\d+)+' },\n  // matches /, /1, /1/2, etc\n  { path: '/:chapters(\\\\d+)*' },\n]\nSensitive and strict route options\n​\n\nBy default, all routes are case-insensitive and match routes with or without a trailing slash. e.g. a route /users matches /users, /users/, and even /Users/. This behavior can be configured with the strict and sensitive options, they can be set both at a router and route level:\n\njs\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    // will match /users/posva but not:\n    // - /users/posva/ because of strict: true\n    // - /Users/posva because of sensitive: true\n    { path: '/users/:id', sensitive: true },\n    // will match /users, /Users, and /users/42 but not /users/ or /users/42/\n    { path: '/users/:id?' },\n  ],\n  strict: true, // applies to all routes\n})\nOptional parameters\n​\n\nYou can also mark a parameter as optional by using the ? modifier (0 or 1):\n\njs\nconst routes = [\n  // will match /users and /users/posva\n  { path: '/users/:userId?' },\n  // will match /users and /users/42\n  { path: '/users/:userId(\\\\d+)?' },\n]\n\nNote that * technically also marks a parameter as optional but ? parameters cannot be repeated.\n\nDebugging\n​\n\nIf you need to dig how your routes are transformed into a regex to understand why a route isn't being matched or, to report a bug, you can use the path ranker tool. It supports sharing your routes through the URL."
  },
  {
    "title": "Dynamic Route Matching with Params | Vue Router",
    "url": "https://router.vuejs.org/guide/essentials/dynamic-matching",
    "html": "Dynamic Route Matching with Params\n​\nWatch a free video lesson on Vue School\n\nVery often we will need to map routes with the given pattern to the same component. For example, we may have a User component which should be rendered for all users but with different user IDs. In Vue Router we can use a dynamic segment in the path to achieve that, we call that a param:\n\njs\nconst User = {\n  template: '<div>User</div>',\n}\n\n// these are passed to `createRouter`\nconst routes = [\n  // dynamic segments start with a colon\n  { path: '/users/:id', component: User },\n]\n\nNow URLs like /users/johnny and /users/jolyne will both map to the same route.\n\nA param is denoted by a colon :. When a route is matched, the value of its params will be exposed as this.$route.params in every component. Therefore, we can render the current user ID by updating User's template to this:\n\njs\nconst User = {\n  template: '<div>User {{ $route.params.id }}</div>',\n}\n\nYou can have multiple params in the same route, and they will map to corresponding fields on $route.params. Examples:\n\npattern\tmatched path\t$route.params\n/users/:username\t/users/eduardo\t{ username: 'eduardo' }\n/users/:username/posts/:postId\t/users/eduardo/posts/123\t{ username: 'eduardo', postId: '123' }\n\nIn addition to $route.params, the $route object also exposes other useful information such as $route.query (if there is a query in the URL), $route.hash, etc. You can check out the full details in the API Reference.\n\nA working demo of this example can be found here.\n\nReacting to Params Changes\n​\nWatch a free video lesson on Vue School\n\nOne thing to note when using routes with params is that when the user navigates from /users/johnny to /users/jolyne, the same component instance will be reused. Since both routes render the same component, this is more efficient than destroying the old instance and then creating a new one. However, this also means that the lifecycle hooks of the component will not be called.\n\nTo react to params changes in the same component, you can simply watch anything on the $route object, in this scenario, the $route.params:\n\njs\nconst User = {\n  template: '...',\n  created() {\n    this.$watch(\n      () => this.$route.params,\n      (toParams, previousParams) => {\n        // react to route changes...\n      }\n    )\n  },\n}\n\nOr, use the beforeRouteUpdate navigation guard, which also allows to cancel the navigation:\n\njs\nconst User = {\n  template: '...',\n  async beforeRouteUpdate(to, from) {\n    // react to route changes...\n    this.userData = await fetchUser(to.params.id)\n  },\n}\nCatch all / 404 Not found Route\n​\nWatch a free video lesson on Vue School\n\nRegular params will only match characters in between url fragments, separated by /. If we want to match anything, we can use a custom param regexp by adding the regexp inside parentheses right after the param:\n\njs\nconst routes = [\n  // will match everything and put it under `$route.params.pathMatch`\n  { path: '/:pathMatch(.*)*', name: 'NotFound', component: NotFound },\n  // will match anything starting with `/user-` and put it under `$route.params.afterUser`\n  { path: '/user-:afterUser(.*)', component: UserGeneric },\n]\n\nIn this specific scenario, we are using a custom regexp between parentheses and marking the pathMatch param as optionally repeatable. This allows us to directly navigate to the route if we need to by splitting the path into an array:\n\njs\nthis.$router.push({\n  name: 'NotFound',\n  // preserve current path and remove the first char to avoid the target URL starting with `//`\n  params: { pathMatch: this.$route.path.substring(1).split('/') },\n  // preserve existing query and hash if any\n  query: this.$route.query,\n  hash: this.$route.hash,\n})\n\nSee more in the repeated params section.\n\nIf you are using History mode, make sure to follow the instructions to correctly configure your server as well.\n\nAdvanced Matching Patterns\n​\n\nVue Router uses its own path matching syntax, inspired by the one used by express, so it supports many advanced matching patterns such as optional params, zero or more / one or more requirements, and even custom regex patterns. Please check the Advanced Matching documentation to explore them."
  },
  {
    "title": "Getting Started | Vue Router",
    "url": "https://router.vuejs.org/guide/",
    "html": "Getting Started\n​\nWatch a Free Vue Router Video Course\n\nCreating a Single-page Application with Vue + Vue Router feels natural: with Vue.js, we are already composing our application with components. When adding Vue Router to the mix, all we need to do is map our components to the routes and let Vue Router know where to render them. Here's a basic example:\n\nHTML\n​\nhtml\n<script src=\"https://unpkg.com/vue@3\"></script>\n<script src=\"https://unpkg.com/vue-router@4\"></script>\n\n<div id=\"app\">\n  <h1>Hello App!</h1>\n  <p>\n    <!-- use the router-link component for navigation. -->\n    <!-- specify the link by passing the `to` prop. -->\n    <!-- `<router-link>` will render an `<a>` tag with the correct `href` attribute -->\n    <router-link to=\"/\">Go to Home</router-link>\n    <router-link to=\"/about\">Go to About</router-link>\n  </p>\n  <!-- route outlet -->\n  <!-- component matched by the route will render here -->\n  <router-view></router-view>\n</div>\nrouter-link\n​\n\nNote how instead of using regular a tags, we use a custom component router-link to create links. This allows Vue Router to change the URL without reloading the page, handle URL generation as well as its encoding. We will see later how to benefit from these features.\n\nrouter-view\n​\n\nrouter-view will display the component that corresponds to the URL. You can put it anywhere to adapt it to your layout.\n\nGet the Vue Router Cheat Sheet from Vue Mastery\nJavaScript\n​\njs\n// 1. Define route components.\n// These can be imported from other files\nconst Home = { template: '<div>Home</div>' }\nconst About = { template: '<div>About</div>' }\n\n// 2. Define some routes\n// Each route should map to a component.\n// We'll talk about nested routes later.\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n]\n\n// 3. Create the router instance and pass the `routes` option\n// You can pass in additional options here, but let's\n// keep it simple for now.\nconst router = VueRouter.createRouter({\n  // 4. Provide the history implementation to use. We are using the hash history for simplicity here.\n  history: VueRouter.createWebHashHistory(),\n  routes, // short for `routes: routes`\n})\n\n// 5. Create and mount the root instance.\nconst app = Vue.createApp({})\n// Make sure to _use_ the router instance to make the\n// whole app router-aware.\napp.use(router)\n\napp.mount('#app')\n\n// Now the app has started!\n\nBy calling app.use(router), we are triggering the initial navigation and giving access to this.$router as well as the current route as this.$route inside of any component:\n\njs\n// Home.vue\nexport default {\n  computed: {\n    username() {\n      // We will see what `params` is shortly\n      return this.$route.params.username\n    },\n  },\n  methods: {\n    goToDashboard() {\n      if (isAuthenticated) {\n        this.$router.push('/dashboard')\n      } else {\n        this.$router.push('/login')\n      }\n    },\n  },\n}\n\nTo access the router or the route inside the setup function, call the useRouter or useRoute functions. We will learn more about this in the Composition API\n\nThroughout the docs, we will often use the router instance. Keep in mind that this.$router is exactly the same as directly using the router instance created through createRouter. The reason we use this.$router is because we don't want to import the router in every single component that needs to manipulate routing."
  },
  {
    "title": "Interface: _RouteRecordBase | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteRecordBase.html#VPContent",
    "html": "API Documentation / _RouteRecordBase\n\nInterface: _RouteRecordBase\n​\n\nInternal type for common properties among all kind of RouteRecordRaw.\n\nHierarchy\n​\n\nPathParserOptions\n\n↳ _RouteRecordBase\n\n↳↳ RouteRecordSingleView\n\n↳↳ RouteRecordSingleViewWithChildren\n\n↳↳ RouteRecordMultipleViews\n\n↳↳ RouteRecordMultipleViewsWithChildren\n\n↳↳ RouteRecordRedirect\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nchildren\n​\n\n• Optional children: RouteRecordRaw[]\n\nArray of nested routes.\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\nPathParserOptions.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nprops\n​\n\n• Optional props: _RouteRecordProps | Record<string, _RouteRecordProps>\n\nAllow passing down params as props to the component rendered by router-view.\n\nredirect\n​\n\n• Optional redirect: RouteRecordRedirectOption\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\nPathParserOptions.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\nPathParserOptions.strict"
  },
  {
    "title": "Interface: RouterLinkProps | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouterLinkProps.html#VPContent",
    "html": "API Documentation / RouterLinkProps\n\nInterface: RouterLinkProps\n​\nHierarchy\n​\n\nRouterLinkOptions\n\n↳ RouterLinkProps\n\nProperties\n​\nactiveClass\n​\n\n• Optional activeClass: string\n\nClass to apply when the link is active\n\nariaCurrentValue\n​\n\n• Optional ariaCurrentValue: \"location\" | \"time\" | \"page\" | \"step\" | \"date\" | \"true\" | \"false\"\n\nValue passed to the attribute aria-current when the link is exact active.\n\nDefault Value\n\n'page'\n\ncustom\n​\n\n• Optional custom: boolean\n\nWhether RouterLink should not wrap its content in an a tag. Useful when using v-slot to create a custom RouterLink\n\nexactActiveClass\n​\n\n• Optional exactActiveClass: string\n\nClass to apply when the link is exact active\n\nreplace\n​\n\n• Optional replace: boolean\n\nCalls router.replace instead of router.push.\n\nInherited from\n​\n\nRouterLinkOptions.replace\n\nto\n​\n\n• to: RouteLocationRaw\n\nRoute Location the link should navigate to when clicked on.\n\nInherited from\n​\n\nRouterLinkOptions.to"
  },
  {
    "title": "Interface: RouteRecordMultipleViews | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerecordmultipleviews#VPContent",
    "html": "API Documentation / RouteRecordMultipleViews\n\nInterface: RouteRecordMultipleViews\n​\n\nRoute Record defining multiple named components with the components option.\n\nHierarchy\n​\n\n_RouteRecordBase\n\n↳ RouteRecordMultipleViews\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nInherited from\n​\n\n_RouteRecordBase.alias\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nInherited from\n​\n\n_RouteRecordBase.beforeEnter\n\nchildren\n​\n\n• Optional children: undefined\n\nArray of nested routes.\n\nOverrides\n​\n\n_RouteRecordBase.children\n\ncomponent\n​\n\n• Optional component: undefined\n\ncomponents\n​\n\n• components: Record<string, RawRouteComponent>\n\nComponents to display when the URL matches this route. Allow using named views.\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\n_RouteRecordBase.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nInherited from\n​\n\n_RouteRecordBase.meta\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\nInherited from\n​\n\n_RouteRecordBase.name\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\n​\n\n_RouteRecordBase.path\n\nprops\n​\n\n• Optional props: boolean | Record<string, _RouteRecordProps>\n\nAllow passing down params as props to the component rendered by router-view. Should be an object with the same keys as components or a boolean to be applied to every component.\n\nOverrides\n​\n\n_RouteRecordBase.props\n\nredirect\n​\n\n• Optional redirect: undefined\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nOverrides\n​\n\n_RouteRecordBase.redirect\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.strict"
  },
  {
    "title": "Interface: RouteMeta | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteMeta.html#VPContent",
    "html": "API Documentation / RouteMeta\n\nInterface: RouteMeta\n​\n\nInterface to type meta fields in route records.\n\nExample\n\nts\n// typings.d.ts or router.ts\nimport 'vue-router';\n\ndeclare module 'vue-router' {\n  interface RouteMeta {\n    requiresAuth?: boolean\n  }\n }\nHierarchy\n​\n\nRecord<string | number | symbol, unknown>\n\n↳ RouteMeta"
  },
  {
    "title": "Interface: RouteLocationNormalizedLoaded | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routelocationnormalizedloaded#VPContent",
    "html": "API Documentation / RouteLocationNormalizedLoaded\n\nInterface: RouteLocationNormalizedLoaded\n​\n\nRouteLocationRaw with\n\nHierarchy\n​\n\n_RouteLocationBase\n\n↳ RouteLocationNormalizedLoaded\n\nProperties\n​\nfullPath\n​\n\n• fullPath: string\n\nThe whole location including the search and hash. This string is percentage encoded.\n\nInherited from\n​\n\n_RouteLocationBase.fullPath\n\nhash\n​\n\n• hash: string\n\nHash of the current location. If present, starts with a #.\n\nInherited from\n​\n\n_RouteLocationBase.hash\n\nmatched\n​\n\n• matched: RouteLocationMatched[]\n\nArray of RouteLocationMatched containing only plain components (any lazy-loaded components have been loaded and were replaced inside the components object) so it can be directly used to display routes. It cannot contain redirect records either\n\nmeta\n​\n\n• meta: RouteMeta\n\nMerged meta properties from all the matched route records.\n\nInherited from\n​\n\n_RouteLocationBase.meta\n\nname\n​\n\n• name: undefined | null | RouteRecordName\n\nName of the matched record\n\nInherited from\n​\n\n_RouteLocationBase.name\n\nparams\n​\n\n• params: RouteParams\n\nObject of decoded params extracted from the path.\n\nInherited from\n​\n\n_RouteLocationBase.params\n\npath\n​\n\n• path: string\n\nPercentage encoded pathname section of the URL.\n\nInherited from\n​\n\n_RouteLocationBase.path\n\nquery\n​\n\n• query: LocationQuery\n\nObject representation of the search property of the current location.\n\nInherited from\n​\n\n_RouteLocationBase.query\n\nredirectedFrom\n​\n\n• redirectedFrom: undefined | RouteLocation\n\nContains the location we were initially trying to access before ending up on the current location.\n\nInherited from\n​\n\n_RouteLocationBase.redirectedFrom"
  },
  {
    "title": "Interface: RouteLocationNormalized | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routelocationnormalized#VPContent",
    "html": "API Documentation / RouteLocationNormalized\n\nInterface: RouteLocationNormalized\n​\n\nSimilar to RouteLocation but its RouteLocationNormalized.matched cannot contain redirect records\n\nHierarchy\n​\n\n_RouteLocationBase\n\n↳ RouteLocationNormalized\n\nProperties\n​\nfullPath\n​\n\n• fullPath: string\n\nThe whole location including the search and hash. This string is percentage encoded.\n\nInherited from\n​\n\n_RouteLocationBase.fullPath\n\nhash\n​\n\n• hash: string\n\nHash of the current location. If present, starts with a #.\n\nInherited from\n​\n\n_RouteLocationBase.hash\n\nmatched\n​\n\n• matched: RouteRecordNormalized[]\n\nArray of RouteRecordNormalized\n\nmeta\n​\n\n• meta: RouteMeta\n\nMerged meta properties from all the matched route records.\n\nInherited from\n​\n\n_RouteLocationBase.meta\n\nname\n​\n\n• name: undefined | null | RouteRecordName\n\nName of the matched record\n\nInherited from\n​\n\n_RouteLocationBase.name\n\nparams\n​\n\n• params: RouteParams\n\nObject of decoded params extracted from the path.\n\nInherited from\n​\n\n_RouteLocationBase.params\n\npath\n​\n\n• path: string\n\nPercentage encoded pathname section of the URL.\n\nInherited from\n​\n\n_RouteLocationBase.path\n\nquery\n​\n\n• query: LocationQuery\n\nObject representation of the search property of the current location.\n\nInherited from\n​\n\n_RouteLocationBase.query\n\nredirectedFrom\n​\n\n• redirectedFrom: undefined | RouteLocation\n\nContains the location we were initially trying to access before ending up on the current location.\n\nInherited from\n​\n\n_RouteLocationBase.redirectedFrom"
  },
  {
    "title": "Interface: _RouteRecordBase | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteRecordBase.html",
    "html": "API Documentation / _RouteRecordBase\n\nInterface: _RouteRecordBase\n​\n\nInternal type for common properties among all kind of RouteRecordRaw.\n\nHierarchy\n​\n\nPathParserOptions\n\n↳ _RouteRecordBase\n\n↳↳ RouteRecordSingleView\n\n↳↳ RouteRecordSingleViewWithChildren\n\n↳↳ RouteRecordMultipleViews\n\n↳↳ RouteRecordMultipleViewsWithChildren\n\n↳↳ RouteRecordRedirect\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nchildren\n​\n\n• Optional children: RouteRecordRaw[]\n\nArray of nested routes.\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\nPathParserOptions.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nprops\n​\n\n• Optional props: _RouteRecordProps | Record<string, _RouteRecordProps>\n\nAllow passing down params as props to the component rendered by router-view.\n\nredirect\n​\n\n• Optional redirect: RouteRecordRedirectOption\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\nPathParserOptions.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\nPathParserOptions.strict"
  },
  {
    "title": "Interface: NavigationGuard | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/NavigationGuard.html#VPContent",
    "html": "API Documentation / NavigationGuard\n\nInterface: NavigationGuard\n​\n\nNavigation guard. See Navigation Guards.\n\nCallable\n​\nNavigationGuard\n​\n\n▸ NavigationGuard(to, from, next): NavigationGuardReturn | Promise<NavigationGuardReturn>\n\nParameters\n​\nName\tType\nto\tRouteLocationNormalized\nfrom\tRouteLocationNormalized\nnext\tNavigationGuardNext\nReturns\n​\n\nNavigationGuardReturn | Promise<NavigationGuardReturn>"
  },
  {
    "title": "Interface: RouteLocation | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteLocation.html#VPContent",
    "html": "API Documentation / RouteLocation\n\nInterface: RouteLocation\n​\n\nRouteLocationRaw resolved using the matcher\n\nHierarchy\n​\n\n_RouteLocationBase\n\n↳ RouteLocation\n\nProperties\n​\nfullPath\n​\n\n• fullPath: string\n\nThe whole location including the search and hash. This string is percentage encoded.\n\nInherited from\n​\n\n_RouteLocationBase.fullPath\n\nhash\n​\n\n• hash: string\n\nHash of the current location. If present, starts with a #.\n\nInherited from\n​\n\n_RouteLocationBase.hash\n\nmatched\n​\n\n• matched: RouteRecordNormalized[]\n\nArray of RouteRecord containing components as they were passed when adding records. It can also contain redirect records. This can't be used directly\n\nmeta\n​\n\n• meta: RouteMeta\n\nMerged meta properties from all the matched route records.\n\nInherited from\n​\n\n_RouteLocationBase.meta\n\nname\n​\n\n• name: undefined | null | RouteRecordName\n\nName of the matched record\n\nInherited from\n​\n\n_RouteLocationBase.name\n\nparams\n​\n\n• params: RouteParams\n\nObject of decoded params extracted from the path.\n\nInherited from\n​\n\n_RouteLocationBase.params\n\npath\n​\n\n• path: string\n\nPercentage encoded pathname section of the URL.\n\nInherited from\n​\n\n_RouteLocationBase.path\n\nquery\n​\n\n• query: LocationQuery\n\nObject representation of the search property of the current location.\n\nInherited from\n​\n\n_RouteLocationBase.query\n\nredirectedFrom\n​\n\n• redirectedFrom: undefined | RouteLocation\n\nContains the location we were initially trying to access before ending up on the current location.\n\nInherited from\n​\n\n_RouteLocationBase.redirectedFrom"
  },
  {
    "title": "Interface: RouterViewProps | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerviewprops",
    "html": "API Documentation / RouterViewProps\n\nInterface: RouterViewProps\n​\nProperties\n​\nname\n​\n\n• Optional name: string\n\nroute\n​\n\n• Optional route: RouteLocationNormalized"
  },
  {
    "title": "Interface: RouterScrollBehavior | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerscrollbehavior",
    "html": "API Documentation / RouterScrollBehavior\n\nInterface: RouterScrollBehavior\n​\n\nType of the scrollBehavior option that can be passed to createRouter.\n\nCallable\n​\nRouterScrollBehavior\n​\n\n▸ RouterScrollBehavior(to, from, savedPosition): Awaitable<false | void | ScrollPosition>\n\nParameters\n​\nName\tType\tDescription\nto\tRouteLocationNormalized\tRoute location where we are navigating to\nfrom\tRouteLocationNormalizedLoaded\tRoute location where we are navigating from\nsavedPosition\tnull | _ScrollPositionNormalized\tsaved position if it exists, null otherwise\nReturns\n​\n\nAwaitable<false | void | ScrollPosition>"
  },
  {
    "title": "Interface: RouterOptions | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routeroptions",
    "html": "API Documentation / RouterOptions\n\nInterface: RouterOptions\n​\n\nOptions to initialize a Router instance.\n\nHierarchy\n​\n\nPathParserOptions\n\n↳ RouterOptions\n\nProperties\n​\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\nPathParserOptions.end\n\nhistory\n​\n\n• history: RouterHistory\n\nHistory implementation used by the router. Most web applications should use createWebHistory but it requires the server to be properly configured. You can also use a hash based history with createWebHashHistory that does not require any configuration on the server but isn't handled at all by search engines and does poorly on SEO.\n\nExample\n\njs\ncreateRouter({\n  history: createWebHistory(),\n  // other options...\n})\nlinkActiveClass\n​\n\n• Optional linkActiveClass: string\n\nDefault class applied to active RouterLink. If none is provided, router-link-active will be applied.\n\nlinkExactActiveClass\n​\n\n• Optional linkExactActiveClass: string\n\nDefault class applied to exact active RouterLink. If none is provided, router-link-exact-active will be applied.\n\nparseQuery\n​\n\n• Optional parseQuery: (search: string) => LocationQuery\n\nType declaration\n​\n\n▸ (search): LocationQuery\n\nCustom implementation to parse a query. See its counterpart, RouterOptions.stringifyQuery.\n\nParameters\n​\nName\tType\nsearch\tstring\nReturns\n​\n\nLocationQuery\n\nExample\n\nLet's say you want to use the qs package to parse queries, you can provide both parseQuery and stringifyQuery:\n\njs\nimport qs from 'qs'\n\ncreateRouter({\n  // other options...\n  parseQuery: qs.parse,\n  stringifyQuery: qs.stringify,\n})\nroutes\n​\n\n• routes: readonly RouteRecordRaw[]\n\nInitial list of routes that should be added to the router.\n\nscrollBehavior\n​\n\n• Optional scrollBehavior: RouterScrollBehavior\n\nFunction to control scrolling when navigating between pages. Can return a Promise to delay scrolling. Check ScrollBehavior.\n\nExample\n\njs\nfunction scrollBehavior(to, from, savedPosition) {\n  // `to` and `from` are both route locations\n  // `savedPosition` can be null if there isn't one\n}\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\nPathParserOptions.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\nPathParserOptions.strict\n\nstringifyQuery\n​\n\n• Optional stringifyQuery: (query: LocationQueryRaw) => string\n\nType declaration\n​\n\n▸ (query): string\n\nCustom implementation to stringify a query object. Should not prepend a leading ?. parseQuery counterpart to handle query parsing.\n\nParameters\n​\nName\tType\nquery\tLocationQueryRaw\nReturns\n​\n\nstring"
  },
  {
    "title": "Interface: RouterLinkProps | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouterLinkProps.html",
    "html": "API Documentation / RouterLinkProps\n\nInterface: RouterLinkProps\n​\nHierarchy\n​\n\nRouterLinkOptions\n\n↳ RouterLinkProps\n\nProperties\n​\nactiveClass\n​\n\n• Optional activeClass: string\n\nClass to apply when the link is active\n\nariaCurrentValue\n​\n\n• Optional ariaCurrentValue: \"location\" | \"time\" | \"page\" | \"step\" | \"date\" | \"true\" | \"false\"\n\nValue passed to the attribute aria-current when the link is exact active.\n\nDefault Value\n\n'page'\n\ncustom\n​\n\n• Optional custom: boolean\n\nWhether RouterLink should not wrap its content in an a tag. Useful when using v-slot to create a custom RouterLink\n\nexactActiveClass\n​\n\n• Optional exactActiveClass: string\n\nClass to apply when the link is exact active\n\nreplace\n​\n\n• Optional replace: boolean\n\nCalls router.replace instead of router.push.\n\nInherited from\n​\n\nRouterLinkOptions.replace\n\nto\n​\n\n• to: RouteLocationRaw\n\nRoute Location the link should navigate to when clicked on.\n\nInherited from\n​\n\nRouterLinkOptions.to"
  },
  {
    "title": "Interface: RouterHistory | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerhistory",
    "html": "API Documentation / RouterHistory\n\nInterface: RouterHistory\n​\n\nInterface implemented by History implementations that can be passed to the router as Router.history\n\nProperties\n​\nbase\n​\n\n• Readonly base: string\n\nBase path that is prepended to every url. This allows hosting an SPA at a sub-folder of a domain like example.com/sub-folder by having a base of /sub-folder\n\nlocation\n​\n\n• Readonly location: string\n\nCurrent History location\n\nstate\n​\n\n• Readonly state: HistoryState\n\nCurrent History state\n\nMethods\n​\ncreateHref\n​\n\n▸ createHref(location): string\n\nGenerates the corresponding href to be used in an anchor tag.\n\nParameters\n​\nName\tType\tDescription\nlocation\tstring\thistory location that should create an href\nReturns\n​\n\nstring\n\ndestroy\n​\n\n▸ destroy(): void\n\nClears any event listener attached by the history implementation.\n\nReturns\n​\n\nvoid\n\ngo\n​\n\n▸ go(delta, triggerListeners?): void\n\nTraverses history in a given direction.\n\nParameters\n​\nName\tType\tDescription\ndelta\tnumber\tdistance to travel. If delta is < 0, it will go back, if it's > 0, it will go forward by that amount of entries.\ntriggerListeners?\tboolean\twhether this should trigger listeners attached to the history\nReturns\n​\n\nvoid\n\nExample\n\njs\nmyHistory.go(-1) // equivalent to window.history.back()\nmyHistory.go(1) // equivalent to window.history.forward()\nlisten\n​\n\n▸ listen(callback): () => void\n\nAttach a listener to the History implementation that is triggered when the navigation is triggered from outside (like the Browser back and forward buttons) or when passing true to RouterHistory.back and RouterHistory.forward\n\nParameters\n​\nName\tType\tDescription\ncallback\tNavigationCallback\tlistener to attach\nReturns\n​\n\nfn\n\na callback to remove the listener\n\n▸ (): void\n\nAttach a listener to the History implementation that is triggered when the navigation is triggered from outside (like the Browser back and forward buttons) or when passing true to RouterHistory.back and RouterHistory.forward\n\nReturns\n​\n\nvoid\n\na callback to remove the listener\n\npush\n​\n\n▸ push(to, data?): void\n\nNavigates to a location. In the case of an HTML5 History implementation, this will call history.pushState to effectively change the URL.\n\nParameters\n​\nName\tType\tDescription\nto\tstring\tlocation to push\ndata?\tHistoryState\toptional HistoryState to be associated with the navigation entry\nReturns\n​\n\nvoid\n\nreplace\n​\n\n▸ replace(to, data?): void\n\nSame as RouterHistory.push but performs a history.replaceState instead of history.pushState\n\nParameters\n​\nName\tType\tDescription\nto\tstring\tlocation to set\ndata?\tHistoryState\toptional HistoryState to be associated with the navigation entry\nReturns\n​\n\nvoid"
  },
  {
    "title": "Interface: Router | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/router",
    "html": "API Documentation / Router\n\nInterface: Router\n​\n\nRouter instance.\n\nProperties\n​\ncurrentRoute\n​\n\n• Readonly currentRoute: Ref<RouteLocationNormalizedLoaded>\n\nCurrent RouteLocationNormalized\n\nlistening\n​\n\n• listening: boolean\n\nAllows turning off the listening of history events. This is a low level api for micro-frontends.\n\noptions\n​\n\n• Readonly options: RouterOptions\n\nOriginal options object passed to create the Router\n\nMethods\n​\naddRoute\n​\n\n▸ addRoute(parentName, route): () => void\n\nAdd a new route record as the child of an existing route.\n\nParameters\n​\nName\tType\tDescription\nparentName\tRouteRecordName\tParent Route Record where route should be appended at\nroute\tRouteRecordRaw\tRoute Record to add\nReturns\n​\n\nfn\n\n▸ (): void\n\nAdd a new route record as the child of an existing route.\n\nReturns\n​\n\nvoid\n\n▸ addRoute(route): () => void\n\nAdd a new route record to the router.\n\nParameters\n​\nName\tType\tDescription\nroute\tRouteRecordRaw\tRoute Record to add\nReturns\n​\n\nfn\n\n▸ (): void\n\nAdd a new route record to the router.\n\nReturns\n​\n\nvoid\n\nafterEach\n​\n\n▸ afterEach(guard): () => void\n\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\n\nParameters\n​\nName\tType\tDescription\nguard\tNavigationHookAfter\tnavigation hook to add\nReturns\n​\n\nfn\n\na function that removes the registered hook\n\n▸ (): void\n\nAdd a navigation hook that is executed after every navigation. Returns a function that removes the registered hook.\n\nReturns\n​\n\nvoid\n\na function that removes the registered hook\n\nExample\n\njs\nrouter.afterEach((to, from, failure) => {\n  if (isNavigationFailure(failure)) {\n    console.log('failed navigation', failure)\n  }\n})\n\nExample\n\njs\nrouter.afterEach((to, from, failure) => {\n  if (isNavigationFailure(failure)) {\n    console.log('failed navigation', failure)\n  }\n})\nback\n​\n\n▸ back(): void\n\nGo back in history if possible by calling history.back(). Equivalent to router.go(-1).\n\nReturns\n​\n\nvoid\n\nbeforeEach\n​\n\n▸ beforeEach(guard): () => void\n\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\n\nParameters\n​\nName\tType\tDescription\nguard\tNavigationGuardWithThis<undefined>\tnavigation guard to add\nReturns\n​\n\nfn\n\n▸ (): void\n\nAdd a navigation guard that executes before any navigation. Returns a function that removes the registered guard.\n\nReturns\n​\n\nvoid\n\nbeforeResolve\n​\n\n▸ beforeResolve(guard): () => void\n\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\n\nParameters\n​\nName\tType\tDescription\nguard\tNavigationGuardWithThis<undefined>\tnavigation guard to add\nReturns\n​\n\nfn\n\na function that removes the registered guard\n\n▸ (): void\n\nAdd a navigation guard that executes before navigation is about to be resolved. At this state all component have been fetched and other navigation guards have been successful. Returns a function that removes the registered guard.\n\nReturns\n​\n\nvoid\n\na function that removes the registered guard\n\nExample\n\njs\nrouter.beforeResolve(to => {\n  if (to.meta.requiresAuth && !isAuthenticated) return false\n})\n\nExample\n\njs\nrouter.beforeResolve(to => {\n  if (to.meta.requiresAuth && !isAuthenticated) return false\n})\nforward\n​\n\n▸ forward(): void\n\nGo forward in history if possible by calling history.forward(). Equivalent to router.go(1).\n\nReturns\n​\n\nvoid\n\ngetRoutes\n​\n\n▸ getRoutes(): RouteRecordNormalized[]\n\nGet a full list of all the route records.\n\nReturns\n​\n\nRouteRecordNormalized[]\n\ngo\n​\n\n▸ go(delta): void\n\nAllows you to move forward or backward through the history. Calls history.go().\n\nParameters\n​\nName\tType\tDescription\ndelta\tnumber\tThe position in the history to which you want to move, relative to the current page\nReturns\n​\n\nvoid\n\nhasRoute\n​\n\n▸ hasRoute(name): boolean\n\nChecks if a route with a given name exists\n\nParameters\n​\nName\tType\tDescription\nname\tRouteRecordName\tName of the route to check\nReturns\n​\n\nboolean\n\nisReady\n​\n\n▸ isReady(): Promise<void>\n\nReturns a Promise that resolves when the router has completed the initial navigation, which means it has resolved all async enter hooks and async components that are associated with the initial route. If the initial navigation already happened, the promise resolves immediately.\n\nThis is useful in server-side rendering to ensure consistent output on both the server and the client. Note that on server side, you need to manually push the initial location while on client side, the router automatically picks it up from the URL.\n\nReturns\n​\n\nPromise<void>\n\nonError\n​\n\n▸ onError(handler): () => void\n\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to next in any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\n\nParameters\n​\nName\tType\tDescription\nhandler\t_ErrorListener\terror handler to register\nReturns\n​\n\nfn\n\n▸ (): void\n\nAdds an error handler that is called every time a non caught error happens during navigation. This includes errors thrown synchronously and asynchronously, errors returned or passed to next in any navigation guard, and errors occurred when trying to resolve an async component that is required to render a route.\n\nReturns\n​\n\nvoid\n\npush\n​\n\n▸ push(to): Promise<undefined | void | NavigationFailure>\n\nProgrammatically navigate to a new URL by pushing an entry in the history stack.\n\nParameters\n​\nName\tType\tDescription\nto\tRouteLocationRaw\tRoute location to navigate to\nReturns\n​\n\nPromise<undefined | void | NavigationFailure>\n\nremoveRoute\n​\n\n▸ removeRoute(name): void\n\nRemove an existing route by its name.\n\nParameters\n​\nName\tType\tDescription\nname\tRouteRecordName\tName of the route to remove\nReturns\n​\n\nvoid\n\nreplace\n​\n\n▸ replace(to): Promise<undefined | void | NavigationFailure>\n\nProgrammatically navigate to a new URL by replacing the current entry in the history stack.\n\nParameters\n​\nName\tType\tDescription\nto\tRouteLocationRaw\tRoute location to navigate to\nReturns\n​\n\nPromise<undefined | void | NavigationFailure>\n\nresolve\n​\n\n▸ resolve(to, currentLocation?): RouteLocation & { href: string }\n\nReturns the normalized version of a route location. Also includes an href property that includes any existing base. By default, the currentLocation used is router.currentRoute and should only be overridden in advanced use cases.\n\nParameters\n​\nName\tType\tDescription\nto\tRouteLocationRaw\tRaw route location to resolve\ncurrentLocation?\tRouteLocationNormalizedLoaded\tOptional current location to resolve against\nReturns\n​\n\nRouteLocation & { href: string }"
  },
  {
    "title": "Interface: RouteRecordSingleViewWithChildren | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerecordsingleviewwithchildren",
    "html": "API Documentation / RouteRecordSingleViewWithChildren\n\nInterface: RouteRecordSingleViewWithChildren\n​\n\nRoute Record defining one single component with a nested view.\n\nHierarchy\n​\n\n_RouteRecordBase\n\n↳ RouteRecordSingleViewWithChildren\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nInherited from\n​\n\n_RouteRecordBase.alias\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nInherited from\n​\n\n_RouteRecordBase.beforeEnter\n\nchildren\n​\n\n• children: RouteRecordRaw[]\n\nArray of nested routes.\n\nOverrides\n​\n\n_RouteRecordBase.children\n\ncomponent\n​\n\n• Optional component: null | RawRouteComponent\n\nComponent to display when the URL matches this route.\n\ncomponents\n​\n\n• Optional components: undefined\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\n_RouteRecordBase.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nInherited from\n​\n\n_RouteRecordBase.meta\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\nInherited from\n​\n\n_RouteRecordBase.name\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\n​\n\n_RouteRecordBase.path\n\nprops\n​\n\n• Optional props: _RouteRecordProps\n\nAllow passing down params as props to the component rendered by router-view.\n\nOverrides\n​\n\n_RouteRecordBase.props\n\nredirect\n​\n\n• Optional redirect: RouteRecordRedirectOption\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nInherited from\n​\n\n_RouteRecordBase.redirect\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.strict"
  },
  {
    "title": "Interface: RouteRecordSingleView | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerecordsingleview",
    "html": "API Documentation / RouteRecordSingleView\n\nInterface: RouteRecordSingleView\n​\n\nRoute Record defining one single component with the component option.\n\nHierarchy\n​\n\n_RouteRecordBase\n\n↳ RouteRecordSingleView\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nInherited from\n​\n\n_RouteRecordBase.alias\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nInherited from\n​\n\n_RouteRecordBase.beforeEnter\n\nchildren\n​\n\n• Optional children: undefined\n\nArray of nested routes.\n\nOverrides\n​\n\n_RouteRecordBase.children\n\ncomponent\n​\n\n• component: RawRouteComponent\n\nComponent to display when the URL matches this route.\n\ncomponents\n​\n\n• Optional components: undefined\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\n_RouteRecordBase.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nInherited from\n​\n\n_RouteRecordBase.meta\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\nInherited from\n​\n\n_RouteRecordBase.name\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\n​\n\n_RouteRecordBase.path\n\nprops\n​\n\n• Optional props: _RouteRecordProps\n\nAllow passing down params as props to the component rendered by router-view.\n\nOverrides\n​\n\n_RouteRecordBase.props\n\nredirect\n​\n\n• Optional redirect: undefined\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nOverrides\n​\n\n_RouteRecordBase.redirect\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.strict"
  },
  {
    "title": "Interface: RouteRecordRedirect | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerecordredirect",
    "html": "API Documentation / RouteRecordRedirect\n\nInterface: RouteRecordRedirect\n​\n\nRoute Record that defines a redirect. Cannot have component or components as it is never rendered.\n\nHierarchy\n​\n\n_RouteRecordBase\n\n↳ RouteRecordRedirect\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nInherited from\n​\n\n_RouteRecordBase.alias\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nInherited from\n​\n\n_RouteRecordBase.beforeEnter\n\nchildren\n​\n\n• Optional children: RouteRecordRaw[]\n\nArray of nested routes.\n\nInherited from\n​\n\n_RouteRecordBase.children\n\ncomponent\n​\n\n• Optional component: undefined\n\ncomponents\n​\n\n• Optional components: undefined\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\n_RouteRecordBase.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nInherited from\n​\n\n_RouteRecordBase.meta\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\nInherited from\n​\n\n_RouteRecordBase.name\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\n​\n\n_RouteRecordBase.path\n\nprops\n​\n\n• Optional props: undefined\n\nAllow passing down params as props to the component rendered by router-view.\n\nOverrides\n​\n\n_RouteRecordBase.props\n\nredirect\n​\n\n• redirect: RouteRecordRedirectOption\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nOverrides\n​\n\n_RouteRecordBase.redirect\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.strict"
  },
  {
    "title": "Interface: RouteRecordNormalized | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerecordnormalized",
    "html": "API Documentation / RouteRecordNormalized\n\nInterface: RouteRecordNormalized\n​\n\nNormalized version of a route record.\n\nHierarchy\n​\n\nRouteRecordNormalized\n\n↳ RouteLocationMatched\n\nProperties\n​\naliasOf\n​\n\n• aliasOf: undefined | RouteRecordNormalized\n\nDefines if this record is the alias of another one. This property is undefined if the record is the original one.\n\nbeforeEnter\n​\n\n• beforeEnter: undefined | NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nRegistered beforeEnter guards\n\nchildren\n​\n\n• children: RouteRecordRaw[]\n\nNested route records.\n\ncomponents\n​\n\n• components: undefined | null | Record<string, RawRouteComponent>\n\nComponents to display when the URL matches this route. Allow using named views.\n\ninstances\n​\n\n• instances: Record<string, undefined | null | ComponentPublicInstance>\n\nMounted route component instances Having the instances on the record mean beforeRouteUpdate and beforeRouteLeave guards can only be invoked with the latest mounted app instance if there are multiple application instances rendering the same view, basically duplicating the content on the page, which shouldn't happen in practice. It will work if multiple apps are rendering different named views.\n\nmeta\n​\n\n• meta: RouteMeta\n\nArbitrary data attached to the record.\n\nname\n​\n\n• name: undefined | RouteRecordName\n\nName for the route record. Must be unique.\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nprops\n​\n\n• props: Record<string, _RouteRecordProps>\n\nAllow passing down params as props to the component rendered by router-view. Should be an object with the same keys as components or a boolean to be applied to every component.\n\nredirect\n​\n\n• redirect: undefined | RouteRecordRedirectOption\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location."
  },
  {
    "title": "Interface: RouteRecordMultipleViewsWithChildren | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routerecordmultipleviewswithchildren",
    "html": "API Documentation / RouteRecordMultipleViewsWithChildren\n\nInterface: RouteRecordMultipleViewsWithChildren\n​\n\nRoute Record defining multiple named components with the components option and children.\n\nHierarchy\n​\n\n_RouteRecordBase\n\n↳ RouteRecordMultipleViewsWithChildren\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nInherited from\n​\n\n_RouteRecordBase.alias\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nInherited from\n​\n\n_RouteRecordBase.beforeEnter\n\nchildren\n​\n\n• children: RouteRecordRaw[]\n\nArray of nested routes.\n\nOverrides\n​\n\n_RouteRecordBase.children\n\ncomponent\n​\n\n• Optional component: undefined\n\ncomponents\n​\n\n• Optional components: null | Record<string, RawRouteComponent>\n\nComponents to display when the URL matches this route. Allow using named views.\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\n_RouteRecordBase.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nInherited from\n​\n\n_RouteRecordBase.meta\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\nInherited from\n​\n\n_RouteRecordBase.name\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\n​\n\n_RouteRecordBase.path\n\nprops\n​\n\n• Optional props: boolean | Record<string, _RouteRecordProps>\n\nAllow passing down params as props to the component rendered by router-view. Should be an object with the same keys as components or a boolean to be applied to every component.\n\nOverrides\n​\n\n_RouteRecordBase.props\n\nredirect\n​\n\n• Optional redirect: RouteRecordRedirectOption\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nInherited from\n​\n\n_RouteRecordBase.redirect\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.strict"
  },
  {
    "title": "Interface: RouteRecordMultipleViews | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteRecordMultipleViews.html",
    "html": "API Documentation / RouteRecordMultipleViews\n\nInterface: RouteRecordMultipleViews\n​\n\nRoute Record defining multiple named components with the components option.\n\nHierarchy\n​\n\n_RouteRecordBase\n\n↳ RouteRecordMultipleViews\n\nProperties\n​\nalias\n​\n\n• Optional alias: string | string[]\n\nAliases for the record. Allows defining extra paths that will behave like a copy of the record. Allows having paths shorthands like /users/:id and /u/:id. All alias and path values must share the same params.\n\nInherited from\n​\n\n_RouteRecordBase.alias\n\nbeforeEnter\n​\n\n• Optional beforeEnter: NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nBefore Enter guard specific to this record. Note beforeEnter has no effect if the record has a redirect property.\n\nInherited from\n​\n\n_RouteRecordBase.beforeEnter\n\nchildren\n​\n\n• Optional children: undefined\n\nArray of nested routes.\n\nOverrides\n​\n\n_RouteRecordBase.children\n\ncomponent\n​\n\n• Optional component: undefined\n\ncomponents\n​\n\n• components: Record<string, RawRouteComponent>\n\nComponents to display when the URL matches this route. Allow using named views.\n\nend\n​\n\n• Optional end: boolean\n\nShould the RegExp match until the end by appending a $ to it.\n\nDefault Value\n\ntrue\n\nInherited from\n​\n\n_RouteRecordBase.end\n\nmeta\n​\n\n• Optional meta: RouteMeta\n\nArbitrary data attached to the record.\n\nInherited from\n​\n\n_RouteRecordBase.meta\n\nname\n​\n\n• Optional name: RouteRecordName\n\nName for the route record. Must be unique.\n\nInherited from\n​\n\n_RouteRecordBase.name\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nExample\n\nts\n`/users/:id` matches `/users/1` as well as `/users/posva`.\nInherited from\n​\n\n_RouteRecordBase.path\n\nprops\n​\n\n• Optional props: boolean | Record<string, _RouteRecordProps>\n\nAllow passing down params as props to the component rendered by router-view. Should be an object with the same keys as components or a boolean to be applied to every component.\n\nOverrides\n​\n\n_RouteRecordBase.props\n\nredirect\n​\n\n• Optional redirect: undefined\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nOverrides\n​\n\n_RouteRecordBase.redirect\n\nsensitive\n​\n\n• Optional sensitive: boolean\n\nMakes the RegExp case-sensitive.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.sensitive\n\nstrict\n​\n\n• Optional strict: boolean\n\nWhether to disallow a trailing slash or not.\n\nDefault Value\n\nfalse\n\nInherited from\n​\n\n_RouteRecordBase.strict"
  },
  {
    "title": "Interface: RouteMeta | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteMeta.html",
    "html": "API Documentation / RouteMeta\n\nInterface: RouteMeta\n​\n\nInterface to type meta fields in route records.\n\nExample\n\nts\n// typings.d.ts or router.ts\nimport 'vue-router';\n\ndeclare module 'vue-router' {\n  interface RouteMeta {\n    requiresAuth?: boolean\n  }\n }\nHierarchy\n​\n\nRecord<string | number | symbol, unknown>\n\n↳ RouteMeta"
  },
  {
    "title": "Interface: RouteLocationOptions | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routelocationoptions",
    "html": "API Documentation / RouteLocationOptions\n\nInterface: RouteLocationOptions\n​\n\nCommon options for all navigation methods.\n\nProperties\n​\nforce\n​\n\n• Optional force: boolean\n\nTriggers the navigation even if the location is the same as the current one. Note this will also add a new entry to the history unless replace: true is passed.\n\nreplace\n​\n\n• Optional replace: boolean\n\nReplace the entry in the history instead of pushing a new entry\n\nstate\n​\n\n• Optional state: HistoryState\n\nState to save using the History API. This cannot contain any reactive values and some primitives like Symbols are forbidden. More info at https://developer.mozilla.org/en-US/docs/Web/API/History/state"
  },
  {
    "title": "Interface: RouteLocationNormalizedLoaded | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteLocationNormalizedLoaded.html",
    "html": "API Documentation / RouteLocationNormalizedLoaded\n\nInterface: RouteLocationNormalizedLoaded\n​\n\nRouteLocationRaw with\n\nHierarchy\n​\n\n_RouteLocationBase\n\n↳ RouteLocationNormalizedLoaded\n\nProperties\n​\nfullPath\n​\n\n• fullPath: string\n\nThe whole location including the search and hash. This string is percentage encoded.\n\nInherited from\n​\n\n_RouteLocationBase.fullPath\n\nhash\n​\n\n• hash: string\n\nHash of the current location. If present, starts with a #.\n\nInherited from\n​\n\n_RouteLocationBase.hash\n\nmatched\n​\n\n• matched: RouteLocationMatched[]\n\nArray of RouteLocationMatched containing only plain components (any lazy-loaded components have been loaded and were replaced inside the components object) so it can be directly used to display routes. It cannot contain redirect records either\n\nmeta\n​\n\n• meta: RouteMeta\n\nMerged meta properties from all the matched route records.\n\nInherited from\n​\n\n_RouteLocationBase.meta\n\nname\n​\n\n• name: undefined | null | RouteRecordName\n\nName of the matched record\n\nInherited from\n​\n\n_RouteLocationBase.name\n\nparams\n​\n\n• params: RouteParams\n\nObject of decoded params extracted from the path.\n\nInherited from\n​\n\n_RouteLocationBase.params\n\npath\n​\n\n• path: string\n\nPercentage encoded pathname section of the URL.\n\nInherited from\n​\n\n_RouteLocationBase.path\n\nquery\n​\n\n• query: LocationQuery\n\nObject representation of the search property of the current location.\n\nInherited from\n​\n\n_RouteLocationBase.query\n\nredirectedFrom\n​\n\n• redirectedFrom: undefined | RouteLocation\n\nContains the location we were initially trying to access before ending up on the current location.\n\nInherited from\n​\n\n_RouteLocationBase.redirectedFrom"
  },
  {
    "title": "Interface: RouteLocationNormalized | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteLocationNormalized.html",
    "html": "API Documentation / RouteLocationNormalized\n\nInterface: RouteLocationNormalized\n​\n\nSimilar to RouteLocation but its RouteLocationNormalized.matched cannot contain redirect records\n\nHierarchy\n​\n\n_RouteLocationBase\n\n↳ RouteLocationNormalized\n\nProperties\n​\nfullPath\n​\n\n• fullPath: string\n\nThe whole location including the search and hash. This string is percentage encoded.\n\nInherited from\n​\n\n_RouteLocationBase.fullPath\n\nhash\n​\n\n• hash: string\n\nHash of the current location. If present, starts with a #.\n\nInherited from\n​\n\n_RouteLocationBase.hash\n\nmatched\n​\n\n• matched: RouteRecordNormalized[]\n\nArray of RouteRecordNormalized\n\nmeta\n​\n\n• meta: RouteMeta\n\nMerged meta properties from all the matched route records.\n\nInherited from\n​\n\n_RouteLocationBase.meta\n\nname\n​\n\n• name: undefined | null | RouteRecordName\n\nName of the matched record\n\nInherited from\n​\n\n_RouteLocationBase.name\n\nparams\n​\n\n• params: RouteParams\n\nObject of decoded params extracted from the path.\n\nInherited from\n​\n\n_RouteLocationBase.params\n\npath\n​\n\n• path: string\n\nPercentage encoded pathname section of the URL.\n\nInherited from\n​\n\n_RouteLocationBase.path\n\nquery\n​\n\n• query: LocationQuery\n\nObject representation of the search property of the current location.\n\nInherited from\n​\n\n_RouteLocationBase.query\n\nredirectedFrom\n​\n\n• redirectedFrom: undefined | RouteLocation\n\nContains the location we were initially trying to access before ending up on the current location.\n\nInherited from\n​\n\n_RouteLocationBase.redirectedFrom"
  },
  {
    "title": "Interface: RouteLocationMatched | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/routelocationmatched",
    "html": "API Documentation / RouteLocationMatched\n\nInterface: RouteLocationMatched\n​\n\nNormalized version of a route record.\n\nHierarchy\n​\n\nRouteRecordNormalized\n\n↳ RouteLocationMatched\n\nProperties\n​\naliasOf\n​\n\n• aliasOf: undefined | RouteRecordNormalized\n\nDefines if this record is the alias of another one. This property is undefined if the record is the original one.\n\nInherited from\n​\n\nRouteRecordNormalized.aliasOf\n\nbeforeEnter\n​\n\n• beforeEnter: undefined | NavigationGuardWithThis<undefined> | NavigationGuardWithThis<undefined>[]\n\nRegistered beforeEnter guards\n\nInherited from\n​\n\nRouteRecordNormalized.beforeEnter\n\nchildren\n​\n\n• children: RouteRecordRaw[]\n\nNested route records.\n\nInherited from\n​\n\nRouteRecordNormalized.children\n\ncomponents\n​\n\n• components: undefined | null | Record<string, RouteComponent>\n\nComponents to display when the URL matches this route. Allow using named views.\n\nOverrides\n​\n\nRouteRecordNormalized.components\n\ninstances\n​\n\n• instances: Record<string, undefined | null | ComponentPublicInstance>\n\nMounted route component instances Having the instances on the record mean beforeRouteUpdate and beforeRouteLeave guards can only be invoked with the latest mounted app instance if there are multiple application instances rendering the same view, basically duplicating the content on the page, which shouldn't happen in practice. It will work if multiple apps are rendering different named views.\n\nInherited from\n​\n\nRouteRecordNormalized.instances\n\nmeta\n​\n\n• meta: RouteMeta\n\nArbitrary data attached to the record.\n\nInherited from\n​\n\nRouteRecordNormalized.meta\n\nname\n​\n\n• name: undefined | RouteRecordName\n\nName for the route record. Must be unique.\n\nInherited from\n​\n\nRouteRecordNormalized.name\n\npath\n​\n\n• path: string\n\nPath of the record. Should start with / unless the record is the child of another record.\n\nInherited from\n​\n\nRouteRecordNormalized.path\n\nprops\n​\n\n• props: Record<string, _RouteRecordProps>\n\nAllow passing down params as props to the component rendered by router-view. Should be an object with the same keys as components or a boolean to be applied to every component.\n\nInherited from\n​\n\nRouteRecordNormalized.props\n\nredirect\n​\n\n• redirect: undefined | RouteRecordRedirectOption\n\nWhere to redirect if the route is directly matched. The redirection happens before any navigation guard and triggers a new navigation with the new target location.\n\nInherited from\n​\n\nRouteRecordNormalized.redirect"
  },
  {
    "title": "Interface: RouteLocation | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/RouteLocation.html",
    "html": "API Documentation / RouteLocation\n\nInterface: RouteLocation\n​\n\nRouteLocationRaw resolved using the matcher\n\nHierarchy\n​\n\n_RouteLocationBase\n\n↳ RouteLocation\n\nProperties\n​\nfullPath\n​\n\n• fullPath: string\n\nThe whole location including the search and hash. This string is percentage encoded.\n\nInherited from\n​\n\n_RouteLocationBase.fullPath\n\nhash\n​\n\n• hash: string\n\nHash of the current location. If present, starts with a #.\n\nInherited from\n​\n\n_RouteLocationBase.hash\n\nmatched\n​\n\n• matched: RouteRecordNormalized[]\n\nArray of RouteRecord containing components as they were passed when adding records. It can also contain redirect records. This can't be used directly\n\nmeta\n​\n\n• meta: RouteMeta\n\nMerged meta properties from all the matched route records.\n\nInherited from\n​\n\n_RouteLocationBase.meta\n\nname\n​\n\n• name: undefined | null | RouteRecordName\n\nName of the matched record\n\nInherited from\n​\n\n_RouteLocationBase.name\n\nparams\n​\n\n• params: RouteParams\n\nObject of decoded params extracted from the path.\n\nInherited from\n​\n\n_RouteLocationBase.params\n\npath\n​\n\n• path: string\n\nPercentage encoded pathname section of the URL.\n\nInherited from\n​\n\n_RouteLocationBase.path\n\nquery\n​\n\n• query: LocationQuery\n\nObject representation of the search property of the current location.\n\nInherited from\n​\n\n_RouteLocationBase.query\n\nredirectedFrom\n​\n\n• redirectedFrom: undefined | RouteLocation\n\nContains the location we were initially trying to access before ending up on the current location.\n\nInherited from\n​\n\n_RouteLocationBase.redirectedFrom"
  },
  {
    "title": "Interface: NavigationHookAfter | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/navigationhookafter",
    "html": "API Documentation / NavigationHookAfter\n\nInterface: NavigationHookAfter\n​\nCallable\n​\nNavigationHookAfter\n​\n\n▸ NavigationHookAfter(to, from, failure?): any\n\nParameters\n​\nName\tType\nto\tRouteLocationNormalized\nfrom\tRouteLocationNormalized\nfailure?\tvoid | NavigationFailure\nReturns\n​\n\nany"
  },
  {
    "title": "Interface: NavigationGuardWithThis<T> | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/navigationguardwiththis",
    "html": "API Documentation / NavigationGuardWithThis\n\nInterface: NavigationGuardWithThis<T>\n​\n\nNavigation guard. See Navigation Guards.\n\nType parameters\n​\nName\nT\nCallable\n​\nNavigationGuardWithThis\n​\n\n▸ NavigationGuardWithThis(this, to, from, next): NavigationGuardReturn | Promise<NavigationGuardReturn>\n\nParameters\n​\nName\tType\nthis\tT\nto\tRouteLocationNormalized\nfrom\tRouteLocationNormalized\nnext\tNavigationGuardNext\nReturns\n​\n\nNavigationGuardReturn | Promise<NavigationGuardReturn>"
  },
  {
    "title": "Interface: NavigationGuardNext | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/navigationguardnext",
    "html": "API Documentation / NavigationGuardNext\n\nInterface: NavigationGuardNext\n​\nCallable\n​\nNavigationGuardNext\n​\n\n▸ NavigationGuardNext(): void\n\nReturns\n​\n\nvoid\n\nNavigationGuardNext\n​\n\n▸ NavigationGuardNext(error): void\n\nParameters\n​\nName\tType\nerror\tError\nReturns\n​\n\nvoid\n\nNavigationGuardNext\n​\n\n▸ NavigationGuardNext(location): void\n\nParameters\n​\nName\tType\nlocation\tRouteLocationRaw\nReturns\n​\n\nvoid\n\nNavigationGuardNext\n​\n\n▸ NavigationGuardNext(valid): void\n\nParameters\n​\nName\tType\nvalid\tundefined | boolean\nReturns\n​\n\nvoid\n\nNavigationGuardNext\n​\n\n▸ NavigationGuardNext(cb): void\n\nParameters\n​\nName\tType\ncb\tNavigationGuardNextCallback\nReturns\n​\n\nvoid"
  },
  {
    "title": "Interface: NavigationGuard | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/NavigationGuard.html",
    "html": "API Documentation / NavigationGuard\n\nInterface: NavigationGuard\n​\n\nNavigation guard. See Navigation Guards.\n\nCallable\n​\nNavigationGuard\n​\n\n▸ NavigationGuard(to, from, next): NavigationGuardReturn | Promise<NavigationGuardReturn>\n\nParameters\n​\nName\tType\nto\tRouteLocationNormalized\nfrom\tRouteLocationNormalized\nnext\tNavigationGuardNext\nReturns\n​\n\nNavigationGuardReturn | Promise<NavigationGuardReturn>"
  },
  {
    "title": "Interface: NavigationFailure | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/navigationfailure",
    "html": "API Documentation / NavigationFailure\n\nInterface: NavigationFailure\n​\n\nExtended Error that contains extra information regarding a failed navigation.\n\nHierarchy\n​\n\nError\n\n↳ NavigationFailure\n\nProperties\n​\ncause\n​\n\n• Optional cause: unknown\n\nInherited from\n​\n\nError.cause\n\nfrom\n​\n\n• from: RouteLocationNormalized\n\nRoute location we were navigating from\n\nmessage\n​\n\n• message: string\n\nInherited from\n​\n\nError.message\n\nname\n​\n\n• name: string\n\nInherited from\n​\n\nError.name\n\nstack\n​\n\n• Optional stack: string\n\nInherited from\n​\n\nError.stack\n\nto\n​\n\n• to: RouteLocationNormalized\n\nRoute location we were navigating to\n\ntype\n​\n\n• type: NAVIGATION_ABORTED | NAVIGATION_CANCELLED | NAVIGATION_DUPLICATED\n\nType of the navigation. One of NavigationFailureType"
  },
  {
    "title": "Interface: HistoryState | Vue Router",
    "url": "https://router.vuejs.org/api/interfaces/historystate",
    "html": "API Documentation / HistoryState\n\nInterface: HistoryState\n​\n\nAllowed HTML history.state\n\nIndexable\n​\n\n▪ [x: number]: HistoryStateValue"
  },
  {
    "title": "Enumeration: NavigationFailureType | Vue Router",
    "url": "https://router.vuejs.org/api/enums/NavigationFailureType.html",
    "html": "API Documentation / NavigationFailureType\n\nEnumeration: NavigationFailureType\n​\n\nEnumeration with all possible types for navigation failures. Can be passed to isNavigationFailure to check for specific failures.\n\nEnumeration Members\n​\naborted\n​\n\n• aborted = 4\n\nAn aborted navigation is a navigation that failed because a navigation guard returned false or called next(false)\n\ncancelled\n​\n\n• cancelled = 8\n\nA cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished).\n\nduplicated\n​\n\n• duplicated = 16\n\nA duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location."
  },
  {
    "title": "API Documentation | Vue Router",
    "url": "https://router.vuejs.org/api/",
    "html": "API Documentation\n\nAPI Documentation\n​\nEnumerations\n​\nNavigationFailureType\nInterfaces\n​\nHistoryState\nNavigationFailure\nNavigationGuard\nNavigationGuardNext\nNavigationGuardWithThis\nNavigationHookAfter\nRouteLocation\nRouteLocationMatched\nRouteLocationNormalized\nRouteLocationNormalizedLoaded\nRouteLocationOptions\nRouteMeta\nRouteRecordMultipleViews\nRouteRecordMultipleViewsWithChildren\nRouteRecordNormalized\nRouteRecordRedirect\nRouteRecordSingleView\nRouteRecordSingleViewWithChildren\nRouter\nRouterHistory\nRouterLinkProps\nRouterOptions\nRouterScrollBehavior\nRouterViewProps\n_RouteRecordBase\nType Aliases\n​\nLocationQuery\n​\n\nƬ LocationQuery: Record<string, LocationQueryValue | LocationQueryValue[]>\n\nNormalized query object that appears in RouteLocationNormalized\n\nLocationQueryRaw\n​\n\nƬ LocationQueryRaw: Record<string | number, LocationQueryValueRaw | LocationQueryValueRaw[]>\n\nLoose LocationQuery object that can be passed to functions like Router.push and Router.replace or anywhere when creating a RouteLocationRaw\n\nPathParserOptions\n​\n\nƬ PathParserOptions: Pick<_PathParserOptions, \"end\" | \"sensitive\" | \"strict\">\n\nRouteComponent\n​\n\nƬ RouteComponent: Component | DefineComponent\n\nAllowed Component in RouteLocationMatched\n\nRouteLocationRaw\n​\n\nƬ RouteLocationRaw: string | RouteLocationPathRaw | RouteLocationNamedRaw\n\nUser-level route location\n\nRouteParams\n​\n\nƬ RouteParams: Record<string, RouteParamValue | RouteParamValue[]>\n\nRouteParamsRaw\n​\n\nƬ RouteParamsRaw: Record<string, RouteParamValueRaw | Exclude<RouteParamValueRaw, null | undefined>[]>\n\nRouteRecord\n​\n\nƬ RouteRecord: RouteRecordNormalized\n\nNormalized version of a route record.\n\nRouteRecordName\n​\n\nƬ RouteRecordName: string | symbol\n\nPossible values for a user-defined route record's name\n\nRouteRecordRaw\n​\n\nƬ RouteRecordRaw: RouteRecordSingleView | RouteRecordSingleViewWithChildren | RouteRecordMultipleViews | RouteRecordMultipleViewsWithChildren | RouteRecordRedirect\n\nUseLinkOptions\n​\n\nƬ UseLinkOptions: VueUseOptions<RouterLinkOptions>\n\nVariables\n​\nRouterLink\n​\n\n• Const RouterLink: _RouterLinkI\n\nComponent to render a link that triggers a navigation on click.\n\nRouterView\n​\n\n• Const RouterView: () => { $props: AllowedComponentProps & ComponentCustomProps & VNodeProps & RouterViewProps ; $slots: { default?: (__namedParameters: { Component: VNode<RendererNode, RendererElement, { [key: string]: any; }> ; route: RouteLocationNormalizedLoaded }) => VNode<RendererNode, RendererElement, { [key: string]: any; }>[] } }\n\nType declaration\n​\n\n• new RouterView(): Object\n\nComponent to display the current route the user is at.\n\nReturns\n​\n\nObject\n\nName\tType\n$props\tAllowedComponentProps & ComponentCustomProps & VNodeProps & RouterViewProps\n$slots\t{ default?: (__namedParameters: { Component: VNode<RendererNode, RendererElement, { [key: string]: any; }> ; route: RouteLocationNormalizedLoaded }) => VNode<RendererNode, RendererElement, { [key: string]: any; }>[] }\n$slots.default?\t(__namedParameters: { Component: VNode<RendererNode, RendererElement, { [key: string]: any; }> ; route: RouteLocationNormalizedLoaded }) => VNode<RendererNode, RendererElement, { [key: string]: any; }>[]\nSTART_LOCATION\n​\n\n• Const START_LOCATION: RouteLocationNormalizedLoaded\n\nInitial route location where the router is. Can be used in navigation guards to differentiate the initial navigation.\n\nExample\n\njs\nimport { START_LOCATION } from 'vue-router'\n\nrouter.beforeEach((to, from) => {\n  if (from === START_LOCATION) {\n    // initial navigation\n  }\n})\nFunctions\n​\ncreateMemoryHistory\n​\n\n▸ createMemoryHistory(base?): RouterHistory\n\nCreates an in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere. It's up to the user to replace that location with the starter location by either calling router.push or router.replace.\n\nParameters\n​\nName\tType\tDefault value\tDescription\nbase\tstring\t''\tBase applied to all urls, defaults to '/'\nReturns\n​\n\nRouterHistory\n\na history object that can be passed to the router constructor\n\ncreateRouter\n​\n\n▸ createRouter(options): Router\n\nCreates a Router instance that can be used by a Vue app.\n\nParameters\n​\nName\tType\tDescription\noptions\tRouterOptions\tRouterOptions\nReturns\n​\n\nRouter\n\ncreateWebHashHistory\n​\n\n▸ createWebHashHistory(base?): RouterHistory\n\nCreates a hash history. Useful for web applications with no host (e.g. file://) or when configuring a server to handle any URL is not possible.\n\nParameters\n​\nName\tType\tDescription\nbase?\tstring\toptional base to provide. Defaults to location.pathname + location.search If there is a <base> tag in the head, its value will be ignored in favor of this parameter but note it affects all the history.pushState() calls, meaning that if you use a <base> tag, it's href value has to match this parameter (ignoring anything after the #).\nReturns\n​\n\nRouterHistory\n\nExample\n\njs\n// at https://example.com/folder\ncreateWebHashHistory() // gives a url of `https://example.com/folder#`\ncreateWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n// if the `#` is provided in the base, it won't be added by `createWebHashHistory`\ncreateWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n// you should avoid doing this because it changes the original url and breaks copying urls\ncreateWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n\n// at file:///usr/etc/folder/index.html\n// for locations with no `host`, the base is ignored\ncreateWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\ncreateWebHistory\n​\n\n▸ createWebHistory(base?): RouterHistory\n\nCreates an HTML5 history. Most common history for single page applications.\n\nParameters\n​\nName\tType\nbase?\tstring\nReturns\n​\n\nRouterHistory\n\nisNavigationFailure\n​\n\n▸ isNavigationFailure(error, type?): error is NavigationRedirectError\n\nCheck if an object is a NavigationFailure.\n\nParameters\n​\nName\tType\tDescription\nerror\tany\tpossible NavigationFailure\ntype?\tNAVIGATION_GUARD_REDIRECT\toptional types to check for\nReturns\n​\n\nerror is NavigationRedirectError\n\nExample\n\njs\nimport { isNavigationFailure, NavigationFailureType } from 'vue-router'\n\nrouter.afterEach((to, from, failure) => {\n  // Any kind of navigation failure\n  if (isNavigationFailure(failure)) {\n    // ...\n  }\n  // Only duplicated navigations\n  if (isNavigationFailure(failure, NavigationFailureType.duplicated)) {\n    // ...\n  }\n  // Aborted or canceled navigations\n  if (isNavigationFailure(failure, NavigationFailureType.aborted | NavigationFailureType.canceled)) {\n    // ...\n  }\n})\n\n▸ isNavigationFailure(error, type?): error is NavigationFailure\n\nParameters\n​\nName\tType\nerror\tany\ntype?\tErrorTypes | NavigationFailureType\nReturns\n​\n\nerror is NavigationFailure\n\nloadRouteLocation\n​\n\n▸ loadRouteLocation(route): Promise<RouteLocationNormalizedLoaded>\n\nEnsures a route is loaded, so it can be passed as o prop to <RouterView>.\n\nParameters\n​\nName\tType\tDescription\nroute\tRouteLocationNormalized\tresolved route to load\nReturns\n​\n\nPromise<RouteLocationNormalizedLoaded>\n\nonBeforeRouteLeave\n​\n\n▸ onBeforeRouteLeave(leaveGuard): void\n\nAdd a navigation guard that triggers whenever the component for the current location is about to be left. Similar to beforeRouteLeave but can be used in any component. The guard is removed when the component is unmounted.\n\nParameters\n​\nName\tType\tDescription\nleaveGuard\tNavigationGuard\tNavigationGuard\nReturns\n​\n\nvoid\n\nonBeforeRouteUpdate\n​\n\n▸ onBeforeRouteUpdate(updateGuard): void\n\nAdd a navigation guard that triggers whenever the current location is about to be updated. Similar to beforeRouteUpdate but can be used in any component. The guard is removed when the component is unmounted.\n\nParameters\n​\nName\tType\tDescription\nupdateGuard\tNavigationGuard\tNavigationGuard\nReturns\n​\n\nvoid\n\nuseLink\n​\n\n▸ useLink(props): Object\n\nParameters\n​\nName\tType\nprops\tVueUseOptions<RouterLinkOptions>\nReturns\n​\n\nObject\n\nName\tType\nhref\tComputedRef<string>\nisActive\tComputedRef<boolean>\nisExactActive\tComputedRef<boolean>\nnavigate\t(e: MouseEvent) => Promise<void | NavigationFailure>\nroute\tComputedRef<RouteLocation & { href: string }>\nuseRoute\n​\n\n▸ useRoute(): RouteLocationNormalizedLoaded\n\nReturns the current route location. Equivalent to using $route inside templates.\n\nReturns\n​\n\nRouteLocationNormalizedLoaded\n\nuseRouter\n​\n\n▸ useRouter(): Router\n\nReturns the router instance. Equivalent to using $router inside templates.\n\nReturns\n​\n\nRouter"
  },
  {
    "title": "Enumeration: NavigationFailureType | Vue Router",
    "url": "https://router.vuejs.org/api/enums/NavigationFailureType.html",
    "html": "API Documentation / NavigationFailureType\n\nEnumeration: NavigationFailureType\n​\n\nEnumeration with all possible types for navigation failures. Can be passed to isNavigationFailure to check for specific failures.\n\nEnumeration Members\n​\naborted\n​\n\n• aborted = 4\n\nAn aborted navigation is a navigation that failed because a navigation guard returned false or called next(false)\n\ncancelled\n​\n\n• cancelled = 8\n\nA cancelled navigation is a navigation that failed because a more recent navigation finished started (not necessarily finished).\n\nduplicated\n​\n\n• duplicated = 16\n\nA duplicated navigation is a navigation that failed because it was initiated while already being at the exact same location."
  }
]
