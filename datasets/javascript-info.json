[
  {
    "title": "Artem Beztsenniy",
    "url": "https://javascript.info/profile/artem-beztsenniy",
    "html": "Public profile\nCountry\nNetherlands\nCity\nAmsterdam\nInterests\nDesign, Web development, Hypothesis testing\nAbout\n\nUX Designer @ Booking.com"
  },
  {
    "title": "Sergey Zelenov",
    "url": "https://javascript.info/profile/sergey-zelenov",
    "html": "Public profile\nCountry\nGermany\nCity\nBerlin\nPublic email\ns.zelenov@javascript.info\nInterests\nNode.JS, Microservices, Algorithms, Functional Programming, ML\nAbout\n\nOne of core developers of this website.\n\nI have more than 9 years experience in software development. Last 6 years I have been working closely with Node.js.\n\nAt the moment I’m creating highloaded system for working with geo-data in Moovel using Node.js. As soon as system’s architecture is based on microservices, technology stack is not limited to Node.js; Python, Clojure, Java and Scala are also used in various projects.\n\nIn teaching process I’m focusing primarly on the practical aspects of writing qualitative, testable and reusable code.\n\nBirthdate\n29.11.1988"
  },
  {
    "title": "Browser: Document, Events, Interfaces",
    "url": "https://javascript.info/ui",
    "html": "Learning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.\n\nDocument\nIntroduction to Events\nUI Events\nForms, controls\nDocument and resource loading\nMiscellaneous"
  },
  {
    "title": "Ilya Kantor",
    "url": "https://javascript.info/profile/ilya-kantor",
    "html": "Ilya Kantor\nregistered 08.11.2017\nThe user decided not to tell any details"
  },
  {
    "title": "Methods of RegExp and String",
    "url": "https://javascript.info/regexp-methods",
    "html": "In this article we’ll cover various methods that work with regexps in-depth.\n\nstr.match(regexp)\n\nThe method str.match(regexp) finds matches for regexp in the string str.\n\nIt has 3 modes:\n\nIf the regexp doesn’t have flag g, then it returns the first match as an array with capturing groups and properties index (position of the match), input (input string, equals str):\n\n\t\nlet str = \"I love JavaScript\";\n\nlet result = str.match(/Java(Script)/);\n\nalert( result[0] );     // JavaScript (full match)\nalert( result[1] );     // Script (first capturing group)\nalert( result.length ); // 2\n\n// Additional information:\nalert( result.index );  // 7 (match position)\nalert( result.input );  // I love JavaScript (source string)\n\nIf the regexp has flag g, then it returns an array of all matches as strings, without capturing groups and other details.\n\n\t\nlet str = \"I love JavaScript\";\n\nlet result = str.match(/Java(Script)/g);\n\nalert( result[0] ); // JavaScript\nalert( result.length ); // 1\n\nIf there are no matches, no matter if there’s flag g or not, null is returned.\n\nThat’s an important nuance. If there are no matches, we don’t get an empty array, but null. It’s easy to make a mistake forgetting about it, e.g.:\n\n\t\nlet str = \"I love JavaScript\";\n\nlet result = str.match(/HTML/);\n\nalert(result); // null\nalert(result.length); // Error: Cannot read property 'length' of null\n\nIf we want the result to be an array, we can write like this:\n\nlet result = str.match(regexp) || [];\nstr.matchAll(regexp)\nA recent addition\nThis is a recent addition to the language. Old browsers may need polyfills.\n\nThe method str.matchAll(regexp) is a “newer, improved” variant of str.match.\n\nIt’s used mainly to search for all matches with all groups.\n\nThere are 3 differences from match:\n\nIt returns an iterable object with matches instead of an array. We can make a regular array from it using Array.from.\nEvery match is returned as an array with capturing groups (the same format as str.match without flag g).\nIf there are no results, it returns an empty iterable object instead of null.\n\nUsage example:\n\n\t\nlet str = '<h1>Hello, world!</h1>';\nlet regexp = /<(.*?)>/g;\n\nlet matchAll = str.matchAll(regexp);\n\nalert(matchAll); // [object RegExp String Iterator], not array, but an iterable\n\nmatchAll = Array.from(matchAll); // array now\n\nlet firstMatch = matchAll[0];\nalert( firstMatch[0] );  // <h1>\nalert( firstMatch[1] );  // h1\nalert( firstMatch.index );  // 0\nalert( firstMatch.input );  // <h1>Hello, world!</h1>\n\nIf we use for..of to loop over matchAll matches, then we don’t need Array.from any more.\n\nstr.split(regexp|substr, limit)\n\nSplits the string using the regexp (or a substring) as a delimiter.\n\nWe can use split with strings, like this:\n\n\t\nalert('12-34-56'.split('-')) // array of ['12', '34', '56']\n\nBut we can split by a regular expression, the same way:\n\n\t\nalert('12, 34, 56'.split(/,\\s*/)) // array of ['12', '34', '56']\nstr.search(regexp)\n\nThe method str.search(regexp) returns the position of the first match or -1 if none found:\n\n\t\nlet str = \"A drop of ink may make a million think\";\n\nalert( str.search( /ink/i ) ); // 10 (first match position)\n\nThe important limitation: search only finds the first match.\n\nIf we need positions of further matches, we should use other means, such as finding them all with str.matchAll(regexp).\n\nstr.replace(str|regexp, str|func)\n\nThis is a generic method for searching and replacing, one of most useful ones. The swiss army knife for searching and replacing.\n\nWe can use it without regexps, to search and replace a substring:\n\n\t\n// replace a dash by a colon\nalert('12-34-56'.replace(\"-\", \":\")) // 12:34-56\n\nThere’s a pitfall though.\n\nWhen the first argument of replace is a string, it only replaces the first match.\n\nYou can see that in the example above: only the first \"-\" is replaced by \":\".\n\nTo find all hyphens, we need to use not the string \"-\", but a regexp /-/g, with the obligatory g flag:\n\n\t\n// replace all dashes by a colon\nalert( '12-34-56'.replace( /-/g, \":\" ) )  // 12:34:56\n\nThe second argument is a replacement string. We can use special characters in it:\n\nSymbols\tAction in the replacement string\n$&\tinserts the whole match\n$`\tinserts a part of the string before the match\n$'\tinserts a part of the string after the match\n$n\tif n is a 1-2 digit number, inserts the contents of n-th capturing group, for details see Capturing groups\n$<name>\tinserts the contents of the parentheses with the given name, for details see Capturing groups\n$$\tinserts character $\n\nFor instance:\n\n\t\nlet str = \"John Smith\";\n\n// swap first and last name\nalert(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John\n\nFor situations that require “smart” replacements, the second argument can be a function.\n\nIt will be called for each match, and the returned value will be inserted as a replacement.\n\nThe function is called with arguments func(match, p1, p2, ..., pn, offset, input, groups):\n\nmatch – the match,\np1, p2, ..., pn – contents of capturing groups (if there are any),\noffset – position of the match,\ninput – the source string,\ngroups – an object with named groups.\n\nIf there are no parentheses in the regexp, then there are only 3 arguments: func(str, offset, input).\n\nFor example, let’s uppercase all matches:\n\n\t\nlet str = \"html and css\";\n\nlet result = str.replace(/html|css/gi, str => str.toUpperCase());\n\nalert(result); // HTML and CSS\n\nReplace each match by its position in the string:\n\n\t\nalert(\"Ho-Ho-ho\".replace(/ho/gi, (match, offset) => offset)); // 0-3-6\n\nIn the example below there are two parentheses, so the replacement function is called with 5 arguments: the first is the full match, then 2 parentheses, and after it (not used in the example) the match position and the source string:\n\n\t\nlet str = \"John Smith\";\n\nlet result = str.replace(/(\\w+) (\\w+)/, (match, name, surname) => `${surname}, ${name}`);\n\nalert(result); // Smith, John\n\nIf there are many groups, it’s convenient to use rest parameters to access them:\n\n\t\nlet str = \"John Smith\";\n\nlet result = str.replace(/(\\w+) (\\w+)/, (...match) => `${match[2]}, ${match[1]}`);\n\nalert(result); // Smith, John\n\nOr, if we’re using named groups, then groups object with them is always the last, so we can obtain it like this:\n\n\t\nlet str = \"John Smith\";\n\nlet result = str.replace(/(?<name>\\w+) (?<surname>\\w+)/, (...match) => {\n  let groups = match.pop();\n\n  return `${groups.surname}, ${groups.name}`;\n});\n\nalert(result); // Smith, John\n\nUsing a function gives us the ultimate replacement power, because it gets all the information about the match, has access to outer variables and can do everything.\n\nstr.replaceAll(str|regexp, str|func)\n\nThis method is essentially the same as str.replace, with two major differences:\n\nIf the first argument is a string, it replaces all occurrences of the string, while replace replaces only the first occurrence.\nIf the first argument is a regular expression without the g flag, there’ll be an error. With g flag, it works the same as replace.\n\nThe main use case for replaceAll is replacing all occurrences of a string.\n\nLike this:\n\n\t\n// replace all dashes by a colon\nalert('12-34-56'.replaceAll(\"-\", \":\")) // 12:34:56\nregexp.exec(str)\n\nThe regexp.exec(str) method returns a match for regexp in the string str. Unlike previous methods, it’s called on a regexp, not on a string.\n\nIt behaves differently depending on whether the regexp has flag g.\n\nIf there’s no g, then regexp.exec(str) returns the first match exactly as str.match(regexp). This behavior doesn’t bring anything new.\n\nBut if there’s flag g, then:\n\nA call to regexp.exec(str) returns the first match and saves the position immediately after it in the property regexp.lastIndex.\nThe next such call starts the search from position regexp.lastIndex, returns the next match and saves the position after it in regexp.lastIndex.\n…And so on.\nIf there are no matches, regexp.exec returns null and resets regexp.lastIndex to 0.\n\nSo, repeated calls return all matches one after another, using property regexp.lastIndex to keep track of the current search position.\n\nIn the past, before the method str.matchAll was added to JavaScript, calls of regexp.exec were used in the loop to get all matches with groups:\n\n\t\nlet str = 'More about JavaScript at https://javascript.info';\nlet regexp = /javascript/ig;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Found ${result[0]} at position ${result.index}` );\n  // Found JavaScript at position 11, then\n  // Found javascript at position 33\n}\n\nThis works now as well, although for newer browsers str.matchAll is usually more convenient.\n\nWe can use regexp.exec to search from a given position by manually setting lastIndex.\n\nFor instance:\n\n\t\nlet str = 'Hello, world!';\n\nlet regexp = /\\w+/g; // without flag \"g\", lastIndex property is ignored\nregexp.lastIndex = 5; // search from 5th position (from the comma)\n\nalert( regexp.exec(str) ); // world\n\nIf the regexp has flag y, then the search will be performed exactly at the position regexp.lastIndex, not any further.\n\nLet’s replace flag g with y in the example above. There will be no matches, as there’s no word at position 5:\n\n\t\nlet str = 'Hello, world!';\n\nlet regexp = /\\w+/y;\nregexp.lastIndex = 5; // search exactly at position 5\n\nalert( regexp.exec(str) ); // null\n\nThat’s convenient for situations when we need to “read” something from the string by a regexp at the exact position, not somewhere further.\n\nregexp.test(str)\n\nThe method regexp.test(str) looks for a match and returns true/false whether it exists.\n\nFor instance:\n\n\t\nlet str = \"I love JavaScript\";\n\n// these two tests do the same\nalert( /love/i.test(str) ); // true\nalert( str.search(/love/i) != -1 ); // true\n\nAn example with the negative answer:\n\n\t\nlet str = \"Bla-bla-bla\";\n\nalert( /love/i.test(str) ); // false\nalert( str.search(/love/i) != -1 ); // false\n\nIf the regexp has flag g, then regexp.test looks from regexp.lastIndex property and updates this property, just like regexp.exec.\n\nSo we can use it to search from a given position:\n\n\t\nlet regexp = /love/gi;\n\nlet str = \"I love JavaScript\";\n\n// start the search from position 10:\nregexp.lastIndex = 10;\nalert( regexp.test(str) ); // false (no match)\nSame global regexp tested repeatedly on different sources may fail\n\nIf we apply the same global regexp to different inputs, it may lead to wrong result, because regexp.test call advances regexp.lastIndex property, so the search in another string may start from non-zero position.\n\nFor instance, here we call regexp.test twice on the same text, and the second time fails:\n\n\t\nlet regexp = /javascript/g;  // (regexp just created: regexp.lastIndex=0)\n\nalert( regexp.test(\"javascript\") ); // true (regexp.lastIndex=10 now)\nalert( regexp.test(\"javascript\") ); // false\n\nThat’s exactly because regexp.lastIndex is non-zero in the second test.\n\nTo work around that, we can set regexp.lastIndex = 0 before each search. Or instead of calling methods on regexp, use string methods str.match/search/..., they don’t use lastIndex."
  },
  {
    "title": "Sticky flag \"y\", searching at position",
    "url": "https://javascript.info/regexp-sticky",
    "html": "The flag y allows to perform the search at the given position in the source string.\n\nTo grasp the use case of y flag, and better understand the ways of regexps, let’s explore a practical example.\n\nOne of common tasks for regexps is “lexical analysis”: we get a text, e.g. in a programming language, and need to find its structural elements. For instance, HTML has tags and attributes, JavaScript code has functions, variables, and so on.\n\nWriting lexical analyzers is a special area, with its own tools and algorithms, so we don’t go deep in there, but there’s a common task: to read something at the given position.\n\nE.g. we have a code string let varName = \"value\", and we need to read the variable name from it, that starts at position 4.\n\nWe’ll look for variable name using regexp \\w+. Actually, JavaScript variable names need a bit more complex regexp for accurate matching, but here it doesn’t matter.\n\nA call to str.match(/\\w+/) will find only the first word in the line (let). That’s not it.\nWe can add the flag g. But then the call str.match(/\\w+/g) will look for all words in the text, while we need one word at position 4. Again, not what we need.\n\nSo, how to search for a regexp exactly at the given position?\n\nLet’s try using method regexp.exec(str).\n\nFor a regexp without flags g and y, this method looks only for the first match, it works exactly like str.match(regexp).\n\n…But if there’s flag g, then it performs the search in str, starting from position stored in the regexp.lastIndex property. And, if it finds a match, then sets regexp.lastIndex to the index immediately after the match.\n\nIn other words, regexp.lastIndex serves as a starting point for the search, that each regexp.exec(str) call resets to the new value (“after the last match”). That’s only if there’s g flag, of course.\n\nSo, successive calls to regexp.exec(str) return matches one after another.\n\nHere’s an example of such calls:\n\n\t\nlet str = 'let varName'; // Let's find all words in this string\nlet regexp = /\\w+/g;\n\nalert(regexp.lastIndex); // 0 (initially lastIndex=0)\n\nlet word1 = regexp.exec(str);\nalert(word1[0]); // let (1st word)\nalert(regexp.lastIndex); // 3 (position after the match)\n\nlet word2 = regexp.exec(str);\nalert(word2[0]); // varName (2nd word)\nalert(regexp.lastIndex); // 11 (position after the match)\n\nlet word3 = regexp.exec(str);\nalert(word3); // null (no more matches)\nalert(regexp.lastIndex); // 0 (resets at search end)\n\nWe can get all matches in the loop:\n\n\t\nlet str = 'let varName';\nlet regexp = /\\w+/g;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n  alert( `Found ${result[0]} at position ${result.index}` );\n  // Found let at position 0, then\n  // Found varName at position 4\n}\n\nSuch use of regexp.exec is an alternative to method str.matchAll, with a bit more control over the process.\n\nLet’s go back to our task.\n\nWe can manually set lastIndex to 4, to start the search from the given position!\n\nLike this:\n\n\t\nlet str = 'let varName = \"value\"';\n\nlet regexp = /\\w+/g; // without flag \"g\", property lastIndex is ignored\n\nregexp.lastIndex = 4;\n\nlet word = regexp.exec(str);\nalert(word); // varName\n\nHooray! Problem solved!\n\nWe performed a search of \\w+, starting from position regexp.lastIndex = 4.\n\nThe result is correct.\n\n…But wait, not so fast.\n\nPlease note: the regexp.exec call starts searching at position lastIndex and then goes further. If there’s no word at position lastIndex, but it’s somewhere after it, then it will be found:\n\n\t\nlet str = 'let varName = \"value\"';\n\nlet regexp = /\\w+/g;\n\n// start the search from position 3\nregexp.lastIndex = 3;\n\nlet word = regexp.exec(str);\n// found the match at position 4\nalert(word[0]); // varName\nalert(word.index); // 4\n\nFor some tasks, including the lexical analysis, that’s just wrong. We need to find a match exactly at the given position at the text, not somewhere after it. And that’s what the flag y is for.\n\nThe flag y makes regexp.exec to search exactly at position lastIndex, not “starting from” it.\n\nHere’s the same search with flag y:\n\n\t\nlet str = 'let varName = \"value\"';\n\nlet regexp = /\\w+/y;\n\nregexp.lastIndex = 3;\nalert( regexp.exec(str) ); // null (there's a space at position 3, not a word)\n\nregexp.lastIndex = 4;\nalert( regexp.exec(str) ); // varName (word at position 4)\n\nAs we can see, regexp /\\w+/y doesn’t match at position 3 (unlike the flag g), but matches at position 4.\n\nNot only that’s what we need, there’s an important performance gain when using flag y.\n\nImagine, we have a long text, and there are no matches in it, at all. Then a search with flag g will go till the end of the text and find nothing, and this will take significantly more time than the search with flag y, that checks only the exact position.\n\nIn tasks like lexical analysis, there are usually many searches at an exact position, to check what we have there. Using flag y is the key for correct implementations and a good performance."
  },
  {
    "title": "Catastrophic backtracking",
    "url": "https://javascript.info/regexp-catastrophic-backtracking",
    "html": "Some regular expressions are looking simple, but can execute a veeeeeery long time, and even “hang” the JavaScript engine.\n\nSooner or later most developers occasionally face such behavior. The typical symptom – a regular expression works fine sometimes, but for certain strings it “hangs”, consuming 100% of CPU.\n\nIn such case a web-browser suggests to kill the script and reload the page. Not a good thing for sure.\n\nFor server-side JavaScript such a regexp may hang the server process, that’s even worse. So we definitely should take a look at it.\n\nExample\n\nLet’s say we have a string, and we’d like to check if it consists of words \\w+ with an optional space \\s? after each.\n\nAn obvious way to construct a regexp would be to take a word followed by an optional space \\w+\\s? and then repeat it with *.\n\nThat leads us to the regexp ^(\\w+\\s?)*$, it specifies zero or more such words, that start at the beginning ^ and finish at the end $ of the line.\n\nIn action:\n\n\t\nlet regexp = /^(\\w+\\s?)*$/;\n\nalert( regexp.test(\"A good string\") ); // true\nalert( regexp.test(\"Bad characters: $@#\") ); // false\n\nThe regexp seems to work. The result is correct. Although, on certain strings it takes a lot of time. So long that JavaScript engine “hangs” with 100% CPU consumption.\n\nIf you run the example below, you probably won’t see anything, as JavaScript will just “hang”. A web-browser will stop reacting on events, the UI will stop working (most browsers allow only scrolling). After some time it will suggest to reload the page. So be careful with this:\n\n\t\nlet regexp = /^(\\w+\\s?)*$/;\nlet str = \"An input string that takes a long time or even makes this regexp hang!\";\n\n// will take a very long time\nalert( regexp.test(str) );\n\nTo be fair, let’s note that some regular expression engines can handle such a search effectively, for example V8 engine version starting from 8.8 can do that (so Google Chrome 88 doesn’t hang here), while Firefox browser does hang.\n\nSimplified example\n\nWhat’s the matter? Why does the regular expression hang?\n\nTo understand that, let’s simplify the example: remove spaces \\s?. Then it becomes ^(\\w+)*$.\n\nAnd, to make things more obvious, let’s replace \\w with \\d. The resulting regular expression still hangs, for instance:\n\n\t\nlet regexp = /^(\\d+)*$/;\n\nlet str = \"012345678901234567890123456789z\";\n\n// will take a very long time (careful!)\nalert( regexp.test(str) );\n\nSo what’s wrong with the regexp?\n\nFirst, one may notice that the regexp (\\d+)* is a little bit strange. The quantifier * looks extraneous. If we want a number, we can use \\d+.\n\nIndeed, the regexp is artificial; we got it by simplifying the previous example. But the reason why it is slow is the same. So let’s understand it, and then the previous example will become obvious.\n\nWhat happens during the search of ^(\\d+)*$ in the line 123456789z (shortened a bit for clarity, please note a non-digit character z at the end, it’s important), why does it take so long?\n\nHere’s what the regexp engine does:\n\nFirst, the regexp engine tries to find the content of the parentheses: the number \\d+. The plus + is greedy by default, so it consumes all digits:\n\n\\d+.......\n(123456789)z\n\nAfter all digits are consumed, \\d+ is considered found (as 123456789).\n\nThen the star quantifier (\\d+)* applies. But there are no more digits in the text, so the star doesn’t give anything.\n\nThe next character in the pattern is the string end $. But in the text we have z instead, so there’s no match:\n\n           X\n\\d+........$\n(123456789)z\n\nAs there’s no match, the greedy quantifier + decreases the count of repetitions, backtracks one character back.\n\nNow \\d+ takes all digits except the last one (12345678):\n\n\\d+.......\n(12345678)9z\n\nThen the engine tries to continue the search from the next position (right after 12345678).\n\nThe star (\\d+)* can be applied – it gives one more match of \\d+, the number 9:\n\n\\d+.......\\d+\n(12345678)(9)z\n\nThe engine tries to match $ again, but fails, because it meets z instead:\n\n             X\n\\d+.......\\d+\n(12345678)(9)z\n\nThere’s no match, so the engine will continue backtracking, decreasing the number of repetitions. Backtracking generally works like this: the last greedy quantifier decreases the number of repetitions until it reaches the minimum. Then the previous greedy quantifier decreases, and so on.\n\nAll possible combinations are attempted. Here are their examples.\n\nThe first number \\d+ has 7 digits, and then a number of 2 digits:\n\n             X\n\\d+......\\d+\n(1234567)(89)z\n\nThe first number has 7 digits, and then two numbers of 1 digit each:\n\n               X\n\\d+......\\d+\\d+\n(1234567)(8)(9)z\n\nThe first number has 6 digits, and then a number of 3 digits:\n\n             X\n\\d+.......\\d+\n(123456)(789)z\n\nThe first number has 6 digits, and then 2 numbers:\n\n               X\n\\d+.....\\d+ \\d+\n(123456)(78)(9)z\n\n…And so on.\n\nThere are many ways to split a sequence of digits 123456789 into numbers. To be precise, there are 2n-1, where n is the length of the sequence.\n\nFor 123456789 we have n=9, that gives 511 combinations.\nFor a longer sequence with n=20 there are about one million (1048575) combinations.\nFor n=30 – a thousand times more (1073741823 combinations).\n\nTrying each of them is exactly the reason why the search takes so long.\n\nBack to words and strings\n\nThe similar thing happens in our first example, when we look for words by pattern ^(\\w+\\s?)*$ in the string An input that hangs!.\n\nThe reason is that a word can be represented as one \\w+ or many:\n\n(input)\n(inpu)(t)\n(inp)(u)(t)\n(in)(p)(ut)\n...\n\nFor a human, it’s obvious that there may be no match, because the string ends with an exclamation sign !, but the regular expression expects a wordly character \\w or a space \\s at the end. But the engine doesn’t know that.\n\nIt tries all combinations of how the regexp (\\w+\\s?)* can “consume” the string, including variants with spaces (\\w+\\s)* and without them (\\w+)* (because spaces \\s? are optional). As there are many such combinations (we’ve seen it with digits), the search takes a lot of time.\n\nWhat to do?\n\nShould we turn on the lazy mode?\n\nUnfortunately, that won’t help: if we replace \\w+ with \\w+?, the regexp will still hang. The order of combinations will change, but not their total count.\n\nSome regular expression engines have tricky tests and finite automations that allow to avoid going through all combinations or make it much faster, but most engines don’t, and it doesn’t always help.\n\nHow to fix?\n\nThere are two main approaches to fixing the problem.\n\nThe first is to lower the number of possible combinations.\n\nLet’s make the space non-optional by rewriting the regular expression as ^(\\w+\\s)*\\w*$ – we’ll look for any number of words followed by a space (\\w+\\s)*, and then (optionally) a final word \\w*.\n\nThis regexp is equivalent to the previous one (matches the same) and works well:\n\n\t\nlet regexp = /^(\\w+\\s)*\\w*$/;\nlet str = \"An input string that takes a long time or even makes this regex hang!\";\n\nalert( regexp.test(str) ); // false\n\nWhy did the problem disappear?\n\nThat’s because now the space is mandatory.\n\nThe previous regexp, if we omit the space, becomes (\\w+)*, leading to many combinations of \\w+ within a single word\n\nSo input could be matched as two repetitions of \\w+, like this:\n\n\\w+  \\w+\n(inp)(ut)\n\nThe new pattern is different: (\\w+\\s)* specifies repetitions of words followed by a space! The input string can’t be matched as two repetitions of \\w+\\s, because the space is mandatory.\n\nThe time needed to try a lot of (actually most of) combinations is now saved.\n\nPreventing backtracking\n\nIt’s not always convenient to rewrite a regexp though. In the example above it was easy, but it’s not always obvious how to do it.\n\nBesides, a rewritten regexp is usually more complex, and that’s not good. Regexps are complex enough without extra efforts.\n\nLuckily, there’s an alternative approach. We can forbid backtracking for the quantifier.\n\nThe root of the problem is that the regexp engine tries many combinations that are obviously wrong for a human.\n\nE.g. in the regexp (\\d+)*$ it’s obvious for a human, that + shouldn’t backtrack. If we replace one \\d+ with two separate \\d+\\d+, nothing changes:\n\n\\d+........\n(123456789)!\n\n\\d+...\\d+....\n(1234)(56789)!\n\nAnd in the original example ^(\\w+\\s?)*$ we may want to forbid backtracking in \\w+. That is: \\w+ should match a whole word, with the maximal possible length. There’s no need to lower the repetitions count in \\w+ or to split it into two words \\w+\\w+ and so on.\n\nModern regular expression engines support possessive quantifiers for that. Regular quantifiers become possessive if we add + after them. That is, we use \\d++ instead of \\d+ to stop + from backtracking.\n\nPossessive quantifiers are in fact simpler than “regular” ones. They just match as many as they can, without any backtracking. The search process without backtracking is simpler.\n\nThere are also so-called “atomic capturing groups” – a way to disable backtracking inside parentheses.\n\n…But the bad news is that, unfortunately, in JavaScript they are not supported.\n\nWe can emulate them though using a “lookahead transform”.\n\nLookahead to the rescue!\n\nSo we’ve come to real advanced topics. We’d like a quantifier, such as + not to backtrack, because sometimes backtracking makes no sense.\n\nThe pattern to take as many repetitions of \\w as possible without backtracking is: (?=(\\w+))\\1. Of course, we could take another pattern instead of \\w.\n\nThat may seem odd, but it’s actually a very simple transform.\n\nLet’s decipher it:\n\nLookahead ?= looks forward for the longest word \\w+ starting at the current position.\nThe contents of parentheses with ?=... isn’t memorized by the engine, so wrap \\w+ into parentheses. Then the engine will memorize their contents\n…And allow us to reference it in the pattern as \\1.\n\nThat is: we look ahead – and if there’s a word \\w+, then match it as \\1.\n\nWhy? That’s because the lookahead finds a word \\w+ as a whole and we capture it into the pattern with \\1. So we essentially implemented a possessive plus + quantifier. It captures only the whole word \\w+, not a part of it.\n\nFor instance, in the word JavaScript it may not only match Java, but leave out Script to match the rest of the pattern.\n\nHere’s the comparison of two patterns:\n\n\t\nalert( \"JavaScript\".match(/\\w+Script/)); // JavaScript\nalert( \"JavaScript\".match(/(?=(\\w+))\\1Script/)); // null\nIn the first variant \\w+ first captures the whole word JavaScript but then + backtracks character by character, to try to match the rest of the pattern, until it finally succeeds (when \\w+ matches Java).\nIn the second variant (?=(\\w+)) looks ahead and finds the word JavaScript, that is included into the pattern as a whole by \\1, so there remains no way to find Script after it.\n\nWe can put a more complex regular expression into (?=(\\w+))\\1 instead of \\w, when we need to forbid backtracking for + after it.\n\nPlease note:\n\nThere’s more about the relation between possessive quantifiers and lookahead in articles Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead and Mimicking Atomic Groups.\n\nLet’s rewrite the first example using lookahead to prevent backtracking:\n\n\t\nlet regexp = /^((?=(\\w+))\\2\\s?)*$/;\n\nalert( regexp.test(\"A good string\") ); // true\n\nlet str = \"An input string that takes a long time or even makes this regex hang!\";\n\nalert( regexp.test(str) ); // false, works and fast!\n\nHere \\2 is used instead of \\1, because there are additional outer parentheses. To avoid messing up with the numbers, we can give the parentheses a name, e.g. (?<word>\\w+).\n\n\t\n// parentheses are named ?<word>, referenced as \\k<word>\nlet regexp = /^((?=(?<word>\\w+))\\k<word>\\s?)*$/;\n\nlet str = \"An input string that takes a long time or even makes this regex hang!\";\n\nalert( regexp.test(str) ); // false\n\nalert( regexp.test(\"A correct string\") ); // true\n\nThe problem described in this article is called “catastrophic backtracking”.\n\nWe covered two ways how to solve it:\n\nRewrite the regexp to lower the possible combinations count.\nPrevent backtracking."
  },
  {
    "title": "Greedy and lazy quantifiers",
    "url": "https://javascript.info/regexp-greedy-and-lazy",
    "html": "Quantifiers are very simple from the first sight, but in fact they can be tricky.\n\nWe should understand how the search works very well if we plan to look for something more complex than /\\d+/.\n\nLet’s take the following task as an example.\n\nWe have a text and need to replace all quotes \"...\" with guillemet marks: «...». They are preferred for typography in many countries.\n\nFor instance: \"Hello, world\" should become «Hello, world». There exist other quotes, such as „Witaj, świecie!” (Polish) or 「你好，世界」 (Chinese), but for our task let’s choose «...».\n\nThe first thing to do is to locate quoted strings, and then we can replace them.\n\nA regular expression like /\".+\"/g (a quote, then something, then the other quote) may seem like a good fit, but it isn’t!\n\nLet’s try it:\n\n\t\nlet regexp = /\".+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(regexp) ); // \"witch\" and her \"broom\"\n\n…We can see that it works not as intended!\n\nInstead of finding two matches \"witch\" and \"broom\", it finds one: \"witch\" and her \"broom\".\n\nThat can be described as “greediness is the cause of all evil”.\n\nGreedy search\n\nTo find a match, the regular expression engine uses the following algorithm:\n\nFor every position in the string\nTry to match the pattern at that position.\nIf there’s no match, go to the next position.\n\nThese common words do not make it obvious why the regexp fails, so let’s elaborate how the search works for the pattern \".+\".\n\nThe first pattern character is a quote \".\n\nThe regular expression engine tries to find it at the zero position of the source string a \"witch\" and her \"broom\" is one, but there’s a there, so there’s immediately no match.\n\nThen it advances: goes to the next positions in the source string and tries to find the first character of the pattern there, fails again, and finally finds the quote at the 3rd position:\n\nThe quote is detected, and then the engine tries to find a match for the rest of the pattern. It tries to see if the rest of the subject string conforms to .+\".\n\nIn our case the next pattern character is . (a dot). It denotes “any character except a newline”, so the next string letter 'w' fits:\n\nThen the dot repeats because of the quantifier .+. The regular expression engine adds to the match one character after another.\n\n…Until when? All characters match the dot, so it only stops when it reaches the end of the string:\n\nNow the engine finished repeating .+ and tries to find the next character of the pattern. It’s the quote \". But there’s a problem: the string has finished, there are no more characters!\n\nThe regular expression engine understands that it took too many .+ and starts to backtrack.\n\nIn other words, it shortens the match for the quantifier by one character:\n\nNow it assumes that .+ ends one character before the string end and tries to match the rest of the pattern from that position.\n\nIf there were a quote there, then the search would end, but the last character is 'e', so there’s no match.\n\n…So the engine decreases the number of repetitions of .+ by one more character:\n\nThe quote '\"' does not match 'n'.\n\nThe engine keep backtracking: it decreases the count of repetition for '.' until the rest of the pattern (in our case '\"') matches:\n\nThe match is complete.\n\nSo the first match is \"witch\" and her \"broom\". If the regular expression has flag g, then the search will continue from where the first match ends. There are no more quotes in the rest of the string is one, so no more results.\n\nThat’s probably not what we expected, but that’s how it works.\n\nIn the greedy mode (by default) a quantified character is repeated as many times as possible.\n\nThe regexp engine adds to the match as many characters as it can for .+, and then shortens that one by one, if the rest of the pattern doesn’t match.\n\nFor our task we want another thing. That’s where a lazy mode can help.\n\nLazy mode\n\nThe lazy mode of quantifiers is an opposite to the greedy mode. It means: “repeat minimal number of times”.\n\nWe can enable it by putting a question mark '?' after the quantifier, so that it becomes *? or +? or even ?? for '?'.\n\nTo make things clear: usually a question mark ? is a quantifier by itself (zero or one), but if added after another quantifier (or even itself) it gets another meaning – it switches the matching mode from greedy to lazy.\n\nThe regexp /\".+?\"/g works as intended: it finds \"witch\" and \"broom\":\n\n\t\nlet regexp = /\".+?\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(regexp) ); // \"witch\", \"broom\"\n\nTo clearly understand the change, let’s trace the search step by step.\n\nThe first step is the same: it finds the pattern start '\"' at the 3rd position:\n\nThe next step is also similar: the engine finds a match for the dot '.':\n\nAnd now the search goes differently. Because we have a lazy mode for +?, the engine doesn’t try to match a dot one more time, but stops and tries to match the rest of the pattern '\"' right now:\n\nIf there were a quote there, then the search would end, but there’s 'i', so there’s no match.\n\nThen the regular expression engine increases the number of repetitions for the dot and tries one more time:\n\nFailure again. Then the number of repetitions is increased again and again…\n\n…Till the match for the rest of the pattern is found:\n\nThe next search starts from the end of the current match and yield one more result:\n\nIn this example we saw how the lazy mode works for +?. Quantifiers *? and ?? work the similar way – the regexp engine increases the number of repetitions only if the rest of the pattern can’t match on the given position.\n\nLaziness is only enabled for the quantifier with ?.\n\nOther quantifiers remain greedy.\n\nFor instance:\n\n\t\nalert( \"123 456\".match(/\\d+ \\d+?/) ); // 123 4\n\nThe pattern \\d+ tries to match as many digits as it can (greedy mode), so it finds 123 and stops, because the next character is a space ' '.\n\nThen there’s a space in the pattern, it matches.\n\nThen there’s \\d+?. The quantifier is in lazy mode, so it finds one digit 4 and tries to check if the rest of the pattern matches from there.\n\n…But there’s nothing in the pattern after \\d+?.\n\nThe lazy mode doesn’t repeat anything without a need. The pattern finished, so we’re done. We have a match 123 4.\n\nOptimizations\n\nModern regular expression engines can optimize internal algorithms to work faster. So they may work a bit differently from the described algorithm.\n\nBut to understand how regular expressions work and to build regular expressions, we don’t need to know about that. They are only used internally to optimize things.\n\nComplex regular expressions are hard to optimize, so the search may work exactly as described as well.\n\nAlternative approach\n\nWith regexps, there’s often more than one way to do the same thing.\n\nIn our case we can find quoted strings without lazy mode using the regexp \"[^\"]+\":\n\n\t\nlet regexp = /\"[^\"]+\"/g;\n\nlet str = 'a \"witch\" and her \"broom\" is one';\n\nalert( str.match(regexp) ); // \"witch\", \"broom\"\n\nThe regexp \"[^\"]+\" gives correct results, because it looks for a quote '\"' followed by one or more non-quotes [^\"], and then the closing quote.\n\nWhen the regexp engine looks for [^\"]+ it stops the repetitions when it meets the closing quote, and we’re done.\n\nPlease note, that this logic does not replace lazy quantifiers!\n\nIt is just different. There are times when we need one or another.\n\nLet’s see an example where lazy quantifiers fail and this variant works right.\n\nFor instance, we want to find links of the form <a href=\"...\" class=\"doc\">, with any href.\n\nWhich regular expression to use?\n\nThe first idea might be: /<a href=\".*\" class=\"doc\">/g.\n\nLet’s check it:\n\n\t\nlet str = '...<a href=\"link\" class=\"doc\">...';\nlet regexp = /<a href=\".*\" class=\"doc\">/g;\n\n// Works!\nalert( str.match(regexp) ); // <a href=\"link\" class=\"doc\">\n\nIt worked. But let’s see what happens if there are many links in the text?\n\n\t\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet regexp = /<a href=\".*\" class=\"doc\">/g;\n\n// Whoops! Two links in one match!\nalert( str.match(regexp) ); // <a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n\nNow the result is wrong for the same reason as our “witches” example. The quantifier .* took too many characters.\n\nThe match looks like this:\n\n<a href=\".....................................\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n\nLet’s modify the pattern by making the quantifier .*? lazy:\n\n\t\nlet str = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet regexp = /<a href=\".*?\" class=\"doc\">/g;\n\n// Works!\nalert( str.match(regexp) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\n\nNow it seems to work, there are two matches:\n\n<a href=\".....\" class=\"doc\">    <a href=\".....\" class=\"doc\">\n<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">\n\n…But let’s test it on one more text input:\n\n\t\nlet str = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet regexp = /<a href=\".*?\" class=\"doc\">/g;\n\n// Wrong match!\nalert( str.match(regexp) ); // <a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n\nNow it fails. The match includes not just a link, but also a lot of text after it, including <p...>.\n\nWhy?\n\nThat’s what’s going on:\n\nFirst the regexp finds a link start <a href=\".\nThen it looks for .*?: takes one character (lazily!), check if there’s a match for \" class=\"doc\"> (none).\nThen takes another character into .*?, and so on… until it finally reaches \" class=\"doc\">.\n\nBut the problem is: that’s already beyond the link <a...>, in another tag <p>. Not what we want.\n\nHere’s the picture of the match aligned with the text:\n\n<a href=\"...................................\" class=\"doc\">\n<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">\n\nSo, we need the pattern to look for <a href=\"...something...\" class=\"doc\">, but both greedy and lazy variants have problems.\n\nThe correct variant can be: href=\"[^\"]*\". It will take all characters inside the href attribute till the nearest quote, just what we need.\n\nA working example:\n\n\t\nlet str1 = '...<a href=\"link1\" class=\"wrong\">... <p style=\"\" class=\"doc\">...';\nlet str2 = '...<a href=\"link1\" class=\"doc\">... <a href=\"link2\" class=\"doc\">...';\nlet regexp = /<a href=\"[^\"]*\" class=\"doc\">/g;\n\n// Works!\nalert( str1.match(regexp) ); // null, no matches, that's correct\nalert( str2.match(regexp) ); // <a href=\"link1\" class=\"doc\">, <a href=\"link2\" class=\"doc\">\nSummary\n\nQuantifiers have two modes of work:\n\nGreedy\nBy default the regular expression engine tries to repeat the quantified character as many times as possible. For instance, \\d+ consumes all possible digits. When it becomes impossible to consume more (no more digits or string end), then it continues to match the rest of the pattern. If there’s no match then it decreases the number of repetitions (backtracks) and tries again.\nLazy\nEnabled by the question mark ? after the quantifier. The regexp engine tries to match the rest of the pattern before each repetition of the quantified character.\n\nAs we’ve seen, the lazy mode is not a “panacea” from the greedy search. An alternative is a “fine-tuned” greedy search, with exclusions, as in the pattern \"[^\"]+\".\n\nTasks\nA match for /d+? d+?/\n\nWhat’s the match here?\n\nalert( \"123 456\".match(/\\d+? \\d+?/g) ); // ?\nsolution\nFind HTML comments\n\nFind all HTML comments in the text:\n\nlet regexp = /your regexp/g;\n\nlet str = `... <!-- My -- comment\n test --> ..  <!----> ..\n`;\n\nalert( str.match(regexp) ); // '<!-- My -- comment \\n test -->', '<!---->'\nsolution\nFind HTML tags\n\nCreate a regular expression to find all (opening and closing) HTML tags with their attributes.\n\nAn example of use:\n\n\t\nlet regexp = /your regexp/g;\n\nlet str = '<> <a href=\"/\"> <input type=\"radio\" checked> <b>';\n\nalert( str.match(regexp) ); // '<a href=\"/\">', '<input type=\"radio\" checked>', '<b>'\n\nHere we assume that tag attributes may not contain < and > (inside quotes too), that simplifies things a bit.\n\nsolution"
  },
  {
    "title": "Lookahead and lookbehind",
    "url": "https://javascript.info/regexp-lookahead-lookbehind",
    "html": "Sometimes we need to find only those matches for a pattern that are followed or preceded by another pattern.\n\nThere’s a special syntax for that, called “lookahead” and “lookbehind”, together referred to as “lookaround”.\n\nFor the start, let’s find the price from the string like 1 turkey costs 30€. That is: a number, followed by € sign.\n\nLookahead\n\nThe syntax is: X(?=Y), it means \"look for X, but match only if followed by Y\". There may be any pattern instead of X and Y.\n\nFor an integer number followed by €, the regexp will be \\d+(?=€):\n\n\t\nlet str = \"1 turkey costs 30€\";\n\nalert( str.match(/\\d+(?=€)/) ); // 30, the number 1 is ignored, as it's not followed by €\n\nPlease note: the lookahead is merely a test, the contents of the parentheses (?=...) is not included in the result 30.\n\nWhen we look for X(?=Y), the regular expression engine finds X and then checks if there’s Y immediately after it. If it’s not so, then the potential match is skipped, and the search continues.\n\nMore complex tests are possible, e.g. X(?=Y)(?=Z) means:\n\nFind X.\nCheck if Y is immediately after X (skip if isn’t).\nCheck if Z is also immediately after X (skip if isn’t).\nIf both tests passed, then the X is a match, otherwise continue searching.\n\nIn other words, such pattern means that we’re looking for X followed by Y and Z at the same time.\n\nThat’s only possible if patterns Y and Z aren’t mutually exclusive.\n\nFor example, \\d+(?=\\s)(?=.*30) looks for \\d+ that is followed by a space (?=\\s), and there’s 30 somewhere after it (?=.*30):\n\n\t\nlet str = \"1 turkey costs 30€\";\n\nalert( str.match(/\\d+(?=\\s)(?=.*30)/) ); // 1\n\nIn our string that exactly matches the number 1.\n\nNegative lookahead\n\nLet’s say that we want a quantity instead, not a price from the same string. That’s a number \\d+, NOT followed by €.\n\nFor that, a negative lookahead can be applied.\n\nThe syntax is: X(?!Y), it means \"search X, but only if not followed by Y\".\n\n\t\nlet str = \"2 turkeys cost 60€\";\n\nalert( str.match(/\\d+\\b(?!€)/g) ); // 2 (the price is not matched)\nLookbehind\nLookbehind browser compatibility\n\nPlease Note: Lookbehind is not supported in non-V8 browsers, such as Safari, Internet Explorer.\n\nLookahead allows to add a condition for “what follows”.\n\nLookbehind is similar, but it looks behind. That is, it allows to match a pattern only if there’s something before it.\n\nThe syntax is:\n\nPositive lookbehind: (?<=Y)X, matches X, but only if there’s Y before it.\nNegative lookbehind: (?<!Y)X, matches X, but only if there’s no Y before it.\n\nFor example, let’s change the price to US dollars. The dollar sign is usually before the number, so to look for $30 we’ll use (?<=\\$)\\d+ – an amount preceded by $:\n\n\t\nlet str = \"1 turkey costs $30\";\n\n// the dollar sign is escaped \\$\nalert( str.match(/(?<=\\$)\\d+/) ); // 30 (skipped the sole number)\n\nAnd, if we need the quantity – a number, not preceded by $, then we can use a negative lookbehind (?<!\\$)\\d+:\n\n\t\nlet str = \"2 turkeys cost $60\";\n\nalert( str.match(/(?<!\\$)\\b\\d+/g) ); // 2 (the price is not matched)\nCapturing groups\n\nGenerally, the contents inside lookaround parentheses does not become a part of the result.\n\nE.g. in the pattern \\d+(?=€), the € sign doesn’t get captured as a part of the match. That’s natural: we look for a number \\d+, while (?=€) is just a test that it should be followed by €.\n\nBut in some situations we might want to capture the lookaround expression as well, or a part of it. That’s possible. Just wrap that part into additional parentheses.\n\nIn the example below the currency sign (€|kr) is captured, along with the amount:\n\n\t\nlet str = \"1 turkey costs 30€\";\nlet regexp = /\\d+(?=(€|kr))/; // extra parentheses around €|kr\n\nalert( str.match(regexp) ); // 30, €\n\nAnd here’s the same for lookbehind:\n\n\t\nlet str = \"1 turkey costs $30\";\nlet regexp = /(?<=(\\$|£))\\d+/;\n\nalert( str.match(regexp) ); // 30, $\nSummary\n\nLookahead and lookbehind (commonly referred to as “lookaround”) are useful when we’d like to match something depending on the context before/after it.\n\nFor simple regexps we can do the similar thing manually. That is: match everything, in any context, and then filter by context in the loop.\n\nRemember, str.match (without flag g) and str.matchAll (always) return matches as arrays with index property, so we know where exactly in the text it is, and can check the context.\n\nBut generally lookaround is more convenient.\n\nLookaround types:\n\nPattern\ttype\tmatches\nX(?=Y)\tPositive lookahead\tX if followed by Y\nX(?!Y)\tNegative lookahead\tX if not followed by Y\n(?<=Y)X\tPositive lookbehind\tX if after Y\n(?<!Y)X\tNegative lookbehind\tX if not after Y\nTasks\nFind non-negative integers\n\nThere’s a string of integer numbers.\n\nCreate a regexp that looks for only non-negative ones (zero is allowed).\n\nAn example of use:\n\nlet regexp = /your regexp/g;\n\nlet str = \"0 12 -5 123 -18\";\n\nalert( str.match(regexp) ); // 0, 12, 123\nsolution\nInsert After Head\n\nWe have a string with an HTML Document.\n\nWrite a regular expression that inserts <h1>Hello</h1> immediately after <body> tag. The tag may have attributes.\n\nFor instance:\n\nlet regexp = /your regular expression/;\n\nlet str = `\n<html>\n  <body style=\"height: 200px\">\n  ...\n  </body>\n</html>\n`;\n\nstr = str.replace(regexp, `<h1>Hello</h1>`);\n\nAfter that the value of str should be:\n\n<html>\n  <body style=\"height: 200px\"><h1>Hello</h1>\n  ...\n  </body>\n</html>\nsolution"
  },
  {
    "title": "Alternation (OR) |",
    "url": "https://javascript.info/regexp-alternation",
    "html": "Alternation is the term in regular expression that is actually a simple “OR”.\n\nIn a regular expression it is denoted with a vertical line character |.\n\nFor instance, we need to find programming languages: HTML, PHP, Java or JavaScript.\n\nThe corresponding regexp: html|php|java(script)?.\n\nA usage example:\n\n\t\nlet regexp = /html|php|css|java(script)?/gi;\n\nlet str = \"First HTML appeared, then CSS, then JavaScript\";\n\nalert( str.match(regexp) ); // 'HTML', 'CSS', 'JavaScript'\n\nWe already saw a similar thing – square brackets. They allow to choose between multiple characters, for instance gr[ae]y matches gray or grey.\n\nSquare brackets allow only characters or character classes. Alternation allows any expressions. A regexp A|B|C means one of expressions A, B or C.\n\nFor instance:\n\ngr(a|e)y means exactly the same as gr[ae]y.\ngra|ey means gra or ey.\n\nTo apply alternation to a chosen part of the pattern, we can enclose it in parentheses:\n\nI love HTML|CSS matches I love HTML or CSS.\nI love (HTML|CSS) matches I love HTML or I love CSS.\nExample: regexp for time\n\nIn previous articles there was a task to build a regexp for searching time in the form hh:mm, for instance 12:00. But a simple \\d\\d:\\d\\d is too vague. It accepts 25:99 as the time (as 99 minutes match the pattern, but that time is invalid).\n\nHow can we make a better pattern?\n\nWe can use more careful matching. First, the hours:\n\nIf the first digit is 0 or 1, then the next digit can be any: [01]\\d.\nOtherwise, if the first digit is 2, then the next must be [0-3].\n(no other first digit is allowed)\n\nWe can write both variants in a regexp using alternation: [01]\\d|2[0-3].\n\nNext, minutes must be from 00 to 59. In the regular expression language that can be written as [0-5]\\d: the first digit 0-5, and then any digit.\n\nIf we glue hours and minutes together, we get the pattern: [01]\\d|2[0-3]:[0-5]\\d.\n\nWe’re almost done, but there’s a problem. The alternation | now happens to be between [01]\\d and 2[0-3]:[0-5]\\d.\n\nThat is: minutes are added to the second alternation variant, here’s a clear picture:\n\n[01]\\d  |  2[0-3]:[0-5]\\d\n\nThat pattern looks for [01]\\d or 2[0-3]:[0-5]\\d.\n\nBut that’s wrong, the alternation should only be used in the “hours” part of the regular expression, to allow [01]\\d OR 2[0-3]. Let’s correct that by enclosing “hours” into parentheses: ([01]\\d|2[0-3]):[0-5]\\d.\n\nThe final solution:\n\n\t\nlet regexp = /([01]\\d|2[0-3]):[0-5]\\d/g;\n\nalert(\"00:00 10:10 23:59 25:99 1:2\".match(regexp)); // 00:00,10:10,23:59\nTasks\nFind programming languages\n\nThere are many programming languages, for instance Java, JavaScript, PHP, C, C++.\n\nCreate a regexp that finds them in the string Java JavaScript PHP C++ C:\n\nlet regexp = /your regexp/g;\n\nalert(\"Java JavaScript PHP C++ C\".match(regexp)); // Java JavaScript PHP C++ C\nsolution\nFind bbtag pairs\n\nA “bb-tag” looks like [tag]...[/tag], where tag is one of: b, url or quote.\n\nFor instance:\n\n[b]text[/b]\n[url]http://google.com[/url]\n\nBB-tags can be nested. But a tag can’t be nested into itself, for instance:\n\nNormal:\n[url] [b]http://google.com[/b] [/url]\n[quote] [b]text[/b] [/quote]\n\nCan't happen:\n[b][b]text[/b][/b]\n\nTags can contain line breaks, that’s normal:\n\n[quote]\n  [b]text[/b]\n[/quote]\n\nCreate a regexp to find all BB-tags with their contents.\n\nFor instance:\n\nlet regexp = /your regexp/flags;\n\nlet str = \"..[url]http://google.com[/url]..\";\nalert( str.match(regexp) ); // [url]http://google.com[/url]\n\nIf tags are nested, then we need the outer tag (if we want we can continue the search in its content):\n\nlet regexp = /your regexp/flags;\n\nlet str = \"..[url][b]http://google.com[/b][/url]..\";\nalert( str.match(regexp) ); // [url][b]http://google.com[/b][/url]\nsolution\nFind quoted strings\n\nCreate a regexp to find strings in double quotes \"...\".\n\nThe strings should support escaping, the same way as JavaScript strings do. For instance, quotes can be inserted as \\\" a newline as \\n, and the backslash itself as \\\\.\n\nlet str = \"Just like \\\"here\\\".\";\n\nPlease note, in particular, that an escaped quote \\\" does not end a string.\n\nSo we should search from one quote to the other ignoring escaped quotes on the way.\n\nThat’s the essential part of the task, otherwise it would be trivial.\n\nExamples of strings to match:\n\n.. \"test me\" ..\n.. \"Say \\\"Hello\\\"!\" ... (escaped quotes inside)\n.. \"\\\\\" ..  (double backslash inside)\n.. \"\\\\ \\\"\" ..  (double backslash and an escaped quote inside)\n\nIn JavaScript we need to double the backslashes to pass them right into the string, like this:\n\n\t\nlet str = ' .. \"test me\" .. \"Say \\\\\"Hello\\\\\"!\" .. \"\\\\\\\\ \\\\\"\" .. ';\n\n// the in-memory string\nalert(str); //  .. \"test me\" .. \"Say \\\"Hello\\\"!\" .. \"\\\\ \\\"\" ..\nsolution\nFind the full tag\n\nWrite a regexp to find the tag <style...>. It should match the full tag: it may have no attributes <style> or have several of them <style type=\"...\" id=\"...\">.\n\n…But the regexp should not match <styler>!\n\nFor instance:\n\nlet regexp = /your regexp/g;\n\nalert( '<style> <styler> <style test=\"...\">'.match(regexp) ); // <style>, <style test=\"...\">\nsolution"
  },
  {
    "title": "Capturing groups",
    "url": "https://javascript.info/regexp-groups",
    "html": "A part of a pattern can be enclosed in parentheses (...). This is called a “capturing group”.\n\nThat has two effects:\n\nIt allows to get a part of the match as a separate item in the result array.\nIf we put a quantifier after the parentheses, it applies to the parentheses as a whole.\nExamples\n\nLet’s see how parentheses work in examples.\n\nExample: gogogo\n\nWithout parentheses, the pattern go+ means g character, followed by o repeated one or more times. For instance, goooo or gooooooooo.\n\nParentheses group characters together, so (go)+ means go, gogo, gogogo and so on.\n\n\t\nalert( 'Gogogo now!'.match(/(go)+/ig) ); // \"Gogogo\"\nExample: domain\n\nLet’s make something more complex – a regular expression to search for a website domain.\n\nFor example:\n\nmail.com\nusers.mail.com\nsmith.users.mail.com\n\nAs we can see, a domain consists of repeated words, a dot after each one except the last one.\n\nIn regular expressions that’s (\\w+\\.)+\\w+:\n\n\t\nlet regexp = /(\\w+\\.)+\\w+/g;\n\nalert( \"site.com my.site.com\".match(regexp) ); // site.com,my.site.com\n\nThe search works, but the pattern can’t match a domain with a hyphen, e.g. my-site.com, because the hyphen does not belong to class \\w.\n\nWe can fix it by replacing \\w with [\\w-] in every word except the last one: ([\\w-]+\\.)+\\w+.\n\nExample: email\n\nThe previous example can be extended. We can create a regular expression for emails based on it.\n\nThe email format is: name@domain. Any word can be the name, hyphens and dots are allowed. In regular expressions that’s [-.\\w]+.\n\nThe pattern:\n\n\t\nlet regexp = /[-.\\w]+@([\\w-]+\\.)+[\\w-]+/g;\n\nalert(\"my@mail.com @ his@site.com.uk\".match(regexp)); // my@mail.com, his@site.com.uk\n\nThat regexp is not perfect, but mostly works and helps to fix accidental mistypes. The only truly reliable check for an email can only be done by sending a letter.\n\nParentheses contents in the match\n\nParentheses are numbered from left to right. The search engine memorizes the content matched by each of them and allows to get it in the result.\n\nThe method str.match(regexp), if regexp has no flag g, looks for the first match and returns it as an array:\n\nAt index 0: the full match.\nAt index 1: the contents of the first parentheses.\nAt index 2: the contents of the second parentheses.\n…and so on…\n\nFor instance, we’d like to find HTML tags <.*?>, and process them. It would be convenient to have tag content (what’s inside the angles), in a separate variable.\n\nLet’s wrap the inner content into parentheses, like this: <(.*?)>.\n\nNow we’ll get both the tag as a whole <h1> and its contents h1 in the resulting array:\n\n\t\nlet str = '<h1>Hello, world!</h1>';\n\nlet tag = str.match(/<(.*?)>/);\n\nalert( tag[0] ); // <h1>\nalert( tag[1] ); // h1\nNested groups\n\nParentheses can be nested. In this case the numbering also goes from left to right.\n\nFor instance, when searching a tag in <span class=\"my\"> we may be interested in:\n\nThe tag content as a whole: span class=\"my\".\nThe tag name: span.\nThe tag attributes: class=\"my\".\n\nLet’s add parentheses for them: <(([a-z]+)\\s*([^>]*))>.\n\nHere’s how they are numbered (left to right, by the opening paren):\n\nIn action:\n\n\t\nlet str = '<span class=\"my\">';\n\nlet regexp = /<(([a-z]+)\\s*([^>]*))>/;\n\nlet result = str.match(regexp);\nalert(result[0]); // <span class=\"my\">\nalert(result[1]); // span class=\"my\"\nalert(result[2]); // span\nalert(result[3]); // class=\"my\"\n\nThe zero index of result always holds the full match.\n\nThen groups, numbered from left to right by an opening paren. The first group is returned as result[1]. Here it encloses the whole tag content.\n\nThen in result[2] goes the group from the second opening paren ([a-z]+) – tag name, then in result[3] the tag: ([^>]*).\n\nThe contents of every group in the string:\n\nOptional groups\n\nEven if a group is optional and doesn’t exist in the match (e.g. has the quantifier (...)?), the corresponding result array item is present and equals undefined.\n\nFor instance, let’s consider the regexp a(z)?(c)?. It looks for \"a\" optionally followed by \"z\" optionally followed by \"c\".\n\nIf we run it on the string with a single letter a, then the result is:\n\n\t\nlet match = 'a'.match(/a(z)?(c)?/);\n\nalert( match.length ); // 3\nalert( match[0] ); // a (whole match)\nalert( match[1] ); // undefined\nalert( match[2] ); // undefined\n\nThe array has the length of 3, but all groups are empty.\n\nAnd here’s a more complex match for the string ac:\n\n\t\nlet match = 'ac'.match(/a(z)?(c)?/)\n\nalert( match.length ); // 3\nalert( match[0] ); // ac (whole match)\nalert( match[1] ); // undefined, because there's nothing for (z)?\nalert( match[2] ); // c\n\nThe array length is permanent: 3. But there’s nothing for the group (z)?, so the result is [\"ac\", undefined, \"c\"].\n\nSearching for all matches with groups: matchAll\nmatchAll is a new method, polyfill may be needed\n\nThe method matchAll is not supported in old browsers.\n\nA polyfill may be required, such as https://github.com/ljharb/String.prototype.matchAll.\n\nWhen we search for all matches (flag g), the match method does not return contents for groups.\n\nFor example, let’s find all tags in a string:\n\n\t\nlet str = '<h1> <h2>';\n\nlet tags = str.match(/<(.*?)>/g);\n\nalert( tags ); // <h1>,<h2>\n\nThe result is an array of matches, but without details about each of them. But in practice we usually need contents of capturing groups in the result.\n\nTo get them, we should search using the method str.matchAll(regexp).\n\nIt was added to JavaScript language long after match, as its “new and improved version”.\n\nJust like match, it looks for matches, but there are 3 differences:\n\nIt returns not an array, but an iterable object.\nWhen the flag g is present, it returns every match as an array with groups.\nIf there are no matches, it returns not null, but an empty iterable object.\n\nFor instance:\n\n\t\nlet results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n\n// results - is not an array, but an iterable object\nalert(results); // [object RegExp String Iterator]\n\nalert(results[0]); // undefined (*)\n\nresults = Array.from(results); // let's turn it into array\n\nalert(results[0]); // <h1>,h1 (1st tag)\nalert(results[1]); // <h2>,h2 (2nd tag)\n\nAs we can see, the first difference is very important, as demonstrated in the line (*). We can’t get the match as results[0], because that object isn’t pseudoarray. We can turn it into a real Array using Array.from. There are more details about pseudoarrays and iterables in the article Iterables.\n\nThere’s no need in Array.from if we’re looping over results:\n\n\t\nlet results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n\nfor(let result of results) {\n  alert(result);\n  // first alert: <h1>,h1\n  // second: <h2>,h2\n}\n\n…Or using destructuring:\n\nlet [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n\nEvery match, returned by matchAll, has the same format as returned by match without flag g: it’s an array with additional properties index (match index in the string) and input (source string):\n\n\t\nlet results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);\n\nlet [tag1, tag2] = results;\n\nalert( tag1[0] ); // <h1>\nalert( tag1[1] ); // h1\nalert( tag1.index ); // 0\nalert( tag1.input ); // <h1> <h2>\nWhy is a result of matchAll an iterable object, not an array?\n\nWhy is the method designed like that? The reason is simple – for the optimization.\n\nThe call to matchAll does not perform the search. Instead, it returns an iterable object, without the results initially. The search is performed each time we iterate over it, e.g. in the loop.\n\nSo, there will be found as many results as needed, not more.\n\nE.g. there are potentially 100 matches in the text, but in a for..of loop we found 5 of them, then decided it’s enough and made a break. Then the engine won’t spend time finding other 95 matches.\n\nNamed groups\n\nRemembering groups by their numbers is hard. For simple patterns it’s doable, but for more complex ones counting parentheses is inconvenient. We have a much better option: give names to parentheses.\n\nThat’s done by putting ?<name> immediately after the opening paren.\n\nFor example, let’s look for a date in the format “year-month-day”:\n\n\t\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;\nlet str = \"2019-04-30\";\n\nlet groups = str.match(dateRegexp).groups;\n\nalert(groups.year); // 2019\nalert(groups.month); // 04\nalert(groups.day); // 30\n\nAs you can see, the groups reside in the .groups property of the match.\n\nTo look for all dates, we can add flag g.\n\nWe’ll also need matchAll to obtain full matches, together with groups:\n\n\t\nlet dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;\n\nlet str = \"2019-10-30 2020-01-01\";\n\nlet results = str.matchAll(dateRegexp);\n\nfor(let result of results) {\n  let {year, month, day} = result.groups;\n\n  alert(`${day}.${month}.${year}`);\n  // first alert: 30.10.2019\n  // second: 01.01.2020\n}\nCapturing groups in replacement\n\nMethod str.replace(regexp, replacement) that replaces all matches with regexp in str allows to use parentheses contents in the replacement string. That’s done using $n, where n is the group number.\n\nFor example,\n\n\t\nlet str = \"John Bull\";\nlet regexp = /(\\w+) (\\w+)/;\n\nalert( str.replace(regexp, '$2, $1') ); // Bull, John\n\nFor named parentheses the reference will be $<name>.\n\nFor example, let’s reformat dates from “year-month-day” to “day.month.year”:\n\n\t\nlet regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;\n\nlet str = \"2019-10-30, 2020-01-01\";\n\nalert( str.replace(regexp, '$<day>.$<month>.$<year>') );\n// 30.10.2019, 01.01.2020\nNon-capturing groups with ?:\n\nSometimes we need parentheses to correctly apply a quantifier, but we don’t want their contents in results.\n\nA group may be excluded by adding ?: in the beginning.\n\nFor instance, if we want to find (go)+, but don’t want the parentheses contents (go) as a separate array item, we can write: (?:go)+.\n\nIn the example below we only get the name John as a separate member of the match:\n\n\t\nlet str = \"Gogogo John!\";\n\n// ?: excludes 'go' from capturing\nlet regexp = /(?:go)+ (\\w+)/i;\n\nlet result = str.match(regexp);\n\nalert( result[0] ); // Gogogo John (full match)\nalert( result[1] ); // John\nalert( result.length ); // 2 (no more items in the array)\nSummary\n\nParentheses group together a part of the regular expression, so that the quantifier applies to it as a whole.\n\nParentheses groups are numbered left-to-right, and can optionally be named with (?<name>...).\n\nThe content, matched by a group, can be obtained in the results:\n\nThe method str.match returns capturing groups only without flag g.\nThe method str.matchAll always returns capturing groups.\n\nIf the parentheses have no name, then their contents is available in the match array by its number. Named parentheses are also available in the property groups.\n\nWe can also use parentheses contents in the replacement string in str.replace: by the number $n or the name $<name>.\n\nA group may be excluded from numbering by adding ?: in its start. That’s used when we need to apply a quantifier to the whole group, but don’t want it as a separate item in the results array. We also can’t reference such parentheses in the replacement string.\n\nTasks\nCheck MAC-address\n\nMAC-address of a network interface consists of 6 two-digit hex numbers separated by a colon.\n\nFor instance: '01:32:54:67:89:AB'.\n\nWrite a regexp that checks whether a string is MAC-address.\n\nUsage:\n\nlet regexp = /your regexp/;\n\nalert( regexp.test('01:32:54:67:89:AB') ); // true\n\nalert( regexp.test('0132546789AB') ); // false (no colons)\n\nalert( regexp.test('01:32:54:67:89') ); // false (5 numbers, must be 6)\n\nalert( regexp.test('01:32:54:67:89:ZZ') ) // false (ZZ at the end)\nsolution\nFind color in the format #abc or #abcdef\n\nWrite a RegExp that matches colors in the format #abc or #abcdef. That is: # followed by 3 or 6 hexadecimal digits.\n\nUsage example:\n\nlet regexp = /your regexp/g;\n\nlet str = \"color: #3f3; background-color: #AA00ef; and: #abcd\";\n\nalert( str.match(regexp) ); // #3f3 #AA00ef\n\nP.S. This should be exactly 3 or 6 hex digits. Values with 4 digits, such as #abcd, should not match.\n\nsolution\nFind all numbers\n\nWrite a regexp that looks for all decimal numbers including integer ones, with the floating point and negative ones.\n\nAn example of use:\n\nlet regexp = /your regexp/g;\n\nlet str = \"-1.5 0 2 -123.4.\";\n\nalert( str.match(regexp) ); // -1.5, 0, 2, -123.4\nsolution\nParse an expression\n\nAn arithmetical expression consists of 2 numbers and an operator between them, for instance:\n\n1 + 2\n1.2 * 3.4\n-3 / -6\n-2 - 2\n\nThe operator is one of: \"+\", \"-\", \"*\" or \"/\".\n\nThere may be extra spaces at the beginning, at the end or between the parts.\n\nCreate a function parse(expr) that takes an expression and returns an array of 3 items:\n\nThe first number.\nThe operator.\nThe second number.\n\nFor example:\n\nlet [a, op, b] = parse(\"1.2 * 3.4\");\n\nalert(a); // 1.2\nalert(op); // *\nalert(b); // 3.4\nsolution"
  },
  {
    "title": "Backreferences in pattern: \\N and \\k<name>",
    "url": "https://javascript.info/regexp-backreferences",
    "html": "We can use the contents of capturing groups (...) not only in the result or in the replacement string, but also in the pattern itself.\n\nBackreference by number: \\N\n\nA group can be referenced in the pattern using \\N, where N is the group number.\n\nTo make clear why that’s helpful, let’s consider a task.\n\nWe need to find quoted strings: either single-quoted '...' or a double-quoted \"...\" – both variants should match.\n\nHow to find them?\n\nWe can put both kinds of quotes in the square brackets: ['\"](.*?)['\"], but it would find strings with mixed quotes, like \"...' and '...\". That would lead to incorrect matches when one quote appears inside other ones, like in the string \"She's the one!\":\n\n\t\nlet str = `He said: \"She's the one!\".`;\n\nlet regexp = /['\"](.*?)['\"]/g;\n\n// The result is not what we'd like to have\nalert( str.match(regexp) ); // \"She'\n\nAs we can see, the pattern found an opening quote \", then the text is consumed till the other quote ', that closes the match.\n\nTo make sure that the pattern looks for the closing quote exactly the same as the opening one, we can wrap it into a capturing group and backreference it: (['\"])(.*?)\\1.\n\nHere’s the correct code:\n\n\t\nlet str = `He said: \"She's the one!\".`;\n\nlet regexp = /(['\"])(.*?)\\1/g;\n\nalert( str.match(regexp) ); // \"She's the one!\"\n\nNow it works! The regular expression engine finds the first quote (['\"]) and memorizes its content. That’s the first capturing group.\n\nFurther in the pattern \\1 means “find the same text as in the first group”, exactly the same quote in our case.\n\nSimilar to that, \\2 would mean the contents of the second group, \\3 – the 3rd group, and so on.\n\nPlease note:\n\nIf we use ?: in the group, then we can’t reference it. Groups that are excluded from capturing (?:...) are not memorized by the engine.\n\nDon’t mess up: in the pattern \\1, in the replacement: $1\n\nIn the replacement string we use a dollar sign: $1, while in the pattern – a backslash \\1.\n\nBackreference by name: \\k<name>\n\nIf a regexp has many parentheses, it’s convenient to give them names.\n\nTo reference a named group we can use \\k<name>.\n\nIn the example below the group with quotes is named ?<quote>, so the backreference is \\k<quote>:\n\n\t\nlet str = `He said: \"She's the one!\".`;\n\nlet regexp = /(?<quote>['\"])(.*?)\\k<quote>/g;\n\nalert( str.match(regexp) ); // \"She's the one!\""
  },
  {
    "title": "Quantifiers +, *, ? and {n}",
    "url": "https://javascript.info/regexp-quantifiers",
    "html": "Let’s say we have a string like +7(903)-123-45-67 and want to find all numbers in it. But unlike before, we are interested not in single digits, but full numbers: 7, 903, 123, 45, 67.\n\nA number is a sequence of 1 or more digits \\d. To mark how many we need, we can append a quantifier.\n\nQuantity {n}\n\nThe simplest quantifier is a number in curly braces: {n}.\n\nA quantifier is appended to a character (or a character class, or a [...] set etc) and specifies how many we need.\n\nIt has a few advanced forms, let’s see examples:\n\nThe exact count: {5}\n\n\\d{5} denotes exactly 5 digits, the same as \\d\\d\\d\\d\\d.\n\nThe example below looks for a 5-digit number:\n\n\t\nalert( \"I'm 12345 years old\".match(/\\d{5}/) ); //  \"12345\"\n\nWe can add \\b to exclude longer numbers: \\b\\d{5}\\b.\n\nThe range: {3,5}, match 3-5 times\n\nTo find numbers from 3 to 5 digits we can put the limits into curly braces: \\d{3,5}\n\n\t\nalert( \"I'm not 12, but 1234 years old\".match(/\\d{3,5}/) ); // \"1234\"\n\nWe can omit the upper limit.\n\nThen a regexp \\d{3,} looks for sequences of digits of length 3 or more:\n\n\t\nalert( \"I'm not 12, but 345678 years old\".match(/\\d{3,}/) ); // \"345678\"\n\nLet’s return to the string +7(903)-123-45-67.\n\nA number is a sequence of one or more digits in a row. So the regexp is \\d{1,}:\n\n\t\nlet str = \"+7(903)-123-45-67\";\n\nlet numbers = str.match(/\\d{1,}/g);\n\nalert(numbers); // 7,903,123,45,67\nShorthands\n\nThere are shorthands for most used quantifiers:\n\n+\n\nMeans “one or more”, the same as {1,}.\n\nFor instance, \\d+ looks for numbers:\n\n\t\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.match(/\\d+/g) ); // 7,903,123,45,67\n?\n\nMeans “zero or one”, the same as {0,1}. In other words, it makes the symbol optional.\n\nFor instance, the pattern ou?r looks for o followed by zero or one u, and then r.\n\nSo, colou?r finds both color and colour:\n\n\t\nlet str = \"Should I write color or colour?\";\n\nalert( str.match(/colou?r/g) ); // color, colour\n*\n\nMeans “zero or more”, the same as {0,}. That is, the character may repeat any times or be absent.\n\nFor example, \\d0* looks for a digit followed by any number of zeroes (may be many or none):\n\n\t\nalert( \"100 10 1\".match(/\\d0*/g) ); // 100, 10, 1\n\nCompare it with + (one or more):\n\n\t\nalert( \"100 10 1\".match(/\\d0+/g) ); // 100, 10\n// 1 not matched, as 0+ requires at least one zero\nMore examples\n\nQuantifiers are used very often. They serve as the main “building block” of complex regular expressions, so let’s see more examples.\n\nRegexp for decimal fractions (a number with a floating point): \\d+\\.\\d+\n\nIn action:\n\n\t\nalert( \"0 1 12.345 7890\".match(/\\d+\\.\\d+/g) ); // 12.345\n\nRegexp for an “opening HTML-tag without attributes”, such as <span> or <p>.\n\nThe simplest one: /<[a-z]+>/i\n\n\t\nalert( \"<body> ... </body>\".match(/<[a-z]+>/gi) ); // <body>\n\nThe regexp looks for character '<' followed by one or more Latin letters, and then '>'.\n\nImproved: /<[a-z][a-z0-9]*>/i\n\nAccording to the standard, HTML tag name may have a digit at any position except the first one, like <h1>.\n\n\t\nalert( \"<h1>Hi!</h1>\".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>\n\nRegexp “opening or closing HTML-tag without attributes”: /<\\/?[a-z][a-z0-9]*>/i\n\nWe added an optional slash /? near the beginning of the pattern. Had to escape it with a backslash, otherwise JavaScript would think it is the pattern end.\n\n\t\nalert( \"<h1>Hi!</h1>\".match(/<\\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>\nTo make a regexp more precise, we often need make it more complex\n\nWe can see one common rule in these examples: the more precise is the regular expression – the longer and more complex it is.\n\nFor instance, for HTML tags we could use a simpler regexp: <\\w+>. But as HTML has stricter restrictions for a tag name, <[a-z][a-z0-9]*> is more reliable.\n\nCan we use <\\w+> or we need <[a-z][a-z0-9]*>?\n\nIn real life both variants are acceptable. Depends on how tolerant we can be to “extra” matches and whether it’s difficult or not to remove them from the result by other means.\n\nTasks\nHow to find an ellipsis \"...\" ?\nimportance: 5\n\nCreate a regexp to find ellipsis: 3 (or more?) dots in a row.\n\nCheck it:\n\nlet regexp = /your regexp/g;\nalert( \"Hello!... How goes?.....\".match(regexp) ); // ..., .....\nsolution\nRegexp for HTML colors\n\nCreate a regexp to search HTML-colors written as #ABCDEF: first # and then 6 hexadecimal characters.\n\nAn example of use:\n\nlet regexp = /...your regexp.../\n\nlet str = \"color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678\";\n\nalert( str.match(regexp) )  // #121212,#AA00ef\n\nP.S. In this task we do not need other color formats like #123 or rgb(1,2,3) etc.\n\nsolution"
  },
  {
    "title": "Sets and ranges [...]",
    "url": "https://javascript.info/regexp-character-sets-and-ranges",
    "html": "Several characters or character classes inside square brackets […] mean to “search for any character among given”.\n\nSets\n\nFor instance, [eao] means any of the 3 characters: 'a', 'e', or 'o'.\n\nThat’s called a set. Sets can be used in a regexp along with regular characters:\n\n\t\n// find [t or m], and then \"op\"\nalert( \"Mop top\".match(/[tm]op/gi) ); // \"Mop\", \"top\"\n\nPlease note that although there are multiple characters in the set, they correspond to exactly one character in the match.\n\nSo the example below gives no matches:\n\n\t\n// find \"V\", then [o or i], then \"la\"\nalert( \"Voila\".match(/V[oi]la/) ); // null, no matches\n\nThe pattern searches for:\n\nV,\nthen one of the letters [oi],\nthen la.\n\nSo there would be a match for Vola or Vila.\n\nRanges\n\nSquare brackets may also contain character ranges.\n\nFor instance, [a-z] is a character in range from a to z, and [0-5] is a digit from 0 to 5.\n\nIn the example below we’re searching for \"x\" followed by two digits or letters from A to F:\n\n\t\nalert( \"Exception 0xAF\".match(/x[0-9A-F][0-9A-F]/g) ); // xAF\n\nHere [0-9A-F] has two ranges: it searches for a character that is either a digit from 0 to 9 or a letter from A to F.\n\nIf we’d like to look for lowercase letters as well, we can add the range a-f: [0-9A-Fa-f]. Or add the flag i.\n\nWe can also use character classes inside […].\n\nFor instance, if we’d like to look for a wordly character \\w or a hyphen -, then the set is [\\w-].\n\nCombining multiple classes is also possible, e.g. [\\s\\d] means “a space character or a digit”.\n\nCharacter classes are shorthands for certain character sets\n\nFor instance:\n\n\\d – is the same as [0-9],\n\\w – is the same as [a-zA-Z0-9_],\n\\s – is the same as [\\t\\n\\v\\f\\r ], plus few other rare Unicode space characters.\nExample: multi-language \\w\n\nAs the character class \\w is a shorthand for [a-zA-Z0-9_], it can’t find Chinese hieroglyphs, Cyrillic letters, etc.\n\nWe can write a more universal pattern, that looks for wordly characters in any language. That’s easy with Unicode properties: [\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}].\n\nLet’s decipher it. Similar to \\w, we’re making a set of our own that includes characters with following Unicode properties:\n\nAlphabetic (Alpha) – for letters,\nMark (M) – for accents,\nDecimal_Number (Nd) – for digits,\nConnector_Punctuation (Pc) – for the underscore '_' and similar characters,\nJoin_Control (Join_C) – two special codes 200c and 200d, used in ligatures, e.g. in Arabic.\n\nAn example of use:\n\n\t\nlet regexp = /[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]/gu;\n\nlet str = `Hi 你好 12`;\n\n// finds all letters and digits:\nalert( str.match(regexp) ); // H,i,你,好,1,2\n\nOf course, we can edit this pattern: add Unicode properties or remove them. Unicode properties are covered in more details in the article Unicode: flag \"u\" and class \\p{...}.\n\nUnicode properties aren’t supported in IE\n\nUnicode properties p{…} are not implemented in IE. If we really need them, we can use library XRegExp.\n\nOr just use ranges of characters in a language that interests us, e.g. [а-я] for Cyrillic letters.\n\nExcluding ranges\n\nBesides normal ranges, there are “excluding” ranges that look like [^…].\n\nThey are denoted by a caret character ^ at the start and match any character except the given ones.\n\nFor instance:\n\n[^aeyo] – any character except 'a', 'e', 'y' or 'o'.\n[^0-9] – any character except a digit, the same as \\D.\n[^\\s] – any non-space character, same as \\S.\n\nThe example below looks for any characters except letters, digits and spaces:\n\n\t\nalert( \"alice15@gmail.com\".match(/[^\\d\\sA-Z]/gi) ); // @ and .\nEscaping in […]\n\nUsually when we want to find exactly a special character, we need to escape it like \\.. And if we need a backslash, then we use \\\\, and so on.\n\nIn square brackets we can use the vast majority of special characters without escaping:\n\nSymbols . + ( ) never need escaping.\nA hyphen - is not escaped in the beginning or the end (where it does not define a range).\nA caret ^ is only escaped in the beginning (where it means exclusion).\nThe closing square bracket ] is always escaped (if we need to look for that symbol).\n\nIn other words, all special characters are allowed without escaping, except when they mean something for square brackets.\n\nA dot . inside square brackets means just a dot. The pattern [.,] would look for one of characters: either a dot or a comma.\n\nIn the example below the regexp [-().^+] looks for one of the characters -().^+:\n\n\t\n// No need to escape\nlet regexp = /[-().^+]/g;\n\nalert( \"1 + 2 - 3\".match(regexp) ); // Matches +, -\n\n…But if you decide to escape them “just in case”, then there would be no harm:\n\n\t\n// Escaped everything\nlet regexp = /[\\-\\(\\)\\.\\^\\+]/g;\n\nalert( \"1 + 2 - 3\".match(regexp) ); // also works: +, -\nRanges and flag “u”\n\nIf there are surrogate pairs in the set, flag u is required for them to work correctly.\n\nFor instance, let’s look for [𝒳𝒴] in the string 𝒳:\n\n\t\nalert( '𝒳'.match(/[𝒳𝒴]/) ); // shows a strange character, like [?]\n// (the search was performed incorrectly, half-character returned)\n\nThe result is incorrect, because by default regular expressions “don’t know” about surrogate pairs.\n\nThe regular expression engine thinks that [𝒳𝒴] – are not two, but four characters:\n\nleft half of 𝒳 (1),\nright half of 𝒳 (2),\nleft half of 𝒴 (3),\nright half of 𝒴 (4).\n\nWe can see their codes like this:\n\n\t\nfor(let i=0; i<'𝒳𝒴'.length; i++) {\n  alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500\n};\n\nSo, the example above finds and shows the left half of 𝒳.\n\nIf we add flag u, then the behavior will be correct:\n\n\t\nalert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳\n\nThe similar situation occurs when looking for a range, such as [𝒳-𝒴].\n\nIf we forget to add flag u, there will be an error:\n\n\t\n'𝒳'.match(/[𝒳-𝒴]/); // Error: Invalid regular expression\n\nThe reason is that without flag u surrogate pairs are perceived as two characters, so [𝒳-𝒴] is interpreted as [<55349><56499>-<55349><56500>] (every surrogate pair is replaced with its codes). Now it’s easy to see that the range 56499-55349 is invalid: its starting code 56499 is greater than the end 55349. That’s the formal reason for the error.\n\nWith the flag u the pattern works correctly:\n\n\t\n// look for characters from 𝒳 to 𝒵\nalert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴\nTasks\nJava[^script]\n\nWe have a regexp /Java[^script]/.\n\nDoes it match anything in the string Java? In the string JavaScript?\n\nsolution\nFind the time as hh:mm or hh-mm\n\nThe time can be in the format hours:minutes or hours-minutes. Both hours and minutes have 2 digits: 09:00 or 21-30.\n\nWrite a regexp to find time:\n\nlet regexp = /your regexp/g;\nalert( \"Breakfast at 09:00. Dinner at 21-30\".match(regexp) ); // 09:00, 21-30\n\nP.S. In this task we assume that the time is always correct, there’s no need to filter out bad strings like “45:67”. Later we’ll deal with that too.\n\nsolution"
  },
  {
    "title": "Anchors: string start ^ and end $",
    "url": "https://javascript.info/regexp-anchors",
    "html": "The caret ^ and dollar $ characters have special meaning in a regexp. They are called “anchors”.\n\nThe caret ^ matches at the beginning of the text, and the dollar $ – at the end.\n\nFor instance, let’s test if the text starts with Mary:\n\n\t\nlet str1 = \"Mary had a little lamb\";\nalert( /^Mary/.test(str1) ); // true\n\nThe pattern ^Mary means: “string start and then Mary”.\n\nSimilar to this, we can test if the string ends with snow using snow$:\n\n\t\nlet str1 = \"its fleece was white as snow\";\nalert( /snow$/.test(str1) ); // true\n\nIn these particular cases we could use string methods startsWith/endsWith instead. Regular expressions should be used for more complex tests.\n\nTesting for a full match\n\nBoth anchors together ^...$ are often used to test whether or not a string fully matches the pattern. For instance, to check if the user input is in the right format.\n\nLet’s check whether or not a string is a time in 12:34 format. That is: two digits, then a colon, and then another two digits.\n\nIn regular expressions language that’s \\d\\d:\\d\\d:\n\n\t\nlet goodInput = \"12:34\";\nlet badInput = \"12:345\";\n\nlet regexp = /^\\d\\d:\\d\\d$/;\nalert( regexp.test(goodInput) ); // true\nalert( regexp.test(badInput) ); // false\n\nHere the match for \\d\\d:\\d\\d must start exactly after the beginning of the text ^, and the end $ must immediately follow.\n\nThe whole string must be exactly in this format. If there’s any deviation or an extra character, the result is false.\n\nAnchors behave differently if flag m is present. We’ll see that in the next article.\n\nAnchors have “zero width”\n\nAnchors ^ and $ are tests. They have zero width.\n\nIn other words, they do not match a character, but rather force the regexp engine to check the condition (text start/end).\n\nTasks\nRegexp ^$\n\nWhich string matches the pattern ^$?\n\nsolution"
  },
  {
    "title": "Escaping, special characters",
    "url": "https://javascript.info/regexp-escaping",
    "html": "As we’ve seen, a backslash \\ is used to denote character classes, e.g. \\d. So it’s a special character in regexps (just like in regular strings).\n\nThere are other special characters as well, that have special meaning in a regexp, such as [ ] { } ( ) \\ ^ $ . | ? * +. They are used to do more powerful searches.\n\nDon’t try to remember the list – soon we’ll deal with each of them, and you’ll know them by heart automatically.\n\nEscaping\n\nLet’s say we want to find literally a dot. Not “any character”, but just a dot.\n\nTo use a special character as a regular one, prepend it with a backslash: \\..\n\nThat’s also called “escaping a character”.\n\nFor example:\n\n\t\nalert( \"Chapter 5.1\".match(/\\d\\.\\d/) ); // 5.1 (match!)\nalert( \"Chapter 511\".match(/\\d\\.\\d/) ); // null (looking for a real dot \\.)\n\nParentheses are also special characters, so if we want them, we should use \\(. The example below looks for a string \"g()\":\n\n\t\nalert( \"function g()\".match(/g\\(\\)/) ); // \"g()\"\n\nIf we’re looking for a backslash \\, it’s a special character in both regular strings and regexps, so we should double it.\n\n\t\nalert( \"1\\\\2\".match(/\\\\/) ); // '\\'\nA slash\n\nA slash symbol '/' is not a special character, but in JavaScript it is used to open and close the regexp: /...pattern.../, so we should escape it too.\n\nHere’s what a search for a slash '/' looks like:\n\n\t\nalert( \"/\".match(/\\//) ); // '/'\n\nOn the other hand, if we’re not using /.../, but create a regexp using new RegExp, then we don’t need to escape it:\n\n\t\nalert( \"/\".match(new RegExp(\"/\")) ); // finds /\nnew RegExp\n\nIf we are creating a regular expression with new RegExp, then we don’t have to escape /, but need to do some other escaping.\n\nFor instance, consider this:\n\n\t\nlet regexp = new RegExp(\"\\d\\.\\d\");\n\nalert( \"Chapter 5.1\".match(regexp) ); // null\n\nThe similar search in one of previous examples worked with /\\d\\.\\d/, but new RegExp(\"\\d\\.\\d\") doesn’t work, why?\n\nThe reason is that backslashes are “consumed” by a string. As we may recall, regular strings have their own special characters, such as \\n, and a backslash is used for escaping.\n\nHere’s how “\\d.\\d” is perceived:\n\n\t\nalert(\"\\d\\.\\d\"); // d.d\n\nString quotes “consume” backslashes and interpret them on their own, for instance:\n\n\\n – becomes a newline character,\n\\u1234 – becomes the Unicode character with such code,\n…And when there’s no special meaning: like \\d or \\z, then the backslash is simply removed.\n\nSo new RegExp gets a string without backslashes. That’s why the search doesn’t work!\n\nTo fix it, we need to double backslashes, because string quotes turn \\\\ into \\:\n\n\t\nlet regStr = \"\\\\d\\\\.\\\\d\";\nalert(regStr); // \\d\\.\\d (correct now)\n\nlet regexp = new RegExp(regStr);\n\nalert( \"Chapter 5.1\".match(regexp) ); // 5.1\nSummary\nTo search for special characters [ \\ ^ $ . | ? * + ( ) literally, we need to prepend them with a backslash \\ (“escape them”).\nWe also need to escape / if we’re inside /.../ (but not inside new RegExp).\nWhen passing a string to new RegExp, we need to double backslashes \\\\, cause string quotes consume one of them."
  },
  {
    "title": "Word boundary: \\b",
    "url": "https://javascript.info/regexp-boundary",
    "html": "A word boundary \\b is a test, just like ^ and $.\n\nWhen the regexp engine (program module that implements searching for regexps) comes across \\b, it checks that the position in the string is a word boundary.\n\nThere are three different positions that qualify as word boundaries:\n\nAt string start, if the first string character is a word character \\w.\nBetween two characters in the string, where one is a word character \\w and the other is not.\nAt string end, if the last string character is a word character \\w.\n\nFor instance, regexp \\bJava\\b will be found in Hello, Java!, where Java is a standalone word, but not in Hello, JavaScript!.\n\n\t\nalert( \"Hello, Java!\".match(/\\bJava\\b/) ); // Java\nalert( \"Hello, JavaScript!\".match(/\\bJava\\b/) ); // null\n\nIn the string Hello, Java! following positions correspond to \\b:\n\nSo, it matches the pattern \\bHello\\b, because:\n\nAt the beginning of the string matches the first test \\b.\nThen matches the word Hello.\nThen the test \\b matches again, as we’re between o and a comma.\n\nSo the pattern \\bHello\\b would match, but not \\bHell\\b (because there’s no word boundary after l) and not Java!\\b (because the exclamation sign is not a wordly character \\w, so there’s no word boundary after it).\n\n\t\nalert( \"Hello, Java!\".match(/\\bHello\\b/) ); // Hello\nalert( \"Hello, Java!\".match(/\\bJava\\b/) );  // Java\nalert( \"Hello, Java!\".match(/\\bHell\\b/) );  // null (no match)\nalert( \"Hello, Java!\".match(/\\bJava!\\b/) ); // null (no match)\n\nWe can use \\b not only with words, but with digits as well.\n\nFor example, the pattern \\b\\d\\d\\b looks for standalone 2-digit numbers. In other words, it looks for 2-digit numbers that are surrounded by characters different from \\w, such as spaces or punctuation (or text start/end).\n\n\t\nalert( \"1 23 456 78\".match(/\\b\\d\\d\\b/g) ); // 23,78\nalert( \"12,34,56\".match(/\\b\\d\\d\\b/g) ); // 12,34,56\nWord boundary \\b doesn’t work for non-latin alphabets\n\nThe word boundary test \\b checks that there should be \\w on the one side from the position and \"not \\w\" – on the other side.\n\nBut \\w means a latin letter a-z (or a digit or an underscore), so the test doesn’t work for other characters, e.g. cyrillic letters or hieroglyphs.\n\nTasks\nFind the time\n\nThe time has a format: hours:minutes. Both hours and minutes has two digits, like 09:00.\n\nMake a regexp to find time in the string: Breakfast at 09:00 in the room 123:456.\n\nP.S. In this task there’s no need to check time correctness yet, so 25:99 can also be a valid result.\n\nP.P.S. The regexp shouldn’t match 123:456.\n\nsolution"
  },
  {
    "title": "Multiline mode of anchors ^ $, flag \"m\"",
    "url": "https://javascript.info/regexp-multiline-mode",
    "html": "The multiline mode is enabled by the flag m.\n\nIt only affects the behavior of ^ and $.\n\nIn the multiline mode they match not only at the beginning and the end of the string, but also at start/end of line.\n\nSearching at line start ^\n\nIn the example below the text has multiple lines. The pattern /^\\d/gm takes a digit from the beginning of each line:\n\n\t\nlet str = `1st place: Winnie\n2nd place: Piglet\n3rd place: Eeyore`;\n\nconsole.log( str.match(/^\\d/gm) ); // 1, 2, 3\n\nWithout the flag m only the first digit is matched:\n\n\t\nlet str = `1st place: Winnie\n2nd place: Piglet\n3rd place: Eeyore`;\n\nconsole.log( str.match(/^\\d/g) ); // 1\n\nThat’s because by default a caret ^ only matches at the beginning of the text, and in the multiline mode – at the start of any line.\n\nPlease note:\n\n“Start of a line” formally means “immediately after a line break”: the test ^ in multiline mode matches at all positions preceded by a newline character \\n.\n\nAnd at the text start.\n\nSearching at line end $\n\nThe dollar sign $ behaves similarly.\n\nThe regular expression \\d$ finds the last digit in every line\n\n\t\nlet str = `Winnie: 1\nPiglet: 2\nEeyore: 3`;\n\nconsole.log( str.match(/\\d$/gm) ); // 1,2,3\n\nWithout the flag m, the dollar $ would only match the end of the whole text, so only the very last digit would be found.\n\nPlease note:\n\n“End of a line” formally means “immediately before a line break”: the test $ in multiline mode matches at all positions succeeded by a newline character \\n.\n\nAnd at the text end.\n\nSearching for \\n instead of ^ $\n\nTo find a newline, we can use not only anchors ^ and $, but also the newline character \\n.\n\nWhat’s the difference? Let’s see an example.\n\nHere we search for \\d\\n instead of \\d$:\n\n\t\nlet str = `Winnie: 1\nPiglet: 2\nEeyore: 3`;\n\nconsole.log( str.match(/\\d\\n/g) ); // 1\\n,2\\n\n\nAs we can see, there are 2 matches instead of 3.\n\nThat’s because there’s no newline after 3 (there’s text end though, so it matches $).\n\nAnother difference: now every match includes a newline character \\n. Unlike the anchors ^ $, that only test the condition (start/end of a line), \\n is a character, so it becomes a part of the result.\n\nSo, a \\n in the pattern is used when we need newline characters in the result, while anchors are used to find something at the beginning/end of a line."
  },
  {
    "title": "Unicode: flag \"u\" and class \\p{...}",
    "url": "https://javascript.info/regexp-unicode",
    "html": "JavaScript uses Unicode encoding for strings. Most characters are encoded with 2 bytes, but that allows to represent at most 65536 characters.\n\nThat range is not big enough to encode all possible characters, that’s why some rare characters are encoded with 4 bytes, for instance like 𝒳 (mathematical X) or 😄 (a smile), some hieroglyphs and so on.\n\nHere are the Unicode values of some characters:\n\nCharacter\tUnicode\tBytes count in Unicode\na\t0x0061\t2\n≈\t0x2248\t2\n𝒳\t0x1d4b3\t4\n𝒴\t0x1d4b4\t4\n😄\t0x1f604\t4\n\nSo characters like a and ≈ occupy 2 bytes, while codes for 𝒳, 𝒴 and 😄 are longer, they have 4 bytes.\n\nLong time ago, when JavaScript language was created, Unicode encoding was simpler: there were no 4-byte characters. So, some language features still handle them incorrectly.\n\nFor instance, length thinks that here are two characters:\n\n\t\nalert('😄'.length); // 2\nalert('𝒳'.length); // 2\n\n…But we can see that there’s only one, right? The point is that length treats 4 bytes as two 2-byte characters. That’s incorrect, because they must be considered only together (so-called “surrogate pair”, you can read about them in the article Strings).\n\nBy default, regular expressions also treat 4-byte “long characters” as a pair of 2-byte ones. And, as it happens with strings, that may lead to odd results. We’ll see that a bit later, in the article Sets and ranges [...].\n\nUnlike strings, regular expressions have flag u that fixes such problems. With such flag, a regexp handles 4-byte characters correctly. And also Unicode property search becomes available, we’ll get to it next.\n\nUnicode properties \\p{…}\n\nEvery character in Unicode has a lot of properties. They describe what “category” the character belongs to, contain miscellaneous information about it.\n\nFor instance, if a character has Letter property, it means that the character belongs to an alphabet (of any language). And Number property means that it’s a digit: maybe Arabic or Chinese, and so on.\n\nWe can search for characters with a property, written as \\p{…}. To use \\p{…}, a regular expression must have flag u.\n\nFor instance, \\p{Letter} denotes a letter in any language. We can also use \\p{L}, as L is an alias of Letter. There are shorter aliases for almost every property.\n\nIn the example below three kinds of letters will be found: English, Georgian and Korean.\n\n\t\nlet str = \"A ბ ㄱ\";\n\nalert( str.match(/\\p{L}/gu) ); // A,ბ,ㄱ\nalert( str.match(/\\p{L}/g) ); // null (no matches, \\p doesn't work without the flag \"u\")\n\nHere’s the main character categories and their subcategories:\n\nLetter L:\nlowercase Ll\nmodifier Lm,\ntitlecase Lt,\nuppercase Lu,\nother Lo.\nNumber N:\ndecimal digit Nd,\nletter number Nl,\nother No.\nPunctuation P:\nconnector Pc,\ndash Pd,\ninitial quote Pi,\nfinal quote Pf,\nopen Ps,\nclose Pe,\nother Po.\nMark M (accents etc):\nspacing combining Mc,\nenclosing Me,\nnon-spacing Mn.\nSymbol S:\ncurrency Sc,\nmodifier Sk,\nmath Sm,\nother So.\nSeparator Z:\nline Zl,\nparagraph Zp,\nspace Zs.\nOther C:\ncontrol Cc,\nformat Cf,\nnot assigned Cn,\nprivate use Co,\nsurrogate Cs.\n\nSo, e.g. if we need letters in lower case, we can write \\p{Ll}, punctuation signs: \\p{P} and so on.\n\nThere are also other derived categories, like:\n\nAlphabetic (Alpha), includes Letters L, plus letter numbers Nl (e.g. Ⅻ – a character for the roman number 12), plus some other symbols Other_Alphabetic (OAlpha).\nHex_Digit includes hexadecimal digits: 0-9, a-f.\n…And so on.\n\nUnicode supports many different properties, their full list would require a lot of space, so here are the references:\n\nList all properties by a character: https://unicode.org/cldr/utility/character.jsp.\nList all characters by a property: https://unicode.org/cldr/utility/list-unicodeset.jsp.\nShort aliases for properties: https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt.\nA full base of Unicode characters in text format, with all properties, is here: https://www.unicode.org/Public/UCD/latest/ucd/.\nExample: hexadecimal numbers\n\nFor instance, let’s look for hexadecimal numbers, written as xFF, where F is a hex digit (0…9 or A…F).\n\nA hex digit can be denoted as \\p{Hex_Digit}:\n\n\t\nlet regexp = /x\\p{Hex_Digit}\\p{Hex_Digit}/u;\n\nalert(\"number: xAF\".match(regexp)); // xAF\nExample: Chinese hieroglyphs\n\nLet’s look for Chinese hieroglyphs.\n\nThere’s a Unicode property Script (a writing system), that may have a value: Cyrillic, Greek, Arabic, Han (Chinese) and so on, here’s the full list.\n\nTo look for characters in a given writing system we should use Script=<value>, e.g. for Cyrillic letters: \\p{sc=Cyrillic}, for Chinese hieroglyphs: \\p{sc=Han}, and so on:\n\n\t\nlet regexp = /\\p{sc=Han}/gu; // returns Chinese hieroglyphs\n\nlet str = `Hello Привет 你好 123_456`;\n\nalert( str.match(regexp) ); // 你,好\nExample: currency\n\nCharacters that denote a currency, such as $, €, ¥, have Unicode property \\p{Currency_Symbol}, the short alias: \\p{Sc}.\n\nLet’s use it to look for prices in the format “currency, followed by a digit”:\n\n\t\nlet regexp = /\\p{Sc}\\d/gu;\n\nlet str = `Prices: $2, €1, ¥9`;\n\nalert( str.match(regexp) ); // $2,€1,¥9\n\nLater, in the article Quantifiers +, *, ? and {n} we’ll see how to look for numbers that contain many digits.\n\nSummary\n\nFlag u enables the support of Unicode in regular expressions.\n\nThat means two things:\n\nCharacters of 4 bytes are handled correctly: as a single character, not two 2-byte characters.\nUnicode properties can be used in the search: \\p{…}.\n\nWith Unicode properties we can look for words in given languages, special characters (quotes, currencies) and so on."
  },
  {
    "title": "Shadow DOM slots, composition",
    "url": "https://javascript.info/slots-composition",
    "html": "Many types of components, such as tabs, menus, image galleries, and so on, need the content to render.\n\nJust like built-in browser <select> expects <option> items, our <custom-tabs> may expect the actual tab content to be passed. And a <custom-menu> may expect menu items.\n\nThe code that makes use of <custom-menu> can look like this:\n\n<custom-menu>\n  <title>Candy menu</title>\n  <item>Lollipop</item>\n  <item>Fruit Toast</item>\n  <item>Cup Cake</item>\n</custom-menu>\n\n…Then our component should render it properly, as a nice menu with given title and items, handle menu events, etc.\n\nHow to implement it?\n\nWe could try to analyze the element content and dynamically copy-rearrange DOM nodes. That’s possible, but if we’re moving elements to shadow DOM, then CSS styles from the document do not apply in there, so the visual styling may be lost. Also that requires some coding.\n\nLuckily, we don’t have to. Shadow DOM supports <slot> elements, that are automatically filled by the content from light DOM.\n\nNamed slots\n\nLet’s see how slots work on a simple example.\n\nHere, <user-card> shadow DOM provides two slots, filled from light DOM:\n\n\t\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <div>Name:\n        <slot name=\"username\"></slot>\n      </div>\n      <div>Birthday:\n        <slot name=\"birthday\"></slot>\n      </div>\n    `;\n  }\n});\n</script>\n\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n\nIn the shadow DOM, <slot name=\"X\"> defines an “insertion point”, a place where elements with slot=\"X\" are rendered.\n\nThen the browser performs “composition”: it takes elements from the light DOM and renders them in corresponding slots of the shadow DOM. At the end, we have exactly what we want – a component that can be filled with data.\n\nHere’s the DOM structure after the script, not taking composition into account:\n\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\n\nWe created the shadow DOM, so here it is, under #shadow-root. Now the element has both light and shadow DOM.\n\nFor rendering purposes, for each <slot name=\"...\"> in shadow DOM, the browser looks for slot=\"...\" with the same name in the light DOM. These elements are rendered inside the slots:\n\nThe result is called “flattened” DOM:\n\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <!-- slotted element is inserted into the slot -->\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n</user-card>\n\n…But the flattened DOM exists only for rendering and event-handling purposes. It’s kind of “virtual”. That’s how things are shown. But the nodes in the document are actually not moved around!\n\nThat can be easily checked if we run querySelectorAll: nodes are still at their places.\n\n// light DOM <span> nodes are still at the same place, under `<user-card>`\nalert( document.querySelectorAll('user-card span').length ); // 2\n\nSo, the flattened DOM is derived from shadow DOM by inserting slots. The browser renders it and uses for style inheritance, event propagation (more about that later). But JavaScript still sees the document “as is”, before flattening.\n\nOnly top-level children may have slot=\"…\" attribute\n\nThe slot=\"...\" attribute is only valid for direct children of the shadow host (in our example, <user-card> element). For nested elements it’s ignored.\n\nFor example, the second <span> here is ignored (as it’s not a top-level child of <user-card>):\n\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <div>\n    <!-- invalid slot, must be direct child of user-card -->\n    <span slot=\"birthday\">01.01.2001</span>\n  </div>\n</user-card>\n\nIf there are multiple elements in light DOM with the same slot name, they are appended into the slot, one after another.\n\nFor example, this:\n\n<user-card>\n  <span slot=\"username\">John</span>\n  <span slot=\"username\">Smith</span>\n</user-card>\n\nGives this flattened DOM with two elements in <slot name=\"username\">:\n\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <span slot=\"username\">John</span>\n        <span slot=\"username\">Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n</user-card>\nSlot fallback content\n\nIf we put something inside a <slot>, it becomes the fallback, “default” content. The browser shows it if there’s no corresponding filler in light DOM.\n\nFor example, in this piece of shadow DOM, Anonymous renders if there’s no slot=\"username\" in light DOM.\n\n<div>Name:\n  <slot name=\"username\">Anonymous</slot>\n</div>\nDefault slot: first unnamed\n\nThe first <slot> in shadow DOM that doesn’t have a name is a “default” slot. It gets all nodes from the light DOM that aren’t slotted elsewhere.\n\nFor example, let’s add the default slot to our <user-card> that shows all unslotted information about the user:\n\n\t\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n    <div>Name:\n      <slot name=\"username\"></slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\"></slot>\n    </div>\n    <fieldset>\n      <legend>Other information</legend>\n      <slot></slot>\n    </fieldset>\n    `;\n  }\n});\n</script>\n\n<user-card>\n  <div>I like to swim.</div>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n  <div>...And play volleyball too!</div>\n</user-card>\n\nAll the unslotted light DOM content gets into the “Other information” fieldset.\n\nElements are appended to a slot one after another, so both unslotted pieces of information are in the default slot together.\n\nThe flattened DOM looks like this:\n\n<user-card>\n  #shadow-root\n    <div>Name:\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n    <div>Birthday:\n      <slot name=\"birthday\">\n        <span slot=\"birthday\">01.01.2001</span>\n      </slot>\n    </div>\n    <fieldset>\n      <legend>Other information</legend>\n      <slot>\n        <div>I like to swim.</div>\n        <div>...And play volleyball too!</div>\n      </slot>\n    </fieldset>\n</user-card>\nMenu example\n\nNow let’s back to <custom-menu>, mentioned at the beginning of the chapter.\n\nWe can use slots to distribute elements.\n\nHere’s the markup for <custom-menu>:\n\n<custom-menu>\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n  <li slot=\"item\">Cup Cake</li>\n</custom-menu>\n\nThe shadow DOM template with proper slots:\n\n<template id=\"tmpl\">\n  <style> /* menu styles */ </style>\n  <div class=\"menu\">\n    <slot name=\"title\"></slot>\n    <ul><slot name=\"item\"></slot></ul>\n  </div>\n</template>\n<span slot=\"title\"> goes into <slot name=\"title\">.\nThere are many <li slot=\"item\"> in the <custom-menu>, but only one <slot name=\"item\"> in the template. So all such <li slot=\"item\"> are appended to <slot name=\"item\"> one after another, thus forming the list.\n\nThe flattened DOM becomes:\n\n<custom-menu>\n  #shadow-root\n    <style> /* menu styles */ </style>\n    <div class=\"menu\">\n      <slot name=\"title\">\n        <span slot=\"title\">Candy menu</span>\n      </slot>\n      <ul>\n        <slot name=\"item\">\n          <li slot=\"item\">Lollipop</li>\n          <li slot=\"item\">Fruit Toast</li>\n          <li slot=\"item\">Cup Cake</li>\n        </slot>\n      </ul>\n    </div>\n</custom-menu>\n\nOne might notice that, in a valid DOM, <li> must be a direct child of <ul>. But that’s flattened DOM, it describes how the component is rendered, such thing happens naturally here.\n\nWe just need to add a click handler to open/close the list, and the <custom-menu> is ready:\n\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n\n    // tmpl is the shadow DOM template (above)\n    this.shadowRoot.append( tmpl.content.cloneNode(true) );\n\n    // we can't select light DOM nodes, so let's handle clicks on the slot\n    this.shadowRoot.querySelector('slot[name=\"title\"]').onclick = () => {\n      // open/close the menu\n      this.shadowRoot.querySelector('.menu').classList.toggle('closed');\n    };\n  }\n});\n\nHere’s the full demo:\n\nOf course, we can add more functionality to it: events, methods and so on.\n\nUpdating slots\n\nWhat if the outer code wants to add/remove menu items dynamically?\n\nThe browser monitors slots and updates the rendering if slotted elements are added/removed.\n\nAlso, as light DOM nodes are not copied, but just rendered in slots, the changes inside them immediately become visible.\n\nSo we don’t have to do anything to update rendering. But if the component code wants to know about slot changes, then slotchange event is available.\n\nFor example, here the menu item is inserted dynamically after 1 second, and the title changes after 2 seconds:\n\n\t\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // shadowRoot can't have event handlers, so using the first child\n    this.shadowRoot.firstElementChild.addEventListener('slotchange',\n      e => alert(\"slotchange: \" + e.target.name)\n    );\n  }\n});\n\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Lollipop</li>')\n}, 1000);\n\nsetTimeout(() => {\n  menu.querySelector('[slot=\"title\"]').innerHTML = \"New menu\";\n}, 2000);\n</script>\n\nThe menu rendering updates each time without our intervention.\n\nThere are two slotchange events here:\n\nAt initialization:\n\nslotchange: title triggers immediately, as the slot=\"title\" from the light DOM gets into the corresponding slot.\n\nAfter 1 second:\n\nslotchange: item triggers, when a new <li slot=\"item\"> is added.\n\nPlease note: there’s no slotchange event after 2 seconds, when the content of slot=\"title\" is modified. That’s because there’s no slot change. We modify the content inside the slotted element, that’s another thing.\n\nIf we’d like to track internal modifications of light DOM from JavaScript, that’s also possible using a more generic mechanism: MutationObserver.\n\nSlot API\n\nFinally, let’s mention the slot-related JavaScript methods.\n\nAs we’ve seen before, JavaScript looks at the “real” DOM, without flattening. But, if the shadow tree has {mode: 'open'}, then we can figure out which elements assigned to a slot and, vice-versa, the slot by the element inside it:\n\nnode.assignedSlot – returns the <slot> element that the node is assigned to.\nslot.assignedNodes({flatten: true/false}) – DOM nodes, assigned to the slot. The flatten option is false by default. If explicitly set to true, then it looks more deeply into the flattened DOM, returning nested slots in case of nested components and the fallback content if no node assigned.\nslot.assignedElements({flatten: true/false}) – DOM elements, assigned to the slot (same as above, but only element nodes).\n\nThese methods are useful when we need not just show the slotted content, but also track it in JavaScript.\n\nFor example, if <custom-menu> component wants to know, what it shows, then it could track slotchange and get the items from slot.assignedElements:\n\n\t\n<custom-menu id=\"menu\">\n  <span slot=\"title\">Candy menu</span>\n  <li slot=\"item\">Lollipop</li>\n  <li slot=\"item\">Fruit Toast</li>\n</custom-menu>\n\n<script>\ncustomElements.define('custom-menu', class extends HTMLElement {\n  items = []\n\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div class=\"menu\">\n      <slot name=\"title\"></slot>\n      <ul><slot name=\"item\"></slot></ul>\n    </div>`;\n\n    // triggers when slot content changes\n    this.shadowRoot.firstElementChild.addEventListener('slotchange', e => {\n      let slot = e.target;\n      if (slot.name == 'item') {\n        this.items = slot.assignedElements().map(elem => elem.textContent);\n        alert(\"Items: \" + this.items);\n      }\n    });\n  }\n});\n\n// items update after 1 second\nsetTimeout(() => {\n  menu.insertAdjacentHTML('beforeEnd', '<li slot=\"item\">Cup Cake</li>')\n}, 1000);\n</script>\nSummary\n\nUsually, if an element has shadow DOM, then its light DOM is not displayed. Slots allow to show elements from light DOM in specified places of shadow DOM.\n\nThere are two kinds of slots:\n\nNamed slots: <slot name=\"X\">...</slot> – gets light children with slot=\"X\".\nDefault slot: the first <slot> without a name (subsequent unnamed slots are ignored) – gets unslotted light children.\nIf there are many elements for the same slot – they are appended one after another.\nThe content of <slot> element is used as a fallback. It’s shown if there are no light children for the slot.\n\nThe process of rendering slotted elements inside their slots is called “composition”. The result is called a “flattened DOM”.\n\nComposition does not really move nodes, from JavaScript point of view the DOM is still same.\n\nJavaScript can access slots using methods:\n\nslot.assignedNodes/Elements() – returns nodes/elements inside the slot.\nnode.assignedSlot – the reverse property, returns slot by a node.\n\nIf we’d like to know what we’re showing, we can track slot contents using:\n\nslotchange event – triggers the first time a slot is filled, and on any add/remove/replace operation of the slotted element, but not its children. The slot is event.target.\nMutationObserver to go deeper into slot content, watch changes inside it.\n\nNow, as we know how to show elements from light DOM in shadow DOM, let’s see how to style them properly. The basic rule is that shadow elements are styled inside, and light elements – outside, but there are notable exceptions.\n\nWe’ll see the details in the next chapter."
  },
  {
    "title": "Character classes",
    "url": "https://javascript.info/regexp-character-classes",
    "html": "Consider a practical task – we have a phone number like \"+7(903)-123-45-67\", and we need to turn it into pure numbers: 79031234567.\n\nTo do so, we can find and remove anything that’s not a number. Character classes can help with that.\n\nA character class is a special notation that matches any symbol from a certain set.\n\nFor the start, let’s explore the “digit” class. It’s written as \\d and corresponds to “any single digit”.\n\nFor instance, let’s find the first digit in the phone number:\n\n\t\nlet str = \"+7(903)-123-45-67\";\n\nlet regexp = /\\d/;\n\nalert( str.match(regexp) ); // 7\n\nWithout the flag g, the regular expression only looks for the first match, that is the first digit \\d.\n\nLet’s add the g flag to find all digits:\n\n\t\nlet str = \"+7(903)-123-45-67\";\n\nlet regexp = /\\d/g;\n\nalert( str.match(regexp) ); // array of matches: 7,9,0,3,1,2,3,4,5,6,7\n\n// let's make the digits-only phone number of them:\nalert( str.match(regexp).join('') ); // 79031234567\n\nThat was a character class for digits. There are other character classes as well.\n\nMost used are:\n\n\\d (“d” is from “digit”)\nA digit: a character from 0 to 9.\n\\s (“s” is from “space”)\nA space symbol: includes spaces, tabs \\t, newlines \\n and few other rare characters, such as \\v, \\f and \\r.\n\\w (“w” is from “word”)\nA “wordly” character: either a letter of Latin alphabet or a digit or an underscore _. Non-Latin letters (like cyrillic or hindi) do not belong to \\w.\n\nFor instance, \\d\\s\\w means a “digit” followed by a “space character” followed by a “wordly character”, such as 1 a.\n\nA regexp may contain both regular symbols and character classes.\n\nFor instance, CSS\\d matches a string CSS with a digit after it:\n\n\t\nlet str = \"Is there CSS4?\";\nlet regexp = /CSS\\d/\n\nalert( str.match(regexp) ); // CSS4\n\nAlso we can use many character classes:\n\n\t\nalert( \"I love HTML5!\".match(/\\s\\w\\w\\w\\w\\d/) ); // ' HTML5'\n\nThe match (each regexp character class has the corresponding result character):\n\nInverse classes\n\nFor every character class there exists an “inverse class”, denoted with the same letter, but uppercased.\n\nThe “inverse” means that it matches all other characters, for instance:\n\n\\D\nNon-digit: any character except \\d, for instance a letter.\n\\S\nNon-space: any character except \\s, for instance a letter.\n\\W\nNon-wordly character: anything but \\w, e.g a non-latin letter or a space.\n\nIn the beginning of the chapter we saw how to make a number-only phone number from a string like +7(903)-123-45-67: find all digits and join them.\n\n\t\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.match(/\\d/g).join('') ); // 79031234567\n\nAn alternative, shorter way is to find non-digits \\D and remove them from the string:\n\n\t\nlet str = \"+7(903)-123-45-67\";\n\nalert( str.replace(/\\D/g, \"\") ); // 79031234567\nA dot is “any character”\n\nA dot . is a special character class that matches “any character except a newline”.\n\nFor instance:\n\n\t\nalert( \"Z\".match(/./) ); // Z\n\nOr in the middle of a regexp:\n\n\t\nlet regexp = /CS.4/;\n\nalert( \"CSS4\".match(regexp) ); // CSS4\nalert( \"CS-4\".match(regexp) ); // CS-4\nalert( \"CS 4\".match(regexp) ); // CS 4 (space is also a character)\n\nPlease note that a dot means “any character”, but not the “absence of a character”. There must be a character to match it:\n\n\t\nalert( \"CS4\".match(/CS.4/) ); // null, no match because there's no character for the dot\nDot as literally any character with “s” flag\n\nBy default, a dot doesn’t match the newline character \\n.\n\nFor instance, the regexp A.B matches A, and then B with any character between them, except a newline \\n:\n\n\t\nalert( \"A\\nB\".match(/A.B/) ); // null (no match)\n\nThere are many situations when we’d like a dot to mean literally “any character”, newline included.\n\nThat’s what flag s does. If a regexp has it, then a dot . matches literally any character:\n\n\t\nalert( \"A\\nB\".match(/A.B/s) ); // A\\nB (match!)\nNot supported in IE\n\nThe s flag is not supported in IE.\n\nLuckily, there’s an alternative, that works everywhere. We can use a regexp like [\\s\\S] to match “any character” (this pattern will be covered in the article Sets and ranges [...]).\n\n\t\nalert( \"A\\nB\".match(/A[\\s\\S]B/) ); // A\\nB (match!)\n\nThe pattern [\\s\\S] literally says: “a space character OR not a space character”. In other words, “anything”. We could use another pair of complementary classes, such as [\\d\\D], that doesn’t matter. Or even the [^] – as it means match any character except nothing.\n\nAlso we can use this trick if we want both kind of “dots” in the same pattern: the actual dot . behaving the regular way (“not including a newline”), and also a way to match “any character” with [\\s\\S] or alike.\n\nPay attention to spaces\n\nUsually we pay little attention to spaces. For us strings 1-5 and 1 - 5 are nearly identical.\n\nBut if a regexp doesn’t take spaces into account, it may fail to work.\n\nLet’s try to find digits separated by a hyphen:\n\n\t\nalert( \"1 - 5\".match(/\\d-\\d/) ); // null, no match!\n\nLet’s fix it adding spaces into the regexp \\d - \\d:\n\n\t\nalert( \"1 - 5\".match(/\\d - \\d/) ); // 1 - 5, now it works\n// or we can use \\s class:\nalert( \"1 - 5\".match(/\\d\\s-\\s\\d/) ); // 1 - 5, also works\n\nA space is a character. Equal in importance with any other character.\n\nWe can’t add or remove spaces from a regular expression and expect it to work the same.\n\nIn other words, in a regular expression all characters matter, spaces too.\n\nSummary\n\nThere exist following character classes:\n\n\\d – digits.\n\\D – non-digits.\n\\s – space symbols, tabs, newlines.\n\\S – all but \\s.\n\\w – Latin letters, digits, underscore '_'.\n\\W – all but \\w.\n. – any character if with the regexp 's' flag, otherwise any except a newline \\n.\n\n…But that’s not all!\n\nUnicode encoding, used by JavaScript for strings, provides many properties for characters, like: which language the letter belongs to (if it’s a letter), is it a punctuation sign, etc.\n\nWe can search by these properties as well. That requires flag u, covered in the next article."
  },
  {
    "title": "Patterns and flags",
    "url": "https://javascript.info/regexp-introduction",
    "html": "Regular expressions are patterns that provide a powerful way to search and replace in text.\n\nIn JavaScript, they are available via the RegExp object, as well as being integrated in methods of strings.\n\nRegular Expressions\n\nA regular expression (also “regexp”, or just “reg”) consists of a pattern and optional flags.\n\nThere are two syntaxes that can be used to create a regular expression object.\n\nThe “long” syntax:\n\nregexp = new RegExp(\"pattern\", \"flags\");\n\nAnd the “short” one, using slashes \"/\":\n\nregexp = /pattern/; // no flags\nregexp = /pattern/gmi; // with flags g,m and i (to be covered soon)\n\nSlashes /.../ tell JavaScript that we are creating a regular expression. They play the same role as quotes for strings.\n\nIn both cases regexp becomes an instance of the built-in RegExp class.\n\nThe main difference between these two syntaxes is that pattern using slashes /.../ does not allow for expressions to be inserted (like string template literals with ${...}). They are fully static.\n\nSlashes are used when we know the regular expression at the code writing time – and that’s the most common situation. While new RegExp is more often used when we need to create a regexp “on the fly” from a dynamically generated string. For instance:\n\nlet tag = prompt(\"What tag do you want to find?\", \"h2\");\n\nlet regexp = new RegExp(`<${tag}>`); // same as /<h2>/ if answered \"h2\" in the prompt above\nFlags\n\nRegular expressions may have flags that affect the search.\n\nThere are only 6 of them in JavaScript:\n\ni\nWith this flag the search is case-insensitive: no difference between A and a (see the example below).\ng\nWith this flag the search looks for all matches, without it – only the first match is returned.\nm\nMultiline mode (covered in the chapter Multiline mode of anchors ^ $, flag \"m\").\ns\nEnables “dotall” mode, that allows a dot . to match newline character \\n (covered in the chapter Character classes).\nu\nEnables full Unicode support. The flag enables correct processing of surrogate pairs. More about that in the chapter Unicode: flag \"u\" and class \\p{...}.\ny\n“Sticky” mode: searching at the exact position in the text (covered in the chapter Sticky flag \"y\", searching at position)\nColors\n\nFrom here on the color scheme is:\n\nregexp – red\nstring (where we search) – blue\nresult – green\nSearching: str.match\n\nAs mentioned previously, regular expressions are integrated with string methods.\n\nThe method str.match(regexp) finds all matches of regexp in the string str.\n\nIt has 3 working modes:\n\nIf the regular expression has flag g, it returns an array of all matches:\n\n\t\nlet str = \"We will, we will rock you\";\n\nalert( str.match(/we/gi) ); // We,we (an array of 2 substrings that match)\n\nPlease note that both We and we are found, because flag i makes the regular expression case-insensitive.\n\nIf there’s no such flag it returns only the first match in the form of an array, with the full match at index 0 and some additional details in properties:\n\n\t\nlet str = \"We will, we will rock you\";\n\nlet result = str.match(/we/i); // without flag g\n\nalert( result[0] );     // We (1st match)\nalert( result.length ); // 1\n\n// Details:\nalert( result.index );  // 0 (position of the match)\nalert( result.input );  // We will, we will rock you (source string)\n\nThe array may have other indexes, besides 0 if a part of the regular expression is enclosed in parentheses. We’ll cover that in the chapter Capturing groups.\n\nAnd, finally, if there are no matches, null is returned (doesn’t matter if there’s flag g or not).\n\nThis a very important nuance. If there are no matches, we don’t receive an empty array, but instead receive null. Forgetting about that may lead to errors, e.g.:\n\n\t\nlet matches = \"JavaScript\".match(/HTML/); // = null\n\nif (!matches.length) { // Error: Cannot read property 'length' of null\n  alert(\"Error in the line above\");\n}\n\nIf we’d like the result to always be an array, we can write it this way:\n\n\t\nlet matches = \"JavaScript\".match(/HTML/) || [];\n\nif (!matches.length) {\n  alert(\"No matches\"); // now it works\n}\nReplacing: str.replace\n\nThe method str.replace(regexp, replacement) replaces matches found using regexp in string str with replacement (all matches if there’s flag g, otherwise, only the first one).\n\nFor instance:\n\n\t\n// no flag g\nalert( \"We will, we will\".replace(/we/i, \"I\") ); // I will, we will\n\n// with flag g\nalert( \"We will, we will\".replace(/we/ig, \"I\") ); // I will, I will\n\nThe second argument is the replacement string. We can use special character combinations in it to insert fragments of the match:\n\nSymbols\tAction in the replacement string\n$&\tinserts the whole match\n$`\tinserts a part of the string before the match\n$'\tinserts a part of the string after the match\n$n\tif n is a 1-2 digit number, then it inserts the contents of n-th parentheses, more about it in the chapter Capturing groups\n$<name>\tinserts the contents of the parentheses with the given name, more about it in the chapter Capturing groups\n$$\tinserts character $\n\nAn example with $&:\n\n\t\nalert( \"I love HTML\".replace(/HTML/, \"$& and JavaScript\") ); // I love HTML and JavaScript\nTesting: regexp.test\n\nThe method regexp.test(str) looks for at least one match, if found, returns true, otherwise false.\n\n\t\nlet str = \"I love JavaScript\";\nlet regexp = /LOVE/i;\n\nalert( regexp.test(str) ); // true\n\nLater in this chapter we’ll study more regular expressions, walk through more examples, and also meet other methods.\n\nFull information about the methods is given in the article Methods of RegExp and String.\n\nSummary\nA regular expression consists of a pattern and optional flags: g, i, m, u, s, y.\nWithout flags and special symbols (that we’ll study later), the search by a regexp is the same as a substring search.\nThe method str.match(regexp) looks for matches: all of them if there’s g flag, otherwise, only the first one.\nThe method str.replace(regexp, replacement) replaces matches found using regexp with replacement: all of them if there’s g flag, otherwise only the first one.\nThe method regexp.test(str) returns true if there’s at least one match, otherwise, it returns false."
  },
  {
    "title": "Shadow DOM styling",
    "url": "https://javascript.info/shadow-dom-style",
    "html": "Shadow DOM may include both <style> and <link rel=\"stylesheet\" href=\"…\"> tags. In the latter case, stylesheets are HTTP-cached, so they are not redownloaded for multiple components that use same template.\n\nAs a general rule, local styles work only inside the shadow tree, and document styles work outside of it. But there are few exceptions.\n\n:host\n\nThe :host selector allows to select the shadow host (the element containing the shadow tree).\n\nFor instance, we’re making <custom-dialog> element that should be centered. For that we need to style the <custom-dialog> element itself.\n\nThat’s exactly what :host does:\n\n\t\n<template id=\"tmpl\">\n  <style>\n    /* the style will be applied from inside to the custom-dialog element */\n    :host {\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n<custom-dialog>\n  Hello!\n</custom-dialog>\nCascading\n\nThe shadow host (<custom-dialog> itself) resides in the light DOM, so it’s affected by document CSS rules.\n\nIf there’s a property styled both in :host locally, and in the document, then the document style takes precedence.\n\nFor instance, if in the document we had:\n\n<style>\ncustom-dialog {\n  padding: 0;\n}\n</style>\n\n…Then the <custom-dialog> would be without padding.\n\nIt’s very convenient, as we can setup “default” component styles in its :host rule, and then easily override them in the document.\n\nThe exception is when a local property is labelled !important, for such properties, local styles take precedence.\n\n:host(selector)\n\nSame as :host, but applied only if the shadow host matches the selector.\n\nFor example, we’d like to center the <custom-dialog> only if it has centered attribute:\n\n\t\n<template id=\"tmpl\">\n  <style>\n    :host([centered]) {\n      position: fixed;\n      left: 50%;\n      top: 50%;\n      transform: translate(-50%, -50%);\n      border-color: blue;\n    }\n\n    :host {\n      display: inline-block;\n      border: 1px solid red;\n      padding: 10px;\n    }\n  </style>\n  <slot></slot>\n</template>\n\n<script>\ncustomElements.define('custom-dialog', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));\n  }\n});\n</script>\n\n\n<custom-dialog centered>\n  Centered!\n</custom-dialog>\n\n<custom-dialog>\n  Not centered.\n</custom-dialog>\n\nNow the additional centering styles are only applied to the first dialog: <custom-dialog centered>.\n\nTo summarize, we can use :host-family of selectors to style the main element of the component. These styles (unless !important) can be overridden by the document.\n\nStyling slotted content\n\nNow let’s consider the situation with slots.\n\nSlotted elements come from light DOM, so they use document styles. Local styles do not affect slotted content.\n\nIn the example below, slotted <span> is bold, as per document style, but does not take background from the local style:\n\n\t\n<style>\n  span { font-weight: bold }\n</style>\n\n<user-card>\n  <div slot=\"username\"><span>John Smith</span></div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n      span { background: red; }\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n\nThe result is bold, but not red.\n\nIf we’d like to style slotted elements in our component, there are two choices.\n\nFirst, we can style the <slot> itself and rely on CSS inheritance:\n\n\t\n<user-card>\n  <div slot=\"username\"><span>John Smith</span></div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n      slot[name=\"username\"] { font-weight: bold; }\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n\nHere <p>John Smith</p> becomes bold, because CSS inheritance is in effect between the <slot> and its contents. But in CSS itself not all properties are inherited.\n\nAnother option is to use ::slotted(selector) pseudo-class. It matches elements based on two conditions:\n\nThat’s a slotted element, that comes from the light DOM. Slot name doesn’t matter. Just any slotted element, but only the element itself, not its children.\nThe element matches the selector.\n\nIn our example, ::slotted(div) selects exactly <div slot=\"username\">, but not its children:\n\n\t\n<user-card>\n  <div slot=\"username\">\n    <div>John Smith</div>\n  </div>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `\n      <style>\n      ::slotted(div) { border: 1px solid red; }\n      </style>\n      Name: <slot name=\"username\"></slot>\n    `;\n  }\n});\n</script>\n\nPlease note, ::slotted selector can’t descend any further into the slot. These selectors are invalid:\n\n::slotted(div span) {\n  /* our slotted <div> does not match this */\n}\n\n::slotted(div) p {\n  /* can't go inside light DOM */\n}\n\nAlso, ::slotted can only be used in CSS. We can’t use it in querySelector.\n\nCSS hooks with custom properties\n\nHow do we style internal elements of a component from the main document?\n\nSelectors like :host apply rules to <custom-dialog> element or <user-card>, but how to style shadow DOM elements inside them?\n\nThere’s no selector that can directly affect shadow DOM styles from the document. But just as we expose methods to interact with our component, we can expose CSS variables (custom CSS properties) to style it.\n\nCustom CSS properties exist on all levels, both in light and shadow.\n\nFor example, in shadow DOM we can use --user-card-field-color CSS variable to style fields, and the outer document can set its value:\n\n<style>\n  .field {\n    color: var(--user-card-field-color, black);\n    /* if --user-card-field-color is not defined, use black color */\n  }\n</style>\n<div class=\"field\">Name: <slot name=\"username\"></slot></div>\n<div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n\nThen, we can declare this property in the outer document for <user-card>:\n\nuser-card {\n  --user-card-field-color: green;\n}\n\nCustom CSS properties pierce through shadow DOM, they are visible everywhere, so the inner .field rule will make use of it.\n\nHere’s the full example:\n\n\t\n<style>\n  user-card {\n    --user-card-field-color: green;\n  }\n</style>\n\n<template id=\"tmpl\">\n  <style>\n    .field {\n      color: var(--user-card-field-color, black);\n    }\n  </style>\n  <div class=\"field\">Name: <slot name=\"username\"></slot></div>\n  <div class=\"field\">Birthday: <slot name=\"birthday\"></slot></div>\n</template>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));\n  }\n});\n</script>\n\n<user-card>\n  <span slot=\"username\">John Smith</span>\n  <span slot=\"birthday\">01.01.2001</span>\n</user-card>\nSummary\n\nShadow DOM can include styles, such as <style> or <link rel=\"stylesheet\">.\n\nLocal styles can affect:\n\nshadow tree,\nshadow host with :host and :host() pseudoclasses,\nslotted elements (coming from light DOM), ::slotted(selector) allows to select slotted elements themselves, but not their children.\n\nDocument styles can affect:\n\nshadow host (as it lives in the outer document)\nslotted elements and their contents (as that’s also in the outer document)\n\nWhen CSS properties conflict, normally document styles have precedence, unless the property is labelled as !important. Then local styles have precedence.\n\nCSS custom properties pierce through shadow DOM. They are used as “hooks” to style the component:\n\nThe component uses a custom CSS property to style key elements, such as var(--component-name-title, <default value>).\nComponent author publishes these properties for developers, they are same important as other public component methods.\nWhen a developer wants to style a title, they assign --component-name-title CSS property for the shadow host or above.\nProfit!"
  },
  {
    "title": "Regular expressions",
    "url": "https://javascript.info/regular-expressions",
    "html": "Regular expressions is a powerful way of doing search and replace in strings.\n\nPatterns and flags\nCharacter classes\nUnicode: flag \"u\" and class \\p{...}\nAnchors: string start ^ and end $\nMultiline mode of anchors ^ $, flag \"m\"\nWord boundary: \\b\nEscaping, special characters\nSets and ranges [...]\nQuantifiers +, *, ? and {n}\nGreedy and lazy quantifiers\nCapturing groups\nBackreferences in pattern: \\N and \\k<name>\nAlternation (OR) |\nLookahead and lookbehind\nCatastrophic backtracking\nSticky flag \"y\", searching at position\nMethods of RegExp and String"
  },
  {
    "title": "Shadow DOM and events",
    "url": "https://javascript.info/shadow-dom-events",
    "html": "The idea behind shadow tree is to encapsulate internal implementation details of a component.\n\nLet’s say, a click event happens inside a shadow DOM of <user-card> component. But scripts in the main document have no idea about the shadow DOM internals, especially if the component comes from a 3rd-party library.\n\nSo, to keep the details encapsulated, the browser retargets the event.\n\nEvents that happen in shadow DOM have the host element as the target, when caught outside of the component.\n\nHere’s a simple example:\n\n\t\n<user-card></user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<p>\n      <button>Click me</button>\n    </p>`;\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Inner target: \" + e.target.tagName);\n  }\n});\n\ndocument.onclick =\n  e => alert(\"Outer target: \" + e.target.tagName);\n</script>\n\nIf you click on the button, the messages are:\n\nInner target: BUTTON – internal event handler gets the correct target, the element inside shadow DOM.\nOuter target: USER-CARD – document event handler gets shadow host as the target.\n\nEvent retargeting is a great thing to have, because the outer document doesn’t have to know about component internals. From its point of view, the event happened on <user-card>.\n\nRetargeting does not occur if the event occurs on a slotted element, that physically lives in the light DOM.\n\nFor example, if a user clicks on <span slot=\"username\"> in the example below, the event target is exactly this span element, for both shadow and light handlers:\n\n\t\n<user-card id=\"userCard\">\n  <span slot=\"username\">John Smith</span>\n</user-card>\n\n<script>\ncustomElements.define('user-card', class extends HTMLElement {\n  connectedCallback() {\n    this.attachShadow({mode: 'open'});\n    this.shadowRoot.innerHTML = `<div>\n      <b>Name:</b> <slot name=\"username\"></slot>\n    </div>`;\n\n    this.shadowRoot.firstElementChild.onclick =\n      e => alert(\"Inner target: \" + e.target.tagName);\n  }\n});\n\nuserCard.onclick = e => alert(`Outer target: ${e.target.tagName}`);\n</script>\n\nIf a click happens on \"John Smith\", for both inner and outer handlers the target is <span slot=\"username\">. That’s an element from the light DOM, so no retargeting.\n\nOn the other hand, if the click occurs on an element originating from shadow DOM, e.g. on <b>Name</b>, then, as it bubbles out of the shadow DOM, its event.target is reset to <user-card>.\n\nBubbling, event.composedPath()\n\nFor purposes of event bubbling, flattened DOM is used.\n\nSo, if we have a slotted element, and an event occurs somewhere inside it, then it bubbles up to the <slot> and upwards.\n\nThe full path to the original event target, with all the shadow elements, can be obtained using event.composedPath(). As we can see from the name of the method, that path is taken after the composition.\n\nIn the example above, the flattened DOM is:\n\n<user-card id=\"userCard\">\n  #shadow-root\n    <div>\n      <b>Name:</b>\n      <slot name=\"username\">\n        <span slot=\"username\">John Smith</span>\n      </slot>\n    </div>\n</user-card>\n\nSo, for a click on <span slot=\"username\">, a call to event.composedPath() returns an array: [span, slot, div, shadow-root, user-card, body, html, document, window]. That’s exactly the parent chain from the target element in the flattened DOM, after the composition.\n\nShadow tree details are only provided for {mode:'open'} trees\n\nIf the shadow tree was created with {mode: 'closed'}, then the composed path starts from the host: user-card and upwards.\n\nThat’s the similar principle as for other methods that work with shadow DOM. Internals of closed trees are completely hidden.\n\nevent.composed\n\nMost events successfully bubble through a shadow DOM boundary. There are few events that do not.\n\nThis is governed by the composed event object property. If it’s true, then the event does cross the boundary. Otherwise, it only can be caught from inside the shadow DOM.\n\nIf you take a look at UI Events specification, most events have composed: true:\n\nblur, focus, focusin, focusout,\nclick, dblclick,\nmousedown, mouseup mousemove, mouseout, mouseover,\nwheel,\nbeforeinput, input, keydown, keyup.\n\nAll touch events and pointer events also have composed: true.\n\nThere are some events that have composed: false though:\n\nmouseenter, mouseleave (they do not bubble at all),\nload, unload, abort, error,\nselect,\nslotchange.\n\nThese events can be caught only on elements within the same DOM, where the event target resides.\n\nCustom events\n\nWhen we dispatch custom events, we need to set both bubbles and composed properties to true for it to bubble up and out of the component.\n\nFor example, here we create div#inner in the shadow DOM of div#outer and trigger two events on it. Only the one with composed: true makes it outside to the document:\n\n\t\n<div id=\"outer\"></div>\n\n<script>\nouter.attachShadow({mode: 'open'});\n\nlet inner = document.createElement('div');\nouter.shadowRoot.append(inner);\n\n/*\ndiv(id=outer)\n  #shadow-dom\n    div(id=inner)\n*/\n\ndocument.addEventListener('test', event => alert(event.detail));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n  composed: true,\n  detail: \"composed\"\n}));\n\ninner.dispatchEvent(new CustomEvent('test', {\n  bubbles: true,\n  composed: false,\n  detail: \"not composed\"\n}));\n</script>\nSummary\n\nEvents only cross shadow DOM boundaries if their composed flag is set to true.\n\nBuilt-in events mostly have composed: true, as described in the relevant specifications:\n\nUI Events https://www.w3.org/TR/uievents.\nTouch Events https://w3c.github.io/touch-events.\nPointer Events https://www.w3.org/TR/pointerevents.\n…And so on.\n\nSome built-in events that have composed: false:\n\nmouseenter, mouseleave (also do not bubble),\nload, unload, abort, error,\nselect,\nslotchange.\n\nThese events can be caught only on elements within the same DOM.\n\nIf we dispatch a CustomEvent, then we should explicitly set composed: true.\n\nPlease note that in case of nested components, one shadow DOM may be nested into another. In that case composed events bubble through all shadow DOM boundaries. So, if an event is intended only for the immediate enclosing component, we can also dispatch it on the shadow host and set composed: false. Then it’s out of the component shadow DOM, but won’t bubble up to higher-level DOM."
  },
  {
    "title": "CSS-animations",
    "url": "https://javascript.info/css-animations",
    "html": "CSS animations make it possible to do simple animations without JavaScript at all.\n\nJavaScript can be used to control CSS animations and make them even better, with little code.\n\nCSS transitions\n\nThe idea of CSS transitions is simple. We describe a property and how its changes should be animated. When the property changes, the browser paints the animation.\n\nThat is, all we need is to change the property, and the fluid transition will be done by the browser.\n\nFor instance, the CSS below animates changes of background-color for 3 seconds:\n\n.animated {\n  transition-property: background-color;\n  transition-duration: 3s;\n}\n\nNow if an element has .animated class, any change of background-color is animated during 3 seconds.\n\nClick the button below to animate the background:\n\n\t\n<button id=\"color\">Click me</button>\n\n<style>\n  #color {\n    transition-property: background-color;\n    transition-duration: 3s;\n  }\n</style>\n\n<script>\n  color.onclick = function() {\n    this.style.backgroundColor = 'red';\n  };\n</script>\n\nThere are 4 properties to describe CSS transitions:\n\ntransition-property\ntransition-duration\ntransition-timing-function\ntransition-delay\n\nWe’ll cover them in a moment, for now let’s note that the common transition property allows declaring them together in the order: property duration timing-function delay, as well as animating multiple properties at once.\n\nFor instance, this button animates both color and font-size:\n\n\t\n<button id=\"growing\">Click me</button>\n\n<style>\n#growing {\n  transition: font-size 3s, color 2s;\n}\n</style>\n\n<script>\ngrowing.onclick = function() {\n  this.style.fontSize = '36px';\n  this.style.color = 'red';\n};\n</script>\n\nNow, let’s cover animation properties one by one.\n\ntransition-property\n\nIn transition-property, we write a list of properties to animate, for instance: left, margin-left, height, color. Or we could write all, which means “animate all properties”.\n\nDo note that, there are properties which can not be animated. However, most of the generally used properties are animatable.\n\ntransition-duration\n\nIn transition-duration we can specify how long the animation should take. The time should be in CSS time format: in seconds s or milliseconds ms.\n\ntransition-delay\n\nIn transition-delay we can specify the delay before the animation. For instance, if transition-delay is 1s and transition-duration is 2s, then the animation starts 1 second after the property change and the total duration will be 2 seconds.\n\nNegative values are also possible. Then the animation is shown immediately, but the starting point of the animation will be after given value (time). For example, if transition-delay is -1s and transition-duration is 2s, then animation starts from the halfway point and total duration will be 1 second.\n\nHere the animation shifts numbers from 0 to 9 using CSS translate property:\n\nResultscript.jsstyle.cssindex.html\n\t\n\nThe transform property is animated like this:\n\n#stripe.animate {\n  transform: translate(-90%);\n  transition-property: transform;\n  transition-duration: 9s;\n}\n\nIn the example above JavaScript adds the class .animate to the element – and the animation starts:\n\nstripe.classList.add('animate');\n\nWe could also start it from somewhere in the middle of the transition, from an exact number, e.g. corresponding to the current second, using a negative transition-delay.\n\nHere if you click the digit – it starts the animation from the current second:\n\nResultscript.jsstyle.cssindex.html\n\t\n\nJavaScript does it with an extra line:\n\nstripe.onclick = function() {\n  let sec = new Date().getSeconds() % 10;\n  // for instance, -3s here starts the animation from the 3rd second\n  stripe.style.transitionDelay = '-' + sec + 's';\n  stripe.classList.add('animate');\n};\ntransition-timing-function\n\nThe timing function describes how the animation process is distributed along its timeline. Will it start slowly and then go fast, or vice versa.\n\nIt appears to be the most complicated property at first. But it becomes very simple if we devote a bit time to it.\n\nThat property accepts two kinds of values: a Bezier curve or steps. Let’s start with the curve, as it’s used more often.\n\nBezier curve\n\nThe timing function can be set as a Bezier curve with 4 control points that satisfy the conditions:\n\nFirst control point: (0,0).\nLast control point: (1,1).\nFor intermediate points, the values of x must be in the interval 0..1, y can be anything.\n\nThe syntax for a Bezier curve in CSS: cubic-bezier(x2, y2, x3, y3). Here we need to specify only 2nd and 3rd control points, because the 1st one is fixed to (0,0) and the 4th one is (1,1).\n\nThe timing function describes how fast the animation process goes.\n\nThe x axis is the time: 0 – the start, 1 – the end of transition-duration.\nThe y axis specifies the completion of the process: 0 – the starting value of the property, 1 – the final value.\n\nThe simplest variant is when the animation goes uniformly, with the same linear speed. That can be specified by the curve cubic-bezier(0, 0, 1, 1).\n\nHere’s how that curve looks:\n\n…As we can see, it’s just a straight line. As the time (x) passes, the completion (y) of the animation steadily goes from 0 to 1.\n\nThe train in the example below goes from left to right with the permanent speed (click it):\n\nResultstyle.cssindex.html\n\t\n\nThe CSS transition is based on that curve:\n\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, 0, 1, 1);\n  /* click on a train sets left to 450px, thus triggering the animation */\n}\n\n…And how can we show a train slowing down?\n\nWe can use another Bezier curve: cubic-bezier(0.0, 0.5, 0.5 ,1.0).\n\nThe graph:\n\nAs we can see, the process starts fast: the curve soars up high, and then slower and slower.\n\nHere’s the timing function in action (click the train):\n\nResultstyle.cssindex.html\n\t\n\nCSS:\n\n.train {\n  left: 0;\n  transition: left 5s cubic-bezier(0, .5, .5, 1);\n  /* click on a train sets left to 450px, thus triggering the animation */\n}\n\nThere are several built-in curves: linear, ease, ease-in, ease-out and ease-in-out.\n\nThe linear is a shorthand for cubic-bezier(0, 0, 1, 1) – a straight line, which we described above.\n\nOther names are shorthands for the following cubic-bezier:\n\nease*\tease-in\tease-out\tease-in-out\n(0.25, 0.1, 0.25, 1.0)\t(0.42, 0, 1.0, 1.0)\t(0, 0, 0.58, 1.0)\t(0.42, 0, 0.58, 1.0)\n\n\t\n\t\n\t\n\n* – by default, if there’s no timing function, ease is used.\n\nSo we could use ease-out for our slowing down train:\n\n.train {\n  left: 0;\n  transition: left 5s ease-out;\n  /* same as transition: left 5s cubic-bezier(0, .5, .5, 1); */\n}\n\nBut it looks a bit differently.\n\nA Bezier curve can make the animation exceed its range.\n\nThe control points on the curve can have any y coordinates: even negative or huge ones. Then the Bezier curve would also extend very low or high, making the animation go beyond its normal range.\n\nIn the example below the animation code is:\n\n.train {\n  left: 100px;\n  transition: left 5s cubic-bezier(.5, -1, .5, 2);\n  /* click on a train sets left to 450px */\n}\n\nThe property left should animate from 100px to 400px.\n\nBut if you click the train, you’ll see that:\n\nFirst, the train goes back: left becomes less than 100px.\nThen it goes forward, a little bit farther than 400px.\nAnd then back again – to 400px.\nResultstyle.cssindex.html\n\t\n\nWhy it happens is pretty obvious if we look at the graph of the given Bezier curve:\n\nWe moved the y coordinate of the 2nd point below zero, and for the 3rd point we made it over 1, so the curve goes out of the “regular” quadrant. The y is out of the “standard” range 0..1.\n\nAs we know, y measures “the completion of the animation process”. The value y = 0 corresponds to the starting property value and y = 1 – the ending value. So values y<0 move the property beyond the starting left and y>1 – past the final left.\n\nThat’s a “soft” variant for sure. If we put y values like -99 and 99 then the train would jump out of the range much more.\n\nBut how do we make a Bezier curve for a specific task? There are many tools.\n\nFor instance, we can do it on the site https://cubic-bezier.com.\nBrowser developer tools also have special support for Bezier curves in CSS:\nOpen the developer tools with F12 (Mac: Cmd+Opt+I).\nSelect the Elements tab, then pay attention to the Styles sub-panel at the right side.\nCSS properties with a word cubic-bezier will have an icon before this word.\nClick this icon to edit the curve.\nSteps\n\nThe timing function steps(number of steps[, start/end]) allows splitting an transition into multiple steps.\n\nLet’s see that in an example with digits.\n\nHere’s a list of digits, without any animations, just as a source:\n\nResultstyle.cssindex.html\n\t\n\nIn the HTML, a stripe of digits is enclosed into a fixed-length <div id=\"digits\">:\n\n<div id=\"digit\">\n  <div id=\"stripe\">0123456789</div>\n</div>\n\nThe #digit div has a fixed width and a border, so it looks like a red window.\n\nWe’ll make a timer: the digits will appear one by one, in a discrete way.\n\nTo achieve that, we’ll hide the #stripe outside of #digit using overflow: hidden, and then shift the #stripe to the left step-by-step.\n\nThere will be 9 steps, a step-move for each digit:\n\n#stripe.animate  {\n  transform: translate(-90%);\n  transition: transform 9s steps(9, start);\n}\n\nThe first argument of steps(9, start) is the number of steps. The transform will be split into 9 parts (10% each). The time interval is automatically divided into 9 parts as well, so transition: 9s gives us 9 seconds for the whole animation – 1 second per digit.\n\nThe second argument is one of two words: start or end.\n\nThe start means that in the beginning of animation we need to make the first step immediately.\n\nIn action:\n\nResultstyle.cssindex.html\n\t\n\nA click on the digit changes it to 1 (the first step) immediately, and then changes in the beginning of the next second.\n\nThe process is progressing like this:\n\n0s – -10% (first change in the beginning of the 1st second, immediately)\n1s – -20%\n…\n8s – -90%\n(the last second shows the final value).\n\nHere, the first change was immediate because of start in the steps.\n\nThe alternative value end would mean that the change should be applied not in the beginning, but at the end of each second.\n\nSo the process for steps(9, end) would go like this:\n\n0s – 0 (during the first second nothing changes)\n1s – -10% (first change at the end of the 1st second)\n2s – -20%\n…\n9s – -90%\n\nHere’s steps(9, end) in action (note the pause before the first digit change):\n\nResultstyle.cssindex.html\n\t\n\nThere are also some pre-defined shorthands for steps(...):\n\nstep-start – is the same as steps(1, start). That is, the animation starts immediately and takes 1 step. So it starts and finishes immediately, as if there were no animation.\nstep-end – the same as steps(1, end): make the animation in a single step at the end of transition-duration.\n\nThese values are rarely used, as they represent not a real animation, but rather a single-step change. We mention them here for completeness.\n\nEvent: “transitionend”\n\nWhen the CSS animation finishes, the transitionend event triggers.\n\nIt is widely used to do an action after the animation is done. Also we can join animations.\n\nFor instance, the ship in the example below starts to sail there and back when clicked, each time farther and farther to the right:\n\n\t\n\nThe animation is initiated by the function go that re-runs each time the transition finishes, and flips the direction:\n\nboat.onclick = function() {\n  //...\n  let times = 1;\n\n  function go() {\n    if (times % 2) {\n      // sail to the right\n      boat.classList.remove('back');\n      boat.style.marginLeft = 100 * times + 200 + 'px';\n    } else {\n      // sail to the left\n      boat.classList.add('back');\n      boat.style.marginLeft = 100 * times - 200 + 'px';\n    }\n\n  }\n\n  go();\n\n  boat.addEventListener('transitionend', function() {\n    times++;\n    go();\n  });\n};\n\nThe event object for transitionend has a few specific properties:\n\nevent.propertyName\nThe property that has finished animating. Can be good if we animate multiple properties simultaneously.\nevent.elapsedTime\nThe time (in seconds) that the animation took, without transition-delay.\nKeyframes\n\nWe can join multiple simple animations together using the @keyframes CSS rule.\n\nIt specifies the “name” of the animation and rules – what, when and where to animate. Then using the animation property, we can attach the animation to the element and specify additional parameters for it.\n\nHere’s an example with explanations:\n\n\t\n<div class=\"progress\"></div>\n\n<style>\n  @keyframes go-left-right {        /* give it a name: \"go-left-right\" */\n    from { left: 0px; }             /* animate from left: 0px */\n    to { left: calc(100% - 50px); } /* animate to left: 100%-50px */\n  }\n\n  .progress {\n    animation: go-left-right 3s infinite alternate;\n    /* apply the animation \"go-left-right\" to the element\n       duration 3 seconds\n       number of times: infinite\n       alternate direction every time\n    */\n\n    position: relative;\n    border: 2px solid green;\n    width: 50px;\n    height: 20px;\n    background: lime;\n  }\n</style>\n\nThere are many articles about @keyframes and a detailed specification.\n\nYou probably won’t need @keyframes often, unless everything is in constant motion on your sites.\n\nPerformance\n\nMost CSS properties can be animated, because most of them are numeric values. For instance, width, color, font-size are all numbers. When you animate them, the browser gradually changes these numbers frame by frame, creating a smooth effect.\n\nHowever, not all animations will look as smooth as you’d like, because different CSS properties cost differently to change.\n\nIn more technical details, when there’s a style change, the browser goes through 3 steps to render the new look:\n\nLayout: re-compute the geometry and position of each element, then\nPaint: re-compute how everything should look like at their places, including background, colors,\nComposite: render the final results into pixels on screen, apply CSS transforms if they exist.\n\nDuring a CSS animation, this process repeats every frame. However, CSS properties that never affect geometry or position, such as color, may skip the Layout step. If a color changes, the browser doesn’t calculate any new geometry, it goes to Paint → Composite. And there are few properties that directly go to Composite. You can find a longer list of CSS properties and which stages they trigger at https://csstriggers.com.\n\nThe calculations may take time, especially on pages with many elements and a complex layout. And the delays are actually visible on most devices, leading to “jittery”, less fluid animations.\n\nAnimations of properties that skip the Layout step are faster. It’s even better if Paint is skipped too.\n\nThe transform property is a great choice, because:\n\nCSS transforms affect the target element box as a whole (rotate, flip, stretch, shift it).\nCSS transforms never affect neighbour elements.\n\n…So browsers apply transform “on top” of existing Layout and Paint calculations, in the Composite stage.\n\nIn other words, the browser calculates the Layout (sizes, positions), paints it with colors, backgrounds, etc at the Paint stage, and then applies transform to element boxes that need it.\n\nChanges (animations) of the transform property never trigger Layout and Paint steps. More than that, the browser leverages the graphics accelerator (a special chip on the CPU or graphics card) for CSS transforms, thus making them very efficient.\n\nLuckily, the transform property is very powerful. By using transform on an element, you could rotate and flip it, stretch and shrink it, move it around, and much more. So instead of left/margin-left properties we can use transform: translateX(…), use transform: scale for increasing element size, etc.\n\nThe opacity property also never triggers Layout (also skips Paint in Mozilla Gecko). We can use it for show/hide or fade-in/fade-out effects.\n\nParing transform with opacity can usually solve most of our needs, providing fluid, good-looking animations.\n\nFor example, here clicking on the #boat element adds the class with transform: translateX(300) and opacity: 0, thus making it move 300px to the right and disappear:\n\n\t\n<img src=\"https://js.cx/clipart/boat.png\" id=\"boat\">\n\n<style>\n#boat {\n  cursor: pointer;\n  transition: transform 2s ease-in-out, opacity 2s ease-in-out;\n}\n\n.move {\n  transform: translateX(300px);\n  opacity: 0;\n}\n</style>\n<script>\n  boat.onclick = () => boat.classList.add('move');\n</script>\n\nHere’s a more complex example, with @keyframes:\n\n\t\n<h2 onclick=\"this.classList.toggle('animated')\">click me to start / stop</h2>\n<style>\n  .animated {\n    animation: hello-goodbye 1.8s infinite;\n    width: fit-content;\n  }\n  @keyframes hello-goodbye {\n    0% {\n      transform: translateY(-60px) rotateX(0.7turn);\n      opacity: 0;\n    }\n    50% {\n      transform: none;\n      opacity: 1;\n    }\n    100% {\n      transform: translateX(230px) rotateZ(90deg) scale(0.5);\n      opacity: 0;\n    }\n  }\n</style>\nSummary\n\nCSS animations allow smoothly (or step-by-step) animated changes of one or multiple CSS properties.\n\nThey are good for most animation tasks. We’re also able to use JavaScript for animations, the next chapter is devoted to that.\n\nLimitations of CSS animations compared to JavaScript animations:\n\nMerits\nSimple things done simply.\nFast and lightweight for CPU.\nDemerits\nJavaScript animations are flexible. They can implement any animation logic, like an “explosion” of an element.\nNot just property changes. We can create new elements in JavaScript as part of the animation.\n\nIn early examples in this chapter, we animate font-size, left, width, height, etc. In real life projects, we should use transform: scale() and transform: translate() for better performance.\n\nThe majority of animations can be implemented using CSS as described in this chapter. And the transitionend event allows JavaScript to be run after the animation, so it integrates fine with the code.\n\nBut in the next chapter we’ll do some JavaScript animations to cover more complex cases.\n\nTasks\nAnimate a plane (CSS)\nimportance: 5\n\nShow the animation like on the picture below (click the plane):\n\nThe picture grows on click from 40x24px to 400x240px (10 times larger).\nThe animation takes 3 seconds.\nAt the end output: “Done!”.\nDuring the animation process, there may be more clicks on the plane. They shouldn’t “break” anything.\n\nOpen a sandbox for the task.\n\nsolution\nAnimate the flying plane (CSS)\nimportance: 5\n\nModify the solution of the previous task Animate a plane (CSS) to make the plane grow more than its original size 400x240px (jump out), and then return to that size.\n\nHere’s how it should look (click on the plane):\n\nTake the solution of the previous task as the source.\n\nsolution\nAnimated circle\nimportance: 5\n\nCreate a function showCircle(cx, cy, radius) that shows an animated growing circle.\n\ncx,cy are window-relative coordinates of the center of the circle,\nradius is the radius of the circle.\n\nClick the button below to see how it should look like:\n\nThe source document has an example of a circle with right styles, so the task is precisely to do the animation right.\n\nOpen a sandbox for the task.\n\nsolution\nAnimated circle with callback\n\nIn the task Animated circle an animated growing circle is shown.\n\nNow let’s say we need not just a circle, but to show a message inside it. The message should appear after the animation is complete (the circle is fully grown), otherwise it would look ugly.\n\nIn the solution of the task, the function showCircle(cx, cy, radius) draws the circle, but gives no way to track when it’s ready.\n\nAdd a callback argument: showCircle(cx, cy, radius, callback) to be called when the animation is complete. The callback should receive the circle <div> as an argument.\n\nHere’s the example:\n\nshowCircle(150, 150, 100, div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n\nDemo:\n\nTake the solution of the task Animated circle as the base.\n\nsolution"
  },
  {
    "title": "Template element",
    "url": "https://javascript.info/template-element",
    "html": "A built-in <template> element serves as a storage for HTML markup templates. The browser ignores its contents, only checks for syntax validity, but we can access and use it in JavaScript, to create other elements.\n\nIn theory, we could create any invisible element somewhere in HTML for HTML markup storage purposes. What’s special about <template>?\n\nFirst, its content can be any valid HTML, even if it normally requires a proper enclosing tag.\n\nFor example, we can put there a table row <tr>:\n\n<template>\n  <tr>\n    <td>Contents</td>\n  </tr>\n</template>\n\nUsually, if we try to put <tr> inside, say, a <div>, the browser detects the invalid DOM structure and “fixes” it, adds <table> around. That’s not what we want. On the other hand, <template> keeps exactly what we place there.\n\nWe can put styles and scripts into <template> as well:\n\n<template>\n  <style>\n    p { font-weight: bold; }\n  </style>\n  <script>\n    alert(\"Hello\");\n  </script>\n</template>\n\nThe browser considers <template> content “out of the document”: styles are not applied, scripts are not executed, <video autoplay> is not run, etc.\n\nThe content becomes live (styles apply, scripts run etc) when we insert it into the document.\n\nInserting template\n\nThe template content is available in its content property as a DocumentFragment – a special type of DOM node.\n\nWe can treat it as any other DOM node, except one special property: when we insert it somewhere, its children are inserted instead.\n\nFor example:\n\n\t\n<template id=\"tmpl\">\n  <script>\n    alert(\"Hello\");\n  </script>\n  <div class=\"message\">Hello, world!</div>\n</template>\n\n<script>\n  let elem = document.createElement('div');\n\n  // Clone the template content to reuse it multiple times\n  elem.append(tmpl.content.cloneNode(true));\n\n  document.body.append(elem);\n  // Now the script from <template> runs\n</script>\n\nLet’s rewrite a Shadow DOM example from the previous chapter using <template>:\n\n\t\n<template id=\"tmpl\">\n  <style> p { font-weight: bold; } </style>\n  <p id=\"message\"></p>\n</template>\n\n<div id=\"elem\">Click me</div>\n\n<script>\n  elem.onclick = function() {\n    elem.attachShadow({mode: 'open'});\n\n    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)\n\n    elem.shadowRoot.getElementById('message').innerHTML = \"Hello from the shadows!\";\n  };\n</script>\n\nIn the line (*) when we clone and insert tmpl.content, as its DocumentFragment, its children (<style>, <p>) are inserted instead.\n\nThey form the shadow DOM:\n\n<div id=\"elem\">\n  #shadow-root\n    <style> p { font-weight: bold; } </style>\n    <p id=\"message\"></p>\n</div>\nSummary\n\nTo summarize:\n\n<template> content can be any syntactically correct HTML.\n<template> content is considered “out of the document”, so it doesn’t affect anything.\nWe can access template.content from JavaScript, clone it to reuse in a new component.\n\nThe <template> tag is quite unique, because:\n\nThe browser checks HTML syntax inside it (as opposed to using a template string inside a script).\n…But still allows use of any top-level HTML tags, even those that don’t make sense without proper wrappers (e.g. <tr>).\nThe content becomes interactive: scripts run, <video autoplay> plays etc, when inserted into the document.\n\nThe <template> element does not feature any iteration mechanisms, data binding or variable substitutions, but we can implement those on top of it."
  },
  {
    "title": "JavaScript animations",
    "url": "https://javascript.info/js-animation",
    "html": "JavaScript animations can handle things that CSS can’t.\n\nFor instance, moving along a complex path, with a timing function different from Bezier curves, or an animation on a canvas.\n\nUsing setInterval\n\nAn animation can be implemented as a sequence of frames – usually small changes to HTML/CSS properties.\n\nFor instance, changing style.left from 0px to 100px moves the element. And if we increase it in setInterval, changing by 2px with a tiny delay, like 50 times per second, then it looks smooth. That’s the same principle as in the cinema: 24 frames per second is enough to make it look smooth.\n\nThe pseudo-code can look like this:\n\nlet timer = setInterval(function() {\n  if (animation complete) clearInterval(timer);\n  else increase style.left by 2px\n}, 20); // change by 2px every 20ms, about 50 frames per second\n\nMore complete example of the animation:\n\nlet start = Date.now(); // remember start time\n\nlet timer = setInterval(function() {\n  // how much time passed from the start?\n  let timePassed = Date.now() - start;\n\n  if (timePassed >= 2000) {\n    clearInterval(timer); // finish the animation after 2 seconds\n    return;\n  }\n\n  // draw the animation at the moment timePassed\n  draw(timePassed);\n\n}, 20);\n\n// as timePassed goes from 0 to 2000\n// left gets values from 0px to 400px\nfunction draw(timePassed) {\n  train.style.left = timePassed / 5 + 'px';\n}\n\nClick for the demo:\n\nResultindex.html\n\t\nUsing requestAnimationFrame\n\nLet’s imagine we have several animations running simultaneously.\n\nIf we run them separately, then even though each one has setInterval(..., 20), then the browser would have to repaint much more often than every 20ms.\n\nThat’s because they have different starting time, so “every 20ms” differs between different animations. The intervals are not aligned. So we’ll have several independent runs within 20ms.\n\nIn other words, this:\n\nsetInterval(function() {\n  animate1();\n  animate2();\n  animate3();\n}, 20)\n\n…Is lighter than three independent calls:\n\nsetInterval(animate1, 20); // independent animations\nsetInterval(animate2, 20); // in different places of the script\nsetInterval(animate3, 20);\n\nThese several independent redraws should be grouped together, to make the redraw easier for the browser and hence load less CPU load and look smoother.\n\nThere’s one more thing to keep in mind. Sometimes CPU is overloaded, or there are other reasons to redraw less often (like when the browser tab is hidden), so we really shouldn’t run it every 20ms.\n\nBut how do we know about that in JavaScript? There’s a specification Animation timing that provides the function requestAnimationFrame. It addresses all these issues and even more.\n\nThe syntax:\n\nlet requestId = requestAnimationFrame(callback)\n\nThat schedules the callback function to run in the closest time when the browser wants to do animation.\n\nIf we do changes in elements in callback then they will be grouped together with other requestAnimationFrame callbacks and with CSS animations. So there will be one geometry recalculation and repaint instead of many.\n\nThe returned value requestId can be used to cancel the call:\n\n// cancel the scheduled execution of callback\ncancelAnimationFrame(requestId);\n\nThe callback gets one argument – the time passed from the beginning of the page load in milliseconds. This time can also be obtained by calling performance.now().\n\nUsually callback runs very soon, unless the CPU is overloaded or the laptop battery is almost discharged, or there’s another reason.\n\nThe code below shows the time between first 10 runs for requestAnimationFrame. Usually it’s 10-20ms:\n\n\t\n<script>\n  let prev = performance.now();\n  let times = 0;\n\n  requestAnimationFrame(function measure(time) {\n    document.body.insertAdjacentHTML(\"beforeEnd\", Math.floor(time - prev) + \" \");\n    prev = time;\n\n    if (times++ < 10) requestAnimationFrame(measure);\n  })\n</script>\nStructured animation\n\nNow we can make a more universal animation function based on requestAnimationFrame:\n\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction goes from 0 to 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // calculate the current animation state\n    let progress = timing(timeFraction)\n\n    draw(progress); // draw it\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n\nFunction animate accepts 3 parameters that essentially describes the animation:\n\nduration\n\nTotal time of animation. Like, 1000.\n\ntiming(timeFraction)\n\nTiming function, like CSS-property transition-timing-function that gets the fraction of time that passed (0 at start, 1 at the end) and returns the animation completion (like y on the Bezier curve).\n\nFor instance, a linear function means that the animation goes on uniformly with the same speed:\n\nfunction linear(timeFraction) {\n  return timeFraction;\n}\n\nIts graph: \n\nThat’s just like transition-timing-function: linear. There are more interesting variants shown below.\n\ndraw(progress)\n\nThe function that takes the animation completion state and draws it. The value progress=0 denotes the beginning animation state, and progress=1 – the end state.\n\nThis is that function that actually draws out the animation.\n\nIt can move the element:\n\nfunction draw(progress) {\n  train.style.left = progress + 'px';\n}\n\n…Or do anything else, we can animate anything, in any way.\n\nLet’s animate the element width from 0 to 100% using our function.\n\nClick on the element for the demo:\n\nResultanimate.jsindex.html\n\t\n\nThe code for it:\n\nanimate({\n  duration: 1000,\n  timing(timeFraction) {\n    return timeFraction;\n  },\n  draw(progress) {\n    elem.style.width = progress * 100 + '%';\n  }\n});\n\nUnlike CSS animation, we can make any timing function and any drawing function here. The timing function is not limited by Bezier curves. And draw can go beyond properties, create new elements for like fireworks animation or something.\n\nTiming functions\n\nWe saw the simplest, linear timing function above.\n\nLet’s see more of them. We’ll try movement animations with different timing functions to see how they work.\n\nPower of n\n\nIf we want to speed up the animation, we can use progress in the power n.\n\nFor instance, a parabolic curve:\n\nfunction quad(timeFraction) {\n  return Math.pow(timeFraction, 2)\n}\n\nThe graph:\n\nSee in action (click to activate):\n\n…Or the cubic curve or even greater n. Increasing the power makes it speed up faster.\n\nHere’s the graph for progress in the power 5:\n\nIn action:\n\nThe arc\n\nFunction:\n\nfunction circ(timeFraction) {\n  return 1 - Math.sin(Math.acos(timeFraction));\n}\n\nThe graph:\n\nBack: bow shooting\n\nThis function does the “bow shooting”. First we “pull the bowstring”, and then “shoot”.\n\nUnlike previous functions, it depends on an additional parameter x, the “elasticity coefficient”. The distance of “bowstring pulling” is defined by it.\n\nThe code:\n\nfunction back(x, timeFraction) {\n  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)\n}\n\nThe graph for x = 1.5:\n\nFor animation we use it with a specific value of x. Example for x = 1.5:\n\nBounce\n\nImagine we are dropping a ball. It falls down, then bounces back a few times and stops.\n\nThe bounce function does the same, but in the reverse order: “bouncing” starts immediately. It uses few special coefficients for that:\n\nfunction bounce(timeFraction) {\n  for (let a = 0, b = 1; 1; a += b, b /= 2) {\n    if (timeFraction >= (7 - 4 * a) / 11) {\n      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)\n    }\n  }\n}\n\nIn action:\n\nElastic animation\n\nOne more “elastic” function that accepts an additional parameter x for the “initial range”.\n\nfunction elastic(x, timeFraction) {\n  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)\n}\n\nThe graph for x=1.5: \n\nIn action for x=1.5:\n\nReversal: ease*\n\nSo we have a collection of timing functions. Their direct application is called “easeIn”.\n\nSometimes we need to show the animation in the reverse order. That’s done with the “easeOut” transform.\n\neaseOut\n\nIn the “easeOut” mode the timing function is put into a wrapper timingEaseOut:\n\ntimingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)\n\nIn other words, we have a “transform” function makeEaseOut that takes a “regular” timing function and returns the wrapper around it:\n\n// accepts a timing function, returns the transformed variant\nfunction makeEaseOut(timing) {\n  return function(timeFraction) {\n    return 1 - timing(1 - timeFraction);\n  }\n}\n\nFor instance, we can take the bounce function described above and apply it:\n\nlet bounceEaseOut = makeEaseOut(bounce);\n\nThen the bounce will be not in the beginning, but at the end of the animation. Looks even better:\n\nResultstyle.cssindex.html\n\t\n\nHere we can see how the transform changes the behavior of the function:\n\nIf there’s an animation effect in the beginning, like bouncing – it will be shown at the end.\n\nIn the graph above the regular bounce has the red color, and the easeOut bounce is blue.\n\nRegular bounce – the object bounces at the bottom, then at the end sharply jumps to the top.\nAfter easeOut – it first jumps to the top, then bounces there.\neaseInOut\n\nWe also can show the effect both in the beginning and the end of the animation. The transform is called “easeInOut”.\n\nGiven the timing function, we calculate the animation state like this:\n\nif (timeFraction <= 0.5) { // first half of the animation\n  return timing(2 * timeFraction) / 2;\n} else { // second half of the animation\n  return (2 - timing(2 * (1 - timeFraction))) / 2;\n}\n\nThe wrapper code:\n\nfunction makeEaseInOut(timing) {\n  return function(timeFraction) {\n    if (timeFraction < .5)\n      return timing(2 * timeFraction) / 2;\n    else\n      return (2 - timing(2 * (1 - timeFraction))) / 2;\n  }\n}\n\nbounceEaseInOut = makeEaseInOut(bounce);\n\nIn action, bounceEaseInOut:\n\nResultstyle.cssindex.html\n\t\n\nThe “easeInOut” transform joins two graphs into one: easeIn (regular) for the first half of the animation and easeOut (reversed) – for the second part.\n\nThe effect is clearly seen if we compare the graphs of easeIn, easeOut and easeInOut of the circ timing function:\n\nRed is the regular variant of circ (easeIn).\nGreen – easeOut.\nBlue – easeInOut.\n\nAs we can see, the graph of the first half of the animation is the scaled down easeIn, and the second half is the scaled down easeOut. As a result, the animation starts and finishes with the same effect.\n\nMore interesting “draw”\n\nInstead of moving the element we can do something else. All we need is to write the proper draw.\n\nHere’s the animated “bouncing” text typing:\n\nResultstyle.cssindex.html\n\t\nSummary\n\nFor animations that CSS can’t handle well, or those that need tight control, JavaScript can help. JavaScript animations should be implemented via requestAnimationFrame. That built-in method allows to setup a callback function to run when the browser will be preparing a repaint. Usually that’s very soon, but the exact time depends on the browser.\n\nWhen a page is in the background, there are no repaints at all, so the callback won’t run: the animation will be suspended and won’t consume resources. That’s great.\n\nHere’s the helper animate function to setup most animations:\n\nfunction animate({timing, draw, duration}) {\n\n  let start = performance.now();\n\n  requestAnimationFrame(function animate(time) {\n    // timeFraction goes from 0 to 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // calculate the current animation state\n    let progress = timing(timeFraction);\n\n    draw(progress); // draw it\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n\n  });\n}\n\nOptions:\n\nduration – the total animation time in ms.\ntiming – the function to calculate animation progress. Gets a time fraction from 0 to 1, returns the animation progress, usually from 0 to 1.\ndraw – the function to draw the animation.\n\nSurely we could improve it, add more bells and whistles, but JavaScript animations are not applied on a daily basis. They are used to do something interesting and non-standard. So you’d want to add the features that you need when you need them.\n\nJavaScript animations can use any timing function. We covered a lot of examples and transformations to make them even more versatile. Unlike CSS, we are not limited to Bezier curves here.\n\nThe same is about draw: we can animate anything, not just CSS properties.\n\nTasks\nAnimate the bouncing ball\nimportance: 5\n\nMake a bouncing ball. Click to see how it should look:\n\nOpen a sandbox for the task.\n\nsolution\nAnimate the ball bouncing to the right\nimportance: 5\n\nMake the ball bounce to the right. Like this:\n\nWrite the animation code. The distance to the left is 100px.\n\nTake the solution of the previous task Animate the bouncing ball as the source.\n\nsolution"
  },
  {
    "title": "Bezier curve",
    "url": "https://javascript.info/bezier-curve",
    "html": "Bezier curves are used in computer graphics to draw shapes, for CSS animation and in many other places.\n\nThey are a very simple thing, worth to study once and then feel comfortable in the world of vector graphics and advanced animations.\n\nSome theory, please\n\nThis article provides a theoretical, but very needed insight into what Bezier curves are, while the next one shows how we can use them for CSS animations.\n\nPlease take your time to read and understand the concept, it’ll serve you well.\n\nControl points\n\nA bezier curve is defined by control points.\n\nThere may be 2, 3, 4 or more.\n\nFor instance, two points curve:\n\nThree points curve:\n\nFour points curve:\n\nIf you look closely at these curves, you can immediately notice:\n\nPoints are not always on curve. That’s perfectly normal, later we’ll see how the curve is built.\n\nThe curve order equals the number of points minus one. For two points we have a linear curve (that’s a straight line), for three points – quadratic curve (parabolic), for four points – cubic curve.\n\nA curve is always inside the convex hull of control points:\n\n \n\nBecause of that last property, in computer graphics it’s possible to optimize intersection tests. If convex hulls do not intersect, then curves do not either. So checking for the convex hulls intersection first can give a very fast “no intersection” result. Checking the intersection of convex hulls is much easier, because they are rectangles, triangles and so on (see the picture above), much simpler figures than the curve.\n\nThe main value of Bezier curves for drawing – by moving the points the curve is changing in intuitively obvious way.\n\nTry to move control points using a mouse in the example below:\n\nAs you can notice, the curve stretches along the tangential lines 1 → 2 and 3 → 4.\n\nAfter some practice it becomes obvious how to place points to get the needed curve. And by connecting several curves we can get practically anything.\n\nHere are some examples:\n\n  \n\nDe Casteljau’s algorithm\n\nThere’s a mathematical formula for Bezier curves, but let’s cover it a bit later, because De Casteljau’s algorithm is identical to the mathematical definition and visually shows how it is constructed.\n\nFirst let’s see the 3-points example.\n\nHere’s the demo, and the explanation follow.\n\nControl points (1,2 and 3) can be moved by the mouse. Press the “play” button to run it.\n\nDe Casteljau’s algorithm of building the 3-point bezier curve:\n\nDraw control points. In the demo above they are labeled: 1, 2, 3.\n\nBuild segments between control points 1 → 2 → 3. In the demo above they are brown.\n\nThe parameter t moves from 0 to 1. In the example above the step 0.05 is used: the loop goes over 0, 0.05, 0.1, 0.15, ... 0.95, 1.\n\nFor each of these values of t:\n\nOn each brown segment we take a point located on the distance proportional to t from its beginning. As there are two segments, we have two points.\n\nFor instance, for t=0 – both points will be at the beginning of segments, and for t=0.25 – on the 25% of segment length from the beginning, for t=0.5 – 50%(the middle), for t=1 – in the end of segments.\n\nConnect the points. On the picture below the connecting segment is painted blue.\n\nFor t=0.25\tFor t=0.5\n\t\n\nNow in the blue segment take a point on the distance proportional to the same value of t. That is, for t=0.25 (the left picture) we have a point at the end of the left quarter of the segment, and for t=0.5 (the right picture) – in the middle of the segment. On pictures above that point is red.\n\nAs t runs from 0 to 1, every value of t adds a point to the curve. The set of such points forms the Bezier curve. It’s red and parabolic on the pictures above.\n\nThat was a process for 3 points. But the same is for 4 points.\n\nThe demo for 4 points (points can be moved by a mouse):\n\nThe algorithm for 4 points:\n\nConnect control points by segments: 1 → 2, 2 → 3, 3 → 4. There will be 3 brown segments.\nFor each t in the interval from 0 to 1:\nWe take points on these segments on the distance proportional to t from the beginning. These points are connected, so that we have two green segments.\nOn these segments we take points proportional to t. We get one blue segment.\nOn the blue segment we take a point proportional to t. On the example above it’s red.\nThese points together form the curve.\n\nThe algorithm is recursive and can be generalized for any number of control points.\n\nGiven N of control points:\n\nWe connect them to get initially N-1 segments.\nThen for each t from 0 to 1, we take a point on each segment on the distance proportional to t and connect them. There will be N-2 segments.\nRepeat step 2 until there is only one point.\n\nThese points make the curve.\n\nRun and pause examples to clearly see the segments and how the curve is built.\n\nA curve that looks like y=1/t:\n\nZig-zag control points also work fine:\n\nMaking a loop is possible:\n\nA non-smooth Bezier curve (yeah, that’s possible too):\n\nIf there’s something unclear in the algorithm description, please look at the live examples above to see how the curve is built.\n\nAs the algorithm is recursive, we can build Bezier curves of any order, that is: using 5, 6 or more control points. But in practice many points are less useful. Usually we take 2-3 points, and for complex lines glue several curves together. That’s simpler to develop and calculate.\n\nHow to draw a curve through given points?\n\nTo specify a Bezier curve, control points are used. As we can see, they are not on the curve, except the first and the last ones.\n\nSometimes we have another task: to draw a curve through several points, so that all of them are on a single smooth curve. That task is called interpolation, and here we don’t cover it.\n\nThere are mathematical formulas for such curves, for instance Lagrange polynomial. In computer graphics spline interpolation is often used to build smooth curves that connect many points.\n\nMaths\n\nA Bezier curve can be described using a mathematical formula.\n\nAs we saw – there’s actually no need to know it, most people just draw the curve by moving points with a mouse. But if you’re into maths – here it is.\n\nGiven the coordinates of control points Pi: the first control point has coordinates P1 = (x1, y1), the second: P2 = (x2, y2), and so on, the curve coordinates are described by the equation that depends on the parameter t from the segment [0,1].\n\nThe formula for a 2-points curve:\n\nP = (1-t)P1 + tP2\n\nFor 3 control points:\n\nP = (1−t)2P1 + 2(1−t)tP2 + t2P3\n\nFor 4 control points:\n\nP = (1−t)3P1 + 3(1−t)2tP2 +3(1−t)t2P3 + t3P4\n\nThese are vector equations. In other words, we can put x and y instead of P to get corresponding coordinates.\n\nFor instance, the 3-point curve is formed by points (x,y) calculated as:\n\nx = (1−t)2x1 + 2(1−t)tx2 + t2x3\ny = (1−t)2y1 + 2(1−t)ty2 + t2y3\n\nInstead of x1, y1, x2, y2, x3, y3 we should put coordinates of 3 control points, and then as t moves from 0 to 1, for each value of t we’ll have (x,y) of the curve.\n\nFor instance, if control points are (0,0), (0.5, 1) and (1, 0), the equations become:\n\nx = (1−t)2 * 0 + 2(1−t)t * 0.5 + t2 * 1 = (1-t)t + t2 = t\ny = (1−t)2 * 0 + 2(1−t)t * 1 + t2 * 0 = 2(1-t)t = –2t2 + 2t\n\nNow as t runs from 0 to 1, the set of values (x,y) for each t forms the curve for such control points.\n\nSummary\n\nBezier curves are defined by their control points.\n\nWe saw two definitions of Bezier curves:\n\nUsing a drawing process: De Casteljau’s algorithm.\nUsing a mathematical formulas.\n\nGood properties of Bezier curves:\n\nWe can draw smooth lines with a mouse by moving control points.\nComplex shapes can be made of several Bezier curves.\n\nUsage:\n\nIn computer graphics, modeling, vector graphic editors. Fonts are described by Bezier curves.\nIn web development – for graphics on Canvas and in the SVG format. By the way, “live” examples above are written in SVG. They are actually a single SVG document that is given different points as parameters. You can open it in a separate window and see the source: demo.svg.\nIn CSS animation to describe the path and speed of animation."
  },
  {
    "title": "From the orbital height",
    "url": "https://javascript.info/webcomponents-intro",
    "html": "This section describes a set of modern standards for “web components”.\n\nAs of now, these standards are under development. Some features are well-supported and integrated into the modern HTML/DOM standard, while others are yet in draft stage. You can try examples in any browser, Google Chrome is probably the most up to date with these features. Guess, that’s because Google fellows are behind many of the related specifications.\n\nWhat’s common between…\n\nThe whole component idea is nothing new. It’s used in many frameworks and elsewhere.\n\nBefore we move to implementation details, take a look at this great achievement of humanity:\n\nThat’s the International Space Station (ISS).\n\nAnd this is how it’s made inside (approximately):\n\nThe International Space Station:\n\nConsists of many components.\nEach component, in its turn, has many smaller details inside.\nThe components are very complex, much more complicated than most websites.\nComponents are developed internationally, by teams from different countries, speaking different languages.\n\n…And this thing flies, keeps humans alive in space!\n\nHow are such complex devices created?\n\nWhich principles could we borrow to make our development same-level reliable and scalable? Or, at least, close to it?\n\nComponent architecture\n\nThe well known rule for developing complex software is: don’t make complex software.\n\nIf something becomes complex – split it into simpler parts and connect in the most obvious way.\n\nA good architect is the one who can make the complex simple.\n\nWe can split user interface into visual components: each of them has own place on the page, can “do” a well-described task, and is separate from the others.\n\nLet’s take a look at a website, for example Twitter.\n\nIt naturally splits into components:\n\nTop navigation.\nUser info.\nFollow suggestions.\nSubmit form.\n(and also 6, 7) – messages.\n\nComponents may have subcomponents, e.g. messages may be parts of a higher-level “message list” component. A clickable user picture itself may be a component, and so on.\n\nHow do we decide, what is a component? That comes from intuition, experience and common sense. Usually it’s a separate visual entity that we can describe in terms of what it does and how it interacts with the page. In the case above, the page has blocks, each of them plays its own role, it’s logical to make these components.\n\nA component has:\n\nIts own JavaScript class.\nDOM structure, managed solely by its class, outside code doesn’t access it (“encapsulation” principle).\nCSS styles, applied to the component.\nAPI: events, class methods etc, to interact with other components.\n\nOnce again, the whole “component” thing is nothing special.\n\nThere exist many frameworks and development methodologies to build them, each with its own bells and whistles. Usually, special CSS classes and conventions are used to provide “component feel” – CSS scoping and DOM encapsulation.\n\n“Web components” provide built-in browser capabilities for that, so we don’t have to emulate them any more.\n\nCustom elements – to define custom HTML elements.\nShadow DOM – to create an internal DOM for the component, hidden from the others.\nCSS Scoping – to declare styles that only apply inside the Shadow DOM of the component.\nEvent retargeting and other minor stuff to make custom components better fit the development.\n\nIn the next chapter we’ll go into details of “Custom Elements” – the fundamental and well-supported feature of web components, good on its own."
  },
  {
    "title": "Shadow DOM",
    "url": "https://javascript.info/shadow-dom",
    "html": "Shadow DOM serves for encapsulation. It allows a component to have its very own “shadow” DOM tree, that can’t be accidentally accessed from the main document, may have local style rules, and more.\n\nBuilt-in shadow DOM\n\nDid you ever think how complex browser controls are created and styled?\n\nSuch as <input type=\"range\">:\n\nThe browser uses DOM/CSS internally to draw them. That DOM structure is normally hidden from us, but we can see it in developer tools. E.g. in Chrome, we need to enable in Dev Tools “Show user agent shadow DOM” option.\n\nThen <input type=\"range\"> looks like this:\n\nWhat you see under #shadow-root is called “shadow DOM”.\n\nWe can’t get built-in shadow DOM elements by regular JavaScript calls or selectors. These are not regular children, but a powerful encapsulation technique.\n\nIn the example above, we can see a useful attribute pseudo. It’s non-standard, exists for historical reasons. We can use it style subelements with CSS, like this:\n\n\t\n<style>\n/* make the slider track red */\ninput::-webkit-slider-runnable-track {\n  background: red;\n}\n</style>\n\n<input type=\"range\">\n\nOnce again, pseudo is a non-standard attribute. Chronologically, browsers first started to experiment with internal DOM structures to implement controls, and then, after time, shadow DOM was standardized to allow us, developers, to do the similar thing.\n\nFurther on, we’ll use the modern shadow DOM standard, covered by DOM spec and other related specifications.\n\nShadow tree\n\nA DOM element can have two types of DOM subtrees:\n\nLight tree – a regular DOM subtree, made of HTML children. All subtrees that we’ve seen in previous chapters were “light”.\nShadow tree – a hidden DOM subtree, not reflected in HTML, hidden from prying eyes.\n\nIf an element has both, then the browser renders only the shadow tree. But we can setup a kind of composition between shadow and light trees as well. We’ll see the details later in the chapter Shadow DOM slots, composition.\n\nShadow tree can be used in Custom Elements to hide component internals and apply component-local styles.\n\nFor example, this <show-hello> element hides its internal DOM in shadow tree:\n\n\t\n<script>\ncustomElements.define('show-hello', class extends HTMLElement {\n  connectedCallback() {\n    const shadow = this.attachShadow({mode: 'open'});\n    shadow.innerHTML = `<p>\n      Hello, ${this.getAttribute('name')}\n    </p>`;\n  }\n});\n</script>\n\n<show-hello name=\"John\"></show-hello>\n\nThat’s how the resulting DOM looks in Chrome dev tools, all the content is under “#shadow-root”:\n\nFirst, the call to elem.attachShadow({mode: …}) creates a shadow tree.\n\nThere are two limitations:\n\nWe can create only one shadow root per element.\nThe elem must be either a custom element, or one of: “article”, “aside”, “blockquote”, “body”, “div”, “footer”, “h1…h6”, “header”, “main” “nav”, “p”, “section”, or “span”. Other elements, like <img>, can’t host shadow tree.\n\nThe mode option sets the encapsulation level. It must have any of two values:\n\n\"open\" – the shadow root is available as elem.shadowRoot.\n\nAny code is able to access the shadow tree of elem.\n\n\"closed\" – elem.shadowRoot is always null.\n\nWe can only access the shadow DOM by the reference returned by attachShadow (and probably hidden inside a class). Browser-native shadow trees, such as <input type=\"range\">, are closed. There’s no way to access them.\n\nThe shadow root, returned by attachShadow, is like an element: we can use innerHTML or DOM methods, such as append, to populate it.\n\nThe element with a shadow root is called a “shadow tree host”, and is available as the shadow root host property:\n\n// assuming {mode: \"open\"}, otherwise elem.shadowRoot is null\nalert(elem.shadowRoot.host === elem); // true\nEncapsulation\n\nShadow DOM is strongly delimited from the main document:\n\nShadow DOM elements are not visible to querySelector from the light DOM. In particular, Shadow DOM elements may have ids that conflict with those in the light DOM. They must be unique only within the shadow tree.\nShadow DOM has own stylesheets. Style rules from the outer DOM don’t get applied.\n\nFor example:\n\n\t\n<style>\n  /* document style won't apply to the shadow tree inside #elem (1) */\n  p { color: red; }\n</style>\n\n<div id=\"elem\"></div>\n\n<script>\n  elem.attachShadow({mode: 'open'});\n    // shadow tree has its own style (2)\n  elem.shadowRoot.innerHTML = `\n    <style> p { font-weight: bold; } </style>\n    <p>Hello, John!</p>\n  `;\n\n  // <p> is only visible from queries inside the shadow tree (3)\n  alert(document.querySelectorAll('p').length); // 0\n  alert(elem.shadowRoot.querySelectorAll('p').length); // 1\n</script>\nThe style from the document does not affect the shadow tree.\n…But the style from the inside works.\nTo get elements in shadow tree, we must query from inside the tree.\nReferences\nDOM: https://dom.spec.whatwg.org/#shadow-trees\nCompatibility: https://caniuse.com/#feat=shadowdomv1\nShadow DOM is mentioned in many other specifications, e.g. DOM Parsing specifies that shadow root has innerHTML.\nSummary\n\nShadow DOM is a way to create a component-local DOM.\n\nshadowRoot = elem.attachShadow({mode: open|closed}) – creates shadow DOM for elem. If mode=\"open\", then it’s accessible as elem.shadowRoot property.\nWe can populate shadowRoot using innerHTML or other DOM methods.\n\nShadow DOM elements:\n\nHave their own ids space,\nInvisible to JavaScript selectors from the main document, such as querySelector,\nUse styles only from the shadow tree, not from the main document.\n\nShadow DOM, if exists, is rendered by the browser instead of so-called “light DOM” (regular children). In the chapter Shadow DOM slots, composition we’ll see how to compose them."
  },
  {
    "title": "Custom elements",
    "url": "https://javascript.info/custom-elements",
    "html": "We can create custom HTML elements, described by our class, with its own methods and properties, events and so on.\n\nOnce a custom element is defined, we can use it on par with built-in HTML elements.\n\nThat’s great, as HTML dictionary is rich, but not infinite. There are no <easy-tabs>, <sliding-carousel>, <beautiful-upload>… Just think of any other tag we might need.\n\nWe can define them with a special class, and then use as if they were always a part of HTML.\n\nThere are two kinds of custom elements:\n\nAutonomous custom elements – “all-new” elements, extending the abstract HTMLElement class.\nCustomized built-in elements – extending built-in elements, like a customized button, based on HTMLButtonElement etc.\n\nFirst we’ll cover autonomous elements, and then move to customized built-in ones.\n\nTo create a custom element, we need to tell the browser several details about it: how to show it, what to do when the element is added or removed to page, etc.\n\nThat’s done by making a class with special methods. That’s easy, as there are only few methods, and all of them are optional.\n\nHere’s a sketch with the full list:\n\nclass MyElement extends HTMLElement {\n  constructor() {\n    super();\n    // element created\n  }\n\n  connectedCallback() {\n    // browser calls this method when the element is added to the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  disconnectedCallback() {\n    // browser calls this method when the element is removed from the document\n    // (can be called many times if an element is repeatedly added/removed)\n  }\n\n  static get observedAttributes() {\n    return [/* array of attribute names to monitor for changes */];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    // called when one of attributes listed above is modified\n  }\n\n  adoptedCallback() {\n    // called when the element is moved to a new document\n    // (happens in document.adoptNode, very rarely used)\n  }\n\n  // there can be other element methods and properties\n}\n\nAfter that, we need to register the element:\n\n// let the browser know that <my-element> is served by our new class\ncustomElements.define(\"my-element\", MyElement);\n\nNow for any HTML elements with tag <my-element>, an instance of MyElement is created, and the aforementioned methods are called. We also can document.createElement('my-element') in JavaScript.\n\nCustom element name must contain a hyphen -\n\nCustom element name must have a hyphen -, e.g. my-element and super-button are valid names, but myelement is not.\n\nThat’s to ensure that there are no name conflicts between built-in and custom HTML elements.\n\nExample: “time-formatted”\n\nFor example, there already exists <time> element in HTML, for date/time. But it doesn’t do any formatting by itself.\n\nLet’s create <time-formatted> element that displays the time in a nice, language-aware format:\n\n\t\n<script>\nclass TimeFormatted extends HTMLElement { // (1)\n\n  connectedCallback() {\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n}\n\ncustomElements.define(\"time-formatted\", TimeFormatted); // (2)\n</script>\n\n<!-- (3) -->\n<time-formatted datetime=\"2019-12-01\"\n  year=\"numeric\" month=\"long\" day=\"numeric\"\n  hour=\"numeric\" minute=\"numeric\" second=\"numeric\"\n  time-zone-name=\"short\"\n></time-formatted>\nThe class has only one method connectedCallback() – the browser calls it when <time-formatted> element is added to page (or when HTML parser detects it), and it uses the built-in Intl.DateTimeFormat data formatter, well-supported across the browsers, to show a nicely formatted time.\nWe need to register our new element by customElements.define(tag, class).\nAnd then we can use it everywhere.\nCustom elements upgrade\n\nIf the browser encounters any <time-formatted> elements before customElements.define, that’s not an error. But the element is yet unknown, just like any non-standard tag.\n\nSuch “undefined” elements can be styled with CSS selector :not(:defined).\n\nWhen customElement.define is called, they are “upgraded”: a new instance of TimeFormatted is created for each, and connectedCallback is called. They become :defined.\n\nTo get the information about custom elements, there are methods:\n\ncustomElements.get(name) – returns the class for a custom element with the given name,\ncustomElements.whenDefined(name) – returns a promise that resolves (without value) when a custom element with the given name becomes defined.\nRendering in connectedCallback, not in constructor\n\nIn the example above, element content is rendered (created) in connectedCallback.\n\nWhy not in the constructor?\n\nThe reason is simple: when constructor is called, it’s yet too early. The element is created, but the browser did not yet process/assign attributes at this stage: calls to getAttribute would return null. So we can’t really render there.\n\nBesides, if you think about it, that’s better performance-wise – to delay the work until it’s really needed.\n\nThe connectedCallback triggers when the element is added to the document. Not just appended to another element as a child, but actually becomes a part of the page. So we can build detached DOM, create elements and prepare them for later use. They will only be actually rendered when they make it into the page.\n\nObserving attributes\n\nIn the current implementation of <time-formatted>, after the element is rendered, further attribute changes don’t have any effect. That’s strange for an HTML element. Usually, when we change an attribute, like a.href, we expect the change to be immediately visible. So let’s fix this.\n\nWe can observe attributes by providing their list in observedAttributes() static getter. For such attributes, attributeChangedCallback is called when they are modified. It doesn’t trigger for other, unlisted attributes (that’s for performance reasons).\n\nHere’s a new <time-formatted>, that auto-updates when attributes change:\n\n\t\n<script>\nclass TimeFormatted extends HTMLElement {\n\n  render() { // (1)\n    let date = new Date(this.getAttribute('datetime') || Date.now());\n\n    this.innerHTML = new Intl.DateTimeFormat(\"default\", {\n      year: this.getAttribute('year') || undefined,\n      month: this.getAttribute('month') || undefined,\n      day: this.getAttribute('day') || undefined,\n      hour: this.getAttribute('hour') || undefined,\n      minute: this.getAttribute('minute') || undefined,\n      second: this.getAttribute('second') || undefined,\n      timeZoneName: this.getAttribute('time-zone-name') || undefined,\n    }).format(date);\n  }\n\n  connectedCallback() { // (2)\n    if (!this.rendered) {\n      this.render();\n      this.rendered = true;\n    }\n  }\n\n  static get observedAttributes() { // (3)\n    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) { // (4)\n    this.render();\n  }\n\n}\n\ncustomElements.define(\"time-formatted\", TimeFormatted);\n</script>\n\n<time-formatted id=\"elem\" hour=\"numeric\" minute=\"numeric\" second=\"numeric\"></time-formatted>\n\n<script>\nsetInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)\n</script>\nThe rendering logic is moved to render() helper method.\nWe call it once when the element is inserted into page.\nFor a change of an attribute, listed in observedAttributes(), attributeChangedCallback triggers.\n…and re-renders the element.\nAt the end, we can easily make a live timer.\nRendering order\n\nWhen HTML parser builds the DOM, elements are processed one after another, parents before children. E.g. if we have <outer><inner></inner></outer>, then <outer> element is created and connected to DOM first, and then <inner>.\n\nThat leads to important consequences for custom elements.\n\nFor example, if a custom element tries to access innerHTML in connectedCallback, it gets nothing:\n\n\t\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n    alert(this.innerHTML); // empty (*)\n  }\n\n});\n</script>\n\n<user-info>John</user-info>\n\nIf you run it, the alert is empty.\n\nThat’s exactly because there are no children on that stage, the DOM is unfinished. HTML parser connected the custom element <user-info>, and is going to proceed to its children, but just didn’t yet.\n\nIf we’d like to pass information to custom element, we can use attributes. They are available immediately.\n\nOr, if we really need the children, we can defer access to them with zero-delay setTimeout.\n\nThis works:\n\n\t\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n\n  connectedCallback() {\n    setTimeout(() => alert(this.innerHTML)); // John (*)\n  }\n\n});\n</script>\n\n<user-info>John</user-info>\n\nNow the alert in line (*) shows “John”, as we run it asynchronously, after the HTML parsing is complete. We can process children if needed and finish the initialization.\n\nOn the other hand, this solution is also not perfect. If nested custom elements also use setTimeout to initialize themselves, then they queue up: the outer setTimeout triggers first, and then the inner one.\n\nSo the outer element finishes the initialization before the inner one.\n\nLet’s demonstrate that on example:\n\n\t\n<script>\ncustomElements.define('user-info', class extends HTMLElement {\n  connectedCallback() {\n    alert(`${this.id} connected.`);\n    setTimeout(() => alert(`${this.id} initialized.`));\n  }\n});\n</script>\n\n<user-info id=\"outer\">\n  <user-info id=\"inner\"></user-info>\n</user-info>\n\nOutput order:\n\nouter connected.\ninner connected.\nouter initialized.\ninner initialized.\n\nWe can clearly see that the outer element finishes initialization (3) before the inner one (4).\n\nThere’s no built-in callback that triggers after nested elements are ready. If needed, we can implement such thing on our own. For instance, inner elements can dispatch events like initialized, and outer ones can listen and react on them.\n\nCustomized built-in elements\n\nNew elements that we create, such as <time-formatted>, don’t have any associated semantics. They are unknown to search engines, and accessibility devices can’t handle them.\n\nBut such things can be important. E.g, a search engine would be interested to know that we actually show a time. And if we’re making a special kind of button, why not reuse the existing <button> functionality?\n\nWe can extend and customize built-in HTML elements by inheriting from their classes.\n\nFor example, buttons are instances of HTMLButtonElement, let’s build upon it.\n\nExtend HTMLButtonElement with our class:\n\nclass HelloButton extends HTMLButtonElement { /* custom element methods */ }\n\nProvide the third argument to customElements.define, that specifies the tag:\n\ncustomElements.define('hello-button', HelloButton, {extends: 'button'});\n\nThere may be different tags that share the same DOM-class, that’s why specifying extends is needed.\n\nAt the end, to use our custom element, insert a regular <button> tag, but add is=\"hello-button\" to it:\n\n<button is=\"hello-button\">...</button>\n\nHere’s a full example:\n\n\t\n<script>\n// The button that says \"hello\" on click\nclass HelloButton extends HTMLButtonElement {\n  constructor() {\n    super();\n    this.addEventListener('click', () => alert(\"Hello!\"));\n  }\n}\n\ncustomElements.define('hello-button', HelloButton, {extends: 'button'});\n</script>\n\n<button is=\"hello-button\">Click me</button>\n\n<button is=\"hello-button\" disabled>Disabled</button>\n\nOur new button extends the built-in one. So it keeps the same styles and standard features like disabled attribute.\n\nReferences\nHTML Living Standard: https://html.spec.whatwg.org/#custom-elements.\nCompatiblity: https://caniuse.com/#feat=custom-elementsv1.\nSummary\n\nCustom elements can be of two types:\n\n“Autonomous” – new tags, extending HTMLElement.\n\nDefinition scheme:\n\nclass MyElement extends HTMLElement {\n  constructor() { super(); /* ... */ }\n  connectedCallback() { /* ... */ }\n  disconnectedCallback() { /* ... */  }\n  static get observedAttributes() { return [/* ... */]; }\n  attributeChangedCallback(name, oldValue, newValue) { /* ... */ }\n  adoptedCallback() { /* ... */ }\n }\ncustomElements.define('my-element', MyElement);\n/* <my-element> */\n\n“Customized built-in elements” – extensions of existing elements.\n\nRequires one more .define argument, and is=\"...\" in HTML:\n\nclass MyButton extends HTMLButtonElement { /*...*/ }\ncustomElements.define('my-button', MyElement, {extends: 'button'});\n/* <button is=\"my-button\"> */\n\nCustom elements are well-supported among browsers. There’s a polyfill https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs.\n\nTasks\nLive timer element\n\nWe already have <time-formatted> element to show a nicely formatted time.\n\nCreate <live-timer> element to show the current time:\n\nIt should use <time-formatted> internally, not duplicate its functionality.\nTicks (updates) every second.\nFor every tick, a custom event named tick should be generated, with the current date in event.detail (see chapter Dispatching custom events).\n\nUsage:\n\n<live-timer id=\"elem\"></live-timer>\n\n<script>\n  elem.addEventListener('tick', event => console.log(event.detail));\n</script>\n\nDemo:\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Animation",
    "url": "https://javascript.info/animation",
    "html": "CSS and JavaScript animations.\n\nBezier curve\nCSS-animations\nJavaScript animations"
  },
  {
    "title": "Web components",
    "url": "https://javascript.info/web-components",
    "html": "Web components is a set of standards to make self-contained components: custom HTML-elements with their own properties and methods, encapsulated DOM and styles.\n\nFrom the orbital height\nCustom elements\nShadow DOM\nTemplate element\nShadow DOM slots, composition\nShadow DOM styling\nShadow DOM and events"
  },
  {
    "title": "IndexedDB",
    "url": "https://javascript.info/indexeddb",
    "html": "IndexedDB is a database that is built into a browser, much more powerful than localStorage.\n\nStores almost any kind of values by keys, multiple key types.\nSupports transactions for reliability.\nSupports key range queries, indexes.\nCan store much bigger volumes of data than localStorage.\n\nThat power is usually excessive for traditional client-server apps. IndexedDB is intended for offline apps, to be combined with ServiceWorkers and other technologies.\n\nThe native interface to IndexedDB, described in the specification https://www.w3.org/TR/IndexedDB, is event-based.\n\nWe can also use async/await with the help of a promise-based wrapper, like https://github.com/jakearchibald/idb. That’s pretty convenient, but the wrapper is not perfect, it can’t replace events for all cases. So we’ll start with events, and then, after we gain an understanding of IndexedDb, we’ll use the wrapper.\n\nWhere’s the data?\n\nTechnically, the data is usually stored in the visitor’s home directory, along with browser settings, extensions, etc.\n\nDifferent browsers and OS-level users have each their own independant storage.\n\nOpen database\n\nTo start working with IndexedDB, we first need to open (connect to) a database.\n\nThe syntax:\n\nlet openRequest = indexedDB.open(name, version);\nname – a string, the database name.\nversion – a positive integer version, by default 1 (explained below).\n\nWe can have many databases with different names, but all of them exist within the current origin (domain/protocol/port). Different websites can’t access each other’s databases.\n\nThe call returns openRequest object, we should listen to events on it:\n\nsuccess: database is ready, there’s the “database object” in openRequest.result, we should use it for further calls.\nerror: opening failed.\nupgradeneeded: database is ready, but its version is outdated (see below).\n\nIndexedDB has a built-in mechanism of “schema versioning”, absent in server-side databases.\n\nUnlike server-side databases, IndexedDB is client-side, the data is stored in the browser, so we, developers, don’t have full-time access to it. So, when we have published a new version of our app, and the user visits our webpage, we may need to update the database.\n\nIf the local database version is less than specified in open, then a special event upgradeneeded is triggered, and we can compare versions and upgrade data structures as needed.\n\nThe upgradeneeded event also triggers when the database doesn’t yet exist (technically, its version is 0), so we can perform the initialization.\n\nLet’s say we published the first version of our app.\n\nThen we can open the database with version 1 and perform the initialization in an upgradeneeded handler like this:\n\nlet openRequest = indexedDB.open(\"store\", 1);\n\nopenRequest.onupgradeneeded = function() {\n  // triggers if the client had no database\n  // ...perform initialization...\n};\n\nopenRequest.onerror = function() {\n  console.error(\"Error\", openRequest.error);\n};\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n  // continue working with database using db object\n};\n\nThen, later, we publish the 2nd version.\n\nWe can open it with version 2 and perform the upgrade like this:\n\nlet openRequest = indexedDB.open(\"store\", 2);\n\nopenRequest.onupgradeneeded = function(event) {\n  // the existing database version is less than 2 (or it doesn't exist)\n  let db = openRequest.result;\n  switch(event.oldVersion) { // existing db version\n    case 0:\n      // version 0 means that the client had no database\n      // perform initialization\n    case 1:\n      // client had version 1\n      // update\n  }\n};\n\nPlease note: as our current version is 2, the onupgradeneeded handler has a code branch for version 0, suitable for users that are accessing for the first time and have no database, and also for version 1, for upgrades.\n\nAnd then, only if onupgradeneeded handler finishes without errors, openRequest.onsuccess triggers, and the database is considered successfully opened.\n\nTo delete a database:\n\nlet deleteRequest = indexedDB.deleteDatabase(name)\n// deleteRequest.onsuccess/onerror tracks the result\nWe can’t open a database using an older open call version\n\nIf the current user database has a higher version than in the open call, e.g. the existing DB version is 3, and we try to open(...2), then that’s an error, openRequest.onerror triggers.\n\nThat’s rare, but such a thing may happen when a visitor loads outdated JavaScript code, e.g. from a proxy cache. So the code is old, but his database is new.\n\nTo protect from errors, we should check db.version and suggest a page reload. Use proper HTTP caching headers to avoid loading the old code, so that you’ll never have such problems.\n\nParallel update problem\n\nAs we’re talking about versioning, let’s tackle a small related problem.\n\nLet’s say:\n\nA visitor opened our site in a browser tab, with database version 1.\nThen we rolled out an update, so our code is newer.\nAnd then the same visitor opens our site in another tab.\n\nSo there’s a tab with an open connection to DB version 1, while the second one attempts to update it to version 2 in its upgradeneeded handler.\n\nThe problem is that a database is shared between two tabs, as it’s the same site, same origin. And it can’t be both version 1 and 2. To perform the update to version 2, all connections to version 1 must be closed, including the one in the first tab.\n\nIn order to organize that, the versionchange event triggers on the “outdated” database object. We should listen for it and close the old database connection (and probably suggest a page reload, to load the updated code).\n\nIf we don’t listen for the versionchange event and don’t close the old connection, then the second, new connection won’t be made. The openRequest object will emit the blocked event instead of success. So the second tab won’t work.\n\nHere’s the code to correctly handle the parallel upgrade. It installs the onversionchange handler, that triggers if the current database connection becomes outdated (db version is updated elsewhere) and closes the connection.\n\nlet openRequest = indexedDB.open(\"store\", 2);\n\nopenRequest.onupgradeneeded = ...;\nopenRequest.onerror = ...;\n\nopenRequest.onsuccess = function() {\n  let db = openRequest.result;\n\n  db.onversionchange = function() {\n    db.close();\n    alert(\"Database is outdated, please reload the page.\")\n  };\n\n  // ...the db is ready, use it...\n};\n\nopenRequest.onblocked = function() {\n  // this event shouldn't trigger if we handle onversionchange correctly\n\n  // it means that there's another open connection to the same database\n  // and it wasn't closed after db.onversionchange triggered for it\n};\n\n…In other words, here we do two things:\n\nThe db.onversionchange listener informs us about a parallel update attempt, if the current database version becomes outdated.\nThe openRequest.onblocked listener informs us about the opposite situation: there’s a connection to an outdated version elsewhere, and it doesn’t close, so the newer connection can’t be made.\n\nWe can handle things more gracefully in db.onversionchange, prompt the visitor to save the data before the connection is closed and so on.\n\nOr, an alternative approach would be to not close the database in db.onversionchange, but instead use the onblocked handler (in the new tab) to alert the visitor, tell him that the newer version can’t be loaded until they close other tabs.\n\nThese update collisions happen rarely, but we should at least have some handling for them, at least an onblocked handler, to prevent our script from dying silently.\n\nObject store\n\nTo store something in IndexedDB, we need an object store.\n\nAn object store is a core concept of IndexedDB. Counterparts in other databases are called “tables” or “collections”. It’s where the data is stored. A database may have multiple stores: one for users, another one for goods, etc.\n\nDespite being named an “object store”, primitives can be stored too.\n\nWe can store almost any value, including complex objects.\n\nIndexedDB uses the standard serialization algorithm to clone-and-store an object. It’s like JSON.stringify, but more powerful, capable of storing much more datatypes.\n\nAn example of an object that can’t be stored: an object with circular references. Such objects are not serializable. JSON.stringify also fails for such objects.\n\nThere must be a unique key for every value in the store.\n\nA key must be one of these types – number, date, string, binary, or array. It’s a unique identifier, so we can search/remove/update values by the key.\n\nAs we’ll see very soon, we can provide a key when we add a value to the store, similar to localStorage. But when we store objects, IndexedDB allows setting up an object property as the key, which is much more convenient. Or we can auto-generate keys.\n\nBut we need to create an object store first.\n\nThe syntax to create an object store:\n\ndb.createObjectStore(name[, keyOptions]);\n\nPlease note, the operation is synchronous, no await needed.\n\nname is the store name, e.g. \"books\" for books,\nkeyOptions is an optional object with one of two properties:\nkeyPath – a path to an object property that IndexedDB will use as the key, e.g. id.\nautoIncrement – if true, then the key for a newly stored object is generated automatically, as an ever-incrementing number.\n\nIf we don’t supply keyOptions, then we’ll need to provide a key explicitly later, when storing an object.\n\nFor instance, this object store uses id property as the key:\n\ndb.createObjectStore('books', {keyPath: 'id'});\n\nAn object store can only be created/modified while updating the DB version, in upgradeneeded handler.\n\nThat’s a technical limitation. Outside of the handler we’ll be able to add/remove/update the data, but object stores can only be created/removed/altered during a version update.\n\nTo perform a database version upgrade, there are two main approaches:\n\nWe can implement per-version upgrade functions: from 1 to 2, from 2 to 3, from 3 to 4 etc. Then, in upgradeneeded we can compare versions (e.g. old 2, now 4) and run per-version upgrades step by step, for every intermediate version (2 to 3, then 3 to 4).\nOr we can just examine the database: get a list of existing object stores as db.objectStoreNames. That object is a DOMStringList that provides contains(name) method to check for existance. And then we can do updates depending on what exists and what doesn’t.\n\nFor small databases the second variant may be simpler.\n\nHere’s the demo of the second approach:\n\nlet openRequest = indexedDB.open(\"db\", 2);\n\n// create/upgrade the database without version checks\nopenRequest.onupgradeneeded = function() {\n  let db = openRequest.result;\n  if (!db.objectStoreNames.contains('books')) { // if there's no \"books\" store\n    db.createObjectStore('books', {keyPath: 'id'}); // create it\n  }\n};\n\nTo delete an object store:\n\ndb.deleteObjectStore('books')\nTransactions\n\nThe term “transaction” is generic, used in many kinds of databases.\n\nA transaction is a group of operations, that should either all succeed or all fail.\n\nFor instance, when a person buys something, we need to:\n\nSubtract the money from their account.\nAdd the item to their inventory.\n\nIt would be pretty bad if we complete the 1st operation, and then something goes wrong, e.g. lights out, and we fail to do the 2nd. Both should either succeed (purchase complete, good!) or both fail (at least the person kept their money, so they can retry).\n\nTransactions can guarantee that.\n\nAll data operations must be made within a transaction in IndexedDB.\n\nTo start a transaction:\n\ndb.transaction(store[, type]);\nstore is a store name that the transaction is going to access, e.g. \"books\". Can be an array of store names if we’re going to access multiple stores.\ntype – a transaction type, one of:\nreadonly – can only read, the default.\nreadwrite – can only read and write the data, but not create/remove/alter object stores.\n\nThere’s also versionchange transaction type: such transactions can do everything, but we can’t create them manually. IndexedDB automatically creates a versionchange transaction when opening the database, for upgradeneeded handler. That’s why it’s a single place where we can update the database structure, create/remove object stores.\n\nWhy are there different types of transactions?\n\nPerformance is the reason why transactions need to be labeled either readonly and readwrite.\n\nMany readonly transactions are able to access the same store concurrently, but readwrite transactions can’t. A readwrite transaction “locks” the store for writing. The next transaction must wait before the previous one finishes before accessing the same store.\n\nAfter the transaction is created, we can add an item to the store, like this:\n\nlet transaction = db.transaction(\"books\", \"readwrite\"); // (1)\n\n// get an object store to operate on it\nlet books = transaction.objectStore(\"books\"); // (2)\n\nlet book = {\n  id: 'js',\n  price: 10,\n  created: new Date()\n};\n\nlet request = books.add(book); // (3)\n\nrequest.onsuccess = function() { // (4)\n  console.log(\"Book added to the store\", request.result);\n};\n\nrequest.onerror = function() {\n  console.log(\"Error\", request.error);\n};\n\nThere were basically four steps:\n\nCreate a transaction, mentioning all the stores it’s going to access, at (1).\nGet the store object using transaction.objectStore(name), at (2).\nPerform the request to the object store books.add(book), at (3).\n…Handle request success/error (4), then we can make other requests if needed, etc.\n\nObject stores support two methods to store a value:\n\nput(value, [key]) Add the value to the store. The key is supplied only if the object store did not have keyPath or autoIncrement option. If there’s already a value with the same key, it will be replaced.\n\nadd(value, [key]) Same as put, but if there’s already a value with the same key, then the request fails, and an error with the name \"ConstraintError\" is generated.\n\nSimilar to opening a database, we can send a request: books.add(book), and then wait for success/error events.\n\nThe request.result for add is the key of the new object.\nThe error is in request.error (if any).\nTransactions’ autocommit\n\nIn the example above we started the transaction and made add request. But as we stated previously, a transaction may have multiple associated requests, that must either all succeed or all fail. How do we mark the transaction as finished, with no more requests to come?\n\nThe short answer is: we don’t.\n\nIn the next version 3.0 of the specification, there will probably be a manual way to finish the transaction, but right now in 2.0 there isn’t.\n\nWhen all transaction requests are finished, and the microtasks queue is empty, it is committed automatically.\n\nUsually, we can assume that a transaction commits when all its requests are complete, and the current code finishes.\n\nSo, in the example above no special call is needed to finish the transaction.\n\nTransactions auto-commit principle has an important side effect. We can’t insert an async operation like fetch, setTimeout in the middle of a transaction. IndexedDB will not keep the transaction waiting till these are done.\n\nIn the code below, request2 in the line (*) fails, because the transaction is already committed, and can’t make any request in it:\n\nlet request1 = books.add(book);\n\nrequest1.onsuccess = function() {\n  fetch('/').then(response => {\n    let request2 = books.add(anotherBook); // (*)\n    request2.onerror = function() {\n      console.log(request2.error.name); // TransactionInactiveError\n    };\n  });\n};\n\nThat’s because fetch is an asynchronous operation, a macrotask. Transactions are closed before the browser starts doing macrotasks.\n\nAuthors of IndexedDB spec believe that transactions should be short-lived. Mostly for performance reasons.\n\nNotably, readwrite transactions “lock” the stores for writing. So if one part of the application initiated readwrite on books object store, then another part that wants to do the same has to wait: the new transaction “hangs” till the first one is done. That can lead to strange delays if transactions take a long time.\n\nSo, what to do?\n\nIn the example above we could make a new db.transaction right before the new request (*).\n\nBut it will be even better, if we’d like to keep the operations together, in one transaction, to split apart IndexedDB transactions and “other” async stuff.\n\nFirst, make fetch, prepare the data if needed, afterwards create a transaction and perform all the database requests, it’ll work then.\n\nTo detect the moment of successful completion, we can listen to transaction.oncomplete event:\n\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\n// ...perform operations...\n\ntransaction.oncomplete = function() {\n  console.log(\"Transaction is complete\");\n};\n\nOnly complete guarantees that the transaction is saved as a whole. Individual requests may succeed, but the final write operation may go wrong (e.g. I/O error or something).\n\nTo manually abort the transaction, call:\n\ntransaction.abort();\n\nThat cancels all modification made by the requests in it and triggers transaction.onabort event.\n\nError handling\n\nWrite requests may fail.\n\nThat’s to be expected, not only because of possible errors at our side, but also for reasons not related to the transaction itself. For instance, the storage quota may be exceeded. So we must be ready to handle such case.\n\nA failed request automatically aborts the transaction, canceling all its changes.\n\nIn some situations, we may want to handle the failure (e.g. try another request), without canceling existing changes, and continue the transaction. That’s possible. The request.onerror handler is able to prevent the transaction abort by calling event.preventDefault().\n\nIn the example below a new book is added with the same key (id) as the existing one. The store.add method generates a \"ConstraintError\" in that case. We handle it without canceling the transaction:\n\nlet transaction = db.transaction(\"books\", \"readwrite\");\n\nlet book = { id: 'js', price: 10 };\n\nlet request = transaction.objectStore(\"books\").add(book);\n\nrequest.onerror = function(event) {\n  // ConstraintError occurs when an object with the same id already exists\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Book with such id already exists\"); // handle the error\n    event.preventDefault(); // don't abort the transaction\n    // use another key for the book?\n  } else {\n    // unexpected error, can't handle it\n    // the transaction will abort\n  }\n};\n\ntransaction.onabort = function() {\n  console.log(\"Error\", transaction.error);\n};\nEvent delegation\n\nDo we need onerror/onsuccess for every request? Not every time. We can use event delegation instead.\n\nIndexedDB events bubble: request → transaction → database.\n\nAll events are DOM events, with capturing and bubbling, but usually only bubbling stage is used.\n\nSo we can catch all errors using db.onerror handler, for reporting or other purposes:\n\ndb.onerror = function(event) {\n  let request = event.target; // the request that caused the error\n\n  console.log(\"Error\", request.error);\n};\n\n…But what if an error is fully handled? We don’t want to report it in that case.\n\nWe can stop the bubbling and hence db.onerror by using event.stopPropagation() in request.onerror.\n\nrequest.onerror = function(event) {\n  if (request.error.name == \"ConstraintError\") {\n    console.log(\"Book with such id already exists\"); // handle the error\n    event.preventDefault(); // don't abort the transaction\n    event.stopPropagation(); // don't bubble error up, \"chew\" it\n  } else {\n    // do nothing\n    // transaction will be aborted\n    // we can take care of error in transaction.onabort\n  }\n};\nSearching\n\nThere are two main types of search in an object store:\n\nBy a key value or a key range. In our “books” storage that would be a value or range of values of book.id.\nBy another object field, e.g. book.price. This required an additional data structure, named “index”.\nBy key\n\nFirst let’s deal with the first type of search: by key.\n\nSearching methods support both exact key values and so-called “ranges of values” – IDBKeyRange objects that specify an acceptable “key range”.\n\nIDBKeyRange objects are created using following calls:\n\nIDBKeyRange.lowerBound(lower, [open]) means: ≥lower (or >lower if open is true)\nIDBKeyRange.upperBound(upper, [open]) means: ≤upper (or <upper if open is true)\nIDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen]) means: between lower and upper. If the open flags is true, the corresponding key is not included in the range.\nIDBKeyRange.only(key) – a range that consists of only one key, rarely used.\n\nWe’ll see practical examples of using them very soon.\n\nTo perform the actual search, there are following methods. They accept a query argument that can be either an exact key or a key range:\n\nstore.get(query) – search for the first value by a key or a range.\nstore.getAll([query], [count]) – search for all values, limit by count if given.\nstore.getKey(query) – search for the first key that satisfies the query, usually a range.\nstore.getAllKeys([query], [count]) – search for all keys that satisfy the query, usually a range, up to count if given.\nstore.count([query]) – get the total count of keys that satisfy the query, usually a range.\n\nFor instance, we have a lot of books in our store. Remember, the id field is the key, so all these methods can search by id.\n\nRequest examples:\n\n// get one book\nbooks.get('js')\n\n// get books with 'css' <= id <= 'html'\nbooks.getAll(IDBKeyRange.bound('css', 'html'))\n\n// get books with id < 'html'\nbooks.getAll(IDBKeyRange.upperBound('html', true))\n\n// get all books\nbooks.getAll()\n\n// get all keys, where id > 'js'\nbooks.getAllKeys(IDBKeyRange.lowerBound('js', true))\nObject store is always sorted\n\nAn object store sorts values by key internally.\n\nSo requests that return many values always return them in sorted by key order.\n\nBy a field using an index\n\nTo search by other object fields, we need to create an additional data structure named “index”.\n\nAn index is an “add-on” to the store that tracks a given object field. For each value of that field, it stores a list of keys for objects that have that value. There will be a more detailed picture below.\n\nThe syntax:\n\nobjectStore.createIndex(name, keyPath, [options]);\nname – index name,\nkeyPath – path to the object field that the index should track (we’re going to search by that field),\noption – an optional object with properties:\nunique – if true, then there may be only one object in the store with the given value at the keyPath. The index will enforce that by generating an error if we try to add a duplicate.\nmultiEntry – only used if the value on keyPath is an array. In that case, by default, the index will treat the whole array as the key. But if multiEntry is true, then the index will keep a list of store objects for each value in that array. So array members become index keys.\n\nIn our example, we store books keyed by id.\n\nLet’s say we want to search by price.\n\nFirst, we need to create an index. It must be done in upgradeneeded, just like an object store:\n\nopenRequest.onupgradeneeded = function() {\n  // we must create the index here, in versionchange transaction\n  let books = db.createObjectStore('books', {keyPath: 'id'});\n  let index = books.createIndex('price_idx', 'price');\n};\nThe index will track price field.\nThe price is not unique, there may be multiple books with the same price, so we don’t set unique option.\nThe price is not an array, so multiEntry flag is not applicable.\n\nImagine that our inventory has 4 books. Here’s the picture that shows exactly what the index is:\n\nAs said, the index for each value of price (second argument) keeps the list of keys that have that price.\n\nThe index keeps itself up to date automatically, we don’t have to care about it.\n\nNow, when we want to search for a given price, we simply apply the same search methods to the index:\n\nlet transaction = db.transaction(\"books\"); // readonly\nlet books = transaction.objectStore(\"books\");\nlet priceIndex = books.index(\"price_idx\");\n\nlet request = priceIndex.getAll(10);\n\nrequest.onsuccess = function() {\n  if (request.result !== undefined) {\n    console.log(\"Books\", request.result); // array of books with price=10\n  } else {\n    console.log(\"No such books\");\n  }\n};\n\nWe can also use IDBKeyRange to create ranges and looks for cheap/expensive books:\n\n// find books where price <= 5\nlet request = priceIndex.getAll(IDBKeyRange.upperBound(5));\n\nIndexes are internally sorted by the tracked object field, price in our case. So when we do the search, the results are also sorted by price.\n\nDeleting from store\n\nThe delete method looks up values to delete by a query, the call format is similar to getAll:\n\ndelete(query) – delete matching values by query.\n\nFor instance:\n\n// delete the book with id='js'\nbooks.delete('js');\n\nIf we’d like to delete books based on a price or another object field, then we should first find the key in the index, and then call delete:\n\n// find the key where price = 5\nlet request = priceIndex.getKey(5);\n\nrequest.onsuccess = function() {\n  let id = request.result;\n  let deleteRequest = books.delete(id);\n};\n\nTo delete everything:\n\nbooks.clear(); // clear the storage.\nCursors\n\nMethods like getAll/getAllKeys return an array of keys/values.\n\nBut an object storage can be huge, bigger than the available memory. Then getAll will fail to get all records as an array.\n\nWhat to do?\n\nCursors provide the means to work around that.\n\nA cursor is a special object that traverses the object storage, given a query, and returns one key/value at a time, thus saving memory.\n\nAs an object store is sorted internally by key, a cursor walks the store in key order (ascending by default).\n\nThe syntax:\n\n// like getAll, but with a cursor:\nlet request = store.openCursor(query, [direction]);\n\n// to get keys, not values (like getAllKeys): store.openKeyCursor\nquery is a key or a key range, same as for getAll.\ndirection is an optional argument, which order to use:\n\"next\" – the default, the cursor walks up from the record with the lowest key.\n\"prev\" – the reverse order: down from the record with the biggest key.\n\"nextunique\", \"prevunique\" – same as above, but skip records with the same key (only for cursors over indexes, e.g. for multiple books with price=5 only the first one will be returned).\n\nThe main difference of the cursor is that request.onsuccess triggers multiple times: once for each result.\n\nHere’s an example of how to use a cursor:\n\nlet transaction = db.transaction(\"books\");\nlet books = transaction.objectStore(\"books\");\n\nlet request = books.openCursor();\n\n// called for each book found by the cursor\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let key = cursor.key; // book key (id field)\n    let value = cursor.value; // book object\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"No more books\");\n  }\n};\n\nThe main cursor methods are:\n\nadvance(count) – advance the cursor count times, skipping values.\ncontinue([key]) – advance the cursor to the next value in range matching (or immediately after key if given).\n\nWhether there are more values matching the cursor or not – onsuccess gets called, and then in result we can get the cursor pointing to the next record, or undefined.\n\nIn the example above the cursor was made for the object store.\n\nBut we also can make a cursor over an index. As we remember, indexes allow to search by an object field. Cursors over indexes do precisely the same as over object stores – they save memory by returning one value at a time.\n\nFor cursors over indexes, cursor.key is the index key (e.g. price), and we should use cursor.primaryKey property for the object key:\n\nlet request = priceIdx.openCursor(IDBKeyRange.upperBound(5));\n\n// called for each record\nrequest.onsuccess = function() {\n  let cursor = request.result;\n  if (cursor) {\n    let primaryKey = cursor.primaryKey; // next object store key (id field)\n    let value = cursor.value; // next object store object (book object)\n    let key = cursor.key; // next index key (price)\n    console.log(key, value);\n    cursor.continue();\n  } else {\n    console.log(\"No more books\");\n  }\n};\nPromise wrapper\n\nAdding onsuccess/onerror to every request is quite a cumbersome task. Sometimes we can make our life easier by using event delegation, e.g. set handlers on the whole transactions, but async/await is much more convenient.\n\nLet’s use a thin promise wrapper https://github.com/jakearchibald/idb further in this chapter. It creates a global idb object with promisified IndexedDB methods.\n\nThen, instead of onsuccess/onerror we can write like this:\n\nlet db = await idb.openDB('store', 1, db => {\n  if (db.oldVersion == 0) {\n    // perform the initialization\n    db.createObjectStore('books', {keyPath: 'id'});\n  }\n});\n\nlet transaction = db.transaction('books', 'readwrite');\nlet books = transaction.objectStore('books');\n\ntry {\n  await books.add(...);\n  await books.add(...);\n\n  await transaction.complete;\n\n  console.log('jsbook saved');\n} catch(err) {\n  console.log('error', err.message);\n}\n\nSo we have all the sweet “plain async code” and “try…catch” stuff.\n\nError handling\n\nIf we don’t catch an error, then it falls through, till the closest outer try..catch.\n\nAn uncaught error becomes an “unhandled promise rejection” event on window object.\n\nWe can handle such errors like this:\n\nwindow.addEventListener('unhandledrejection', event => {\n  let request = event.target; // IndexedDB native request object\n  let error = event.reason; //  Unhandled error object, same as request.error\n  ...report about the error...\n});\n“Inactive transaction” pitfall\n\nAs we already know, a transaction auto-commits as soon as the browser is done with the current code and microtasks. So if we put a macrotask like fetch in the middle of a transaction, then the transaction won’t wait for it to finish. It just auto-commits. So the next request in it would fail.\n\nFor a promise wrapper and async/await the situation is the same.\n\nHere’s an example of fetch in the middle of the transaction:\n\nlet transaction = db.transaction(\"inventory\", \"readwrite\");\nlet inventory = transaction.objectStore(\"inventory\");\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() });\n\nawait fetch(...); // (*)\n\nawait inventory.add({ id: 'js', price: 10, created: new Date() }); // Error\n\nThe next inventory.add after fetch (*) fails with an “inactive transaction” error, because the transaction is already committed and closed at that time.\n\nThe workaround is the same as when working with native IndexedDB: either make a new transaction or just split things apart.\n\nPrepare the data and fetch all that’s needed first.\nThen save in the database.\nGetting native objects\n\nInternally, the wrapper performs a native IndexedDB request, adding onerror/onsuccess to it, and returns a promise that rejects/resolves with the result.\n\nThat works fine most of the time. The examples are at the lib page https://github.com/jakearchibald/idb.\n\nIn few rare cases, when we need the original request object, we can access it as promise.request property of the promise:\n\nlet promise = books.add(book); // get a promise (don't await for its result)\n\nlet request = promise.request; // native request object\nlet transaction = request.transaction; // native transaction object\n\n// ...do some native IndexedDB voodoo...\n\nlet result = await promise; // if still needed\nSummary\n\nIndexedDB can be thought of as a “localStorage on steroids”. It’s a simple key-value database, powerful enough for offline apps, yet simple to use.\n\nThe best manual is the specification, the current one is 2.0, but few methods from 3.0 (it’s not much different) are partially supported.\n\nThe basic usage can be described with a few phrases:\n\nGet a promise wrapper like idb.\nOpen a database: idb.openDb(name, version, onupgradeneeded)\nCreate object storages and indexes in onupgradeneeded handler or perform version update if needed.\nFor requests:\nCreate transaction db.transaction('books') (readwrite if needed).\nGet the object store transaction.objectStore('books').\nThen, to search by a key, call methods on the object store directly.\nTo search by an object field, create an index.\nIf the data does not fit in memory, use a cursor.\n\nHere’s a small demo app:\n\nResultindex.html\n\t\n<!doctype html>\n<script src=\"https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js\"></script>\n\n<button onclick=\"addBook()\">Add a book</button>\n<button onclick=\"clearBooks()\">Clear books</button>\n\n<p>Books list:</p>\n\n<ul id=\"listElem\"></ul>\n\n<script>\nlet db;\n\ninit();\n\nasync function init() {\n  db = await idb.openDb('booksDb', 1, db => {\n    db.createObjectStore('books', {keyPath: 'name'});\n  });\n\n  list();\n}\n\nasync function list() {\n  let tx = db.transaction('books');\n  let bookStore = tx.objectStore('books');\n\n  let books = await bookStore.getAll();\n\n  if (books.length) {\n    listElem.innerHTML = books.map(book => `<li>\n        name: ${book.name}, price: ${book.price}\n      </li>`).join('');\n  } else {\n    listElem.innerHTML = '<li>No books yet. Please add books.</li>'\n  }\n\n\n}\n\nasync function clearBooks() {\n  let tx = db.transaction('books', 'readwrite');\n  await tx.objectStore('books').clear();\n  await list();\n}\n\nasync function addBook() {\n  let name = prompt(\"Book name?\");\n  let price = +prompt(\"Book price?\");\n\n  let tx = db.transaction('books', 'readwrite');\n\n  try {\n    await tx.objectStore('books').add({name, price});\n    await list();\n  } catch(err) {\n    if (err.name == 'ConstraintError') {\n      alert(\"Such book exists already\");\n      await addBook();\n    } else {\n      throw err;\n    }\n  }\n}\n\nwindow.addEventListener('unhandledrejection', event => {\n  alert(\"Error: \" + event.reason.message);\n});\n\n</script>"
  },
  {
    "title": "LocalStorage, sessionStorage",
    "url": "https://javascript.info/localstorage",
    "html": "Web storage objects localStorage and sessionStorage allow to save key/value pairs in the browser.\n\nWhat’s interesting about them is that the data survives a page refresh (for sessionStorage) and even a full browser restart (for localStorage). We’ll see that very soon.\n\nWe already have cookies. Why additional objects?\n\nUnlike cookies, web storage objects are not sent to server with each request. Because of that, we can store much more. Most modern browsers allow at least 5 megabytes of data (or more) and have settings to configure that.\nAlso unlike cookies, the server can’t manipulate storage objects via HTTP headers. Everything’s done in JavaScript.\nThe storage is bound to the origin (domain/protocol/port triplet). That is, different protocols or subdomains infer different storage objects, they can’t access data from each other.\n\nBoth storage objects provide the same methods and properties:\n\nsetItem(key, value) – store key/value pair.\ngetItem(key) – get the value by key.\nremoveItem(key) – remove the key with its value.\nclear() – delete everything.\nkey(index) – get the key on a given position.\nlength – the number of stored items.\n\nAs you can see, it’s like a Map collection (setItem/getItem/removeItem), but also allows access by index with key(index).\n\nLet’s see how it works.\n\nlocalStorage demo\n\nThe main features of localStorage are:\n\nShared between all tabs and windows from the same origin.\nThe data does not expire. It remains after the browser restart and even OS reboot.\n\nFor instance, if you run this code…\n\n\t\nlocalStorage.setItem('test', 1);\n\n…And close/open the browser or just open the same page in a different window, then you can get it like this:\n\n\t\nalert( localStorage.getItem('test') ); // 1\n\nWe only have to be on the same origin (domain/port/protocol), the url path can be different.\n\nThe localStorage is shared between all windows with the same origin, so if we set the data in one window, the change becomes visible in another one.\n\nObject-like access\n\nWe can also use a plain object way of getting/setting keys, like this:\n\n\t\n// set key\nlocalStorage.test = 2;\n\n// get key\nalert( localStorage.test ); // 2\n\n// remove key\ndelete localStorage.test;\n\nThat’s allowed for historical reasons, and mostly works, but generally not recommended, because:\n\nIf the key is user-generated, it can be anything, like length or toString, or another built-in method of localStorage. In that case getItem/setItem work fine, while object-like access fails:\n\n\t\nlet key = 'length';\nlocalStorage[key] = 5; // Error, can't assign length\n\nThere’s a storage event, it triggers when we modify the data. That event does not happen for object-like access. We’ll see that later in this chapter.\n\nLooping over keys\n\nAs we’ve seen, the methods provide “get/set/remove by key” functionality. But how to get all saved values or keys?\n\nUnfortunately, storage objects are not iterable.\n\nOne way is to loop over them as over an array:\n\n\t\nfor(let i=0; i<localStorage.length; i++) {\n  let key = localStorage.key(i);\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n\nAnother way is to use for key in localStorage loop, just as we do with regular objects.\n\nIt iterates over keys, but also outputs few built-in fields that we don’t need:\n\n\t\n// bad try\nfor(let key in localStorage) {\n  alert(key); // shows getItem, setItem and other built-in stuff\n}\n\n…So we need either to filter fields from the prototype with hasOwnProperty check:\n\n\t\nfor(let key in localStorage) {\n  if (!localStorage.hasOwnProperty(key)) {\n    continue; // skip keys like \"setItem\", \"getItem\" etc\n  }\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n\n…Or just get the “own” keys with Object.keys and then loop over them if needed:\n\n\t\nlet keys = Object.keys(localStorage);\nfor(let key of keys) {\n  alert(`${key}: ${localStorage.getItem(key)}`);\n}\n\nThe latter works, because Object.keys only returns the keys that belong to the object, ignoring the prototype.\n\nStrings only\n\nPlease note that both key and value must be strings.\n\nIf they were any other type, like a number, or an object, they would get converted to a string automatically:\n\n\t\nlocalStorage.user = {name: \"John\"};\nalert(localStorage.user); // [object Object]\n\nWe can use JSON to store objects though:\n\n\t\nlocalStorage.user = JSON.stringify({name: \"John\"});\n\n// sometime later\nlet user = JSON.parse( localStorage.user );\nalert( user.name ); // John\n\nAlso it is possible to stringify the whole storage object, e.g. for debugging purposes:\n\n\t\n// added formatting options to JSON.stringify to make the object look nicer\nalert( JSON.stringify(localStorage, null, 2) );\nsessionStorage\n\nThe sessionStorage object is used much less often than localStorage.\n\nProperties and methods are the same, but it’s much more limited:\n\nThe sessionStorage exists only within the current browser tab.\nAnother tab with the same page will have a different storage.\nBut it is shared between iframes in the same tab (assuming they come from the same origin).\nThe data survives page refresh, but not closing/opening the tab.\n\nLet’s see that in action.\n\nRun this code…\n\n\t\nsessionStorage.setItem('test', 1);\n\n…Then refresh the page. Now you can still get the data:\n\n\t\nalert( sessionStorage.getItem('test') ); // after refresh: 1\n\n…But if you open the same page in another tab, and try again there, the code above returns null, meaning “nothing found”.\n\nThat’s exactly because sessionStorage is bound not only to the origin, but also to the browser tab. For that reason, sessionStorage is used sparingly.\n\nStorage event\n\nWhen the data gets updated in localStorage or sessionStorage, storage event triggers, with properties:\n\nkey – the key that was changed (null if .clear() is called).\noldValue – the old value (null if the key is newly added).\nnewValue – the new value (null if the key is removed).\nurl – the url of the document where the update happened.\nstorageArea – either localStorage or sessionStorage object where the update happened.\n\nThe important thing is: the event triggers on all window objects where the storage is accessible, except the one that caused it.\n\nLet’s elaborate.\n\nImagine, you have two windows with the same site in each. So localStorage is shared between them.\n\nYou might want to open this page in two browser windows to test the code below.\n\nIf both windows are listening for window.onstorage, then each one will react on updates that happened in the other one.\n\n\t\n// triggers on updates made to the same storage from other documents\nwindow.onstorage = event => { // can also use window.addEventListener('storage', event => {\n  if (event.key != 'now') return;\n  alert(event.key + ':' + event.newValue + \" at \" + event.url);\n};\n\nlocalStorage.setItem('now', Date.now());\n\nPlease note that the event also contains: event.url – the url of the document where the data was updated.\n\nAlso, event.storageArea contains the storage object – the event is the same for both sessionStorage and localStorage, so event.storageArea references the one that was modified. We may even want to set something back in it, to “respond” to a change.\n\nThat allows different windows from the same origin to exchange messages.\n\nModern browsers also support Broadcast channel API, the special API for same-origin inter-window communication, it’s more full featured, but less supported. There are libraries that polyfill that API, based on localStorage, that make it available everywhere.\n\nSummary\n\nWeb storage objects localStorage and sessionStorage allow to store key/value pairs in the browser.\n\nBoth key and value must be strings.\nThe limit is 5mb+, depends on the browser.\nThey do not expire.\nThe data is bound to the origin (domain/port/protocol).\nlocalStorage\tsessionStorage\nShared between all tabs and windows with the same origin\tVisible within a browser tab, including iframes from the same origin\nSurvives browser restart\tSurvives page refresh (but not tab close)\n\nAPI:\n\nsetItem(key, value) – store key/value pair.\ngetItem(key) – get the value by key.\nremoveItem(key) – remove the key with its value.\nclear() – delete everything.\nkey(index) – get the key number index.\nlength – the number of stored items.\nUse Object.keys to get all keys.\nWe access keys as object properties, in that case storage event isn’t triggered.\n\nStorage event:\n\nTriggers on setItem, removeItem, clear calls.\nContains all the data about the operation (key/oldValue/newValue), the document url and the storage object storageArea.\nTriggers on all window objects that have access to the storage except the one that generated it (within a tab for sessionStorage, globally for localStorage).\nTasks\nAutosave a form field\n\nCreate a textarea field that “autosaves” its value on every change.\n\nSo, if the user accidentally closes the page, and opens it again, he’ll find his unfinished input at place.\n\nLike this:\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Cookies, document.cookie",
    "url": "https://javascript.info/cookie",
    "html": "Cookies are small strings of data that are stored directly in the browser. They are a part of the HTTP protocol, defined by the RFC 6265 specification.\n\nCookies are usually set by a web-server using the response Set-Cookie HTTP-header. Then, the browser automatically adds them to (almost) every request to the same domain using the Cookie HTTP-header.\n\nOne of the most widespread use cases is authentication:\n\nUpon sign in, the server uses the Set-Cookie HTTP-header in the response to set a cookie with a unique “session identifier”.\nNext time when the request is sent to the same domain, the browser sends the cookie over the net using the Cookie HTTP-header.\nSo the server knows who made the request.\n\nWe can also access cookies from the browser, using document.cookie property.\n\nThere are many tricky things about cookies and their options. In this chapter we’ll cover them in detail.\n\nReading from document.cookie\n\nDoes your browser store any cookies from this site? Let’s see:\n\n\t\n// At javascript.info, we use Google Analytics for statistics,\n// so there should be some cookies\nalert( document.cookie ); // cookie1=value1; cookie2=value2;...\n\nThe value of document.cookie consists of name=value pairs, delimited by ;. Each one is a separate cookie.\n\nTo find a particular cookie, we can split document.cookie by ;, and then find the right name. We can use either a regular expression or array functions to do that.\n\nWe leave it as an exercise for the reader. Also, at the end of the chapter you’ll find helper functions to manipulate cookies.\n\nWriting to document.cookie\n\nWe can write to document.cookie. But it’s not a data property, it’s an accessor (getter/setter). An assignment to it is treated specially.\n\nA write operation to document.cookie updates only cookies mentioned in it, but doesn’t touch other cookies.\n\nFor instance, this call sets a cookie with the name user and value John:\n\n\t\ndocument.cookie = \"user=John\"; // update only cookie named 'user'\nalert(document.cookie); // show all cookies\n\nIf you run it, then probably you’ll see multiple cookies. That’s because the document.cookie= operation does not overwrite all cookies. It only sets the mentioned cookie user.\n\nTechnically, name and value can have any characters. To keep the valid formatting, they should be escaped using a built-in encodeURIComponent function:\n\n\t\n// special characters (spaces), need encoding\nlet name = \"my name\";\nlet value = \"John Smith\"\n\n// encodes the cookie as my%20name=John%20Smith\ndocument.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);\n\nalert(document.cookie); // ...; my%20name=John%20Smith\nLimitations\n\nThere are few limitations:\n\nThe name=value pair, after encodeURIComponent, should not exceed 4KB. So we can’t store anything huge in a cookie.\nThe total number of cookies per domain is limited to around 20+, the exact limit depends on the browser.\n\nCookies have several options, many of them are important and should be set.\n\nThe options are listed after key=value, delimited by ;, like this:\n\n\t\ndocument.cookie = \"user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT\"\npath\npath=/mypath\n\nThe url path prefix must be absolute. It makes the cookie accessible for pages under that path. By default, it’s the current path.\n\nIf a cookie is set with path=/admin, it’s visible at pages /admin and /admin/something, but not at /home or /adminpage.\n\nUsually, we should set path to the root: path=/ to make the cookie accessible from all website pages.\n\ndomain\ndomain=site.com\n\nA domain defines where the cookie is accessible. In practice though, there are limitations. We can’t set any domain.\n\nThere’s no way to let a cookie be accessible from another 2nd-level domain, so other.com will never receive a cookie set at site.com.\n\nIt’s a safety restriction, to allow us to store sensitive data in cookies that should be available only on one site.\n\nBy default, a cookie is accessible only at the domain that set it.\n\nPlease note, by default a cookie is also not shared to a subdomain as well, such as forum.site.com.\n\n// if we set a cookie at site.com website...\ndocument.cookie = \"user=John\"\n\n// ...we won't see it at forum.site.com\nalert(document.cookie); // no user\n\n…But this can be changed. If we’d like to allow subdomains like forum.site.com to get a cookie set at site.com, that’s possible.\n\nFor that to happen, when setting a cookie at site.com, we should explicitly set the domain option to the root domain: domain=site.com. Then all subdomains will see such cookie.\n\nFor example:\n\n// at site.com\n// make the cookie accessible on any subdomain *.site.com:\ndocument.cookie = \"user=John; domain=site.com\"\n\n// later\n\n// at forum.site.com\nalert(document.cookie); // has cookie user=John\n\nFor historical reasons, domain=.site.com (with a dot before site.com) also works the same way, allowing access to the cookie from subdomains. That’s an old notation and should be used if we need to support very old browsers.\n\nTo summarize, the domain option allows to make a cookie accessible at subdomains.\n\nexpires, max-age\n\nBy default, if a cookie doesn’t have one of these options, it disappears when the browser is closed. Such cookies are called “session cookies”\n\nTo let cookies survive a browser close, we can set either the expires or max-age option.\n\nexpires=Tue, 19 Jan 2038 03:14:07 GMT\n\nThe cookie expiration date defines the time, when the browser will automatically delete it.\n\nThe date must be exactly in this format, in the GMT timezone. We can use date.toUTCString to get it. For instance, we can set the cookie to expire in 1 day:\n\n// +1 day from now\nlet date = new Date(Date.now() + 86400e3);\ndate = date.toUTCString();\ndocument.cookie = \"user=John; expires=\" + date;\n\nIf we set expires to a date in the past, the cookie is deleted.\n\nmax-age=3600\n\nIt’s an alternative to expires and specifies the cookie’s expiration in seconds from the current moment.\n\nIf set to zero or a negative value, the cookie is deleted:\n\n// cookie will die in +1 hour from now\ndocument.cookie = \"user=John; max-age=3600\";\n\n// delete cookie (let it expire right now)\ndocument.cookie = \"user=John; max-age=0\";\nsecure\nsecure\n\nThe cookie should be transferred only over HTTPS.\n\nBy default, if we set a cookie at http://site.com, then it also appears at https://site.com and vice versa.\n\nThat is, cookies are domain-based, they do not distinguish between the protocols.\n\nWith this option, if a cookie is set by https://site.com, then it doesn’t appear when the same site is accessed by HTTP, as http://site.com. So if a cookie has sensitive content that should never be sent over unencrypted HTTP, the secure flag is the right thing.\n\n// assuming we're on https:// now\n// set the cookie to be secure (only accessible over HTTPS)\ndocument.cookie = \"user=John; secure\";\nsamesite\n\nThat’s another security attribute samesite. It’s designed to protect from so-called XSRF (cross-site request forgery) attacks.\n\nTo understand how it works and when it’s useful, let’s take a look at XSRF attacks.\n\nXSRF attack\n\nImagine, you are logged into the site bank.com. That is: you have an authentication cookie from that site. Your browser sends it to bank.com with every request, so that it recognizes you and performs all sensitive financial operations.\n\nNow, while browsing the web in another window, you accidentally come to another site evil.com. That site has JavaScript code that submits a form <form action=\"https://bank.com/pay\"> to bank.com with fields that initiate a transaction to the hacker’s account.\n\nThe browser sends cookies every time you visit the site bank.com, even if the form was submitted from evil.com. So the bank recognizes you and actually performs the payment.\n\nThat’s a so-called “Cross-Site Request Forgery” (in short, XSRF) attack.\n\nReal banks are protected from it of course. All forms generated by bank.com have a special field, a so-called “XSRF protection token”, that an evil page can’t generate or extract from a remote page. It can submit a form there, but can’t get the data back. The site bank.com checks for such token in every form it receives.\n\nSuch a protection takes time to implement though. We need to ensure that every form has the required token field, and we must also check all requests.\n\nEnter cookie samesite option\n\nThe cookie samesite option provides another way to protect from such attacks, that (in theory) should not require “xsrf protection tokens”.\n\nIt has two possible values:\n\nsamesite=strict (same as samesite without value)\n\nA cookie with samesite=strict is never sent if the user comes from outside the same site.\n\nIn other words, whether a user follows a link from their mail or submits a form from evil.com, or does any operation that originates from another domain, the cookie is not sent.\n\nIf authentication cookies have the samesite option, then a XSRF attack has no chances to succeed, because a submission from evil.com comes without cookies. So bank.com will not recognize the user and will not proceed with the payment.\n\nThe protection is quite reliable. Only operations that come from bank.com will send the samesite cookie, e.g. a form submission from another page at bank.com.\n\nAlthough, there’s a small inconvenience.\n\nWhen a user follows a legitimate link to bank.com, like from their own notes, they’ll be surprised that bank.com does not recognize them. Indeed, samesite=strict cookies are not sent in that case.\n\nWe could work around that by using two cookies: one for “general recognition”, only for the purposes of saying: “Hello, John”, and the other one for data-changing operations with samesite=strict. Then, a person coming from outside of the site will see a welcome, but payments must be initiated from the bank’s website, for the second cookie to be sent.\n\nsamesite=lax\n\nA more relaxed approach that also protects from XSRF and doesn’t break the user experience.\n\nLax mode, just like strict, forbids the browser to send cookies when coming from outside the site, but adds an exception.\n\nA samesite=lax cookie is sent if both of these conditions are true:\n\nThe HTTP method is “safe” (e.g. GET, but not POST).\n\nThe full list of safe HTTP methods is in the RFC7231 specification. Basically, these are the methods that should be used for reading, but not writing the data. They must not perform any data-changing operations. Following a link is always GET, the safe method.\n\nThe operation performs a top-level navigation (changes URL in the browser address bar).\n\nThat’s usually true, but if the navigation is performed in an <iframe>, then it’s not top-level. Also, JavaScript methods for network requests do not perform any navigation, hence they don’t fit.\n\nSo, what samesite=lax does, is to basically allow the most common “go to URL” operation to have cookies. E.g. opening a website link from notes that satisfy these conditions.\n\nBut anything more complicated, like a network request from another site or a form submission, loses cookies.\n\nIf that’s fine for you, then adding samesite=lax will probably not break the user experience and add protection.\n\nOverall, samesite is a great option.\n\nThere’s a drawback:\n\nsamesite is ignored (not supported) by very old browsers, year 2017 or so.\n\nSo if we solely rely on samesite to provide protection, then old browsers will be vulnerable.\n\nBut we surely can use samesite together with other protection measures, like xsrf tokens, to add an additional layer of defence and then, in the future, when old browsers die out, we’ll probably be able to drop xsrf tokens.\n\nhttpOnly\n\nThis option has nothing to do with JavaScript, but we have to mention it for completeness.\n\nThe web-server uses the Set-Cookie header to set a cookie. Also, it may set the httpOnly option.\n\nThis option forbids any JavaScript access to the cookie. We can’t see such a cookie or manipulate it using document.cookie.\n\nThat’s used as a precaution measure, to protect from certain attacks when a hacker injects his own JavaScript code into a page and waits for a user to visit that page. That shouldn’t be possible at all, hackers should not be able to inject their code into our site, but there may be bugs that let them do it.\n\nNormally, if such a thing happens, and a user visits a web-page with hacker’s JavaScript code, then that code executes and gains access to document.cookie with user cookies containing authentication information. That’s bad.\n\nBut if a cookie is httpOnly, then document.cookie doesn’t see it, so it is protected.\n\nAppendix: Cookie functions\n\nHere’s a small set of functions to work with cookies, more convenient than a manual modification of document.cookie.\n\nThere exist many cookie libraries for that, so these are for demo purposes. Fully working though.\n\ngetCookie(name)\n\nThe shortest way to access a cookie is to use a regular expression.\n\nThe function getCookie(name) returns the cookie with the given name:\n\n// returns the cookie with the given name,\n// or undefined if not found\nfunction getCookie(name) {\n  let matches = document.cookie.match(new RegExp(\n    \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n  ));\n  return matches ? decodeURIComponent(matches[1]) : undefined;\n}\n\nHere new RegExp is generated dynamically, to match ; name=<value>.\n\nPlease note that a cookie value is encoded, so getCookie uses a built-in decodeURIComponent function to decode it.\n\nsetCookie(name, value, options)\n\nSets the cookie’s name to the given value with path=/ by default (can be modified to add other defaults):\n\n\t\nfunction setCookie(name, value, options = {}) {\n\n  options = {\n    path: '/',\n    // add other defaults here if necessary\n    ...options\n  };\n\n  if (options.expires instanceof Date) {\n    options.expires = options.expires.toUTCString();\n  }\n\n  let updatedCookie = encodeURIComponent(name) + \"=\" + encodeURIComponent(value);\n\n  for (let optionKey in options) {\n    updatedCookie += \"; \" + optionKey;\n    let optionValue = options[optionKey];\n    if (optionValue !== true) {\n      updatedCookie += \"=\" + optionValue;\n    }\n  }\n\n  document.cookie = updatedCookie;\n}\n\n// Example of use:\nsetCookie('user', 'John', {secure: true, 'max-age': 3600});\ndeleteCookie(name)\n\nTo delete a cookie, we can call it with a negative expiration date:\n\nfunction deleteCookie(name) {\n  setCookie(name, \"\", {\n    'max-age': -1\n  })\n}\nUpdating or deleting must use same path and domain\n\nPlease note: when we update or delete a cookie, we should use exactly the same path and domain options as when we set it.\n\nTogether: cookie.js.\n\nAppendix: Third-party cookies\n\nA cookie is called “third-party” if it’s placed by a domain other than the page the user is visiting.\n\nFor instance:\n\nA page at site.com loads a banner from another site: <img src=\"https://ads.com/banner.png\">.\n\nAlong with the banner, the remote server at ads.com may set the Set-Cookie header with a cookie like id=1234. Such a cookie originates from the ads.com domain, and will only be visible at ads.com:\n\nNext time when ads.com is accessed, the remote server gets the id cookie and recognizes the user:\n\nWhat’s even more important is, when the user moves from site.com to another site other.com, which also has a banner, then ads.com gets the cookie, as it belongs to ads.com, thus recognizing the visitor and tracking him as he moves between sites:\n\nThird-party cookies are traditionally used for tracking and ads services, due to their nature. They are bound to the originating domain, so ads.com can track the same user between different sites, if they all access it.\n\nNaturally, some people don’t like being tracked, so browsers allow to disable such cookies.\n\nAlso, some modern browsers employ special policies for such cookies:\n\nSafari does not allow third-party cookies at all.\nFirefox comes with a “black list” of third-party domains where it blocks third-party cookies.\nPlease note:\n\nIf we load a script from a third-party domain, like <script src=\"https://google-analytics.com/analytics.js\">, and that script uses document.cookie to set a cookie, then such cookie is not third-party.\n\nIf a script sets a cookie, then no matter where the script came from – the cookie belongs to the domain of the current webpage.\n\nAppendix: GDPR\n\nThis topic is not related to JavaScript at all, just something to keep in mind when setting cookies.\n\nThere’s a legislation in Europe called GDPR, that enforces a set of rules for websites to respect the users’ privacy. One of these rules is to require an explicit permission for tracking cookies from the user.\n\nPlease note, that’s only about tracking/identifying/authorizing cookies.\n\nSo, if we set a cookie that just saves some information, but neither tracks nor identifies the user, then we are free to do it.\n\nBut if we are going to set a cookie with an authentication session or a tracking id, then a user must allow that.\n\nWebsites generally have two variants of following GDPR. You must have seen them both already in the web:\n\nIf a website wants to set tracking cookies only for authenticated users.\n\nTo do so, the registration form should have a checkbox like “accept the privacy policy” (that describes how cookies are used), the user must check it, and then the website is free to set auth cookies.\n\nIf a website wants to set tracking cookies for everyone.\n\nTo do so legally, a website shows a modal “splash screen” for newcomers, and requires them to agree to the cookies. Then the website can set them and let people see the content. That can be disturbing for new visitors though. No one likes to see such “must-click” modal splash screens instead of the content. But GDPR requires an explicit agreement.\n\nGDPR is not only about cookies, it’s about other privacy-related issues too, but that’s too much beyond our scope.\n\nSummary\n\ndocument.cookie provides access to cookies.\n\nWrite operations modify only cookies mentioned in it.\nName/value must be encoded.\nOne cookie may not exceed 4KB in size. The number of cookies allowed on a domain is around 20+ (varies by browser).\n\nCookie options:\n\npath=/, by default current path, makes the cookie visible only under that path.\ndomain=site.com, by default a cookie is visible on the current domain only. If the domain is set explicitly, the cookie becomes visible on subdomains.\nexpires or max-age sets the cookie expiration time. Without them the cookie dies when the browser is closed.\nsecure makes the cookie HTTPS-only.\nsamesite forbids the browser to send the cookie with requests coming from outside the site. This helps to prevent XSRF attacks.\n\nAdditionally:\n\nThird-party cookies may be forbidden by the browser, e.g. Safari does that by default.\nWhen setting a tracking cookie for EU citizens, GDPR requires to ask for permission."
  },
  {
    "title": "Server Sent Events",
    "url": "https://javascript.info/server-sent-events",
    "html": "The Server-Sent Events specification describes a built-in class EventSource, that keeps connection with the server and allows to receive events from it.\n\nSimilar to WebSocket, the connection is persistent.\n\nBut there are several important differences:\n\nWebSocket\tEventSource\nBi-directional: both client and server can exchange messages\tOne-directional: only server sends data\nBinary and text data\tOnly text\nWebSocket protocol\tRegular HTTP\n\nEventSource is a less-powerful way of communicating with the server than WebSocket.\n\nWhy should one ever use it?\n\nThe main reason: it’s simpler. In many applications, the power of WebSocket is a little bit too much.\n\nWe need to receive a stream of data from server: maybe chat messages or market prices, or whatever. That’s what EventSource is good at. Also it supports auto-reconnect, something we need to implement manually with WebSocket. Besides, it’s a plain old HTTP, not a new protocol.\n\nGetting messages\n\nTo start receiving messages, we just need to create new EventSource(url).\n\nThe browser will connect to url and keep the connection open, waiting for events.\n\nThe server should respond with status 200 and the header Content-Type: text/event-stream, then keep the connection and write messages into it in the special format, like this:\n\ndata: Message 1\n\ndata: Message 2\n\ndata: Message 3\ndata: of two lines\nA message text goes after data:, the space after the colon is optional.\nMessages are delimited with double line breaks \\n\\n.\nTo send a line break \\n, we can immediately send one more data: (3rd message above).\n\nIn practice, complex messages are usually sent JSON-encoded. Line-breaks are encoded as \\n within them, so multiline data: messages are not necessary.\n\nFor instance:\n\ndata: {\"user\":\"John\",\"message\":\"First line\\n Second line\"}\n\n…So we can assume that one data: holds exactly one message.\n\nFor each such message, the message event is generated:\n\nlet eventSource = new EventSource(\"/events/subscribe\");\n\neventSource.onmessage = function(event) {\n  console.log(\"New message\", event.data);\n  // will log 3 times for the data stream above\n};\n\n// or eventSource.addEventListener('message', ...)\nCross-origin requests\n\nEventSource supports cross-origin requests, like fetch and any other networking methods. We can use any URL:\n\nlet source = new EventSource(\"https://another-site.com/events\");\n\nThe remote server will get the Origin header and must respond with Access-Control-Allow-Origin to proceed.\n\nTo pass credentials, we should set the additional option withCredentials, like this:\n\nlet source = new EventSource(\"https://another-site.com/events\", {\n  withCredentials: true\n});\n\nPlease see the chapter Fetch: Cross-Origin Requests for more details about cross-origin headers.\n\nReconnection\n\nUpon creation, new EventSource connects to the server, and if the connection is broken – reconnects.\n\nThat’s very convenient, as we don’t have to care about it.\n\nThere’s a small delay between reconnections, a few seconds by default.\n\nThe server can set the recommended delay using retry: in response (in milliseconds):\n\nretry: 15000\ndata: Hello, I set the reconnection delay to 15 seconds\n\nThe retry: may come both together with some data, or as a standalone message.\n\nThe browser should wait that many milliseconds before reconnecting. Or longer, e.g. if the browser knows (from OS) that there’s no network connection at the moment, it may wait until the connection appears, and then retry.\n\nIf the server wants the browser to stop reconnecting, it should respond with HTTP status 204.\nIf the browser wants to close the connection, it should call eventSource.close():\nlet eventSource = new EventSource(...);\n\neventSource.close();\n\nAlso, there will be no reconnection if the response has an incorrect Content-Type or its HTTP status differs from 301, 307, 200 and 204. In such cases the \"error\" event will be emitted, and the browser won’t reconnect.\n\nPlease note:\n\nWhen a connection is finally closed, there’s no way to “reopen” it. If we’d like to connect again, just create a new EventSource.\n\nMessage id\n\nWhen a connection breaks due to network problems, either side can’t be sure which messages were received, and which weren’t.\n\nTo correctly resume the connection, each message should have an id field, like this:\n\ndata: Message 1\nid: 1\n\ndata: Message 2\nid: 2\n\ndata: Message 3\ndata: of two lines\nid: 3\n\nWhen a message with id: is received, the browser:\n\nSets the property eventSource.lastEventId to its value.\nUpon reconnection sends the header Last-Event-ID with that id, so that the server may re-send following messages.\nPut id: after data:\n\nPlease note: the id is appended below message data by the server, to ensure that lastEventId is updated after the message is received.\n\nConnection status: readyState\n\nThe EventSource object has readyState property, that has one of three values:\n\nEventSource.CONNECTING = 0; // connecting or reconnecting\nEventSource.OPEN = 1;       // connected\nEventSource.CLOSED = 2;     // connection closed\n\nWhen an object is created, or the connection is down, it’s always EventSource.CONNECTING (equals 0).\n\nWe can query this property to know the state of EventSource.\n\nEvent types\n\nBy default EventSource object generates three events:\n\nmessage – a message received, available as event.data.\nopen – the connection is open.\nerror – the connection could not be established, e.g. the server returned HTTP 500 status.\n\nThe server may specify another type of event with event: ... at the event start.\n\nFor example:\n\nevent: join\ndata: Bob\n\ndata: Hello\n\nevent: leave\ndata: Bob\n\nTo handle custom events, we must use addEventListener, not onmessage:\n\neventSource.addEventListener('join', event => {\n  alert(`Joined ${event.data}`);\n});\n\neventSource.addEventListener('message', event => {\n  alert(`Said: ${event.data}`);\n});\n\neventSource.addEventListener('leave', event => {\n  alert(`Left ${event.data}`);\n});\nFull example\n\nHere’s the server that sends messages with 1, 2, 3, then bye and breaks the connection.\n\nThen the browser automatically reconnects.\n\nResultserver.jsindex.html\n\t\nSummary\n\nEventSource object automatically establishes a persistent connection and allows the server to send messages over it.\n\nIt offers:\n\nAutomatic reconnect, with tunable retry timeout.\nMessage ids to resume events, the last received identifier is sent in Last-Event-ID header upon reconnection.\nThe current state is in the readyState property.\n\nThat makes EventSource a viable alternative to WebSocket, as the latter is more low-level and lacks such built-in features (though they can be implemented).\n\nIn many real-life applications, the power of EventSource is just enough.\n\nSupported in all modern browsers (not IE).\n\nThe syntax is:\n\nlet source = new EventSource(url, [credentials]);\n\nThe second argument has only one possible option: { withCredentials: true }, it allows sending cross-origin credentials.\n\nOverall cross-origin security is same as for fetch and other network methods.\n\nProperties of an EventSource object\nreadyState\nThe current connection state: either EventSource.CONNECTING (=0), EventSource.OPEN (=1) or EventSource.CLOSED (=2).\nlastEventId\nThe last received id. Upon reconnection the browser sends it in the header Last-Event-ID.\nMethods\nclose()\nCloses the connection.\nEvents\nmessage\nMessage received, the data is in event.data.\nopen\nThe connection is established.\nerror\nIn case of an error, including both lost connection (will auto-reconnect) and fatal errors. We can check readyState to see if the reconnection is being attempted.\n\nThe server may set a custom event name in event:. Such events should be handled using addEventListener, not on<event>.\n\nServer response format\n\nThe server sends messages, delimited by \\n\\n.\n\nA message may have following fields:\n\ndata: – message body, a sequence of multiple data is interpreted as a single message, with \\n between the parts.\nid: – renews lastEventId, sent in Last-Event-ID on reconnect.\nretry: – recommends a retry delay for reconnections in ms. There’s no way to set it from JavaScript.\nevent: – event name, must precede data:.\n\nA message may include one or more fields in any order, but id: usually goes the last."
  },
  {
    "title": "WebSocket",
    "url": "https://javascript.info/websocket",
    "html": "The WebSocket protocol, described in the specification RFC 6455, provides a way to exchange data between browser and server via a persistent connection. The data can be passed in both directions as “packets”, without breaking the connection and the need of additional HTTP-requests.\n\nWebSocket is especially great for services that require continuous data exchange, e.g. online games, real-time trading systems and so on.\n\nA simple example\n\nTo open a websocket connection, we need to create new WebSocket using the special protocol ws in the url:\n\nlet socket = new WebSocket(\"ws://javascript.info\");\n\nThere’s also encrypted wss:// protocol. It’s like HTTPS for websockets.\n\nAlways prefer wss://\n\nThe wss:// protocol is not only encrypted, but also more reliable.\n\nThat’s because ws:// data is not encrypted, visible for any intermediary. Old proxy servers do not know about WebSocket, they may see “strange” headers and abort the connection.\n\nOn the other hand, wss:// is WebSocket over TLS, (same as HTTPS is HTTP over TLS), the transport security layer encrypts the data at the sender and decrypts it at the receiver. So data packets are passed encrypted through proxies. They can’t see what’s inside and let them through.\n\nOnce the socket is created, we should listen to events on it. There are totally 4 events:\n\nopen – connection established,\nmessage – data received,\nerror – websocket error,\nclose – connection closed.\n\n…And if we’d like to send something, then socket.send(data) will do that.\n\nHere’s an example:\n\n\t\nlet socket = new WebSocket(\"wss://javascript.info/article/websocket/demo/hello\");\n\nsocket.onopen = function(e) {\n  alert(\"[open] Connection established\");\n  alert(\"Sending to server\");\n  socket.send(\"My name is John\");\n};\n\nsocket.onmessage = function(event) {\n  alert(`[message] Data received from server: ${event.data}`);\n};\n\nsocket.onclose = function(event) {\n  if (event.wasClean) {\n    alert(`[close] Connection closed cleanly, code=${event.code} reason=${event.reason}`);\n  } else {\n    // e.g. server process killed or network down\n    // event.code is usually 1006 in this case\n    alert('[close] Connection died');\n  }\n};\n\nsocket.onerror = function(error) {\n  alert(`[error]`);\n};\n\nFor demo purposes, there’s a small server server.js written in Node.js, for the example above, running. It responds with “Hello from server, John”, then waits 5 seconds and closes the connection.\n\nSo you’ll see events open → message → close.\n\nThat’s actually it, we can talk WebSocket already. Quite simple, isn’t it?\n\nNow let’s talk more in-depth.\n\nOpening a websocket\n\nWhen new WebSocket(url) is created, it starts connecting immediately.\n\nDuring the connection, the browser (using headers) asks the server: “Do you support Websocket?” And if the server replies “yes”, then the talk continues in WebSocket protocol, which is not HTTP at all.\n\nHere’s an example of browser headers for a request made by new WebSocket(\"wss://javascript.info/chat\").\n\nGET /chat\nHost: javascript.info\nOrigin: https://javascript.info\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\nOrigin – the origin of the client page, e.g. https://javascript.info. WebSocket objects are cross-origin by nature. There are no special headers or other limitations. Old servers are unable to handle WebSocket anyway, so there are no compatibility issues. But the Origin header is important, as it allows the server to decide whether or not to talk WebSocket with this website.\nConnection: Upgrade – signals that the client would like to change the protocol.\nUpgrade: websocket – the requested protocol is “websocket”.\nSec-WebSocket-Key – a random browser-generated key, used to ensure that the server supports WebSocket protocol. It’s random to prevent proxies from caching any following communication.\nSec-WebSocket-Version – WebSocket protocol version, 13 is the current one.\nWebSocket handshake can’t be emulated\n\nWe can’t use XMLHttpRequest or fetch to make this kind of HTTP-request, because JavaScript is not allowed to set these headers.\n\nIf the server agrees to switch to WebSocket, it should send code 101 response:\n\n101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\n\nHere Sec-WebSocket-Accept is Sec-WebSocket-Key, recoded using a special algorithm. Upon seeing it, the browser understands that the server really does support the WebSocket protocol.\n\nAfterwards, the data is transferred using the WebSocket protocol, we’ll see its structure (“frames”) soon. And that’s not HTTP at all.\n\nExtensions and subprotocols\n\nThere may be additional headers Sec-WebSocket-Extensions and Sec-WebSocket-Protocol that describe extensions and subprotocols.\n\nFor instance:\n\nSec-WebSocket-Extensions: deflate-frame means that the browser supports data compression. An extension is something related to transferring the data, functionality that extends the WebSocket protocol. The header Sec-WebSocket-Extensions is sent automatically by the browser, with the list of all extensions it supports.\n\nSec-WebSocket-Protocol: soap, wamp means that we’d like to transfer not just any data, but the data in SOAP or WAMP (“The WebSocket Application Messaging Protocol”) protocols. WebSocket subprotocols are registered in the IANA catalogue. So, this header describes the data formats that we’re going to use.\n\nThis optional header is set using the second parameter of new WebSocket. That’s the array of subprotocols, e.g. if we’d like to use SOAP or WAMP:\n\nlet socket = new WebSocket(\"wss://javascript.info/chat\", [\"soap\", \"wamp\"]);\n\nThe server should respond with a list of protocols and extensions that it agrees to use.\n\nFor example, the request:\n\nGET /chat\nHost: javascript.info\nUpgrade: websocket\nConnection: Upgrade\nOrigin: https://javascript.info\nSec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==\nSec-WebSocket-Version: 13\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap, wamp\n\nResponse:\n\n101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=\nSec-WebSocket-Extensions: deflate-frame\nSec-WebSocket-Protocol: soap\n\nHere the server responds that it supports the extension “deflate-frame”, and only SOAP of the requested subprotocols.\n\nData transfer\n\nWebSocket communication consists of “frames” – data fragments, that can be sent from either side, and can be of several kinds:\n\n“text frames” – contain text data that parties send to each other.\n“binary data frames” – contain binary data that parties send to each other.\n“ping/pong frames” are used to check the connection, sent from the server, the browser responds to these automatically.\nthere’s also “connection close frame” and a few other service frames.\n\nIn the browser, we directly work only with text or binary frames.\n\nWebSocket .send() method can send either text or binary data.\n\nA call socket.send(body) allows body in string or a binary format, including Blob, ArrayBuffer, etc. No settings are required: just send it out in any format.\n\nWhen we receive the data, text always comes as string. And for binary data, we can choose between Blob and ArrayBuffer formats.\n\nThat’s set by socket.binaryType property, it’s \"blob\" by default, so binary data comes as Blob objects.\n\nBlob is a high-level binary object, it directly integrates with <a>, <img> and other tags, so that’s a sane default. But for binary processing, to access individual data bytes, we can change it to \"arraybuffer\":\n\nsocket.binaryType = \"arraybuffer\";\nsocket.onmessage = (event) => {\n  // event.data is either a string (if text) or arraybuffer (if binary)\n};\nRate limiting\n\nImagine, our app is generating a lot of data to send. But the user has a slow network connection, maybe on a mobile internet, outside of a city.\n\nWe can call socket.send(data) again and again. But the data will be buffered (stored) in memory and sent out only as fast as network speed allows.\n\nThe socket.bufferedAmount property stores how many bytes remain buffered at this moment, waiting to be sent over the network.\n\nWe can examine it to see whether the socket is actually available for transmission.\n\n// every 100ms examine the socket and send more data\n// only if all the existing data was sent out\nsetInterval(() => {\n  if (socket.bufferedAmount == 0) {\n    socket.send(moreData());\n  }\n}, 100);\nConnection close\n\nNormally, when a party wants to close the connection (both browser and server have equal rights), they send a “connection close frame” with a numeric code and a textual reason.\n\nThe method for that is:\n\nsocket.close([code], [reason]);\ncode is a special WebSocket closing code (optional)\nreason is a string that describes the reason of closing (optional)\n\nThen the other party in the close event handler gets the code and the reason, e.g.:\n\n// closing party:\nsocket.close(1000, \"Work complete\");\n\n// the other party\nsocket.onclose = event => {\n  // event.code === 1000\n  // event.reason === \"Work complete\"\n  // event.wasClean === true (clean close)\n};\n\nMost common code values:\n\n1000 – the default, normal closure (used if no code supplied),\n1006 – no way to set such code manually, indicates that the connection was lost (no close frame).\n\nThere are other codes like:\n\n1001 – the party is going away, e.g. server is shutting down, or a browser leaves the page,\n1009 – the message is too big to process,\n1011 – unexpected error on server,\n…and so on.\n\nThe full list can be found in RFC6455, §7.4.1.\n\nWebSocket codes are somewhat like HTTP codes, but different. In particular, codes lower than 1000 are reserved, there’ll be an error if we try to set such a code.\n\n// in case connection is broken\nsocket.onclose = event => {\n  // event.code === 1006\n  // event.reason === \"\"\n  // event.wasClean === false (no closing frame)\n};\nConnection state\n\nTo get connection state, additionally there’s socket.readyState property with values:\n\n0 – “CONNECTING”: the connection has not yet been established,\n1 – “OPEN”: communicating,\n2 – “CLOSING”: the connection is closing,\n3 – “CLOSED”: the connection is closed.\nChat example\n\nLet’s review a chat example using browser WebSocket API and Node.js WebSocket module https://github.com/websockets/ws. We’ll pay the main attention to the client side, but the server is also simple.\n\nHTML: we need a <form> to send messages and a <div> for incoming messages:\n\n<!-- message form -->\n<form name=\"publish\">\n  <input type=\"text\" name=\"message\">\n  <input type=\"submit\" value=\"Send\">\n</form>\n\n<!-- div with messages -->\n<div id=\"messages\"></div>\n\nFrom JavaScript we want three things:\n\nOpen the connection.\nOn form submission – socket.send(message) for the message.\nOn incoming message – append it to div#messages.\n\nHere’s the code:\n\nlet socket = new WebSocket(\"wss://javascript.info/article/websocket/chat/ws\");\n\n// send message from the form\ndocument.forms.publish.onsubmit = function() {\n  let outgoingMessage = this.message.value;\n\n  socket.send(outgoingMessage);\n  return false;\n};\n\n// message received - show the message in div#messages\nsocket.onmessage = function(event) {\n  let message = event.data;\n\n  let messageElem = document.createElement('div');\n  messageElem.textContent = message;\n  document.getElementById('messages').prepend(messageElem);\n}\n\nServer-side code is a little bit beyond our scope. Here we’ll use Node.js, but you don’t have to. Other platforms also have their means to work with WebSocket.\n\nThe server-side algorithm will be:\n\nCreate clients = new Set() – a set of sockets.\nFor each accepted websocket, add it to the set clients.add(socket) and set message event listener to get its messages.\nWhen a message is received: iterate over clients and send it to everyone.\nWhen a connection is closed: clients.delete(socket).\nconst ws = new require('ws');\nconst wss = new ws.Server({noServer: true});\n\nconst clients = new Set();\n\nhttp.createServer((req, res) => {\n  // here we only handle websocket connections\n  // in real project we'd have some other code here to handle non-websocket requests\n  wss.handleUpgrade(req, req.socket, Buffer.alloc(0), onSocketConnect);\n});\n\nfunction onSocketConnect(ws) {\n  clients.add(ws);\n\n  ws.on('message', function(message) {\n    message = message.slice(0, 50); // max message length will be 50\n\n    for(let client of clients) {\n      client.send(message);\n    }\n  });\n\n  ws.on('close', function() {\n    clients.delete(ws);\n  });\n}\n\nHere’s the working example:\n\nYou can also download it (upper-right button in the iframe) and run it locally. Just don’t forget to install Node.js and npm install ws before running.\n\nSummary\n\nWebSocket is a modern way to have persistent browser-server connections.\n\nWebSockets don’t have cross-origin limitations.\nThey are well-supported in browsers.\nCan send/receive strings and binary data.\n\nThe API is simple.\n\nMethods:\n\nsocket.send(data),\nsocket.close([code], [reason]).\n\nEvents:\n\nopen,\nmessage,\nerror,\nclose.\n\nWebSocket by itself does not include reconnection, authentication and many other high-level mechanisms. So there are client/server libraries for that, and it’s also possible to implement these capabilities manually.\n\nSometimes, to integrate WebSocket into existing projects, people run a WebSocket server in parallel with the main HTTP-server, and they share a single database. Requests to WebSocket use wss://ws.site.com, a subdomain that leads to the WebSocket server, while https://site.com goes to the main HTTP-server.\n\nSurely, other ways of integration are also possible."
  },
  {
    "title": "Storing data in the browser",
    "url": "https://javascript.info/data-storage",
    "html": "Cookies, document.cookie\nLocalStorage, sessionStorage\nIndexedDB"
  },
  {
    "title": "Long polling",
    "url": "https://javascript.info/long-polling",
    "html": "Long polling is the simplest way of having persistent connection with server, that doesn’t use any specific protocol like WebSocket or Server Sent Events.\n\nBeing very easy to implement, it’s also good enough in a lot of cases.\n\nRegular Polling\n\nThe simplest way to get new information from the server is periodic polling. That is, regular requests to the server: “Hello, I’m here, do you have any information for me?”. For example, once every 10 seconds.\n\nIn response, the server first takes a notice to itself that the client is online, and second – sends a packet of messages it got till that moment.\n\nThat works, but there are downsides:\n\nMessages are passed with a delay up to 10 seconds (between requests).\nEven if there are no messages, the server is bombed with requests every 10 seconds, even if the user switched somewhere else or is asleep. That’s quite a load to handle, speaking performance-wise.\n\nSo, if we’re talking about a very small service, the approach may be viable, but generally, it needs an improvement.\n\nLong polling\n\nSo-called “long polling” is a much better way to poll the server.\n\nIt’s also very easy to implement, and delivers messages without delays.\n\nThe flow:\n\nA request is sent to the server.\nThe server doesn’t close the connection until it has a message to send.\nWhen a message appears – the server responds to the request with it.\nThe browser makes a new request immediately.\n\nThis situation, where the browser has sent a request and keeps a pending connection with the server, is standard for this method. Only when a message is delivered, the connection is closed and reestablished.\n\nIf the connection is lost, because of, say, a network error, the browser immediately sends a new request.\n\nA sketch of client-side subscribe function that makes long requests:\n\nasync function subscribe() {\n  let response = await fetch(\"/subscribe\");\n\n  if (response.status == 502) {\n    // Status 502 is a connection timeout error,\n    // may happen when the connection was pending for too long,\n    // and the remote server or a proxy closed it\n    // let's reconnect\n    await subscribe();\n  } else if (response.status != 200) {\n    // An error - let's show it\n    showMessage(response.statusText);\n    // Reconnect in one second\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    await subscribe();\n  } else {\n    // Get and show the message\n    let message = await response.text();\n    showMessage(message);\n    // Call subscribe() again to get the next message\n    await subscribe();\n  }\n}\n\nsubscribe();\n\nAs you can see, subscribe function makes a fetch, then waits for the response, handles it and calls itself again.\n\nServer should be ok with many pending connections\n\nThe server architecture must be able to work with many pending connections.\n\nCertain server architectures run one process per connection, resulting in there being as many processes as there are connections, while each process consumes quite a bit of memory. So, too many connections will just consume it all.\n\nThat’s often the case for backends written in languages like PHP and Ruby.\n\nServers written using Node.js usually don’t have such problems.\n\nThat said, it isn’t a programming language issue. Most modern languages, including PHP and Ruby allow to implement a proper backend. Just please make sure that your server architecture works fine with many simultaneous connections.\n\nDemo: a chat\n\nHere’s a demo chat, you can also download it and run locally (if you’re familiar with Node.js and can install modules):\n\nResultbrowser.jsserver.jsindex.html\n\t\n\nBrowser code is in browser.js.\n\nArea of usage\n\nLong polling works great in situations when messages are rare.\n\nIf messages come very often, then the chart of requesting-receiving messages, painted above, becomes saw-like.\n\nEvery message is a separate request, supplied with headers, authentication overhead, and so on.\n\nSo, in this case, another method is preferred, such as Websocket or Server Sent Events."
  },
  {
    "title": "XMLHttpRequest",
    "url": "https://javascript.info/xmlhttprequest",
    "html": "XMLHttpRequest is a built-in browser object that allows to make HTTP requests in JavaScript.\n\nDespite having the word “XML” in its name, it can operate on any data, not only in XML format. We can upload/download files, track progress and much more.\n\nRight now, there’s another, more modern method fetch, that somewhat deprecates XMLHttpRequest.\n\nIn modern web-development XMLHttpRequest is used for three reasons:\n\nHistorical reasons: we need to support existing scripts with XMLHttpRequest.\nWe need to support old browsers, and don’t want polyfills (e.g. to keep scripts tiny).\nWe need something that fetch can’t do yet, e.g. to track upload progress.\n\nDoes that sound familiar? If yes, then all right, go on with XMLHttpRequest. Otherwise, please head on to Fetch.\n\nThe basics\n\nXMLHttpRequest has two modes of operation: synchronous and asynchronous.\n\nLet’s see the asynchronous first, as it’s used in the majority of cases.\n\nTo do the request, we need 3 steps:\n\nCreate XMLHttpRequest:\n\nlet xhr = new XMLHttpRequest();\n\nThe constructor has no arguments.\n\nInitialize it, usually right after new XMLHttpRequest:\n\nxhr.open(method, URL, [async, user, password])\n\nThis method specifies the main parameters of the request:\n\nmethod – HTTP-method. Usually \"GET\" or \"POST\".\nURL – the URL to request, a string, can be URL object.\nasync – if explicitly set to false, then the request is synchronous, we’ll cover that a bit later.\nuser, password – login and password for basic HTTP auth (if required).\n\nPlease note that open call, contrary to its name, does not open the connection. It only configures the request, but the network activity only starts with the call of send.\n\nSend it out.\n\nxhr.send([body])\n\nThis method opens the connection and sends the request to server. The optional body parameter contains the request body.\n\nSome request methods like GET do not have a body. And some of them like POST use body to send the data to the server. We’ll see examples of that later.\n\nListen to xhr events for response.\n\nThese three events are the most widely used:\n\nload – when the request is complete (even if HTTP status is like 400 or 500), and the response is fully downloaded.\nerror – when the request couldn’t be made, e.g. network down or invalid URL.\nprogress – triggers periodically while the response is being downloaded, reports how much has been downloaded.\nxhr.onload = function() {\n  alert(`Loaded: ${xhr.status} ${xhr.response}`);\n};\n\nxhr.onerror = function() { // only triggers if the request couldn't be made at all\n  alert(`Network Error`);\n};\n\nxhr.onprogress = function(event) { // triggers periodically\n  // event.loaded - how many bytes downloaded\n  // event.lengthComputable = true if the server sent Content-Length header\n  // event.total - total number of bytes (if lengthComputable)\n  alert(`Received ${event.loaded} of ${event.total}`);\n};\n\nHere’s a full example. The code below loads the URL at /article/xmlhttprequest/example/load from the server and prints the progress:\n\n\t\n// 1. Create a new XMLHttpRequest object\nlet xhr = new XMLHttpRequest();\n\n// 2. Configure it: GET-request for the URL /article/.../load\nxhr.open('GET', '/article/xmlhttprequest/example/load');\n\n// 3. Send the request over the network\nxhr.send();\n\n// 4. This will be called after the response is received\nxhr.onload = function() {\n  if (xhr.status != 200) { // analyze HTTP status of the response\n    alert(`Error ${xhr.status}: ${xhr.statusText}`); // e.g. 404: Not Found\n  } else { // show the result\n    alert(`Done, got ${xhr.response.length} bytes`); // response is the server response\n  }\n};\n\nxhr.onprogress = function(event) {\n  if (event.lengthComputable) {\n    alert(`Received ${event.loaded} of ${event.total} bytes`);\n  } else {\n    alert(`Received ${event.loaded} bytes`); // no Content-Length\n  }\n\n};\n\nxhr.onerror = function() {\n  alert(\"Request failed\");\n};\n\nOnce the server has responded, we can receive the result in the following xhr properties:\n\nstatus\nHTTP status code (a number): 200, 404, 403 and so on, can be 0 in case of a non-HTTP failure.\nstatusText\nHTTP status message (a string): usually OK for 200, Not Found for 404, Forbidden for 403 and so on.\nresponse (old scripts may use responseText)\nThe server response body.\n\nWe can also specify a timeout using the corresponding property:\n\nxhr.timeout = 10000; // timeout in ms, 10 seconds\n\nIf the request does not succeed within the given time, it gets canceled and timeout event triggers.\n\nURL search parameters\n\nTo add parameters to URL, like ?name=value, and ensure the proper encoding, we can use URL object:\n\nlet url = new URL('https://google.com/search');\nurl.searchParams.set('q', 'test me!');\n\n// the parameter 'q' is encoded\nxhr.open('GET', url); // https://google.com/search?q=test+me%21\nResponse Type\n\nWe can use xhr.responseType property to set the response format:\n\n\"\" (default) – get as string,\n\"text\" – get as string,\n\"arraybuffer\" – get as ArrayBuffer (for binary data, see chapter ArrayBuffer, binary arrays),\n\"blob\" – get as Blob (for binary data, see chapter Blob),\n\"document\" – get as XML document (can use XPath and other XML methods) or HTML document (based on the MIME type of the received data),\n\"json\" – get as JSON (parsed automatically).\n\nFor example, let’s get the response as JSON:\n\n\t\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/article/xmlhttprequest/example/json');\n\nxhr.responseType = 'json';\n\nxhr.send();\n\n// the response is {\"message\": \"Hello, world!\"}\nxhr.onload = function() {\n  let responseObj = xhr.response;\n  alert(responseObj.message); // Hello, world!\n};\nPlease note:\n\nIn the old scripts you may also find xhr.responseText and even xhr.responseXML properties.\n\nThey exist for historical reasons, to get either a string or XML document. Nowadays, we should set the format in xhr.responseType and get xhr.response as demonstrated above.\n\nReady states\n\nXMLHttpRequest changes between states as it progresses. The current state is accessible as xhr.readyState.\n\nAll states, as in the specification:\n\nUNSENT = 0; // initial state\nOPENED = 1; // open called\nHEADERS_RECEIVED = 2; // response headers received\nLOADING = 3; // response is loading (a data packet is received)\nDONE = 4; // request complete\n\nAn XMLHttpRequest object travels them in the order 0 → 1 → 2 → 3 → … → 3 → 4. State 3 repeats every time a data packet is received over the network.\n\nWe can track them using readystatechange event:\n\nxhr.onreadystatechange = function() {\n  if (xhr.readyState == 3) {\n    // loading\n  }\n  if (xhr.readyState == 4) {\n    // request finished\n  }\n};\n\nYou can find readystatechange listeners in really old code, it’s there for historical reasons, as there was a time when there were no load and other events. Nowadays, load/error/progress handlers deprecate it.\n\nAborting request\n\nWe can terminate the request at any time. The call to xhr.abort() does that:\n\nxhr.abort(); // terminate the request\n\nThat triggers abort event, and xhr.status becomes 0.\n\nSynchronous requests\n\nIf in the open method the third parameter async is set to false, the request is made synchronously.\n\nIn other words, JavaScript execution pauses at send() and resumes when the response is received. Somewhat like alert or prompt commands.\n\nHere’s the rewritten example, the 3rd parameter of open is false:\n\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/article/xmlhttprequest/hello.txt', false);\n\ntry {\n  xhr.send();\n  if (xhr.status != 200) {\n    alert(`Error ${xhr.status}: ${xhr.statusText}`);\n  } else {\n    alert(xhr.response);\n  }\n} catch(err) { // instead of onerror\n  alert(\"Request failed\");\n}\n\nIt might look good, but synchronous calls are used rarely, because they block in-page JavaScript till the loading is complete. In some browsers it becomes impossible to scroll. If a synchronous call takes too much time, the browser may suggest to close the “hanging” webpage.\n\nMany advanced capabilities of XMLHttpRequest, like requesting from another domain or specifying a timeout, are unavailable for synchronous requests. Also, as you can see, no progress indication.\n\nBecause of all that, synchronous requests are used very sparingly, almost never. We won’t talk about them any more.\n\nHTTP-headers\n\nXMLHttpRequest allows both to send custom headers and read headers from the response.\n\nThere are 3 methods for HTTP-headers:\n\nsetRequestHeader(name, value)\n\nSets the request header with the given name and value.\n\nFor instance:\n\nxhr.setRequestHeader('Content-Type', 'application/json');\nHeaders limitations\n\nSeveral headers are managed exclusively by the browser, e.g. Referer and Host. The full list is in the specification.\n\nXMLHttpRequest is not allowed to change them, for the sake of user safety and correctness of the request.\n\nCan’t remove a header\n\nAnother peculiarity of XMLHttpRequest is that one can’t undo setRequestHeader.\n\nOnce the header is set, it’s set. Additional calls add information to the header, don’t overwrite it.\n\nFor instance:\n\nxhr.setRequestHeader('X-Auth', '123');\nxhr.setRequestHeader('X-Auth', '456');\n\n// the header will be:\n// X-Auth: 123, 456\ngetResponseHeader(name)\n\nGets the response header with the given name (except Set-Cookie and Set-Cookie2).\n\nFor instance:\n\nxhr.getResponseHeader('Content-Type')\ngetAllResponseHeaders()\n\nReturns all response headers, except Set-Cookie and Set-Cookie2.\n\nHeaders are returned as a single line, e.g.:\n\nCache-Control: max-age=31536000\nContent-Length: 4260\nContent-Type: image/png\nDate: Sat, 08 Sep 2012 16:53:16 GMT\n\nThe line break between headers is always \"\\r\\n\" (doesn’t depend on OS), so we can easily split it into individual headers. The separator between the name and the value is always a colon followed by a space \": \". That’s fixed in the specification.\n\nSo, if we want to get an object with name/value pairs, we need to throw in a bit JS.\n\nLike this (assuming that if two headers have the same name, then the latter one overwrites the former one):\n\nlet headers = xhr\n  .getAllResponseHeaders()\n  .split('\\r\\n')\n  .reduce((result, current) => {\n    let [name, value] = current.split(': ');\n    result[name] = value;\n    return result;\n  }, {});\n\n// headers['Content-Type'] = 'image/png'\nPOST, FormData\n\nTo make a POST request, we can use the built-in FormData object.\n\nThe syntax:\n\nlet formData = new FormData([form]); // creates an object, optionally fill from <form>\nformData.append(name, value); // appends a field\n\nWe create it, optionally fill from a form, append more fields if needed, and then:\n\nxhr.open('POST', ...) – use POST method.\nxhr.send(formData) to submit the form to the server.\n\nFor instance:\n\n\t\n<form name=\"person\">\n  <input name=\"name\" value=\"John\">\n  <input name=\"surname\" value=\"Smith\">\n</form>\n\n<script>\n  // pre-fill FormData from the form\n  let formData = new FormData(document.forms.person);\n\n  // add one more field\n  formData.append(\"middle\", \"Lee\");\n\n  // send it out\n  let xhr = new XMLHttpRequest();\n  xhr.open(\"POST\", \"/article/xmlhttprequest/post/user\");\n  xhr.send(formData);\n\n  xhr.onload = () => alert(xhr.response);\n</script>\n\nThe form is sent with multipart/form-data encoding.\n\nOr, if we like JSON more, then JSON.stringify and send as a string.\n\nJust don’t forget to set the header Content-Type: application/json, many server-side frameworks automatically decode JSON with it:\n\nlet xhr = new XMLHttpRequest();\n\nlet json = JSON.stringify({\n  name: \"John\",\n  surname: \"Smith\"\n});\n\nxhr.open(\"POST\", '/submit')\nxhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\n\nxhr.send(json);\n\nThe .send(body) method is pretty omnivore. It can send almost any body, including Blob and BufferSource objects.\n\nUpload progress\n\nThe progress event triggers only on the downloading stage.\n\nThat is: if we POST something, XMLHttpRequest first uploads our data (the request body), then downloads the response.\n\nIf we’re uploading something big, then we’re surely more interested in tracking the upload progress. But xhr.onprogress doesn’t help here.\n\nThere’s another object, without methods, exclusively to track upload events: xhr.upload.\n\nIt generates events, similar to xhr, but xhr.upload triggers them solely on uploading:\n\nloadstart – upload started.\nprogress – triggers periodically during the upload.\nabort – upload aborted.\nerror – non-HTTP error.\nload – upload finished successfully.\ntimeout – upload timed out (if timeout property is set).\nloadend – upload finished with either success or error.\n\nExample of handlers:\n\nxhr.upload.onprogress = function(event) {\n  alert(`Uploaded ${event.loaded} of ${event.total} bytes`);\n};\n\nxhr.upload.onload = function() {\n  alert(`Upload finished successfully.`);\n};\n\nxhr.upload.onerror = function() {\n  alert(`Error during the upload: ${xhr.status}`);\n};\n\nHere’s a real-life example: file upload with progress indication:\n\n\t\n<input type=\"file\" onchange=\"upload(this.files[0])\">\n\n<script>\nfunction upload(file) {\n  let xhr = new XMLHttpRequest();\n\n  // track upload progress\n  xhr.upload.onprogress = function(event) {\n    console.log(`Uploaded ${event.loaded} of ${event.total}`);\n  };\n\n  // track completion: both successful or not\n  xhr.onloadend = function() {\n    if (xhr.status == 200) {\n      console.log(\"success\");\n    } else {\n      console.log(\"error \" + this.status);\n    }\n  };\n\n  xhr.open(\"POST\", \"/article/xmlhttprequest/post/upload\");\n  xhr.send(file);\n}\n</script>\nCross-origin requests\n\nXMLHttpRequest can make cross-origin requests, using the same CORS policy as fetch.\n\nJust like fetch, it doesn’t send cookies and HTTP-authorization to another origin by default. To enable them, set xhr.withCredentials to true:\n\nlet xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\nxhr.open('POST', 'http://anywhere.com/request');\n...\n\nSee the chapter Fetch: Cross-Origin Requests for details about cross-origin headers.\n\nSummary\n\nTypical code of the GET-request with XMLHttpRequest:\n\nlet xhr = new XMLHttpRequest();\n\nxhr.open('GET', '/my/url');\n\nxhr.send();\n\nxhr.onload = function() {\n  if (xhr.status != 200) { // HTTP error?\n    // handle error\n    alert( 'Error: ' + xhr.status);\n    return;\n  }\n\n  // get the response from xhr.response\n};\n\nxhr.onprogress = function(event) {\n  // report progress\n  alert(`Loaded ${event.loaded} of ${event.total}`);\n};\n\nxhr.onerror = function() {\n  // handle non-HTTP error (e.g. network down)\n};\n\nThere are actually more events, the modern specification lists them (in the lifecycle order):\n\nloadstart – the request has started.\nprogress – a data packet of the response has arrived, the whole response body at the moment is in response.\nabort – the request was canceled by the call xhr.abort().\nerror – connection error has occurred, e.g. wrong domain name. Doesn’t happen for HTTP-errors like 404.\nload – the request has finished successfully.\ntimeout – the request was canceled due to timeout (only happens if it was set).\nloadend – triggers after load, error, timeout or abort.\n\nThe error, abort, timeout, and load events are mutually exclusive. Only one of them may happen.\n\nThe most used events are load completion (load), load failure (error), or we can use a single loadend handler and check the properties of the request object xhr to see what happened.\n\nWe’ve already seen another event: readystatechange. Historically, it appeared long ago, before the specification settled. Nowadays, there’s no need to use it, we can replace it with newer events, but it can often be found in older scripts.\n\nIf we need to track uploading specifically, then we should listen to same events on xhr.upload object."
  },
  {
    "title": "Resumable file upload",
    "url": "https://javascript.info/resume-upload",
    "html": "With fetch method it’s fairly easy to upload a file.\n\nHow to resume the upload after lost connection? There’s no built-in option for that, but we have the pieces to implement it.\n\nResumable uploads should come with upload progress indication, as we expect big files (if we may need to resume). So, as fetch doesn’t allow to track upload progress, we’ll use XMLHttpRequest.\n\nNot-so-useful progress event\n\nTo resume upload, we need to know how much was uploaded till the connection was lost.\n\nThere’s xhr.upload.onprogress to track upload progress.\n\nUnfortunately, it won’t help us to resume the upload here, as it triggers when the data is sent, but was it received by the server? The browser doesn’t know.\n\nMaybe it was buffered by a local network proxy, or maybe the remote server process just died and couldn’t process them, or it was just lost in the middle and didn’t reach the receiver.\n\nThat’s why this event is only useful to show a nice progress bar.\n\nTo resume upload, we need to know exactly the number of bytes received by the server. And only the server can tell that, so we’ll make an additional request.\n\nAlgorithm\n\nFirst, create a file id, to uniquely identify the file we’re going to upload:\n\nlet fileId = file.name + '-' + file.size + '-' + file.lastModified;\n\nThat’s needed for resume upload, to tell the server what we’re resuming.\n\nIf the name or the size or the last modification date changes, then there’ll be another fileId.\n\nSend a request to the server, asking how many bytes it already has, like this:\n\nlet response = await fetch('status', {\n  headers: {\n    'X-File-Id': fileId\n  }\n});\n\n// The server has that many bytes\nlet startByte = +await response.text();\n\nThis assumes that the server tracks file uploads by X-File-Id header. Should be implemented at server-side.\n\nIf the file doesn’t yet exist at the server, then the server response should be 0\n\nThen, we can use Blob method slice to send the file from startByte:\n\nxhr.open(\"POST\", \"upload\");\n\n// File id, so that the server knows which file we upload\nxhr.setRequestHeader('X-File-Id', fileId);\n\n// The byte we're resuming from, so the server knows we're resuming\nxhr.setRequestHeader('X-Start-Byte', startByte);\n\nxhr.upload.onprogress = (e) => {\n  console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);\n};\n\n// file can be from input.files[0] or another source\nxhr.send(file.slice(startByte));\n\nHere we send the server both file id as X-File-Id, so it knows which file we’re uploading, and the starting byte as X-Start-Byte, so it knows we’re not uploading it initially, but resuming.\n\nThe server should check its records, and if there was an upload of that file, and the current uploaded size is exactly X-Start-Byte, then append the data to it.\n\nHere’s the demo with both client and server code, written on Node.js.\n\nIt works only partially on this site, as Node.js is behind another server named Nginx, that buffers uploads, passing them to Node.js when fully complete.\n\nBut you can download it and run locally for the full demonstration:\n\nResultserver.jsuploader.jsindex.html\n\t\n\nAs we can see, modern networking methods are close to file managers in their capabilities – control over headers, progress indicator, sending file parts, etc.\n\nWe can implement resumable upload and much more."
  },
  {
    "title": "URL objects",
    "url": "https://javascript.info/url",
    "html": "The built-in URL class provides a convenient interface for creating and parsing URLs.\n\nThere are no networking methods that require exactly a URL object, strings are good enough. So technically we don’t have to use URL. But sometimes it can be really helpful.\n\nCreating a URL\n\nThe syntax to create a new URL object:\n\nnew URL(url, [base])\nurl – the full URL or only path (if base is set, see below),\nbase – an optional base URL: if set and url argument has only path, then the URL is generated relative to base.\n\nFor example:\n\nlet url = new URL('https://javascript.info/profile/admin');\n\nThese two URLs are same:\n\n\t\nlet url1 = new URL('https://javascript.info/profile/admin');\nlet url2 = new URL('/profile/admin', 'https://javascript.info');\n\nalert(url1); // https://javascript.info/profile/admin\nalert(url2); // https://javascript.info/profile/admin\n\nWe can easily create a new URL based on the path relative to an existing URL:\n\n\t\nlet url = new URL('https://javascript.info/profile/admin');\nlet newUrl = new URL('tester', url);\n\nalert(newUrl); // https://javascript.info/profile/tester\n\nThe URL object immediately allows us to access its components, so it’s a nice way to parse the url, e.g.:\n\n\t\nlet url = new URL('https://javascript.info/url');\n\nalert(url.protocol); // https:\nalert(url.host);     // javascript.info\nalert(url.pathname); // /url\n\nHere’s the cheatsheet for URL components:\n\nhref is the full url, same as url.toString()\nprotocol ends with the colon character :\nsearch – a string of parameters, starts with the question mark ?\nhash starts with the hash character #\nthere may be also user and password properties if HTTP authentication is present: http://login:password@site.com (not painted above, rarely used).\nWe can pass URL objects to networking (and most other) methods instead of a string\n\nWe can use a URL object in fetch or XMLHttpRequest, almost everywhere where a URL-string is expected.\n\nGenerally, the URL object can be passed to any method instead of a string, as most methods will perform the string conversion, that turns a URL object into a string with full URL.\n\nSearchParams “?…”\n\nLet’s say we want to create a url with given search params, for instance, https://google.com/search?query=JavaScript.\n\nWe can provide them in the URL string:\n\nnew URL('https://google.com/search?query=JavaScript')\n\n…But parameters need to be encoded if they contain spaces, non-latin letters, etc (more about that below).\n\nSo there’s a URL property for that: url.searchParams, an object of type URLSearchParams.\n\nIt provides convenient methods for search parameters:\n\nappend(name, value) – add the parameter by name,\ndelete(name) – remove the parameter by name,\nget(name) – get the parameter by name,\ngetAll(name) – get all parameters with the same name (that’s possible, e.g. ?user=John&user=Pete),\nhas(name) – check for the existence of the parameter by name,\nset(name, value) – set/replace the parameter,\nsort() – sort parameters by name, rarely needed,\n…and it’s also iterable, similar to Map.\n\nAn example with parameters that contain spaces and punctuation marks:\n\n\t\nlet url = new URL('https://google.com/search');\n\nurl.searchParams.set('q', 'test me!'); // added parameter with a space and !\n\nalert(url); // https://google.com/search?q=test+me%21\n\nurl.searchParams.set('tbs', 'qdr:y'); // added parameter with a colon :\n\n// parameters are automatically encoded\nalert(url); // https://google.com/search?q=test+me%21&tbs=qdr%3Ay\n\n// iterate over search parameters (decoded)\nfor(let [name, value] of url.searchParams) {\n  alert(`${name}=${value}`); // q=test me!, then tbs=qdr:y\n}\nEncoding\n\nThere’s a standard RFC3986 that defines which characters are allowed in URLs and which are not.\n\nThose that are not allowed, must be encoded, for instance non-latin letters and spaces – replaced with their UTF-8 codes, prefixed by %, such as %20 (a space can be encoded by +, for historical reasons, but that’s an exception).\n\nThe good news is that URL objects handle all that automatically. We just supply all parameters unencoded, and then convert the URL to string:\n\n\t\n// using some cyrillic characters for this example\n\nlet url = new URL('https://ru.wikipedia.org/wiki/Тест');\n\nurl.searchParams.set('key', 'ъ');\nalert(url); //https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A\n\nAs you can see, both Тест in the url path and ъ in the parameter are encoded.\n\nThe URL became longer, because each cyrillic letter is represented with two bytes in UTF-8, so there are two %.. entities.\n\nEncoding strings\n\nIn old times, before URL objects appeared, people used strings for URLs.\n\nAs of now, URL objects are often more convenient, but strings can still be used as well. In many cases using a string makes the code shorter.\n\nIf we use a string though, we need to encode/decode special characters manually.\n\nThere are built-in functions for that:\n\nencodeURI – encodes URL as a whole.\ndecodeURI – decodes it back.\nencodeURIComponent – encodes a URL component, such as a search parameter, or a hash, or a pathname.\ndecodeURIComponent – decodes it back.\n\nA natural question is: “What’s the difference between encodeURIComponent and encodeURI? When we should use either?”\n\nThat’s easy to understand if we look at the URL, that’s split into components in the picture above:\n\nhttps://site.com:8080/path/page?p1=v1&p2=v2#hash\n\nAs we can see, characters such as :, ?, =, &, # are allowed in URL.\n\n…On the other hand, if we look at a single URL component, such as a search parameter, these characters must be encoded, not to break the formatting.\n\nencodeURI encodes only characters that are totally forbidden in URL.\nencodeURIComponent encodes same characters, and, in addition to them, characters #, $, &, +, ,, /, :, ;, =, ? and @.\n\nSo, for a whole URL we can use encodeURI:\n\n\t\n// using cyrillic characters in url path\nlet url = encodeURI('http://site.com/привет');\n\nalert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82\n\n…While for URL parameters we should use encodeURIComponent instead:\n\n\t\nlet music = encodeURIComponent('Rock&Roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=Rock%26Roll\n\nCompare it with encodeURI:\n\n\t\nlet music = encodeURI('Rock&Roll');\n\nlet url = `https://google.com/search?q=${music}`;\nalert(url); // https://google.com/search?q=Rock&Roll\n\nAs we can see, encodeURI does not encode &, as this is a legit character in URL as a whole.\n\nBut we should encode & inside a search parameter, otherwise, we get q=Rock&Roll – that is actually q=Rock plus some obscure parameter Roll. Not as intended.\n\nSo we should use only encodeURIComponent for each search parameter, to correctly insert it in the URL string. The safest is to encode both name and value, unless we’re absolutely sure that it has only allowed characters.\n\nEncoding difference compared to URL\n\nClasses URL and URLSearchParams are based on the latest URI specification: RFC3986, while encode* functions are based on the obsolete version RFC2396.\n\nThere are a few differences, e.g. IPv6 addresses are encoded differently:\n\n\t\n// valid url with IPv6 address\nlet url = 'http://[2607:f8b0:4005:802::1007]/';\n\nalert(encodeURI(url)); // http://%5B2607:f8b0:4005:802::1007%5D/\nalert(new URL(url)); // http://[2607:f8b0:4005:802::1007]/\n\nAs we can see, encodeURI replaced square brackets [...], that’s not correct, the reason is: IPv6 urls did not exist at the time of RFC2396 (August 1998).\n\nSuch cases are rare, encode* functions work well most of the time."
  },
  {
    "title": "Fetch API",
    "url": "https://javascript.info/fetch-api",
    "html": "So far, we know quite a bit about fetch.\n\nLet’s see the rest of API, to cover all its abilities.\n\nPlease note:\n\nPlease note: most of these options are used rarely. You may skip this chapter and still use fetch well.\n\nStill, it’s good to know what fetch can do, so if the need arises, you can return and read the details.\n\nHere’s the full list of all possible fetch options with their default values (alternatives in comments):\n\nlet promise = fetch(url, {\n  method: \"GET\", // POST, PUT, DELETE, etc.\n  headers: {\n    // the content type header value is usually auto-set\n    // depending on the request body\n    \"Content-Type\": \"text/plain;charset=UTF-8\"\n  },\n  body: undefined, // string, FormData, Blob, BufferSource, or URLSearchParams\n  referrer: \"about:client\", // or \"\" to send no Referer header,\n  // or an url from the current origin\n  referrerPolicy: \"strict-origin-when-cross-origin\", // no-referrer-when-downgrade, no-referrer, origin, same-origin...\n  mode: \"cors\", // same-origin, no-cors\n  credentials: \"same-origin\", // omit, include\n  cache: \"default\", // no-store, reload, no-cache, force-cache, or only-if-cached\n  redirect: \"follow\", // manual, error\n  integrity: \"\", // a hash, like \"sha256-abcdef1234567890\"\n  keepalive: false, // true\n  signal: undefined, // AbortController to abort request\n  window: window // null\n});\n\nAn impressive list, right?\n\nWe fully covered method, headers and body in the chapter Fetch.\n\nThe signal option is covered in Fetch: Abort.\n\nNow let’s explore the remaining capabilities.\n\nreferrer, referrerPolicy\n\nThese options govern how fetch sets the HTTP Referer header.\n\nUsually that header is set automatically and contains the url of the page that made the request. In most scenarios, it’s not important at all, sometimes, for security purposes, it makes sense to remove or shorten it.\n\nThe referrer option allows to set any Referer (within the current origin) or remove it.\n\nTo send no referrer, set an empty string:\n\nfetch('/page', {\n  referrer: \"\" // no Referer header\n});\n\nTo set another url within the current origin:\n\nfetch('/page', {\n  // assuming we're on https://javascript.info\n  // we can set any Referer header, but only within the current origin\n  referrer: \"https://javascript.info/anotherpage\"\n});\n\nThe referrerPolicy option sets general rules for Referer.\n\nRequests are split into 3 types:\n\nRequest to the same origin.\nRequest to another origin.\nRequest from HTTPS to HTTP (from safe to unsafe protocol).\n\nUnlike the referrer option that allows to set the exact Referer value, referrerPolicy tells the browser general rules for each request type.\n\nPossible values are described in the Referrer Policy specification:\n\n\"strict-origin-when-cross-origin\" – the default value: for same-origin send the full Referer, for cross-origin send only the origin, unless it’s HTTPS→HTTP request, then send nothing.\n\"no-referrer-when-downgrade\" – full Referer is always sent, unless we send a request from HTTPS to HTTP (to the less secure protocol).\n\"no-referrer\" – never send Referer.\n\"origin\" – only send the origin in Referer, not the full page URL, e.g. only http://site.com instead of http://site.com/path.\n\"origin-when-cross-origin\" – send the full Referer to the same origin, but only the origin part for cross-origin requests (as above).\n\"same-origin\" – send the full Referer to the same origin, but no Referer for cross-origin requests.\n\"strict-origin\" – send only the origin, not the Referer for HTTPS→HTTP requests.\n\"unsafe-url\" – always send the full url in Referer, even for HTTPS→HTTP requests.\n\nHere’s a table with all combinations:\n\nValue\tTo same origin\tTo another origin\tHTTPS→HTTP\n\"no-referrer\"\t-\t-\t-\n\"no-referrer-when-downgrade\"\tfull\tfull\t-\n\"origin\"\torigin\torigin\torigin\n\"origin-when-cross-origin\"\tfull\torigin\torigin\n\"same-origin\"\tfull\t-\t-\n\"strict-origin\"\torigin\torigin\t-\n\"strict-origin-when-cross-origin\" or \"\" (default)\tfull\torigin\t-\n\"unsafe-url\"\tfull\tfull\tfull\n\nLet’s say we have an admin zone with a URL structure that shouldn’t be known from outside of the site.\n\nIf we send a fetch, then by default it always sends the Referer header with the full url of our page (except when we request from HTTPS to HTTP, then no Referer).\n\nE.g. Referer: https://javascript.info/admin/secret/paths.\n\nIf we’d like other websites know only the origin part, not the URL-path, we can set the option:\n\nfetch('https://another.com/page', {\n  // ...\n  referrerPolicy: \"origin-when-cross-origin\" // Referer: https://javascript.info\n});\n\nWe can put it to all fetch calls, maybe integrate into JavaScript library of our project that does all requests and uses fetch inside.\n\nIts only difference compared to the default behavior is that for requests to another origin fetch sends only the origin part of the URL (e.g. https://javascript.info, without path). For requests to our origin we still get the full Referer (maybe useful for debugging purposes).\n\nReferrer policy is not only for fetch\n\nReferrer policy, described in the specification, is not just for fetch, but more global.\n\nIn particular, it’s possible to set the default policy for the whole page using the Referrer-Policy HTTP header, or per-link, with <a rel=\"noreferrer\">.\n\nmode\n\nThe mode option is a safe-guard that prevents occasional cross-origin requests:\n\n\"cors\" – the default, cross-origin requests are allowed, as described in Fetch: Cross-Origin Requests,\n\"same-origin\" – cross-origin requests are forbidden,\n\"no-cors\" – only safe cross-origin requests are allowed.\n\nThis option may be useful when the URL for fetch comes from a 3rd-party, and we want a “power off switch” to limit cross-origin capabilities.\n\ncredentials\n\nThe credentials option specifies whether fetch should send cookies and HTTP-Authorization headers with the request.\n\n\"same-origin\" – the default, don’t send for cross-origin requests,\n\"include\" – always send, requires Access-Control-Allow-Credentials from cross-origin server in order for JavaScript to access the response, that was covered in the chapter Fetch: Cross-Origin Requests,\n\"omit\" – never send, even for same-origin requests.\ncache\n\nBy default, fetch requests make use of standard HTTP-caching. That is, it respects the Expires and Cache-Control headers, sends If-Modified-Since and so on. Just like regular HTTP-requests do.\n\nThe cache options allows to ignore HTTP-cache or fine-tune its usage:\n\n\"default\" – fetch uses standard HTTP-cache rules and headers,\n\"no-store\" – totally ignore HTTP-cache, this mode becomes the default if we set a header If-Modified-Since, If-None-Match, If-Unmodified-Since, If-Match, or If-Range,\n\"reload\" – don’t take the result from HTTP-cache (if any), but populate the cache with the response (if the response headers permit this action),\n\"no-cache\" – create a conditional request if there is a cached response, and a normal request otherwise. Populate HTTP-cache with the response,\n\"force-cache\" – use a response from HTTP-cache, even if it’s stale. If there’s no response in HTTP-cache, make a regular HTTP-request, behave normally,\n\"only-if-cached\" – use a response from HTTP-cache, even if it’s stale. If there’s no response in HTTP-cache, then error. Only works when mode is \"same-origin\".\nredirect\n\nNormally, fetch transparently follows HTTP-redirects, like 301, 302 etc.\n\nThe redirect option allows to change that:\n\n\"follow\" – the default, follow HTTP-redirects,\n\"error\" – error in case of HTTP-redirect,\n\"manual\" – allows to process HTTP-redirects manually. In case of redirect, we’ll get a special response object, with response.type=\"opaqueredirect\" and zeroed/empty status and most other properies.\nintegrity\n\nThe integrity option allows to check if the response matches the known-ahead checksum.\n\nAs described in the specification, supported hash-functions are SHA-256, SHA-384, and SHA-512, there might be others depending on the browser.\n\nFor example, we’re downloading a file, and we know that its SHA-256 checksum is “abcdef” (a real checksum is longer, of course).\n\nWe can put it in the integrity option, like this:\n\nfetch('http://site.com/file', {\n  integrity: 'sha256-abcdef'\n});\n\nThen fetch will calculate SHA-256 on its own and compare it with our string. In case of a mismatch, an error is triggered.\n\nkeepalive\n\nThe keepalive option indicates that the request may “outlive” the webpage that initiated it.\n\nFor example, we gather statistics on how the current visitor uses our page (mouse clicks, page fragments he views), to analyze and improve the user experience.\n\nWhen the visitor leaves our page – we’d like to save the data to our server.\n\nWe can use the window.onunload event for that:\n\n\t\nwindow.onunload = function() {\n  fetch('/analytics', {\n    method: 'POST',\n    body: \"statistics\",\n    keepalive: true\n  });\n};\n\nNormally, when a document is unloaded, all associated network requests are aborted. But the keepalive option tells the browser to perform the request in the background, even after it leaves the page. So this option is essential for our request to succeed.\n\nIt has a few limitations:\n\nWe can’t send megabytes: the body limit for keepalive requests is 64KB.\nIf we need to gather a lot of statistics about the visit, we should send it out regularly in packets, so that there won’t be a lot left for the last onunload request.\nThis limit applies to all keepalive requests together. In other words, we can perform multiple keepalive requests in parallel, but the sum of their body lengths should not exceed 64KB.\nWe can’t handle the server response if the document is unloaded. So in our example fetch will succeed due to keepalive, but subsequent functions won’t work.\nIn most cases, such as sending out statistics, it’s not a problem, as the server just accepts the data and usually sends an empty response to such requests."
  },
  {
    "title": "Fetch: Abort",
    "url": "https://javascript.info/fetch-abort",
    "html": "As we know, fetch returns a promise. And JavaScript generally has no concept of “aborting” a promise. So how can we cancel an ongoing fetch? E.g. if the user actions on our site indicate that the fetch isn’t needed any more.\n\nThere’s a special built-in object for such purposes: AbortController. It can be used to abort not only fetch, but other asynchronous tasks as well.\n\nThe usage is very straightforward:\n\nThe AbortController object\n\nCreate a controller:\n\nlet controller = new AbortController();\n\nA controller is an extremely simple object.\n\nIt has a single method abort(),\nAnd a single property signal that allows to set event listeners on it.\n\nWhen abort() is called:\n\ncontroller.signal emits the \"abort\" event.\ncontroller.signal.aborted property becomes true.\n\nGenerally, we have two parties in the process:\n\nThe one that performs a cancelable operation, it sets a listener on controller.signal.\nThe one that cancels: it calls controller.abort() when needed.\n\nHere’s the full example (without fetch yet):\n\n\t\nlet controller = new AbortController();\nlet signal = controller.signal;\n\n// The party that performs a cancelable operation\n// gets the \"signal\" object\n// and sets the listener to trigger when controller.abort() is called\nsignal.addEventListener('abort', () => alert(\"abort!\"));\n\n// The other party, that cancels (at any point later):\ncontroller.abort(); // abort!\n\n// The event triggers and signal.aborted becomes true\nalert(signal.aborted); // true\n\nAs we can see, AbortController is just a mean to pass abort events when abort() is called on it.\n\nWe could implement the same kind of event listening in our code on our own, without the AbortController object.\n\nBut what’s valuable is that fetch knows how to work with the AbortController object. It’s integrated in it.\n\nUsing with fetch\n\nTo be able to cancel fetch, pass the signal property of an AbortController as a fetch option:\n\nlet controller = new AbortController();\nfetch(url, {\n  signal: controller.signal\n});\n\nThe fetch method knows how to work with AbortController. It will listen to abort events on signal.\n\nNow, to abort, call controller.abort():\n\ncontroller.abort();\n\nWe’re done: fetch gets the event from signal and aborts the request.\n\nWhen a fetch is aborted, its promise rejects with an error AbortError, so we should handle it, e.g. in try..catch.\n\nHere’s the full example with fetch aborted after 1 second:\n\n\t\n// abort in 1 second\nlet controller = new AbortController();\nsetTimeout(() => controller.abort(), 1000);\n\ntry {\n  let response = await fetch('/article/fetch-abort/demo/hang', {\n    signal: controller.signal\n  });\n} catch(err) {\n  if (err.name == 'AbortError') { // handle abort()\n    alert(\"Aborted!\");\n  } else {\n    throw err;\n  }\n}\nAbortController is scalable\n\nAbortController is scalable. It allows to cancel multiple fetches at once.\n\nHere’s a sketch of code that fetches many urls in parallel, and uses a single controller to abort them all:\n\nlet urls = [...]; // a list of urls to fetch in parallel\n\nlet controller = new AbortController();\n\n// an array of fetch promises\nlet fetchJobs = urls.map(url => fetch(url, {\n  signal: controller.signal\n}));\n\nlet results = await Promise.all(fetchJobs);\n\n// if controller.abort() is called from anywhere,\n// it aborts all fetches\n\nIf we have our own asynchronous tasks, different from fetch, we can use a single AbortController to stop those, together with fetches.\n\nWe just need to listen to its abort event in our tasks:\n\nlet urls = [...];\nlet controller = new AbortController();\n\nlet ourJob = new Promise((resolve, reject) => { // our task\n  ...\n  controller.signal.addEventListener('abort', reject);\n});\n\nlet fetchJobs = urls.map(url => fetch(url, { // fetches\n  signal: controller.signal\n}));\n\n// Wait for fetches and our task in parallel\nlet results = await Promise.all([...fetchJobs, ourJob]);\n\n// if controller.abort() is called from anywhere,\n// it aborts all fetches and ourJob\nSummary\nAbortController is a simple object that generates an abort event on its signal property when the abort() method is called (and also sets signal.aborted to true).\nfetch integrates with it: we pass the signal property as the option, and then fetch listens to it, so it’s possible to abort the fetch.\nWe can use AbortController in our code. The \"call abort()\" → “listen to abort event” interaction is simple and universal. We can use it even without fetch."
  },
  {
    "title": "Fetch: Download progress",
    "url": "https://javascript.info/fetch-progress",
    "html": "The fetch method allows to track download progress.\n\nPlease note: there’s currently no way for fetch to track upload progress. For that purpose, please use XMLHttpRequest, we’ll cover it later.\n\nTo track download progress, we can use response.body property. It’s a ReadableStream – a special object that provides body chunk-by-chunk, as it comes. Readable streams are described in the Streams API specification.\n\nUnlike response.text(), response.json() and other methods, response.body gives full control over the reading process, and we can count how much is consumed at any moment.\n\nHere’s the sketch of code that reads the response from response.body:\n\n// instead of response.json() and other methods\nconst reader = response.body.getReader();\n\n// infinite loop while the body is downloading\nwhile(true) {\n  // done is true for the last chunk\n  // value is Uint8Array of the chunk bytes\n  const {done, value} = await reader.read();\n\n  if (done) {\n    break;\n  }\n\n  console.log(`Received ${value.length} bytes`)\n}\n\nThe result of await reader.read() call is an object with two properties:\n\ndone – true when the reading is complete, otherwise false.\nvalue – a typed array of bytes: Uint8Array.\nPlease note:\n\nStreams API also describes asynchronous iteration over ReadableStream with for await..of loop, but it’s not yet widely supported (see browser issues), so we use while loop.\n\nWe receive response chunks in the loop, until the loading finishes, that is: until done becomes true.\n\nTo log the progress, we just need for every received fragment value to add its length to the counter.\n\nHere’s the full working example that gets the response and logs the progress in console, more explanations to follow:\n\n\t\n// Step 1: start the fetch and obtain a reader\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits?per_page=100');\n\nconst reader = response.body.getReader();\n\n// Step 2: get total length\nconst contentLength = +response.headers.get('Content-Length');\n\n// Step 3: read the data\nlet receivedLength = 0; // received that many bytes at the moment\nlet chunks = []; // array of received binary chunks (comprises the body)\nwhile(true) {\n  const {done, value} = await reader.read();\n\n  if (done) {\n    break;\n  }\n\n  chunks.push(value);\n  receivedLength += value.length;\n\n  console.log(`Received ${receivedLength} of ${contentLength}`)\n}\n\n// Step 4: concatenate chunks into single Uint8Array\nlet chunksAll = new Uint8Array(receivedLength); // (4.1)\nlet position = 0;\nfor(let chunk of chunks) {\n  chunksAll.set(chunk, position); // (4.2)\n  position += chunk.length;\n}\n\n// Step 5: decode into a string\nlet result = new TextDecoder(\"utf-8\").decode(chunksAll);\n\n// We're done!\nlet commits = JSON.parse(result);\nalert(commits[0].author.login);\n\nLet’s explain that step-by-step:\n\nWe perform fetch as usual, but instead of calling response.json(), we obtain a stream reader response.body.getReader().\n\nPlease note, we can’t use both these methods to read the same response: either use a reader or a response method to get the result.\n\nPrior to reading, we can figure out the full response length from the Content-Length header.\n\nIt may be absent for cross-origin requests (see chapter Fetch: Cross-Origin Requests) and, well, technically a server doesn’t have to set it. But usually it’s at place.\n\nCall await reader.read() until it’s done.\n\nWe gather response chunks in the array chunks. That’s important, because after the response is consumed, we won’t be able to “re-read” it using response.json() or another way (you can try, there’ll be an error).\n\nAt the end, we have chunks – an array of Uint8Array byte chunks. We need to join them into a single result. Unfortunately, there’s no single method that concatenates those, so there’s some code to do that:\n\nWe create chunksAll = new Uint8Array(receivedLength) – a same-typed array with the combined length.\nThen use .set(chunk, position) method to copy each chunk one after another in it.\n\nWe have the result in chunksAll. It’s a byte array though, not a string.\n\nTo create a string, we need to interpret these bytes. The built-in TextDecoder does exactly that. Then we can JSON.parse it, if necessary.\n\nWhat if we need binary content instead of a string? That’s even simpler. Replace steps 4 and 5 with a single line that creates a Blob from all chunks:\n\nlet blob = new Blob(chunks);\n\nAt the end we have the result (as a string or a blob, whatever is convenient), and progress-tracking in the process.\n\nOnce again, please note, that’s not for upload progress (no way now with fetch), only for download progress.\n\nAlso, if the size is unknown, we should check receivedLength in the loop and break it once it reaches a certain limit. So that the chunks won’t overflow the memory."
  },
  {
    "title": "FormData",
    "url": "https://javascript.info/formdata",
    "html": "This chapter is about sending HTML forms: with or without files, with additional fields and so on.\n\nFormData objects can help with that. As you might have guessed, it’s the object to represent HTML form data.\n\nThe constructor is:\n\nlet formData = new FormData([form]);\n\nIf HTML form element is provided, it automatically captures its fields.\n\nThe special thing about FormData is that network methods, such as fetch, can accept a FormData object as a body. It’s encoded and sent out with Content-Type: multipart/form-data.\n\nFrom the server point of view, that looks like a usual form submission.\n\nSending a simple form\n\nLet’s send a simple form first.\n\nAs you can see, that’s almost one-liner:\n\n\t\n<form id=\"formElem\">\n  <input type=\"text\" name=\"name\" value=\"John\">\n  <input type=\"text\" name=\"surname\" value=\"Smith\">\n  <input type=\"submit\">\n</form>\n\n<script>\n  formElem.onsubmit = async (e) => {\n    e.preventDefault();\n\n    let response = await fetch('/article/formdata/post/user', {\n      method: 'POST',\n      body: new FormData(formElem)\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n  };\n</script>\n\nIn this example, the server code is not presented, as it’s beyond our scope. The server accepts the POST request and replies “User saved”.\n\nFormData Methods\n\nWe can modify fields in FormData with methods:\n\nformData.append(name, value) – add a form field with the given name and value,\nformData.append(name, blob, fileName) – add a field as if it were <input type=\"file\">, the third argument fileName sets file name (not form field name), as it were a name of the file in user’s filesystem,\nformData.delete(name) – remove the field with the given name,\nformData.get(name) – get the value of the field with the given name,\nformData.has(name) – if there exists a field with the given name, returns true, otherwise false\n\nA form is technically allowed to have many fields with the same name, so multiple calls to append add more same-named fields.\n\nThere’s also method set, with the same syntax as append. The difference is that .set removes all fields with the given name, and then appends a new field. So it makes sure there’s only one field with such name, the rest is just like append:\n\nformData.set(name, value),\nformData.set(name, blob, fileName).\n\nAlso we can iterate over formData fields using for..of loop:\n\n\t\nlet formData = new FormData();\nformData.append('key1', 'value1');\nformData.append('key2', 'value2');\n\n// List key/value pairs\nfor(let [name, value] of formData) {\n  alert(`${name} = ${value}`); // key1 = value1, then key2 = value2\n}\nSending a form with a file\n\nThe form is always sent as Content-Type: multipart/form-data, this encoding allows to send files. So, <input type=\"file\"> fields are sent also, similar to a usual form submission.\n\nHere’s an example with such form:\n\n\t\n<form id=\"formElem\">\n  <input type=\"text\" name=\"firstName\" value=\"John\">\n  Picture: <input type=\"file\" name=\"picture\" accept=\"image/*\">\n  <input type=\"submit\">\n</form>\n\n<script>\n  formElem.onsubmit = async (e) => {\n    e.preventDefault();\n\n    let response = await fetch('/article/formdata/post/user-avatar', {\n      method: 'POST',\n      body: new FormData(formElem)\n    });\n\n    let result = await response.json();\n\n    alert(result.message);\n  };\n</script>\nSending a form with Blob data\n\nAs we’ve seen in the chapter Fetch, it’s easy to send dynamically generated binary data e.g. an image, as Blob. We can supply it directly as fetch parameter body.\n\nIn practice though, it’s often convenient to send an image not separately, but as a part of the form, with additional fields, such as “name” and other metadata.\n\nAlso, servers are usually more suited to accept multipart-encoded forms, rather than raw binary data.\n\nThis example submits an image from <canvas>, along with some other fields, as a form, using FormData:\n\n\t\n<body style=\"margin:0\">\n  <canvas id=\"canvasElem\" width=\"100\" height=\"80\" style=\"border:1px solid\"></canvas>\n\n  <input type=\"button\" value=\"Submit\" onclick=\"submit()\">\n\n  <script>\n    canvasElem.onmousemove = function(e) {\n      let ctx = canvasElem.getContext('2d');\n      ctx.lineTo(e.clientX, e.clientY);\n      ctx.stroke();\n    };\n\n    async function submit() {\n      let imageBlob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n\n      let formData = new FormData();\n      formData.append(\"firstName\", \"John\");\n      formData.append(\"image\", imageBlob, \"image.png\");\n\n      let response = await fetch('/article/formdata/post/image-form', {\n        method: 'POST',\n        body: formData\n      });\n      let result = await response.json();\n      alert(result.message);\n    }\n\n  </script>\n</body>\n\nPlease note how the image Blob is added:\n\nformData.append(\"image\", imageBlob, \"image.png\");\n\nThat’s same as if there were <input type=\"file\" name=\"image\"> in the form, and the visitor submitted a file named \"image.png\" (3rd argument) with the data imageBlob (2nd argument) from their filesystem.\n\nThe server reads form data and the file, as if it were a regular form submission.\n\nSummary\n\nFormData objects are used to capture HTML form and submit it using fetch or another network method.\n\nWe can either create new FormData(form) from an HTML form, or create an object without a form at all, and then append fields with methods:\n\nformData.append(name, value)\nformData.append(name, blob, fileName)\nformData.set(name, value)\nformData.set(name, blob, fileName)\n\nLet’s note two peculiarities here:\n\nThe set method removes fields with the same name, append doesn’t. That’s the only difference between them.\nTo send a file, 3-argument syntax is needed, the last argument is a file name, that normally is taken from user filesystem for <input type=\"file\">.\n\nOther methods are:\n\nformData.delete(name)\nformData.get(name)\nformData.has(name)\n\nThat’s it!"
  },
  {
    "title": "Fetch",
    "url": "https://javascript.info/fetch",
    "html": "JavaScript can send network requests to the server and load new information whenever it’s needed.\n\nFor example, we can use a network request to:\n\nSubmit an order,\nLoad user information,\nReceive latest updates from the server,\n…etc.\n\n…And all of that without reloading the page!\n\nThere’s an umbrella term “AJAX” (abbreviated Asynchronous JavaScript And XML) for network requests from JavaScript. We don’t have to use XML though: the term comes from old times, that’s why that word is there. You may have heard that term already.\n\nThere are multiple ways to send a network request and get information from the server.\n\nThe fetch() method is modern and versatile, so we’ll start with it. It’s not supported by old browsers (can be polyfilled), but very well supported among the modern ones.\n\nThe basic syntax is:\n\nlet promise = fetch(url, [options])\nurl – the URL to access.\noptions – optional parameters: method, headers etc.\n\nWithout options, this is a simple GET request, downloading the contents of the url.\n\nThe browser starts the request right away and returns a promise that the calling code should use to get the result.\n\nGetting a response is usually a two-stage process.\n\nFirst, the promise, returned by fetch, resolves with an object of the built-in Response class as soon as the server responds with headers.\n\nAt this stage we can check HTTP status, to see whether it is successful or not, check headers, but don’t have the body yet.\n\nThe promise rejects if the fetch was unable to make HTTP-request, e.g. network problems, or there’s no such site. Abnormal HTTP-statuses, such as 404 or 500 do not cause an error.\n\nWe can see HTTP-status in response properties:\n\nstatus – HTTP status code, e.g. 200.\nok – boolean, true if the HTTP status code is 200-299.\n\nFor example:\n\nlet response = await fetch(url);\n\nif (response.ok) { // if HTTP-status is 200-299\n  // get the response body (the method explained below)\n  let json = await response.json();\n} else {\n  alert(\"HTTP-Error: \" + response.status);\n}\n\nSecond, to get the response body, we need to use an additional method call.\n\nResponse provides multiple promise-based methods to access the body in various formats:\n\nresponse.text() – read the response and return as text,\nresponse.json() – parse the response as JSON,\nresponse.formData() – return the response as FormData object (explained in the next chapter),\nresponse.blob() – return the response as Blob (binary data with type),\nresponse.arrayBuffer() – return the response as ArrayBuffer (low-level representation of binary data),\nadditionally, response.body is a ReadableStream object, it allows you to read the body chunk-by-chunk, we’ll see an example later.\n\nFor instance, let’s get a JSON-object with latest commits from GitHub:\n\n\t\nlet url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';\nlet response = await fetch(url);\n\nlet commits = await response.json(); // read response body and parse as JSON\n\nalert(commits[0].author.login);\n\nOr, the same without await, using pure promises syntax:\n\n\t\nfetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')\n  .then(response => response.json())\n  .then(commits => alert(commits[0].author.login));\n\nTo get the response text, await response.text() instead of .json():\n\n\t\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\nlet text = await response.text(); // read response body as text\n\nalert(text.slice(0, 80) + '...');\n\nAs a show-case for reading in binary format, let’s fetch and show a logo image of “fetch” specification (see chapter Blob for details about operations on Blob):\n\n\t\nlet response = await fetch('/article/fetch/logo-fetch.svg');\n\nlet blob = await response.blob(); // download as Blob object\n\n// create <img> for it\nlet img = document.createElement('img');\nimg.style = 'position:fixed;top:10px;left:10px;width:100px';\ndocument.body.append(img);\n\n// show it\nimg.src = URL.createObjectURL(blob);\n\nsetTimeout(() => { // hide after three seconds\n  img.remove();\n  URL.revokeObjectURL(img.src);\n}, 3000);\nImportant:\n\nWe can choose only one body-reading method.\n\nIf we’ve already got the response with response.text(), then response.json() won’t work, as the body content has already been processed.\n\nlet text = await response.text(); // response body consumed\nlet parsed = await response.json(); // fails (already consumed)\nResponse headers\n\nThe response headers are available in a Map-like headers object in response.headers.\n\nIt’s not exactly a Map, but it has similar methods to get individual headers by name or iterate over them:\n\n\t\nlet response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');\n\n// get one header\nalert(response.headers.get('Content-Type')); // application/json; charset=utf-8\n\n// iterate over all headers\nfor (let [key, value] of response.headers) {\n  alert(`${key} = ${value}`);\n}\nRequest headers\n\nTo set a request header in fetch, we can use the headers option. It has an object with outgoing headers, like this:\n\nlet response = fetch(protectedUrl, {\n  headers: {\n    Authentication: 'secret'\n  }\n});\n\n…But there’s a list of forbidden HTTP headers that we can’t set:\n\nAccept-Charset, Accept-Encoding\nAccess-Control-Request-Headers\nAccess-Control-Request-Method\nConnection\nContent-Length\nCookie, Cookie2\nDate\nDNT\nExpect\nHost\nKeep-Alive\nOrigin\nReferer\nTE\nTrailer\nTransfer-Encoding\nUpgrade\nVia\nProxy-*\nSec-*\n\nThese headers ensure proper and safe HTTP, so they are controlled exclusively by the browser.\n\nPOST requests\n\nTo make a POST request, or a request with another method, we need to use fetch options:\n\nmethod – HTTP-method, e.g. POST,\nbody – the request body, one of:\na string (e.g. JSON-encoded),\nFormData object, to submit the data as multipart/form-data,\nBlob/BufferSource to send binary data,\nURLSearchParams, to submit the data in x-www-form-urlencoded encoding, rarely used.\n\nThe JSON format is used most of the time.\n\nFor example, this code submits user object as JSON:\n\n\t\nlet user = {\n  name: 'John',\n  surname: 'Smith'\n};\n\nlet response = await fetch('/article/fetch/post/user', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json;charset=utf-8'\n  },\n  body: JSON.stringify(user)\n});\n\nlet result = await response.json();\nalert(result.message);\n\nPlease note, if the request body is a string, then Content-Type header is set to text/plain;charset=UTF-8 by default.\n\nBut, as we’re going to send JSON, we use headers option to send application/json instead, the correct Content-Type for JSON-encoded data.\n\nSending an image\n\nWe can also submit binary data with fetch using Blob or BufferSource objects.\n\nIn this example, there’s a <canvas> where we can draw by moving a mouse over it. A click on the “submit” button sends the image to the server:\n\n\t\n<body style=\"margin:0\">\n  <canvas id=\"canvasElem\" width=\"100\" height=\"80\" style=\"border:1px solid\"></canvas>\n\n  <input type=\"button\" value=\"Submit\" onclick=\"submit()\">\n\n  <script>\n    canvasElem.onmousemove = function(e) {\n      let ctx = canvasElem.getContext('2d');\n      ctx.lineTo(e.clientX, e.clientY);\n      ctx.stroke();\n    };\n\n    async function submit() {\n      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n      let response = await fetch('/article/fetch/post/image', {\n        method: 'POST',\n        body: blob\n      });\n\n      // the server responds with confirmation and the image size\n      let result = await response.json();\n      alert(result.message);\n    }\n\n  </script>\n</body>\n\nPlease note, here we don’t set Content-Type header manually, because a Blob object has a built-in type (here image/png, as generated by toBlob). For Blob objects that type becomes the value of Content-Type.\n\nThe submit() function can be rewritten without async/await like this:\n\nfunction submit() {\n  canvasElem.toBlob(function(blob) {\n    fetch('/article/fetch/post/image', {\n      method: 'POST',\n      body: blob\n    })\n      .then(response => response.json())\n      .then(result => alert(JSON.stringify(result, null, 2)))\n  }, 'image/png');\n}\nSummary\n\nA typical fetch request consists of two await calls:\n\nlet response = await fetch(url, options); // resolves with response headers\nlet result = await response.json(); // read body as json\n\nOr, without await:\n\nfetch(url, options)\n  .then(response => response.json())\n  .then(result => /* process result */)\n\nResponse properties:\n\nresponse.status – HTTP code of the response,\nresponse.ok – true if the status is 200-299.\nresponse.headers – Map-like object with HTTP headers.\n\nMethods to get response body:\n\nresponse.text() – return the response as text,\nresponse.json() – parse the response as JSON object,\nresponse.formData() – return the response as FormData object (multipart/form-data encoding, see the next chapter),\nresponse.blob() – return the response as Blob (binary data with type),\nresponse.arrayBuffer() – return the response as ArrayBuffer (low-level binary data),\n\nFetch options so far:\n\nmethod – HTTP-method,\nheaders – an object with request headers (not any header is allowed),\nbody – the data to send (request body) as string, FormData, BufferSource, Blob or UrlSearchParams object.\n\nIn the next chapters we’ll see more options and use cases of fetch.\n\nTasks\nFetch users from GitHub\n\nCreate an async function getUsers(names), that gets an array of GitHub logins, fetches the users from GitHub and returns an array of GitHub users.\n\nThe GitHub url with user information for the given USERNAME is: https://api.github.com/users/USERNAME.\n\nThere’s a test example in the sandbox.\n\nImportant details:\n\nThere should be one fetch request per user.\nRequests shouldn’t wait for each other. So that the data arrives as soon as possible.\nIf any request fails, or if there’s no such user, the function should return null in the resulting array.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "File and FileReader",
    "url": "https://javascript.info/file",
    "html": "A File object inherits from Blob and is extended with filesystem-related capabilities.\n\nThere are two ways to obtain it.\n\nFirst, there’s a constructor, similar to Blob:\n\nnew File(fileParts, fileName, [options])\nfileParts – is an array of Blob/BufferSource/String values.\nfileName – file name string.\noptions – optional object:\nlastModified – the timestamp (integer date) of last modification.\n\nSecond, more often we get a file from <input type=\"file\"> or drag’n’drop or other browser interfaces. In that case, the file gets this information from OS.\n\nAs File inherits from Blob, File objects have the same properties, plus:\n\nname – the file name,\nlastModified – the timestamp of last modification.\n\nThat’s how we can get a File object from <input type=\"file\">:\n\n\t\n<input type=\"file\" onchange=\"showFile(this)\">\n\n<script>\nfunction showFile(input) {\n  let file = input.files[0];\n\n  alert(`File name: ${file.name}`); // e.g my.png\n  alert(`Last modified: ${file.lastModified}`); // e.g 1552830408824\n}\n</script>\nPlease note:\n\nThe input may select multiple files, so input.files is an array-like object with them. Here we have only one file, so we just take input.files[0].\n\nFileReader\n\nFileReader is an object with the sole purpose of reading data from Blob (and hence File too) objects.\n\nIt delivers the data using events, as reading from disk may take time.\n\nThe constructor:\n\nlet reader = new FileReader(); // no arguments\n\nThe main methods:\n\nreadAsArrayBuffer(blob) – read the data in binary format ArrayBuffer.\nreadAsText(blob, [encoding]) – read the data as a text string with the given encoding (utf-8 by default).\nreadAsDataURL(blob) – read the binary data and encode it as base64 data url.\nabort() – cancel the operation.\n\nThe choice of read* method depends on which format we prefer, how we’re going to use the data.\n\nreadAsArrayBuffer – for binary files, to do low-level binary operations. For high-level operations, like slicing, File inherits from Blob, so we can call them directly, without reading.\nreadAsText – for text files, when we’d like to get a string.\nreadAsDataURL – when we’d like to use this data in src for img or another tag. There’s an alternative to reading a file for that, as discussed in chapter Blob: URL.createObjectURL(file).\n\nAs the reading proceeds, there are events:\n\nloadstart – loading started.\nprogress – occurs during reading.\nload – no errors, reading complete.\nabort – abort() called.\nerror – error has occurred.\nloadend – reading finished with either success or failure.\n\nWhen the reading is finished, we can access the result as:\n\nreader.result is the result (if successful)\nreader.error is the error (if failed).\n\nThe most widely used events are for sure load and error.\n\nHere’s an example of reading a file:\n\n\t\n<input type=\"file\" onchange=\"readFile(this)\">\n\n<script>\nfunction readFile(input) {\n  let file = input.files[0];\n\n  let reader = new FileReader();\n\n  reader.readAsText(file);\n\n  reader.onload = function() {\n    console.log(reader.result);\n  };\n\n  reader.onerror = function() {\n    console.log(reader.error);\n  };\n\n}\n</script>\nFileReader for blobs\n\nAs mentioned in the chapter Blob, FileReader can read not just files, but any blobs.\n\nWe can use it to convert a blob to another format:\n\nreadAsArrayBuffer(blob) – to ArrayBuffer,\nreadAsText(blob, [encoding]) – to string (an alternative to TextDecoder),\nreadAsDataURL(blob) – to base64 data url.\nFileReaderSync is available inside Web Workers\n\nFor Web Workers, there also exists a synchronous variant of FileReader, called FileReaderSync.\n\nIts reading methods read* do not generate events, but rather return a result, as regular functions do.\n\nThat’s only inside a Web Worker though, because delays in synchronous calls, that are possible while reading from files, in Web Workers are less important. They do not affect the page.\n\nSummary\n\nFile objects inherit from Blob.\n\nIn addition to Blob methods and properties, File objects also have name and lastModified properties, plus the internal ability to read from filesystem. We usually get File objects from user input, like <input> or Drag’n’Drop events (ondragend).\n\nFileReader objects can read from a file or a blob, in one of three formats:\n\nString (readAsText).\nArrayBuffer (readAsArrayBuffer).\nData url, base-64 encoded (readAsDataURL).\n\nIn many cases though, we don’t have to read the file contents. Just as we did with blobs, we can create a short url with URL.createObjectURL(file) and assign it to <a> or <img>. This way the file can be downloaded or shown up as an image, as a part of canvas etc.\n\nAnd if we’re going to send a File over a network, that’s also easy: network API like XMLHttpRequest or fetch natively accepts File objects."
  },
  {
    "title": "Network requests",
    "url": "https://javascript.info/network",
    "html": "Fetch\nFormData\nFetch: Download progress\nFetch: Abort\nFetch: Cross-Origin Requests\nFetch API\nURL objects\nXMLHttpRequest\nResumable file upload\nLong polling\nWebSocket\nServer Sent Events"
  },
  {
    "title": "Blob",
    "url": "https://javascript.info/blob",
    "html": "ArrayBuffer and views are a part of ECMA standard, a part of JavaScript.\n\nIn the browser, there are additional higher-level objects, described in File API, in particular Blob.\n\nBlob consists of an optional string type (a MIME-type usually), plus blobParts – a sequence of other Blob objects, strings and BufferSource.\n\nThe constructor syntax is:\n\nnew Blob(blobParts, options);\nblobParts is an array of Blob/BufferSource/String values.\noptions optional object:\ntype – Blob type, usually MIME-type, e.g. image/png,\nendings – whether to transform end-of-line to make the Blob correspond to current OS newlines (\\r\\n or \\n). By default \"transparent\" (do nothing), but also can be \"native\" (transform).\n\nFor example:\n\n// create Blob from a string\nlet blob = new Blob([\"<html>…</html>\"], {type: 'text/html'});\n// please note: the first argument must be an array [...]\n// create Blob from a typed array and strings\nlet hello = new Uint8Array([72, 101, 108, 108, 111]); // \"Hello\" in binary form\n\nlet blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});\n\nWe can extract Blob slices with:\n\nblob.slice([byteStart], [byteEnd], [contentType]);\nbyteStart – the starting byte, by default 0.\nbyteEnd – the last byte (exclusive, by default till the end).\ncontentType – the type of the new blob, by default the same as the source.\n\nThe arguments are similar to array.slice, negative numbers are allowed too.\n\nBlob objects are immutable\n\nWe can’t change data directly in a Blob, but we can slice parts of a Blob, create new Blob objects from them, mix them into a new Blob and so on.\n\nThis behavior is similar to JavaScript strings: we can’t change a character in a string, but we can make a new corrected string.\n\nBlob as URL\n\nA Blob can be easily used as a URL for <a>, <img> or other tags, to show its contents.\n\nThanks to type, we can also download/upload Blob objects, and the type naturally becomes Content-Type in network requests.\n\nLet’s start with a simple example. By clicking on a link you download a dynamically-generated Blob with hello world contents as a file:\n\n\t\n<!-- download attribute forces the browser to download instead of navigating -->\n<a download=\"hello.txt\" href='#' id=\"link\">Download</a>\n\n<script>\nlet blob = new Blob([\"Hello, world!\"], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n</script>\n\nWe can also create a link dynamically in JavaScript and simulate a click by link.click(), then download starts automatically.\n\nHere’s the similar code that causes user to download the dynamically created Blob, without any HTML:\n\n\t\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\nlink.href = URL.createObjectURL(blob);\n\nlink.click();\n\nURL.revokeObjectURL(link.href);\n\nURL.createObjectURL takes a Blob and creates a unique URL for it, in the form blob:<origin>/<uuid>.\n\nThat’s what the value of link.href looks like:\n\nblob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273\n\nFor each URL generated by URL.createObjectURL the browser stores a URL → Blob mapping internally. So such URLs are short, but allow to access the Blob.\n\nA generated URL (and hence the link with it) is only valid within the current document, while it’s open. And it allows to reference the Blob in <img>, <a>, basically any other object that expects a URL.\n\nThere’s a side effect though. While there’s a mapping for a Blob, the Blob itself resides in the memory. The browser can’t free it.\n\nThe mapping is automatically cleared on document unload, so Blob objects are freed then. But if an app is long-living, then that doesn’t happen soon.\n\nSo if we create a URL, that Blob will hang in memory, even if not needed any more.\n\nURL.revokeObjectURL(url) removes the reference from the internal mapping, thus allowing the Blob to be deleted (if there are no other references), and the memory to be freed.\n\nIn the last example, we intend the Blob to be used only once, for instant downloading, so we call URL.revokeObjectURL(link.href) immediately.\n\nIn the previous example with the clickable HTML-link, we don’t call URL.revokeObjectURL(link.href), because that would make the Blob url invalid. After the revocation, as the mapping is removed, the URL doesn’t work any more.\n\nBlob to base64\n\nAn alternative to URL.createObjectURL is to convert a Blob into a base64-encoded string.\n\nThat encoding represents binary data as a string of ultra-safe “readable” characters with ASCII-codes from 0 to 64. And what’s more important – we can use this encoding in “data-urls”.\n\nA data url has the form data:[<mediatype>][;base64],<data>. We can use such urls everywhere, on par with “regular” urls.\n\nFor instance, here’s a smiley:\n\n<img src=\"data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7\">\n\nThe browser will decode the string and show the image: \n\nTo transform a Blob into base64, we’ll use the built-in FileReader object. It can read data from Blobs in multiple formats. In the next chapter we’ll cover it more in-depth.\n\nHere’s the demo of downloading a blob, now via base-64:\n\n\t\nlet link = document.createElement('a');\nlink.download = 'hello.txt';\n\nlet blob = new Blob(['Hello, world!'], {type: 'text/plain'});\n\nlet reader = new FileReader();\nreader.readAsDataURL(blob); // converts the blob to base64 and calls onload\n\nreader.onload = function() {\n  link.href = reader.result; // data url\n  link.click();\n};\n\nBoth ways of making a URL of a Blob are usable. But usually URL.createObjectURL(blob) is simpler and faster.\n\nURL.createObjectURL(blob)\nWe need to revoke them if care about memory.\nDirect access to blob, no “encoding/decoding”\nBlob to data url\nNo need to revoke anything.\nPerformance and memory losses on big Blob objects for encoding.\nImage to blob\n\nWe can create a Blob of an image, an image part, or even make a page screenshot. That’s handy to upload it somewhere.\n\nImage operations are done via <canvas> element:\n\nDraw an image (or its part) on canvas using canvas.drawImage.\nCall canvas method .toBlob(callback, format, quality) that creates a Blob and runs callback with it when done.\n\nIn the example below, an image is just copied, but we could cut from it, or transform it on canvas prior to making a blob:\n\n\t\n// take any image\nlet img = document.querySelector('img');\n\n// make <canvas> of the same size\nlet canvas = document.createElement('canvas');\ncanvas.width = img.clientWidth;\ncanvas.height = img.clientHeight;\n\nlet context = canvas.getContext('2d');\n\n// copy image to it (this method allows to cut image)\ncontext.drawImage(img, 0, 0);\n// we can context.rotate(), and do many other things on canvas\n\n// toBlob is async operation, callback is called when done\ncanvas.toBlob(function(blob) {\n  // blob ready, download it\n  let link = document.createElement('a');\n  link.download = 'example.png';\n\n  link.href = URL.createObjectURL(blob);\n  link.click();\n\n  // delete the internal blob reference, to let the browser clear memory from it\n  URL.revokeObjectURL(link.href);\n}, 'image/png');\n\nIf we prefer async/await instead of callbacks:\n\nlet blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));\n\nFor screenshotting a page, we can use a library such as https://github.com/niklasvh/html2canvas. What it does is just walks the page and draws it on <canvas>. Then we can get a Blob of it the same way as above.\n\nFrom Blob to ArrayBuffer\n\nThe Blob constructor allows to create a blob from almost anything, including any BufferSource.\n\nBut if we need to perform low-level processing, we can get the lowest-level ArrayBuffer from blob.arrayBuffer():\n\n// get arrayBuffer from blob\nconst bufferPromise = await blob.arrayBuffer();\n\n// or\nblob.arrayBuffer().then(buffer => /* process the ArrayBuffer */);\nFrom Blob to stream\n\nWhen we read and write to a blob of more than 2 GB, the use of arrayBuffer becomes more memory intensive for us. At this point, we can directly convert the blob to a stream.\n\nA stream is a special object that allows to read from it (or write into it) portion by portion. It’s outside of our scope here, but here’s an example, and you can read more at https://developer.mozilla.org/en-US/docs/Web/API/Streams_API. Streams are convenient for data that is suitable for processing piece-by-piece.\n\nThe Blob interface’s stream() method returns a ReadableStream which upon reading returns the data contained within the Blob.\n\nThen we can read from it, like this:\n\n// get readableStream from blob\nconst readableStream = blob.stream();\nconst stream = readableStream.getReader();\n\nwhile (true) {\n  // for each iteration: value is the next blob fragment\n  let { done, value } = await stream.read();\n  if (done) {\n    // no more data in the stream\n    console.log('all blob processed.');\n    break;\n  }\n\n   // do something with the data portion we've just read from the blob\n  console.log(value);\n}\nSummary\n\nWhile ArrayBuffer, Uint8Array and other BufferSource are “binary data”, a Blob represents “binary data with type”.\n\nThat makes Blobs convenient for upload/download operations, that are so common in the browser.\n\nMethods that perform web-requests, such as XMLHttpRequest, fetch and so on, can work with Blob natively, as well as with other binary types.\n\nWe can easily convert between Blob and low-level binary data types:\n\nWe can make a Blob from a typed array using new Blob(...) constructor.\nWe can get back ArrayBuffer from a Blob using blob.arrayBuffer(), and then create a view over it for low-level binary processing.\n\nConversion streams are very useful when we need to handle large blob. You can easily create a ReadableStream from a blob. The Blob interface’s stream() method returns a ReadableStream which upon reading returns the data contained within the blob."
  },
  {
    "title": "TextDecoder and TextEncoder",
    "url": "https://javascript.info/text-decoder",
    "html": "What if the binary data is actually a string? For instance, we received a file with textual data.\n\nThe built-in TextDecoder object allows one to read the value into an actual JavaScript string, given the buffer and the encoding.\n\nWe first need to create it:\n\nlet decoder = new TextDecoder([label], [options]);\nlabel – the encoding, utf-8 by default, but big5, windows-1251 and many other are also supported.\noptions – optional object:\nfatal – boolean, if true then throw an exception for invalid (non-decodable) characters, otherwise (default) replace them with character \\uFFFD.\nignoreBOM – boolean, if true then ignore BOM (an optional byte-order Unicode mark), rarely needed.\n\n…And then decode:\n\nlet str = decoder.decode([input], [options]);\ninput – BufferSource to decode.\noptions – optional object:\nstream – true for decoding streams, when decoder is called repeatedly with incoming chunks of data. In that case a multi-byte character may occasionally split between chunks. This options tells TextDecoder to memorize “unfinished” characters and decode them when the next chunk comes.\n\nFor instance:\n\n\t\nlet uint8Array = new Uint8Array([72, 101, 108, 108, 111]);\n\nalert( new TextDecoder().decode(uint8Array) ); // Hello\n\t\nlet uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);\n\nalert( new TextDecoder().decode(uint8Array) ); // 你好\n\nWe can decode a part of the buffer by creating a subarray view for it:\n\n\t\nlet uint8Array = new Uint8Array([0, 72, 101, 108, 108, 111, 0]);\n\n// the string is in the middle\n// create a new view over it, without copying anything\nlet binaryString = uint8Array.subarray(1, -1);\n\nalert( new TextDecoder().decode(binaryString) ); // Hello\nTextEncoder\n\nTextEncoder does the reverse thing – converts a string into bytes.\n\nThe syntax is:\n\nlet encoder = new TextEncoder();\n\nThe only encoding it supports is “utf-8”.\n\nIt has two methods:\n\nencode(str) – returns Uint8Array from a string.\nencodeInto(str, destination) – encodes str into destination that must be Uint8Array.\n\t\nlet encoder = new TextEncoder();\n\nlet uint8Array = encoder.encode(\"Hello\");\nalert(uint8Array); // 72,101,108,108,111"
  },
  {
    "title": "The clickjacking attack",
    "url": "https://javascript.info/clickjacking",
    "html": "The “clickjacking” attack allows an evil page to click on a “victim site” on behalf of the visitor.\n\nMany sites were hacked this way, including Twitter, Facebook, Paypal and other sites. They have all been fixed, of course.\n\nThe idea\n\nThe idea is very simple.\n\nHere’s how clickjacking was done with Facebook:\n\nA visitor is lured to the evil page. It doesn’t matter how.\nThe page has a harmless-looking link on it (like “get rich now” or “click here, very funny”).\nOver that link the evil page positions a transparent <iframe> with src from facebook.com, in such a way that the “Like” button is right above that link. Usually that’s done with z-index.\nIn attempting to click the link, the visitor in fact clicks the button.\nThe demo\n\nHere’s how the evil page looks. To make things clear, the <iframe> is half-transparent (in real evil pages it’s fully transparent):\n\n\t\n<style>\niframe { /* iframe from the victim site */\n  width: 400px;\n  height: 100px;\n  position: absolute;\n  top:0; left:-20px;\n  opacity: 0.5; /* in real opacity:0 */\n  z-index: 1;\n}\n</style>\n\n<div>Click to get rich now:</div>\n\n<!-- The url from the victim site -->\n<iframe src=\"/clickjacking/facebook.html\"></iframe>\n\n<button>Click here!</button>\n\n<div>...And you're cool (I'm a cool hacker actually)!</div>\n\nThe full demo of the attack:\n\nResultfacebook.htmlindex.html\n\t\n\nHere we have a half-transparent <iframe src=\"facebook.html\">, and in the example we can see it hovering over the button. A click on the button actually clicks on the iframe, but that’s not visible to the user, because the iframe is transparent.\n\nAs a result, if the visitor is authorized on Facebook (“remember me” is usually turned on), then it adds a “Like”. On Twitter that would be a “Follow” button.\n\nHere’s the same example, but closer to reality, with opacity:0 for <iframe>:\n\nResultfacebook.htmlindex.html\n\t\n\nAll we need to attack – is to position the <iframe> on the evil page in such a way that the button is right over the link. So that when a user clicks the link, they actually click the button. That’s usually doable with CSS.\n\nClickjacking is for clicks, not for keyboard\n\nThe attack only affects mouse actions (or similar, like taps on mobile).\n\nKeyboard input is much difficult to redirect. Technically, if we have a text field to hack, then we can position an iframe in such a way that text fields overlap each other. So when a visitor tries to focus on the input they see on the page, they actually focus on the input inside the iframe.\n\nBut then there’s a problem. Everything that the visitor types will be hidden, because the iframe is not visible.\n\nPeople will usually stop typing when they can’t see their new characters printing on the screen.\n\nOld-school defences (weak)\n\nThe oldest defence is a bit of JavaScript which forbids opening the page in a frame (so-called “framebusting”).\n\nThat looks like this:\n\nif (top != window) {\n  top.location = window.location;\n}\n\nThat is: if the window finds out that it’s not on top, then it automatically makes itself the top.\n\nThis not a reliable defence, because there are many ways to hack around it. Let’s cover a few.\n\nBlocking top-navigation\n\nWe can block the transition caused by changing top.location in beforeunload event handler.\n\nThe top page (enclosing one, belonging to the hacker) sets a preventing handler to it, like this:\n\nwindow.onbeforeunload = function() {\n  return false;\n};\n\nWhen the iframe tries to change top.location, the visitor gets a message asking them whether they want to leave.\n\nIn most cases the visitor would answer negatively because they don’t know about the iframe – all they can see is the top page, there’s no reason to leave. So top.location won’t change!\n\nIn action:\n\nResultiframe.htmlindex.html\n\t\nSandbox attribute\n\nOne of the things restricted by the sandbox attribute is navigation. A sandboxed iframe may not change top.location.\n\nSo we can add the iframe with sandbox=\"allow-scripts allow-forms\". That would relax the restrictions, permitting scripts and forms. But we omit allow-top-navigation so that changing top.location is forbidden.\n\nHere’s the code:\n\n<iframe sandbox=\"allow-scripts allow-forms\" src=\"facebook.html\"></iframe>\n\nThere are other ways to work around that simple protection too.\n\nX-Frame-Options\n\nThe server-side header X-Frame-Options can permit or forbid displaying the page inside a frame.\n\nIt must be sent exactly as HTTP-header: the browser will ignore it if found in HTML <meta> tag. So, <meta http-equiv=\"X-Frame-Options\"...> won’t do anything.\n\nThe header may have 3 values:\n\nDENY\nNever ever show the page inside a frame.\nSAMEORIGIN\nAllow inside a frame if the parent document comes from the same origin.\nALLOW-FROM domain\nAllow inside a frame if the parent document is from the given domain.\n\nFor instance, Twitter uses X-Frame-Options: SAMEORIGIN.\n\nHere’s the result:\n\n<iframe src=\"https://twitter.com\"></iframe>\n\nDepending on your browser, the iframe above is either empty or alerting you that the browser won’t permit that page to be navigating in this way.\n\nShowing with disabled functionality\n\nThe X-Frame-Options header has a side effect. Other sites won’t be able to show our page in a frame, even if they have good reasons to do so.\n\nSo there are other solutions… For instance, we can “cover” the page with a <div> with styles height: 100%; width: 100%;, so that it will intercept all clicks. That <div> is to be removed if window == top or if we figure out that we don’t need the protection.\n\nSomething like this:\n\n<style>\n  #protector {\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    left: 0;\n    top: 0;\n    z-index: 99999999;\n  }\n</style>\n\n<div id=\"protector\">\n  <a href=\"/\" target=\"_blank\">Go to the site</a>\n</div>\n\n<script>\n  // there will be an error if top window is from the different origin\n  // but that's ok here\n  if (top.document.domain == document.domain) {\n    protector.remove();\n  }\n</script>\n\nThe demo:\n\nResultiframe.htmlindex.html\n\t\nSamesite cookie attribute\n\nThe samesite cookie attribute can also prevent clickjacking attacks.\n\nA cookie with such attribute is only sent to a website if it’s opened directly, not via a frame, or otherwise. More information in the chapter Cookies, document.cookie.\n\nIf the site, such as Facebook, had samesite attribute on its authentication cookie, like this:\n\nSet-Cookie: authorization=secret; samesite\n\n…Then such cookie wouldn’t be sent when Facebook is open in iframe from another site. So the attack would fail.\n\nThe samesite cookie attribute will not have an effect when cookies are not used. This may allow other websites to easily show our public, unauthenticated pages in iframes.\n\nHowever, this may also allow clickjacking attacks to work in a few limited cases. An anonymous polling website that prevents duplicate voting by checking IP addresses, for example, would still be vulnerable to clickjacking because it does not authenticate users using cookies.\n\nSummary\n\nClickjacking is a way to “trick” users into clicking on a victim site without even knowing what’s happening. That’s dangerous if there are important click-activated actions.\n\nA hacker can post a link to their evil page in a message, or lure visitors to their page by some other means. There are many variations.\n\nFrom one perspective – the attack is “not deep”: all a hacker is doing is intercepting a single click. But from another perspective, if the hacker knows that after the click another control will appear, then they may use cunning messages to coerce the user into clicking on them as well.\n\nThe attack is quite dangerous, because when we engineer the UI we usually don’t anticipate that a hacker may click on behalf of the visitor. So vulnerabilities can be found in totally unexpected places.\n\nIt is recommended to use X-Frame-Options: SAMEORIGIN on pages (or whole websites) which are not intended to be viewed inside frames.\nUse a covering <div> if we want to allow our pages to be shown in iframes, but still stay safe."
  },
  {
    "title": "ArrayBuffer, binary arrays",
    "url": "https://javascript.info/arraybuffer-binary-arrays",
    "html": "In web-development we meet binary data mostly while dealing with files (create, upload, download). Another typical use case is image processing.\n\nThat’s all possible in JavaScript, and binary operations are high-performant.\n\nAlthough, there’s a bit of confusion, because there are many classes. To name a few:\n\nArrayBuffer, Uint8Array, DataView, Blob, File, etc.\n\nBinary data in JavaScript is implemented in a non-standard way, compared to other languages. But when we sort things out, everything becomes fairly simple.\n\nThe basic binary object is ArrayBuffer – a reference to a fixed-length contiguous memory area.\n\nWe create it like this:\n\n\t\nlet buffer = new ArrayBuffer(16); // create a buffer of length 16\nalert(buffer.byteLength); // 16\n\nThis allocates a contiguous memory area of 16 bytes and pre-fills it with zeroes.\n\nArrayBuffer is not an array of something\n\nLet’s eliminate a possible source of confusion. ArrayBuffer has nothing in common with Array:\n\nIt has a fixed length, we can’t increase or decrease it.\nIt takes exactly that much space in the memory.\nTo access individual bytes, another “view” object is needed, not buffer[index].\n\nArrayBuffer is a memory area. What’s stored in it? It has no clue. Just a raw sequence of bytes.\n\nTo manipulate an ArrayBuffer, we need to use a “view” object.\n\nA view object does not store anything on its own. It’s the “eyeglasses” that give an interpretation of the bytes stored in the ArrayBuffer.\n\nFor instance:\n\nUint8Array – treats each byte in ArrayBuffer as a separate number, with possible values from 0 to 255 (a byte is 8-bit, so it can hold only that much). Such value is called a “8-bit unsigned integer”.\nUint16Array – treats every 2 bytes as an integer, with possible values from 0 to 65535. That’s called a “16-bit unsigned integer”.\nUint32Array – treats every 4 bytes as an integer, with possible values from 0 to 4294967295. That’s called a “32-bit unsigned integer”.\nFloat64Array – treats every 8 bytes as a floating point number with possible values from 5.0x10-324 to 1.8x10308.\n\nSo, the binary data in an ArrayBuffer of 16 bytes can be interpreted as 16 “tiny numbers”, or 8 bigger numbers (2 bytes each), or 4 even bigger (4 bytes each), or 2 floating-point values with high precision (8 bytes each).\n\nArrayBuffer is the core object, the root of everything, the raw binary data.\n\nBut if we’re going to write into it, or iterate over it, basically for almost any operation – we must use a view, e.g:\n\n\t\nlet buffer = new ArrayBuffer(16); // create a buffer of length 16\n\nlet view = new Uint32Array(buffer); // treat buffer as a sequence of 32-bit integers\n\nalert(Uint32Array.BYTES_PER_ELEMENT); // 4 bytes per integer\n\nalert(view.length); // 4, it stores that many integers\nalert(view.byteLength); // 16, the size in bytes\n\n// let's write a value\nview[0] = 123456;\n\n// iterate over values\nfor(let num of view) {\n  alert(num); // 123456, then 0, 0, 0 (4 values total)\n}\nTypedArray\n\nThe common term for all these views (Uint8Array, Uint32Array, etc) is TypedArray. They share the same set of methods and properties.\n\nPlease note, there’s no constructor called TypedArray, it’s just a common “umbrella” term to represent one of views over ArrayBuffer: Int8Array, Uint8Array and so on, the full list will soon follow.\n\nWhen you see something like new TypedArray, it means any of new Int8Array, new Uint8Array, etc.\n\nTyped arrays behave like regular arrays: have indexes and are iterable.\n\nA typed array constructor (be it Int8Array or Float64Array, doesn’t matter) behaves differently depending on argument types.\n\nThere are 5 variants of arguments:\n\nnew TypedArray(buffer, [byteOffset], [length]);\nnew TypedArray(object);\nnew TypedArray(typedArray);\nnew TypedArray(length);\nnew TypedArray();\n\nIf an ArrayBuffer argument is supplied, the view is created over it. We used that syntax already.\n\nOptionally we can provide byteOffset to start from (0 by default) and the length (till the end of the buffer by default), then the view will cover only a part of the buffer.\n\nIf an Array, or any array-like object is given, it creates a typed array of the same length and copies the content.\n\nWe can use it to pre-fill the array with the data:\n\n\t\nlet arr = new Uint8Array([0, 1, 2, 3]);\nalert( arr.length ); // 4, created binary array of the same length\nalert( arr[1] ); // 1, filled with 4 bytes (unsigned 8-bit integers) with given values\n\nIf another TypedArray is supplied, it does the same: creates a typed array of the same length and copies values. Values are converted to the new type in the process, if needed.\n\n\t\nlet arr16 = new Uint16Array([1, 1000]);\nlet arr8 = new Uint8Array(arr16);\nalert( arr8[0] ); // 1\nalert( arr8[1] ); // 232, tried to copy 1000, but can't fit 1000 into 8 bits (explanations below)\n\nFor a numeric argument length – creates the typed array to contain that many elements. Its byte length will be length multiplied by the number of bytes in a single item TypedArray.BYTES_PER_ELEMENT:\n\n\t\nlet arr = new Uint16Array(4); // create typed array for 4 integers\nalert( Uint16Array.BYTES_PER_ELEMENT ); // 2 bytes per integer\nalert( arr.byteLength ); // 8 (size in bytes)\n\nWithout arguments, creates an zero-length typed array.\n\nWe can create a TypedArray directly, without mentioning ArrayBuffer. But a view cannot exist without an underlying ArrayBuffer, so gets created automatically in all these cases except the first one (when provided).\n\nTo access the underlying ArrayBuffer, there are following properties in TypedArray:\n\nbuffer – references the ArrayBuffer.\nbyteLength – the length of the ArrayBuffer.\n\nSo, we can always move from one view to another:\n\nlet arr8 = new Uint8Array([0, 1, 2, 3]);\n\n// another view on the same data\nlet arr16 = new Uint16Array(arr8.buffer);\n\nHere’s the list of typed arrays:\n\nUint8Array, Uint16Array, Uint32Array – for integer numbers of 8, 16 and 32 bits.\nUint8ClampedArray – for 8-bit integers, “clamps” them on assignment (see below).\nInt8Array, Int16Array, Int32Array – for signed integer numbers (can be negative).\nFloat32Array, Float64Array – for signed floating-point numbers of 32 and 64 bits.\nNo int8 or similar single-valued types\n\nPlease note, despite of the names like Int8Array, there’s no single-value type like int, or int8 in JavaScript.\n\nThat’s logical, as Int8Array is not an array of these individual values, but rather a view on ArrayBuffer.\n\nOut-of-bounds behavior\n\nWhat if we attempt to write an out-of-bounds value into a typed array? There will be no error. But extra bits are cut-off.\n\nFor instance, let’s try to put 256 into Uint8Array. In binary form, 256 is 100000000 (9 bits), but Uint8Array only provides 8 bits per value, that makes the available range from 0 to 255.\n\nFor bigger numbers, only the rightmost (less significant) 8 bits are stored, and the rest is cut off:\n\nSo we’ll get zero.\n\nFor 257, the binary form is 100000001 (9 bits), the rightmost 8 get stored, so we’ll have 1 in the array:\n\nIn other words, the number modulo 28 is saved.\n\nHere’s the demo:\n\n\t\nlet uint8array = new Uint8Array(16);\n\nlet num = 256;\nalert(num.toString(2)); // 100000000 (binary representation)\n\nuint8array[0] = 256;\nuint8array[1] = 257;\n\nalert(uint8array[0]); // 0\nalert(uint8array[1]); // 1\n\nUint8ClampedArray is special in this aspect, its behavior is different. It saves 255 for any number that is greater than 255, and 0 for any negative number. That behavior is useful for image processing.\n\nTypedArray methods\n\nTypedArray has regular Array methods, with notable exceptions.\n\nWe can iterate, map, slice, find, reduce etc.\n\nThere are few things we can’t do though:\n\nNo splice – we can’t “delete” a value, because typed arrays are views on a buffer, and these are fixed, contiguous areas of memory. All we can do is to assign a zero.\nNo concat method.\n\nThere are two additional methods:\n\narr.set(fromArr, [offset]) copies all elements from fromArr to the arr, starting at position offset (0 by default).\narr.subarray([begin, end]) creates a new view of the same type from begin to end (exclusive). That’s similar to slice method (that’s also supported), but doesn’t copy anything – just creates a new view, to operate on the given piece of data.\n\nThese methods allow us to copy typed arrays, mix them, create new arrays from existing ones, and so on.\n\nDataView\n\nDataView is a special super-flexible “untyped” view over ArrayBuffer. It allows to access the data on any offset in any format.\n\nFor typed arrays, the constructor dictates what the format is. The whole array is supposed to be uniform. The i-th number is arr[i].\nWith DataView we access the data with methods like .getUint8(i) or .getUint16(i). We choose the format at method call time instead of the construction time.\n\nThe syntax:\n\nnew DataView(buffer, [byteOffset], [byteLength])\nbuffer – the underlying ArrayBuffer. Unlike typed arrays, DataView doesn’t create a buffer on its own. We need to have it ready.\nbyteOffset – the starting byte position of the view (by default 0).\nbyteLength – the byte length of the view (by default till the end of buffer).\n\nFor instance, here we extract numbers in different formats from the same buffer:\n\n\t\n// binary array of 4 bytes, all have the maximal value 255\nlet buffer = new Uint8Array([255, 255, 255, 255]).buffer;\n\nlet dataView = new DataView(buffer);\n\n// get 8-bit number at offset 0\nalert( dataView.getUint8(0) ); // 255\n\n// now get 16-bit number at offset 0, it consists of 2 bytes, together interpreted as 65535\nalert( dataView.getUint16(0) ); // 65535 (biggest 16-bit unsigned int)\n\n// get 32-bit number at offset 0\nalert( dataView.getUint32(0) ); // 4294967295 (biggest 32-bit unsigned int)\n\ndataView.setUint32(0, 0); // set 4-byte number to zero, thus setting all bytes to 0\n\nDataView is great when we store mixed-format data in the same buffer. For example, when we store a sequence of pairs (16-bit integer, 32-bit float), DataView allows to access them easily.\n\nSummary\n\nArrayBuffer is the core object, a reference to the fixed-length contiguous memory area.\n\nTo do almost any operation on ArrayBuffer, we need a view.\n\nIt can be a TypedArray:\nUint8Array, Uint16Array, Uint32Array – for unsigned integers of 8, 16, and 32 bits.\nUint8ClampedArray – for 8-bit integers, “clamps” them on assignment.\nInt8Array, Int16Array, Int32Array – for signed integer numbers (can be negative).\nFloat32Array, Float64Array – for signed floating-point numbers of 32 and 64 bits.\nOr a DataView – the view that uses methods to specify a format, e.g. getUint8(offset).\n\nIn most cases we create and operate directly on typed arrays, leaving ArrayBuffer under cover, as a “common denominator”. We can access it as .buffer and make another view if needed.\n\nThere are also two additional terms, that are used in descriptions of methods that operate on binary data:\n\nArrayBufferView is an umbrella term for all these kinds of views.\nBufferSource is an umbrella term for ArrayBuffer or ArrayBufferView.\n\nWe’ll see these terms in the next chapters. BufferSource is one of the most common terms, as it means “any kind of binary data” – an ArrayBuffer or a view over it.\n\nHere’s a cheatsheet:\n\nTasks\nConcatenate typed arrays\n\nGiven an array of Uint8Array, write a function concat(arrays) that returns a concatenation of them into a single array.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Cross-window communication",
    "url": "https://javascript.info/cross-window-communication",
    "html": "The “Same Origin” (same site) policy limits access of windows and frames to each other.\n\nThe idea is that if a user has two pages open: one from john-smith.com, and another one is gmail.com, then they wouldn’t want a script from john-smith.com to read our mail from gmail.com. So, the purpose of the “Same Origin” policy is to protect users from information theft.\n\nSame Origin\n\nTwo URLs are said to have the “same origin” if they have the same protocol, domain and port.\n\nThese URLs all share the same origin:\n\nhttp://site.com\nhttp://site.com/\nhttp://site.com/my/page.html\n\nThese ones do not:\n\nhttp://www.site.com (another domain: www. matters)\nhttp://site.org (another domain: .org matters)\nhttps://site.com (another protocol: https)\nhttp://site.com:8080 (another port: 8080)\n\nThe “Same Origin” policy states that:\n\nif we have a reference to another window, e.g. a popup created by window.open or a window inside <iframe>, and that window comes from the same origin, then we have full access to that window.\notherwise, if it comes from another origin, then we can’t access the content of that window: variables, document, anything. The only exception is location: we can change it (thus redirecting the user). But we cannot read location (so we can’t see where the user is now, no information leak).\nIn action: iframe\n\nAn <iframe> tag hosts a separate embedded window, with its own separate document and window objects.\n\nWe can access them using properties:\n\niframe.contentWindow to get the window inside the <iframe>.\niframe.contentDocument to get the document inside the <iframe>, shorthand for iframe.contentWindow.document.\n\nWhen we access something inside the embedded window, the browser checks if the iframe has the same origin. If that’s not so then the access is denied (writing to location is an exception, it’s still permitted).\n\nFor instance, let’s try reading and writing to <iframe> from another origin:\n\n\t\n<iframe src=\"https://example.com\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // we can get the reference to the inner window\n    let iframeWindow = iframe.contentWindow; // OK\n    try {\n      // ...but not to the document inside it\n      let doc = iframe.contentDocument; // ERROR\n    } catch(e) {\n      alert(e); // Security Error (another origin)\n    }\n\n    // also we can't READ the URL of the page in iframe\n    try {\n      // Can't read URL from the Location object\n      let href = iframe.contentWindow.location.href; // ERROR\n    } catch(e) {\n      alert(e); // Security Error\n    }\n\n    // ...we can WRITE into location (and thus load something else into the iframe)!\n    iframe.contentWindow.location = '/'; // OK\n\n    iframe.onload = null; // clear the handler, not to run it after the location change\n  };\n</script>\n\nThe code above shows errors for any operations except:\n\nGetting the reference to the inner window iframe.contentWindow – that’s allowed.\nWriting to location.\n\nContrary to that, if the <iframe> has the same origin, we can do anything with it:\n\n\t\n<!-- iframe from the same site -->\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  iframe.onload = function() {\n    // just do anything\n    iframe.contentDocument.body.prepend(\"Hello, world!\");\n  };\n</script>\niframe.onload vs iframe.contentWindow.onload\n\nThe iframe.onload event (on the <iframe> tag) is essentially the same as iframe.contentWindow.onload (on the embedded window object). It triggers when the embedded window fully loads with all resources.\n\n…But we can’t access iframe.contentWindow.onload for an iframe from another origin, so using iframe.onload.\n\nWindows on subdomains: document.domain\n\nBy definition, two URLs with different domains have different origins.\n\nBut if windows share the same second-level domain, for instance john.site.com, peter.site.com and site.com (so that their common second-level domain is site.com), we can make the browser ignore that difference, so that they can be treated as coming from the “same origin” for the purposes of cross-window communication.\n\nTo make it work, each such window should run the code:\n\ndocument.domain = 'site.com';\n\nThat’s all. Now they can interact without limitations. Again, that’s only possible for pages with the same second-level domain.\n\nDeprecated, but still working\n\nThe document.domain property is in the process of being removed from the specification. The cross-window messaging (explained soon below) is the suggested replacement.\n\nThat said, as of now all browsers support it. And the support will be kept for the future, not to break old code that relies on document.domain.\n\nIframe: wrong document pitfall\n\nWhen an iframe comes from the same origin, and we may access its document, there’s a pitfall. It’s not related to cross-origin things, but important to know.\n\nUpon its creation an iframe immediately has a document. But that document is different from the one that loads into it!\n\nSo if we do something with the document immediately, that will probably be lost.\n\nHere, look:\n\n\t\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  let oldDoc = iframe.contentDocument;\n  iframe.onload = function() {\n    let newDoc = iframe.contentDocument;\n    // the loaded document is not the same as initial!\n    alert(oldDoc == newDoc); // false\n  };\n</script>\n\nWe shouldn’t work with the document of a not-yet-loaded iframe, because that’s the wrong document. If we set any event handlers on it, they will be ignored.\n\nHow to detect the moment when the document is there?\n\nThe right document is definitely at place when iframe.onload triggers. But it only triggers when the whole iframe with all resources is loaded.\n\nWe can try to catch the moment earlier using checks in setInterval:\n\n\t\n<iframe src=\"/\" id=\"iframe\"></iframe>\n\n<script>\n  let oldDoc = iframe.contentDocument;\n\n  // every 100 ms check if the document is the new one\n  let timer = setInterval(() => {\n    let newDoc = iframe.contentDocument;\n    if (newDoc == oldDoc) return;\n\n    alert(\"New document is here!\");\n\n    clearInterval(timer); // cancel setInterval, don't need it any more\n  }, 100);\n</script>\nCollection: window.frames\n\nAn alternative way to get a window object for <iframe> – is to get it from the named collection window.frames:\n\nBy number: window.frames[0] – the window object for the first frame in the document.\nBy name: window.frames.iframeName – the window object for the frame with name=\"iframeName\".\n\nFor instance:\n\n\t\n<iframe src=\"/\" style=\"height:80px\" name=\"win\" id=\"iframe\"></iframe>\n\n<script>\n  alert(iframe.contentWindow == frames[0]); // true\n  alert(iframe.contentWindow == frames.win); // true\n</script>\n\nAn iframe may have other iframes inside. The corresponding window objects form a hierarchy.\n\nNavigation links are:\n\nwindow.frames – the collection of “children” windows (for nested frames).\nwindow.parent – the reference to the “parent” (outer) window.\nwindow.top – the reference to the topmost parent window.\n\nFor instance:\n\n\t\nwindow.frames[0].parent === window; // true\n\nWe can use the top property to check if the current document is open inside a frame or not:\n\n\t\nif (window == top) { // current window == window.top?\n  alert('The script is in the topmost window, not in a frame');\n} else {\n  alert('The script runs in a frame!');\n}\nThe “sandbox” iframe attribute\n\nThe sandbox attribute allows for the exclusion of certain actions inside an <iframe> in order to prevent it executing untrusted code. It “sandboxes” the iframe by treating it as coming from another origin and/or applying other limitations.\n\nThere’s a “default set” of restrictions applied for <iframe sandbox src=\"...\">. But it can be relaxed if we provide a space-separated list of restrictions that should not be applied as a value of the attribute, like this: <iframe sandbox=\"allow-forms allow-popups\">.\n\nIn other words, an empty \"sandbox\" attribute puts the strictest limitations possible, but we can put a space-delimited list of those that we want to lift.\n\nHere’s a list of limitations:\n\nallow-same-origin\nBy default \"sandbox\" forces the “different origin” policy for the iframe. In other words, it makes the browser to treat the iframe as coming from another origin, even if its src points to the same site. With all implied restrictions for scripts. This option removes that feature.\nallow-top-navigation\nAllows the iframe to change parent.location.\nallow-forms\nAllows to submit forms from iframe.\nallow-scripts\nAllows to run scripts from the iframe.\nallow-popups\nAllows to window.open popups from the iframe\n\nSee the manual for more.\n\nThe example below demonstrates a sandboxed iframe with the default set of restrictions: <iframe sandbox src=\"...\">. It has some JavaScript and a form.\n\nPlease note that nothing works. So the default set is really harsh:\n\nResultindex.htmlsandboxed.html\n\t\nPlease note:\n\nThe purpose of the \"sandbox\" attribute is only to add more restrictions. It cannot remove them. In particular, it can’t relax same-origin restrictions if the iframe comes from another origin.\n\nCross-window messaging\n\nThe postMessage interface allows windows to talk to each other no matter which origin they are from.\n\nSo, it’s a way around the “Same Origin” policy. It allows a window from john-smith.com to talk to gmail.com and exchange information, but only if they both agree and call corresponding JavaScript functions. That makes it safe for users.\n\nThe interface has two parts.\n\npostMessage\n\nThe window that wants to send a message calls postMessage method of the receiving window. In other words, if we want to send the message to win, we should call win.postMessage(data, targetOrigin).\n\nArguments:\n\ndata\nThe data to send. Can be any object, the data is cloned using the “structured serialization algorithm”. IE supports only strings, so we should JSON.stringify complex objects to support that browser.\ntargetOrigin\nSpecifies the origin for the target window, so that only a window from the given origin will get the message.\n\nThe targetOrigin is a safety measure. Remember, if the target window comes from another origin, we can’t read its location in the sender window. So we can’t be sure which site is open in the intended window right now: the user could navigate away, and the sender window has no idea about it.\n\nSpecifying targetOrigin ensures that the window only receives the data if it’s still at the right site. Important when the data is sensitive.\n\nFor instance, here win will only receive the message if it has a document from the origin http://example.com:\n\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n  win.postMessage(\"message\", \"http://example.com\");\n</script>\n\nIf we don’t want that check, we can set targetOrigin to *.\n\n<iframe src=\"http://example.com\" name=\"example\">\n\n<script>\n  let win = window.frames.example;\n\n  win.postMessage(\"message\", \"*\");\n</script>\nonmessage\n\nTo receive a message, the target window should have a handler on the message event. It triggers when postMessage is called (and targetOrigin check is successful).\n\nThe event object has special properties:\n\ndata\nThe data from postMessage.\norigin\nThe origin of the sender, for instance http://javascript.info.\nsource\nThe reference to the sender window. We can immediately source.postMessage(...) back if we want.\n\nTo assign that handler, we should use addEventListener, a short syntax window.onmessage does not work.\n\nHere’s an example:\n\nwindow.addEventListener(\"message\", function(event) {\n  if (event.origin != 'http://javascript.info') {\n    // something from an unknown domain, let's ignore it\n    return;\n  }\n\n  alert( \"received: \" + event.data );\n\n  // can message back using event.source.postMessage(...)\n});\n\nThe full example:\n\nResultiframe.htmlindex.html\n\t\nSummary\n\nTo call methods and access the content of another window, we should first have a reference to it.\n\nFor popups we have these references:\n\nFrom the opener window: window.open – opens a new window and returns a reference to it,\nFrom the popup: window.opener – is a reference to the opener window from a popup.\n\nFor iframes, we can access parent/children windows using:\n\nwindow.frames – a collection of nested window objects,\nwindow.parent, window.top are the references to parent and top windows,\niframe.contentWindow is the window inside an <iframe> tag.\n\nIf windows share the same origin (host, port, protocol), then windows can do whatever they want with each other.\n\nOtherwise, only possible actions are:\n\nChange the location of another window (write-only access).\nPost a message to it.\n\nExceptions are:\n\nWindows that share the same second-level domain: a.site.com and b.site.com. Then setting document.domain='site.com' in both of them puts them into the “same origin” state.\nIf an iframe has a sandbox attribute, it is forcefully put into the “different origin” state, unless the allow-same-origin is specified in the attribute value. That can be used to run untrusted code in iframes from the same site.\n\nThe postMessage interface allows two windows with any origins to talk:\n\nThe sender calls targetWin.postMessage(data, targetOrigin).\n\nIf targetOrigin is not '*', then the browser checks if window targetWin has the origin targetOrigin.\n\nIf it is so, then targetWin triggers the message event with special properties:\n\norigin – the origin of the sender window (like http://my.site.com)\nsource – the reference to the sender window.\ndata – the data, any object in everywhere except IE that supports only strings.\n\nWe should use addEventListener to set the handler for this event inside the target window."
  },
  {
    "title": "Event loop: microtasks and macrotasks",
    "url": "https://javascript.info/event-loop",
    "html": "Browser JavaScript execution flow, as well as in Node.js, is based on an event loop.\n\nUnderstanding how event loop works is important for optimizations, and sometimes for the right architecture.\n\nIn this chapter we first cover theoretical details about how things work, and then see practical applications of that knowledge.\n\nEvent Loop\n\nThe event loop concept is very simple. There’s an endless loop, where the JavaScript engine waits for tasks, executes them and then sleeps, waiting for more tasks.\n\nThe general algorithm of the engine:\n\nWhile there are tasks:\nexecute them, starting with the oldest task.\nSleep until a task appears, then go to 1.\n\nThat’s a formalization for what we see when browsing a page. The JavaScript engine does nothing most of the time, it only runs if a script/handler/event activates.\n\nExamples of tasks:\n\nWhen an external script <script src=\"...\"> loads, the task is to execute it.\nWhen a user moves their mouse, the task is to dispatch mousemove event and execute handlers.\nWhen the time is due for a scheduled setTimeout, the task is to run its callback.\n…and so on.\n\nTasks are set – the engine handles them – then waits for more tasks (while sleeping and consuming close to zero CPU).\n\nIt may happen that a task comes while the engine is busy, then it’s enqueued.\n\nThe tasks form a queue, so-called “macrotask queue” (v8 term):\n\nFor instance, while the engine is busy executing a script, a user may move their mouse causing mousemove, and setTimeout may be due and so on, these tasks form a queue, as illustrated on the picture above.\n\nTasks from the queue are processed on “first come – first served” basis. When the engine browser is done with the script, it handles mousemove event, then setTimeout handler, and so on.\n\nSo far, quite simple, right?\n\nTwo more details:\n\nRendering never happens while the engine executes a task. It doesn’t matter if the task takes a long time. Changes to the DOM are painted only after the task is complete.\nIf a task takes too long, the browser can’t do other tasks, such as processing user events. So after a time, it raises an alert like “Page Unresponsive”, suggesting killing the task with the whole page. That happens when there are a lot of complex calculations or a programming error leading to an infinite loop.\n\nThat was the theory. Now let’s see how we can apply that knowledge.\n\nUse-case 1: splitting CPU-hungry tasks\n\nLet’s say we have a CPU-hungry task.\n\nFor example, syntax-highlighting (used to colorize code examples on this page) is quite CPU-heavy. To highlight the code, it performs the analysis, creates many colored elements, adds them to the document – for a large amount of text that takes a lot of time.\n\nWhile the engine is busy with syntax highlighting, it can’t do other DOM-related stuff, process user events, etc. It may even cause the browser to “hiccup” or even “hang” for a bit, which is unacceptable.\n\nWe can avoid problems by splitting the big task into pieces. Highlight first 100 lines, then schedule setTimeout (with zero-delay) for the next 100 lines, and so on.\n\nTo demonstrate this approach, for the sake of simplicity, instead of text-highlighting, let’s take a function that counts from 1 to 1000000000.\n\nIf you run the code below, the engine will “hang” for some time. For server-side JS that’s clearly noticeable, and if you are running it in-browser, then try to click other buttons on the page – you’ll see that no other events get handled until the counting finishes.\n\n\t\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // do a heavy job\n  for (let j = 0; j < 1e9; j++) {\n    i++;\n  }\n\n  alert(\"Done in \" + (Date.now() - start) + 'ms');\n}\n\ncount();\n\nThe browser may even show a “the script takes too long” warning.\n\nLet’s split the job using nested setTimeout calls:\n\n\t\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // do a piece of the heavy job (*)\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  } else {\n    setTimeout(count); // schedule the new call (**)\n  }\n\n}\n\ncount();\n\nNow the browser interface is fully functional during the “counting” process.\n\nA single run of count does a part of the job (*), and then re-schedules itself (**) if needed:\n\nFirst run counts: i=1...1000000.\nSecond run counts: i=1000001..2000000.\n…and so on.\n\nNow, if a new side task (e.g. onclick event) appears while the engine is busy executing part 1, it gets queued and then executes when part 1 finished, before the next part. Periodic returns to the event loop between count executions provide just enough “air” for the JavaScript engine to do something else, to react to other user actions.\n\nThe notable thing is that both variants – with and without splitting the job by setTimeout – are comparable in speed. There’s not much difference in the overall counting time.\n\nTo make them closer, let’s make an improvement.\n\nWe’ll move the scheduling to the beginning of the count():\n\n\t\nlet i = 0;\n\nlet start = Date.now();\n\nfunction count() {\n\n  // move the scheduling to the beginning\n  if (i < 1e9 - 1e6) {\n    setTimeout(count); // schedule the new call\n  }\n\n  do {\n    i++;\n  } while (i % 1e6 != 0);\n\n  if (i == 1e9) {\n    alert(\"Done in \" + (Date.now() - start) + 'ms');\n  }\n\n}\n\ncount();\n\nNow when we start to count() and see that we’ll need to count() more, we schedule that immediately, before doing the job.\n\nIf you run it, it’s easy to notice that it takes significantly less time.\n\nWhy?\n\nThat’s simple: as you remember, there’s the in-browser minimal delay of 4ms for many nested setTimeout calls. Even if we set 0, it’s 4ms (or a bit more). So the earlier we schedule it – the faster it runs.\n\nFinally, we’ve split a CPU-hungry task into parts – now it doesn’t block the user interface. And its overall execution time isn’t much longer.\n\nUse case 2: progress indication\n\nAnother benefit of splitting heavy tasks for browser scripts is that we can show progress indication.\n\nAs mentioned earlier, changes to DOM are painted only after the currently running task is completed, irrespective of how long it takes.\n\nOn one hand, that’s great, because our function may create many elements, add them one-by-one to the document and change their styles – the visitor won’t see any “intermediate”, unfinished state. An important thing, right?\n\nHere’s the demo, the changes to i won’t show up until the function finishes, so we’ll see only the last value:\n\n\t\n<div id=\"progress\"></div>\n\n<script>\n\n  function count() {\n    for (let i = 0; i < 1e6; i++) {\n      i++;\n      progress.innerHTML = i;\n    }\n  }\n\n  count();\n</script>\n\n…But we also may want to show something during the task, e.g. a progress bar.\n\nIf we split the heavy task into pieces using setTimeout, then changes are painted out in-between them.\n\nThis looks prettier:\n\n\t\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // do a piece of the heavy job (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e7) {\n      setTimeout(count);\n    }\n\n  }\n\n  count();\n</script>\n\nNow the <div> shows increasing values of i, a kind of a progress bar.\n\nUse case 3: doing something after the event\n\nIn an event handler we may decide to postpone some actions until the event bubbled up and was handled on all levels. We can do that by wrapping the code in zero delay setTimeout.\n\nIn the chapter Dispatching custom events we saw an example: custom event menu-open is dispatched in setTimeout, so that it happens after the “click” event is fully handled.\n\nmenu.onclick = function() {\n  // ...\n\n  // create a custom event with the clicked menu item data\n  let customEvent = new CustomEvent(\"menu-open\", {\n    bubbles: true\n  });\n\n  // dispatch the custom event asynchronously\n  setTimeout(() => menu.dispatchEvent(customEvent));\n};\nMacrotasks and Microtasks\n\nAlong with macrotasks, described in this chapter, there are microtasks, mentioned in the chapter Microtasks.\n\nMicrotasks come solely from our code. They are usually created by promises: an execution of .then/catch/finally handler becomes a microtask. Microtasks are used “under the cover” of await as well, as it’s another form of promise handling.\n\nThere’s also a special function queueMicrotask(func) that queues func for execution in the microtask queue.\n\nImmediately after every macrotask, the engine executes all tasks from microtask queue, prior to running any other macrotasks or rendering or anything else.\n\nFor instance, take a look:\n\n\t\nsetTimeout(() => alert(\"timeout\"));\n\nPromise.resolve()\n  .then(() => alert(\"promise\"));\n\nalert(\"code\");\n\nWhat’s going to be the order here?\n\ncode shows first, because it’s a regular synchronous call.\npromise shows second, because .then passes through the microtask queue, and runs after the current code.\ntimeout shows last, because it’s a macrotask.\n\nThe richer event loop picture looks like this (order is from top to bottom, that is: the script first, then microtasks, rendering and so on):\n\nAll microtasks are completed before any other event handling or rendering or any other macrotask takes place.\n\nThat’s important, as it guarantees that the application environment is basically the same (no mouse coordinate changes, no new network data, etc) between microtasks.\n\nIf we’d like to execute a function asynchronously (after the current code), but before changes are rendered or new events handled, we can schedule it with queueMicrotask.\n\nHere’s an example with “counting progress bar”, similar to the one shown previously, but queueMicrotask is used instead of setTimeout. You can see that it renders at the very end. Just like the synchronous code:\n\n\t\n<div id=\"progress\"></div>\n\n<script>\n  let i = 0;\n\n  function count() {\n\n    // do a piece of the heavy job (*)\n    do {\n      i++;\n      progress.innerHTML = i;\n    } while (i % 1e3 != 0);\n\n    if (i < 1e6) {\n      queueMicrotask(count);\n    }\n\n  }\n\n  count();\n</script>\nSummary\n\nA more detailed event loop algorithm (though still simplified compared to the specification):\n\nDequeue and run the oldest task from the macrotask queue (e.g. “script”).\nExecute all microtasks:\nWhile the microtask queue is not empty:\nDequeue and run the oldest microtask.\nRender changes if any.\nIf the macrotask queue is empty, wait till a macrotask appears.\nGo to step 1.\n\nTo schedule a new macrotask:\n\nUse zero delayed setTimeout(f).\n\nThat may be used to split a big calculation-heavy task into pieces, for the browser to be able to react to user events and show progress between them.\n\nAlso, used in event handlers to schedule an action after the event is fully handled (bubbling done).\n\nTo schedule a new microtask\n\nUse queueMicrotask(f).\nAlso promise handlers go through the microtask queue.\n\nThere’s no UI or network event handling between microtasks: they run immediately one after another.\n\nSo one may want to queueMicrotask to execute a function asynchronously, but within the environment state.\n\nWeb Workers\n\nFor long heavy calculations that shouldn’t block the event loop, we can use Web Workers.\n\nThat’s a way to run code in another, parallel thread.\n\nWeb Workers can exchange messages with the main process, but they have their own variables, and their own event loop.\n\nWeb Workers do not have access to DOM, so they are useful, mainly, for calculations, to use multiple CPU cores simultaneously.\n\nTasks\nWhat will be the output of this code?\nimportance: 5\nconsole.log(1);\n\nsetTimeout(() => console.log(2));\n\nPromise.resolve().then(() => console.log(3));\n\nPromise.resolve().then(() => setTimeout(() => console.log(4)));\n\nPromise.resolve().then(() => console.log(5));\n\nsetTimeout(() => console.log(6));\n\nconsole.log(7);\nsolution"
  },
  {
    "title": "Binary data, files",
    "url": "https://javascript.info/binary",
    "html": "Working with binary data and files in JavaScript.\n\nArrayBuffer, binary arrays\nTextDecoder and TextEncoder\nBlob\nFile and FileReader"
  },
  {
    "title": "Selection and Range",
    "url": "https://javascript.info/selection-range",
    "html": "In this chapter we’ll cover selection in the document, as well as selection in form fields, such as <input>.\n\nJavaScript can access an existing selection, select/deselect DOM nodes as a whole or partially, remove the selected content from the document, wrap it into a tag, and so on.\n\nYou can find some recipes for common tasks at the end of the chapter, in “Summary” section. Maybe that covers your current needs, but you’ll get much more if you read the whole text.\n\nThe underlying Range and Selection objects are easy to grasp, and then you’ll need no recipes to make them do what you want.\n\nRange\n\nThe basic concept of selection is Range, that is essentially a pair of “boundary points”: range start and range end.\n\nA Range object is created without parameters:\n\nlet range = new Range();\n\nThen we can set the selection boundaries using range.setStart(node, offset) and range.setEnd(node, offset).\n\nAs you might guess, further we’ll use the Range objects for selection, but first let’s create few such objects.\n\nSelecting the text partially\n\nThe interesting thing is that the first argument node in both methods can be either a text node or an element node, and the meaning of the second argument depends on that.\n\nIf node is a text node, then offset must be the position in its text.\n\nFor example, given the element <p>Hello</p>, we can create the range containing the letters “ll” as follows:\n\n\t\n<p id=\"p\">Hello</p>\n<script>\n  let range = new Range();\n  range.setStart(p.firstChild, 2);\n  range.setEnd(p.firstChild, 4);\n\n  // toString of a range returns its content as text\n  console.log(range); // ll\n</script>\n\nHere we take the first child of <p> (that’s the text node) and specify the text positions inside it:\n\nSelecting element nodes\n\nAlternatively, if node is an element node, then offset must be the child number.\n\nThat’s handy for making ranges that contain nodes as a whole, not stop somewhere inside their text.\n\nFor example, we have a more complex document fragment:\n\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\nHere’s its DOM structure with both element and text nodes:\n\n▾\nP\n#text Example:␣\n▾\nI\n#text italic\n#text ␣and␣\n▾\nB\n#text bold\n\nLet’s make a range for \"Example: <i>italic</i>\".\n\nAs we can see, this phrase consists of exactly two children of <p>, with indexes 0 and 1:\n\nThe starting point has <p> as the parent node, and 0 as the offset.\n\nSo we can set it as range.setStart(p, 0).\n\nThe ending point also has <p> as the parent node, but 2 as the offset (it specifies the range up to, but not including offset).\n\nSo we can set it as range.setEnd(p, 2).\n\nHere’s the demo. If you run it, you can see that the text gets selected:\n\n\t\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n\n  range.setStart(p, 0);\n  range.setEnd(p, 2);\n\n  // toString of a range returns its content as text, without tags\n  console.log(range); // Example: italic\n\n  // apply this range for document selection (explained later below)\n  document.getSelection().addRange(range);\n</script>\n\nHere’s a more flexible test stand where you can set range start/end numbers and explore other variants:\n\n\t\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"start\" type=\"number\" value=1> – To <input id=\"end\" type=\"number\" value=4>\n<button id=\"button\">Click to select</button>\n<script>\n  button.onclick = () => {\n    let range = new Range();\n\n    range.setStart(p, start.value);\n    range.setEnd(p, end.value);\n\n    // apply the selection, explained later below\n    document.getSelection().removeAllRanges();\n    document.getSelection().addRange(range);\n  };\n</script>\n\nE.g. selecting in the same <p> from offset 1 to 4 gives us the range <i>italic</i> and <b>bold</b>:\n\nStarting and ending nodes can be different\n\nWe don’t have to use the same node in setStart and setEnd. A range may span across many unrelated nodes. It’s only important that the end is after the start in the document.\n\nSelecting a bigger fragment\n\nLet’s make a bigger selection in our example, like this:\n\nWe already know how to do that. We just need to set the start and the end as a relative offset in text nodes.\n\nWe need to create a range, that:\n\nstarts from position 2 in <p> first child (taking all but two first letters of \"Example: \")\nends at the position 3 in <b> first child (taking first three letters of “bold”, but no more):\n\t\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n\n  range.setStart(p.firstChild, 2);\n  range.setEnd(p.querySelector('b').firstChild, 3);\n\n  console.log(range); // ample: italic and bol\n\n  // use this range for selection (explained later)\n  window.getSelection().addRange(range);\n</script>\n\nAs you can see, it’s fairly easy to make a range of whatever we want.\n\nIf we’d like to take nodes as a whole, we can pass elements in setStart/setEnd. Otherwise, we can work on the text level.\n\nRange properties\n\nThe range object that we created in the example above has following properties:\n\nstartContainer, startOffset – node and offset of the start,\nin the example above: first text node inside <p> and 2.\nendContainer, endOffset – node and offset of the end,\nin the example above: first text node inside <b> and 3.\ncollapsed – boolean, true if the range starts and ends on the same point (so there’s no content inside the range),\nin the example above: false\ncommonAncestorContainer – the nearest common ancestor of all nodes within the range,\nin the example above: <p>\nRange selection methods\n\nThere are many convenient methods to manipulate ranges.\n\nWe’ve already seen setStart and setEnd, here are other similar methods.\n\nSet range start:\n\nsetStart(node, offset) set start at: position offset in node\nsetStartBefore(node) set start at: right before node\nsetStartAfter(node) set start at: right after node\n\nSet range end (similar methods):\n\nsetEnd(node, offset) set end at: position offset in node\nsetEndBefore(node) set end at: right before node\nsetEndAfter(node) set end at: right after node\n\nTechnically, setStart/setEnd can do anything, but more methods provide more convenience.\n\nIn all these methods, node can be both a text or element node: for text nodes offset skips that many of characters, while for element nodes that many child nodes.\n\nEven more methods to create ranges:\n\nselectNode(node) set range to select the whole node\nselectNodeContents(node) set range to select the whole node contents\ncollapse(toStart) if toStart=true set end=start, otherwise set start=end, thus collapsing the range\ncloneRange() creates a new range with the same start/end\nRange editing methods\n\nOnce the range is created, we can manipulate its content using these methods:\n\ndeleteContents() – remove range content from the document\nextractContents() – remove range content from the document and return as DocumentFragment\ncloneContents() – clone range content and return as DocumentFragment\ninsertNode(node) – insert node into the document at the beginning of the range\nsurroundContents(node) – wrap node around range content. For this to work, the range must contain both opening and closing tags for all elements inside it: no partial ranges like <i>abc.\n\nWith these methods we can do basically anything with selected nodes.\n\nHere’s the test stand to see them in action:\n\n\t\nClick buttons to run methods on the selection, \"resetExample\" to reset it.\n\n<p id=\"p\">Example: <i>italic</i> and <b>bold</b></p>\n\n<p id=\"result\"></p>\n<script>\n  let range = new Range();\n\n  // Each demonstrated method is represented here:\n  let methods = {\n    deleteContents() {\n      range.deleteContents()\n    },\n    extractContents() {\n      let content = range.extractContents();\n      result.innerHTML = \"\";\n      result.append(\"extracted: \", content);\n    },\n    cloneContents() {\n      let content = range.cloneContents();\n      result.innerHTML = \"\";\n      result.append(\"cloned: \", content);\n    },\n    insertNode() {\n      let newNode = document.createElement('u');\n      newNode.innerHTML = \"NEW NODE\";\n      range.insertNode(newNode);\n    },\n    surroundContents() {\n      let newNode = document.createElement('u');\n      try {\n        range.surroundContents(newNode);\n      } catch(e) { console.log(e) }\n    },\n    resetExample() {\n      p.innerHTML = `Example: <i>italic</i> and <b>bold</b>`;\n      result.innerHTML = \"\";\n\n      range.setStart(p.firstChild, 2);\n      range.setEnd(p.querySelector('b').firstChild, 3);\n\n      window.getSelection().removeAllRanges();\n      window.getSelection().addRange(range);\n    }\n  };\n\n  for(let method in methods) {\n    document.write(`<div><button onclick=\"methods.${method}()\">${method}</button></div>`);\n  }\n\n  methods.resetExample();\n</script>\n\nThere also exist methods to compare ranges, but these are rarely used. When you need them, please refer to the spec or MDN manual.\n\nSelection\n\nRange is a generic object for managing selection ranges. Although, creating a Range doesn’t mean that we see a selection on screen.\n\nWe may create Range objects, pass them around – they do not visually select anything on their own.\n\nThe document selection is represented by Selection object, that can be obtained as window.getSelection() or document.getSelection(). A selection may include zero or more ranges. At least, the Selection API specification says so. In practice though, only Firefox allows to select multiple ranges in the document by using Ctrl+click (Cmd+click for Mac).\n\nHere’s a screenshot of a selection with 3 ranges, made in Firefox:\n\nOther browsers support at maximum 1 range. As we’ll see, some of Selection methods imply that there may be many ranges, but again, in all browsers except Firefox, there’s at maximum 1.\n\nHere’s a small demo that shows the current selection (select something and click) as text:\n\nalert(document.getSelection())\n\nSelection properties\n\nAs said, a selection may in theory contain multiple ranges. We can get these range objects using the method:\n\ngetRangeAt(i) – get i-th range, starting from 0. In all browsers except Firefox, only 0 is used.\n\nAlso, there exist properties that often provide better convenience.\n\nSimilar to a range, a selection object has a start, called “anchor”, and the end, called “focus”.\n\nThe main selection properties are:\n\nanchorNode – the node where the selection starts,\nanchorOffset – the offset in anchorNode where the selection starts,\nfocusNode – the node where the selection ends,\nfocusOffset – the offset in focusNode where the selection ends,\nisCollapsed – true if selection selects nothing (empty range), or doesn’t exist.\nrangeCount – count of ranges in the selection, maximum 1 in all browsers except Firefox.\nSelection end/start vs Range\n\nThere’s an important differences of a selection anchor/focus compared with a Range start/end.\n\nAs we know, Range objects always have their start before the end.\n\nFor selections, that’s not always the case.\n\nSelecting something with a mouse can be done in both directions: either “left-to-right” or “right-to-left”.\n\nIn other words, when the mouse button is pressed, and then it moves forward in the document, then its end (focus) will be after its start (anchor).\n\nE.g. if the user starts selecting with mouse and goes from “Example” to “italic”:\n\n…But the same selection could be done backwards: starting from “italic” to “Example” (backward direction), then its end (focus) will be before the start (anchor):\n\nSelection events\n\nThere are events on to keep track of selection:\n\nelem.onselectstart – when a selection starts specifically on element elem (or inside it). For instance, when the user presses the mouse button on it and starts to move the pointer.\nPreventing the default action cancels the selection start. So starting a selection from this element becomes impossible, but the element is still selectable. The visitor just needs to start the selection from elsewhere.\ndocument.onselectionchange – whenever a selection changes or starts.\nPlease note: this handler can be set only on document, it tracks all selections in it.\nSelection tracking demo\n\nHere’s a small demo. It tracks the current selection on the document and shows its boundaries:\n\n\t\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n<script>\n  document.onselectionchange = function() {\n    let selection = document.getSelection();\n\n    let {anchorNode, anchorOffset, focusNode, focusOffset} = selection;\n\n    // anchorNode and focusNode are text nodes usually\n    from.value = `${anchorNode?.data}, offset ${anchorOffset}`;\n    to.value = `${focusNode?.data}, offset ${focusOffset}`;\n  };\n</script>\nSelection copying demo\n\nThere are two approaches to copying the selected content:\n\nWe can use document.getSelection().toString() to get it as text.\nOtherwise, to copy the full DOM, e.g. if we need to keep formatting, we can get the underlying ranges with getRangeAt(...). A Range object, in turn, has cloneContents() method that clones its content and returns as DocumentFragment object, that we can insert elsewhere.\n\nHere’s the demo of copying the selected content both as text and as DOM nodes:\n\n\t\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\nCloned: <span id=\"cloned\"></span>\n<br>\nAs text: <span id=\"astext\"></span>\n\n<script>\n  document.onselectionchange = function() {\n    let selection = document.getSelection();\n\n    cloned.innerHTML = astext.innerHTML = \"\";\n\n    // Clone DOM nodes from ranges (we support multiselect here)\n    for (let i = 0; i < selection.rangeCount; i++) {\n      cloned.append(selection.getRangeAt(i).cloneContents());\n    }\n\n    // Get as text\n    astext.innerHTML += selection;\n  };\n</script>\nSelection methods\n\nWe can work with the selection by adding/removing ranges:\n\ngetRangeAt(i) – get i-th range, starting from 0. In all browsers except Firefox, only 0 is used.\naddRange(range) – add range to selection. All browsers except Firefox ignore the call, if the selection already has an associated range.\nremoveRange(range) – remove range from the selection.\nremoveAllRanges() – remove all ranges.\nempty() – alias to removeAllRanges.\n\nThere are also convenience methods to manipulate the selection range directly, without intermediate Range calls:\n\ncollapse(node, offset) – replace selected range with a new one that starts and ends at the given node, at position offset.\nsetPosition(node, offset) – alias to collapse.\ncollapseToStart() – collapse (replace with an empty range) to selection start,\ncollapseToEnd() – collapse to selection end,\nextend(node, offset) – move focus of the selection to the given node, position offset,\nsetBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) – replace selection range with the given start anchorNode/anchorOffset and end focusNode/focusOffset. All content in-between them is selected.\nselectAllChildren(node) – select all children of the node.\ndeleteFromDocument() – remove selected content from the document.\ncontainsNode(node, allowPartialContainment = false) – checks whether the selection contains node (partially if the second argument is true)\n\nFor most tasks these methods are just fine, there’s no need to access the underlying Range object.\n\nFor example, selecting the whole contents of the paragraph <p>:\n\n\t\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  // select from 0th child of <p> to the last child\n  document.getSelection().setBaseAndExtent(p, 0, p, p.childNodes.length);\n</script>\n\nThe same thing using ranges:\n\n\t\n<p id=\"p\">Select me: <i>italic</i> and <b>bold</b></p>\n\n<script>\n  let range = new Range();\n  range.selectNodeContents(p); // or selectNode(p) to select the <p> tag too\n\n  document.getSelection().removeAllRanges(); // clear existing selection if any\n  document.getSelection().addRange(range);\n</script>\nTo select something, remove the existing selection first\n\nIf a document selection already exists, empty it first with removeAllRanges(). And then add ranges. Otherwise, all browsers except Firefox ignore new ranges.\n\nThe exception is some selection methods, that replace the existing selection, such as setBaseAndExtent.\n\nSelection in form controls\n\nForm elements, such as input and textarea provide special API for selection, without Selection or Range objects. As an input value is a pure text, not HTML, there’s no need for such objects, everything’s much simpler.\n\nProperties:\n\ninput.selectionStart – position of selection start (writeable),\ninput.selectionEnd – position of selection end (writeable),\ninput.selectionDirection – selection direction, one of: “forward”, “backward” or “none” (if e.g. selected with a double mouse click),\n\nEvents:\n\ninput.onselect – triggers when something is selected.\n\nMethods:\n\ninput.select() – selects everything in the text control (can be textarea instead of input),\n\ninput.setSelectionRange(start, end, [direction]) – change the selection to span from position start till end, in the given direction (optional).\n\ninput.setRangeText(replacement, [start], [end], [selectionMode]) – replace a range of text with the new text.\n\nOptional arguments start and end, if provided, set the range start and end, otherwise user selection is used.\n\nThe last argument, selectionMode, determines how the selection will be set after the text has been replaced. The possible values are:\n\n\"select\" – the newly inserted text will be selected.\n\"start\" – the selection range collapses just before the inserted text (the cursor will be immediately before it).\n\"end\" – the selection range collapses just after the inserted text (the cursor will be right after it).\n\"preserve\" – attempts to preserve the selection. This is the default.\n\nNow let’s see these methods in action.\n\nExample: tracking selection\n\nFor example, this code uses onselect event to track selection:\n\n\t\n<textarea id=\"area\" style=\"width:80%;height:60px\">\nSelecting in this text updates values below.\n</textarea>\n<br>\nFrom <input id=\"from\" disabled> – To <input id=\"to\" disabled>\n\n<script>\n  area.onselect = function() {\n    from.value = area.selectionStart;\n    to.value = area.selectionEnd;\n  };\n</script>\n\nPlease note:\n\nonselect triggers when something is selected, but not when the selection is removed.\ndocument.onselectionchange event should not trigger for selections inside a form control, according to the spec, as it’s not related to document selection and ranges. Some browsers generate it, but we shouldn’t rely on it.\nExample: moving cursor\n\nWe can change selectionStart and selectionEnd, that sets the selection.\n\nAn important edge case is when selectionStart and selectionEnd equal each other. Then it’s exactly the cursor position. Or, to rephrase, when nothing is selected, the selection is collapsed at the cursor position.\n\nSo, by setting selectionStart and selectionEnd to the same value, we move the cursor.\n\nFor example:\n\n\t\n<textarea id=\"area\" style=\"width:80%;height:60px\">\nFocus on me, the cursor will be at position 10.\n</textarea>\n\n<script>\n  area.onfocus = () => {\n    // zero delay setTimeout to run after browser \"focus\" action finishes\n    setTimeout(() => {\n      // we can set any selection\n      // if start=end, the cursor is exactly at that place\n      area.selectionStart = area.selectionEnd = 10;\n    });\n  };\n</script>\nExample: modifying selection\n\nTo modify the content of the selection, we can use input.setRangeText() method. Of course, we can read selectionStart/End and, with the knowledge of the selection, change the corresponding substring of value, but setRangeText is more powerful and often more convenient.\n\nThat’s a somewhat complex method. In its simplest one-argument form it replaces the user selected range and removes the selection.\n\nFor example, here the user selection will be wrapped by *...*:\n\n\t\n<input id=\"input\" style=\"width:200px\" value=\"Select here and click the button\">\n<button id=\"button\">Wrap selection in stars *...*</button>\n\n<script>\nbutton.onclick = () => {\n  if (input.selectionStart == input.selectionEnd) {\n    return; // nothing is selected\n  }\n\n  let selected = input.value.slice(input.selectionStart, input.selectionEnd);\n  input.setRangeText(`*${selected}*`);\n};\n</script>\n\nWith more arguments, we can set range start and end.\n\nIn this example we find \"THIS\" in the input text, replace it and keep the replacement selected:\n\n\t\n<input id=\"input\" style=\"width:200px\" value=\"Replace THIS in text\">\n<button id=\"button\">Replace THIS</button>\n\n<script>\nbutton.onclick = () => {\n  let pos = input.value.indexOf(\"THIS\");\n  if (pos >= 0) {\n    input.setRangeText(\"*THIS*\", pos, pos + 4, \"select\");\n    input.focus(); // focus to make selection visible\n  }\n};\n</script>\nExample: insert at cursor\n\nIf nothing is selected, or we use equal start and end in setRangeText, then the new text is just inserted, nothing is removed.\n\nWe can also insert something “at the cursor” using setRangeText.\n\nHere’s a button that inserts \"HELLO\" at the cursor position and puts the cursor immediately after it. If the selection is not empty, then it gets replaced (we can detect it by comparing selectionStart!=selectionEnd and do something else instead):\n\n\t\n<input id=\"input\" style=\"width:200px\" value=\"Text Text Text Text Text\">\n<button id=\"button\">Insert \"HELLO\" at cursor</button>\n\n<script>\n  button.onclick = () => {\n    input.setRangeText(\"HELLO\", input.selectionStart, input.selectionEnd, \"end\");\n    input.focus();\n  };\n</script>\nMaking unselectable\n\nTo make something unselectable, there are three ways:\n\nUse CSS property user-select: none.\n\n\t\n<style>\n#elem {\n  user-select: none;\n}\n</style>\n<div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n\nThis doesn’t allow the selection to start at elem. But the user may start the selection elsewhere and include elem into it.\n\nThen elem will become a part of document.getSelection(), so the selection actually happens, but its content is usually ignored in copy-paste.\n\nPrevent default action in onselectstart or mousedown events.\n\n\t\n<div>Selectable <div id=\"elem\">Unselectable</div> Selectable</div>\n\n<script>\n  elem.onselectstart = () => false;\n</script>\n\nThis prevents starting the selection on elem, but the visitor may start it at another element, then extend to elem.\n\nThat’s convenient when there’s another event handler on the same action that triggers the select (e.g. mousedown). So we disable the selection to avoid conflict, still allowing elem contents to be copied.\n\nWe can also clear the selection post-factum after it happens with document.getSelection().empty(). That’s rarely used, as this causes unwanted blinking as the selection appears-disappears.\n\nReferences\nDOM spec: Range\nSelection API\nHTML spec: APIs for the text control selections\nSummary\n\nWe covered two different APIs for selections:\n\nFor document: Selection and Range objects.\nFor input, textarea: additional methods and properties.\n\nThe second API is very simple, as it works with text.\n\nThe most used recipes are probably:\n\nGetting the selection:\nlet selection = document.getSelection();\n\nlet cloned = /* element to clone the selected nodes to */;\n\n// then apply Range methods to selection.getRangeAt(0)\n// or, like here, to all ranges to support multi-select\nfor (let i = 0; i < selection.rangeCount; i++) {\n  cloned.append(selection.getRangeAt(i).cloneContents());\n}\nSetting the selection:\nlet selection = document.getSelection();\n\n// directly:\nselection.setBaseAndExtent(...from...to...);\n\n// or we can create a range and:\nselection.removeAllRanges();\nselection.addRange(range);\n\nAnd finally, about the cursor. The cursor position in editable elements, like <textarea> is always at the start or the end of the selection. We can use it to get cursor position or to move the cursor by setting elem.selectionStart and elem.selectionEnd."
  },
  {
    "title": "Frames and windows",
    "url": "https://javascript.info/frames-and-windows",
    "html": "Popups and window methods\nCross-window communication\nThe clickjacking attack"
  },
  {
    "title": "Popups and window methods",
    "url": "https://javascript.info/popup-windows",
    "html": "A popup window is one of the oldest methods to show additional document to user.\n\nBasically, you just run:\n\nwindow.open('https://javascript.info/')\n\n…And it will open a new window with given URL. Most modern browsers are configured to open url in new tabs instead of separate windows.\n\nPopups exist from really ancient times. The initial idea was to show another content without closing the main window. As of now, there are other ways to do that: we can load content dynamically with fetch and show it in a dynamically generated <div>. So, popups is not something we use everyday.\n\nAlso, popups are tricky on mobile devices, that don’t show multiple windows simultaneously.\n\nStill, there are tasks where popups are still used, e.g. for OAuth authorization (login with Google/Facebook/…), because:\n\nA popup is a separate window which has its own independent JavaScript environment. So opening a popup from a third-party, non-trusted site is safe.\nIt’s very easy to open a popup.\nA popup can navigate (change URL) and send messages to the opener window.\nPopup blocking\n\nIn the past, evil sites abused popups a lot. A bad page could open tons of popup windows with ads. So now most browsers try to block popups and protect the user.\n\nMost browsers block popups if they are called outside of user-triggered event handlers like onclick.\n\nFor example:\n\n// popup blocked\nwindow.open('https://javascript.info');\n\n// popup allowed\nbutton.onclick = () => {\n  window.open('https://javascript.info');\n};\n\nThis way users are somewhat protected from unwanted popups, but the functionality is not disabled totally.\n\nwindow.open\n\nThe syntax to open a popup is: window.open(url, name, params):\n\nurl\nAn URL to load into the new window.\nname\nA name of the new window. Each window has a window.name, and here we can specify which window to use for the popup. If there’s already a window with such name – the given URL opens in it, otherwise a new window is opened.\nparams\nThe configuration string for the new window. It contains settings, delimited by a comma. There must be no spaces in params, for instance: width=200,height=100.\n\nSettings for params:\n\nPosition:\nleft/top (numeric) – coordinates of the window top-left corner on the screen. There is a limitation: a new window cannot be positioned offscreen.\nwidth/height (numeric) – width and height of a new window. There is a limit on minimal width/height, so it’s impossible to create an invisible window.\nWindow features:\nmenubar (yes/no) – shows or hides the browser menu on the new window.\ntoolbar (yes/no) – shows or hides the browser navigation bar (back, forward, reload etc) on the new window.\nlocation (yes/no) – shows or hides the URL field in the new window. FF and IE don’t allow to hide it by default.\nstatus (yes/no) – shows or hides the status bar. Again, most browsers force it to show.\nresizable (yes/no) – allows to disable the resize for the new window. Not recommended.\nscrollbars (yes/no) – allows to disable the scrollbars for the new window. Not recommended.\n\nThere is also a number of less supported browser-specific features, which are usually not used. Check window.open in MDN for examples.\n\nExample: a minimalistic window\n\nLet’s open a window with minimal set of features, just to see which of them browser allows to disable:\n\n\t\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=0,height=0,left=-1000,top=-1000`;\n\nopen('/', 'test', params);\n\nHere most “window features” are disabled and window is positioned offscreen. Run it and see what really happens. Most browsers “fix” odd things like zero width/height and offscreen left/top. For instance, Chrome open such a window with full width/height, so that it occupies the full screen.\n\nLet’s add normal positioning options and reasonable width, height, left, top coordinates:\n\n\t\nlet params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,\nwidth=600,height=300,left=100,top=100`;\n\nopen('/', 'test', params);\n\nMost browsers show the example above as required.\n\nRules for omitted settings:\n\nIf there is no 3rd argument in the open call, or it is empty, then the default window parameters are used.\nIf there is a string of params, but some yes/no features are omitted, then the omitted features assumed to have no value. So if you specify params, make sure you explicitly set all required features to yes.\nIf there is no left/top in params, then the browser tries to open a new window near the last opened window.\nIf there is no width/height, then the new window will be the same size as the last opened.\nAccessing popup from window\n\nThe open call returns a reference to the new window. It can be used to manipulate its properties, change location and even more.\n\nIn this example, we generate popup content from JavaScript:\n\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\"Hello, world!\");\n\nAnd here we modify the contents after loading:\n\n\t\nlet newWindow = open('/', 'example', 'width=300,height=300')\nnewWindow.focus();\n\nalert(newWindow.location.href); // (*) about:blank, loading hasn't started yet\n\nnewWindow.onload = function() {\n  let html = `<div style=\"font-size:30px\">Welcome!</div>`;\n  newWindow.document.body.insertAdjacentHTML('afterbegin', html);\n};\n\nPlease note: immediately after window.open, the new window isn’t loaded yet. That’s demonstrated by alert in line (*). So we wait for onload to modify it. We could also use DOMContentLoaded handler for newWin.document.\n\nSame origin policy\n\nWindows may freely access content of each other only if they come from the same origin (the same protocol://domain:port).\n\nOtherwise, e.g. if the main window is from site.com, and the popup from gmail.com, that’s impossible for user safety reasons. For the details, see chapter Cross-window communication.\n\nAccessing window from popup\n\nA popup may access the “opener” window as well using window.opener reference. It is null for all windows except popups.\n\nIf you run the code below, it replaces the opener (current) window content with “Test”:\n\n\t\nlet newWin = window.open(\"about:blank\", \"hello\", \"width=200,height=200\");\n\nnewWin.document.write(\n  \"<script>window.opener.document.body.innerHTML = 'Test'<\\/script>\"\n);\n\nSo the connection between the windows is bidirectional: the main window and the popup have a reference to each other.\n\nClosing a popup\n\nTo close a window: win.close().\n\nTo check if a window is closed: win.closed.\n\nTechnically, the close() method is available for any window, but window.close() is ignored by most browsers if window is not created with window.open(). So it’ll only work on a popup.\n\nThe closed property is true if the window is closed. That’s useful to check if the popup (or the main window) is still open or not. A user can close it anytime, and our code should take that possibility into account.\n\nThis code loads and then closes the window:\n\n\t\nlet newWindow = open('/', 'example', 'width=300,height=300');\n\nnewWindow.onload = function() {\n  newWindow.close();\n  alert(newWindow.closed); // true\n};\nMoving and resizing\n\nThere are methods to move/resize a window:\n\nwin.moveBy(x,y)\nMove the window relative to current position x pixels to the right and y pixels down. Negative values are allowed (to move left/up).\nwin.moveTo(x,y)\nMove the window to coordinates (x,y) on the screen.\nwin.resizeBy(width,height)\nResize the window by given width/height relative to the current size. Negative values are allowed.\nwin.resizeTo(width,height)\nResize the window to the given size.\n\nThere’s also window.onresize event.\n\nOnly popups\n\nTo prevent abuse, the browser usually blocks these methods. They only work reliably on popups that we opened, that have no additional tabs.\n\nNo minification/maximization\n\nJavaScript has no way to minify or maximize a window. These OS-level functions are hidden from Frontend-developers.\n\nMove/resize methods do not work for maximized/minimized windows.\n\nScrolling a window\n\nWe already talked about scrolling a window in the chapter Window sizes and scrolling.\n\nwin.scrollBy(x,y)\nScroll the window x pixels right and y down relative the current scroll. Negative values are allowed.\nwin.scrollTo(x,y)\nScroll the window to the given coordinates (x,y).\nelem.scrollIntoView(top = true)\nScroll the window to make elem show up at the top (the default) or at the bottom for elem.scrollIntoView(false).\n\nThere’s also window.onscroll event.\n\nFocus/blur on a window\n\nTheoretically, there are window.focus() and window.blur() methods to focus/unfocus on a window. And there are also focus/blur events that allow to catch the moment when the visitor focuses on a window and switches elsewhere.\n\nAlthough, in practice they are severely limited, because in the past evil pages abused them.\n\nFor instance, look at this code:\n\n\t\nwindow.onblur = () => window.focus();\n\nWhen a user attempts to switch out of the window (window.onblur), it brings the window back into focus. The intention is to “lock” the user within the window.\n\nSo browsers had to introduce many limitations to forbid the code like that and protect the user from ads and evils pages. They depend on the browser.\n\nFor instance, a mobile browser usually ignores window.focus() completely. Also focusing doesn’t work when a popup opens in a separate tab rather than a new window.\n\nStill, there are some use cases when such calls do work and can be useful.\n\nFor instance:\n\nWhen we open a popup, it might be a good idea to run newWindow.focus() on it. Just in case, for some OS/browser combinations it ensures that the user is in the new window now.\nIf we want to track when a visitor actually uses our web-app, we can track window.onfocus/onblur. That allows us to suspend/resume in-page activities, animations etc. But please note that the blur event means that the visitor switched out from the window, but they still may observe it. The window is in the background, but still may be visible.\nSummary\n\nPopup windows are used rarely, as there are alternatives: loading and displaying information in-page, or in iframe.\n\nIf we’re going to open a popup, a good practice is to inform the user about it. An “opening window” icon near a link or button would allow the visitor to survive the focus shift and keep both windows in mind.\n\nA popup can be opened by the open(url, name, params) call. It returns the reference to the newly opened window.\nBrowsers block open calls from the code outside of user actions. Usually a notification appears, so that a user may allow them.\nBrowsers open a new tab by default, but if sizes are provided, then it’ll be a popup window.\nThe popup may access the opener window using the window.opener property.\nThe main window and the popup can freely read and modify each other if they have the same origin. Otherwise, they can change location of each other and exchange messages.\n\nTo close the popup: use close() call. Also the user may close them (just like any other windows). The window.closed is true after that.\n\nMethods focus() and blur() allow to focus/unfocus a window. But they don’t work all the time.\nEvents focus and blur allow to track switching in and out of the window. But please note that a window may still be visible even in the background state, after blur."
  },
  {
    "title": "Resource loading: onload and onerror",
    "url": "https://javascript.info/onload-onerror",
    "html": "The browser allows us to track the loading of external resources – scripts, iframes, pictures and so on.\n\nThere are two events for it:\n\nonload – successful load,\nonerror – an error occurred.\nLoading a script\n\nLet’s say we need to load a third-party script and call a function that resides there.\n\nWe can load it dynamically, like this:\n\nlet script = document.createElement('script');\nscript.src = \"my.js\";\n\ndocument.head.append(script);\n\n…But how to run the function that is declared inside that script? We need to wait until the script loads, and only then we can call it.\n\nPlease note:\n\nFor our own scripts we could use JavaScript modules here, but they are not widely adopted by third-party libraries.\n\nscript.onload\n\nThe main helper is the load event. It triggers after the script was loaded and executed.\n\nFor instance:\n\n\t\nlet script = document.createElement('script');\n\n// can load any script, from any domain\nscript.src = \"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"\ndocument.head.append(script);\n\nscript.onload = function() {\n  // the script creates a variable \"_\"\n  alert( _.VERSION ); // shows library version\n};\n\nSo in onload we can use script variables, run functions etc.\n\n…And what if the loading failed? For instance, there’s no such script (error 404) or the server is down (unavailable).\n\nscript.onerror\n\nErrors that occur during the loading of the script can be tracked in an error event.\n\nFor instance, let’s request a script that doesn’t exist:\n\n\t\nlet script = document.createElement('script');\nscript.src = \"https://example.com/404.js\"; // no such script\ndocument.head.append(script);\n\nscript.onerror = function() {\n  alert(\"Error loading \" + this.src); // Error loading https://example.com/404.js\n};\n\nPlease note that we can’t get HTTP error details here. We don’t know if it was an error 404 or 500 or something else. Just that the loading failed.\n\nImportant:\n\nEvents onload/onerror track only the loading itself.\n\nErrors that may occur during script processing and execution are out of scope for these events. That is: if a script loaded successfully, then onload triggers, even if it has programming errors in it. To track script errors, one can use window.onerror global handler.\n\nOther resources\n\nThe load and error events also work for other resources, basically for any resource that has an external src.\n\nFor example:\n\n\t\nlet img = document.createElement('img');\nimg.src = \"https://js.cx/clipart/train.gif\"; // (*)\n\nimg.onload = function() {\n  alert(`Image loaded, size ${img.width}x${img.height}`);\n};\n\nimg.onerror = function() {\n  alert(\"Error occurred while loading image\");\n};\n\nThere are some notes though:\n\nMost resources start loading when they are added to the document. But <img> is an exception. It starts loading when it gets a src (*).\nFor <iframe>, the iframe.onload event triggers when the iframe loading finished, both for successful load and in case of an error.\n\nThat’s for historical reasons.\n\nCrossorigin policy\n\nThere’s a rule: scripts from one site can’t access contents of the other site. So, e.g. a script at https://facebook.com can’t read the user’s mailbox at https://gmail.com.\n\nOr, to be more precise, one origin (domain/port/protocol triplet) can’t access the content from another one. So even if we have a subdomain, or just another port, these are different origins with no access to each other.\n\nThis rule also affects resources from other domains.\n\nIf we’re using a script from another domain, and there’s an error in it, we can’t get error details.\n\nFor example, let’s take a script error.js that consists of a single (bad) function call:\n\n// 📁 error.js\nnoSuchFunction();\n\nNow load it from the same site where it’s located:\n\n\t\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"/article/onload-onerror/crossorigin/error.js\"></script>\n\nWe can see a good error report, like this:\n\nUncaught ReferenceError: noSuchFunction is not defined\nhttps://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1\n\nNow let’s load the same script from another domain:\n\n\t\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n\nThe report is different, like this:\n\nScript error.\n, 0:0\n\nDetails may vary depending on the browser, but the idea is the same: any information about the internals of a script, including error stack traces, is hidden. Exactly because it’s from another domain.\n\nWhy do we need error details?\n\nThere are many services (and we can build our own) that listen for global errors using window.onerror, save errors and provide an interface to access and analyze them. That’s great, as we can see real errors, triggered by our users. But if a script comes from another origin, then there’s not much information about errors in it, as we’ve just seen.\n\nSimilar cross-origin policy (CORS) is enforced for other types of resources as well.\n\nTo allow cross-origin access, the <script> tag needs to have the crossorigin attribute, plus the remote server must provide special headers.\n\nThere are three levels of cross-origin access:\n\nNo crossorigin attribute – access prohibited.\ncrossorigin=\"anonymous\" – access allowed if the server responds with the header Access-Control-Allow-Origin with * or our origin. Browser does not send authorization information and cookies to remote server.\ncrossorigin=\"use-credentials\" – access allowed if the server sends back the header Access-Control-Allow-Origin with our origin and Access-Control-Allow-Credentials: true. Browser sends authorization information and cookies to remote server.\nPlease note:\n\nYou can read more about cross-origin access in the chapter Fetch: Cross-Origin Requests. It describes the fetch method for network requests, but the policy is exactly the same.\n\nSuch thing as “cookies” is out of our current scope, but you can read about them in the chapter Cookies, document.cookie.\n\nIn our case, we didn’t have any crossorigin attribute. So the cross-origin access was prohibited. Let’s add it.\n\nWe can choose between \"anonymous\" (no cookies sent, one server-side header needed) and \"use-credentials\" (sends cookies too, two server-side headers needed).\n\nIf we don’t care about cookies, then \"anonymous\" is the way to go:\n\n\t\n<script>\nwindow.onerror = function(message, url, line, col, errorObj) {\n  alert(`${message}\\n${url}, ${line}:${col}`);\n};\n</script>\n<script crossorigin=\"anonymous\" src=\"https://cors.javascript.info/article/onload-onerror/crossorigin/error.js\"></script>\n\nNow, assuming that the server provides an Access-Control-Allow-Origin header, everything’s fine. We have the full error report.\n\nSummary\n\nImages <img>, external styles, scripts and other resources provide load and error events to track their loading:\n\nload triggers on a successful load,\nerror triggers on a failed load.\n\nThe only exception is <iframe>: for historical reasons it always triggers load, for any load completion, even if the page is not found.\n\nThe readystatechange event also works for resources, but is rarely used, because load/error events are simpler.\n\nTasks\nLoad images with a callback\nimportance: 4\n\nNormally, images are loaded when they are created. So when we add <img> to the page, the user does not see the picture immediately. The browser needs to load it first.\n\nTo show an image immediately, we can create it “in advance”, like this:\n\nlet img = document.createElement('img');\nimg.src = 'my.jpg';\n\nThe browser starts loading the image and remembers it in the cache. Later, when the same image appears in the document (no matter how), it shows up immediately.\n\nCreate a function preloadImages(sources, callback) that loads all images from the array sources and, when ready, runs callback.\n\nFor instance, this will show an alert after the images are loaded:\n\nfunction loaded() {\n  alert(\"Images loaded\")\n}\n\npreloadImages([\"1.jpg\", \"2.jpg\", \"3.jpg\"], loaded);\n\nIn case of an error, the function should still assume the picture “loaded”.\n\nIn other words, the callback is executed when all images are either loaded or errored out.\n\nThe function is useful, for instance, when we plan to show a gallery with many scrollable images, and want to be sure that all images are loaded.\n\nIn the source document you can find links to test images, and also the code to check whether they are loaded or not. It should output 300.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Mutation observer",
    "url": "https://javascript.info/mutation-observer",
    "html": "MutationObserver is a built-in object that observes a DOM element and fires a callback when it detects a change.\n\nWe’ll first take a look at the syntax, and then explore a real-world use case, to see where such thing may be useful.\n\nSyntax\n\nMutationObserver is easy to use.\n\nFirst, we create an observer with a callback-function:\n\nlet observer = new MutationObserver(callback);\n\nAnd then attach it to a DOM node:\n\nobserver.observe(node, config);\n\nconfig is an object with boolean options “what kind of changes to react on”:\n\nchildList – changes in the direct children of node,\nsubtree – in all descendants of node,\nattributes – attributes of node,\nattributeFilter – an array of attribute names, to observe only selected ones.\ncharacterData – whether to observe node.data (text content),\n\nFew other options:\n\nattributeOldValue – if true, pass both the old and the new value of attribute to callback (see below), otherwise only the new one (needs attributes option),\ncharacterDataOldValue – if true, pass both the old and the new value of node.data to callback (see below), otherwise only the new one (needs characterData option).\n\nThen after any changes, the callback is executed: changes are passed in the first argument as a list of MutationRecord objects, and the observer itself as the second argument.\n\nMutationRecord objects have properties:\n\ntype – mutation type, one of\n\"attributes\": attribute modified\n\"characterData\": data modified, used for text nodes,\n\"childList\": child elements added/removed,\ntarget – where the change occurred: an element for \"attributes\", or text node for \"characterData\", or an element for a \"childList\" mutation,\naddedNodes/removedNodes – nodes that were added/removed,\npreviousSibling/nextSibling – the previous and next sibling to added/removed nodes,\nattributeName/attributeNamespace – the name/namespace (for XML) of the changed attribute,\noldValue – the previous value, only for attribute or text changes, if the corresponding option is set attributeOldValue/characterDataOldValue.\n\nFor example, here’s a <div> with a contentEditable attribute. That attribute allows us to focus on it and edit.\n\n\t\n<div contentEditable id=\"elem\">Click and <b>edit</b>, please</div>\n\n<script>\nlet observer = new MutationObserver(mutationRecords => {\n  console.log(mutationRecords); // console.log(the changes)\n});\n\n// observe everything except attributes\nobserver.observe(elem, {\n  childList: true, // observe direct children\n  subtree: true, // and lower descendants too\n  characterDataOldValue: true // pass old data to callback\n});\n</script>\n\nIf we run this code in the browser, then focus on the given <div> and change the text inside <b>edit</b>, console.log will show one mutation:\n\nmutationRecords = [{\n  type: \"characterData\",\n  oldValue: \"edit\",\n  target: <text node>,\n  // other properties empty\n}];\n\nIf we make more complex editing operations, e.g. remove the <b>edit</b>, the mutation event may contain multiple mutation records:\n\nmutationRecords = [{\n  type: \"childList\",\n  target: <div#elem>,\n  removedNodes: [<b>],\n  nextSibling: <text node>,\n  previousSibling: <text node>\n  // other properties empty\n}, {\n  type: \"characterData\"\n  target: <text node>\n  // ...mutation details depend on how the browser handles such removal\n  // it may coalesce two adjacent text nodes \"edit \" and \", please\" into one node\n  // or it may leave them separate text nodes\n}];\n\nSo, MutationObserver allows to react on any changes within DOM subtree.\n\nUsage for integration\n\nWhen such thing may be useful?\n\nImagine the situation when you need to add a third-party script that contains useful functionality, but also does something unwanted, e.g. shows ads <div class=\"ads\">Unwanted ads</div>.\n\nNaturally, the third-party script provides no mechanisms to remove it.\n\nUsing MutationObserver, we can detect when the unwanted element appears in our DOM and remove it.\n\nThere are other situations when a third-party script adds something into our document, and we’d like to detect, when it happens, to adapt our page, dynamically resize something etc.\n\nMutationObserver allows to implement this.\n\nUsage for architecture\n\nThere are also situations when MutationObserver is good from architectural standpoint.\n\nLet’s say we’re making a website about programming. Naturally, articles and other materials may contain source code snippets.\n\nSuch snippet in an HTML markup looks like this:\n\n...\n<pre class=\"language-javascript\"><code>\n  // here's the code\n  let hello = \"world\";\n</code></pre>\n...\n\nFor better readability and at the same time, to beautify it, we’ll be using a JavaScript syntax highlighting library on our site, like Prism.js. To get syntax highlighting for above snippet in Prism, Prism.highlightElem(pre) is called, which examines the contents of such pre elements and adds special tags and styles for colored syntax highlighting into those elements, similar to what you see in examples here, on this page.\n\nWhen exactly should we run that highlighting method? Well, we can do it on DOMContentLoaded event, or put the script at the bottom of the page. The moment our DOM is ready, we can search for elements pre[class*=\"language\"] and call Prism.highlightElem on them:\n\n// highlight all code snippets on the page\ndocument.querySelectorAll('pre[class*=\"language\"]').forEach(Prism.highlightElem);\n\nEverything’s simple so far, right? We find code snippets in HTML and highlight them.\n\nNow let’s go on. Let’s say we’re going to dynamically fetch materials from a server. We’ll study methods for that later in the tutorial. For now it only matters that we fetch an HTML article from a webserver and display it on demand:\n\nlet article = /* fetch new content from server */\narticleElem.innerHTML = article;\n\nThe new article HTML may contain code snippets. We need to call Prism.highlightElem on them, otherwise they won’t get highlighted.\n\nWhere and when to call Prism.highlightElem for a dynamically loaded article?\n\nWe could append that call to the code that loads an article, like this:\n\nlet article = /* fetch new content from server */\narticleElem.innerHTML = article;\n\nlet snippets = articleElem.querySelectorAll('pre[class*=\"language-\"]');\nsnippets.forEach(Prism.highlightElem);\n\n…But, imagine if we have many places in the code where we load our content – articles, quizzes, forum posts, etc. Do we need to put the highlighting call everywhere, to highlight the code in content after loading? That’s not very convenient.\n\nAnd what if the content is loaded by a third-party module? For example, we have a forum written by someone else, that loads content dynamically, and we’d like to add syntax highlighting to it. No one likes patching third-party scripts.\n\nLuckily, there’s another option.\n\nWe can use MutationObserver to automatically detect when code snippets are inserted into the page and highlight them.\n\nSo we’ll handle the highlighting functionality in one place, relieving us from the need to integrate it.\n\nDynamic highlight demo\n\nHere’s the working example.\n\nIf you run this code, it starts observing the element below and highlighting any code snippets that appear there:\n\n\t\nlet observer = new MutationObserver(mutations => {\n\n  for(let mutation of mutations) {\n    // examine new nodes, is there anything to highlight?\n\n    for(let node of mutation.addedNodes) {\n      // we track only elements, skip other nodes (e.g. text nodes)\n      if (!(node instanceof HTMLElement)) continue;\n\n      // check the inserted element for being a code snippet\n      if (node.matches('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(node);\n      }\n\n      // or maybe there's a code snippet somewhere in its subtree?\n      for(let elem of node.querySelectorAll('pre[class*=\"language-\"]')) {\n        Prism.highlightElement(elem);\n      }\n    }\n  }\n\n});\n\nlet demoElem = document.getElementById('highlight-demo');\n\nobserver.observe(demoElem, {childList: true, subtree: true});\n\nHere, below, there’s an HTML-element and JavaScript that dynamically fills it using innerHTML.\n\nPlease run the previous code (above, observes that element), and then the code below. You’ll see how MutationObserver detects and highlights the snippet.\n\nA demo-element with id=\"highlight-demo\", run the code above to observe it.\n\nThe following code populates its innerHTML, that causes the MutationObserver to react and highlight its contents:\n\n\t\nlet demoElem = document.getElementById('highlight-demo');\n\n// dynamically insert content with code snippets\ndemoElem.innerHTML = `A code snippet is below:\n  <pre class=\"language-javascript\"><code> let hello = \"world!\"; </code></pre>\n  <div>Another one:</div>\n  <div>\n    <pre class=\"language-css\"><code>.class { margin: 5px; } </code></pre>\n  </div>\n`;\n\nNow we have MutationObserver that can track all highlighting in observed elements or the whole document. We can add/remove code snippets in HTML without thinking about it.\n\nAdditional methods\n\nThere’s a method to stop observing the node:\n\nobserver.disconnect() – stops the observation.\n\nWhen we stop the observing, it might be possible that some changes were not yet processed by the observer. In such cases, we use\n\nobserver.takeRecords() – gets a list of unprocessed mutation records – those that happened, but the callback has not handled them.\n\nThese methods can be used together, like this:\n\n// get a list of unprocessed mutations\n// should be called before disconnecting,\n// if you care about possibly unhandled recent mutations\nlet mutationRecords = observer.takeRecords();\n\n// stop tracking changes\nobserver.disconnect();\n...\nRecords returned by observer.takeRecords() are removed from the processing queue\n\nThe callback won’t be called for records, returned by observer.takeRecords().\n\nGarbage collection interaction\n\nObservers use weak references to nodes internally. That is, if a node is removed from the DOM, and becomes unreachable, then it can be garbage collected.\n\nThe mere fact that a DOM node is observed doesn’t prevent the garbage collection.\n\nSummary\n\nMutationObserver can react to changes in DOM – attributes, text content and adding/removing elements.\n\nWe can use it to track changes introduced by other parts of our code, as well as to integrate with third-party scripts.\n\nMutationObserver can track any changes. The config “what to observe” options are used for optimizations, not to spend resources on unneeded callback invocations."
  },
  {
    "title": "Miscellaneous",
    "url": "https://javascript.info/ui-misc",
    "html": "Mutation observer\nSelection and Range\nEvent loop: microtasks and macrotasks"
  },
  {
    "title": "Page: DOMContentLoaded, load, beforeunload, unload",
    "url": "https://javascript.info/onload-ondomcontentloaded",
    "html": "The lifecycle of an HTML page has three important events:\n\nDOMContentLoaded – the browser fully loaded HTML, and the DOM tree is built, but external resources like pictures <img> and stylesheets may not yet have loaded.\nload – not only HTML is loaded, but also all the external resources: images, styles etc.\nbeforeunload/unload – the user is leaving the page.\n\nEach event may be useful:\n\nDOMContentLoaded event – DOM is ready, so the handler can lookup DOM nodes, initialize the interface.\nload event – external resources are loaded, so styles are applied, image sizes are known etc.\nbeforeunload event – the user is leaving: we can check if the user saved the changes and ask them whether they really want to leave.\nunload – the user almost left, but we still can initiate some operations, such as sending out statistics.\n\nLet’s explore the details of these events.\n\nDOMContentLoaded\n\nThe DOMContentLoaded event happens on the document object.\n\nWe must use addEventListener to catch it:\n\ndocument.addEventListener(\"DOMContentLoaded\", ready);\n// not \"document.onDOMContentLoaded = ...\"\n\nFor instance:\n\n\t\n<script>\n  function ready() {\n    alert('DOM is ready');\n\n    // image is not yet loaded (unless it was cached), so the size is 0x0\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  }\n\n  document.addEventListener(\"DOMContentLoaded\", ready);\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\n\nIn the example, the DOMContentLoaded handler runs when the document is loaded, so it can see all the elements, including <img> below.\n\nBut it doesn’t wait for the image to load. So alert shows zero sizes.\n\nAt first sight, the DOMContentLoaded event is very simple. The DOM tree is ready – here’s the event. There are few peculiarities though.\n\nDOMContentLoaded and scripts\n\nWhen the browser processes an HTML-document and comes across a <script> tag, it needs to execute before continuing building the DOM. That’s a precaution, as scripts may want to modify DOM, and even document.write into it, so DOMContentLoaded has to wait.\n\nSo DOMContentLoaded definitely happens after such scripts:\n\n\t\n<script>\n  document.addEventListener(\"DOMContentLoaded\", () => {\n    alert(\"DOM ready!\");\n  });\n</script>\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\"></script>\n\n<script>\n  alert(\"Library loaded, inline script executed\");\n</script>\n\nIn the example above, we first see “Library loaded…”, and then “DOM ready!” (all scripts are executed).\n\nScripts that don’t block DOMContentLoaded\n\nThere are two exceptions from this rule:\n\nScripts with the async attribute, that we’ll cover a bit later, don’t block DOMContentLoaded.\nScripts that are generated dynamically with document.createElement('script') and then added to the webpage also don’t block this event.\nDOMContentLoaded and styles\n\nExternal style sheets don’t affect DOM, so DOMContentLoaded does not wait for them.\n\nBut there’s a pitfall. If we have a script after the style, then that script must wait until the stylesheet loads:\n\n\t\n<link type=\"text/css\" rel=\"stylesheet\" href=\"style.css\">\n<script>\n  // the script doesn't execute until the stylesheet is loaded\n  alert(getComputedStyle(document.body).marginTop);\n</script>\n\nThe reason for this is that the script may want to get coordinates and other style-dependent properties of elements, like in the example above. Naturally, it has to wait for styles to load.\n\nAs DOMContentLoaded waits for scripts, it now waits for styles before them as well.\n\nBuilt-in browser autofill\n\nFirefox, Chrome and Opera autofill forms on DOMContentLoaded.\n\nFor instance, if the page has a form with login and password, and the browser remembered the values, then on DOMContentLoaded it may try to autofill them (if approved by the user).\n\nSo if DOMContentLoaded is postponed by long-loading scripts, then autofill also awaits. You probably saw that on some sites (if you use browser autofill) – the login/password fields don’t get autofilled immediately, but there’s a delay till the page fully loads. That’s actually the delay until the DOMContentLoaded event.\n\nwindow.onload\n\nThe load event on the window object triggers when the whole page is loaded including styles, images and other resources. This event is available via the onload property.\n\nThe example below correctly shows image sizes, because window.onload waits for all images:\n\n\t\n<script>\n  window.onload = function() { // can also use window.addEventListener('load', (event) => {\n    alert('Page loaded');\n\n    // image is loaded at this time\n    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);\n  };\n</script>\n\n<img id=\"img\" src=\"https://en.js.cx/clipart/train.gif?speed=1&cache=0\">\nwindow.onunload\n\nWhen a visitor leaves the page, the unload event triggers on window. We can do something there that doesn’t involve a delay, like closing related popup windows.\n\nThe notable exception is sending analytics.\n\nLet’s say we gather data about how the page is used: mouse clicks, scrolls, viewed page areas, and so on.\n\nNaturally, unload event is when the user leaves us, and we’d like to save the data on our server.\n\nThere exists a special navigator.sendBeacon(url, data) method for such needs, described in the specification https://w3c.github.io/beacon/.\n\nIt sends the data in background. The transition to another page is not delayed: the browser leaves the page, but still performs sendBeacon.\n\nHere’s how to use it:\n\nlet analyticsData = { /* object with gathered data */ };\n\nwindow.addEventListener(\"unload\", function() {\n  navigator.sendBeacon(\"/analytics\", JSON.stringify(analyticsData));\n});\nThe request is sent as POST.\nWe can send not only a string, but also forms and other formats, as described in the chapter Fetch, but usually it’s a stringified object.\nThe data is limited by 64kb.\n\nWhen the sendBeacon request is finished, the browser probably has already left the document, so there’s no way to get server response (which is usually empty for analytics).\n\nThere’s also a keepalive flag for doing such “after-page-left” requests in fetch method for generic network requests. You can find more information in the chapter Fetch API.\n\nIf we want to cancel the transition to another page, we can’t do it here. But we can use another event – onbeforeunload.\n\nwindow.onbeforeunload\n\nIf a visitor initiated navigation away from the page or tries to close the window, the beforeunload handler asks for additional confirmation.\n\nIf we cancel the event, the browser may ask the visitor if they are sure.\n\nYou can try it by running this code and then reloading the page:\n\n\t\nwindow.onbeforeunload = function() {\n  return false;\n};\n\nFor historical reasons, returning a non-empty string also counts as canceling the event. Some time ago browsers used to show it as a message, but as the modern specification says, they shouldn’t.\n\nHere’s an example:\n\n\t\nwindow.onbeforeunload = function() {\n  return \"There are unsaved changes. Leave now?\";\n};\n\nThe behavior was changed, because some webmasters abused this event handler by showing misleading and annoying messages. So right now old browsers still may show it as a message, but aside of that – there’s no way to customize the message shown to the user.\n\nThe event.preventDefault() doesn’t work from a beforeunload handler\n\nThat may sound weird, but most browsers ignore event.preventDefault().\n\nWhich means, following code may not work:\n\n\t\nwindow.addEventListener(\"beforeunload\", (event) => {\n  // doesn't work, so this event handler doesn't do anything\n  event.preventDefault();\n});\n\nInstead, in such handlers one should set event.returnValue to a string to get the result similar to the code above:\n\n\t\nwindow.addEventListener(\"beforeunload\", (event) => {\n  // works, same as returning from window.onbeforeunload\n  event.returnValue = \"There are unsaved changes. Leave now?\";\n});\nreadyState\n\nWhat happens if we set the DOMContentLoaded handler after the document is loaded?\n\nNaturally, it never runs.\n\nThere are cases when we are not sure whether the document is ready or not. We’d like our function to execute when the DOM is loaded, be it now or later.\n\nThe document.readyState property tells us about the current loading state.\n\nThere are 3 possible values:\n\n\"loading\" – the document is loading.\n\"interactive\" – the document was fully read.\n\"complete\" – the document was fully read and all resources (like images) are loaded too.\n\nSo we can check document.readyState and setup a handler or execute the code immediately if it’s ready.\n\nLike this:\n\nfunction work() { /*...*/ }\n\nif (document.readyState == 'loading') {\n  // still loading, wait for the event\n  document.addEventListener('DOMContentLoaded', work);\n} else {\n  // DOM is ready!\n  work();\n}\n\nThere’s also the readystatechange event that triggers when the state changes, so we can print all these states like this:\n\n\t\n// current state\nconsole.log(document.readyState);\n\n// print state changes\ndocument.addEventListener('readystatechange', () => console.log(document.readyState));\n\nThe readystatechange event is an alternative mechanics of tracking the document loading state, it appeared long ago. Nowadays, it is rarely used.\n\nLet’s see the full events flow for the completeness.\n\nHere’s a document with <iframe>, <img> and handlers that log events:\n\n<script>\n  log('initial readyState:' + document.readyState);\n\n  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));\n  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));\n\n  window.onload = () => log('window onload');\n</script>\n\n<iframe src=\"iframe.html\" onload=\"log('iframe onload')\"></iframe>\n\n<img src=\"https://en.js.cx/clipart/train.gif\" id=\"img\">\n<script>\n  img.onload = () => log('img onload');\n</script>\n\nThe working example is in the sandbox.\n\nThe typical output:\n\n[1] initial readyState:loading\n[2] readyState:interactive\n[2] DOMContentLoaded\n[3] iframe onload\n[4] img onload\n[4] readyState:complete\n[4] window onload\n\nThe numbers in square brackets denote the approximate time of when it happens. Events labeled with the same digit happen approximately at the same time (± a few ms).\n\ndocument.readyState becomes interactive right before DOMContentLoaded. These two things actually mean the same.\ndocument.readyState becomes complete when all resources (iframe and img) are loaded. Here we can see that it happens in about the same time as img.onload (img is the last resource) and window.onload. Switching to complete state means the same as window.onload. The difference is that window.onload always works after all other load handlers.\nSummary\n\nPage load events:\n\nThe DOMContentLoaded event triggers on document when the DOM is ready. We can apply JavaScript to elements at this stage.\nScript such as <script>...</script> or <script src=\"...\"></script> block DOMContentLoaded, the browser waits for them to execute.\nImages and other resources may also still continue loading.\nThe load event on window triggers when the page and all resources are loaded. We rarely use it, because there’s usually no need to wait for so long.\nThe beforeunload event on window triggers when the user wants to leave the page. If we cancel the event, browser asks whether the user really wants to leave (e.g we have unsaved changes).\nThe unload event on window triggers when the user is finally leaving, in the handler we can only do simple things that do not involve delays or asking a user. Because of that limitation, it’s rarely used. We can send out a network request with navigator.sendBeacon.\ndocument.readyState is the current state of the document, changes can be tracked in the readystatechange event:\nloading – the document is loading.\ninteractive – the document is parsed, happens at about the same time as DOMContentLoaded, but before it.\ncomplete – the document and resources are loaded, happens at about the same time as window.onload, but before it."
  },
  {
    "title": "Forms: event and method submit",
    "url": "https://javascript.info/forms-submit",
    "html": "The submit event triggers when the form is submitted, it is usually used to validate the form before sending it to the server or to abort the submission and process it in JavaScript.\n\nThe method form.submit() allows to initiate form sending from JavaScript. We can use it to dynamically create and send our own forms to server.\n\nLet’s see more details of them.\n\nEvent: submit\n\nThere are two main ways to submit a form:\n\nThe first – to click <input type=\"submit\"> or <input type=\"image\">.\nThe second – press Enter on an input field.\n\nBoth actions lead to submit event on the form. The handler can check the data, and if there are errors, show them and call event.preventDefault(), then the form won’t be sent to the server.\n\nIn the form below:\n\nGo into the text field and press Enter.\nClick <input type=\"submit\">.\n\nBoth actions show alert and the form is not sent anywhere due to return false:\n\n<form onsubmit=\"alert('submit!');return false\">\n  First: Enter in the input field <input type=\"text\" value=\"text\"><br>\n  Second: Click \"submit\": <input type=\"submit\" value=\"Submit\">\n</form>\nRelation between submit and click\n\nWhen a form is sent using Enter on an input field, a click event triggers on the <input type=\"submit\">.\n\nThat’s rather funny, because there was no click at all.\n\nHere’s the demo:\n\n<form onsubmit=\"return false\">\n <input type=\"text\" size=\"30\" value=\"Focus here and press enter\">\n <input type=\"submit\" value=\"Submit\" onclick=\"alert('click')\">\n</form>\nMethod: submit\n\nTo submit a form to the server manually, we can call form.submit().\n\nThen the submit event is not generated. It is assumed that if the programmer calls form.submit(), then the script already did all related processing.\n\nSometimes that’s used to manually create and send a form, like this:\n\n\t\nlet form = document.createElement('form');\nform.action = 'https://google.com/search';\nform.method = 'GET';\n\nform.innerHTML = '<input name=\"q\" value=\"test\">';\n\n// the form must be in the document to submit it\ndocument.body.append(form);\n\nform.submit();\nTasks\nModal form\nimportance: 5\n\nCreate a function showPrompt(html, callback) that shows a form with the message html, an input field and buttons OK/CANCEL.\n\nA user should type something into a text field and press Enter or the OK button, then callback(value) is called with the value they entered.\nOtherwise if the user presses Esc or CANCEL, then callback(null) is called.\n\nIn both cases that ends the input process and removes the form.\n\nRequirements:\n\nThe form should be in the center of the window.\nThe form is modal. In other words, no interaction with the rest of the page is possible until the user closes it.\nWhen the form is shown, the focus should be inside the <input> for the user.\nKeys Tab/Shift+Tab should shift the focus between form fields, don’t allow it to leave for other page elements.\n\nUsage example:\n\nshowPrompt(\"Enter something<br>...smart :)\", function(value) {\n  alert(value);\n});\n\nA demo in the iframe:\n\nP.S. The source document has HTML/CSS for the form with fixed positioning, but it’s up to you to make it modal.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Focusing: focus/blur",
    "url": "https://javascript.info/focus-blur",
    "html": "An element receives the focus when the user either clicks on it or uses the Tab key on the keyboard. There’s also an autofocus HTML attribute that puts the focus onto an element by default when a page loads and other means of getting the focus.\n\nFocusing on an element generally means: “prepare to accept the data here”, so that’s the moment when we can run the code to initialize the required functionality.\n\nThe moment of losing the focus (“blur”) can be even more important. That’s when a user clicks somewhere else or presses Tab to go to the next form field, or there are other means as well.\n\nLosing the focus generally means: “the data has been entered”, so we can run the code to check it or even to save it to the server and so on.\n\nThere are important peculiarities when working with focus events. We’ll do the best to cover them further on.\n\nEvents focus/blur\n\nThe focus event is called on focusing, and blur – when the element loses the focus.\n\nLet’s use them for validation of an input field.\n\nIn the example below:\n\nThe blur handler checks if the field has an email entered, and if not – shows an error.\nThe focus handler hides the error message (on blur it will be checked again):\n\t\n<style>\n  .invalid { border-color: red; }\n  #error { color: red }\n</style>\n\nYour email please: <input type=\"email\" id=\"input\">\n\n<div id=\"error\"></div>\n\n<script>\ninput.onblur = function() {\n  if (!input.value.includes('@')) { // not email\n    input.classList.add('invalid');\n    error.innerHTML = 'Please enter a correct email.'\n  }\n};\n\ninput.onfocus = function() {\n  if (this.classList.contains('invalid')) {\n    // remove the \"error\" indication, because the user wants to re-enter something\n    this.classList.remove('invalid');\n    error.innerHTML = \"\";\n  }\n};\n</script>\n\nModern HTML allows us to do many validations using input attributes: required, pattern and so on. And sometimes they are just what we need. JavaScript can be used when we want more flexibility. Also we could automatically send the changed value to the server if it’s correct.\n\nMethods focus/blur\n\nMethods elem.focus() and elem.blur() set/unset the focus on the element.\n\nFor instance, let’s make the visitor unable to leave the input if the value is invalid:\n\n\t\n<style>\n  .error {\n    background: red;\n  }\n</style>\n\nYour email please: <input type=\"email\" id=\"input\">\n<input type=\"text\" style=\"width:220px\" placeholder=\"make email invalid and try to focus here\">\n\n<script>\n  input.onblur = function() {\n    if (!this.value.includes('@')) { // not email\n      // show the error\n      this.classList.add(\"error\");\n      // ...and put the focus back\n      input.focus();\n    } else {\n      this.classList.remove(\"error\");\n    }\n  };\n</script>\n\nIt works in all browsers except Firefox (bug).\n\nIf we enter something into the input and then try to use Tab or click away from the <input>, then onblur returns the focus back.\n\nPlease note that we can’t “prevent losing focus” by calling event.preventDefault() in onblur, because onblur works after the element lost the focus.\n\nIn practice though, one should think well, before implementing something like this, because we generally should show errors to the user, but should not prevent their progress in filling our form. They may want to fill other fields first.\n\nJavaScript-initiated focus loss\n\nA focus loss can occur for many reasons.\n\nOne of them is when the visitor clicks somewhere else. But also JavaScript itself may cause it, for instance:\n\nAn alert moves focus to itself, so it causes the focus loss at the element (blur event), and when the alert is dismissed, the focus comes back (focus event).\nIf an element is removed from DOM, then it also causes the focus loss. If it is reinserted later, then the focus doesn’t return.\n\nThese features sometimes cause focus/blur handlers to misbehave – to trigger when they are not needed.\n\nThe best recipe is to be careful when using these events. If we want to track user-initiated focus-loss, then we should avoid causing it ourselves.\n\nAllow focusing on any element: tabindex\n\nBy default, many elements do not support focusing.\n\nThe list varies a bit between browsers, but one thing is always correct: focus/blur support is guaranteed for elements that a visitor can interact with: <button>, <input>, <select>, <a> and so on.\n\nOn the other hand, elements that exist to format something, such as <div>, <span>, <table> – are unfocusable by default. The method elem.focus() doesn’t work on them, and focus/blur events are never triggered.\n\nThis can be changed using HTML-attribute tabindex.\n\nAny element becomes focusable if it has tabindex. The value of the attribute is the order number of the element when Tab (or something like that) is used to switch between them.\n\nThat is: if we have two elements, the first has tabindex=\"1\", and the second has tabindex=\"2\", then pressing Tab while in the first element – moves the focus into the second one.\n\nThe switch order is: elements with tabindex from 1 and above go first (in the tabindex order), and then elements without tabindex (e.g. a regular <input>).\n\nElements without matching tabindex are switched in the document source order (the default order).\n\nThere are two special values:\n\ntabindex=\"0\" puts an element among those without tabindex. That is, when we switch elements, elements with tabindex=0 go after elements with tabindex ≥ 1.\n\nUsually it’s used to make an element focusable, but keep the default switching order. To make an element a part of the form on par with <input>.\n\ntabindex=\"-1\" allows only programmatic focusing on an element. The Tab key ignores such elements, but method elem.focus() works.\n\nFor instance, here’s a list. Click the first item and press Tab:\n\nClick the first item and press Tab. Keep track of the order. Please note that many subsequent Tabs can move the focus out of the iframe in the example.\n<ul>\n  <li tabindex=\"1\">One</li>\n  <li tabindex=\"0\">Zero</li>\n  <li tabindex=\"2\">Two</li>\n  <li tabindex=\"-1\">Minus one</li>\n</ul>\n\n<style>\n  li { cursor: pointer; }\n  :focus { outline: 1px dashed green; }\n</style>\n\nThe order is like this: 1 - 2 - 0. Normally, <li> does not support focusing, but tabindex full enables it, along with events and styling with :focus.\n\nThe property elem.tabIndex works too\n\nWe can add tabindex from JavaScript by using the elem.tabIndex property. That has the same effect.\n\nDelegation: focusin/focusout\n\nEvents focus and blur do not bubble.\n\nFor instance, we can’t put onfocus on the <form> to highlight it, like this:\n\n<!-- on focusing in the form -- add the class -->\n<form onfocus=\"this.className='focused'\">\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\nThe example above doesn’t work, because when user focuses on an <input>, the focus event triggers on that input only. It doesn’t bubble up. So form.onfocus never triggers.\n\nThere are two solutions.\n\nFirst, there’s a funny historical feature: focus/blur do not bubble up, but propagate down on the capturing phase.\n\nThis will work:\n\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n  // put the handler on capturing phase (last argument true)\n  form.addEventListener(\"focus\", () => form.classList.add('focused'), true);\n  form.addEventListener(\"blur\", () => form.classList.remove('focused'), true);\n</script>\n\nSecond, there are focusin and focusout events – exactly the same as focus/blur, but they bubble.\n\nNote that they must be assigned using elem.addEventListener, not on<event>.\n\nSo here’s another working variant:\n\n<form id=\"form\">\n  <input type=\"text\" name=\"name\" value=\"Name\">\n  <input type=\"text\" name=\"surname\" value=\"Surname\">\n</form>\n\n<style> .focused { outline: 1px solid red; } </style>\n\n<script>\n  form.addEventListener(\"focusin\", () => form.classList.add('focused'));\n  form.addEventListener(\"focusout\", () => form.classList.remove('focused'));\n</script>\nSummary\n\nEvents focus and blur trigger on an element focusing/losing focus.\n\nTheir specials are:\n\nThey do not bubble. Can use capturing state instead or focusin/focusout.\nMost elements do not support focus by default. Use tabindex to make anything focusable.\n\nThe current focused element is available as document.activeElement.\n\nTasks\nEditable div\nimportance: 5\n\nCreate a <div> that turns into <textarea> when clicked.\n\nThe textarea allows to edit the HTML in the <div>.\n\nWhen the user presses Enter or it loses focus, the <textarea> turns back into <div>, and its content becomes HTML in <div>.\n\nDemo in new window\n\nOpen a sandbox for the task.\n\nsolution\nEdit TD on click\nimportance: 5\n\nMake table cells editable on click.\n\nOn click – the cell should become “editable” (textarea appears inside), we can change HTML. There should be no resize, all geometry should remain the same.\nButtons OK and CANCEL appear below the cell to finish/cancel the editing.\nOnly one cell may be editable at a moment. While a <td> is in “edit mode”, clicks on other cells are ignored.\nThe table may have many cells. Use event delegation.\n\nThe demo:\n\nOpen a sandbox for the task.\n\nsolution\nKeyboard-driven mouse\nimportance: 4\n\nFocus on the mouse. Then use arrow keys to move it:\n\nDemo in new window\n\nP.S. Don’t put event handlers anywhere except the #mouse element.\n\nP.P.S. Don’t modify HTML/CSS, the approach should be generic and work with any element.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Document and resource loading",
    "url": "https://javascript.info/loading",
    "html": "Page: DOMContentLoaded, load, beforeunload, unload\nScripts: async, defer\nResource loading: onload and onerror"
  },
  {
    "title": "Events: change, input, cut, copy, paste",
    "url": "https://javascript.info/events-change-input",
    "html": "Let’s cover various events that accompany data updates.\n\nEvent: change\n\nThe change event triggers when the element has finished changing.\n\nFor text inputs that means that the event occurs when it loses focus.\n\nFor instance, while we are typing in the text field below – there’s no event. But when we move the focus somewhere else, for instance, click on a button – there will be a change event:\n\n\t\n<input type=\"text\" onchange=\"alert(this.value)\">\n<input type=\"button\" value=\"Button\">\n\nFor other elements: select, input type=checkbox/radio it triggers right after the selection changes:\n\n\t\n<select onchange=\"alert(this.value)\">\n  <option value=\"\">Select something</option>\n  <option value=\"1\">Option 1</option>\n  <option value=\"2\">Option 2</option>\n  <option value=\"3\">Option 3</option>\n</select>\nEvent: input\n\nThe input event triggers every time after a value is modified by the user.\n\nUnlike keyboard events, it triggers on any value change, even those that does not involve keyboard actions: pasting with a mouse or using speech recognition to dictate the text.\n\nFor instance:\n\n\t\n<input type=\"text\" id=\"input\"> oninput: <span id=\"result\"></span>\n<script>\n  input.oninput = function() {\n    result.innerHTML = input.value;\n  };\n</script>\n\nIf we want to handle every modification of an <input> then this event is the best choice.\n\nOn the other hand, input event doesn’t trigger on keyboard input and other actions that do not involve value change, e.g. pressing arrow keys ⇦ ⇨ while in the input.\n\nCan’t prevent anything in oninput\n\nThe input event occurs after the value is modified.\n\nSo we can’t use event.preventDefault() there – it’s just too late, there would be no effect.\n\nEvents: cut, copy, paste\n\nThese events occur on cutting/copying/pasting a value.\n\nThey belong to ClipboardEvent class and provide access to the data that is cut/copied/pasted.\n\nWe also can use event.preventDefault() to abort the action, then nothing gets copied/pasted.\n\nFor instance, the code below prevents all cut/copy/paste events and shows the text we’re trying to cut/copy/paste:\n\n\t\n<input type=\"text\" id=\"input\">\n<script>\n  input.onpaste = function(event) {\n    alert(\"paste: \" + event.clipboardData.getData('text/plain'));\n    event.preventDefault();\n  };\n\n  input.oncut = input.oncopy = function(event) {\n    alert(event.type + '-' + document.getSelection());\n    event.preventDefault();\n  };\n</script>\n\nPlease note: inside cut and copy event handlers a call to event.clipboardData.getData(...) returns an empty string. That’s because technically the data isn’t in the clipboard yet. If we use event.preventDefault() it won’t be copied at all.\n\nSo the example above uses document.getSelection() to get the selected text. You can find more details about document selection in the article Selection and Range.\n\nIt’s possible to copy/paste not just text, but everything. For instance, we can copy a file in the OS file manager, and paste it.\n\nThat’s because clipboardData implements DataTransfer interface, commonly used for drag’n’drop and copy/pasting. It’s a bit beyond our scope now, but you can find its methods in the DataTransfer specification.\n\nAlso, there’s an additional asynchronous API of accessing the clipboard: navigator.clipboard. More about it in the specification Clipboard API and events, not supported by Firefox.\n\nSafety restrictions\n\nThe clipboard is a “global” OS-level thing. A user may switch between various applications, copy/paste different things, and a browser page shouldn’t see all that.\n\nSo most browsers allow seamless read/write access to the clipboard only in the scope of certain user actions, such as copying/pasting etc.\n\nIt’s forbidden to generate “custom” clipboard events with dispatchEvent in all browsers except Firefox. And even if we manage to dispatch such event, the specification clearly states that such “syntetic” events must not provide access to the clipboard.\n\nEven if someone decides to save event.clipboardData in an event handler, and then access it later – it won’t work.\n\nTo reiterate, event.clipboardData works solely in the context of user-initiated event handlers.\n\nOn the other hand, navigator.clipboard is the more recent API, meant for use in any context. It asks for user permission, if needed.\n\nSummary\n\nData change events:\n\nEvent\tDescription\tSpecials\nchange\tA value was changed.\tFor text inputs triggers on focus loss.\ninput\tFor text inputs on every change.\tTriggers immediately unlike change.\ncut/copy/paste\tCut/copy/paste actions.\tThe action can be prevented. The event.clipboardData property gives access to the clipboard. All browsers except Firefox also support navigator.clipboard.\nTasks\nDeposit calculator\nimportance: 5\n\nCreate an interface that allows to enter a sum of bank deposit and percentage, then calculates how much it will be after given periods of time.\n\nHere’s the demo:\n\nAny input change should be processed immediately.\n\nThe formula is:\n\n// initial: the initial money sum\n// interest: e.g. 0.05 means 5% per year\n// years: how many years to wait\nlet result = Math.round(initial * (1 + interest) ** years);\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Form properties and methods",
    "url": "https://javascript.info/form-elements",
    "html": "Forms and control elements, such as <input> have a lot of special properties and events.\n\nWorking with forms will be much more convenient when we learn them.\n\nNavigation: form and elements\n\nDocument forms are members of the special collection document.forms.\n\nThat’s a so-called “named collection”: it’s both named and ordered. We can use both the name or the number in the document to get the form.\n\ndocument.forms.my; // the form with name=\"my\"\ndocument.forms[0]; // the first form in the document\n\nWhen we have a form, then any element is available in the named collection form.elements.\n\nFor instance:\n\n\t\n<form name=\"my\">\n  <input name=\"one\" value=\"1\">\n  <input name=\"two\" value=\"2\">\n</form>\n\n<script>\n  // get the form\n  let form = document.forms.my; // <form name=\"my\"> element\n\n  // get the element\n  let elem = form.elements.one; // <input name=\"one\"> element\n\n  alert(elem.value); // 1\n</script>\n\nThere may be multiple elements with the same name. This is typical with radio buttons and checkboxes.\n\nIn that case, form.elements[name] is a collection. For instance:\n\n\t\n<form>\n  <input type=\"radio\" name=\"age\" value=\"10\">\n  <input type=\"radio\" name=\"age\" value=\"20\">\n</form>\n\n<script>\nlet form = document.forms[0];\n\nlet ageElems = form.elements.age;\n\nalert(ageElems[0]); // [object HTMLInputElement]\n</script>\n\nThese navigation properties do not depend on the tag structure. All control elements, no matter how deep they are in the form, are available in form.elements.\n\nFieldsets as “subforms”\n\nA form may have one or many <fieldset> elements inside it. They also have elements property that lists form controls inside them.\n\nFor instance:\n\n\t\n<body>\n  <form id=\"form\">\n    <fieldset name=\"userFields\">\n      <legend>info</legend>\n      <input name=\"login\" type=\"text\">\n    </fieldset>\n  </form>\n\n  <script>\n    alert(form.elements.login); // <input name=\"login\">\n\n    let fieldset = form.elements.userFields;\n    alert(fieldset); // HTMLFieldSetElement\n\n    // we can get the input by name both from the form and from the fieldset\n    alert(fieldset.elements.login == form.elements.login); // true\n  </script>\n</body>\nShorter notation: form.name\n\nThere’s a shorter notation: we can access the element as form[index/name].\n\nIn other words, instead of form.elements.login we can write form.login.\n\nThat also works, but there’s a minor issue: if we access an element, and then change its name, then it is still available under the old name (as well as under the new one).\n\nThat’s easy to see in an example:\n\n\t\n<form id=\"form\">\n  <input name=\"login\">\n</form>\n\n<script>\n  alert(form.elements.login == form.login); // true, the same <input>\n\n  form.login.name = \"username\"; // change the name of the input\n\n  // form.elements updated the name:\n  alert(form.elements.login); // undefined\n  alert(form.elements.username); // input\n\n  // form allows both names: the new one and the old one\n  alert(form.username == form.login); // true\n</script>\n\nThat’s usually not a problem, however, because we rarely change names of form elements.\n\nBackreference: element.form\n\nFor any element, the form is available as element.form. So a form references all elements, and elements reference the form.\n\nHere’s the picture:\n\nFor instance:\n\n\t\n<form id=\"form\">\n  <input type=\"text\" name=\"login\">\n</form>\n\n<script>\n  // form -> element\n  let login = form.login;\n\n  // element -> form\n  alert(login.form); // HTMLFormElement\n</script>\nForm elements\n\nLet’s talk about form controls.\n\ninput and textarea\n\nWe can access their value as input.value (string) or input.checked (boolean) for checkboxes and radio buttons.\n\nLike this:\n\ninput.value = \"New value\";\ntextarea.value = \"New text\";\n\ninput.checked = true; // for a checkbox or radio button\nUse textarea.value, not textarea.innerHTML\n\nPlease note that even though <textarea>...</textarea> holds its value as nested HTML, we should never use textarea.innerHTML to access it.\n\nIt stores only the HTML that was initially on the page, not the current value.\n\nselect and option\n\nA <select> element has 3 important properties:\n\nselect.options – the collection of <option> subelements,\nselect.value – the value of the currently selected <option>,\nselect.selectedIndex – the number of the currently selected <option>.\n\nThey provide three different ways of setting a value for a <select>:\n\nFind the corresponding <option> element (e.g. among select.options) and set its option.selected to true.\nIf we know a new value: set select.value to the new value.\nIf we know the new option number: set select.selectedIndex to that number.\n\nHere is an example of all three methods:\n\n\t\n<select id=\"select\">\n  <option value=\"apple\">Apple</option>\n  <option value=\"pear\">Pear</option>\n  <option value=\"banana\">Banana</option>\n</select>\n\n<script>\n  // all three lines do the same thing\n  select.options[2].selected = true;\n  select.selectedIndex = 2;\n  select.value = 'banana';\n  // please note: options start from zero, so index 2 means the 3rd option.\n</script>\n\nUnlike most other controls, <select> allows to select multiple options at once if it has multiple attribute. This attribute is rarely used, though.\n\nFor multiple selected values, use the first way of setting values: add/remove the selected property from <option> subelements.\n\nHere’s an example of how to get selected values from a multi-select:\n\n\t\n<select id=\"select\" multiple>\n  <option value=\"blues\" selected>Blues</option>\n  <option value=\"rock\" selected>Rock</option>\n  <option value=\"classic\">Classic</option>\n</select>\n\n<script>\n  // get all selected values from multi-select\n  let selected = Array.from(select.options)\n    .filter(option => option.selected)\n    .map(option => option.value);\n\n  alert(selected); // blues,rock\n</script>\n\nThe full specification of the <select> element is available in the specification https://html.spec.whatwg.org/multipage/forms.html#the-select-element.\n\nnew Option\n\nIn the specification there’s a nice short syntax to create an <option> element:\n\noption = new Option(text, value, defaultSelected, selected);\n\nThis syntax is optional. We can use document.createElement('option') and set attributes manually. Still, it may be shorter, so here are the parameters:\n\ntext – the text inside the option,\nvalue – the option value,\ndefaultSelected – if true, then selected HTML-attribute is created,\nselected – if true, then the option is selected.\n\nThe difference between defaultSelected and selected is that defaultSelected sets the HTML-attribute (that we can get using option.getAttribute('selected'), while selected sets whether the option is selected or not.\n\nIn practice, one should usually set both values to true or false. (Or, simply omit them; both default to false.)\n\nFor instance, here’s a new “unselected” option:\n\nlet option = new Option(\"Text\", \"value\");\n// creates <option value=\"value\">Text</option>\n\nThe same option, but selected:\n\nlet option = new Option(\"Text\", \"value\", true, true);\n\nOption elements have properties:\n\noption.selected\nIs the option selected.\noption.index\nThe number of the option among the others in its <select>.\noption.text\nText content of the option (seen by the visitor).\nReferences\nSpecification: https://html.spec.whatwg.org/multipage/forms.html.\nSummary\n\nForm navigation:\n\ndocument.forms\nA form is available as document.forms[name/index].\nform.elements\nForm elements are available as form.elements[name/index], or can use just form[name/index]. The elements property also works for <fieldset>.\nelement.form\nElements reference their form in the form property.\n\nValue is available as input.value, textarea.value, select.value, etc. (For checkboxes and radio buttons, use input.checked to determine whether a value is selected.)\n\nFor <select>, one can also get the value by the index select.selectedIndex or through the options collection select.options.\n\nThese are the basics to start working with forms. We’ll meet many examples further in the tutorial.\n\nIn the next chapter we’ll cover focus and blur events that may occur on any element, but are mostly handled on forms.\n\nTasks\nAdd an option to select\nimportance: 5\n\nThere’s a <select>:\n\n<select id=\"genres\">\n  <option value=\"rock\">Rock</option>\n  <option value=\"blues\" selected>Blues</option>\n</select>\n\nUse JavaScript to:\n\nShow the value and the text of the selected option.\nAdd an option: <option value=\"classic\">Classic</option>.\nMake it selected.\n\nNote, if you’ve done everything right, your alert should show blues.\n\nsolution"
  },
  {
    "title": "Scrolling",
    "url": "https://javascript.info/onscroll",
    "html": "The scroll event allows reacting to a page or element scrolling. There are quite a few good things we can do here.\n\nFor instance:\n\nShow/hide additional controls or information depending on where in the document the user is.\nLoad more data when the user scrolls down till the end of the page.\n\nHere’s a small function to show the current scroll:\n\nwindow.addEventListener('scroll', function() {\n  document.getElementById('showScroll').innerHTML = window.pageYOffset + 'px';\n});\n\nIn action:\n\nCurrent scroll = scroll the window\n\nThe scroll event works both on the window and on scrollable elements.\n\nPrevent scrolling\n\nHow do we make something unscrollable?\n\nWe can’t prevent scrolling by using event.preventDefault() in onscroll listener, because it triggers after the scroll has already happened.\n\nBut we can prevent scrolling by event.preventDefault() on an event that causes the scroll, for instance keydown event for pageUp and pageDown.\n\nIf we add an event handler to these events and event.preventDefault() in it, then the scroll won’t start.\n\nThere are many ways to initiate a scroll, so it’s more reliable to use CSS, overflow property.\n\nHere are few tasks that you can solve or look through to see applications of onscroll.\n\nTasks\nEndless page\nimportance: 5\n\nCreate an endless page. When a visitor scrolls it to the end, it auto-appends current date-time to the text (so that a visitor can scroll more).\n\nLike this:\n\nPlease note two important features of the scroll:\n\nThe scroll is “elastic”. We can scroll a little beyond the document start or end in some browsers/devices (empty space below is shown, and then the document will automatically “bounces back” to normal).\nThe scroll is imprecise. When we scroll to page end, then we may be in fact like 0-50px away from the real document bottom.\n\nSo, “scrolling to the end” should mean that the visitor is no more than 100px away from the document end.\n\nP.S. In real life we may want to show “more messages” or “more goods”.\n\nOpen a sandbox for the task.\n\nsolution\nUp/down button\nimportance: 5\n\nCreate a “to the top” button to help with page scrolling.\n\nIt should work like this:\n\nWhile the page is not scrolled down at least for the window height – it’s invisible.\nWhen the page is scrolled down more than the window height – there appears an “upwards” arrow in the left-top corner. If the page is scrolled back, it disappears.\nWhen the arrow is clicked, the page scrolls to the top.\n\nLike this (top-left corner, scroll to see):\n\nOpen a sandbox for the task.\n\nsolution\nLoad visible images\nimportance: 4\n\nLet’s say we have a slow-speed client and want to save their mobile traffic.\n\nFor that purpose we decide not to show images immediately, but rather replace them with placeholders, like this:\n\n<img src=\"placeholder.svg\" width=\"128\" height=\"128\" data-src=\"real.jpg\">\n\nSo, initially all images are placeholder.svg. When the page scrolls to the position where the user can see the image – we change src to the one in data-src, and so the image loads.\n\nHere’s an example in iframe:\n\nScroll it to see images load “on-demand”.\n\nRequirements:\n\nWhen the page loads, those images that are on-screen should load immediately, prior to any scrolling.\nSome images may be regular, without data-src. The code should not touch them.\nOnce an image is loaded, it should not reload any more when scrolled in/out.\n\nP.S. If you can, make a more advanced solution that would “preload” images that are one page below/after the current position.\n\nP.P.S. Only vertical scroll is to be handled, no horizontal scrolling.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Moving the mouse: mouseover/out, mouseenter/leave",
    "url": "https://javascript.info/mousemove-mouseover-mouseout-mouseenter-mouseleave",
    "html": "Let’s dive into more details about events that happen when the mouse moves between elements.\n\nEvents mouseover/mouseout, relatedTarget\n\nThe mouseover event occurs when a mouse pointer comes over an element, and mouseout – when it leaves.\n\nThese events are special, because they have property relatedTarget. This property complements target. When a mouse leaves one element for another, one of them becomes target, and the other one – relatedTarget.\n\nFor mouseover:\n\nevent.target – is the element where the mouse came over.\nevent.relatedTarget – is the element from which the mouse came (relatedTarget → target).\n\nFor mouseout the reverse:\n\nevent.target – is the element that the mouse left.\nevent.relatedTarget – is the new under-the-pointer element, that mouse left for (target → relatedTarget).\n\nIn the example below each face and its features are separate elements. When you move the mouse, you can see mouse events in the text area.\n\nEach event has the information about both target and relatedTarget:\n\nResultscript.jsstyle.cssindex.html\n\t\nrelatedTarget can be null\n\nThe relatedTarget property can be null.\n\nThat’s normal and just means that the mouse came not from another element, but from out of the window. Or that it left the window.\n\nWe should keep that possibility in mind when using event.relatedTarget in our code. If we access event.relatedTarget.tagName, then there will be an error.\n\nSkipping elements\n\nThe mousemove event triggers when the mouse moves. But that doesn’t mean that every pixel leads to an event.\n\nThe browser checks the mouse position from time to time. And if it notices changes then triggers the events.\n\nThat means that if the visitor is moving the mouse very fast then some DOM-elements may be skipped:\n\nIf the mouse moves very fast from #FROM to #TO elements as painted above, then intermediate <div> elements (or some of them) may be skipped. The mouseout event may trigger on #FROM and then immediately mouseover on #TO.\n\nThat’s good for performance, because there may be many intermediate elements. We don’t really want to process in and out of each one.\n\nOn the other hand, we should keep in mind that the mouse pointer doesn’t “visit” all elements along the way. It can “jump”.\n\nIn particular, it’s possible that the pointer jumps right inside the middle of the page from out of the window. In that case relatedTarget is null, because it came from “nowhere”:\n\nYou can check it out “live” on a teststand below.\n\nIts HTML has two nested elements: the <div id=\"child\"> is inside the <div id=\"parent\">. If you move the mouse fast over them, then maybe only the child div triggers events, or maybe the parent one, or maybe there will be no events at all.\n\nAlso move the pointer into the child div, and then move it out quickly down through the parent one. If the movement is fast enough, then the parent element is ignored. The mouse will cross the parent element without noticing it.\n\nResultscript.jsstyle.cssindex.html\n\t\nIf mouseover triggered, there must be mouseout\n\nIn case of fast mouse movements, intermediate elements may be ignored, but one thing we know for sure: if the pointer “officially” entered an element (mouseover event generated), then upon leaving it we always get mouseout.\n\nMouseout when leaving for a child\n\nAn important feature of mouseout – it triggers, when the pointer moves from an element to its descendant, e.g. from #parent to #child in this HTML:\n\n<div id=\"parent\">\n  <div id=\"child\">...</div>\n</div>\n\nIf we’re on #parent and then move the pointer deeper into #child, we get mouseout on #parent!\n\nThat may seem strange, but can be easily explained.\n\nAccording to the browser logic, the mouse cursor may be only over a single element at any time – the most nested one and top by z-index.\n\nSo if it goes to another element (even a descendant), then it leaves the previous one.\n\nPlease note another important detail of event processing.\n\nThe mouseover event on a descendant bubbles up. So, if #parent has mouseover handler, it triggers:\n\nYou can see that very well in the example below: <div id=\"child\"> is inside the <div id=\"parent\">. There are mouseover/out handlers on #parent element that output event details.\n\nIf you move the mouse from #parent to #child, you see two events on #parent:\n\nmouseout [target: parent] (left the parent), then\nmouseover [target: child] (came to the child, bubbled).\nResultscript.jsstyle.cssindex.html\n\t\n\nAs shown, when the pointer moves from #parent element to #child, two handlers trigger on the parent element: mouseout and mouseover:\n\nparent.onmouseout = function(event) {\n  /* event.target: parent element */\n};\nparent.onmouseover = function(event) {\n  /* event.target: child element (bubbled) */\n};\n\nIf we don’t examine event.target inside the handlers, then it may seem that the mouse pointer left #parent element, and then immediately came back over it.\n\nBut that’s not the case! The pointer is still over the parent, it just moved deeper into the child element.\n\nIf there are some actions upon leaving the parent element, e.g. an animation runs in parent.onmouseout, we usually don’t want it when the pointer just goes deeper into #parent.\n\nTo avoid it, we can check relatedTarget in the handler and, if the mouse is still inside the element, then ignore such event.\n\nAlternatively we can use other events: mouseenter and mouseleave, that we’ll be covering now, as they don’t have such problems.\n\nEvents mouseenter and mouseleave\n\nEvents mouseenter/mouseleave are like mouseover/mouseout. They trigger when the mouse pointer enters/leaves the element.\n\nBut there are two important differences:\n\nTransitions inside the element, to/from descendants, are not counted.\nEvents mouseenter/mouseleave do not bubble.\n\nThese events are extremely simple.\n\nWhen the pointer enters an element – mouseenter triggers. The exact location of the pointer inside the element or its descendants doesn’t matter.\n\nWhen the pointer leaves an element – mouseleave triggers.\n\nThis example is similar to the one above, but now the top element has mouseenter/mouseleave instead of mouseover/mouseout.\n\nAs you can see, the only generated events are the ones related to moving the pointer in and out of the top element. Nothing happens when the pointer goes to the child and back. Transitions between descendants are ignored\n\nResultscript.jsstyle.cssindex.html\n\t\nEvent delegation\n\nEvents mouseenter/leave are very simple and easy to use. But they do not bubble. So we can’t use event delegation with them.\n\nImagine we want to handle mouse enter/leave for table cells. And there are hundreds of cells.\n\nThe natural solution would be – to set the handler on <table> and process events there. But mouseenter/leave don’t bubble. So if such event happens on <td>, then only a handler on that <td> is able to catch it.\n\nHandlers for mouseenter/leave on <table> only trigger when the pointer enters/leaves the table as a whole. It’s impossible to get any information about transitions inside it.\n\nSo, let’s use mouseover/mouseout.\n\nLet’s start with simple handlers that highlight the element under mouse:\n\n// let's highlight an element under the pointer\ntable.onmouseover = function(event) {\n  let target = event.target;\n  target.style.background = 'pink';\n};\n\ntable.onmouseout = function(event) {\n  let target = event.target;\n  target.style.background = '';\n};\n\nHere they are in action. As the mouse travels across the elements of this table, the current one is highlighted:\n\nResultscript.jsstyle.cssindex.html\n\t\n\nIn our case we’d like to handle transitions between table cells <td>: entering a cell and leaving it. Other transitions, such as inside the cell or outside of any cells, don’t interest us. Let’s filter them out.\n\nHere’s what we can do:\n\nRemember the currently highlighted <td> in a variable, let’s call it currentElem.\nOn mouseover – ignore the event if we’re still inside the current <td>.\nOn mouseout – ignore if we didn’t leave the current <td>.\n\nHere’s an example of code that accounts for all possible situations:\n\n// <td> under the mouse right now (if any)\nlet currentElem = null;\n\ntable.onmouseover = function(event) {\n  // before entering a new element, the mouse always leaves the previous one\n  // if currentElem is set, we didn't leave the previous <td>,\n  // that's a mouseover inside it, ignore the event\n  if (currentElem) return;\n\n  let target = event.target.closest('td');\n\n  // we moved not into a <td> - ignore\n  if (!target) return;\n\n  // moved into <td>, but outside of our table (possible in case of nested tables)\n  // ignore\n  if (!table.contains(target)) return;\n\n  // hooray! we entered a new <td>\n  currentElem = target;\n  onEnter(currentElem);\n};\n\n\ntable.onmouseout = function(event) {\n  // if we're outside of any <td> now, then ignore the event\n  // that's probably a move inside the table, but out of <td>,\n  // e.g. from <tr> to another <tr>\n  if (!currentElem) return;\n\n  // we're leaving the element – where to? Maybe to a descendant?\n  let relatedTarget = event.relatedTarget;\n\n  while (relatedTarget) {\n    // go up the parent chain and check – if we're still inside currentElem\n    // then that's an internal transition – ignore it\n    if (relatedTarget == currentElem) return;\n\n    relatedTarget = relatedTarget.parentNode;\n  }\n\n  // we left the <td>. really.\n  onLeave(currentElem);\n  currentElem = null;\n};\n\n// any functions to handle entering/leaving an element\nfunction onEnter(elem) {\n  elem.style.background = 'pink';\n\n  // show that in textarea\n  text.value += `over -> ${currentElem.tagName}.${currentElem.className}\\n`;\n  text.scrollTop = 1e6;\n}\n\nfunction onLeave(elem) {\n  elem.style.background = '';\n\n  // show that in textarea\n  text.value += `out <- ${elem.tagName}.${elem.className}\\n`;\n  text.scrollTop = 1e6;\n}\n\nOnce again, the important features are:\n\nIt uses event delegation to handle entering/leaving of any <td> inside the table. So it relies on mouseover/out instead of mouseenter/leave that don’t bubble and hence allow no delegation.\nExtra events, such as moving between descendants of <td> are filtered out, so that onEnter/Leave runs only if the pointer leaves or enters <td> as a whole.\n\nHere’s the full example with all details:\n\nResultscript.jsstyle.cssindex.html\n\t\n\nTry to move the cursor in and out of table cells and inside them. Fast or slow – doesn’t matter. Only <td> as a whole is highlighted, unlike the example before.\n\nSummary\n\nWe covered events mouseover, mouseout, mousemove, mouseenter and mouseleave.\n\nThese things are good to note:\n\nA fast mouse move may skip intermediate elements.\nEvents mouseover/out and mouseenter/leave have an additional property: relatedTarget. That’s the element that we are coming from/to, complementary to target.\n\nEvents mouseover/out trigger even when we go from the parent element to a child element. The browser assumes that the mouse can be only over one element at one time – the deepest one.\n\nEvents mouseenter/leave are different in that aspect: they only trigger when the mouse comes in and out the element as a whole. Also they do not bubble.\n\nTasks\nImproved tooltip behavior\nimportance: 5\n\nWrite JavaScript that shows a tooltip over an element with the attribute data-tooltip. The value of this attribute should become the tooltip text.\n\nThat’s like the task Tooltip behavior, but here the annotated elements can be nested. The most deeply nested tooltip is shown.\n\nOnly one tooltip may show up at the same time.\n\nFor instance:\n\n<div data-tooltip=\"Here – is the house interior\" id=\"house\">\n  <div data-tooltip=\"Here – is the roof\" id=\"roof\"></div>\n  ...\n  <a href=\"https://en.wikipedia.org/wiki/The_Three_Little_Pigs\" data-tooltip=\"Read on…\">Hover over me</a>\n</div>\n\nThe result in iframe:\n\nOpen a sandbox for the task.\n\nsolution\n\"Smart\" tooltip\nimportance: 5\n\nWrite a function that shows a tooltip over an element only if the visitor moves the mouse to it, but not through it.\n\nIn other words, if the visitor moves the mouse to the element and stops there – show the tooltip. And if they just moved the mouse through, then no need, who wants extra blinking?\n\nTechnically, we can measure the mouse speed over the element, and if it’s slow then we assume that it comes “over the element” and show the tooltip, if it’s fast – then we ignore it.\n\nMake a universal object new HoverIntent(options) for it.\n\nIts options:\n\nelem – element to track.\nover – a function to call if the mouse came to the element: that is, it moves slowly or stopped over it.\nout – a function to call when the mouse leaves the element (if over was called).\n\nAn example of using such object for the tooltip:\n\n// a sample tooltip\nlet tooltip = document.createElement('div');\ntooltip.className = \"tooltip\";\ntooltip.innerHTML = \"Tooltip\";\n\n// the object will track mouse and call over/out\nnew HoverIntent({\n  elem,\n  over() {\n    tooltip.style.left = elem.getBoundingClientRect().left + 'px';\n    tooltip.style.top = elem.getBoundingClientRect().bottom + 5 + 'px';\n    document.body.append(tooltip);\n  },\n  out() {\n    tooltip.remove();\n  }\n});\n\nThe demo:\n\nIf you move the mouse over the “clock” fast then nothing happens, and if you do it slow or stop on them, then there will be a tooltip.\n\nPlease note: the tooltip doesn’t “blink” when the cursor moves between the clock subelements.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Forms, controls",
    "url": "https://javascript.info/forms-controls",
    "html": "Special properties and events for forms <form> and controls: <input>, <select> and other.\n\nForm properties and methods\nFocusing: focus/blur\nEvents: change, input, cut, copy, paste\nForms: event and method submit"
  },
  {
    "title": "Keyboard: keydown and keyup",
    "url": "https://javascript.info/keyboard-events",
    "html": "Before we get to keyboard, please note that on modern devices there are other ways to “input something”. For instance, people use speech recognition (especially on mobile devices) or copy/paste with the mouse.\n\nSo if we want to track any input into an <input> field, then keyboard events are not enough. There’s another event named input to track changes of an <input> field, by any means. And it may be a better choice for such task. We’ll cover it later in the chapter Events: change, input, cut, copy, paste.\n\nKeyboard events should be used when we want to handle keyboard actions (virtual keyboard also counts). For instance, to react on arrow keys Up and Down or hotkeys (including combinations of keys).\n\nTeststand\n\nTo better understand keyboard events, you can use the teststand below.\n\nTry different key combinations in the text field.\n\nResultscript.jsstyle.cssindex.html\n\t\nKeydown and keyup\n\nThe keydown events happens when a key is pressed down, and then keyup – when it’s released.\n\nevent.code and event.key\n\nThe key property of the event object allows to get the character, while the code property of the event object allows to get the “physical key code”.\n\nFor instance, the same key Z can be pressed with or without Shift. That gives us two different characters: lowercase z and uppercase Z.\n\nThe event.key is exactly the character, and it will be different. But event.code is the same:\n\nKey\tevent.key\tevent.code\nZ\tz (lowercase)\tKeyZ\nShift+Z\tZ (uppercase)\tKeyZ\n\nIf a user works with different languages, then switching to another language would make a totally different character instead of \"Z\". That will become the value of event.key, while event.code is always the same: \"KeyZ\".\n\n“KeyZ” and other key codes\n\nEvery key has the code that depends on its location on the keyboard. Key codes described in the UI Events code specification.\n\nFor instance:\n\nLetter keys have codes \"Key<letter>\": \"KeyA\", \"KeyB\" etc.\nDigit keys have codes: \"Digit<number>\": \"Digit0\", \"Digit1\" etc.\nSpecial keys are coded by their names: \"Enter\", \"Backspace\", \"Tab\" etc.\n\nThere are several widespread keyboard layouts, and the specification gives key codes for each of them.\n\nRead the alphanumeric section of the spec for more codes, or just press a key in the teststand above.\n\nCase matters: \"KeyZ\", not \"keyZ\"\n\nSeems obvious, but people still make mistakes.\n\nPlease evade mistypes: it’s KeyZ, not keyZ. The check like event.code==\"keyZ\" won’t work: the first letter of \"Key\" must be uppercase.\n\nWhat if a key does not give any character? For instance, Shift or F1 or others. For those keys, event.key is approximately the same as event.code:\n\nKey\tevent.key\tevent.code\nF1\tF1\tF1\nBackspace\tBackspace\tBackspace\nShift\tShift\tShiftRight or ShiftLeft\n\nPlease note that event.code specifies exactly which key is pressed. For instance, most keyboards have two Shift keys: on the left and on the right side. The event.code tells us exactly which one was pressed, and event.key is responsible for the “meaning” of the key: what it is (a “Shift”).\n\nLet’s say, we want to handle a hotkey: Ctrl+Z (or Cmd+Z for Mac). Most text editors hook the “Undo” action on it. We can set a listener on keydown and check which key is pressed.\n\nThere’s a dilemma here: in such a listener, should we check the value of event.key or event.code?\n\nOn one hand, the value of event.key is a character, it changes depending on the language. If the visitor has several languages in OS and switches between them, the same key gives different characters. So it makes sense to check event.code, it’s always the same.\n\nLike this:\n\n\t\ndocument.addEventListener('keydown', function(event) {\n  if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {\n    alert('Undo!')\n  }\n});\n\nOn the other hand, there’s a problem with event.code. For different keyboard layouts, the same key may have different characters.\n\nFor example, here are US layout (“QWERTY”) and German layout (“QWERTZ”) under it (from Wikipedia):\n\nFor the same key, US layout has “Z”, while German layout has “Y” (letters are swapped).\n\nLiterally, event.code will equal KeyZ for people with German layout when they press Y.\n\nIf we check event.code == 'KeyZ' in our code, then for people with German layout such test will pass when they press Y.\n\nThat sounds really odd, but so it is. The specification explicitly mentions such behavior.\n\nSo, event.code may match a wrong character for unexpected layout. Same letters in different layouts may map to different physical keys, leading to different codes. Luckily, that happens only with several codes, e.g. keyA, keyQ, keyZ (as we’ve seen), and doesn’t happen with special keys such as Shift. You can find the list in the specification.\n\nTo reliably track layout-dependent characters, event.key may be a better way.\n\nOn the other hand, event.code has the benefit of staying always the same, bound to the physical key location. So hotkeys that rely on it work well even in case of a language switch.\n\nDo we want to handle layout-dependant keys? Then event.key is the way to go.\n\nOr we want a hotkey to work even after a language switch? Then event.code may be better.\n\nAuto-repeat\n\nIf a key is being pressed for a long enough time, it starts to “auto-repeat”: the keydown triggers again and again, and then when it’s released we finally get keyup. So it’s kind of normal to have many keydown and a single keyup.\n\nFor events triggered by auto-repeat, the event object has event.repeat property set to true.\n\nDefault actions\n\nDefault actions vary, as there are many possible things that may be initiated by the keyboard.\n\nFor instance:\n\nA character appears on the screen (the most obvious outcome).\nA character is deleted (Delete key).\nThe page is scrolled (PageDown key).\nThe browser opens the “Save Page” dialog (Ctrl+S)\n…and so on.\n\nPreventing the default action on keydown can cancel most of them, with the exception of OS-based special keys. For instance, on Windows Alt+F4 closes the current browser window. And there’s no way to stop it by preventing the default action in JavaScript.\n\nFor instance, the <input> below expects a phone number, so it does not accept keys except digits, +, () or -:\n\n\t\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') || ['+','(',')','-'].includes(key);\n}\n</script>\n<input onkeydown=\"return checkPhoneKey(event.key)\" placeholder=\"Phone, please\" type=\"tel\">\n\nThe onkeydown handler here uses checkPhoneKey to check for the key pressed. If it’s valid (from 0..9 or one of +-()), then it returns true, otherwise false.\n\nAs we know, the false value returned from the event handler, assigned using a DOM property or an attribute, such as above, prevents the default action, so nothing appears in the <input> for keys that don’t pass the test. (The true value returned doesn’t affect anything, only returning false matters)\n\nPlease note that special keys, such as Backspace, Left, Right, do not work in the input. That’s a side effect of the strict filter checkPhoneKey. These keys make it return false.\n\nLet’s relax the filter a little bit by allowing arrow keys Left, Right and Delete, Backspace:\n\n\t\n<script>\nfunction checkPhoneKey(key) {\n  return (key >= '0' && key <= '9') ||\n    ['+','(',')','-','ArrowLeft','ArrowRight','Delete','Backspace'].includes(key);\n}\n</script>\n<input onkeydown=\"return checkPhoneKey(event.key)\" placeholder=\"Phone, please\" type=\"tel\">\n\nNow arrows and deletion works well.\n\nEven though we have the key filter, one still can enter anything using a mouse and right-click + Paste. Mobile devices provide other means to enter values. So the filter is not 100% reliable.\n\nThe alternative approach would be to track the oninput event – it triggers after any modification. There we can check the new input.value and modify it/highlight the <input> when it’s invalid. Or we can use both event handlers together.\n\nLegacy\n\nIn the past, there was a keypress event, and also keyCode, charCode, which properties of the event object.\n\nThere were so many browser incompatibilities while working with them, that developers of the specification had no way, other than deprecating all of them and creating new, modern events (described above in this chapter). The old code still works, as browsers keep supporting them, but there’s totally no need to use those any more.\n\nMobile Keyboards\n\nWhen using virtual/mobile keyboards, formally known as IME (Input-Method Editor), the W3C standard states that a KeyboardEvent’s e.keyCode should be 229 and e.key should be \"Unidentified\".\n\nWhile some of these keyboards might still use the right values for e.key, e.code, e.keyCode… when pressing certain keys such as arrows or backspace, there’s no guarantee, so your keyboard logic might not always work on mobile devices.\n\nSummary\n\nPressing a key always generates a keyboard event, be it symbol keys or special keys like Shift or Ctrl and so on. The only exception is Fn key that sometimes presents on a laptop keyboard. There’s no keyboard event for it, because it’s often implemented on lower level than OS.\n\nKeyboard events:\n\nkeydown – on pressing the key (auto-repeats if the key is pressed for long),\nkeyup – on releasing the key.\n\nMain keyboard event properties:\n\ncode – the “key code” (\"KeyA\", \"ArrowLeft\" and so on), specific to the physical location of the key on keyboard.\nkey – the character (\"A\", \"a\" and so on), for non-character keys, such as Esc, usually has the same value as code.\n\nIn the past, keyboard events were sometimes used to track user input in form fields. That’s not reliable, because the input can come from various sources. We have input and change events to handle any input (covered later in the chapter Events: change, input, cut, copy, paste). They trigger after any kind of input, including copy-pasting or speech recognition.\n\nWe should use keyboard events when we really want keyboard. For example, to react on hotkeys or special keys.\n\nTasks\nExtended hotkeys\nimportance: 5\n\nCreate a function runOnKeys(func, code1, code2, ... code_n) that runs func on simultaneous pressing of keys with codes code1, code2, …, code_n.\n\nFor instance, the code below shows alert when \"Q\" and \"W\" are pressed together (in any language, with or without CapsLock)\n\nrunOnKeys(\n  () => alert(\"Hello!\"),\n  \"KeyQ\",\n  \"KeyW\"\n);\n\nDemo in new window\n\nsolution"
  },
  {
    "title": "Drag'n'Drop with mouse events",
    "url": "https://javascript.info/mouse-drag-and-drop",
    "html": "Drag’n’Drop is a great interface solution. Taking something and dragging and dropping it is a clear and simple way to do many things, from copying and moving documents (as in file managers) to ordering (dropping items into a cart).\n\nIn the modern HTML standard there’s a section about Drag and Drop with special events such as dragstart, dragend, and so on.\n\nThese events allow us to support special kinds of drag’n’drop, such as handling dragging a file from OS file-manager and dropping it into the browser window. Then JavaScript can access the contents of such files.\n\nBut native Drag Events also have limitations. For instance, we can’t prevent dragging from a certain area. Also we can’t make the dragging “horizontal” or “vertical” only. And there are many other drag’n’drop tasks that can’t be done using them. Also, mobile device support for such events is very weak.\n\nSo here we’ll see how to implement Drag’n’Drop using mouse events.\n\nDrag’n’Drop algorithm\n\nThe basic Drag’n’Drop algorithm looks like this:\n\nOn mousedown – prepare the element for moving, if needed (maybe create a clone of it, add a class to it or whatever).\nThen on mousemove move it by changing left/top with position:absolute.\nOn mouseup – perform all actions related to finishing the drag’n’drop.\n\nThese are the basics. Later we’ll see how to add other features, such as highlighting current underlying elements while we drag over them.\n\nHere’s the implementation of dragging a ball:\n\nball.onmousedown = function(event) {\n  // (1) prepare to moving: make absolute and on top by z-index\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n\n  // move it out of any current parents directly into body\n  // to make it positioned relative to the body\n  document.body.append(ball);\n\n  // centers the ball at (pageX, pageY) coordinates\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - ball.offsetWidth / 2 + 'px';\n    ball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n  }\n\n  // move our absolutely positioned ball under the pointer\n  moveAt(event.pageX, event.pageY);\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // (2) move the ball on mousemove\n  document.addEventListener('mousemove', onMouseMove);\n\n  // (3) drop the ball, remove unneeded handlers\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n\nIf we run the code, we can notice something strange. On the beginning of the drag’n’drop, the ball “forks”: we start dragging its “clone”.\n\nHere’s an example in action:\n\nTry to drag’n’drop with the mouse and you’ll see such behavior.\n\nThat’s because the browser has its own drag’n’drop support for images and some other elements. It runs automatically and conflicts with ours.\n\nTo disable it:\n\nball.ondragstart = function() {\n  return false;\n};\n\nNow everything will be all right.\n\nIn action:\n\nAnother important aspect – we track mousemove on document, not on ball. From the first sight it may seem that the mouse is always over the ball, and we can put mousemove on it.\n\nBut as we remember, mousemove triggers often, but not for every pixel. So after swift move the pointer can jump from the ball somewhere in the middle of document (or even outside of the window).\n\nSo we should listen on document to catch it.\n\nCorrect positioning\n\nIn the examples above the ball is always moved so that its center is under the pointer:\n\nball.style.left = pageX - ball.offsetWidth / 2 + 'px';\nball.style.top = pageY - ball.offsetHeight / 2 + 'px';\n\nNot bad, but there’s a side effect. To initiate the drag’n’drop, we can mousedown anywhere on the ball. But if “take” it from its edge, then the ball suddenly “jumps” to become centered under the mouse pointer.\n\nIt would be better if we keep the initial shift of the element relative to the pointer.\n\nFor instance, if we start dragging by the edge of the ball, then the pointer should remain over the edge while dragging.\n\nLet’s update our algorithm:\n\nWhen a visitor presses the button (mousedown) – remember the distance from the pointer to the left-upper corner of the ball in variables shiftX/shiftY. We’ll keep that distance while dragging.\n\nTo get these shifts we can substract the coordinates:\n\n// onmousedown\nlet shiftX = event.clientX - ball.getBoundingClientRect().left;\nlet shiftY = event.clientY - ball.getBoundingClientRect().top;\n\nThen while dragging we position the ball on the same shift relative to the pointer, like this:\n\n// onmousemove\n// ball has position:absolute\nball.style.left = event.pageX - shiftX + 'px';\nball.style.top = event.pageY - shiftY + 'px';\n\nThe final code with better positioning:\n\nball.onmousedown = function(event) {\n\n  let shiftX = event.clientX - ball.getBoundingClientRect().left;\n  let shiftY = event.clientY - ball.getBoundingClientRect().top;\n\n  ball.style.position = 'absolute';\n  ball.style.zIndex = 1000;\n  document.body.append(ball);\n\n  moveAt(event.pageX, event.pageY);\n\n  // moves the ball at (pageX, pageY) coordinates\n  // taking initial shifts into account\n  function moveAt(pageX, pageY) {\n    ball.style.left = pageX - shiftX + 'px';\n    ball.style.top = pageY - shiftY + 'px';\n  }\n\n  function onMouseMove(event) {\n    moveAt(event.pageX, event.pageY);\n  }\n\n  // move the ball on mousemove\n  document.addEventListener('mousemove', onMouseMove);\n\n  // drop the ball, remove unneeded handlers\n  ball.onmouseup = function() {\n    document.removeEventListener('mousemove', onMouseMove);\n    ball.onmouseup = null;\n  };\n\n};\n\nball.ondragstart = function() {\n  return false;\n};\n\nIn action (inside <iframe>):\n\nThe difference is especially noticeable if we drag the ball by its right-bottom corner. In the previous example the ball “jumps” under the pointer. Now it fluently follows the pointer from the current position.\n\nPotential drop targets (droppables)\n\nIn previous examples the ball could be dropped just “anywhere” to stay. In real-life we usually take one element and drop it onto another. For instance, a “file” into a “folder” or something else.\n\nSpeaking abstract, we take a “draggable” element and drop it onto “droppable” element.\n\nWe need to know:\n\nwhere the element was dropped at the end of Drag’n’Drop – to do the corresponding action,\nand, preferably, know the droppable we’re dragging over, to highlight it.\n\nThe solution is kind-of interesting and just a little bit tricky, so let’s cover it here.\n\nWhat may be the first idea? Probably to set mouseover/mouseup handlers on potential droppables?\n\nBut that doesn’t work.\n\nThe problem is that, while we’re dragging, the draggable element is always above other elements. And mouse events only happen on the top element, not on those below it.\n\nFor instance, below are two <div> elements, red one on top of the blue one (fully covers). There’s no way to catch an event on the blue one, because the red is on top:\n\n\t\n<style>\n  div {\n    width: 50px;\n    height: 50px;\n    position: absolute;\n    top: 0;\n  }\n</style>\n<div style=\"background:blue\" onmouseover=\"alert('never works')\"></div>\n<div style=\"background:red\" onmouseover=\"alert('over red!')\"></div>\n\nThe same with a draggable element. The ball is always on top over other elements, so events happen on it. Whatever handlers we set on lower elements, they won’t work.\n\nThat’s why the initial idea to put handlers on potential droppables doesn’t work in practice. They won’t run.\n\nSo, what to do?\n\nThere’s a method called document.elementFromPoint(clientX, clientY). It returns the most nested element on given window-relative coordinates (or null if given coordinates are out of the window). If there are multiple overlapping elements on the same coordinates, then the topmost one is returned.\n\nWe can use it in any of our mouse event handlers to detect the potential droppable under the pointer, like this:\n\n// in a mouse event handler\nball.hidden = true; // (*) hide the element that we drag\n\nlet elemBelow = document.elementFromPoint(event.clientX, event.clientY);\n// elemBelow is the element below the ball, may be droppable\n\nball.hidden = false;\n\nPlease note: we need to hide the ball before the call (*). Otherwise we’ll usually have a ball on these coordinates, as it’s the top element under the pointer: elemBelow=ball. So we hide it and immediately show again.\n\nWe can use that code to check what element we’re “flying over” at any time. And handle the drop when it happens.\n\nAn extended code of onMouseMove to find “droppable” elements:\n\n// potential droppable that we're flying over right now\nlet currentDroppable = null;\n\nfunction onMouseMove(event) {\n  moveAt(event.pageX, event.pageY);\n\n  ball.hidden = true;\n  let elemBelow = document.elementFromPoint(event.clientX, event.clientY);\n  ball.hidden = false;\n\n  // mousemove events may trigger out of the window (when the ball is dragged off-screen)\n  // if clientX/clientY are out of the window, then elementFromPoint returns null\n  if (!elemBelow) return;\n\n  // potential droppables are labeled with the class \"droppable\" (can be other logic)\n  let droppableBelow = elemBelow.closest('.droppable');\n\n  if (currentDroppable != droppableBelow) {\n    // we're flying in or out...\n    // note: both values can be null\n    //   currentDroppable=null if we were not over a droppable before this event (e.g over an empty space)\n    //   droppableBelow=null if we're not over a droppable now, during this event\n\n    if (currentDroppable) {\n      // the logic to process \"flying out\" of the droppable (remove highlight)\n      leaveDroppable(currentDroppable);\n    }\n    currentDroppable = droppableBelow;\n    if (currentDroppable) {\n      // the logic to process \"flying in\" of the droppable\n      enterDroppable(currentDroppable);\n    }\n  }\n}\n\nIn the example below when the ball is dragged over the soccer goal, the goal is highlighted.\n\nResultstyle.cssindex.html\n\t\n\nNow we have the current “drop target”, that we’re flying over, in the variable currentDroppable during the whole process and can use it to highlight or any other stuff.\n\nSummary\n\nWe considered a basic Drag’n’Drop algorithm.\n\nThe key components:\n\nEvents flow: ball.mousedown → document.mousemove → ball.mouseup (don’t forget to cancel native ondragstart).\nAt the drag start – remember the initial shift of the pointer relative to the element: shiftX/shiftY and keep it during the dragging.\nDetect droppable elements under the pointer using document.elementFromPoint.\n\nWe can lay a lot on this foundation.\n\nOn mouseup we can intellectually finalize the drop: change data, move elements around.\nWe can highlight the elements we’re flying over.\nWe can limit dragging by a certain area or direction.\nWe can use event delegation for mousedown/up. A large-area event handler that checks event.target can manage Drag’n’Drop for hundreds of elements.\nAnd so on.\n\nThere are frameworks that build architecture over it: DragZone, Droppable, Draggable and other classes. Most of them do the similar stuff to what’s described above, so it should be easy to understand them now. Or roll your own, as you can see that that’s easy enough to do, sometimes easier than adapting a third-party solution.\n\nTasks\nSlider\nimportance: 5\n\nCreate a slider:\n\nDrag the blue thumb with the mouse and move it.\n\nImportant details:\n\nWhen the mouse button is pressed, during the dragging the mouse may go over or below the slider. The slider will still work (convenient for the user).\nIf the mouse moves very fast to the left or to the right, the thumb should stop exactly at the edge.\n\nOpen a sandbox for the task.\n\nsolution\nDrag superheroes around the field\nimportance: 5\n\nThis task can help you to check understanding of several aspects of Drag’n’Drop and DOM.\n\nMake all elements with class draggable – draggable. Like a ball in the chapter.\n\nRequirements:\n\nUse event delegation to track drag start: a single event handler on document for mousedown.\nIf elements are dragged to top/bottom window edges – the page scrolls up/down to allow further dragging.\nThere is no horizontal scroll (this makes the task a bit simpler, adding it is easy).\nDraggable elements or their parts should never leave the window, even after swift mouse moves.\n\nThe demo is too big to fit it here, so here’s the link.\n\nDemo in new window\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Pointer events",
    "url": "https://javascript.info/pointer-events",
    "html": "Pointer events are a modern way to handle input from a variety of pointing devices, such as a mouse, a pen/stylus, a touchscreen, and so on.\n\nThe brief history\n\nLet’s make a small overview, so that you understand the general picture and the place of Pointer Events among other event types.\n\nLong ago, in the past, there were only mouse events.\n\nThen touch devices became widespread, phones and tablets in particular. For the existing scripts to work, they generated (and still generate) mouse events. For instance, tapping a touchscreen generates mousedown. So touch devices worked well with web pages.\n\nBut touch devices have more capabilities than a mouse. For example, it’s possible to touch multiple points at once (“multi-touch”). Although, mouse events don’t have necessary properties to handle such multi-touches.\n\nSo touch events were introduced, such as touchstart, touchend, touchmove, that have touch-specific properties (we don’t cover them in detail here, because pointer events are even better).\n\nStill, it wasn’t enough, as there are many other devices, such as pens, that have their own features. Also, writing code that listens for both touch and mouse events was cumbersome.\n\nTo solve these issues, the new standard Pointer Events was introduced. It provides a single set of events for all kinds of pointing devices.\n\nAs of now, Pointer Events Level 2 specification is supported in all major browsers, while the newer Pointer Events Level 3 is in the works and is mostly compatible with Pointer Events level 2.\n\nUnless you develop for old browsers, such as Internet Explorer 10, or for Safari 12 or below, there’s no point in using mouse or touch events any more – we can switch to pointer events.\n\nThen your code will work well with both touch and mouse devices.\n\nThat said, there are some important peculiarities that one should know in order to use Pointer Events correctly and avoid surprises. We’ll make note of them in this article.\n\nPointer event types\n\nPointer events are named similarly to mouse events:\n\nPointer event\tSimilar mouse event\npointerdown\tmousedown\npointerup\tmouseup\npointermove\tmousemove\npointerover\tmouseover\npointerout\tmouseout\npointerenter\tmouseenter\npointerleave\tmouseleave\npointercancel\t-\ngotpointercapture\t-\nlostpointercapture\t-\n\nAs we can see, for every mouse<event>, there’s a pointer<event> that plays a similar role. Also there are 3 additional pointer events that don’t have a corresponding mouse... counterpart, we’ll explain them soon.\n\nReplacing mouse<event> with pointer<event> in our code\n\nWe can replace mouse<event> events with pointer<event> in our code and expect things to continue working fine with mouse.\n\nThe support for touch devices will also “magically” improve. Although, we may need to add touch-action: none in some places in CSS. We’ll cover it below in the section about pointercancel.\n\nPointer event properties\n\nPointer events have the same properties as mouse events, such as clientX/Y, target, etc., plus some others:\n\npointerId – the unique identifier of the pointer causing the event.\n\nBrowser-generated. Allows us to handle multiple pointers, such as a touchscreen with stylus and multi-touch (examples will follow).\n\npointerType – the pointing device type. Must be a string, one of: “mouse”, “pen” or “touch”.\n\nWe can use this property to react differently on various pointer types.\n\nisPrimary – is true for the primary pointer (the first finger in multi-touch).\n\nSome pointer devices measure contact area and pressure, e.g. for a finger on the touchscreen, there are additional properties for that:\n\nwidth – the width of the area where the pointer (e.g. a finger) touches the device. Where unsupported, e.g. for a mouse, it’s always 1.\nheight – the height of the area where the pointer touches the device. Where unsupported, it’s always 1.\npressure – the pressure of the pointer tip, in range from 0 to 1. For devices that don’t support pressure must be either 0.5 (pressed) or 0.\ntangentialPressure – the normalized tangential pressure.\ntiltX, tiltY, twist – pen-specific properties that describe how the pen is positioned relative to the surface.\n\nThese properties aren’t supported by most devices, so they are rarely used. You can find the details about them in the specification if needed.\n\nMulti-touch\n\nOne of the things that mouse events totally don’t support is multi-touch: a user can touch in several places at once on their phone or tablet, or perform special gestures.\n\nPointer Events allow handling multi-touch with the help of the pointerId and isPrimary properties.\n\nHere’s what happens when a user touches a touchscreen in one place, then puts another finger somewhere else on it:\n\nAt the first finger touch:\npointerdown with isPrimary=true and some pointerId.\nFor the second finger and more fingers (assuming the first one is still touching):\npointerdown with isPrimary=false and a different pointerId for every finger.\n\nPlease note: the pointerId is assigned not to the whole device, but for each touching finger. If we use 5 fingers to simultaneously touch the screen, we have 5 pointerdown events, each with their respective coordinates and a different pointerId.\n\nThe events associated with the first finger always have isPrimary=true.\n\nWe can track multiple touching fingers using their pointerId. When the user moves and then removes a finger, we get pointermove and pointerup events with the same pointerId as we had in pointerdown.\n\nHere’s the demo that logs pointerdown and pointerup events:\n\nPlease note: you must be using a touchscreen device, such as a phone or a tablet, to actually see the difference in pointerId/isPrimary. For single-touch devices, such as a mouse, there’ll be always same pointerId with isPrimary=true, for all pointer events.\n\nEvent: pointercancel\n\nThe pointercancel event fires when there’s an ongoing pointer interaction, and then something happens that causes it to be aborted, so that no more pointer events are generated.\n\nSuch causes are:\n\nThe pointer device hardware was physically disabled.\nThe device orientation changed (tablet rotated).\nThe browser decided to handle the interaction on its own, considering it a mouse gesture or zoom-and-pan action or something else.\n\nWe’ll demonstrate pointercancel on a practical example to see how it affects us.\n\nLet’s say we’re implementing drag’n’drop for a ball, just as in the beginning of the article Drag'n'Drop with mouse events.\n\nHere is the flow of user actions and the corresponding events:\n\nThe user presses on an image, to start dragging\npointerdown event fires\nThen they start moving the pointer (thus dragging the image)\npointermove fires, maybe several times\nAnd then the surprise happens! The browser has native drag’n’drop support for images, that kicks in and takes over the drag’n’drop process, thus generating pointercancel event.\nThe browser now handles drag’n’drop of the image on its own. The user may even drag the ball image out of the browser, into their Mail program or a File Manager.\nNo more pointermove events for us.\n\nSo the issue is that the browser “hijacks” the interaction: pointercancel fires in the beginning of the “drag-and-drop” process, and no more pointermove events are generated.\n\nHere’s the drag’n’drop demo with loggin of pointer events (only up/down, move and cancel) in the textarea:\n\nWe’d like to implement the drag’n’drop on our own, so let’s tell the browser not to take it over.\n\nPrevent the default browser action to avoid pointercancel.\n\nWe need to do two things:\n\nPrevent native drag’n’drop from happening:\nWe can do this by setting ball.ondragstart = () => false, just as described in the article Drag'n'Drop with mouse events.\nThat works well for mouse events.\nFor touch devices, there are other touch-related browser actions (besides drag’n’drop). To avoid problems with them too:\nPrevent them by setting #ball { touch-action: none } in CSS.\nThen our code will start working on touch devices.\n\nAfter we do that, the events will work as intended, the browser won’t hijack the process and doesn’t emit pointercancel.\n\nThis demo adds these lines:\n\nAs you can see, there’s no pointercancel any more.\n\nNow we can add the code to actually move the ball, and our drag’n’drop will work for mouse devices and touch devices.\n\nPointer capturing\n\nPointer capturing is a special feature of pointer events.\n\nThe idea is very simple, but may seem quite odd at first, as nothing like that exists for any other event type.\n\nThe main method is:\n\nelem.setPointerCapture(pointerId) – binds events with the given pointerId to elem. After the call all pointer events with the same pointerId will have elem as the target (as if happened on elem), no matter where in document they really happened.\n\nIn other words, elem.setPointerCapture(pointerId) retargets all subsequent events with the given pointerId to elem.\n\nThe binding is removed:\n\nautomatically when pointerup or pointercancel events occur,\nautomatically when elem is removed from the document,\nwhen elem.releasePointerCapture(pointerId) is called.\n\nNow what is it good for? It’s time to see a real-life example.\n\nPointer capturing can be used to simplify drag’n’drop kind of interactions.\n\nLet’s recall how one can implement a custom slider, described in the Drag'n'Drop with mouse events.\n\nWe can make a slider element to represent the strip and the “runner” (thumb) inside it:\n\n<div class=\"slider\">\n  <div class=\"thumb\"></div>\n</div>\n\nWith styles, it looks like this:\n\nAnd here’s the working logic, as it was described, after replacing mouse events with similar pointer events:\n\nThe user presses on the slider thumb – pointerdown triggers.\nThen they move the pointer – pointermove triggers, and our code moves the thumb element along.\n…As the pointer moves, it may leave the slider thumb element, go above or below it. The thumb should move strictly horizontally, remaining aligned with the pointer.\n\nIn the mouse event based solution, to track all pointer movements, including when it goes above/below the thumb, we had to assign mousemove event handler on the whole document.\n\nThat’s not a cleanest solution, though. One of the problems is that when a user moves the pointer around the document, it may trigger event handlers (such as mouseover) on some other elements, invoke totally unrelated UI functionality, and we don’t want that.\n\nThis is the place where setPointerCapture comes into play.\n\nWe can call thumb.setPointerCapture(event.pointerId) in pointerdown handler,\nThen future pointer events until pointerup/cancel will be retargeted to thumb.\nWhen pointerup happens (dragging complete), the binding is removed automatically, we don’t need to care about it.\n\nSo, even if the user moves the pointer around the whole document, events handlers will be called on thumb. Nevertheless, coordinate properties of the event objects, such as clientX/clientY will still be correct – the capturing only affects target/currentTarget.\n\nHere’s the essential code:\n\nthumb.onpointerdown = function(event) {\n  // retarget all pointer events (until pointerup) to thumb\n  thumb.setPointerCapture(event.pointerId);\n\n  // start tracking pointer moves\n  thumb.onpointermove = function(event) {\n    // moving the slider: listen on the thumb, as all pointer events are retargeted to it\n    let newLeft = event.clientX - slider.getBoundingClientRect().left;\n    thumb.style.left = newLeft + 'px';\n  };\n\n  // on pointer up finish tracking pointer moves\n  thumb.onpointerup = function(event) {\n    thumb.onpointermove = null;\n    thumb.onpointerup = null;\n    // ...also process the \"drag end\" if needed\n  };\n};\n\n// note: no need to call thumb.releasePointerCapture,\n// it happens on pointerup automatically\n\nThe full demo:\n\nIn the demo, there’s also an additional element with onmouseover handler showing the current date.\n\nPlease note: while you’re dragging the thumb, you may hover over this element, and its handler does not trigger.\n\nSo the dragging is now free of side effects, thanks to setPointerCapture.\n\nAt the end, pointer capturing gives us two benefits:\n\nThe code becomes cleaner as we don’t need to add/remove handlers on the whole document any more. The binding is released automatically.\nIf there are other pointer event handlers in the document, they won’t be accidentally triggered by the pointer while the user is dragging the slider.\nPointer capturing events\n\nThere’s one more thing to mention here, for the sake of completeness.\n\nThere are two events associated with pointer capturing:\n\ngotpointercapture fires when an element uses setPointerCapture to enable capturing.\nlostpointercapture fires when the capture is released: either explicitly with releasePointerCapture call, or automatically on pointerup/pointercancel.\nSummary\n\nPointer events allow handling mouse, touch and pen events simultaneously, with a single piece of code.\n\nPointer events extend mouse events. We can replace mouse with pointer in event names and expect our code to continue working for mouse, with better support for other device types.\n\nFor drag’n’drops and complex touch interactions that the browser may decide to hijack and handle on its own – remember to cancel the default action on events and set touch-action: none in CSS for elements that we engage.\n\nAdditional abilities of pointer events are:\n\nMulti-touch support using pointerId and isPrimary.\nDevice-specific properties, such as pressure, width/height, and others.\nPointer capturing: we can retarget all pointer events to a specific element until pointerup/pointercancel.\n\nAs of now, pointer events are supported in all major browsers, so we can safely switch to them, especially if IE10- and Safari 12- are not needed. And even with those browsers, there are polyfills that enable the support of pointer events."
  },
  {
    "title": "Event delegation",
    "url": "https://javascript.info/event-delegation",
    "html": "Capturing and bubbling allow us to implement one of the most powerful event handling patterns called event delegation.\n\nThe idea is that if we have a lot of elements handled in a similar way, then instead of assigning a handler to each of them – we put a single handler on their common ancestor.\n\nIn the handler we get event.target to see where the event actually happened and handle it.\n\nLet’s see an example – the Ba-Gua diagram reflecting the ancient Chinese philosophy.\n\nHere it is:\n\n\t\n\nThe HTML is like this:\n\n<table>\n  <tr>\n    <th colspan=\"3\"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>\n  </tr>\n  <tr>\n    <td class=\"nw\"><strong>Northwest</strong><br>Metal<br>Silver<br>Elders</td>\n    <td class=\"n\">...</td>\n    <td class=\"ne\">...</td>\n  </tr>\n  <tr>...2 more lines of this kind...</tr>\n  <tr>...2 more lines of this kind...</tr>\n</table>\n\nThe table has 9 cells, but there could be 99 or 9999, doesn’t matter.\n\nOur task is to highlight a cell <td> on click.\n\nInstead of assign an onclick handler to each <td> (can be many) – we’ll setup the “catch-all” handler on <table> element.\n\nIt will use event.target to get the clicked element and highlight it.\n\nThe code:\n\nlet selectedTd;\n\ntable.onclick = function(event) {\n  let target = event.target; // where was the click?\n\n  if (target.tagName != 'TD') return; // not on TD? Then we're not interested\n\n  highlight(target); // highlight it\n};\n\nfunction highlight(td) {\n  if (selectedTd) { // remove the existing highlight if any\n    selectedTd.classList.remove('highlight');\n  }\n  selectedTd = td;\n  selectedTd.classList.add('highlight'); // highlight the new td\n}\n\nSuch a code doesn’t care how many cells there are in the table. We can add/remove <td> dynamically at any time and the highlighting will still work.\n\nStill, there’s a drawback.\n\nThe click may occur not on the <td>, but inside it.\n\nIn our case if we take a look inside the HTML, we can see nested tags inside <td>, like <strong>:\n\n<td>\n  <strong>Northwest</strong>\n  ...\n</td>\n\nNaturally, if a click happens on that <strong> then it becomes the value of event.target.\n\nIn the handler table.onclick we should take such event.target and find out whether the click was inside <td> or not.\n\nHere’s the improved code:\n\ntable.onclick = function(event) {\n  let td = event.target.closest('td'); // (1)\n\n  if (!td) return; // (2)\n\n  if (!table.contains(td)) return; // (3)\n\n  highlight(td); // (4)\n};\n\nExplanations:\n\nThe method elem.closest(selector) returns the nearest ancestor that matches the selector. In our case we look for <td> on the way up from the source element.\nIf event.target is not inside any <td>, then the call returns immediately, as there’s nothing to do.\nIn case of nested tables, event.target may be a <td>, but lying outside of the current table. So we check if that’s actually our table’s <td>.\nAnd, if it’s so, then highlight it.\n\nAs the result, we have a fast, efficient highlighting code, that doesn’t care about the total number of <td> in the table.\n\nDelegation example: actions in markup\n\nThere are other uses for event delegation.\n\nLet’s say, we want to make a menu with buttons “Save”, “Load”, “Search” and so on. And there’s an object with methods save, load, search… How to match them?\n\nThe first idea may be to assign a separate handler to each button. But there’s a more elegant solution. We can add a handler for the whole menu and data-action attributes for buttons that has the method to call:\n\n<button data-action=\"save\">Click to Save</button>\n\nThe handler reads the attribute and executes the method. Take a look at the working example:\n\n\t\n<div id=\"menu\">\n  <button data-action=\"save\">Save</button>\n  <button data-action=\"load\">Load</button>\n  <button data-action=\"search\">Search</button>\n</div>\n\n<script>\n  class Menu {\n    constructor(elem) {\n      this._elem = elem;\n      elem.onclick = this.onClick.bind(this); // (*)\n    }\n\n    save() {\n      alert('saving');\n    }\n\n    load() {\n      alert('loading');\n    }\n\n    search() {\n      alert('searching');\n    }\n\n    onClick(event) {\n      let action = event.target.dataset.action;\n      if (action) {\n        this[action]();\n      }\n    };\n  }\n\n  new Menu(menu);\n</script>\n\nPlease note that this.onClick is bound to this in (*). That’s important, because otherwise this inside it would reference the DOM element (elem), not the Menu object, and this[action] would not be what we need.\n\nSo, what advantages does delegation give us here?\n\nWe don’t need to write the code to assign a handler to each button. Just make a method and put it in the markup.\nThe HTML structure is flexible, we can add/remove buttons at any time.\n\nWe could also use classes .action-save, .action-load, but an attribute data-action is better semantically. And we can use it in CSS rules too.\n\nThe “behavior” pattern\n\nWe can also use event delegation to add “behaviors” to elements declaratively, with special attributes and classes.\n\nThe pattern has two parts:\n\nWe add a custom attribute to an element that describes its behavior.\nA document-wide handler tracks events, and if an event happens on an attributed element – performs the action.\nBehavior: Counter\n\nFor instance, here the attribute data-counter adds a behavior: “increase value on click” to buttons:\n\n\t\nCounter: <input type=\"button\" value=\"1\" data-counter>\nOne more counter: <input type=\"button\" value=\"2\" data-counter>\n\n<script>\n  document.addEventListener('click', function(event) {\n\n    if (event.target.dataset.counter != undefined) { // if the attribute exists...\n      event.target.value++;\n    }\n\n  });\n</script>\n\nIf we click a button – its value is increased. Not buttons, but the general approach is important here.\n\nThere can be as many attributes with data-counter as we want. We can add new ones to HTML at any moment. Using the event delegation we “extended” HTML, added an attribute that describes a new behavior.\n\nFor document-level handlers – always addEventListener\n\nWhen we assign an event handler to the document object, we should always use addEventListener, not document.on<event>, because the latter will cause conflicts: new handlers overwrite old ones.\n\nFor real projects it’s normal that there are many handlers on document set by different parts of the code.\n\nBehavior: Toggler\n\nOne more example of behavior. A click on an element with the attribute data-toggle-id will show/hide the element with the given id:\n\n\t\n<button data-toggle-id=\"subscribe-mail\">\n  Show the subscription form\n</button>\n\n<form id=\"subscribe-mail\" hidden>\n  Your mail: <input type=\"email\">\n</form>\n\n<script>\n  document.addEventListener('click', function(event) {\n    let id = event.target.dataset.toggleId;\n    if (!id) return;\n\n    let elem = document.getElementById(id);\n\n    elem.hidden = !elem.hidden;\n  });\n</script>\n\nLet’s note once again what we did. Now, to add toggling functionality to an element – there’s no need to know JavaScript, just use the attribute data-toggle-id.\n\nThat may become really convenient – no need to write JavaScript for every such element. Just use the behavior. The document-level handler makes it work for any element of the page.\n\nWe can combine multiple behaviors on a single element as well.\n\nThe “behavior” pattern can be an alternative to mini-fragments of JavaScript.\n\nSummary\n\nEvent delegation is really cool! It’s one of the most helpful patterns for DOM events.\n\nIt’s often used to add the same handling for many similar elements, but not only for that.\n\nThe algorithm:\n\nPut a single handler on the container.\nIn the handler – check the source element event.target.\nIf the event happened inside an element that interests us, then handle the event.\n\nBenefits:\n\nSimplifies initialization and saves memory: no need to add many handlers.\nLess code: when adding or removing elements, no need to add/remove handlers.\nDOM modifications: we can mass add/remove elements with innerHTML and the like.\n\nThe delegation has its limitations of course:\n\nFirst, the event must be bubbling. Some events do not bubble. Also, low-level handlers should not use event.stopPropagation().\nSecond, the delegation may add CPU load, because the container-level handler reacts on events in any place of the container, no matter whether they interest us or not. But usually the load is negligible, so we don’t take it into account.\nTasks\nHide messages with delegation\nimportance: 5\n\nThere’s a list of messages with removal buttons [x]. Make the buttons work.\n\nLike this:\n\nP.S. Should be only one event listener on the container, use event delegation.\n\nOpen a sandbox for the task.\n\nsolution\nTree menu\nimportance: 5\n\nCreate a tree that shows/hides node children on click:\n\nRequirements:\n\nOnly one event handler (use delegation)\nA click outside the node title (on an empty space) should not do anything.\n\nOpen a sandbox for the task.\n\nsolution\nSortable table\nimportance: 4\n\nMake the table sortable: clicks on <th> elements should sort it by corresponding column.\n\nEach <th> has the type in the attribute, like this:\n\n<table id=\"grid\">\n  <thead>\n    <tr>\n      <th data-type=\"number\">Age</th>\n      <th data-type=\"string\">Name</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>5</td>\n      <td>John</td>\n    </tr>\n    <tr>\n      <td>10</td>\n      <td>Ann</td>\n    </tr>\n    ...\n  </tbody>\n</table>\n\nIn the example above the first column has numbers, and the second one – strings. The sorting function should handle sort according to the type.\n\nOnly \"string\" and \"number\" types should be supported.\n\nThe working example:\n\nP.S. The table can be big, with any number of rows and columns.\n\nOpen a sandbox for the task.\n\nsolution\nTooltip behavior\nimportance: 5\n\nCreate JS-code for the tooltip behavior.\n\nWhen a mouse comes over an element with data-tooltip, the tooltip should appear over it, and when it’s gone then hide.\n\nAn example of annotated HTML:\n\n<button data-tooltip=\"the tooltip is longer than the element\">Short button</button>\n<button data-tooltip=\"HTML<br>tooltip\">One more button</button>\n\nShould work like this:\n\nIn this task we assume that all elements with data-tooltip have only text inside. No nested tags (yet).\n\nDetails:\n\nThe distance between the element and the tooltip should be 5px.\nThe tooltip should be centered relative to the element, if possible.\nThe tooltip should not cross window edges. Normally it should be above the element, but if the element is at the page top and there’s no space for the tooltip, then below it.\nThe tooltip content is given in the data-tooltip attribute. It can be arbitrary HTML.\n\nYou’ll need two events here:\n\nmouseover triggers when a pointer comes over an element.\nmouseout triggers when a pointer leaves an element.\n\nPlease use event delegation: set up two handlers on document to track all “overs” and “outs” from elements with data-tooltip and manage tooltips from there.\n\nAfter the behavior is implemented, even people unfamiliar with JavaScript can add annotated elements.\n\nP.S. Only one tooltip may show up at a time.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Browser default actions",
    "url": "https://javascript.info/default-browser-action",
    "html": "Many events automatically lead to certain actions performed by the browser.\n\nFor instance:\n\nA click on a link – initiates navigation to its URL.\nA click on a form submit button – initiates its submission to the server.\nPressing a mouse button over a text and moving it – selects the text.\n\nIf we handle an event in JavaScript, we may not want the corresponding browser action to happen, and want to implement another behavior instead.\n\nPreventing browser actions\n\nThere are two ways to tell the browser we don’t want it to act:\n\nThe main way is to use the event object. There’s a method event.preventDefault().\nIf the handler is assigned using on<event> (not by addEventListener), then returning false also works the same.\n\nIn this HTML, a click on a link doesn’t lead to navigation; the browser doesn’t do anything:\n\n<a href=\"/\" onclick=\"return false\">Click here</a>\nor\n<a href=\"/\" onclick=\"event.preventDefault()\">here</a>\n\nIn the next example we’ll use this technique to create a JavaScript-powered menu.\n\nReturning false from a handler is an exception\n\nThe value returned by an event handler is usually ignored.\n\nThe only exception is return false from a handler assigned using on<event>.\n\nIn all other cases, return value is ignored. In particular, there’s no sense in returning true.\n\nExample: the menu\n\nConsider a site menu, like this:\n\n<ul id=\"menu\" class=\"menu\">\n  <li><a href=\"/html\">HTML</a></li>\n  <li><a href=\"/javascript\">JavaScript</a></li>\n  <li><a href=\"/css\">CSS</a></li>\n</ul>\n\nHere’s how it looks with some CSS:\n\n\t\n\nMenu items are implemented as HTML-links <a>, not buttons <button>. There are several reasons to do so, for instance:\n\nMany people like to use “right click” – “open in a new window”. If we use <button> or <span>, that doesn’t work.\nSearch engines follow <a href=\"...\"> links while indexing.\n\nSo we use <a> in the markup. But normally we intend to handle clicks in JavaScript. So we should prevent the default browser action.\n\nLike here:\n\nmenu.onclick = function(event) {\n  if (event.target.nodeName != 'A') return;\n\n  let href = event.target.getAttribute('href');\n  alert( href ); // ...can be loading from the server, UI generation etc\n\n  return false; // prevent browser action (don't go to the URL)\n};\n\nIf we omit return false, then after our code executes the browser will do its “default action” – navigating to the URL in href. And we don’t need that here, as we’re handling the click by ourselves.\n\nBy the way, using event delegation here makes our menu very flexible. We can add nested lists and style them using CSS to “slide down”.\n\nFollow-up events\n\nCertain events flow one into another. If we prevent the first event, there will be no second.\n\nFor instance, mousedown on an <input> field leads to focusing in it, and the focus event. If we prevent the mousedown event, there’s no focus.\n\nTry to click on the first <input> below – the focus event happens. But if you click the second one, there’s no focus.\n\n\t\n<input value=\"Focus works\" onfocus=\"this.value=''\">\n<input onmousedown=\"return false\" onfocus=\"this.value=''\" value=\"Click me\">\n\nThat’s because the browser action is canceled on mousedown. The focusing is still possible if we use another way to enter the input. For instance, the Tab key to switch from the 1st input into the 2nd. But not with the mouse click any more.\n\nThe “passive” handler option\n\nThe optional passive: true option of addEventListener signals the browser that the handler is not going to call preventDefault().\n\nWhy might that be needed?\n\nThere are some events like touchmove on mobile devices (when the user moves their finger across the screen), that cause scrolling by default, but that scrolling can be prevented using preventDefault() in the handler.\n\nSo when the browser detects such event, it has first to process all handlers, and then if preventDefault is not called anywhere, it can proceed with scrolling. That may cause unnecessary delays and “jitters” in the UI.\n\nThe passive: true options tells the browser that the handler is not going to cancel scrolling. Then browser scrolls immediately providing a maximally fluent experience, and the event is handled by the way.\n\nFor some browsers (Firefox, Chrome), passive is true by default for touchstart and touchmove events.\n\nevent.defaultPrevented\n\nThe property event.defaultPrevented is true if the default action was prevented, and false otherwise.\n\nThere’s an interesting use case for it.\n\nYou remember in the chapter Bubbling and capturing we talked about event.stopPropagation() and why stopping bubbling is bad?\n\nSometimes we can use event.defaultPrevented instead, to signal other event handlers that the event was handled.\n\nLet’s see a practical example.\n\nBy default the browser on contextmenu event (right mouse click) shows a context menu with standard options. We can prevent it and show our own, like this:\n\n\t\n<button>Right-click shows browser context menu</button>\n\n<button oncontextmenu=\"alert('Draw our menu'); return false\">\n  Right-click shows our context menu\n</button>\n\nNow, in addition to that context menu we’d like to implement document-wide context menu.\n\nUpon right click, the closest context menu should show up.\n\n\t\n<p>Right-click here for the document context menu</p>\n<button id=\"elem\">Right-click here for the button context menu</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n\nThe problem is that when we click on elem, we get two menus: the button-level and (the event bubbles up) the document-level menu.\n\nHow to fix it? One of solutions is to think like: “When we handle right-click in the button handler, let’s stop its bubbling” and use event.stopPropagation():\n\n\t\n<p>Right-click for the document menu</p>\n<button id=\"elem\">Right-click for the button menu (fixed with event.stopPropagation)</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n\nNow the button-level menu works as intended. But the price is high. We forever deny access to information about right-clicks for any outer code, including counters that gather statistics and so on. That’s quite unwise.\n\nAn alternative solution would be to check in the document handler if the default action was prevented? If it is so, then the event was handled, and we don’t need to react on it.\n\n\t\n<p>Right-click for the document menu (added a check for event.defaultPrevented)</p>\n<button id=\"elem\">Right-click for the button menu</button>\n\n<script>\n  elem.oncontextmenu = function(event) {\n    event.preventDefault();\n    alert(\"Button context menu\");\n  };\n\n  document.oncontextmenu = function(event) {\n    if (event.defaultPrevented) return;\n\n    event.preventDefault();\n    alert(\"Document context menu\");\n  };\n</script>\n\nNow everything also works correctly. If we have nested elements, and each of them has a context menu of its own, that would also work. Just make sure to check for event.defaultPrevented in each contextmenu handler.\n\nevent.stopPropagation() and event.preventDefault()\n\nAs we can clearly see, event.stopPropagation() and event.preventDefault() (also known as return false) are two different things. They are not related to each other.\n\nNested context menus architecture\n\nThere are also alternative ways to implement nested context menus. One of them is to have a single global object with a handler for document.oncontextmenu, and also methods that allow us to store other handlers in it.\n\nThe object will catch any right-click, look through stored handlers and run the appropriate one.\n\nBut then each piece of code that wants a context menu should know about that object and use its help instead of the own contextmenu handler.\n\nSummary\n\nThere are many default browser actions:\n\nmousedown – starts the selection (move the mouse to select).\nclick on <input type=\"checkbox\"> – checks/unchecks the input.\nsubmit – clicking an <input type=\"submit\"> or hitting Enter inside a form field causes this event to happen, and the browser submits the form after it.\nkeydown – pressing a key may lead to adding a character into a field, or other actions.\ncontextmenu – the event happens on a right-click, the action is to show the browser context menu.\n…there are more…\n\nAll the default actions can be prevented if we want to handle the event exclusively by JavaScript.\n\nTo prevent a default action – use either event.preventDefault() or return false. The second method works only for handlers assigned with on<event>.\n\nThe passive: true option of addEventListener tells the browser that the action is not going to be prevented. That’s useful for some mobile events, like touchstart and touchmove, to tell the browser that it should not wait for all handlers to finish before scrolling.\n\nIf the default action was prevented, the value of event.defaultPrevented becomes true, otherwise it’s false.\n\nStay semantic, don’t abuse\n\nTechnically, by preventing default actions and adding JavaScript we can customize the behavior of any elements. For instance, we can make a link <a> work like a button, and a button <button> behave as a link (redirect to another URL or so).\n\nBut we should generally keep the semantic meaning of HTML elements. For instance, <a> should perform navigation, not a button.\n\nBesides being “just a good thing”, that makes your HTML better in terms of accessibility.\n\nAlso if we consider the example with <a>, then please note: a browser allows us to open such links in a new window (by right-clicking them and other means). And people like that. But if we make a button behave as a link using JavaScript and even look like a link using CSS, then <a>-specific browser features still won’t work for it.\n\nTasks\nWhy \"return false\" doesn't work?\nimportance: 3\n\nWhy in the code below return false doesn’t work at all?\n\n\t\n<script>\n  function handler() {\n    alert( \"...\" );\n    return false;\n  }\n</script>\n\n<a href=\"https://w3.org\" onclick=\"handler()\">the browser will go to w3.org</a>\n\nThe browser follows the URL on click, but we don’t want it.\n\nHow to fix?\n\nsolution\nCatch links in the element\nimportance: 5\n\nMake all links inside the element with id=\"contents\" ask the user if they really want to leave. And if they don’t then don’t follow.\n\nLike this:\n\nDetails:\n\nHTML inside the element may be loaded or regenerated dynamically at any time, so we can’t find all links and put handlers on them. Use event delegation.\nThe content may have nested tags. Inside links too, like <a href=\"..\"><i>...</i></a>.\n\nOpen a sandbox for the task.\n\nsolution\nImage gallery\nimportance: 5\n\nCreate an image gallery where the main image changes by the click on a thumbnail.\n\nLike this:\n\nP.S. Use event delegation.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Mouse events",
    "url": "https://javascript.info/mouse-events-basics",
    "html": "In this chapter we’ll get into more details about mouse events and their properties.\n\nPlease note: such events may come not only from “mouse devices”, but are also from other devices, such as phones and tablets, where they are emulated for compatibility.\n\nMouse event types\n\nWe’ve already seen some of these events:\n\nmousedown/mouseup\nMouse button is clicked/released over an element.\nmouseover/mouseout\nMouse pointer comes over/out from an element.\nmousemove\nEvery mouse move over an element triggers that event.\nclick\nTriggers after mousedown and then mouseup over the same element if the left mouse button was used.\ndblclick\nTriggers after two clicks on the same element within a short timeframe. Rarely used nowadays.\ncontextmenu\nTriggers when the right mouse button is pressed. There are other ways to open a context menu, e.g. using a special keyboard key, it triggers in that case also, so it’s not exactly the mouse event.\n\n…There are several other events too, we’ll cover them later.\n\nEvents order\n\nAs you can see from the list above, a user action may trigger multiple events.\n\nFor instance, a left-button click first triggers mousedown, when the button is pressed, then mouseup and click when it’s released.\n\nIn cases when a single action initiates multiple events, their order is fixed. That is, the handlers are called in the order mousedown → mouseup → click.\n\nClick the button below and you’ll see the events. Try double-click too.\n\nOn the teststand below, all mouse events are logged, and if there is more than a 1 second delay between them, they are separated by a horizontal rule.\n\nAlso, we can see the button property that allows us to detect the mouse button; it’s explained below.\n\n \n\nMouse button\n\nClick-related events always have the button property, which allows to get the exact mouse button.\n\nWe usually don’t use it for click and contextmenu events, because the former happens only on left-click, and the latter – only on right-click.\n\nOn the other hand, mousedown and mouseup handlers may need event.button, because these events trigger on any button, so button allows to distinguish between “right-mousedown” and “left-mousedown”.\n\nThe possible values of event.button are:\n\nButton state\tevent.button\nLeft button (primary)\t0\nMiddle button (auxiliary)\t1\nRight button (secondary)\t2\nX1 button (back)\t3\nX2 button (forward)\t4\n\nMost mouse devices only have the left and right buttons, so possible values are 0 or 2. Touch devices also generate similar events when one taps on them.\n\nAlso there’s event.buttons property that has all currently pressed buttons as an integer, one bit per button. In practice this property is very rarely used, you can find details at MDN if you ever need it.\n\nThe outdated event.which\n\nOld code may use event.which property that’s an old non-standard way of getting a button, with possible values:\n\nevent.which == 1 – left button,\nevent.which == 2 – middle button,\nevent.which == 3 – right button.\n\nAs of now, event.which is deprecated, we shouldn’t use it.\n\nModifiers: shift, alt, ctrl and meta\n\nAll mouse events include the information about pressed modifier keys.\n\nEvent properties:\n\nshiftKey: Shift\naltKey: Alt (or Opt for Mac)\nctrlKey: Ctrl\nmetaKey: Cmd for Mac\n\nThey are true if the corresponding key was pressed during the event.\n\nFor instance, the button below only works on Alt+Shift+click:\n\n<button id=\"button\">Alt+Shift+Click on me!</button>\n\n<script>\n  button.onclick = function(event) {\n    if (event.altKey && event.shiftKey) {\n      alert('Hooray!');\n    }\n  };\n</script>\nAttention: on Mac it’s usually Cmd instead of Ctrl\n\nOn Windows and Linux there are modifier keys Alt, Shift and Ctrl. On Mac there’s one more: Cmd, corresponding to the property metaKey.\n\nIn most applications, when Windows/Linux uses Ctrl, on Mac Cmd is used.\n\nThat is: where a Windows user presses Ctrl+Enter or Ctrl+A, a Mac user would press Cmd+Enter or Cmd+A, and so on.\n\nSo if we want to support combinations like Ctrl+click, then for Mac it makes sense to use Cmd+click. That’s more comfortable for Mac users.\n\nEven if we’d like to force Mac users to Ctrl+click – that’s kind of difficult. The problem is: a left-click with Ctrl is interpreted as a right-click on MacOS, and it generates the contextmenu event, not click like Windows/Linux.\n\nSo if we want users of all operating systems to feel comfortable, then together with ctrlKey we should check metaKey.\n\nFor JS-code it means that we should check if (event.ctrlKey || event.metaKey).\n\nThere are also mobile devices\n\nKeyboard combinations are good as an addition to the workflow. So that if the visitor uses a keyboard – they work.\n\nBut if their device doesn’t have it – then there should be a way to live without modifier keys.\n\nCoordinates: clientX/Y, pageX/Y\n\nAll mouse events provide coordinates in two flavours:\n\nWindow-relative: clientX and clientY.\nDocument-relative: pageX and pageY.\n\nWe already covered the difference between them in the chapter Coordinates.\n\nIn short, document-relative coordinates pageX/Y are counted from the left-upper corner of the document, and do not change when the page is scrolled, while clientX/Y are counted from the current window left-upper corner. When the page is scrolled, they change.\n\nFor instance, if we have a window of the size 500x500, and the mouse is in the left-upper corner, then clientX and clientY are 0, no matter how the page is scrolled.\n\nAnd if the mouse is in the center, then clientX and clientY are 250, no matter what place in the document it is. They are similar to position:fixed in that aspect.\n\nMove the mouse over the input field to see clientX/clientY (the example is in the iframe, so coordinates are relative to that iframe):\n\n<input onmousemove=\"this.value=event.clientX+':'+event.clientY\" value=\"Mouse over me\">\nPreventing selection on mousedown\n\nDouble mouse click has a side effect that may be disturbing in some interfaces: it selects text.\n\nFor instance, double-clicking on the text below selects it in addition to our handler:\n\n<span ondblclick=\"alert('dblclick')\">Double-click me</span>\n\nIf one presses the left mouse button and, without releasing it, moves the mouse, that also makes the selection, often unwanted.\n\nThere are multiple ways to prevent the selection, that you can read in the chapter Selection and Range.\n\nIn this particular case the most reasonable way is to prevent the browser action on mousedown. It prevents both these selections:\n\nBefore...\n<b ondblclick=\"alert('Click!')\" onmousedown=\"return false\">\n  Double-click me\n</b>\n...After\n\nNow the bold element is not selected on double clicks, and pressing the left button on it won’t start the selection.\n\nPlease note: the text inside it is still selectable. However, the selection should start not on the text itself, but before or after it. Usually that’s fine for users.\n\nPreventing copying\n\nIf we want to disable selection to protect our page content from copy-pasting, then we can use another event: oncopy.\n\n<div oncopy=\"alert('Copying forbidden!');return false\">\n  Dear user,\n  The copying is forbidden for you.\n  If you know JS or HTML, then you can get everything from the page source though.\n</div>\n\nIf you try to copy a piece of text in the <div>, that won’t work, because the default action oncopy is prevented.\n\nSurely the user has access to HTML-source of the page, and can take the content from there, but not everyone knows how to do it.\n\nSummary\n\nMouse events have the following properties:\n\nButton: button.\n\nModifier keys (true if pressed): altKey, ctrlKey, shiftKey and metaKey (Mac).\n\nIf you want to handle Ctrl, then don’t forget Mac users, they usually use Cmd, so it’s better to check if (e.metaKey || e.ctrlKey).\n\nWindow-relative coordinates: clientX/clientY.\n\nDocument-relative coordinates: pageX/pageY.\n\nThe default browser action of mousedown is text selection, if it’s not good for the interface, then it should be prevented.\n\nIn the next chapter we’ll see more details about events that follow pointer movement and how to track element changes under it.\n\nTasks\nSelectable list\nimportance: 5\n\nCreate a list where elements are selectable, like in file-managers.\n\nA click on a list element selects only that element (adds the class .selected), deselects all others.\nIf a click is made with Ctrl (Cmd for Mac), then the selection is toggled on the element, but other elements are not modified.\n\nThe demo:\n\nP.S. For this task we can assume that list items are text-only. No nested tags.\n\nP.P.S. Prevent the native browser selection of the text on clicks.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Dispatching custom events",
    "url": "https://javascript.info/dispatch-events",
    "html": "We can not only assign handlers, but also generate events from JavaScript.\n\nCustom events can be used to create “graphical components”. For instance, a root element of our own JS-based menu may trigger events telling what happens with the menu: open (menu open), select (an item is selected) and so on. Another code may listen for the events and observe what’s happening with the menu.\n\nWe can generate not only completely new events, that we invent for our own purposes, but also built-in ones, such as click, mousedown etc. That may be helpful for automated testing.\n\nEvent constructor\n\nBuilt-in event classes form a hierarchy, similar to DOM element classes. The root is the built-in Event class.\n\nWe can create Event objects like this:\n\nlet event = new Event(type[, options]);\n\nArguments:\n\ntype – event type, a string like \"click\" or our own like \"my-event\".\n\noptions – the object with two optional properties:\n\nbubbles: true/false – if true, then the event bubbles.\ncancelable: true/false – if true, then the “default action” may be prevented. Later we’ll see what it means for custom events.\n\nBy default both are false: {bubbles: false, cancelable: false}.\n\ndispatchEvent\n\nAfter an event object is created, we should “run” it on an element using the call elem.dispatchEvent(event).\n\nThen handlers react on it as if it were a regular browser event. If the event was created with the bubbles flag, then it bubbles.\n\nIn the example below the click event is initiated in JavaScript. The handler works same way as if the button was clicked:\n\n\t\n<button id=\"elem\" onclick=\"alert('Click!');\">Autoclick</button>\n\n<script>\n  let event = new Event(\"click\");\n  elem.dispatchEvent(event);\n</script>\nevent.isTrusted\n\nThere is a way to tell a “real” user event from a script-generated one.\n\nThe property event.isTrusted is true for events that come from real user actions and false for script-generated events.\n\nBubbling example\n\nWe can create a bubbling event with the name \"hello\" and catch it on document.\n\nAll we need is to set bubbles to true:\n\n\t\n<h1 id=\"elem\">Hello from the script!</h1>\n\n<script>\n  // catch on document...\n  document.addEventListener(\"hello\", function(event) { // (1)\n    alert(\"Hello from \" + event.target.tagName); // Hello from H1\n  });\n\n  // ...dispatch on elem!\n  let event = new Event(\"hello\", {bubbles: true}); // (2)\n  elem.dispatchEvent(event);\n\n  // the handler on document will activate and display the message.\n\n</script>\n\nNotes:\n\nWe should use addEventListener for our custom events, because on<event> only exists for built-in events, document.onhello doesn’t work.\nMust set bubbles:true, otherwise the event won’t bubble up.\n\nThe bubbling mechanics is the same for built-in (click) and custom (hello) events. There are also capturing and bubbling stages.\n\nMouseEvent, KeyboardEvent and others\n\nHere’s a short list of classes for UI Events from the UI Event specification:\n\nUIEvent\nFocusEvent\nMouseEvent\nWheelEvent\nKeyboardEvent\n…\n\nWe should use them instead of new Event if we want to create such events. For instance, new MouseEvent(\"click\").\n\nThe right constructor allows to specify standard properties for that type of event.\n\nLike clientX/clientY for a mouse event:\n\n\t\nlet event = new MouseEvent(\"click\", {\n  bubbles: true,\n  cancelable: true,\n  clientX: 100,\n  clientY: 100\n});\n\nalert(event.clientX); // 100\n\nPlease note: the generic Event constructor does not allow that.\n\nLet’s try:\n\n\t\nlet event = new Event(\"click\", {\n  bubbles: true, // only bubbles and cancelable\n  cancelable: true, // work in the Event constructor\n  clientX: 100,\n  clientY: 100\n});\n\nalert(event.clientX); // undefined, the unknown property is ignored!\n\nTechnically, we can work around that by assigning directly event.clientX=100 after creation. So that’s a matter of convenience and following the rules. Browser-generated events always have the right type.\n\nThe full list of properties for different UI events is in the specification, for instance, MouseEvent.\n\nCustom events\n\nFor our own, completely new events types like \"hello\" we should use new CustomEvent. Technically CustomEvent is the same as Event, with one exception.\n\nIn the second argument (object) we can add an additional property detail for any custom information that we want to pass with the event.\n\nFor instance:\n\n\t\n<h1 id=\"elem\">Hello for John!</h1>\n\n<script>\n  // additional details come with the event to the handler\n  elem.addEventListener(\"hello\", function(event) {\n    alert(event.detail.name);\n  });\n\n  elem.dispatchEvent(new CustomEvent(\"hello\", {\n    detail: { name: \"John\" }\n  }));\n</script>\n\nThe detail property can have any data. Technically we could live without, because we can assign any properties into a regular new Event object after its creation. But CustomEvent provides the special detail field for it to evade conflicts with other event properties.\n\nBesides, the event class describes “what kind of event” it is, and if the event is custom, then we should use CustomEvent just to be clear about what it is.\n\nevent.preventDefault()\n\nMany browser events have a “default action”, such as navigating to a link, starting a selection, and so on.\n\nFor new, custom events, there are definitely no default browser actions, but a code that dispatches such event may have its own plans what to do after triggering the event.\n\nBy calling event.preventDefault(), an event handler may send a signal that those actions should be canceled.\n\nIn that case the call to elem.dispatchEvent(event) returns false. And the code that dispatched it knows that it shouldn’t continue.\n\nLet’s see a practical example – a hiding rabbit (could be a closing menu or something else).\n\nBelow you can see a #rabbit and hide() function that dispatches \"hide\" event on it, to let all interested parties know that the rabbit is going to hide.\n\nAny handler can listen for that event with rabbit.addEventListener('hide',...) and, if needed, cancel the action using event.preventDefault(). Then the rabbit won’t disappear:\n\n\t\n<pre id=\"rabbit\">\n  |\\   /|\n   \\|_|/\n   /. .\\\n  =\\_Y_/=\n   {>o<}\n</pre>\n<button onclick=\"hide()\">Hide()</button>\n\n<script>\n  function hide() {\n    let event = new CustomEvent(\"hide\", {\n      cancelable: true // without that flag preventDefault doesn't work\n    });\n    if (!rabbit.dispatchEvent(event)) {\n      alert('The action was prevented by a handler');\n    } else {\n      rabbit.hidden = true;\n    }\n  }\n\n  rabbit.addEventListener('hide', function(event) {\n    if (confirm(\"Call preventDefault?\")) {\n      event.preventDefault();\n    }\n  });\n</script>\n\nPlease note: the event must have the flag cancelable: true, otherwise the call event.preventDefault() is ignored.\n\nEvents-in-events are synchronous\n\nUsually events are processed in a queue. That is: if the browser is processing onclick and a new event occurs, e.g. mouse moved, then its handling is queued up, corresponding mousemove handlers will be called after onclick processing is finished.\n\nThe notable exception is when one event is initiated from within another one, e.g. using dispatchEvent. Such events are processed immediately: the new event handlers are called, and then the current event handling is resumed.\n\nFor instance, in the code below the menu-open event is triggered during the onclick.\n\nIt’s processed immediately, without waiting for onclick handler to end:\n\n\t\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  menu.onclick = function() {\n    alert(1);\n\n    menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    }));\n\n    alert(2);\n  };\n\n  // triggers between 1 and 2\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n\nThe output order is: 1 → nested → 2.\n\nPlease note that the nested event menu-open is caught on the document. The propagation and handling of the nested event is finished before the processing gets back to the outer code (onclick).\n\nThat’s not only about dispatchEvent, there are other cases. If an event handler calls methods that trigger other events – they are processed synchronously too, in a nested fashion.\n\nLet’s say we don’t like it. We’d want onclick to be fully processed first, independently from menu-open or any other nested events.\n\nThen we can either put the dispatchEvent (or another event-triggering call) at the end of onclick or, maybe better, wrap it in the zero-delay setTimeout:\n\n\t\n<button id=\"menu\">Menu (click me)</button>\n\n<script>\n  menu.onclick = function() {\n    alert(1);\n\n    setTimeout(() => menu.dispatchEvent(new CustomEvent(\"menu-open\", {\n      bubbles: true\n    })));\n\n    alert(2);\n  };\n\n  document.addEventListener('menu-open', () => alert('nested'));\n</script>\n\nNow dispatchEvent runs asynchronously after the current code execution is finished, including menu.onclick, so event handlers are totally separate.\n\nThe output order becomes: 1 → 2 → nested.\n\nSummary\n\nTo generate an event from code, we first need to create an event object.\n\nThe generic Event(name, options) constructor accepts an arbitrary event name and the options object with two properties:\n\nbubbles: true if the event should bubble.\ncancelable: true if the event.preventDefault() should work.\n\nOther constructors of native events like MouseEvent, KeyboardEvent and so on accept properties specific to that event type. For instance, clientX for mouse events.\n\nFor custom events we should use CustomEvent constructor. It has an additional option named detail, we should assign the event-specific data to it. Then all handlers can access it as event.detail.\n\nDespite the technical possibility of generating browser events like click or keydown, we should use them with great care.\n\nWe shouldn’t generate browser events as it’s a hacky way to run handlers. That’s bad architecture most of the time.\n\nNative events might be generated:\n\nAs a dirty hack to make 3rd-party libraries work the needed way, if they don’t provide other means of interaction.\nFor automated testing, to “click the button” in the script and see if the interface reacts correctly.\n\nCustom events with our own names are often generated for architectural purposes, to signal what happens inside our menus, sliders, carousels etc."
  },
  {
    "title": "UI Events",
    "url": "https://javascript.info/event-details",
    "html": "Here we cover most important user interface events and how to work with them.\n\nMouse events\nMoving the mouse: mouseover/out, mouseenter/leave\nDrag'n'Drop with mouse events\nPointer events\nKeyboard: keydown and keyup\nScrolling"
  },
  {
    "title": "Introduction to browser events",
    "url": "https://javascript.info/introduction-browser-events",
    "html": "An event is a signal that something has happened. All DOM nodes generate such signals (but events are not limited to DOM).\n\nHere’s a list of the most useful DOM events, just to take a look at:\n\nMouse events:\n\nclick – when the mouse clicks on an element (touchscreen devices generate it on a tap).\ncontextmenu – when the mouse right-clicks on an element.\nmouseover / mouseout – when the mouse cursor comes over / leaves an element.\nmousedown / mouseup – when the mouse button is pressed / released over an element.\nmousemove – when the mouse is moved.\n\nKeyboard events:\n\nkeydown and keyup – when a keyboard key is pressed and released.\n\nForm element events:\n\nsubmit – when the visitor submits a <form>.\nfocus – when the visitor focuses on an element, e.g. on an <input>.\n\nDocument events:\n\nDOMContentLoaded – when the HTML is loaded and processed, DOM is fully built.\n\nCSS events:\n\ntransitionend – when a CSS-animation finishes.\n\nThere are many other events. We’ll get into more details of particular events in upcoming chapters.\n\nEvent handlers\n\nTo react on events we can assign a handler – a function that runs in case of an event.\n\nHandlers are a way to run JavaScript code in case of user actions.\n\nThere are several ways to assign a handler. Let’s see them, starting from the simplest one.\n\nHTML-attribute\n\nA handler can be set in HTML with an attribute named on<event>.\n\nFor instance, to assign a click handler for an input, we can use onclick, like here:\n\n\t\n<input value=\"Click me\" onclick=\"alert('Click!')\" type=\"button\">\n\nOn mouse click, the code inside onclick runs.\n\nPlease note that inside onclick we use single quotes, because the attribute itself is in double quotes. If we forget that the code is inside the attribute and use double quotes inside, like this: onclick=\"alert(\"Click!\")\", then it won’t work right.\n\nAn HTML-attribute is not a convenient place to write a lot of code, so we’d better create a JavaScript function and call it there.\n\nHere a click runs the function countRabbits():\n\n<script>\n  function countRabbits() {\n    for(let i=1; i<=3; i++) {\n      alert(\"Rabbit number \" + i);\n    }\n  }\n</script>\n\n<input type=\"button\" onclick=\"countRabbits()\" value=\"Count rabbits!\">\n\nAs we know, HTML attribute names are not case-sensitive, so ONCLICK works as well as onClick and onCLICK… But usually attributes are lowercased: onclick.\n\nDOM property\n\nWe can assign a handler using a DOM property on<event>.\n\nFor instance, elem.onclick:\n\n<input id=\"elem\" type=\"button\" value=\"Click me\">\n<script>\n  elem.onclick = function() {\n    alert('Thank you');\n  };\n</script>\n\nIf the handler is assigned using an HTML-attribute then the browser reads it, creates a new function from the attribute content and writes it to the DOM property.\n\nSo this way is actually the same as the previous one.\n\nThese two code pieces work the same:\n\nOnly HTML:\n\n<input type=\"button\" onclick=\"alert('Click!')\" value=\"Button\">\n\nHTML + JS:\n\n<input type=\"button\" id=\"button\" value=\"Button\">\n<script>\n  button.onclick = function() {\n    alert('Click!');\n  };\n</script>\n\nIn the first example, the HTML attribute is used to initialize the button.onclick, while in the second example – the script, that’s all the difference.\n\nAs there’s only one onclick property, we can’t assign more than one event handler.\n\nIn the example below adding a handler with JavaScript overwrites the existing handler:\n\n\t\n<input type=\"button\" id=\"elem\" onclick=\"alert('Before')\" value=\"Click me\">\n<script>\n  elem.onclick = function() { // overwrites the existing handler\n    alert('After'); // only this will be shown\n  };\n</script>\n\nTo remove a handler – assign elem.onclick = null.\n\nAccessing the element: this\n\nThe value of this inside a handler is the element. The one which has the handler on it.\n\nIn the code below button shows its contents using this.innerHTML:\n\n<button onclick=\"alert(this.innerHTML)\">Click me</button>\nPossible mistakes\n\nIf you’re starting to work with events – please note some subtleties.\n\nWe can set an existing function as a handler:\n\nfunction sayThanks() {\n  alert('Thanks!');\n}\n\nelem.onclick = sayThanks;\n\nBut be careful: the function should be assigned as sayThanks, not sayThanks().\n\n// right\nbutton.onclick = sayThanks;\n\n// wrong\nbutton.onclick = sayThanks();\n\nIf we add parentheses, then sayThanks() becomes a function call. So the last line actually takes the result of the function execution, that is undefined (as the function returns nothing), and assigns it to onclick. That doesn’t work.\n\n…On the other hand, in the markup we do need the parentheses:\n\n<input type=\"button\" id=\"button\" onclick=\"sayThanks()\">\n\nThe difference is easy to explain. When the browser reads the attribute, it creates a handler function with body from the attribute content.\n\nSo the markup generates this property:\n\nbutton.onclick = function() {\n  sayThanks(); // <-- the attribute content goes here\n};\n\nDon’t use setAttribute for handlers.\n\nSuch a call won’t work:\n\n\t\n// a click on <body> will generate errors,\n// because attributes are always strings, function becomes a string\ndocument.body.setAttribute('onclick', function() { alert(1) });\n\nDOM-property case matters.\n\nAssign a handler to elem.onclick, not elem.ONCLICK, because DOM properties are case-sensitive.\n\naddEventListener\n\nThe fundamental problem of the aforementioned ways to assign handlers is that we can’t assign multiple handlers to one event.\n\nLet’s say, one part of our code wants to highlight a button on click, and another one wants to show a message on the same click.\n\nWe’d like to assign two event handlers for that. But a new DOM property will overwrite the existing one:\n\ninput.onclick = function() { alert(1); }\n// ...\ninput.onclick = function() { alert(2); } // replaces the previous handler\n\nDevelopers of web standards understood that long ago and suggested an alternative way of managing handlers using the special methods addEventListener and removeEventListener which aren’t bound by such constraint.\n\nThe syntax to add a handler:\n\nelement.addEventListener(event, handler, [options]);\nevent\nEvent name, e.g. \"click\".\nhandler\nThe handler function.\noptions\nAn additional optional object with properties:\nonce: if true, then the listener is automatically removed after it triggers.\ncapture: the phase where to handle the event, to be covered later in the chapter Bubbling and capturing. For historical reasons, options can also be false/true, that’s the same as {capture: false/true}.\npassive: if true, then the handler will not call preventDefault(), we’ll explain that later in Browser default actions.\n\nTo remove the handler, use removeEventListener:\n\nelement.removeEventListener(event, handler, [options]);\nRemoval requires the same function\n\nTo remove a handler we should pass exactly the same function as was assigned.\n\nThis doesn’t work:\n\nelem.addEventListener( \"click\" , () => alert('Thanks!'));\n// ....\nelem.removeEventListener( \"click\", () => alert('Thanks!'));\n\nThe handler won’t be removed, because removeEventListener gets another function – with the same code, but that doesn’t matter, as it’s a different function object.\n\nHere’s the right way:\n\nfunction handler() {\n  alert( 'Thanks!' );\n}\n\ninput.addEventListener(\"click\", handler);\n// ....\ninput.removeEventListener(\"click\", handler);\n\nPlease note – if we don’t store the function in a variable, then we can’t remove it. There’s no way to “read back” handlers assigned by addEventListener.\n\nMultiple calls to addEventListener allow it to add multiple handlers, like this:\n\n\t\n<input id=\"elem\" type=\"button\" value=\"Click me\"/>\n\n<script>\n  function handler1() {\n    alert('Thanks!');\n  };\n\n  function handler2() {\n    alert('Thanks again!');\n  }\n\n  elem.onclick = () => alert(\"Hello\");\n  elem.addEventListener(\"click\", handler1); // Thanks!\n  elem.addEventListener(\"click\", handler2); // Thanks again!\n</script>\n\nAs we can see in the example above, we can set handlers both using a DOM-property and addEventListener. But generally we use only one of these ways.\n\nFor some events, handlers only work with addEventListener\n\nThere exist events that can’t be assigned via a DOM-property. Only with addEventListener.\n\nFor instance, the DOMContentLoaded event, that triggers when the document is loaded and the DOM has been built.\n\n// will never run\ndocument.onDOMContentLoaded = function() {\n  alert(\"DOM built\");\n};\n// this way it works\ndocument.addEventListener(\"DOMContentLoaded\", function() {\n  alert(\"DOM built\");\n});\n\nSo addEventListener is more universal. Although, such events are an exception rather than the rule.\n\nEvent object\n\nTo properly handle an event we’d want to know more about what’s happened. Not just a “click” or a “keydown”, but what were the pointer coordinates? Which key was pressed? And so on.\n\nWhen an event happens, the browser creates an event object, puts details into it and passes it as an argument to the handler.\n\nHere’s an example of getting pointer coordinates from the event object:\n\n\t\n<input type=\"button\" value=\"Click me\" id=\"elem\">\n\n<script>\n  elem.onclick = function(event) {\n    // show event type, element and coordinates of the click\n    alert(event.type + \" at \" + event.currentTarget);\n    alert(\"Coordinates: \" + event.clientX + \":\" + event.clientY);\n  };\n</script>\n\nSome properties of event object:\n\nevent.type\nEvent type, here it’s \"click\".\nevent.currentTarget\nElement that handled the event. That’s exactly the same as this, unless the handler is an arrow function, or its this is bound to something else, then we can get the element from event.currentTarget.\nevent.clientX / event.clientY\nWindow-relative coordinates of the cursor, for pointer events.\n\nThere are more properties. Many of them depend on the event type: keyboard events have one set of properties, pointer events – another one, we’ll study them later when as we move on to the details of different events.\n\nThe event object is also available in HTML handlers\n\nIf we assign a handler in HTML, we can also use the event object, like this:\n\n<input type=\"button\" onclick=\"alert(event.type)\" value=\"Event type\">\n\nThat’s possible because when the browser reads the attribute, it creates a handler like this: function(event) { alert(event.type) }. That is: its first argument is called \"event\", and the body is taken from the attribute.\n\nObject handlers: handleEvent\n\nWe can assign not just a function, but an object as an event handler using addEventListener. When an event occurs, its handleEvent method is called.\n\nFor instance:\n\n\t\n<button id=\"elem\">Click me</button>\n\n<script>\n  let obj = {\n    handleEvent(event) {\n      alert(event.type + \" at \" + event.currentTarget);\n    }\n  };\n\n  elem.addEventListener('click', obj);\n</script>\n\nAs we can see, when addEventListener receives an object as the handler, it calls obj.handleEvent(event) in case of an event.\n\nWe could also use objects of a custom class, like this:\n\n\t\n<button id=\"elem\">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      switch(event.type) {\n        case 'mousedown':\n          elem.innerHTML = \"Mouse button pressed\";\n          break;\n        case 'mouseup':\n          elem.innerHTML += \"...and released.\";\n          break;\n      }\n    }\n  }\n\n  let menu = new Menu();\n\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n</script>\n\nHere the same object handles both events. Please note that we need to explicitly setup the events to listen using addEventListener. The menu object only gets mousedown and mouseup here, not any other types of events.\n\nThe method handleEvent does not have to do all the job by itself. It can call other event-specific methods instead, like this:\n\n\t\n<button id=\"elem\">Click me</button>\n\n<script>\n  class Menu {\n    handleEvent(event) {\n      // mousedown -> onMousedown\n      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);\n      this[method](event);\n    }\n\n    onMousedown() {\n      elem.innerHTML = \"Mouse button pressed\";\n    }\n\n    onMouseup() {\n      elem.innerHTML += \"...and released.\";\n    }\n  }\n\n  let menu = new Menu();\n  elem.addEventListener('mousedown', menu);\n  elem.addEventListener('mouseup', menu);\n</script>\n\nNow event handlers are clearly separated, that may be easier to support.\n\nSummary\n\nThere are 3 ways to assign event handlers:\n\nHTML attribute: onclick=\"...\".\nDOM property: elem.onclick = function.\nMethods: elem.addEventListener(event, handler[, phase]) to add, removeEventListener to remove.\n\nHTML attributes are used sparingly, because JavaScript in the middle of an HTML tag looks a little bit odd and alien. Also can’t write lots of code in there.\n\nDOM properties are ok to use, but we can’t assign more than one handler of the particular event. In many cases that limitation is not pressing.\n\nThe last way is the most flexible, but it is also the longest to write. There are few events that only work with it, for instance transitionend and DOMContentLoaded (to be covered). Also addEventListener supports objects as event handlers. In that case the method handleEvent is called in case of the event.\n\nNo matter how you assign the handler – it gets an event object as the first argument. That object contains the details about what’s happened.\n\nWe’ll learn more about events in general and about different types of events in the next chapters.\n\nTasks\nHide on click\nimportance: 5\n\nAdd JavaScript to the button to make <div id=\"text\"> disappear when we click it.\n\nThe demo:\n\nOpen a sandbox for the task.\n\nsolution\nHide self\nimportance: 5\n\nCreate a button that hides itself on click.\n\nLike this: \n\nsolution\nWhich handlers run?\nimportance: 5\n\nThere’s a button in the variable. There are no handlers on it.\n\nWhich handlers run on click after the following code? Which alerts show up?\n\nbutton.addEventListener(\"click\", () => alert(\"1\"));\n\nbutton.removeEventListener(\"click\", () => alert(\"1\"));\n\nbutton.onclick = () => alert(2);\nsolution\nMove the ball across the field\nimportance: 5\n\nMove the ball across the field to a click. Like this:\n\nRequirements:\n\nThe ball center should come exactly under the pointer on click (if possible without crossing the field edge).\nCSS-animation is welcome.\nThe ball must not cross field boundaries.\nWhen the page is scrolled, nothing should break.\n\nNotes:\n\nThe code should also work with different ball and field sizes, not be bound to any fixed values.\nUse properties event.clientX/event.clientY for click coordinates.\n\nOpen a sandbox for the task.\n\nsolution\nCreate a sliding menu\nimportance: 5\n\nCreate a menu that opens/collapses on click:\n\nP.S. HTML/CSS of the source document is to be modified.\n\nOpen a sandbox for the task.\n\nsolution\nAdd a closing button\nimportance: 5\n\nThere’s a list of messages.\n\nUse JavaScript to add a closing button to the right-upper corner of each message.\n\nThe result should look like this:\n\nOpen a sandbox for the task.\n\nsolution\nCarousel\nimportance: 4\n\nCreate a “carousel” – a ribbon of images that can be scrolled by clicking on arrows.\n\nLater we can add more features to it: infinite scrolling, dynamic loading etc.\n\nP.S. For this task HTML/CSS structure is actually 90% of the solution.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Bubbling and capturing",
    "url": "https://javascript.info/bubbling-and-capturing",
    "html": "Let’s start with an example.\n\nThis handler is assigned to <div>, but also runs if you click any nested tag like <em> or <code>:\n\n<div onclick=\"alert('The handler!')\">\n  <em>If you click on <code>EM</code>, the handler on <code>DIV</code> runs.</em>\n</div>\n\nIsn’t it a bit strange? Why does the handler on <div> run if the actual click was on <em>?\n\nBubbling\n\nThe bubbling principle is simple.\n\nWhen an event happens on an element, it first runs the handlers on it, then on its parent, then all the way up on other ancestors.\n\nLet’s say we have 3 nested elements FORM > DIV > P with a handler on each of them:\n\n\t\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form onclick=\"alert('form')\">FORM\n  <div onclick=\"alert('div')\">DIV\n    <p onclick=\"alert('p')\">P</p>\n  </div>\n</form>\n\nA click on the inner <p> first runs onclick:\n\nOn that <p>.\nThen on the outer <div>.\nThen on the outer <form>.\nAnd so on upwards till the document object.\n\nSo if we click on <p>, then we’ll see 3 alerts: p → div → form.\n\nThe process is called “bubbling”, because events “bubble” from the inner element up through parents like a bubble in the water.\n\nAlmost all events bubble.\n\nThe key word in this phrase is “almost”.\n\nFor instance, a focus event does not bubble. There are other examples too, we’ll meet them. But still it’s an exception, rather than a rule, most events do bubble.\n\nevent.target\n\nA handler on a parent element can always get the details about where it actually happened.\n\nThe most deeply nested element that caused the event is called a target element, accessible as event.target.\n\nNote the differences from this (=event.currentTarget):\n\nevent.target – is the “target” element that initiated the event, it doesn’t change through the bubbling process.\nthis – is the “current” element, the one that has a currently running handler on it.\n\nFor instance, if we have a single handler form.onclick, then it can “catch” all clicks inside the form. No matter where the click happened, it bubbles up to <form> and runs the handler.\n\nIn form.onclick handler:\n\nthis (=event.currentTarget) is the <form> element, because the handler runs on it.\nevent.target is the actual element inside the form that was clicked.\n\nCheck it out:\n\nResultscript.jsexample.cssindex.html\n\t\n\nIt’s possible that event.target could equal this – it happens when the click is made directly on the <form> element.\n\nStopping bubbling\n\nA bubbling event goes from the target element straight up. Normally it goes upwards till <html>, and then to document object, and some events even reach window, calling all handlers on the path.\n\nBut any handler may decide that the event has been fully processed and stop the bubbling.\n\nThe method for it is event.stopPropagation().\n\nFor instance, here body.onclick doesn’t work if you click on <button>:\n\n\t\n<body onclick=\"alert(`the bubbling doesn't reach here`)\">\n  <button onclick=\"event.stopPropagation()\">Click me</button>\n</body>\nevent.stopImmediatePropagation()\n\nIf an element has multiple event handlers on a single event, then even if one of them stops the bubbling, the other ones still execute.\n\nIn other words, event.stopPropagation() stops the move upwards, but on the current element all other handlers will run.\n\nTo stop the bubbling and prevent handlers on the current element from running, there’s a method event.stopImmediatePropagation(). After it no other handlers execute.\n\nDon’t stop bubbling without a need!\n\nBubbling is convenient. Don’t stop it without a real need: obvious and architecturally well thought out.\n\nSometimes event.stopPropagation() creates hidden pitfalls that later may become problems.\n\nFor instance:\n\nWe create a nested menu. Each submenu handles clicks on its elements and calls stopPropagation so that the outer menu won’t trigger.\nLater we decide to catch clicks on the whole window, to track users’ behavior (where people click). Some analytic systems do that. Usually the code uses document.addEventListener('click'…) to catch all clicks.\nOur analytic won’t work over the area where clicks are stopped by stopPropagation. Sadly, we’ve got a “dead zone”.\n\nThere’s usually no real need to prevent the bubbling. A task that seemingly requires that may be solved by other means. One of them is to use custom events, we’ll cover them later. Also we can write our data into the event object in one handler and read it in another one, so we can pass to handlers on parents information about the processing below.\n\nCapturing\n\nThere’s another phase of event processing called “capturing”. It is rarely used in real code, but sometimes can be useful.\n\nThe standard DOM Events describes 3 phases of event propagation:\n\nCapturing phase – the event goes down to the element.\nTarget phase – the event reached the target element.\nBubbling phase – the event bubbles up from the element.\n\nHere’s the picture, taken from the specification, of the capturing (1), target (2) and bubbling (3) phases for a click event on a <td> inside a table:\n\nThat is: for a click on <td> the event first goes through the ancestors chain down to the element (capturing phase), then it reaches the target and triggers there (target phase), and then it goes up (bubbling phase), calling handlers on its way.\n\nUntil now, we only talked about bubbling, because the capturing phase is rarely used.\n\nIn fact, the capturing phase was invisible for us, because handlers added using on<event>-property or using HTML attributes or using two-argument addEventListener(event, handler) don’t know anything about capturing, they only run on the 2nd and 3rd phases.\n\nTo catch an event on the capturing phase, we need to set the handler capture option to true:\n\nelem.addEventListener(..., {capture: true})\n\n// or, just \"true\" is an alias to {capture: true}\nelem.addEventListener(..., true)\n\nThere are two possible values of the capture option:\n\nIf it’s false (default), then the handler is set on the bubbling phase.\nIf it’s true, then the handler is set on the capturing phase.\n\nNote that while formally there are 3 phases, the 2nd phase (“target phase”: the event reached the element) is not handled separately: handlers on both capturing and bubbling phases trigger at that phase.\n\nLet’s see both capturing and bubbling in action:\n\n\t\n<style>\n  body * {\n    margin: 10px;\n    border: 1px solid blue;\n  }\n</style>\n\n<form>FORM\n  <div>DIV\n    <p>P</p>\n  </div>\n</form>\n\n<script>\n  for(let elem of document.querySelectorAll('*')) {\n    elem.addEventListener(\"click\", e => alert(`Capturing: ${elem.tagName}`), true);\n    elem.addEventListener(\"click\", e => alert(`Bubbling: ${elem.tagName}`));\n  }\n</script>\n\nThe code sets click handlers on every element in the document to see which ones are working.\n\nIf you click on <p>, then the sequence is:\n\nHTML → BODY → FORM → DIV -> P (capturing phase, the first listener):\nP → DIV → FORM → BODY → HTML (bubbling phase, the second listener).\n\nPlease note, the P shows up twice, because we’ve set two listeners: capturing and bubbling. The target triggers at the end of the first and at the beginning of the second phase.\n\nThere’s a property event.eventPhase that tells us the number of the phase on which the event was caught. But it’s rarely used, because we usually know it in the handler.\n\nTo remove the handler, removeEventListener needs the same phase\n\nIf we addEventListener(..., true), then we should mention the same phase in removeEventListener(..., true) to correctly remove the handler.\n\nListeners on the same element and same phase run in their set order\n\nIf we have multiple event handlers on the same phase, assigned to the same element with addEventListener, they run in the same order as they are created:\n\nelem.addEventListener(\"click\", e => alert(1)); // guaranteed to trigger first\nelem.addEventListener(\"click\", e => alert(2));\nThe event.stopPropagation() during the capturing also prevents the bubbling\n\nThe event.stopPropagation() method and its sibling event.stopImmediatePropagation() can also be called on the capturing phase. Then not only the futher capturing is stopped, but the bubbling as well.\n\nIn other words, normally the event goes first down (“capturing”) and then up (“bubbling”). But if event.stopPropagation() is called during the capturing phase, then the event travel stops, no bubbling will occur.\n\nSummary\n\nWhen an event happens – the most nested element where it happens gets labeled as the “target element” (event.target).\n\nThen the event moves down from the document root to event.target, calling handlers assigned with addEventListener(..., true) on the way (true is a shorthand for {capture: true}).\nThen handlers are called on the target element itself.\nThen the event bubbles up from event.target to the root, calling handlers assigned using on<event>, HTML attributes and addEventListener without the 3rd argument or with the 3rd argument false/{capture:false}.\n\nEach handler can access event object properties:\n\nevent.target – the deepest element that originated the event.\nevent.currentTarget (=this) – the current element that handles the event (the one that has the handler on it)\nevent.eventPhase – the current phase (capturing=1, target=2, bubbling=3).\n\nAny event handler can stop the event by calling event.stopPropagation(), but that’s not recommended, because we can’t really be sure we won’t need it above, maybe for completely different things.\n\nThe capturing phase is used very rarely, usually we handle events on bubbling. And there’s a logical explanation for that.\n\nIn real world, when an accident happens, local authorities react first. They know best the area where it happened. Then higher-level authorities if needed.\n\nThe same for event handlers. The code that set the handler on a particular element knows maximum details about the element and what it does. A handler on a particular <td> may be suited for that exactly <td>, it knows everything about it, so it should get the chance first. Then its immediate parent also knows about the context, but a little bit less, and so on till the very top element that handles general concepts and runs the last one.\n\nBubbling and capturing lay the foundation for “event delegation” – an extremely powerful event handling pattern that we study in the next chapter."
  },
  {
    "title": "Coordinates",
    "url": "https://javascript.info/coordinates",
    "html": "To move elements around we should be familiar with coordinates.\n\nMost JavaScript methods deal with one of two coordinate systems:\n\nRelative to the window – similar to position:fixed, calculated from the window top/left edge.\nwe’ll denote these coordinates as clientX/clientY, the reasoning for such name will become clear later, when we study event properties.\nRelative to the document – similar to position:absolute in the document root, calculated from the document top/left edge.\nwe’ll denote them pageX/pageY.\n\nWhen the page is scrolled to the very beginning, so that the top/left corner of the window is exactly the document top/left corner, these coordinates equal each other. But after the document shifts, window-relative coordinates of elements change, as elements move across the window, while document-relative coordinates remain the same.\n\nOn this picture we take a point in the document and demonstrate its coordinates before the scroll (left) and after it (right):\n\nWhen the document scrolled:\n\npageY – document-relative coordinate stayed the same, it’s counted from the document top (now scrolled out).\nclientY – window-relative coordinate did change (the arrow became shorter), as the same point became closer to window top.\nElement coordinates: getBoundingClientRect\n\nThe method elem.getBoundingClientRect() returns window coordinates for a minimal rectangle that encloses elem as an object of built-in DOMRect class.\n\nMain DOMRect properties:\n\nx/y – X/Y-coordinates of the rectangle origin relative to window,\nwidth/height – width/height of the rectangle (can be negative).\n\nAdditionally, there are derived properties:\n\ntop/bottom – Y-coordinate for the top/bottom rectangle edge,\nleft/right – X-coordinate for the left/right rectangle edge.\n\nFor instance click this button to see its window coordinates:\n\nIf you scroll the page and repeat, you’ll notice that as window-relative button position changes, its window coordinates (y/top/bottom if you scroll vertically) change as well.\n\nHere’s the picture of elem.getBoundingClientRect() output:\n\nAs you can see, x/y and width/height fully describe the rectangle. Derived properties can be easily calculated from them:\n\nleft = x\ntop = y\nright = x + width\nbottom = y + height\n\nPlease note:\n\nCoordinates may be decimal fractions, such as 10.5. That’s normal, internally browser uses fractions in calculations. We don’t have to round them when setting to style.left/top.\nCoordinates may be negative. For instance, if the page is scrolled so that elem is now above the window, then elem.getBoundingClientRect().top is negative.\nWhy derived properties are needed? Why does top/left exist if there’s x/y?\n\nMathematically, a rectangle is uniquely defined with its starting point (x,y) and the direction vector (width,height). So the additional derived properties are for convenience.\n\nTechnically it’s possible for width/height to be negative, that allows for “directed” rectangle, e.g. to represent mouse selection with properly marked start and end.\n\nNegative width/height values mean that the rectangle starts at its bottom-right corner and then “grows” left-upwards.\n\nHere’s a rectangle with negative width and height (e.g. width=-200, height=-100):\n\nAs you can see, left/top do not equal x/y in such case.\n\nIn practice though, elem.getBoundingClientRect() always returns positive width/height, here we mention negative width/height only for you to understand why these seemingly duplicate properties are not actually duplicates.\n\nInternet Explorer: no support for x/y\n\nInternet Explorer doesn’t support x/y properties for historical reasons.\n\nSo we can either make a polyfill (add getters in DomRect.prototype) or just use top/left, as they are always the same as x/y for positive width/height, in particular in the result of elem.getBoundingClientRect().\n\nCoordinates right/bottom are different from CSS position properties\n\nThere are obvious similarities between window-relative coordinates and CSS position:fixed.\n\nBut in CSS positioning, right property means the distance from the right edge, and bottom property means the distance from the bottom edge.\n\nIf we just look at the picture above, we can see that in JavaScript it is not so. All window coordinates are counted from the top-left corner, including these ones.\n\nelementFromPoint(x, y)\n\nThe call to document.elementFromPoint(x, y) returns the most nested element at window coordinates (x, y).\n\nThe syntax is:\n\nlet elem = document.elementFromPoint(x, y);\n\nFor instance, the code below highlights and outputs the tag of the element that is now in the middle of the window:\n\n\t\nlet centerX = document.documentElement.clientWidth / 2;\nlet centerY = document.documentElement.clientHeight / 2;\n\nlet elem = document.elementFromPoint(centerX, centerY);\n\nelem.style.background = \"red\";\nalert(elem.tagName);\n\nAs it uses window coordinates, the element may be different depending on the current scroll position.\n\nFor out-of-window coordinates the elementFromPoint returns null\n\nThe method document.elementFromPoint(x,y) only works if (x,y) are inside the visible area.\n\nIf any of the coordinates is negative or exceeds the window width/height, then it returns null.\n\nHere’s a typical error that may occur if we don’t check for it:\n\nlet elem = document.elementFromPoint(x, y);\n// if the coordinates happen to be out of the window, then elem = null\nelem.style.background = ''; // Error!\nUsing for “fixed” positioning\n\nMost of time we need coordinates in order to position something.\n\nTo show something near an element, we can use getBoundingClientRect to get its coordinates, and then CSS position together with left/top (or right/bottom).\n\nFor instance, the function createMessageUnder(elem, html) below shows the message under elem:\n\nlet elem = document.getElementById(\"coords-show-mark\");\n\nfunction createMessageUnder(elem, html) {\n  // create message element\n  let message = document.createElement('div');\n  // better to use a css class for the style here\n  message.style.cssText = \"position:fixed; color: red\";\n\n  // assign coordinates, don't forget \"px\"!\n  let coords = elem.getBoundingClientRect();\n\n  message.style.left = coords.left + \"px\";\n  message.style.top = coords.bottom + \"px\";\n\n  message.innerHTML = html;\n\n  return message;\n}\n\n// Usage:\n// add it for 5 seconds in the document\nlet message = createMessageUnder(elem, 'Hello, world!');\ndocument.body.append(message);\nsetTimeout(() => message.remove(), 5000);\n\nClick the button to run it:\n\nButton with id=“coords-show-mark”, the message will appear under it\n\nThe code can be modified to show the message at the left, right, below, apply CSS animations to “fade it in” and so on. That’s easy, as we have all the coordinates and sizes of the element.\n\nBut note the important detail: when the page is scrolled, the message flows away from the button.\n\nThe reason is obvious: the message element relies on position:fixed, so it remains at the same place of the window while the page scrolls away.\n\nTo change that, we need to use document-based coordinates and position:absolute.\n\nDocument coordinates\n\nDocument-relative coordinates start from the upper-left corner of the document, not the window.\n\nIn CSS, window coordinates correspond to position:fixed, while document coordinates are similar to position:absolute on top.\n\nWe can use position:absolute and top/left to put something at a certain place of the document, so that it remains there during a page scroll. But we need the right coordinates first.\n\nThere’s no standard method to get the document coordinates of an element. But it’s easy to write it.\n\nThe two coordinate systems are connected by the formula:\n\npageY = clientY + height of the scrolled-out vertical part of the document.\npageX = clientX + width of the scrolled-out horizontal part of the document.\n\nThe function getCoords(elem) will take window coordinates from elem.getBoundingClientRect() and add the current scroll to them:\n\n// get document coordinates of the element\nfunction getCoords(elem) {\n  let box = elem.getBoundingClientRect();\n\n  return {\n    top: box.top + window.pageYOffset,\n    right: box.right + window.pageXOffset,\n    bottom: box.bottom + window.pageYOffset,\n    left: box.left + window.pageXOffset\n  };\n}\n\nIf in the example above we used it with position:absolute, then the message would stay near the element on scroll.\n\nThe modified createMessageUnder function:\n\nfunction createMessageUnder(elem, html) {\n  let message = document.createElement('div');\n  message.style.cssText = \"position:absolute; color: red\";\n\n  let coords = getCoords(elem);\n\n  message.style.left = coords.left + \"px\";\n  message.style.top = coords.bottom + \"px\";\n\n  message.innerHTML = html;\n\n  return message;\n}\nSummary\n\nAny point on the page has coordinates:\n\nRelative to the window – elem.getBoundingClientRect().\nRelative to the document – elem.getBoundingClientRect() plus the current page scroll.\n\nWindow coordinates are great to use with position:fixed, and document coordinates do well with position:absolute.\n\nBoth coordinate systems have their pros and cons; there are times we need one or the other one, just like CSS position absolute and fixed.\n\nTasks\nFind window coordinates of the field\nimportance: 5\n\nIn the iframe below you can see a document with the green “field”.\n\nUse JavaScript to find window coordinates of corners pointed by with arrows.\n\nThere’s a small feature implemented in the document for convenience. A click at any place shows coordinates there.\n\n\t\n\nYour code should use DOM to get window coordinates of:\n\nUpper-left, outer corner (that’s simple).\nBottom-right, outer corner (simple too).\nUpper-left, inner corner (a bit harder).\nBottom-right, inner corner (there are several ways, choose one).\n\nThe coordinates that you calculate should be the same as those returned by the mouse click.\n\nP.S. The code should also work if the element has another size or border, not bound to any fixed values.\n\nOpen a sandbox for the task.\n\nsolution\nShow a note near the element\nimportance: 5\n\nCreate a function positionAt(anchor, position, elem) that positions elem, depending on position near anchor element.\n\nThe position must be a string with any one of 3 values:\n\n\"top\" – position elem right above anchor\n\"right\" – position elem immediately at the right of anchor\n\"bottom\" – position elem right below anchor\n\nIt’s used inside function showNote(anchor, position, html), provided in the task source code, that creates a “note” element with given html and shows it at the given position near the anchor.\n\nHere’s the demo of notes:\n\nOpen a sandbox for the task.\n\nsolution\nShow a note near the element (absolute)\nimportance: 5\n\nModify the solution of the previous task so that the note uses position:absolute instead of position:fixed.\n\nThat will prevent its “runaway” from the element when the page scrolls.\n\nTake the solution of that task as a starting point. To test the scroll, add the style <body style=\"height: 2000px\">.\n\nsolution\nPosition the note inside (absolute)\nimportance: 5\n\nExtend the previous task Show a note near the element (absolute): teach the function positionAt(anchor, position, elem) to insert elem inside the anchor.\n\nNew values for position:\n\ntop-out, right-out, bottom-out – work the same as before, they insert the elem over/right/under anchor.\ntop-in, right-in, bottom-in – insert elem inside the anchor: stick it to the upper/right/bottom edge.\n\nFor instance:\n\n// shows the note above blockquote\npositionAt(blockquote, \"top-out\", note);\n\n// shows the note inside blockquote, at the top\npositionAt(blockquote, \"top-in\", note);\n\nThe result:\n\nAs the source code, take the solution of the task Show a note near the element (absolute).\n\nsolution"
  },
  {
    "title": "Introduction to Events",
    "url": "https://javascript.info/events",
    "html": "An introduction to browser events, event properties and handling patterns.\n\nIntroduction to browser events\nBubbling and capturing\nEvent delegation\nBrowser default actions\nDispatching custom events"
  },
  {
    "title": "Element size and scrolling",
    "url": "https://javascript.info/size-and-scroll",
    "html": "There are many JavaScript properties that allow us to read information about element width, height and other geometry features.\n\nWe often need them when moving or positioning elements in JavaScript.\n\nSample element\n\nAs a sample element to demonstrate properties we’ll use the one given below:\n\n<div id=\"example\">\n  ...Text...\n</div>\n<style>\n  #example {\n    width: 300px;\n    height: 200px;\n    border: 25px solid #E8C48F;\n    padding: 20px;\n    overflow: auto;\n  }\n</style>\n\nIt has the border, padding and scrolling. The full set of features. There are no margins, as they are not the part of the element itself, and there are no special properties for them.\n\nThe element looks like this:\n\nYou can open the document in the sandbox.\n\nMind the scrollbar\n\nThe picture above demonstrates the most complex case when the element has a scrollbar. Some browsers (not all) reserve the space for it by taking it from the content (labeled as “content width” above).\n\nSo, without scrollbar the content width would be 300px, but if the scrollbar is 16px wide (the width may vary between devices and browsers) then only 300 - 16 = 284px remains, and we should take it into account. That’s why examples from this chapter assume that there’s a scrollbar. Without it, some calculations are simpler.\n\nThe padding-bottom area may be filled with text\n\nUsually paddings are shown empty on our illustrations, but if there’s a lot of text in the element and it overflows, then browsers show the “overflowing” text at padding-bottom, that’s normal.\n\nGeometry\n\nHere’s the overall picture with geometry properties:\n\nValues of these properties are technically numbers, but these numbers are “of pixels”, so these are pixel measurements.\n\nLet’s start exploring the properties starting from the outside of the element.\n\noffsetParent, offsetLeft/Top\n\nThese properties are rarely needed, but still they are the “most outer” geometry properties, so we’ll start with them.\n\nThe offsetParent is the nearest ancestor that the browser uses for calculating coordinates during rendering.\n\nThat’s the nearest ancestor that is one of the following:\n\nCSS-positioned (position is absolute, relative, fixed or sticky), or\n<td>, <th>, or <table>, or\n<body>.\n\nProperties offsetLeft/offsetTop provide x/y coordinates relative to offsetParent upper-left corner.\n\nIn the example below the inner <div> has <main> as offsetParent and offsetLeft/offsetTop shifts from its upper-left corner (180):\n\n\t\n<main style=\"position: relative\" id=\"main\">\n  <article>\n    <div id=\"example\" style=\"position: absolute; left: 180px; top: 180px\">...</div>\n  </article>\n</main>\n<script>\n  alert(example.offsetParent.id); // main\n  alert(example.offsetLeft); // 180 (note: a number, not a string \"180px\")\n  alert(example.offsetTop); // 180\n</script>\n\nThere are several occasions when offsetParent is null:\n\nFor not shown elements (display:none or not in the document).\nFor <body> and <html>.\nFor elements with position:fixed.\noffsetWidth/Height\n\nNow let’s move on to the element itself.\n\nThese two properties are the simplest ones. They provide the “outer” width/height of the element. Or, in other words, its full size including borders.\n\nFor our sample element:\n\noffsetWidth = 390 – the outer width, can be calculated as inner CSS-width (300px) plus paddings (2 * 20px) and borders (2 * 25px).\noffsetHeight = 290 – the outer height.\nGeometry properties are zero/null for elements that are not displayed\n\nGeometry properties are calculated only for displayed elements.\n\nIf an element (or any of its ancestors) has display:none or is not in the document, then all geometry properties are zero (or null for offsetParent).\n\nFor example, offsetParent is null, and offsetWidth, offsetHeight are 0 when we created an element, but haven’t inserted it into the document yet, or it (or its ancestor) has display:none.\n\nWe can use this to check if an element is hidden, like this:\n\nfunction isHidden(elem) {\n  return !elem.offsetWidth && !elem.offsetHeight;\n}\n\nPlease note that such isHidden returns true for elements that are on-screen, but have zero sizes.\n\nclientTop/Left\n\nInside the element we have the borders.\n\nTo measure them, there are properties clientTop and clientLeft.\n\nIn our example:\n\nclientLeft = 25 – left border width\nclientTop = 25 – top border width\n\n…But to be precise – these properties are not border width/height, but rather relative coordinates of the inner side from the outer side.\n\nWhat’s the difference?\n\nIt becomes visible when the document is right-to-left (the operating system is in Arabic or Hebrew languages). The scrollbar is then not on the right, but on the left, and then clientLeft also includes the scrollbar width.\n\nIn that case, clientLeft would be not 25, but with the scrollbar width 25 + 16 = 41.\n\nHere’s the example in hebrew:\n\nclientWidth/Height\n\nThese properties provide the size of the area inside the element borders.\n\nThey include the content width together with paddings, but without the scrollbar:\n\nOn the picture above let’s first consider clientHeight.\n\nThere’s no horizontal scrollbar, so it’s exactly the sum of what’s inside the borders: CSS-height 200px plus top and bottom paddings (2 * 20px) total 240px.\n\nNow clientWidth – here the content width is not 300px, but 284px, because 16px are occupied by the scrollbar. So the sum is 284px plus left and right paddings, total 324px.\n\nIf there are no paddings, then clientWidth/Height is exactly the content area, inside the borders and the scrollbar (if any).\n\nSo when there’s no padding we can use clientWidth/clientHeight to get the content area size.\n\nscrollWidth/Height\n\nThese properties are like clientWidth/clientHeight, but they also include the scrolled out (hidden) parts:\n\nOn the picture above:\n\nscrollHeight = 723 – is the full inner height of the content area including the scrolled out parts.\nscrollWidth = 324 – is the full inner width, here we have no horizontal scroll, so it equals clientWidth.\n\nWe can use these properties to expand the element wide to its full width/height.\n\nLike this:\n\n// expand the element to the full content height\nelement.style.height = `${element.scrollHeight}px`;\n\nClick the button to expand the element:\n\ntext text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text\n\nelement.style.height = ${element.scrollHeight}px\n\nscrollLeft/scrollTop\n\nProperties scrollLeft/scrollTop are the width/height of the hidden, scrolled out part of the element.\n\nOn the picture below we can see scrollHeight and scrollTop for a block with a vertical scroll.\n\nIn other words, scrollTop is “how much is scrolled up”.\n\nscrollLeft/scrollTop can be modified\n\nMost of the geometry properties here are read-only, but scrollLeft/scrollTop can be changed, and the browser will scroll the element.\n\nIf you click the element below, the code elem.scrollTop += 10 executes. That makes the element content scroll 10px down.\n\nClick\nMe\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\nSetting scrollTop to 0 or a big value, such as 1e9 will make the element scroll to the very top/bottom respectively.\n\nDon’t take width/height from CSS\n\nWe’ve just covered geometry properties of DOM elements, that can be used to get widths, heights and calculate distances.\n\nBut as we know from the chapter Styles and classes, we can read CSS-height and width using getComputedStyle.\n\nSo why not to read the width of an element with getComputedStyle, like this?\n\n\t\nlet elem = document.body;\n\nalert( getComputedStyle(elem).width ); // show CSS width for elem\n\nWhy should we use geometry properties instead? There are two reasons:\n\nFirst, CSS width/height depend on another property: box-sizing that defines “what is” CSS width and height. A change in box-sizing for CSS purposes may break such JavaScript.\n\nSecond, CSS width/height may be auto, for instance for an inline element:\n\n\t\n<span id=\"elem\">Hello!</span>\n\n<script>\n  alert( getComputedStyle(elem).width ); // auto\n</script>\n\nFrom the CSS standpoint, width:auto is perfectly normal, but in JavaScript we need an exact size in px that we can use in calculations. So here CSS width is useless.\n\nAnd there’s one more reason: a scrollbar. Sometimes the code that works fine without a scrollbar becomes buggy with it, because a scrollbar takes the space from the content in some browsers. So the real width available for the content is less than CSS width. And clientWidth/clientHeight take that into account.\n\n…But with getComputedStyle(elem).width the situation is different. Some browsers (e.g. Chrome) return the real inner width, minus the scrollbar, and some of them (e.g. Firefox) – CSS width (ignore the scrollbar). Such cross-browser differences is the reason not to use getComputedStyle, but rather rely on geometry properties.\n\nIf your browser reserves the space for a scrollbar (most browsers for Windows do), then you can test it below.\n\nThe element with text has CSS width:300px.\n\nOn a Desktop Windows OS, Firefox, Chrome, Edge all reserve the space for the scrollbar. But Firefox shows 300px, while Chrome and Edge show less. That’s because Firefox returns the CSS width and other browsers return the “real” width.\n\nPlease note that the described difference is only about reading getComputedStyle(...).width from JavaScript, visually everything is correct.\n\nSummary\n\nElements have the following geometry properties:\n\noffsetParent – is the nearest positioned ancestor or td, th, table, body.\noffsetLeft/offsetTop – coordinates relative to the upper-left edge of offsetParent.\noffsetWidth/offsetHeight – “outer” width/height of an element including borders.\nclientLeft/clientTop – the distances from the upper-left outer corner to the upper-left inner (content + padding) corner. For left-to-right OS they are always the widths of left/top borders. For right-to-left OS the vertical scrollbar is on the left so clientLeft includes its width too.\nclientWidth/clientHeight – the width/height of the content including paddings, but without the scrollbar.\nscrollWidth/scrollHeight – the width/height of the content, just like clientWidth/clientHeight, but also include scrolled-out, invisible part of the element.\nscrollLeft/scrollTop – width/height of the scrolled out upper part of the element, starting from its upper-left corner.\n\nAll properties are read-only except scrollLeft/scrollTop that make the browser scroll the element if changed.\n\nTasks\nWhat's the scroll from the bottom?\nimportance: 5\n\nThe elem.scrollTop property is the size of the scrolled out part from the top. How to get the size of the bottom scroll (let’s call it scrollBottom)?\n\nWrite the code that works for an arbitrary elem.\n\nP.S. Please check your code: if there’s no scroll or the element is fully scrolled down, then it should return 0.\n\nsolution\nWhat is the scrollbar width?\nimportance: 3\n\nWrite the code that returns the width of a standard scrollbar.\n\nFor Windows it usually varies between 12px and 20px. If the browser doesn’t reserve any space for it (the scrollbar is half-translucent over the text, also happens), then it may be 0px.\n\nP.S. The code should work for any HTML document, do not depend on its content.\n\nsolution\nPlace the ball in the field center\nimportance: 5\n\nHere’s how the source document looks:\n\n\t\n\nWhat are coordinates of the field center?\n\nCalculate them and use to place the ball into the center of the green field:\n\nThe element should be moved by JavaScript, not CSS.\nThe code should work with any ball size (10, 20, 30 pixels) and any field size, not be bound to the given values.\n\nP.S. Sure, centering could be done with CSS, but here we want exactly JavaScript. Further we’ll meet other topics and more complex situations when JavaScript must be used. Here we do a “warm-up”.\n\nOpen a sandbox for the task.\n\nsolution\nThe difference: CSS width versus clientWidth\nimportance: 5\n\nWhat’s the difference between getComputedStyle(elem).width and elem.clientWidth?\n\nGive at least 3 differences. The more the better.\n\nsolution"
  },
  {
    "title": "Window sizes and scrolling",
    "url": "https://javascript.info/size-and-scroll-window",
    "html": "How do we find the width and height of the browser window? How do we get the full width and height of the document, including the scrolled out part? How do we scroll the page using JavaScript?\n\nFor this type of information, we can use the root document element document.documentElement, that corresponds to the <html> tag. But there are additional methods and peculiarities to consider.\n\nWidth/height of the window\n\nTo get window width and height, we can use the clientWidth/clientHeight of document.documentElement:\n\nFor instance, this button shows the height of your window:\n\nalert(document.documentElement.clientHeight)\n\nNot window.innerWidth/innerHeight\n\nBrowsers also support properties like window.innerWidth/innerHeight. They look like what we want, so why not to use them instead?\n\nIf there exists a scrollbar, and it occupies some space, clientWidth/clientHeight provide the width/height without it (subtract it). In other words, they return the width/height of the visible part of the document, available for the content.\n\nwindow.innerWidth/innerHeight includes the scrollbar.\n\nIf there’s a scrollbar, and it occupies some space, then these two lines show different values:\n\n\t\nalert( window.innerWidth ); // full window width\nalert( document.documentElement.clientWidth ); // window width minus the scrollbar\n\nIn most cases, we need the available window width in order to draw or position something within scrollbars (if there are any), so we should use documentElement.clientHeight/clientWidth.\n\nDOCTYPE is important\n\nPlease note: top-level geometry properties may work a little bit differently when there’s no <!DOCTYPE HTML> in HTML. Odd things are possible.\n\nIn modern HTML we should always write DOCTYPE.\n\nWidth/height of the document\n\nTheoretically, as the root document element is document.documentElement, and it encloses all the content, we could measure the document’s full size as document.documentElement.scrollWidth/scrollHeight.\n\nBut on that element, for the whole page, these properties do not work as intended. In Chrome/Safari/Opera, if there’s no scroll, then documentElement.scrollHeight may be even less than documentElement.clientHeight! Weird, right?\n\nTo reliably obtain the full document height, we should take the maximum of these properties:\n\n\t\nlet scrollHeight = Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n);\n\nalert('Full document height, with scrolled out part: ' + scrollHeight);\n\nWhy so? Better don’t ask. These inconsistencies come from ancient times, not a “smart” logic.\n\nGet the current scroll\n\nDOM elements have their current scroll state in their scrollLeft/scrollTop properties.\n\nFor document scroll, document.documentElement.scrollLeft/scrollTop works in most browsers, except older WebKit-based ones, like Safari (bug 5991), where we should use document.body instead of document.documentElement.\n\nLuckily, we don’t have to remember these peculiarities at all, because the scroll is available in the special properties, window.pageXOffset/pageYOffset:\n\n\t\nalert('Current scroll from the top: ' + window.pageYOffset);\nalert('Current scroll from the left: ' + window.pageXOffset);\n\nThese properties are read-only.\n\nAlso available as window properties scrollX and scrollY\n\nFor historical reasons, both properties exist, but they are the same:\n\nwindow.pageXOffset is an alias of window.scrollX.\nwindow.pageYOffset is an alias of window.scrollY.\nScrolling: scrollTo, scrollBy, scrollIntoView\nImportant:\n\nTo scroll the page with JavaScript, its DOM must be fully built.\n\nFor instance, if we try to scroll the page with a script in <head>, it won’t work.\n\nRegular elements can be scrolled by changing scrollTop/scrollLeft.\n\nWe can do the same for the page using document.documentElement.scrollTop/scrollLeft (except Safari, where document.body.scrollTop/Left should be used instead).\n\nAlternatively, there’s a simpler, universal solution: special methods window.scrollBy(x,y) and window.scrollTo(pageX,pageY).\n\nThe method scrollBy(x,y) scrolls the page relative to its current position. For instance, scrollBy(0,10) scrolls the page 10px down.\n\nThe button below demonstrates this:\n\nwindow.scrollBy(0,10)\n\nThe method scrollTo(pageX,pageY) scrolls the page to absolute coordinates, so that the top-left corner of the visible part has coordinates (pageX, pageY) relative to the document’s top-left corner. It’s like setting scrollLeft/scrollTop.\n\nTo scroll to the very beginning, we can use scrollTo(0,0).\n\nwindow.scrollTo(0,0)\n\nThese methods work for all browsers the same way.\n\nscrollIntoView\n\nFor completeness, let’s cover one more method: elem.scrollIntoView(top).\n\nThe call to elem.scrollIntoView(top) scrolls the page to make elem visible. It has one argument:\n\nIf top=true (that’s the default), then the page will be scrolled to make elem appear on the top of the window. The upper edge of the element will be aligned with the window top.\nIf top=false, then the page scrolls to make elem appear at the bottom. The bottom edge of the element will be aligned with the window bottom.\n\nThe button below scrolls the page to position itself at the window top:\n\nthis.scrollIntoView()\n\nAnd this button scrolls the page to position itself at the bottom:\n\nthis.scrollIntoView(false)\n\nForbid the scrolling\n\nSometimes we need to make the document “unscrollable”. For instance, when we need to cover the page with a large message requiring immediate attention, and we want the visitor to interact with that message, not with the document.\n\nTo make the document unscrollable, it’s enough to set document.body.style.overflow = \"hidden\". The page will “freeze” at its current scroll position.\n\nTry it:\n\ndocument.body.style.overflow = ‘hidden’\n\ndocument.body.style.overflow = ‘’\n\nThe first button freezes the scroll, while the second one releases it.\n\nWe can use the same technique to freeze the scroll for other elements, not just for document.body.\n\nThe drawback of the method is that the scrollbar disappears. If it occupied some space, then that space is now free and the content “jumps” to fill it.\n\nThat looks a bit odd, but can be worked around if we compare clientWidth before and after the freeze. If it increased (the scrollbar disappeared), then add padding to document.body in place of the scrollbar to keep the content width the same.\n\nSummary\n\nGeometry:\n\nWidth/height of the visible part of the document (content area width/height): document.documentElement.clientWidth/clientHeight\n\nWidth/height of the whole document, with the scrolled out part:\n\nlet scrollHeight = Math.max(\n  document.body.scrollHeight, document.documentElement.scrollHeight,\n  document.body.offsetHeight, document.documentElement.offsetHeight,\n  document.body.clientHeight, document.documentElement.clientHeight\n);\n\nScrolling:\n\nRead the current scroll: window.pageYOffset/pageXOffset.\n\nChange the current scroll:\n\nwindow.scrollTo(pageX,pageY) – absolute coordinates,\nwindow.scrollBy(x,y) – scroll relative the current place,\nelem.scrollIntoView(top) – scroll to make elem visible (align with the top/bottom of the window)."
  },
  {
    "title": "Searching: getElement*, querySelector*",
    "url": "https://javascript.info/searching-elements-dom",
    "html": "DOM navigation properties are great when elements are close to each other. What if they are not? How to get an arbitrary element of the page?\n\nThere are additional searching methods for that.\n\ndocument.getElementById or just id\n\nIf an element has the id attribute, we can get the element using the method document.getElementById(id), no matter where it is.\n\nFor instance:\n\n\t\n<div id=\"elem\">\n  <div id=\"elem-content\">Element</div>\n</div>\n\n<script>\n  // get the element\n  let elem = document.getElementById('elem');\n\n  // make its background red\n  elem.style.background = 'red';\n</script>\n\nAlso, there’s a global variable named by id that references the element:\n\n\t\n<div id=\"elem\">\n  <div id=\"elem-content\">Element</div>\n</div>\n\n<script>\n  // elem is a reference to DOM-element with id=\"elem\"\n  elem.style.background = 'red';\n\n  // id=\"elem-content\" has a hyphen inside, so it can't be a variable name\n  // ...but we can access it using square brackets: window['elem-content']\n</script>\n\n…That’s unless we declare a JavaScript variable with the same name, then it takes precedence:\n\n\t\n<div id=\"elem\"></div>\n\n<script>\n  let elem = 5; // now elem is 5, not a reference to <div id=\"elem\">\n\n  alert(elem); // 5\n</script>\nPlease don’t use id-named global variables to access elements\n\nThis behavior is described in the specification, but it is supported mainly for compatibility.\n\nThe browser tries to help us by mixing namespaces of JS and DOM. That’s fine for simple scripts, inlined into HTML, but generally isn’t a good thing. There may be naming conflicts. Also, when one reads JS code and doesn’t have HTML in view, it’s not obvious where the variable comes from.\n\nHere in the tutorial we use id to directly reference an element for brevity, when it’s obvious where the element comes from.\n\nIn real life document.getElementById is the preferred method.\n\nThe id must be unique\n\nThe id must be unique. There can be only one element in the document with the given id.\n\nIf there are multiple elements with the same id, then the behavior of methods that use it is unpredictable, e.g. document.getElementById may return any of such elements at random. So please stick to the rule and keep id unique.\n\nOnly document.getElementById, not anyElem.getElementById\n\nThe method getElementById can be called only on document object. It looks for the given id in the whole document.\n\nquerySelectorAll\n\nBy far, the most versatile method, elem.querySelectorAll(css) returns all elements inside elem matching the given CSS selector.\n\nHere we look for all <li> elements that are last children:\n\n\t\n<ul>\n  <li>The</li>\n  <li>test</li>\n</ul>\n<ul>\n  <li>has</li>\n  <li>passed</li>\n</ul>\n<script>\n  let elements = document.querySelectorAll('ul > li:last-child');\n\n  for (let elem of elements) {\n    alert(elem.innerHTML); // \"test\", \"passed\"\n  }\n</script>\n\nThis method is indeed powerful, because any CSS selector can be used.\n\nCan use pseudo-classes as well\n\nPseudo-classes in the CSS selector like :hover and :active are also supported. For instance, document.querySelectorAll(':hover') will return the collection with elements that the pointer is over now (in nesting order: from the outermost <html> to the most nested one).\n\nquerySelector\n\nThe call to elem.querySelector(css) returns the first element for the given CSS selector.\n\nIn other words, the result is the same as elem.querySelectorAll(css)[0], but the latter is looking for all elements and picking one, while elem.querySelector just looks for one. So it’s faster and also shorter to write.\n\nmatches\n\nPrevious methods were searching the DOM.\n\nThe elem.matches(css) does not look for anything, it merely checks if elem matches the given CSS-selector. It returns true or false.\n\nThe method comes in handy when we are iterating over elements (like in an array or something) and trying to filter out those that interest us.\n\nFor instance:\n\n\t\n<a href=\"http://example.com/file.zip\">...</a>\n<a href=\"http://ya.ru\">...</a>\n\n<script>\n  // can be any collection instead of document.body.children\n  for (let elem of document.body.children) {\n    if (elem.matches('a[href$=\"zip\"]')) {\n      alert(\"The archive reference: \" + elem.href );\n    }\n  }\n</script>\nclosest\n\nAncestors of an element are: parent, the parent of parent, its parent and so on. The ancestors together form the chain of parents from the element to the top.\n\nThe method elem.closest(css) looks for the nearest ancestor that matches the CSS-selector. The elem itself is also included in the search.\n\nIn other words, the method closest goes up from the element and checks each of parents. If it matches the selector, then the search stops, and the ancestor is returned.\n\nFor instance:\n\n\t\n<h1>Contents</h1>\n\n<div class=\"contents\">\n  <ul class=\"book\">\n    <li class=\"chapter\">Chapter 1</li>\n    <li class=\"chapter\">Chapter 2</li>\n  </ul>\n</div>\n\n<script>\n  let chapter = document.querySelector('.chapter'); // LI\n\n  alert(chapter.closest('.book')); // UL\n  alert(chapter.closest('.contents')); // DIV\n\n  alert(chapter.closest('h1')); // null (because h1 is not an ancestor)\n</script>\ngetElementsBy*\n\nThere are also other methods to look for nodes by a tag, class, etc.\n\nToday, they are mostly history, as querySelector is more powerful and shorter to write.\n\nSo here we cover them mainly for completeness, while you can still find them in the old scripts.\n\nelem.getElementsByTagName(tag) looks for elements with the given tag and returns the collection of them. The tag parameter can also be a star \"*\" for “any tags”.\nelem.getElementsByClassName(className) returns elements that have the given CSS class.\ndocument.getElementsByName(name) returns elements with the given name attribute, document-wide. Very rarely used.\n\nFor instance:\n\n// get all divs in the document\nlet divs = document.getElementsByTagName('div');\n\nLet’s find all input tags inside the table:\n\n\t\n<table id=\"table\">\n  <tr>\n    <td>Your age:</td>\n\n    <td>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"young\" checked> less than 18\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"mature\"> from 18 to 50\n      </label>\n      <label>\n        <input type=\"radio\" name=\"age\" value=\"senior\"> more than 60\n      </label>\n    </td>\n  </tr>\n</table>\n\n<script>\n  let inputs = table.getElementsByTagName('input');\n\n  for (let input of inputs) {\n    alert( input.value + ': ' + input.checked );\n  }\n</script>\nDon’t forget the \"s\" letter!\n\nNovice developers sometimes forget the letter \"s\". That is, they try to call getElementByTagName instead of getElementsByTagName.\n\nThe \"s\" letter is absent in getElementById, because it returns a single element. But getElementsByTagName returns a collection of elements, so there’s \"s\" inside.\n\nIt returns a collection, not an element!\n\nAnother widespread novice mistake is to write:\n\n// doesn't work\ndocument.getElementsByTagName('input').value = 5;\n\nThat won’t work, because it takes a collection of inputs and assigns the value to it rather than to elements inside it.\n\nWe should either iterate over the collection or get an element by its index, and then assign, like this:\n\n// should work (if there's an input)\ndocument.getElementsByTagName('input')[0].value = 5;\n\nLooking for .article elements:\n\n\t\n<form name=\"my-form\">\n  <div class=\"article\">Article</div>\n  <div class=\"long article\">Long article</div>\n</form>\n\n<script>\n  // find by name attribute\n  let form = document.getElementsByName('my-form')[0];\n\n  // find by class inside the form\n  let articles = form.getElementsByClassName('article');\n  alert(articles.length); // 2, found two elements with class \"article\"\n</script>\nLive collections\n\nAll methods \"getElementsBy*\" return a live collection. Such collections always reflect the current state of the document and “auto-update” when it changes.\n\nIn the example below, there are two scripts.\n\nThe first one creates a reference to the collection of <div>. As of now, its length is 1.\nThe second scripts runs after the browser meets one more <div>, so its length is 2.\n\t\n<div>First div</div>\n\n<script>\n  let divs = document.getElementsByTagName('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n  alert(divs.length); // 2\n</script>\n\nIn contrast, querySelectorAll returns a static collection. It’s like a fixed array of elements.\n\nIf we use it instead, then both scripts output 1:\n\n\t\n<div>First div</div>\n\n<script>\n  let divs = document.querySelectorAll('div');\n  alert(divs.length); // 1\n</script>\n\n<div>Second div</div>\n\n<script>\n  alert(divs.length); // 1\n</script>\n\nNow we can easily see the difference. The static collection did not increase after the appearance of a new div in the document.\n\nSummary\n\nThere are 6 main methods to search for nodes in DOM:\n\nMethod\tSearches by...\tCan call on an element?\tLive?\nquerySelector\tCSS-selector\t✔\t-\nquerySelectorAll\tCSS-selector\t✔\t-\ngetElementById\tid\t-\t-\ngetElementsByName\tname\t-\t✔\ngetElementsByTagName\ttag or '*'\t✔\t✔\ngetElementsByClassName\tclass\t✔\t✔\n\nBy far the most used are querySelector and querySelectorAll, but getElement(s)By* can be sporadically helpful or found in the old scripts.\n\nBesides that:\n\nThere is elem.matches(css) to check if elem matches the given CSS selector.\nThere is elem.closest(css) to look for the nearest ancestor that matches the given CSS-selector. The elem itself is also checked.\n\nAnd let’s mention one more method here to check for the child-parent relationship, as it’s sometimes useful:\n\nelemA.contains(elemB) returns true if elemB is inside elemA (a descendant of elemA) or when elemA==elemB.\nTasks\nSearch for elements\nimportance: 4\n\nHere’s the document with the table and form.\n\nHow to find?…\n\nThe table with id=\"age-table\".\nAll label elements inside that table (there should be 3 of them).\nThe first td in that table (with the word “Age”).\nThe form with name=\"search\".\nThe first input in that form.\nThe last input in that form.\n\nOpen the page table.html in a separate window and make use of browser tools for that.\n\nsolution"
  },
  {
    "title": "Styles and classes",
    "url": "https://javascript.info/styles-and-classes",
    "html": "Before we get into JavaScript’s ways of dealing with styles and classes – here’s an important rule. Hopefully it’s obvious enough, but we still have to mention it.\n\nThere are generally two ways to style an element:\n\nCreate a class in CSS and add it: <div class=\"...\">\nWrite properties directly into style: <div style=\"...\">.\n\nJavaScript can modify both classes and style properties.\n\nWe should always prefer CSS classes to style. The latter should only be used if classes “can’t handle it”.\n\nFor example, style is acceptable if we calculate coordinates of an element dynamically and want to set them from JavaScript, like this:\n\nlet top = /* complex calculations */;\nlet left = /* complex calculations */;\n\nelem.style.left = left; // e.g '123px', calculated at run-time\nelem.style.top = top; // e.g '456px'\n\nFor other cases, like making the text red, adding a background icon – describe that in CSS and then add the class (JavaScript can do that). That’s more flexible and easier to support.\n\nclassName and classList\n\nChanging a class is one of the most often used actions in scripts.\n\nIn the ancient time, there was a limitation in JavaScript: a reserved word like \"class\" could not be an object property. That limitation does not exist now, but at that time it was impossible to have a \"class\" property, like elem.class.\n\nSo for classes the similar-looking property \"className\" was introduced: the elem.className corresponds to the \"class\" attribute.\n\nFor instance:\n\n\t\n<body class=\"main page\">\n  <script>\n    alert(document.body.className); // main page\n  </script>\n</body>\n\nIf we assign something to elem.className, it replaces the whole string of classes. Sometimes that’s what we need, but often we want to add/remove a single class.\n\nThere’s another property for that: elem.classList.\n\nThe elem.classList is a special object with methods to add/remove/toggle a single class.\n\nFor instance:\n\n\t\n<body class=\"main page\">\n  <script>\n    // add a class\n    document.body.classList.add('article');\n\n    alert(document.body.className); // main page article\n  </script>\n</body>\n\nSo we can operate both on the full class string using className or on individual classes using classList. What we choose depends on our needs.\n\nMethods of classList:\n\nelem.classList.add/remove(\"class\") – adds/removes the class.\nelem.classList.toggle(\"class\") – adds the class if it doesn’t exist, otherwise removes it.\nelem.classList.contains(\"class\") – checks for the given class, returns true/false.\n\nBesides, classList is iterable, so we can list all classes with for..of, like this:\n\n\t\n<body class=\"main page\">\n  <script>\n    for (let name of document.body.classList) {\n      alert(name); // main, and then page\n    }\n  </script>\n</body>\nElement style\n\nThe property elem.style is an object that corresponds to what’s written in the \"style\" attribute. Setting elem.style.width=\"100px\" works the same as if we had in the attribute style a string width:100px.\n\nFor multi-word property the camelCase is used:\n\nbackground-color  => elem.style.backgroundColor\nz-index           => elem.style.zIndex\nborder-left-width => elem.style.borderLeftWidth\n\nFor instance:\n\n\t\ndocument.body.style.backgroundColor = prompt('background color?', 'green');\nPrefixed properties\n\nBrowser-prefixed properties like -moz-border-radius, -webkit-border-radius also follow the same rule: a dash means upper case.\n\nFor instance:\n\nbutton.style.MozBorderRadius = '5px';\nbutton.style.WebkitBorderRadius = '5px';\nResetting the style property\n\nSometimes we want to assign a style property, and later remove it.\n\nFor instance, to hide an element, we can set elem.style.display = \"none\".\n\nThen later we may want to remove the style.display as if it were not set. Instead of delete elem.style.display we should assign an empty string to it: elem.style.display = \"\".\n\n\t\n// if we run this code, the <body> will blink\ndocument.body.style.display = \"none\"; // hide\n\nsetTimeout(() => document.body.style.display = \"\", 1000); // back to normal\n\nIf we set style.display to an empty string, then the browser applies CSS classes and its built-in styles normally, as if there were no such style.display property at all.\n\nAlso there is a special method for that, elem.style.removeProperty('style property'). So, We can remove a property like this:\n\n\t\ndocument.body.style.background = 'red'; //set background to red\n\nsetTimeout(() => document.body.style.removeProperty('background'), 1000); // remove background after 1 second\nFull rewrite with style.cssText\n\nNormally, we use style.* to assign individual style properties. We can’t set the full style like div.style=\"color: red; width: 100px\", because div.style is an object, and it’s read-only.\n\nTo set the full style as a string, there’s a special property style.cssText:\n\n\t\n<div id=\"div\">Button</div>\n\n<script>\n  // we can set special style flags like \"important\" here\n  div.style.cssText=`color: red !important;\n    background-color: yellow;\n    width: 100px;\n    text-align: center;\n  `;\n\n  alert(div.style.cssText);\n</script>\n\nThis property is rarely used, because such assignment removes all existing styles: it does not add, but replaces them. May occasionally delete something needed. But we can safely use it for new elements, when we know we won’t delete an existing style.\n\nThe same can be accomplished by setting an attribute: div.setAttribute('style', 'color: red...').\n\nMind the units\n\nDon’t forget to add CSS units to values.\n\nFor instance, we should not set elem.style.top to 10, but rather to 10px. Otherwise it wouldn’t work:\n\n\t\n<body>\n  <script>\n    // doesn't work!\n    document.body.style.margin = 20;\n    alert(document.body.style.margin); // '' (empty string, the assignment is ignored)\n\n    // now add the CSS unit (px) - and it works\n    document.body.style.margin = '20px';\n    alert(document.body.style.margin); // 20px\n\n    alert(document.body.style.marginTop); // 20px\n    alert(document.body.style.marginLeft); // 20px\n  </script>\n</body>\n\nPlease note: the browser “unpacks” the property style.margin in the last lines and infers style.marginLeft and style.marginTop from it.\n\nComputed styles: getComputedStyle\n\nSo, modifying a style is easy. But how to read it?\n\nFor instance, we want to know the size, margins, the color of an element. How to do it?\n\nThe style property operates only on the value of the \"style\" attribute, without any CSS cascade.\n\nSo we can’t read anything that comes from CSS classes using elem.style.\n\nFor instance, here style doesn’t see the margin:\n\n\t\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  The red text\n  <script>\n    alert(document.body.style.color); // empty\n    alert(document.body.style.marginTop); // empty\n  </script>\n</body>\n\n…But what if we need, say, to increase the margin by 20px? We would want the current value of it.\n\nThere’s another method for that: getComputedStyle.\n\nThe syntax is:\n\ngetComputedStyle(element, [pseudo])\nelement\nElement to read the value for.\npseudo\nA pseudo-element if required, for instance ::before. An empty string or no argument means the element itself.\n\nThe result is an object with styles, like elem.style, but now with respect to all CSS classes.\n\nFor instance:\n\n\t\n<head>\n  <style> body { color: red; margin: 5px } </style>\n</head>\n<body>\n\n  <script>\n    let computedStyle = getComputedStyle(document.body);\n\n    // now we can read the margin and the color from it\n\n    alert( computedStyle.marginTop ); // 5px\n    alert( computedStyle.color ); // rgb(255, 0, 0)\n  </script>\n\n</body>\nComputed and resolved values\n\nThere are two concepts in CSS:\n\nA computed style value is the value after all CSS rules and CSS inheritance is applied, as the result of the CSS cascade. It can look like height:1em or font-size:125%.\nA resolved style value is the one finally applied to the element. Values like 1em or 125% are relative. The browser takes the computed value and makes all units fixed and absolute, for instance: height:20px or font-size:16px. For geometry properties resolved values may have a floating point, like width:50.5px.\n\nA long time ago getComputedStyle was created to get computed values, but it turned out that resolved values are much more convenient, and the standard changed.\n\nSo nowadays getComputedStyle actually returns the resolved value of the property, usually in px for geometry.\n\ngetComputedStyle requires the full property name\n\nWe should always ask for the exact property that we want, like paddingLeft or marginTop or borderTopWidth. Otherwise the correct result is not guaranteed.\n\nFor instance, if there are properties paddingLeft/paddingTop, then what should we get for getComputedStyle(elem).padding? Nothing, or maybe a “generated” value from known paddings? There’s no standard rule here.\n\nStyles applied to :visited links are hidden!\n\nVisited links may be colored using :visited CSS pseudoclass.\n\nBut getComputedStyle does not give access to that color, because otherwise an arbitrary page could find out whether the user visited a link by creating it on the page and checking the styles.\n\nJavaScript may not see the styles applied by :visited. And also, there’s a limitation in CSS that forbids applying geometry-changing styles in :visited. That’s to guarantee that there’s no side way for an evil page to test if a link was visited and hence to break the privacy.\n\nSummary\n\nTo manage classes, there are two DOM properties:\n\nclassName – the string value, good to manage the whole set of classes.\nclassList – the object with methods add/remove/toggle/contains, good for individual classes.\n\nTo change the styles:\n\nThe style property is an object with camelCased styles. Reading and writing to it has the same meaning as modifying individual properties in the \"style\" attribute. To see how to apply important and other rare stuff – there’s a list of methods at MDN.\n\nThe style.cssText property corresponds to the whole \"style\" attribute, the full string of styles.\n\nTo read the resolved styles (with respect to all classes, after all CSS is applied and final values are calculated):\n\nThe getComputedStyle(elem, [pseudo]) returns the style-like object with them. Read-only.\nTasks\nCreate a notification\nimportance: 5\n\nWrite a function showNotification(options) that creates a notification: <div class=\"notification\"> with the given content. The notification should automatically disappear after 1.5 seconds.\n\nThe options are:\n\n// shows an element with the text \"Hello\" near the right-top of the window\nshowNotification({\n  top: 10, // 10px from the top of the window (by default 0px)\n  right: 10, // 10px from the right edge of the window (by default 0px)\n  html: \"Hello!\", // the HTML of notification\n  className: \"welcome\" // an additional class for the div (optional)\n});\n\nDemo in new window\n\nUse CSS positioning to show the element at given top/right coordinates. The source document has the necessary styles.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Modifying the document",
    "url": "https://javascript.info/modifying-document",
    "html": "DOM modification is the key to creating “live” pages.\n\nHere we’ll see how to create new elements “on the fly” and modify the existing page content.\n\nExample: show a message\n\nLet’s demonstrate using an example. We’ll add a message on the page that looks nicer than alert.\n\nHere’s how it will look:\n\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<div class=\"alert\">\n  <strong>Hi there!</strong> You've read an important message.\n</div>\n\nThat was the HTML example. Now let’s create the same div with JavaScript (assuming that the styles are in the HTML/CSS already).\n\nCreating an element\n\nTo create DOM nodes, there are two methods:\n\ndocument.createElement(tag)\n\nCreates a new element node with the given tag:\n\nlet div = document.createElement('div');\ndocument.createTextNode(text)\n\nCreates a new text node with the given text:\n\nlet textNode = document.createTextNode('Here I am');\n\nMost of the time we need to create element nodes, such as the div for the message.\n\nCreating the message\n\nCreating the message div takes 3 steps:\n\n// 1. Create <div> element\nlet div = document.createElement('div');\n\n// 2. Set its class to \"alert\"\ndiv.className = \"alert\";\n\n// 3. Fill it with the content\ndiv.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n\nWe’ve created the element. But as of now it’s only in a variable named div, not in the page yet. So we can’t see it.\n\nInsertion methods\n\nTo make the div show up, we need to insert it somewhere into document. For instance, into <body> element, referenced by document.body.\n\nThere’s a special method append for that: document.body.append(div).\n\nHere’s the full code:\n\n\t\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert\";\n  div.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n\n  document.body.append(div);\n</script>\n\nHere we called append on document.body, but we can call append method on any other element, to put another element into it. For instance, we can append something to <div> by calling div.append(anotherElement).\n\nHere are more insertion methods, they specify different places where to insert:\n\nnode.append(...nodes or strings) – append nodes or strings at the end of node,\nnode.prepend(...nodes or strings) – insert nodes or strings at the beginning of node,\nnode.before(...nodes or strings) –- insert nodes or strings before node,\nnode.after(...nodes or strings) –- insert nodes or strings after node,\nnode.replaceWith(...nodes or strings) –- replaces node with the given nodes or strings.\n\nArguments of these methods are an arbitrary list of DOM nodes to insert, or text strings (that become text nodes automatically).\n\nLet’s see them in action.\n\nHere’s an example of using these methods to add items to a list and the text before/after it:\n\n<ol id=\"ol\">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  ol.before('before'); // insert string \"before\" before <ol>\n  ol.after('after'); // insert string \"after\" after <ol>\n\n  let liFirst = document.createElement('li');\n  liFirst.innerHTML = 'prepend';\n  ol.prepend(liFirst); // insert liFirst at the beginning of <ol>\n\n  let liLast = document.createElement('li');\n  liLast.innerHTML = 'append';\n  ol.append(liLast); // insert liLast at the end of <ol>\n</script>\n\nHere’s a visual picture of what the methods do:\n\nSo the final list will be:\n\nbefore\n<ol id=\"ol\">\n  <li>prepend</li>\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n  <li>append</li>\n</ol>\nafter\n\nAs said, these methods can insert multiple nodes and text pieces in a single call.\n\nFor instance, here a string and an element are inserted:\n\n\t\n<div id=\"div\"></div>\n<script>\n  div.before('<p>Hello</p>', document.createElement('hr'));\n</script>\n\nPlease note: the text is inserted “as text”, not “as HTML”, with proper escaping of characters such as <, >.\n\nSo the final HTML is:\n\n\t\n&lt;p&gt;Hello&lt;/p&gt;\n<hr>\n<div id=\"div\"></div>\n\nIn other words, strings are inserted in a safe way, like elem.textContent does it.\n\nSo, these methods can only be used to insert DOM nodes or text pieces.\n\nBut what if we’d like to insert an HTML string “as html”, with all tags and stuff working, in the same manner as elem.innerHTML does it?\n\ninsertAdjacentHTML/Text/Element\n\nFor that we can use another, pretty versatile method: elem.insertAdjacentHTML(where, html).\n\nThe first parameter is a code word, specifying where to insert relative to elem. Must be one of the following:\n\n\"beforebegin\" – insert html immediately before elem,\n\"afterbegin\" – insert html into elem, at the beginning,\n\"beforeend\" – insert html into elem, at the end,\n\"afterend\" – insert html immediately after elem.\n\nThe second parameter is an HTML string, that is inserted “as HTML”.\n\nFor instance:\n\n\t\n<div id=\"div\"></div>\n<script>\n  div.insertAdjacentHTML('beforebegin', '<p>Hello</p>');\n  div.insertAdjacentHTML('afterend', '<p>Bye</p>');\n</script>\n\n…Would lead to:\n\n\t\n<p>Hello</p>\n<div id=\"div\"></div>\n<p>Bye</p>\n\nThat’s how we can append arbitrary HTML to the page.\n\nHere’s the picture of insertion variants:\n\nWe can easily notice similarities between this and the previous picture. The insertion points are actually the same, but this method inserts HTML.\n\nThe method has two brothers:\n\nelem.insertAdjacentText(where, text) – the same syntax, but a string of text is inserted “as text” instead of HTML,\nelem.insertAdjacentElement(where, elem) – the same syntax, but inserts an element.\n\nThey exist mainly to make the syntax “uniform”. In practice, only insertAdjacentHTML is used most of the time. Because for elements and text, we have methods append/prepend/before/after – they are shorter to write and can insert nodes/text pieces.\n\nSo here’s an alternative variant of showing a message:\n\n\t\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  document.body.insertAdjacentHTML(\"afterbegin\", `<div class=\"alert\">\n    <strong>Hi there!</strong> You've read an important message.\n  </div>`);\n</script>\nNode removal\n\nTo remove a node, there’s a method node.remove().\n\nLet’s make our message disappear after a second:\n\n\t\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<script>\n  let div = document.createElement('div');\n  div.className = \"alert\";\n  div.innerHTML = \"<strong>Hi there!</strong> You've read an important message.\";\n\n  document.body.append(div);\n  setTimeout(() => div.remove(), 1000);\n</script>\n\nPlease note: if we want to move an element to another place – there’s no need to remove it from the old one.\n\nAll insertion methods automatically remove the node from the old place.\n\nFor instance, let’s swap elements:\n\n\t\n<div id=\"first\">First</div>\n<div id=\"second\">Second</div>\n<script>\n  // no need to call remove\n  second.after(first); // take #second and after it insert #first\n</script>\nCloning nodes: cloneNode\n\nHow to insert one more similar message?\n\nWe could make a function and put the code there. But the alternative way would be to clone the existing div and modify the text inside it (if needed).\n\nSometimes when we have a big element, that may be faster and simpler.\n\nThe call elem.cloneNode(true) creates a “deep” clone of the element – with all attributes and subelements. If we call elem.cloneNode(false), then the clone is made without child elements.\n\nAn example of copying the message:\n\n\t\n<style>\n.alert {\n  padding: 15px;\n  border: 1px solid #d6e9c6;\n  border-radius: 4px;\n  color: #3c763d;\n  background-color: #dff0d8;\n}\n</style>\n\n<div class=\"alert\" id=\"div\">\n  <strong>Hi there!</strong> You've read an important message.\n</div>\n\n<script>\n  let div2 = div.cloneNode(true); // clone the message\n  div2.querySelector('strong').innerHTML = 'Bye there!'; // change the clone\n\n  div.after(div2); // show the clone after the existing div\n</script>\nDocumentFragment\n\nDocumentFragment is a special DOM node that serves as a wrapper to pass around lists of nodes.\n\nWe can append other nodes to it, but when we insert it somewhere, then its content is inserted instead.\n\nFor example, getListContent below generates a fragment with <li> items, that are later inserted into <ul>:\n\n\t\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let fragment = new DocumentFragment();\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    fragment.append(li);\n  }\n\n  return fragment;\n}\n\nul.append(getListContent()); // (*)\n</script>\n\nPlease note, at the last line (*) we append DocumentFragment, but it “blends in”, so the resulting structure will be:\n\n<ul>\n  <li>1</li>\n  <li>2</li>\n  <li>3</li>\n</ul>\n\nDocumentFragment is rarely used explicitly. Why append to a special kind of node, if we can return an array of nodes instead? Rewritten example:\n\n\t\n<ul id=\"ul\"></ul>\n\n<script>\nfunction getListContent() {\n  let result = [];\n\n  for(let i=1; i<=3; i++) {\n    let li = document.createElement('li');\n    li.append(i);\n    result.push(li);\n  }\n\n  return result;\n}\n\nul.append(...getListContent()); // append + \"...\" operator = friends!\n</script>\n\nWe mention DocumentFragment mainly because there are some concepts on top of it, like template element, that we’ll cover much later.\n\nOld-school insert/remove methods\nOld school\nThis information helps to understand old scripts, but not needed for new development.\n\nThere are also “old school” DOM manipulation methods, existing for historical reasons.\n\nThese methods come from really ancient times. Nowadays, there’s no reason to use them, as modern methods, such as append, prepend, before, after, remove, replaceWith, are more flexible.\n\nThe only reason we list these methods here is that you can find them in many old scripts:\n\nparentElem.appendChild(node)\n\nAppends node as the last child of parentElem.\n\nThe following example adds a new <li> to the end of <ol>:\n\n\t\n<ol id=\"list\">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  let newLi = document.createElement('li');\n  newLi.innerHTML = 'Hello, world!';\n\n  list.appendChild(newLi);\n</script>\nparentElem.insertBefore(node, nextSibling)\n\nInserts node before nextSibling into parentElem.\n\nThe following code inserts a new list item before the second <li>:\n\n\t\n<ol id=\"list\">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n<script>\n  let newLi = document.createElement('li');\n  newLi.innerHTML = 'Hello, world!';\n\n  list.insertBefore(newLi, list.children[1]);\n</script>\n\nTo insert newLi as the first element, we can do it like this:\n\nlist.insertBefore(newLi, list.firstChild);\nparentElem.replaceChild(node, oldChild)\n\nReplaces oldChild with node among children of parentElem.\n\nparentElem.removeChild(node)\n\nRemoves node from parentElem (assuming node is its child).\n\nThe following example removes first <li> from <ol>:\n\n\t\n<ol id=\"list\">\n  <li>0</li>\n  <li>1</li>\n  <li>2</li>\n</ol>\n\n<script>\n  let li = list.firstElementChild;\n  list.removeChild(li);\n</script>\n\nAll these methods return the inserted/removed node. In other words, parentElem.appendChild(node) returns node. But usually the returned value is not used, we just run the method.\n\nA word about “document.write”\n\nThere’s one more, very ancient method of adding something to a web-page: document.write.\n\nThe syntax:\n\n\t\n<p>Somewhere in the page...</p>\n<script>\n  document.write('<b>Hello from JS</b>');\n</script>\n<p>The end</p>\n\nThe call to document.write(html) writes the html into page “right here and now”. The html string can be dynamically generated, so it’s kind of flexible. We can use JavaScript to create a full-fledged webpage and write it.\n\nThe method comes from times when there was no DOM, no standards… Really old times. It still lives, because there are scripts using it.\n\nIn modern scripts we can rarely see it, because of the following important limitation:\n\nThe call to document.write only works while the page is loading.\n\nIf we call it afterwards, the existing document content is erased.\n\nFor instance:\n\n\t\n<p>After one second the contents of this page will be replaced...</p>\n<script>\n  // document.write after 1 second\n  // that's after the page loaded, so it erases the existing content\n  setTimeout(() => document.write('<b>...By this.</b>'), 1000);\n</script>\n\nSo it’s kind of unusable at “after loaded” stage, unlike other DOM methods we covered above.\n\nThat’s the downside.\n\nThere’s an upside also. Technically, when document.write is called while the browser is reading (“parsing”) incoming HTML, and it writes something, the browser consumes it just as if it were initially there, in the HTML text.\n\nSo it works blazingly fast, because there’s no DOM modification involved. It writes directly into the page text, while the DOM is not yet built.\n\nSo if we need to add a lot of text into HTML dynamically, and we’re at page loading phase, and the speed matters, it may help. But in practice these requirements rarely come together. And usually we can see this method in scripts just because they are old.\n\nSummary\n\nMethods to create new nodes:\n\ndocument.createElement(tag) – creates an element with the given tag,\ndocument.createTextNode(value) – creates a text node (rarely used),\nelem.cloneNode(deep) – clones the element, if deep==true then with all descendants.\n\nInsertion and removal:\n\nnode.append(...nodes or strings) – insert into node, at the end,\nnode.prepend(...nodes or strings) – insert into node, at the beginning,\nnode.before(...nodes or strings) –- insert right before node,\nnode.after(...nodes or strings) –- insert right after node,\nnode.replaceWith(...nodes or strings) –- replace node.\nnode.remove() –- remove the node.\n\nText strings are inserted “as text”.\n\nThere are also “old school” methods:\n\nparent.appendChild(node)\nparent.insertBefore(node, nextSibling)\nparent.removeChild(node)\nparent.replaceChild(newElem, node)\n\nAll these methods return node.\n\nGiven some HTML in html, elem.insertAdjacentHTML(where, html) inserts it depending on the value of where:\n\n\"beforebegin\" – insert html right before elem,\n\"afterbegin\" – insert html into elem, at the beginning,\n\"beforeend\" – insert html into elem, at the end,\n\"afterend\" – insert html right after elem.\n\nAlso there are similar methods, elem.insertAdjacentText and elem.insertAdjacentElement, that insert text strings and elements, but they are rarely used.\n\nTo append HTML to the page before it has finished loading:\n\ndocument.write(html)\n\nAfter the page is loaded such a call erases the document. Mostly seen in old scripts.\n\nTasks\ncreateTextNode vs innerHTML vs textContent\nimportance: 5\n\nWe have an empty DOM element elem and a string text.\n\nWhich of these 3 commands will do exactly the same?\n\nelem.append(document.createTextNode(text))\nelem.innerHTML = text\nelem.textContent = text\nsolution\nClear the element\nimportance: 5\n\nCreate a function clear(elem) that removes everything from the element.\n\n\t\n<ol id=\"elem\">\n  <li>Hello</li>\n  <li>World</li>\n</ol>\n\n<script>\n  function clear(elem) { /* your code */ }\n\n  clear(elem); // clears the list\n</script>\nsolution\nWhy does \"aaa\" remain?\nimportance: 1\n\nIn the example below, the call table.remove() removes the table from the document.\n\nBut if you run it, you can see that the text \"aaa\" is still visible.\n\nWhy does that happen?\n\n\t\n<table id=\"table\">\n  aaa\n  <tr>\n    <td>Test</td>\n  </tr>\n</table>\n\n<script>\n  alert(table); // the table, as it should be\n\n  table.remove();\n  // why there's still \"aaa\" in the document?\n</script>\nsolution\nCreate a list\nimportance: 4\n\nWrite an interface to create a list from user input.\n\nFor every list item:\n\nAsk a user about its content using prompt.\nCreate the <li> with it and add it to <ul>.\nContinue until the user cancels the input (by pressing Esc or via an empty entry).\n\nAll elements should be created dynamically.\n\nIf a user types HTML-tags, they should be treated like a text.\n\nDemo in new window\n\nsolution\nCreate a tree from the object\nimportance: 5\n\nWrite a function createTree that creates a nested ul/li list from the nested object.\n\nFor instance:\n\nlet data = {\n  \"Fish\": {\n    \"trout\": {},\n    \"salmon\": {}\n  },\n\n  \"Tree\": {\n    \"Huge\": {\n      \"sequoia\": {},\n      \"oak\": {}\n    },\n    \"Flowering\": {\n      \"apple tree\": {},\n      \"magnolia\": {}\n    }\n  }\n};\n\nThe syntax:\n\nlet container = document.getElementById('container');\ncreateTree(container, data); // creates the tree in the container\n\nThe result (tree) should look like this:\n\nChoose one of two ways of solving this task:\n\nCreate the HTML for the tree and then assign to container.innerHTML.\nCreate tree nodes and append with DOM methods.\n\nWould be great if you could do both.\n\nP.S. The tree should not have “extra” elements like empty <ul></ul> for the leaves.\n\nOpen a sandbox for the task.\n\nsolution\nShow descendants in a tree\nimportance: 5\n\nThere’s a tree organized as nested ul/li.\n\nWrite the code that adds to each <li> the number of its descendants. Skip leaves (nodes without children).\n\nThe result:\n\nOpen a sandbox for the task.\n\nsolution\nCreate a calendar\nimportance: 4\n\nWrite a function createCalendar(elem, year, month).\n\nThe call should create a calendar for the given year/month and put it inside elem.\n\nThe calendar should be a table, where a week is <tr>, and a day is <td>. The table top should be <th> with weekday names: the first day should be Monday, and so on till Sunday.\n\nFor instance, createCalendar(cal, 2012, 9) should generate in element cal the following calendar:\n\nP.S. For this task it’s enough to generate the calendar, should not yet be clickable.\n\nOpen a sandbox for the task.\n\nsolution\nColored clock with setInterval\nimportance: 4\n\nCreate a colored clock like here:\n\nUse HTML/CSS for the styling, JavaScript only updates time in elements.\n\nOpen a sandbox for the task.\n\nsolution\nInsert the HTML in the list\nimportance: 5\n\nWrite the code to insert <li>2</li><li>3</li> between two <li> here:\n\n<ul id=\"ul\">\n  <li id=\"one\">1</li>\n  <li id=\"two\">4</li>\n</ul>\nsolution\nSort the table\nimportance: 5\n\nThere’s a table:\n\n\t\n<table>\n<thead>\n  <tr>\n    <th>Name</th><th>Surname</th><th>Age</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>John</td><td>Smith</td><td>10</td>\n  </tr>\n  <tr>\n    <td>Pete</td><td>Brown</td><td>15</td>\n  </tr>\n  <tr>\n    <td>Ann</td><td>Lee</td><td>5</td>\n  </tr>\n  <tr>\n    <td>...</td><td>...</td><td>...</td>\n  </tr>\n</tbody>\n</table>\n\nThere may be more rows in it.\n\nWrite the code to sort it by the \"name\" column.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Attributes and properties",
    "url": "https://javascript.info/dom-attributes-and-properties",
    "html": "When the browser loads the page, it “reads” (another word: “parses”) the HTML and generates DOM objects from it. For element nodes, most standard HTML attributes automatically become properties of DOM objects.\n\nFor instance, if the tag is <body id=\"page\">, then the DOM object has body.id=\"page\".\n\nBut the attribute-property mapping is not one-to-one! In this chapter we’ll pay attention to separate these two notions, to see how to work with them, when they are the same, and when they are different.\n\nDOM properties\n\nWe’ve already seen built-in DOM properties. There are a lot. But technically no one limits us, and if there aren’t enough, we can add our own.\n\nDOM nodes are regular JavaScript objects. We can alter them.\n\nFor instance, let’s create a new property in document.body:\n\n\t\ndocument.body.myData = {\n  name: 'Caesar',\n  title: 'Imperator'\n};\n\nalert(document.body.myData.title); // Imperator\n\nWe can add a method as well:\n\n\t\ndocument.body.sayTagName = function() {\n  alert(this.tagName);\n};\n\ndocument.body.sayTagName(); // BODY (the value of \"this\" in the method is document.body)\n\nWe can also modify built-in prototypes like Element.prototype and add new methods to all elements:\n\n\t\nElement.prototype.sayHi = function() {\n  alert(`Hello, I'm ${this.tagName}`);\n};\n\ndocument.documentElement.sayHi(); // Hello, I'm HTML\ndocument.body.sayHi(); // Hello, I'm BODY\n\nSo, DOM properties and methods behave just like those of regular JavaScript objects:\n\nThey can have any value.\nThey are case-sensitive (write elem.nodeType, not elem.NoDeTyPe).\nHTML attributes\n\nIn HTML, tags may have attributes. When the browser parses the HTML to create DOM objects for tags, it recognizes standard attributes and creates DOM properties from them.\n\nSo when an element has id or another standard attribute, the corresponding property gets created. But that doesn’t happen if the attribute is non-standard.\n\nFor instance:\n\n\t\n<body id=\"test\" something=\"non-standard\">\n  <script>\n    alert(document.body.id); // test\n    // non-standard attribute does not yield a property\n    alert(document.body.something); // undefined\n  </script>\n</body>\n\nPlease note that a standard attribute for one element can be unknown for another one. For instance, \"type\" is standard for <input> (HTMLInputElement), but not for <body> (HTMLBodyElement). Standard attributes are described in the specification for the corresponding element class.\n\nHere we can see it:\n\n\t\n<body id=\"body\" type=\"...\">\n  <input id=\"input\" type=\"text\">\n  <script>\n    alert(input.type); // text\n    alert(body.type); // undefined: DOM property not created, because it's non-standard\n  </script>\n</body>\n\nSo, if an attribute is non-standard, there won’t be a DOM-property for it. Is there a way to access such attributes?\n\nSure. All attributes are accessible by using the following methods:\n\nelem.hasAttribute(name) – checks for existence.\nelem.getAttribute(name) – gets the value.\nelem.setAttribute(name, value) – sets the value.\nelem.removeAttribute(name) – removes the attribute.\n\nThese methods operate exactly with what’s written in HTML.\n\nAlso one can read all attributes using elem.attributes: a collection of objects that belong to a built-in Attr class, with name and value properties.\n\nHere’s a demo of reading a non-standard property:\n\n\t\n<body something=\"non-standard\">\n  <script>\n    alert(document.body.getAttribute('something')); // non-standard\n  </script>\n</body>\n\nHTML attributes have the following features:\n\nTheir name is case-insensitive (id is same as ID).\nTheir values are always strings.\n\nHere’s an extended demo of working with attributes:\n\n\t\n<body>\n  <div id=\"elem\" about=\"Elephant\"></div>\n\n  <script>\n    alert( elem.getAttribute('About') ); // (1) 'Elephant', reading\n\n    elem.setAttribute('Test', 123); // (2), writing\n\n    alert( elem.outerHTML ); // (3), see if the attribute is in HTML (yes)\n\n    for (let attr of elem.attributes) { // (4) list all\n      alert( `${attr.name} = ${attr.value}` );\n    }\n  </script>\n</body>\n\nPlease note:\n\ngetAttribute('About') – the first letter is uppercase here, and in HTML it’s all lowercase. But that doesn’t matter: attribute names are case-insensitive.\nWe can assign anything to an attribute, but it becomes a string. So here we have \"123\" as the value.\nAll attributes including ones that we set are visible in outerHTML.\nThe attributes collection is iterable and has all the attributes of the element (standard and non-standard) as objects with name and value properties.\nProperty-attribute synchronization\n\nWhen a standard attribute changes, the corresponding property is auto-updated, and (with some exceptions) vice versa.\n\nIn the example below id is modified as an attribute, and we can see the property changed too. And then the same backwards:\n\n\t\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // attribute => property\n  input.setAttribute('id', 'id');\n  alert(input.id); // id (updated)\n\n  // property => attribute\n  input.id = 'newId';\n  alert(input.getAttribute('id')); // newId (updated)\n</script>\n\nBut there are exclusions, for instance input.value synchronizes only from attribute → property, but not back:\n\n\t\n<input>\n\n<script>\n  let input = document.querySelector('input');\n\n  // attribute => property\n  input.setAttribute('value', 'text');\n  alert(input.value); // text\n\n  // NOT property => attribute\n  input.value = 'newValue';\n  alert(input.getAttribute('value')); // text (not updated!)\n</script>\n\nIn the example above:\n\nChanging the attribute value updates the property.\nBut the property change does not affect the attribute.\n\nThat “feature” may actually come in handy, because the user actions may lead to value changes, and then after them, if we want to recover the “original” value from HTML, it’s in the attribute.\n\nDOM properties are typed\n\nDOM properties are not always strings. For instance, the input.checked property (for checkboxes) is a boolean:\n\n\t\n<input id=\"input\" type=\"checkbox\" checked> checkbox\n\n<script>\n  alert(input.getAttribute('checked')); // the attribute value is: empty string\n  alert(input.checked); // the property value is: true\n</script>\n\nThere are other examples. The style attribute is a string, but the style property is an object:\n\n\t\n<div id=\"div\" style=\"color:red;font-size:120%\">Hello</div>\n\n<script>\n  // string\n  alert(div.getAttribute('style')); // color:red;font-size:120%\n\n  // object\n  alert(div.style); // [object CSSStyleDeclaration]\n  alert(div.style.color); // red\n</script>\n\nMost properties are strings though.\n\nQuite rarely, even if a DOM property type is a string, it may differ from the attribute. For instance, the href DOM property is always a full URL, even if the attribute contains a relative URL or just a #hash.\n\nHere’s an example:\n\n\t\n<a id=\"a\" href=\"#hello\">link</a>\n<script>\n  // attribute\n  alert(a.getAttribute('href')); // #hello\n\n  // property\n  alert(a.href ); // full URL in the form http://site.com/page#hello\n</script>\n\nIf we need the value of href or any other attribute exactly as written in the HTML, we can use getAttribute.\n\nNon-standard attributes, dataset\n\nWhen writing HTML, we use a lot of standard attributes. But what about non-standard, custom ones? First, let’s see whether they are useful or not? What for?\n\nSometimes non-standard attributes are used to pass custom data from HTML to JavaScript, or to “mark” HTML-elements for JavaScript.\n\nLike this:\n\n\t\n<!-- mark the div to show \"name\" here -->\n<div show-info=\"name\"></div>\n<!-- and age here -->\n<div show-info=\"age\"></div>\n\n<script>\n  // the code finds an element with the mark and shows what's requested\n  let user = {\n    name: \"Pete\",\n    age: 25\n  };\n\n  for(let div of document.querySelectorAll('[show-info]')) {\n    // insert the corresponding info into the field\n    let field = div.getAttribute('show-info');\n    div.innerHTML = user[field]; // first Pete into \"name\", then 25 into \"age\"\n  }\n</script>\n\nAlso they can be used to style an element.\n\nFor instance, here for the order state the attribute order-state is used:\n\n\t\n<style>\n  /* styles rely on the custom attribute \"order-state\" */\n  .order[order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div class=\"order\" order-state=\"new\">\n  A new order.\n</div>\n\n<div class=\"order\" order-state=\"pending\">\n  A pending order.\n</div>\n\n<div class=\"order\" order-state=\"canceled\">\n  A canceled order.\n</div>\n\nWhy would using an attribute be preferable to having classes like .order-state-new, .order-state-pending, .order-state-canceled?\n\nBecause an attribute is more convenient to manage. The state can be changed as easy as:\n\n// a bit simpler than removing old/adding a new class\ndiv.setAttribute('order-state', 'canceled');\n\nBut there may be a possible problem with custom attributes. What if we use a non-standard attribute for our purposes and later the standard introduces it and makes it do something? The HTML language is alive, it grows, and more attributes appear to suit the needs of developers. There may be unexpected effects in such case.\n\nTo avoid conflicts, there exist data-* attributes.\n\nAll attributes starting with “data-” are reserved for programmers’ use. They are available in the dataset property.\n\nFor instance, if an elem has an attribute named \"data-about\", it’s available as elem.dataset.about.\n\nLike this:\n\n\t\n<body data-about=\"Elephants\">\n<script>\n  alert(document.body.dataset.about); // Elephants\n</script>\n\nMultiword attributes like data-order-state become camel-cased: dataset.orderState.\n\nHere’s a rewritten “order state” example:\n\n\t\n<style>\n  .order[data-order-state=\"new\"] {\n    color: green;\n  }\n\n  .order[data-order-state=\"pending\"] {\n    color: blue;\n  }\n\n  .order[data-order-state=\"canceled\"] {\n    color: red;\n  }\n</style>\n\n<div id=\"order\" class=\"order\" data-order-state=\"new\">\n  A new order.\n</div>\n\n<script>\n  // read\n  alert(order.dataset.orderState); // new\n\n  // modify\n  order.dataset.orderState = \"pending\"; // (*)\n</script>\n\nUsing data-* attributes is a valid, safe way to pass custom data.\n\nPlease note that we can not only read, but also modify data-attributes. Then CSS updates the view accordingly: in the example above the last line (*) changes the color to blue.\n\nSummary\nAttributes – is what’s written in HTML.\nProperties – is what’s in DOM objects.\n\nA small comparison:\n\n\tProperties\tAttributes\nType\tAny value, standard properties have types described in the spec\tA string\nName\tName is case-sensitive\tName is not case-sensitive\n\nMethods to work with attributes are:\n\nelem.hasAttribute(name) – to check for existence.\nelem.getAttribute(name) – to get the value.\nelem.setAttribute(name, value) – to set the value.\nelem.removeAttribute(name) – to remove the attribute.\nelem.attributes is a collection of all attributes.\n\nFor most situations using DOM properties is preferable. We should refer to attributes only when DOM properties do not suit us, when we need exactly attributes, for instance:\n\nWe need a non-standard attribute. But if it starts with data-, then we should use dataset.\nWe want to read the value “as written” in HTML. The value of the DOM property may be different, for instance the href property is always a full URL, and we may want to get the “original” value.\nTasks\nGet the attribute\nimportance: 5\n\nWrite the code to select the element with data-widget-name attribute from the document and to read its value.\n\n\t\n<!DOCTYPE html>\n<html>\n<body>\n\n  <div data-widget-name=\"menu\">Choose the genre</div>\n\n  <script>\n    /* your code */\n  </script>\n</body>\n</html>\nsolution\nMake external links orange\nimportance: 3\n\nMake all external links orange by altering their style property.\n\nA link is external if:\n\nIts href has :// in it\nBut doesn’t start with http://internal.com.\n\nExample:\n\n\t\n<a name=\"list\">the list</a>\n<ul>\n  <li><a href=\"http://google.com\">http://google.com</a></li>\n  <li><a href=\"/tutorial\">/tutorial.html</a></li>\n  <li><a href=\"local/path\">local/path</a></li>\n  <li><a href=\"ftp://ftp.com/my.zip\">ftp://ftp.com/my.zip</a></li>\n  <li><a href=\"http://nodejs.org\">http://nodejs.org</a></li>\n  <li><a href=\"http://internal.com/test\">http://internal.com/test</a></li>\n</ul>\n\n<script>\n  // setting style for a single link\n  let link = document.querySelector('a');\n  link.style.color = 'orange';\n</script>\n\nThe result should be:\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Walking the DOM",
    "url": "https://javascript.info/dom-navigation",
    "html": "The DOM allows us to do anything with elements and their contents, but first we need to reach the corresponding DOM object.\n\nAll operations on the DOM start with the document object. That’s the main “entry point” to DOM. From it we can access any node.\n\nHere’s a picture of links that allow for travel between DOM nodes:\n\nLet’s discuss them in more detail.\n\nOn top: documentElement and body\n\nThe topmost tree nodes are available directly as document properties:\n\n<html> = document.documentElement\nThe topmost document node is document.documentElement. That’s the DOM node of the <html> tag.\n<body> = document.body\nAnother widely used DOM node is the <body> element – document.body.\n<head> = document.head\nThe <head> tag is available as document.head.\nThere’s a catch: document.body can be null\n\nA script cannot access an element that doesn’t exist at the moment of running.\n\nIn particular, if a script is inside <head>, then document.body is unavailable, because the browser did not read it yet.\n\nSo, in the example below the first alert shows null:\n\n\t\n<html>\n\n<head>\n  <script>\n    alert( \"From HEAD: \" + document.body ); // null, there's no <body> yet\n  </script>\n</head>\n\n<body>\n\n  <script>\n    alert( \"From BODY: \" + document.body ); // HTMLBodyElement, now it exists\n  </script>\n\n</body>\n</html>\nIn the DOM world null means “doesn’t exist”\n\nIn the DOM, the null value means “doesn’t exist” or “no such node”.\n\nChildren: childNodes, firstChild, lastChild\n\nThere are two terms that we’ll use from now on:\n\nChild nodes (or children) – elements that are direct children. In other words, they are nested exactly in the given one. For instance, <head> and <body> are children of <html> element.\nDescendants – all elements that are nested in the given one, including children, their children and so on.\n\nFor instance, here <body> has children <div> and <ul> (and few blank text nodes):\n\n\t\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>\n      <b>Information</b>\n    </li>\n  </ul>\n</body>\n</html>\n\n…And descendants of <body> are not only direct children <div>, <ul> but also more deeply nested elements, such as <li> (a child of <ul>) and <b> (a child of <li>) – the entire subtree.\n\nThe childNodes collection lists all child nodes, including text nodes.\n\nThe example below shows children of document.body:\n\n\t\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>Information</li>\n  </ul>\n\n  <div>End</div>\n\n  <script>\n    for (let i = 0; i < document.body.childNodes.length; i++) {\n      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT\n    }\n  </script>\n  ...more stuff...\n</body>\n</html>\n\nPlease note an interesting detail here. If we run the example above, the last element shown is <script>. In fact, the document has more stuff below, but at the moment of the script execution the browser did not read it yet, so the script doesn’t see it.\n\nProperties firstChild and lastChild give fast access to the first and last children.\n\nThey are just shorthands. If there exist child nodes, then the following is always true:\n\nelem.childNodes[0] === elem.firstChild\nelem.childNodes[elem.childNodes.length - 1] === elem.lastChild\n\nThere’s also a special function elem.hasChildNodes() to check whether there are any child nodes.\n\nDOM collections\n\nAs we can see, childNodes looks like an array. But actually it’s not an array, but rather a collection – a special array-like iterable object.\n\nThere are two important consequences:\n\nWe can use for..of to iterate over it:\nfor (let node of document.body.childNodes) {\n  alert(node); // shows all nodes from the collection\n}\n\nThat’s because it’s iterable (provides the Symbol.iterator property, as required).\n\nArray methods won’t work, because it’s not an array:\n\t\nalert(document.body.childNodes.filter); // undefined (there's no filter method!)\n\nThe first thing is nice. The second is tolerable, because we can use Array.from to create a “real” array from the collection, if we want array methods:\n\n\t\nalert( Array.from(document.body.childNodes).filter ); // function\nDOM collections are read-only\n\nDOM collections, and even more – all navigation properties listed in this chapter are read-only.\n\nWe can’t replace a child by something else by assigning childNodes[i] = ....\n\nChanging DOM needs other methods. We will see them in the next chapter.\n\nDOM collections are live\n\nAlmost all DOM collections with minor exceptions are live. In other words, they reflect the current state of DOM.\n\nIf we keep a reference to elem.childNodes, and add/remove nodes into DOM, then they appear in the collection automatically.\n\nDon’t use for..in to loop over collections\n\nCollections are iterable using for..of. Sometimes people try to use for..in for that.\n\nPlease, don’t. The for..in loop iterates over all enumerable properties. And collections have some “extra” rarely used properties that we usually do not want to get:\n\n\t\n<body>\n<script>\n  // shows 0, 1, length, item, values and more.\n  for (let prop in document.body.childNodes) alert(prop);\n</script>\n</body>\nSiblings and the parent\n\nSiblings are nodes that are children of the same parent.\n\nFor instance, here <head> and <body> are siblings:\n\n<html>\n  <head>...</head><body>...</body>\n</html>\n<body> is said to be the “next” or “right” sibling of <head>,\n<head> is said to be the “previous” or “left” sibling of <body>.\n\nThe next sibling is in nextSibling property, and the previous one – in previousSibling.\n\nThe parent is available as parentNode.\n\nFor example:\n\n\t\n// parent of <body> is <html>\nalert( document.body.parentNode === document.documentElement ); // true\n\n// after <head> goes <body>\nalert( document.head.nextSibling ); // HTMLBodyElement\n\n// before <body> goes <head>\nalert( document.body.previousSibling ); // HTMLHeadElement\nElement-only navigation\n\nNavigation properties listed above refer to all nodes. For instance, in childNodes we can see both text nodes, element nodes, and even comment nodes if they exist.\n\nBut for many tasks we don’t want text or comment nodes. We want to manipulate element nodes that represent tags and form the structure of the page.\n\nSo let’s see more navigation links that only take element nodes into account:\n\nThe links are similar to those given above, just with Element word inside:\n\nchildren – only those children that are element nodes.\nfirstElementChild, lastElementChild – first and last element children.\npreviousElementSibling, nextElementSibling – neighbor elements.\nparentElement – parent element.\nWhy parentElement? Can the parent be not an element?\n\nThe parentElement property returns the “element” parent, while parentNode returns “any node” parent. These properties are usually the same: they both get the parent.\n\nWith the one exception of document.documentElement:\n\n\t\nalert( document.documentElement.parentNode ); // document\nalert( document.documentElement.parentElement ); // null\n\nThe reason is that the root node document.documentElement (<html>) has document as its parent. But document is not an element node, so parentNode returns it and parentElement does not.\n\nThis detail may be useful when we want to travel up from an arbitrary element elem to <html>, but not to the document:\n\nwhile(elem = elem.parentElement) { // go up till <html>\n  alert( elem );\n}\n\nLet’s modify one of the examples above: replace childNodes with children. Now it shows only elements:\n\n\t\n<html>\n<body>\n  <div>Begin</div>\n\n  <ul>\n    <li>Information</li>\n  </ul>\n\n  <div>End</div>\n\n  <script>\n    for (let elem of document.body.children) {\n      alert(elem); // DIV, UL, DIV, SCRIPT\n    }\n  </script>\n  ...\n</body>\n</html>\nMore links: tables\n\nTill now we described the basic navigation properties.\n\nCertain types of DOM elements may provide additional properties, specific to their type, for convenience.\n\nTables are a great example of that, and represent a particularly important case:\n\nThe <table> element supports (in addition to the given above) these properties:\n\ntable.rows – the collection of <tr> elements of the table.\ntable.caption/tHead/tFoot – references to elements <caption>, <thead>, <tfoot>.\ntable.tBodies – the collection of <tbody> elements (can be many according to the standard, but there will always be at least one – even if it is not in the source HTML, the browser will put it in the DOM).\n\n<thead>, <tfoot>, <tbody> elements provide the rows property:\n\ntbody.rows – the collection of <tr> inside.\n\n<tr>:\n\ntr.cells – the collection of <td> and <th> cells inside the given <tr>.\ntr.sectionRowIndex – the position (index) of the given <tr> inside the enclosing <thead>/<tbody>/<tfoot>.\ntr.rowIndex – the number of the <tr> in the table as a whole (including all table rows).\n\n<td> and <th>:\n\ntd.cellIndex – the number of the cell inside the enclosing <tr>.\n\nAn example of usage:\n\n\t\n<table id=\"table\">\n  <tr>\n    <td>one</td><td>two</td>\n  </tr>\n  <tr>\n    <td>three</td><td>four</td>\n  </tr>\n</table>\n\n<script>\n  // get td with \"two\" (first row, second column)\n  let td = table.rows[0].cells[1];\n  td.style.backgroundColor = \"red\"; // highlight it\n</script>\n\nThe specification: tabular data.\n\nThere are also additional navigation properties for HTML forms. We’ll look at them later when we start working with forms.\n\nSummary\n\nGiven a DOM node, we can go to its immediate neighbors using navigation properties.\n\nThere are two main sets of them:\n\nFor all nodes: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.\nFor element nodes only: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.\n\nSome types of DOM elements, e.g. tables, provide additional properties and collections to access their content.\n\nTasks\nDOM children\nimportance: 5\n\nLook at this page:\n\n<html>\n<body>\n  <div>Users:</div>\n  <ul>\n    <li>John</li>\n    <li>Pete</li>\n  </ul>\n</body>\n</html>\n\nFor each of the following, give at least one way of how to access them:\n\nThe <div> DOM node?\nThe <ul> DOM node?\nThe second <li> (with Pete)?\nsolution\nThe sibling question\nimportance: 5\n\nIf elem – is an arbitrary DOM element node…\n\nIs it true that elem.lastChild.nextSibling is always null?\nIs it true that elem.children[0].previousSibling is always null ?\nsolution\nSelect all diagonal cells\nimportance: 5\n\nWrite the code to paint all diagonal table cells in red.\n\nYou’ll need to get all diagonal <td> from the <table> and paint them using the code:\n\n// td should be the reference to the table cell\ntd.style.backgroundColor = 'red';\n\nThe result should be:\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "DOM tree",
    "url": "https://javascript.info/dom-nodes",
    "html": "The backbone of an HTML document is tags.\n\nAccording to the Document Object Model (DOM), every HTML tag is an object. Nested tags are “children” of the enclosing one. The text inside a tag is an object as well.\n\nAll these objects are accessible using JavaScript, and we can use them to modify the page.\n\nFor example, document.body is the object representing the <body> tag.\n\nRunning this code will make the <body> red for 3 seconds:\n\n\t\ndocument.body.style.background = 'red'; // make the background red\n\nsetTimeout(() => document.body.style.background = '', 3000); // return back\n\nHere we used style.background to change the background color of document.body, but there are many other properties, such as:\n\ninnerHTML – HTML contents of the node.\noffsetWidth – the node width (in pixels)\n…and so on.\n\nSoon we’ll learn more ways to manipulate the DOM, but first we need to know about its structure.\n\nAn example of the DOM\n\nLet’s start with the following simple document:\n\n\t\n<!DOCTYPE HTML>\n<html>\n<head>\n  <title>About elk</title>\n</head>\n<body>\n  The truth about elk.\n</body>\n</html>\n\nThe DOM represents HTML as a tree structure of tags. Here’s how it looks:\n\n▾\nHTML\n▾\nHEAD\n#text ↵␣␣\n▾\nTITLE\n#text About elk\n#text ↵\n#text ↵\n▾\nBODY\n#text ↵␣␣The truth about elk.↵\n\nOn the picture above, you can click on element nodes and their children will open/collapse.\n\nEvery tree node is an object.\n\nTags are element nodes (or just elements) and form the tree structure: <html> is at the root, then <head> and <body> are its children, etc.\n\nThe text inside elements forms text nodes, labelled as #text. A text node contains only a string. It may not have children and is always a leaf of the tree.\n\nFor instance, the <title> tag has the text \"About elk\".\n\nPlease note the special characters in text nodes:\n\na newline: ↵ (in JavaScript known as \\n)\na space: ␣\n\nSpaces and newlines are totally valid characters, like letters and digits. They form text nodes and become a part of the DOM. So, for instance, in the example above the <head> tag contains some spaces before <title>, and that text becomes a #text node (it contains a newline and some spaces only).\n\nThere are only two top-level exclusions:\n\nSpaces and newlines before <head> are ignored for historical reasons.\nIf we put something after </body>, then that is automatically moved inside the body, at the end, as the HTML spec requires that all content must be inside <body>. So there can’t be any spaces after </body>.\n\nIn other cases everything’s straightforward – if there are spaces (just like any character) in the document, then they become text nodes in the DOM, and if we remove them, then there won’t be any.\n\nHere are no space-only text nodes:\n\n<!DOCTYPE HTML>\n<html><head><title>About elk</title></head><body>The truth about elk.</body></html>\n▾\nHTML\n▾\nHEAD\n▾\nTITLE\n#text About elk\n▾\nBODY\n#text The truth about elk.\nSpaces at string start/end and space-only text nodes are usually hidden in tools\n\nBrowser tools (to be covered soon) that work with DOM usually do not show spaces at the start/end of the text and empty text nodes (line-breaks) between tags.\n\nDeveloper tools save screen space this way.\n\nOn further DOM pictures we’ll sometimes omit them when they are irrelevant. Such spaces usually do not affect how the document is displayed.\n\nAutocorrection\n\nIf the browser encounters malformed HTML, it automatically corrects it when making the DOM.\n\nFor instance, the top tag is always <html>. Even if it doesn’t exist in the document, it will exist in the DOM, because the browser will create it. The same goes for <body>.\n\nAs an example, if the HTML file is the single word \"Hello\", the browser will wrap it into <html> and <body>, and add the required <head>, and the DOM will be:\n\n▾\nHTML\n▾\nHEAD\n▾\nBODY\n#text Hello\n\nWhile generating the DOM, browsers automatically process errors in the document, close tags and so on.\n\nA document with unclosed tags:\n\n<p>Hello\n<li>Mom\n<li>and\n<li>Dad\n\n…will become a normal DOM as the browser reads tags and restores the missing parts:\n\n▾\nHTML\n▾\nHEAD\n▾\nBODY\n▾\nP\n#text Hello\n▾\nLI\n#text Mom\n▾\nLI\n#text and\n▾\nLI\n#text Dad\nTables always have <tbody>\n\nAn interesting “special case” is tables. By DOM specification they must have <tbody> tag, but HTML text may omit it. Then the browser creates <tbody> in the DOM automatically.\n\nFor the HTML:\n\n<table id=\"table\"><tr><td>1</td></tr></table>\n\nDOM-structure will be:\n\n▾\nTABLE\n▾\nTBODY\n▾\nTR\n▾\nTD\n#text 1\n\nYou see? The <tbody> appeared out of nowhere. We should keep this in mind while working with tables to avoid surprises.\n\nOther node types\n\nThere are some other node types besides elements and text nodes.\n\nFor example, comments:\n\n<!DOCTYPE HTML>\n<html>\n<body>\n  The truth about elk.\n  <ol>\n    <li>An elk is a smart</li>\n    <!-- comment -->\n    <li>...and cunning animal!</li>\n  </ol>\n</body>\n</html>\n▾\nHTML\n▾\nHEAD\n▾\nBODY\n#text ↵␣␣The truth about elk.↵␣␣\n▾\nOL\n#text ↵␣␣␣␣\n▾\nLI\n#text An elk is a smart\n#text ↵␣␣␣␣\n#comment comment\n#text ↵␣␣␣␣\n▾\nLI\n#text ...and cunning animal!\n#text ↵␣␣\n#text ↵↵↵\n\nWe can see here a new tree node type – comment node, labeled as #comment, between two text nodes.\n\nWe may think – why is a comment added to the DOM? It doesn’t affect the visual representation in any way. But there’s a rule – if something’s in HTML, then it also must be in the DOM tree.\n\nEverything in HTML, even comments, becomes a part of the DOM.\n\nEven the <!DOCTYPE...> directive at the very beginning of HTML is also a DOM node. It’s in the DOM tree right before <html>. Few people know about that. We are not going to touch that node, we even don’t draw it on diagrams, but it’s there.\n\nThe document object that represents the whole document is, formally, a DOM node as well.\n\nThere are 12 node types. In practice we usually work with 4 of them:\n\ndocument – the “entry point” into DOM.\nelement nodes – HTML-tags, the tree building blocks.\ntext nodes – contain text.\ncomments – sometimes we can put information there, it won’t be shown, but JS can read it from the DOM.\nSee it for yourself\n\nTo see the DOM structure in real-time, try Live DOM Viewer. Just type in the document, and it will show up as a DOM at an instant.\n\nAnother way to explore the DOM is to use the browser developer tools. Actually, that’s what we use when developing.\n\nTo do so, open the web page elk.html, turn on the browser developer tools and switch to the Elements tab.\n\nIt should look like this:\n\nYou can see the DOM, click on elements, see their details and so on.\n\nPlease note that the DOM structure in developer tools is simplified. Text nodes are shown just as text. And there are no “blank” (space only) text nodes at all. That’s fine, because most of the time we are interested in element nodes.\n\nClicking the  button in the left-upper corner allows us to choose a node from the webpage using a mouse (or other pointer devices) and “inspect” it (scroll to it in the Elements tab). This works great when we have a huge HTML page (and corresponding huge DOM) and would like to see the place of a particular element in it.\n\nAnother way to do it would be just right-clicking on a webpage and selecting “Inspect” in the context menu.\n\nAt the right part of the tools there are the following subtabs:\n\nStyles – we can see CSS applied to the current element rule by rule, including built-in rules (gray). Almost everything can be edited in-place, including the dimensions/margins/paddings of the box below.\nComputed – to see CSS applied to the element by property: for each property we can see a rule that gives it (including CSS inheritance and such).\nEvent Listeners – to see event listeners attached to DOM elements (we’ll cover them in the next part of the tutorial).\n…and so on.\n\nThe best way to study them is to click around. Most values are editable in-place.\n\nInteraction with console\n\nAs we work the DOM, we also may want to apply JavaScript to it. Like: get a node and run some code to modify it, to see the result. Here are few tips to travel between the Elements tab and the console.\n\nFor the start:\n\nSelect the first <li> in the Elements tab.\nPress Esc – it will open console right below the Elements tab.\n\nNow the last selected element is available as $0, the previously selected is $1 etc.\n\nWe can run commands on them. For instance, $0.style.background = 'red' makes the selected list item red, like this:\n\nThat’s how to get a node from Elements in Console.\n\nThere’s also a road back. If there’s a variable referencing a DOM node, then we can use the command inspect(node) in Console to see it in the Elements pane.\n\nOr we can just output the DOM node in the console and explore “in-place”, like document.body below:\n\nThat’s for debugging purposes of course. From the next chapter on we’ll access and modify DOM using JavaScript.\n\nThe browser developer tools are a great help in development: we can explore the DOM, try things and see what goes wrong.\n\nSummary\n\nAn HTML/XML document is represented inside the browser as the DOM tree.\n\nTags become element nodes and form the structure.\nText becomes text nodes.\n…etc, everything in HTML has its place in DOM, even comments.\n\nWe can use developer tools to inspect DOM and modify it manually.\n\nHere we covered the basics, the most used and important actions to start with. There’s an extensive documentation about Chrome Developer Tools at https://developers.google.com/web/tools/chrome-devtools. The best way to learn the tools is to click here and there, read menus: most options are obvious. Later, when you know them in general, read the docs and pick up the rest.\n\nDOM nodes have properties and methods that allow us to travel between them, modify them, move around the page, and more. We’ll get down to them in the next chapters."
  },
  {
    "title": "WeakRef and FinalizationRegistry",
    "url": "https://javascript.info/weakref-finalizationregistry",
    "html": "“Hidden” features of the language\n\nThis article covers a very narrowly focused topic, that most developers extremely rarely encounter in practice (and may not even be aware of its existence).\n\nWe recommend skipping this chapter if you have just started learning JavaScript.\n\nRecalling the basic concept of the reachability principle from the Garbage collection chapter, we can note that the JavaScript engine is guaranteed to keep values in memory that are accessible or in use.\n\nFor example:\n\n//  the user variable holds a strong reference to the object\nlet user = { name: \"John\" };\n\n// let's overwrite the value of the user variable\nuser = null;\n\n// the reference is lost and the object will be deleted from memory\n\nOr a similar, but slightly more complicated code with two strong references:\n\n//  the user variable holds a strong reference to the object\nlet user = { name: \"John\" };\n\n// copied the strong reference to the object into the admin variable\nlet admin = user;\n\n// let's overwrite the value of the user variable\nuser = null;\n\n// the object is still reachable through the admin variable\n\nThe object { name: \"John\" } would only be deleted from memory if there were no strong references to it (if we also overwrote the value of the admin variable).\n\nIn JavaScript, there is a concept called WeakRef, which behaves slightly differently in this case.\n\nTerms: “Strong reference”, “Weak reference”\n\nStrong reference – is a reference to an object or value, that prevents them from being deleted by the garbage collector. Thereby, keeping the object or value in memory, to which it points.\n\nThis means, that the object or value remains in memory and is not collected by the garbage collector as long, as there are active strong references to it.\n\nIn JavaScript, ordinary references to objects are strong references. For example:\n\n// the user variable holds a strong reference to this object\nlet user = { name: \"John\" };\n\nWeak reference – is a reference to an object or value, that does not prevent them from being deleted by the garbage collector. An object or value can be deleted by the garbage collector if, the only remaining references to them are weak references.\n\nWeakRef\nNote of caution\n\nBefore we dive into it, it is worth noting that the correct use of the structures discussed in this article requires very careful thought, and they are best avoided if possible.\n\nWeakRef – is an object, that contains a weak reference to another object, called target or referent.\n\nThe peculiarity of WeakRef is that it does not prevent the garbage collector from deleting its referent-object. In other words, a WeakRef object does not keep the referent object alive.\n\nNow let’s take the user variable as the “referent” and create a weak reference from it to the admin variable. To create a weak reference, you need to use the WeakRef constructor, passing in the target object (the object you want a weak reference to).\n\nIn our case — this is the user variable:\n\n//  the user variable holds a strong reference to the object\nlet user = { name: \"John\" };\n\n//  the admin variable holds a weak reference to the object\nlet admin = new WeakRef(user);\n\nThe diagram below depicts two types of references: a strong reference using the user variable and a weak reference using the admin variable:\n\nThen, at some point, we stop using the user variable – it gets overwritten, goes out of scope, etc., while keeping the WeakRef instance in the admin variable:\n\n// let's overwrite the value of the user variable\nuser = null;\n\nA weak reference to an object is not enough to keep it “alive”. When the only remaining references to a referent-object are weak references, the garbage collector is free to destroy this object and use its memory for something else.\n\nHowever, until the object is actually destroyed, the weak reference may return it, even if there are no more strong references to this object. That is, our object becomes a kind of “Schrödinger’s cat” – we cannot know for sure whether it’s “alive” or “dead”:\n\nAt this point, to get the object from the WeakRef instance, we will use its deref() method.\n\nThe deref() method returns the referent-object that the WeakRef points to, if the object is still in memory. If the object has been deleted by the garbage collector, then the deref() method will return undefined:\n\nlet ref = admin.deref();\n\nif (ref) {\n  // the object is still accessible: we can perform any manipulations with it\n} else {\n  // the object has been collected by the garbage collector\n}\nWeakRef use cases\n\nWeakRef is typically used to create caches or associative arrays that store resource-intensive objects. This allows one to avoid preventing these objects from being collected by the garbage collector solely based on their presence in the cache or associative array.\n\nOne of the primary examples – is a situation when we have numerous binary image objects (for instance, represented as ArrayBuffer or Blob), and we want to associate a name or path with each image. Existing data structures are not quite suitable for these purposes:\n\nUsing Map to create associations between names and images, or vice versa, will keep the image objects in memory since they are present in the Map as keys or values.\nWeakMap is ineligible for this goal either: because the objects represented as WeakMap keys use weak references, and are not protected from deletion by the garbage collector.\n\nBut, in this situation, we need a data structure that would use weak references in its values.\n\nFor this purpose, we can use a Map collection, whose values are WeakRef instances referring to the large objects we need. Consequently, we will not keep these large and unnecessary objects in memory longer than they should be.\n\nOtherwise, this is a way to get the image object from the cache if it is still reachable. If it has been garbage collected, we will re-generate or re-download it again.\n\nThis way, less memory is used in some situations.\n\nExample №1: using WeakRef for caching\n\nBelow is a code snippet that demonstrates the technique of using WeakRef.\n\nIn short, we use a Map with string keys and WeakRef objects as their values. If the WeakRef object has not been collected by the garbage collector, we get it from the cache. Otherwise, we re-download it again and put it in the cache for further possible reuse:\n\nfunction fetchImg() {\n    // abstract function for downloading images...\n}\n\nfunction weakRefCache(fetchImg) { // (1)\n    const imgCache = new Map(); // (2)\n\n    return (imgName) => { // (3)\n        const cachedImg = imgCache.get(imgName); // (4)\n\n        if (cachedImg?.deref()) { // (5)\n            return cachedImg?.deref();\n        }\n\n        const newImg = fetchImg(imgName); // (6)\n        imgCache.set(imgName, new WeakRef(newImg)); // (7)\n\n        return newImg;\n    };\n}\n\nconst getCachedImg = weakRefCache(fetchImg);\n\nLet’s delve into the details of what happened here:\n\nweakRefCache – is a higher-order function that takes another function, fetchImg, as an argument. In this example, we can neglect a detailed description of the fetchImg function, since it can be any logic for downloading images.\nimgCache – is a cache of images, that stores cached results of the fetchImg function, in the form of string keys (image name) and WeakRef objects as their values.\nReturn an anonymous function that takes the image name as an argument. This argument will be used as a key for the cached image.\nTrying to get the cached result from the cache, using the provided key (image name).\nIf the cache contains a value for the specified key, and the WeakRef object has not been deleted by the garbage collector, return the cached result.\nIf there is no entry in the cache with the requested key, or deref() method returns undefined (meaning that the WeakRef object has been garbage collected), the fetchImg function downloads the image again.\nPut the downloaded image into the cache as a WeakRef object.\n\nNow we have a Map collection, where the keys – are image names as strings, and values – are WeakRef objects containing the images themselves.\n\nThis technique helps to avoid allocating a large amount of memory for resource-intensive objects, that nobody uses anymore. It also saves memory and time in case of reusing cached objects.\n\nHere is a visual representation of what this code looks like:\n\nBut, this implementation has its drawbacks: over time, Map will be filled with strings as keys, that point to a WeakRef, whose referent-object has already been garbage collected:\n\nOne way to handle this problem – is to periodically scavenge the cache and clear out “dead” entries. Another way – is to use finalizers, which we will explore next.\n\nExample №2: Using WeakRef to track DOM objects\n\nAnother use case for WeakRef – is tracking DOM objects.\n\nLet’s imagine a scenario where some third-party code or library interacts with elements on our page as long as they exist in the DOM. For example, it could be an external utility for monitoring and notifying about the system’s state (commonly so-called “logger” – a program that sends informational messages called “logs”).\n\nInteractive example:\n\nResultindex.jsindex.cssindex.html\n\t\n\nWhen the “Start sending messages” button is clicked, in the so-called “logs display window” (an element with the .window__body class), messages (logs) start to appear.\n\nBut, as soon as this element is deleted from the DOM, the logger should stop sending messages. To reproduce the removal of this element, just click the “Close” button in the top right corner.\n\nIn order not to complicate our work, and not to notify third-party code every time our DOM-element is available, and when it is not, it will be enough to create a weak reference to it using WeakRef.\n\nOnce the element is removed from the DOM, the logger will notice it and stop sending messages.\n\nNow let’s take a closer look at the source code (tab index.js):\n\nGet the DOM-element of the “Start sending messages” button.\n\nGet the DOM-element of the “Close” button.\n\nGet the DOM-element of the logs display window using the new WeakRef() constructor. This way, the windowElementRef variable holds a weak reference to the DOM-element.\n\nAdd an event listener on the “Start sending messages” button, responsible for starting the logger when clicked.\n\nAdd an event listener on the “Close” button, responsible for closing the logs display window when clicked.\n\nUse setInterval to start displaying a new message every second.\n\nIf the DOM-element of the logs display window is still accessible and kept in memory, create and send a new message.\n\nIf the deref() method returns undefined, it means that the DOM-element has been deleted from memory. In this case, the logger stops displaying messages and clears the timer.\n\nalert, which will be called, after the DOM-element of the logs display window is deleted from memory (i.e. after clicking the “Close” button). Note, that deletion from memory may not happen immediately, as it depends only on the internal mechanisms of the garbage collector.\n\nWe cannot control this process directly from the code. However, despite this, we still have the option to force garbage collection from the browser.\n\nIn Google Chrome, for example, to do this, you need to open the developer tools (Ctrl + Shift + J on Windows/Linux or Option + ⌘ + J on macOS), go to the “Performance” tab, and click on the bin icon button – “Collect garbage”:\n\n\nThis functionality is supported in most modern browsers. After the actions are taken, the alert will trigger immediately.\nFinalizationRegistry\n\nNow it is time to talk about finalizers. Before we move on, let’s clarify the terminology:\n\nCleanup callback (finalizer) – is a function that is executed, when an object, registered in the FinalizationRegistry, is deleted from memory by the garbage collector.\n\nIts purpose – is to provide the ability to perform additional operations, related to the object, after it has been finally deleted from memory.\n\nRegistry (or FinalizationRegistry) – is a special object in JavaScript that manages the registration and unregistration of objects and their cleanup callbacks.\n\nThis mechanism allows registering an object to track and associate a cleanup callback with it. Essentially it is a structure that stores information about registered objects and their cleanup callbacks, and then automatically invokes those callbacks when the objects are deleted from memory.\n\nTo create an instance of the FinalizationRegistry, it needs to call its constructor, which takes a single argument – the cleanup callback (finalizer).\n\nSyntax:\n\nfunction cleanupCallback(heldValue) {\n  // cleanup callback code\n}\n\nconst registry = new FinalizationRegistry(cleanupCallback);\n\nHere:\n\ncleanupCallback – a cleanup callback that will be automatically called when a registered object is deleted from memory.\nheldValue – the value that is passed as an argument to the cleanup callback. If heldValue is an object, the registry keeps a strong reference to it.\nregistry – an instance of FinalizationRegistry.\n\nFinalizationRegistry methods:\n\nregister(target, heldValue [, unregisterToken]) – used to register objects in the registry.\n\ntarget – the object being registered for tracking. If the target is garbage collected, the cleanup callback will be called with heldValue as its argument.\n\nOptional unregisterToken – an unregistration token. It can be passed to unregister an object before the garbage collector deletes it. Typically, the target object is used as unregisterToken, which is the standard practice.\n\nunregister(unregisterToken) – the unregister method is used to unregister an object from the registry. It takes one argument – unregisterToken (the unregister token that was obtained when registering the object).\n\nNow let’s move on to a simple example. Let’s use the already-known user object and create an instance of FinalizationRegistry:\n\nlet user = { name: \"John\" };\n\nconst registry = new FinalizationRegistry((heldValue) => {\n  console.log(`${heldValue} has been collected by the garbage collector.`);\n});\n\nThen, we will register the object, that requires a cleanup callback by calling the register method:\n\nregistry.register(user, user.name);\n\nThe registry does not keep a strong reference to the object being registered, as this would defeat its purpose. If the registry kept a strong reference, then the object would never be garbage collected.\n\nIf the object is deleted by the garbage collector, our cleanup callback may be called at some point in the future, with the heldValue passed to it:\n\n// When the user object is deleted by the garbage collector, the following message will be printed in the console:\n\"John has been collected by the garbage collector.\"\n\nThere are also situations where, even in implementations that use a cleanup callback, there is a chance that it will not be called.\n\nFor example:\n\nWhen the program fully terminates its operation (for example, when closing a tab in a browser).\nWhen the FinalizationRegistry instance itself is no longer reachable to JavaScript code. If the object that creates the FinalizationRegistry instance goes out of scope or is deleted, the cleanup callbacks registered in that registry might also not be invoked.\nCaching with FinalizationRegistry\n\nReturning to our weak cache example, we can notice the following:\n\nEven though the values wrapped in the WeakRef have been collected by the garbage collector, there is still an issue of “memory leakage” in the form of the remaining keys, whose values have been collected by the garbage collector.\n\nHere is an improved caching example using FinalizationRegistry:\n\nfunction fetchImg() {\n  // abstract function for downloading images...\n}\n\nfunction weakRefCache(fetchImg) {\n  const imgCache = new Map();\n\n  const registry = new FinalizationRegistry((imgName) => { // (1)\n    const cachedImg = imgCache.get(imgName);\n    if (cachedImg && !cachedImg.deref()) imgCache.delete(imgName);\n  });\n\n  return (imgName) => {\n    const cachedImg = imgCache.get(imgName);\n\n    if (cachedImg?.deref()) {\n      return cachedImg?.deref();\n    }\n\n    const newImg = fetchImg(imgName);\n    imgCache.set(imgName, new WeakRef(newImg));\n    registry.register(newImg, imgName); // (2)\n\n    return newImg;\n  };\n}\n\nconst getCachedImg = weakRefCache(fetchImg);\n\nTo manage the cleanup of “dead” cache entries, when the associated WeakRef objects are collected by the garbage collector, we create a FinalizationRegistry cleanup registry.\n\nThe important point here is, that in the cleanup callback, it should be checked, if the entry was deleted by the garbage collector and not re-added, in order not to delete a “live” entry.\n\nOnce the new value (image) is downloaded and put into the cache, we register it in the finalizer registry to track the WeakRef object.\n\nThis implementation contains only actual or “live” key/value pairs. In this case, each WeakRef object is registered in the FinalizationRegistry. And after the objects are cleaned up by the garbage collector, the cleanup callback will delete all undefined values.\n\nHere is a visual representation of the updated code:\n\nA key aspect of the updated implementation is that finalizers allow parallel processes to be created between the “main” program and cleanup callbacks. In the context of JavaScript, the “main” program – is our JavaScript-code, that runs and executes in our application or web page.\n\nHence, from the moment an object is marked for deletion by the garbage collector, and to the actual execution of the cleanup callback, there may be a certain time gap. It is important to understand that during this time gap, the main program can make any changes to the object or even bring it back to memory.\n\nThat’s why, in the cleanup callback, we must check to see if an entry has been added back to the cache by the main program to avoid deleting “live” entries. Similarly, when searching for a key in the cache, there is a chance that the value has been deleted by the garbage collector, but the cleanup callback has not been executed yet.\n\nSuch situations require special attention if you are working with FinalizationRegistry.\n\nUsing WeakRef and FinalizationRegistry in practice\n\nMoving from theory to practice, imagine a real-life scenario, where a user synchronizes their photos on a mobile device with some cloud service (such as iCloud or Google Photos), and wants to view them from other devices. In addition to the basic functionality of viewing photos, such services offer a lot of additional features, for example:\n\nPhoto editing and video effects.\nCreating “memories” and albums.\nVideo montage from a series of photos.\n…and much more.\n\nHere, as an example, we will use a fairly primitive implementation of such a service. The main point – is to show a possible scenario of using WeakRef and FinalizationRegistry together in real life.\n\nHere is what it looks like:\n\n\nOn the left side, there is a cloud library of photos (they are displayed as thumbnails). We can select the images we need and create a collage, by clicking the \"Create collage\" button on the right side of the page. Then, the resulting collage can be downloaded as an image.\n\n\n\nTo increase page loading speed, it would be reasonable to download and display photo thumbnails in compressed quality. But, to create a collage from selected photos, download and use them in full-size quality.\n\nBelow, we can see, that the intrinsic size of the thumbnails is 240x240 pixels. The size was chosen on purpose to increase loading speed. Moreover, we do not need full-size photos in preview mode.\n\n\nLet's assume, that we need to create a collage of 4 photos: we select them, and then click the \"Create collage\" button. At this stage, the already known to us weakRefCache function checks whether the required image is in the cache. If not, it downloads it from the cloud and puts it in the cache for further use. This happens for each selected image:\n\n\n\n\n\nPaying attention to the output in the console, you can see, which of the photos were downloaded from the cloud – this is indicated by FETCHED_IMAGE. Since this is the first attempt to create a collage, this means, that at this stage the “weak cache” was still empty, and all the photos were downloaded from the cloud and put in it.\n\nBut, along with the process of downloading images, there is also a process of memory cleanup by the garbage collector. This means, that the object stored in the cache, which we refer to, using a weak reference, is deleted by the garbage collector. And our finalizer executes successfully, thereby deleting the key, by which the image was stored in the cache. CLEANED_IMAGE notifies us about it:\n\n\nNext, we realize that we do not like the resulting collage, and decide to change one of the images and create a new one. To do this, just deselect the unnecessary image, select another one, and click the \"Create collage\" button again:\n\n\n\nBut this time not all images were downloaded from the network, and one of them was taken from the weak cache: the CACHED_IMAGE message tells us about it. This means that at the time of collage creation, the garbage collector had not yet deleted our image, and we boldly took it from the cache, thereby reducing the number of network requests and speeding up the overall time of the collage creation process:\n\n\n\nLet's \"play around\" a little more, by replacing one of the images again and creating a new collage:\n\n\n\nThis time the result is even more impressive. Of the 4 images selected, 3 of them were taken from the weak cache, and only one had to be downloaded from the network. The reduction in network load was about 75%. Impressive, isn't it?\n\n\n\n\n\nOf course, it is important to remember, that such behavior is not guaranteed, and depends on the specific implementation and operation of the garbage collector.\n\nBased on this, a completely logical question immediately arises: why do not we use an ordinary cache, where we can manage its entities ourselves, instead of relying on the garbage collector? That’s right, in the vast majority of cases there is no need to use WeakRef and FinalizationRegistry.\n\nHere, we simply demonstrated an alternative implementation of similar functionality, using a non-trivial approach with interesting language features. Still, we cannot rely on this example, if we need a constant and predictable result.\n\nYou can open this example in the sandbox.\n\nSummary\n\nWeakRef – designed to create weak references to objects, allowing them to be deleted from memory by the garbage collector if there are no longer strong references to them. This is beneficial for addressing excessive memory usage and optimizing the utilization of system resources in applications.\n\nFinalizationRegistry – is a tool for registering callbacks, that are executed when objects that are no longer strongly referenced, are destroyed. This allows releasing resources associated with the object or performing other necessary operations before deleting the object from memory."
  },
  {
    "title": "Node properties: type, tag and contents",
    "url": "https://javascript.info/basic-dom-node-properties",
    "html": "Let’s get a more in-depth look at DOM nodes.\n\nIn this chapter we’ll see more into what they are and learn their most used properties.\n\nDOM node classes\n\nDifferent DOM nodes may have different properties. For instance, an element node corresponding to tag <a> has link-related properties, and the one corresponding to <input> has input-related properties and so on. Text nodes are not the same as element nodes. But there are also common properties and methods between all of them, because all classes of DOM nodes form a single hierarchy.\n\nEach DOM node belongs to the corresponding built-in class.\n\nThe root of the hierarchy is EventTarget, that is inherited by Node, and other DOM nodes inherit from it.\n\nHere’s the picture, explanations to follow:\n\nThe classes are:\n\nEventTarget – is the root “abstract” class for everything.\n\nObjects of that class are never created. It serves as a base, so that all DOM nodes support so-called “events”, we’ll study them later.\n\nNode – is also an “abstract” class, serving as a base for DOM nodes.\n\nIt provides the core tree functionality: parentNode, nextSibling, childNodes and so on (they are getters). Objects of Node class are never created. But there are other classes that inherit from it (and so inherit the Node functionality).\n\nDocument, for historical reasons often inherited by HTMLDocument (though the latest spec doesn’t dictate it) – is a document as a whole.\n\nThe document global object belongs exactly to this class. It serves as an entry point to the DOM.\n\nCharacterData – an “abstract” class, inherited by:\n\nText – the class corresponding to a text inside elements, e.g. Hello in <p>Hello</p>.\nComment – the class for comments. They are not shown, but each comment becomes a member of DOM.\n\nElement – is the base class for DOM elements.\n\nIt provides element-level navigation like nextElementSibling, children and searching methods like getElementsByTagName, querySelector.\n\nA browser supports not only HTML, but also XML and SVG. So the Element class serves as a base for more specific classes: SVGElement, XMLElement (we don’t need them here) and HTMLElement.\n\nFinally, HTMLElement is the basic class for all HTML elements. We’ll work with it most of the time.\n\nIt is inherited by concrete HTML elements:\n\nHTMLInputElement – the class for <input> elements,\nHTMLBodyElement – the class for <body> elements,\nHTMLAnchorElement – the class for <a> elements,\n…and so on.\n\nThere are many other tags with their own classes that may have specific properties and methods, while some elements, such as <span>, <section>, <article> do not have any specific properties, so they are instances of HTMLElement class.\n\nSo, the full set of properties and methods of a given node comes as the result of the chain of inheritance.\n\nFor example, let’s consider the DOM object for an <input> element. It belongs to HTMLInputElement class.\n\nIt gets properties and methods as a superposition of (listed in inheritance order):\n\nHTMLInputElement – this class provides input-specific properties,\nHTMLElement – it provides common HTML element methods (and getters/setters),\nElement – provides generic element methods,\nNode – provides common DOM node properties,\nEventTarget – gives the support for events (to be covered),\n…and finally it inherits from Object, so “plain object” methods like hasOwnProperty are also available.\n\nTo see the DOM node class name, we can recall that an object usually has the constructor property. It references the class constructor, and constructor.name is its name:\n\n\t\nalert( document.body.constructor.name ); // HTMLBodyElement\n\n…Or we can just toString it:\n\n\t\nalert( document.body ); // [object HTMLBodyElement]\n\nWe also can use instanceof to check the inheritance:\n\n\t\nalert( document.body instanceof HTMLBodyElement ); // true\nalert( document.body instanceof HTMLElement ); // true\nalert( document.body instanceof Element ); // true\nalert( document.body instanceof Node ); // true\nalert( document.body instanceof EventTarget ); // true\n\nAs we can see, DOM nodes are regular JavaScript objects. They use prototype-based classes for inheritance.\n\nThat’s also easy to see by outputting an element with console.dir(elem) in a browser. There in the console you can see HTMLElement.prototype, Element.prototype and so on.\n\nconsole.dir(elem) versus console.log(elem)\n\nMost browsers support two commands in their developer tools: console.log and console.dir. They output their arguments to the console. For JavaScript objects these commands usually do the same.\n\nBut for DOM elements they are different:\n\nconsole.log(elem) shows the element DOM tree.\nconsole.dir(elem) shows the element as a DOM object, good to explore its properties.\n\nTry it on document.body.\n\nIDL in the spec\n\nIn the specification, DOM classes aren’t described by using JavaScript, but a special Interface description language (IDL), that is usually easy to understand.\n\nIn IDL all properties are prepended with their types. For instance, DOMString, boolean and so on.\n\nHere’s an excerpt from it, with comments:\n\n// Define HTMLInputElement\n// The colon \":\" means that HTMLInputElement inherits from HTMLElement\ninterface HTMLInputElement: HTMLElement {\n  // here go properties and methods of <input> elements\n\n  // \"DOMString\" means that the value of a property is a string\n  attribute DOMString accept;\n  attribute DOMString alt;\n  attribute DOMString autocomplete;\n  attribute DOMString value;\n\n  // boolean value property (true/false)\n  attribute boolean autofocus;\n  ...\n  // now the method: \"void\" means that the method returns no value\n  void select();\n  ...\n}\nThe “nodeType” property\n\nThe nodeType property provides one more, “old-fashioned” way to get the “type” of a DOM node.\n\nIt has a numeric value:\n\nelem.nodeType == 1 for element nodes,\nelem.nodeType == 3 for text nodes,\nelem.nodeType == 9 for the document object,\nthere are few other values in the specification.\n\nFor instance:\n\n\t\n<body>\n  <script>\n  let elem = document.body;\n\n  // let's examine: what type of node is in elem?\n  alert(elem.nodeType); // 1 => element\n\n  // and its first child is...\n  alert(elem.firstChild.nodeType); // 3 => text\n\n  // for the document object, the type is 9\n  alert( document.nodeType ); // 9\n  </script>\n</body>\n\nIn modern scripts, we can use instanceof and other class-based tests to see the node type, but sometimes nodeType may be simpler. We can only read nodeType, not change it.\n\nTag: nodeName and tagName\n\nGiven a DOM node, we can read its tag name from nodeName or tagName properties:\n\nFor instance:\n\n\t\nalert( document.body.nodeName ); // BODY\nalert( document.body.tagName ); // BODY\n\nIs there any difference between tagName and nodeName?\n\nSure, the difference is reflected in their names, but is indeed a bit subtle.\n\nThe tagName property exists only for Element nodes.\nThe nodeName is defined for any Node:\nfor elements it means the same as tagName.\nfor other node types (text, comment, etc.) it has a string with the node type.\n\nIn other words, tagName is only supported by element nodes (as it originates from Element class), while nodeName can say something about other node types.\n\nFor instance, let’s compare tagName and nodeName for the document and a comment node:\n\n\t\n<body><!-- comment -->\n\n  <script>\n    // for comment\n    alert( document.body.firstChild.tagName ); // undefined (not an element)\n    alert( document.body.firstChild.nodeName ); // #comment\n\n    // for document\n    alert( document.tagName ); // undefined (not an element)\n    alert( document.nodeName ); // #document\n  </script>\n</body>\n\nIf we only deal with elements, then we can use both tagName and nodeName – there’s no difference.\n\nThe tag name is always uppercase except in XML mode\n\nThe browser has two modes of processing documents: HTML and XML. Usually the HTML-mode is used for webpages. XML-mode is enabled when the browser receives an XML-document with the header: Content-Type: application/xml+xhtml.\n\nIn HTML mode tagName/nodeName is always uppercased: it’s BODY either for <body> or <BoDy>.\n\nIn XML mode the case is kept “as is”. Nowadays XML mode is rarely used.\n\ninnerHTML: the contents\n\nThe innerHTML property allows to get the HTML inside the element as a string.\n\nWe can also modify it. So it’s one of the most powerful ways to change the page.\n\nThe example shows the contents of document.body and then replaces it completely:\n\n\t\n<body>\n  <p>A paragraph</p>\n  <div>A div</div>\n\n  <script>\n    alert( document.body.innerHTML ); // read the current contents\n    document.body.innerHTML = 'The new BODY!'; // replace it\n  </script>\n\n</body>\n\nWe can try to insert invalid HTML, the browser will fix our errors:\n\n\t\n<body>\n\n  <script>\n    document.body.innerHTML = '<b>test'; // forgot to close the tag\n    alert( document.body.innerHTML ); // <b>test</b> (fixed)\n  </script>\n\n</body>\nScripts don’t execute\n\nIf innerHTML inserts a <script> tag into the document – it becomes a part of HTML, but doesn’t execute.\n\nBeware: “innerHTML+=” does a full overwrite\n\nWe can append HTML to an element by using elem.innerHTML+=\"more html\".\n\nLike this:\n\nchatDiv.innerHTML += \"<div>Hello<img src='smile.gif'/> !</div>\";\nchatDiv.innerHTML += \"How goes?\";\n\nBut we should be very careful about doing it, because what’s going on is not an addition, but a full overwrite.\n\nTechnically, these two lines do the same:\n\nelem.innerHTML += \"...\";\n// is a shorter way to write:\nelem.innerHTML = elem.innerHTML + \"...\"\n\nIn other words, innerHTML+= does this:\n\nThe old contents is removed.\nThe new innerHTML is written instead (a concatenation of the old and the new one).\n\nAs the content is “zeroed-out” and rewritten from the scratch, all images and other resources will be reloaded.\n\nIn the chatDiv example above the line chatDiv.innerHTML+=\"How goes?\" re-creates the HTML content and reloads smile.gif (hope it’s cached). If chatDiv has a lot of other text and images, then the reload becomes clearly visible.\n\nThere are other side-effects as well. For instance, if the existing text was selected with the mouse, then most browsers will remove the selection upon rewriting innerHTML. And if there was an <input> with a text entered by the visitor, then the text will be removed. And so on.\n\nLuckily, there are other ways to add HTML besides innerHTML, and we’ll study them soon.\n\nouterHTML: full HTML of the element\n\nThe outerHTML property contains the full HTML of the element. That’s like innerHTML plus the element itself.\n\nHere’s an example:\n\n\t\n<div id=\"elem\">Hello <b>World</b></div>\n\n<script>\n  alert(elem.outerHTML); // <div id=\"elem\">Hello <b>World</b></div>\n</script>\n\nBeware: unlike innerHTML, writing to outerHTML does not change the element. Instead, it replaces it in the DOM.\n\nYeah, sounds strange, and strange it is, that’s why we make a separate note about it here. Take a look.\n\nConsider the example:\n\n\t\n<div>Hello, world!</div>\n\n<script>\n  let div = document.querySelector('div');\n\n  // replace div.outerHTML with <p>...</p>\n  div.outerHTML = '<p>A new element</p>'; // (*)\n\n  // Wow! 'div' is still the same!\n  alert(div.outerHTML); // <div>Hello, world!</div> (**)\n</script>\n\nLooks really odd, right?\n\nIn the line (*) we replaced div with <p>A new element</p>. In the outer document (the DOM) we can see the new content instead of the <div>. But, as we can see in line (**), the value of the old div variable hasn’t changed!\n\nThe outerHTML assignment does not modify the DOM element (the object referenced by, in this case, the variable ‘div’), but removes it from the DOM and inserts the new HTML in its place.\n\nSo what happened in div.outerHTML=... is:\n\ndiv was removed from the document.\nAnother piece of HTML <p>A new element</p> was inserted in its place.\ndiv still has its old value. The new HTML wasn’t saved to any variable.\n\nIt’s so easy to make an error here: modify div.outerHTML and then continue to work with div as if it had the new content in it. But it doesn’t. Such thing is correct for innerHTML, but not for outerHTML.\n\nWe can write to elem.outerHTML, but should keep in mind that it doesn’t change the element we’re writing to (‘elem’). It puts the new HTML in its place instead. We can get references to the new elements by querying the DOM.\n\nnodeValue/data: text node content\n\nThe innerHTML property is only valid for element nodes.\n\nOther node types, such as text nodes, have their counterpart: nodeValue and data properties. These two are almost the same for practical use, there are only minor specification differences. So we’ll use data, because it’s shorter.\n\nAn example of reading the content of a text node and a comment:\n\n\t\n<body>\n  Hello\n  <!-- Comment -->\n  <script>\n    let text = document.body.firstChild;\n    alert(text.data); // Hello\n\n    let comment = text.nextSibling;\n    alert(comment.data); // Comment\n  </script>\n</body>\n\nFor text nodes we can imagine a reason to read or modify them, but why comments?\n\nSometimes developers embed information or template instructions into HTML in them, like this:\n\n<!-- if isAdmin -->\n  <div>Welcome, Admin!</div>\n<!-- /if -->\n\n…Then JavaScript can read it from data property and process embedded instructions.\n\ntextContent: pure text\n\nThe textContent provides access to the text inside the element: only text, minus all <tags>.\n\nFor instance:\n\n\t\n<div id=\"news\">\n  <h1>Headline!</h1>\n  <p>Martians attack people!</p>\n</div>\n\n<script>\n  // Headline! Martians attack people!\n  alert(news.textContent);\n</script>\n\nAs we can see, only text is returned, as if all <tags> were cut out, but the text in them remained.\n\nIn practice, reading such text is rarely needed.\n\nWriting to textContent is much more useful, because it allows to write text the “safe way”.\n\nLet’s say we have an arbitrary string, for instance entered by a user, and want to show it.\n\nWith innerHTML we’ll have it inserted “as HTML”, with all HTML tags.\nWith textContent we’ll have it inserted “as text”, all symbols are treated literally.\n\nCompare the two:\n\n\t\n<div id=\"elem1\"></div>\n<div id=\"elem2\"></div>\n\n<script>\n  let name = prompt(\"What's your name?\", \"<b>Winnie-the-Pooh!</b>\");\n\n  elem1.innerHTML = name;\n  elem2.textContent = name;\n</script>\nThe first <div> gets the name “as HTML”: all tags become tags, so we see the bold name.\nThe second <div> gets the name “as text”, so we literally see <b>Winnie-the-Pooh!</b>.\n\nIn most cases, we expect the text from a user, and want to treat it as text. We don’t want unexpected HTML in our site. An assignment to textContent does exactly that.\n\nThe “hidden” property\n\nThe “hidden” attribute and the DOM property specifies whether the element is visible or not.\n\nWe can use it in HTML or assign it using JavaScript, like this:\n\n\t\n<div>Both divs below are hidden</div>\n\n<div hidden>With the attribute \"hidden\"</div>\n\n<div id=\"elem\">JavaScript assigned the property \"hidden\"</div>\n\n<script>\n  elem.hidden = true;\n</script>\n\nTechnically, hidden works the same as style=\"display:none\". But it’s shorter to write.\n\nHere’s a blinking element:\n\n\t\n<div id=\"elem\">A blinking element</div>\n\n<script>\n  setInterval(() => elem.hidden = !elem.hidden, 1000);\n</script>\nMore properties\n\nDOM elements also have additional properties, in particular those that depend on the class:\n\nvalue – the value for <input>, <select> and <textarea> (HTMLInputElement, HTMLSelectElement…).\nhref – the “href” for <a href=\"...\"> (HTMLAnchorElement).\nid – the value of “id” attribute, for all elements (HTMLElement).\n…and much more…\n\nFor instance:\n\n\t\n<input type=\"text\" id=\"elem\" value=\"value\">\n\n<script>\n  alert(elem.type); // \"text\"\n  alert(elem.id); // \"elem\"\n  alert(elem.value); // value\n</script>\n\nMost standard HTML attributes have the corresponding DOM property, and we can access it like that.\n\nIf we want to know the full list of supported properties for a given class, we can find them in the specification. For instance, HTMLInputElement is documented at https://html.spec.whatwg.org/#htmlinputelement.\n\nOr if we’d like to get them fast or are interested in a concrete browser specification – we can always output the element using console.dir(elem) and read the properties. Or explore “DOM properties” in the Elements tab of the browser developer tools.\n\nSummary\n\nEach DOM node belongs to a certain class. The classes form a hierarchy. The full set of properties and methods come as the result of inheritance.\n\nMain DOM node properties are:\n\nnodeType\nWe can use it to see if a node is a text or an element node. It has a numeric value: 1 for elements,3 for text nodes, and a few others for other node types. Read-only.\nnodeName/tagName\nFor elements, tag name (uppercased unless XML-mode). For non-element nodes nodeName describes what it is. Read-only.\ninnerHTML\nThe HTML content of the element. Can be modified.\nouterHTML\nThe full HTML of the element. A write operation into elem.outerHTML does not touch elem itself. Instead it gets replaced with the new HTML in the outer context.\nnodeValue/data\nThe content of a non-element node (text, comment). These two are almost the same, usually we use data. Can be modified.\ntextContent\nThe text inside the element: HTML minus all <tags>. Writing into it puts the text inside the element, with all special characters and tags treated exactly as text. Can safely insert user-generated text and protect from unwanted HTML insertions.\nhidden\nWhen set to true, does the same as CSS display:none.\n\nDOM nodes also have other properties depending on their class. For instance, <input> elements (HTMLInputElement) support value, type, while <a> elements (HTMLAnchorElement) support href etc. Most standard HTML attributes have a corresponding DOM property.\n\nHowever, HTML attributes and DOM properties are not always the same, as we’ll see in the next chapter.\n\nTasks\nCount descendants\nimportance: 5\n\nThere’s a tree structured as nested ul/li.\n\nWrite the code that for each <li> shows:\n\nWhat’s the text inside it (without the subtree)\nThe number of nested <li> – all descendants, including the deeply nested ones.\n\nDemo in new window\n\nOpen a sandbox for the task.\n\nsolution\nWhat's in the nodeType?\nimportance: 5\n\nWhat does the script show?\n\n<html>\n\n<body>\n  <script>\n    alert(document.body.lastChild.nodeType);\n  </script>\n</body>\n\n</html>\nsolution\nTag in comment\nimportance: 3\n\nWhat does this code show?\n\n<script>\n  let body = document.body;\n\n  body.innerHTML = \"<!--\" + body.tagName + \"-->\";\n\n  alert( body.firstChild.data ); // what's here?\n</script>\nsolution\nWhere's the \"document\" in the hierarchy?\nimportance: 4\n\nWhich class does the document belong to?\n\nWhat’s its place in the DOM hierarchy?\n\nDoes it inherit from Node or Element, or maybe HTMLElement?\n\nsolution"
  },
  {
    "title": "Browser environment, specs",
    "url": "https://javascript.info/browser-environment",
    "html": "The JavaScript language was initially created for web browsers. Since then, it has evolved into a language with many uses and platforms.\n\nA platform may be a browser, or a web-server or another host, or even a “smart” coffee machine if it can run JavaScript. Each of these provides platform-specific functionality. The JavaScript specification calls that a host environment.\n\nA host environment provides its own objects and functions in addition to the language core. Web browsers give a means to control web pages. Node.js provides server-side features, and so on.\n\nHere’s a bird’s-eye view of what we have when JavaScript runs in a web browser:\n\nThere’s a “root” object called window. It has two roles:\n\nFirst, it is a global object for JavaScript code, as described in the chapter Global object.\nSecond, it represents the “browser window” and provides methods to control it.\n\nFor instance, we can use it as a global object:\n\n\t\nfunction sayHi() {\n  alert(\"Hello\");\n}\n\n// global functions are methods of the global object:\nwindow.sayHi();\n\nAnd we can use it as a browser window, to show the window height:\n\n\t\nalert(window.innerHeight); // inner window height\n\nThere are more window-specific methods and properties, which we’ll cover later.\n\nDOM (Document Object Model)\n\nThe Document Object Model, or DOM for short, represents all page content as objects that can be modified.\n\nThe document object is the main “entry point” to the page. We can change or create anything on the page using it.\n\nFor instance:\n\n\t\n// change the background color to red\ndocument.body.style.background = \"red\";\n\n// change it back after 1 second\nsetTimeout(() => document.body.style.background = \"\", 1000);\n\nHere, we used document.body.style, but there’s much, much more. Properties and methods are described in the specification: DOM Living Standard.\n\nDOM is not only for browsers\n\nThe DOM specification explains the structure of a document and provides objects to manipulate it. There are non-browser instruments that use DOM too.\n\nFor instance, server-side scripts that download HTML pages and process them can also use the DOM. They may support only a part of the specification though.\n\nCSSOM for styling\n\nThere’s also a separate specification, CSS Object Model (CSSOM) for CSS rules and stylesheets, that explains how they are represented as objects, and how to read and write them.\n\nThe CSSOM is used together with the DOM when we modify style rules for the document. In practice though, the CSSOM is rarely required, because we rarely need to modify CSS rules from JavaScript (usually we just add/remove CSS classes, not modify their CSS rules), but that’s also possible.\n\nBOM (Browser Object Model)\n\nThe Browser Object Model (BOM) represents additional objects provided by the browser (host environment) for working with everything except the document.\n\nFor instance:\n\nThe navigator object provides background information about the browser and the operating system. There are many properties, but the two most widely known are: navigator.userAgent – about the current browser, and navigator.platform – about the platform (can help to differentiate between Windows/Linux/Mac etc).\nThe location object allows us to read the current URL and can redirect the browser to a new one.\n\nHere’s how we can use the location object:\n\n\t\nalert(location.href); // shows current URL\nif (confirm(\"Go to Wikipedia?\")) {\n  location.href = \"https://wikipedia.org\"; // redirect the browser to another URL\n}\n\nThe functions alert/confirm/prompt are also a part of the BOM: they are not directly related to the document, but represent pure browser methods for communicating with the user.\n\nSpecifications\n\nThe BOM is a part of the general HTML specification.\n\nYes, you heard that right. The HTML spec at https://html.spec.whatwg.org is not only about the “HTML language” (tags, attributes), but also covers a bunch of objects, methods, and browser-specific DOM extensions. That’s “HTML in broad terms”. Also, some parts have additional specs listed at https://spec.whatwg.org.\n\nSummary\n\nTalking about standards, we have:\n\nDOM specification\nDescribes the document structure, manipulations, and events, see https://dom.spec.whatwg.org.\nCSSOM specification\nDescribes stylesheets and style rules, manipulations with them, and their binding to documents, see https://www.w3.org/TR/cssom-1/.\nHTML specification\nDescribes the HTML language (e.g. tags) and also the BOM (browser object model) – various browser functions: setTimeout, alert, location and so on, see https://html.spec.whatwg.org. It takes the DOM specification and extends it with many additional properties and methods.\n\nAdditionally, some classes are described separately at https://spec.whatwg.org/.\n\nPlease note these links, as there’s so much to learn that it’s impossible to cover everything and remember it all.\n\nWhen you’d like to read about a property or a method, the Mozilla manual at https://developer.mozilla.org/en-US/ is also a nice resource, but the corresponding spec may be better: it’s more complex and longer to read, but will make your fundamental knowledge sound and complete.\n\nTo find something, it’s often convenient to use an internet search “WHATWG [term]” or “MDN [term]”, e.g https://google.com?q=whatwg+localstorage, https://google.com?q=mdn+localstorage.\n\nNow, we’ll get down to learning the DOM, because the document plays the central role in the UI."
  },
  {
    "title": "Document",
    "url": "https://javascript.info/document",
    "html": "Here we’ll learn to manipulate a web-page using JavaScript.\n\nBrowser environment, specs\nDOM tree\nWalking the DOM\nSearching: getElement*, querySelector*\nNode properties: type, tag and contents\nAttributes and properties\nModifying the document\nStyles and classes\nElement size and scrolling\nWindow sizes and scrolling\nCoordinates"
  },
  {
    "title": "Unicode, String internals",
    "url": "https://javascript.info/unicode",
    "html": "Advanced knowledge\n\nThe section goes deeper into string internals. This knowledge will be useful for you if you plan to deal with emoji, rare mathematical or hieroglyphic characters, or other rare symbols.\n\nAs we already know, JavaScript strings are based on Unicode: each character is represented by a byte sequence of 1-4 bytes.\n\nJavaScript allows us to insert a character into a string by specifying its hexadecimal Unicode code with one of these three notations:\n\n\\xXX\n\nXX must be two hexadecimal digits with a value between 00 and FF, then \\xXX is the character whose Unicode code is XX.\n\nBecause the \\xXX notation supports only two hexadecimal digits, it can be used only for the first 256 Unicode characters.\n\nThese first 256 characters include the Latin alphabet, most basic syntax characters, and some others. For example, \"\\x7A\" is the same as \"z\" (Unicode U+007A).\n\n\t\nalert( \"\\x7A\" ); // z\nalert( \"\\xA9\" ); // ©, the copyright symbol\n\n\\uXXXX XXXX must be exactly 4 hex digits with the value between 0000 and FFFF, then \\uXXXX is the character whose Unicode code is XXXX.\n\nCharacters with Unicode values greater than U+FFFF can also be represented with this notation, but in this case, we will need to use a so called surrogate pair (we will talk about surrogate pairs later in this chapter).\n\n\t\nalert( \"\\u00A9\" ); // ©, the same as \\xA9, using the 4-digit hex notation\nalert( \"\\u044F\" ); // я, the Cyrillic alphabet letter\nalert( \"\\u2191\" ); // ↑, the arrow up symbol\n\n\\u{X…XXXXXX}\n\nX…XXXXXX must be a hexadecimal value of 1 to 6 bytes between 0 and 10FFFF (the highest code point defined by Unicode). This notation allows us to easily represent all existing Unicode characters.\n\n\t\nalert( \"\\u{20331}\" ); // 佫, a rare Chinese character (long Unicode)\nalert( \"\\u{1F60D}\" ); // 😍, a smiling face symbol (another long Unicode)\nSurrogate pairs\n\nAll frequently used characters have 2-byte codes (4 hex digits). Letters in most European languages, numbers, and the basic unified CJK ideographic sets (CJK – from Chinese, Japanese, and Korean writing systems), have a 2-byte representation.\n\nInitially, JavaScript was based on UTF-16 encoding that only allowed 2 bytes per character. But 2 bytes only allow 65536 combinations and that’s not enough for every possible symbol of Unicode.\n\nSo rare symbols that require more than 2 bytes are encoded with a pair of 2-byte characters called “a surrogate pair”.\n\nAs a side effect, the length of such symbols is 2:\n\n\t\nalert( '𝒳'.length ); // 2, MATHEMATICAL SCRIPT CAPITAL X\nalert( '😂'.length ); // 2, FACE WITH TEARS OF JOY\nalert( '𩷶'.length ); // 2, a rare Chinese character\n\nThat’s because surrogate pairs did not exist at the time when JavaScript was created, and thus are not correctly processed by the language!\n\nWe actually have a single symbol in each of the strings above, but the length property shows a length of 2.\n\nGetting a symbol can also be tricky, because most language features treat surrogate pairs as two characters.\n\nFor example, here we can see two odd characters in the output:\n\n\t\nalert( '𝒳'[0] ); // shows strange symbols...\nalert( '𝒳'[1] ); // ...pieces of the surrogate pair\n\nPieces of a surrogate pair have no meaning without each other. So the alerts in the example above actually display garbage.\n\nTechnically, surrogate pairs are also detectable by their codes: if a character has the code in the interval of 0xd800..0xdbff, then it is the first part of the surrogate pair. The next character (second part) must have the code in interval 0xdc00..0xdfff. These intervals are reserved exclusively for surrogate pairs by the standard.\n\nSo the methods String.fromCodePoint and str.codePointAt were added in JavaScript to deal with surrogate pairs.\n\nThey are essentially the same as String.fromCharCode and str.charCodeAt, but they treat surrogate pairs correctly.\n\nOne can see the difference here:\n\n\t\n// charCodeAt is not surrogate-pair aware, so it gives codes for the 1st part of 𝒳:\n\nalert( '𝒳'.charCodeAt(0).toString(16) ); // d835\n\n// codePointAt is surrogate-pair aware\nalert( '𝒳'.codePointAt(0).toString(16) ); // 1d4b3, reads both parts of the surrogate pair\n\nThat said, if we take from position 1 (and that’s rather incorrect here), then they both return only the 2nd part of the pair:\n\n\t\nalert( '𝒳'.charCodeAt(1).toString(16) ); // dcb3\nalert( '𝒳'.codePointAt(1).toString(16) ); // dcb3\n// meaningless 2nd half of the pair\n\nYou will find more ways to deal with surrogate pairs later in the chapter Iterables. There are probably special libraries for that too, but nothing famous enough to suggest here.\n\nTakeaway: splitting strings at an arbitrary point is dangerous\n\nWe can’t just split a string at an arbitrary position, e.g. take str.slice(0, 4) and expect it to be a valid string, e.g.:\n\n\t\nalert( 'hi 😂'.slice(0, 4) ); //  hi [?]\n\nHere we can see a garbage character (first half of the smile surrogate pair) in the output.\n\nJust be aware of it if you intend to reliably work with surrogate pairs. May not be a big problem, but at least you should understand what happens.\n\nDiacritical marks and normalization\n\nIn many languages, there are symbols that are composed of the base character with a mark above/under it.\n\nFor instance, the letter a can be the base character for these characters: àáâäãåā.\n\nMost common “composite” characters have their own code in the Unicode table. But not all of them, because there are too many possible combinations.\n\nTo support arbitrary compositions, the Unicode standard allows us to use several Unicode characters: the base character followed by one or many “mark” characters that “decorate” it.\n\nFor instance, if we have S followed by the special “dot above” character (code \\u0307), it is shown as Ṡ.\n\n\t\nalert( 'S\\u0307' ); // Ṡ\n\nIf we need an additional mark above the letter (or below it) – no problem, just add the necessary mark character.\n\nFor instance, if we append a character “dot below” (code \\u0323), then we’ll have “S with dots above and below”: Ṩ.\n\nFor example:\n\n\t\nalert( 'S\\u0307\\u0323' ); // Ṩ\n\nThis provides great flexibility, but also an interesting problem: two characters may visually look the same, but be represented with different Unicode compositions.\n\nFor instance:\n\n\t\nlet s1 = 'S\\u0307\\u0323'; // Ṩ, S + dot above + dot below\nlet s2 = 'S\\u0323\\u0307'; // Ṩ, S + dot below + dot above\n\nalert( `s1: ${s1}, s2: ${s2}` );\n\nalert( s1 == s2 ); // false though the characters look identical (?!)\n\nTo solve this, there exists a “Unicode normalization” algorithm that brings each string to the single “normal” form.\n\nIt is implemented by str.normalize().\n\n\t\nalert( \"S\\u0307\\u0323\".normalize() == \"S\\u0323\\u0307\".normalize() ); // true\n\nIt’s funny that in our situation normalize() actually brings together a sequence of 3 characters to one: \\u1e68 (S with two dots).\n\n\t\nalert( \"S\\u0307\\u0323\".normalize().length ); // 1\n\nalert( \"S\\u0307\\u0323\".normalize() == \"\\u1e68\" ); // true\n\nIn reality, this is not always the case. The reason is that the symbol Ṩ is “common enough”, so Unicode creators included it in the main table and gave it the code.\n\nIf you want to learn more about normalization rules and variants – they are described in the appendix of the Unicode standard: Unicode Normalization Forms, but for most practical purposes the information from this section is enough."
  },
  {
    "title": "BigInt",
    "url": "https://javascript.info/bigint",
    "html": "A recent addition\nThis is a recent addition to the language. You can find the current state of support at https://caniuse.com/#feat=bigint.\n\nBigInt is a special numeric type that provides support for integers of arbitrary length.\n\nA bigint is created by appending n to the end of an integer literal or by calling the function BigInt that creates bigints from strings, numbers etc.\n\nconst bigint = 1234567890123456789012345678901234567890n;\n\nconst sameBigint = BigInt(\"1234567890123456789012345678901234567890\");\n\nconst bigintFromNumber = BigInt(10); // same as 10n\nMath operators\n\nBigInt can mostly be used like a regular number, for example:\n\n\t\nalert(1n + 2n); // 3\n\nalert(5n / 2n); // 2\n\nPlease note: the division 5/2 returns the result rounded towards zero, without the decimal part. All operations on bigints return bigints.\n\nWe can’t mix bigints and regular numbers:\n\n\t\nalert(1n + 2); // Error: Cannot mix BigInt and other types\n\nWe should explicitly convert them if needed: using either BigInt() or Number(), like this:\n\n\t\nlet bigint = 1n;\nlet number = 2;\n\n// number to bigint\nalert(bigint + BigInt(number)); // 3\n\n// bigint to number\nalert(Number(bigint) + number); // 3\n\nThe conversion operations are always silent, never give errors, but if the bigint is too huge and won’t fit the number type, then extra bits will be cut off, so we should be careful doing such conversion.\n\nThe unary plus is not supported on bigints\n\nThe unary plus operator +value is a well-known way to convert value to a number.\n\nIn order to avoid confusion, it’s not supported on bigints:\n\n\t\nlet bigint = 1n;\n\nalert( +bigint ); // error\n\nSo we should use Number() to convert a bigint to a number.\n\nComparisons\n\nComparisons, such as <, > work with bigints and numbers just fine:\n\n\t\nalert( 2n > 1n ); // true\n\nalert( 2n > 1 ); // true\n\nPlease note though, as numbers and bigints belong to different types, they can be equal ==, but not strictly equal ===:\n\n\t\nalert( 1 == 1n ); // true\n\nalert( 1 === 1n ); // false\nBoolean operations\n\nWhen inside if or other boolean operations, bigints behave like numbers.\n\nFor instance, in if, bigint 0n is falsy, other values are truthy:\n\n\t\nif (0n) {\n  // never executes\n}\n\nBoolean operators, such as ||, && and others also work with bigints similar to numbers:\n\n\t\nalert( 1n || 2 ); // 1 (1n is considered truthy)\n\nalert( 0n || 2 ); // 2 (0n is considered falsy)\nPolyfills\n\nPolyfilling bigints is tricky. The reason is that many JavaScript operators, such as +, - and so on behave differently with bigints compared to regular numbers.\n\nFor example, division of bigints always returns a bigint (rounded if necessary).\n\nTo emulate such behavior, a polyfill would need to analyze the code and replace all such operators with its functions. But doing so is cumbersome and would cost a lot of performance.\n\nSo, there’s no well-known good polyfill.\n\nAlthough, the other way around is proposed by the developers of JSBI library.\n\nThis library implements big numbers using its own methods. We can use them instead of native bigints:\n\nOperation\tnative BigInt\tJSBI\nCreation from Number\ta = BigInt(789)\ta = JSBI.BigInt(789)\nAddition\tc = a + b\tc = JSBI.add(a, b)\nSubtraction\tc = a - b\tc = JSBI.subtract(a, b)\n…\t…\t…\n\n…And then use the polyfill (Babel plugin) to convert JSBI calls to native bigints for those browsers that support them.\n\nIn other words, this approach suggests that we write code in JSBI instead of native bigints. But JSBI works with numbers as with bigints internally, emulates them closely following the specification, so the code will be “bigint-ready”.\n\nWe can use such JSBI code “as is” for engines that don’t support bigints and for those that do support – the polyfill will convert the calls to native bigints.\n\nReferences\nMDN docs on BigInt.\nSpecification."
  },
  {
    "title": "Currying",
    "url": "https://javascript.info/currying-partials",
    "html": "Currying is an advanced technique of working with functions. It’s used not only in JavaScript, but in other languages as well.\n\nCurrying is a transformation of functions that translates a function from callable as f(a, b, c) into callable as f(a)(b)(c).\n\nCurrying doesn’t call a function. It just transforms it.\n\nLet’s see an example first, to better understand what we’re talking about, and then practical applications.\n\nWe’ll create a helper function curry(f) that performs currying for a two-argument f. In other words, curry(f) for two-argument f(a, b) translates it into a function that runs as f(a)(b):\n\n\t\nfunction curry(f) { // curry(f) does the currying transform\n  return function(a) {\n    return function(b) {\n      return f(a, b);\n    };\n  };\n}\n\n// usage\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1)(2) ); // 3\n\nAs you can see, the implementation is straightforward: it’s just two wrappers.\n\nThe result of curry(func) is a wrapper function(a).\nWhen it is called like curriedSum(1), the argument is saved in the Lexical Environment, and a new wrapper is returned function(b).\nThen this wrapper is called with 2 as an argument, and it passes the call to the original sum.\n\nMore advanced implementations of currying, such as _.curry from lodash library, return a wrapper that allows a function to be called both normally and partially:\n\n\t\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet curriedSum = _.curry(sum); // using _.curry from lodash library\n\nalert( curriedSum(1, 2) ); // 3, still callable normally\nalert( curriedSum(1)(2) ); // 3, called partially\nCurrying? What for?\n\nTo understand the benefits we need a worthy real-life example.\n\nFor instance, we have the logging function log(date, importance, message) that formats and outputs the information. In real projects such functions have many useful features like sending logs over the network, here we’ll just use alert:\n\nfunction log(date, importance, message) {\n  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);\n}\n\nLet’s curry it!\n\nlog = _.curry(log);\n\nAfter that log works normally:\n\nlog(new Date(), \"DEBUG\", \"some debug\"); // log(a, b, c)\n\n…But also works in the curried form:\n\nlog(new Date())(\"DEBUG\")(\"some debug\"); // log(a)(b)(c)\n\nNow we can easily make a convenience function for current logs:\n\n// logNow will be the partial of log with fixed first argument\nlet logNow = log(new Date());\n\n// use it\nlogNow(\"INFO\", \"message\"); // [HH:mm] INFO message\n\nNow logNow is log with fixed first argument, in other words “partially applied function” or “partial” for short.\n\nWe can go further and make a convenience function for current debug logs:\n\nlet debugNow = logNow(\"DEBUG\");\n\ndebugNow(\"message\"); // [HH:mm] DEBUG message\n\nSo:\n\nWe didn’t lose anything after currying: log is still callable normally.\nWe can easily generate partial functions such as for today’s logs.\nAdvanced curry implementation\n\nIn case you’d like to get in to the details, here’s the “advanced” curry implementation for multi-argument functions that we could use above.\n\nIt’s pretty short:\n\nfunction curry(func) {\n\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    } else {\n      return function(...args2) {\n        return curried.apply(this, args.concat(args2));\n      }\n    }\n  };\n\n}\n\nUsage examples:\n\nfunction sum(a, b, c) {\n  return a + b + c;\n}\n\nlet curriedSum = curry(sum);\n\nalert( curriedSum(1, 2, 3) ); // 6, still callable normally\nalert( curriedSum(1)(2,3) ); // 6, currying of 1st arg\nalert( curriedSum(1)(2)(3) ); // 6, full currying\n\nThe new curry may look complicated, but it’s actually easy to understand.\n\nThe result of curry(func) call is the wrapper curried that looks like this:\n\n// func is the function to transform\nfunction curried(...args) {\n  if (args.length >= func.length) { // (1)\n    return func.apply(this, args);\n  } else {\n    return function(...args2) { // (2)\n      return curried.apply(this, args.concat(args2));\n    }\n  }\n};\n\nWhen we run it, there are two if execution branches:\n\nIf passed args count is the same or more than the original function has in its definition (func.length) , then just pass the call to it using func.apply.\nOtherwise, get a partial: we don’t call func just yet. Instead, another wrapper is returned, that will re-apply curried providing previous arguments together with the new ones.\n\nThen, if we call it, again, we’ll get either a new partial (if not enough arguments) or, finally, the result.\n\nFixed-length functions only\n\nThe currying requires the function to have a fixed number of arguments.\n\nA function that uses rest parameters, such as f(...args), can’t be curried this way.\n\nA little more than currying\n\nBy definition, currying should convert sum(a, b, c) into sum(a)(b)(c).\n\nBut most implementations of currying in JavaScript are advanced, as described: they also keep the function callable in the multi-argument variant.\n\nSummary\n\nCurrying is a transform that makes f(a,b,c) callable as f(a)(b)(c). JavaScript implementations usually both keep the function callable normally and return the partial if the arguments count is not enough.\n\nCurrying allows us to easily get partials. As we’ve seen in the logging example, after currying the three argument universal function log(date, importance, message) gives us partials when called with one argument (like log(date)) or two arguments (like log(date, importance))."
  },
  {
    "title": "Reference Type",
    "url": "https://javascript.info/reference-type",
    "html": "In-depth language feature\n\nThis article covers an advanced topic, to understand certain edge-cases better.\n\nIt’s not important. Many experienced developers live fine without knowing it. Read on if you want to know how things work under the hood.\n\nA dynamically evaluated method call can lose this.\n\nFor instance:\n\n\t\nlet user = {\n  name: \"John\",\n  hi() { alert(this.name); },\n  bye() { alert(\"Bye\"); }\n};\n\nuser.hi(); // works\n\n// now let's call user.hi or user.bye depending on the name\n(user.name == \"John\" ? user.hi : user.bye)(); // Error!\n\nOn the last line there is a conditional operator that chooses either user.hi or user.bye. In this case the result is user.hi.\n\nThen the method is immediately called with parentheses (). But it doesn’t work correctly!\n\nAs you can see, the call results in an error, because the value of \"this\" inside the call becomes undefined.\n\nThis works (object dot method):\n\nuser.hi();\n\nThis doesn’t (evaluated method):\n\n(user.name == \"John\" ? user.hi : user.bye)(); // Error!\n\nWhy? If we want to understand why it happens, let’s get under the hood of how obj.method() call works.\n\nReference type explained\n\nLooking closely, we may notice two operations in obj.method() statement:\n\nFirst, the dot '.' retrieves the property obj.method.\nThen parentheses () execute it.\n\nSo, how does the information about this get passed from the first part to the second one?\n\nIf we put these operations on separate lines, then this will be lost for sure:\n\n\t\nlet user = {\n  name: \"John\",\n  hi() { alert(this.name); }\n};\n\n// split getting and calling the method in two lines\nlet hi = user.hi;\nhi(); // Error, because this is undefined\n\nHere hi = user.hi puts the function into the variable, and then on the last line it is completely standalone, and so there’s no this.\n\nTo make user.hi() calls work, JavaScript uses a trick – the dot '.' returns not a function, but a value of the special Reference Type.\n\nThe Reference Type is a “specification type”. We can’t explicitly use it, but it is used internally by the language.\n\nThe value of Reference Type is a three-value combination (base, name, strict), where:\n\nbase is the object.\nname is the property name.\nstrict is true if use strict is in effect.\n\nThe result of a property access user.hi is not a function, but a value of Reference Type. For user.hi in strict mode it is:\n\n// Reference Type value\n(user, \"hi\", true)\n\nWhen parentheses () are called on the Reference Type, they receive the full information about the object and its method, and can set the right this (user in this case).\n\nReference type is a special “intermediary” internal type, with the purpose to pass information from dot . to calling parentheses ().\n\nAny other operation like assignment hi = user.hi discards the reference type as a whole, takes the value of user.hi (a function) and passes it on. So any further operation “loses” this.\n\nSo, as the result, the value of this is only passed the right way if the function is called directly using a dot obj.method() or square brackets obj['method']() syntax (they do the same here). There are various ways to solve this problem such as func.bind().\n\nSummary\n\nReference Type is an internal type of the language.\n\nReading a property, such as with dot . in obj.method() returns not exactly the property value, but a special “reference type” value that stores both the property value and the object it was taken from.\n\nThat’s for the subsequent method call () to get the object and set this to it.\n\nFor all other operations, the reference type automatically becomes the property value (a function in our case).\n\nThe whole mechanics is hidden from our eyes. It only matters in subtle cases, such as when a method is obtained dynamically from the object, using an expression.\n\nTasks\nSyntax check\nimportance: 2\n\nWhat is the result of this code?\n\nlet user = {\n  name: \"John\",\n  go: function() { alert(this.name) }\n}\n\n(user.go)()\n\nP.S. There’s a pitfall :)\n\nsolution\nExplain the value of \"this\"\nimportance: 3\n\nIn the code below we intend to call obj.go() method 4 times in a row.\n\nBut calls (1) and (2) works differently from (3) and (4). Why?\n\n\t\nlet obj, method;\n\nobj = {\n  go: function() { alert(this); }\n};\n\nobj.go();               // (1) [object Object]\n\n(obj.go)();             // (2) [object Object]\n\n(method = obj.go)();    // (3) undefined\n\n(obj.go || obj.stop)(); // (4) undefined\nsolution"
  },
  {
    "title": "Eval: run a code string",
    "url": "https://javascript.info/eval",
    "html": "The built-in eval function allows to execute a string of code.\n\nThe syntax is:\n\nlet result = eval(code);\n\nFor example:\n\n\t\nlet code = 'alert(\"Hello\")';\neval(code); // Hello\n\nA string of code may be long, contain line breaks, function declarations, variables and so on.\n\nThe result of eval is the result of the last statement.\n\nFor example:\n\n\t\nlet value = eval('1+1');\nalert(value); // 2\n\t\nlet value = eval('let i = 0; ++i');\nalert(value); // 1\n\nThe eval’ed code is executed in the current lexical environment, so it can see outer variables:\n\n\t\nlet a = 1;\n\nfunction f() {\n  let a = 2;\n\n  eval('alert(a)'); // 2\n}\n\nf();\n\nIt can change outer variables as well:\n\n\t\nlet x = 5;\neval(\"x = 10\");\nalert(x); // 10, value modified\n\nIn strict mode, eval has its own lexical environment. So functions and variables, declared inside eval, are not visible outside:\n\n\t\n// reminder: 'use strict' is enabled in runnable examples by default\n\neval(\"let x = 5; function f() {}\");\n\nalert(typeof x); // undefined (no such variable)\n// function f is also not visible\n\nWithout use strict, eval doesn’t have its own lexical environment, so we would see x and f outside.\n\nUsing “eval”\n\nIn modern programming eval is used very sparingly. It’s often said that “eval is evil”.\n\nThe reason is simple: long, long time ago JavaScript was a much weaker language, many things could only be done with eval. But that time passed a decade ago.\n\nRight now, there’s almost no reason to use eval. If someone is using it, there’s a good chance they can replace it with a modern language construct or a JavaScript Module.\n\nPlease note that its ability to access outer variables has side-effects.\n\nCode minifiers (tools used before JS gets to production, to compress it) rename local variables into shorter ones (like a, b etc) to make the code smaller. That’s usually safe, but not if eval is used, as local variables may be accessed from eval’ed code string. So minifiers don’t do that renaming for all variables potentially visible from eval. That negatively affects code compression ratio.\n\nUsing outer local variables inside eval is also considered a bad programming practice, as it makes maintaining the code more difficult.\n\nThere are two ways how to be totally safe from such problems.\n\nIf eval’ed code doesn’t use outer variables, please call eval as window.eval(...):\n\nThis way the code is executed in the global scope:\n\n\t\nlet x = 1;\n{\n  let x = 5;\n  window.eval('alert(x)'); // 1 (global variable)\n}\n\nIf eval’ed code needs local variables, change eval to new Function and pass them as arguments:\n\n\t\nlet f = new Function('a', 'alert(a)');\n\nf(5); // 5\n\nThe new Function construct is explained in the chapter The \"new Function\" syntax. It creates a function from a string, also in the global scope. So it can’t see local variables. But it’s so much clearer to pass them explicitly as arguments, like in the example above.\n\nSummary\n\nA call to eval(code) runs the string of code and returns the result of the last statement.\n\nRarely used in modern JavaScript, as there’s usually no need.\nCan access outer local variables. That’s considered bad practice.\nInstead, to eval the code in the global scope, use window.eval(code).\nOr, if your code needs some data from the outer scope, use new Function and pass it as arguments.\nTasks\nEval-calculator\nimportance: 4\n\nCreate a calculator that prompts for an arithmetic expression and returns its result.\n\nThere’s no need to check the expression for correctness in this task. Just evaluate and return the result.\n\nRun the demo\n\nsolution"
  },
  {
    "title": "Proxy and Reflect",
    "url": "https://javascript.info/proxy",
    "html": "A Proxy object wraps another object and intercepts operations, like reading/writing properties and others, optionally handling them on its own, or transparently allowing the object to handle them.\n\nProxies are used in many libraries and some browser frameworks. We’ll see many practical applications in this article.\n\nProxy\n\nThe syntax:\n\nlet proxy = new Proxy(target, handler)\ntarget – is an object to wrap, can be anything, including functions.\nhandler – proxy configuration: an object with “traps”, methods that intercept operations. – e.g. get trap for reading a property of target, set trap for writing a property into target, and so on.\n\nFor operations on proxy, if there’s a corresponding trap in handler, then it runs, and the proxy has a chance to handle it, otherwise the operation is performed on target.\n\nAs a starting example, let’s create a proxy without any traps:\n\n\t\nlet target = {};\nlet proxy = new Proxy(target, {}); // empty handler\n\nproxy.test = 5; // writing to proxy (1)\nalert(target.test); // 5, the property appeared in target!\n\nalert(proxy.test); // 5, we can read it from proxy too (2)\n\nfor(let key in proxy) alert(key); // test, iteration works (3)\n\nAs there are no traps, all operations on proxy are forwarded to target.\n\nA writing operation proxy.test= sets the value on target.\nA reading operation proxy.test returns the value from target.\nIteration over proxy returns values from target.\n\nAs we can see, without any traps, proxy is a transparent wrapper around target.\n\nProxy is a special “exotic object”. It doesn’t have own properties. With an empty handler it transparently forwards operations to target.\n\nTo activate more capabilities, let’s add traps.\n\nWhat can we intercept with them?\n\nFor most operations on objects, there’s a so-called “internal method” in the JavaScript specification that describes how it works at the lowest level. For instance [[Get]], the internal method to read a property, [[Set]], the internal method to write a property, and so on. These methods are only used in the specification, we can’t call them directly by name.\n\nProxy traps intercept invocations of these methods. They are listed in the Proxy specification and in the table below.\n\nFor every internal method, there’s a trap in this table: the name of the method that we can add to the handler parameter of new Proxy to intercept the operation:\n\nInternal Method\tHandler Method\tTriggers when…\n[[Get]]\tget\treading a property\n[[Set]]\tset\twriting to a property\n[[HasProperty]]\thas\tin operator\n[[Delete]]\tdeleteProperty\tdelete operator\n[[Call]]\tapply\tfunction call\n[[Construct]]\tconstruct\tnew operator\n[[GetPrototypeOf]]\tgetPrototypeOf\tObject.getPrototypeOf\n[[SetPrototypeOf]]\tsetPrototypeOf\tObject.setPrototypeOf\n[[IsExtensible]]\tisExtensible\tObject.isExtensible\n[[PreventExtensions]]\tpreventExtensions\tObject.preventExtensions\n[[DefineOwnProperty]]\tdefineProperty\tObject.defineProperty, Object.defineProperties\n[[GetOwnProperty]]\tgetOwnPropertyDescriptor\tObject.getOwnPropertyDescriptor, for..in, Object.keys/values/entries\n[[OwnPropertyKeys]]\townKeys\tObject.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries\nInvariants\n\nJavaScript enforces some invariants – conditions that must be fulfilled by internal methods and traps.\n\nMost of them are for return values:\n\n[[Set]] must return true if the value was written successfully, otherwise false.\n[[Delete]] must return true if the value was deleted successfully, otherwise false.\n…and so on, we’ll see more in examples below.\n\nThere are some other invariants, like:\n\n[[GetPrototypeOf]], applied to the proxy object must return the same value as [[GetPrototypeOf]] applied to the proxy object’s target object. In other words, reading prototype of a proxy must always return the prototype of the target object.\n\nTraps can intercept these operations, but they must follow these rules.\n\nInvariants ensure correct and consistent behavior of language features. The full invariants list is in the specification. You probably won’t violate them if you’re not doing something weird.\n\nLet’s see how that works in practical examples.\n\nDefault value with “get” trap\n\nThe most common traps are for reading/writing properties.\n\nTo intercept reading, the handler should have a method get(target, property, receiver).\n\nIt triggers when a property is read, with following arguments:\n\ntarget – is the target object, the one passed as the first argument to new Proxy,\nproperty – property name,\nreceiver – if the target property is a getter, then receiver is the object that’s going to be used as this in its call. Usually that’s the proxy object itself (or an object that inherits from it, if we inherit from proxy). Right now we don’t need this argument, so it will be explained in more detail later.\n\nLet’s use get to implement default values for an object.\n\nWe’ll make a numeric array that returns 0 for nonexistent values.\n\nUsually when one tries to get a non-existing array item, they get undefined, but we’ll wrap a regular array into the proxy that traps reading and returns 0 if there’s no such property:\n\n\t\nlet numbers = [0, 1, 2];\n\nnumbers = new Proxy(numbers, {\n  get(target, prop) {\n    if (prop in target) {\n      return target[prop];\n    } else {\n      return 0; // default value\n    }\n  }\n});\n\nalert( numbers[1] ); // 1\nalert( numbers[123] ); // 0 (no such item)\n\nAs we can see, it’s quite easy to do with a get trap.\n\nWe can use Proxy to implement any logic for “default” values.\n\nImagine we have a dictionary, with phrases and their translations:\n\n\t\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\nalert( dictionary['Hello'] ); // Hola\nalert( dictionary['Welcome'] ); // undefined\n\nRight now, if there’s no phrase, reading from dictionary returns undefined. But in practice, leaving a phrase untranslated is usually better than undefined. So let’s make it return an untranslated phrase in that case instead of undefined.\n\nTo achieve that, we’ll wrap dictionary in a proxy that intercepts reading operations:\n\n\t\nlet dictionary = {\n  'Hello': 'Hola',\n  'Bye': 'Adiós'\n};\n\ndictionary = new Proxy(dictionary, {\n  get(target, phrase) { // intercept reading a property from dictionary\n    if (phrase in target) { // if we have it in the dictionary\n      return target[phrase]; // return the translation\n    } else {\n      // otherwise, return the non-translated phrase\n      return phrase;\n    }\n  }\n});\n\n// Look up arbitrary phrases in the dictionary!\n// At worst, they're not translated.\nalert( dictionary['Hello'] ); // Hola\nalert( dictionary['Welcome to Proxy']); // Welcome to Proxy (no translation)\nPlease note:\n\nPlease note how the proxy overwrites the variable:\n\ndictionary = new Proxy(dictionary, ...);\n\nThe proxy should totally replace the target object everywhere. No one should ever reference the target object after it got proxied. Otherwise it’s easy to mess up.\n\nValidation with “set” trap\n\nLet’s say we want an array exclusively for numbers. If a value of another type is added, there should be an error.\n\nThe set trap triggers when a property is written.\n\nset(target, property, value, receiver):\n\ntarget – is the target object, the one passed as the first argument to new Proxy,\nproperty – property name,\nvalue – property value,\nreceiver – similar to get trap, matters only for setter properties.\n\nThe set trap should return true if setting is successful, and false otherwise (triggers TypeError).\n\nLet’s use it to validate new values:\n\n\t\nlet numbers = [];\n\nnumbers = new Proxy(numbers, { // (*)\n  set(target, prop, val) { // to intercept property writing\n    if (typeof val == 'number') {\n      target[prop] = val;\n      return true;\n    } else {\n      return false;\n    }\n  }\n});\n\nnumbers.push(1); // added successfully\nnumbers.push(2); // added successfully\nalert(\"Length is: \" + numbers.length); // 2\n\nnumbers.push(\"test\"); // TypeError ('set' on proxy returned false)\n\nalert(\"This line is never reached (error in the line above)\");\n\nPlease note: the built-in functionality of arrays is still working! Values are added by push. The length property auto-increases when values are added. Our proxy doesn’t break anything.\n\nWe don’t have to override value-adding array methods like push and unshift, and so on, to add checks in there, because internally they use the [[Set]] operation that’s intercepted by the proxy.\n\nSo the code is clean and concise.\n\nDon’t forget to return true\n\nAs said above, there are invariants to be held.\n\nFor set, it must return true for a successful write.\n\nIf we forget to do it or return any falsy value, the operation triggers TypeError.\n\nIteration with “ownKeys” and “getOwnPropertyDescriptor”\n\nObject.keys, for..in loop and most other methods that iterate over object properties use [[OwnPropertyKeys]] internal method (intercepted by ownKeys trap) to get a list of properties.\n\nSuch methods differ in details:\n\nObject.getOwnPropertyNames(obj) returns non-symbol keys.\nObject.getOwnPropertySymbols(obj) returns symbol keys.\nObject.keys/values() returns non-symbol keys/values with enumerable flag (property flags were explained in the article Property flags and descriptors).\nfor..in loops over non-symbol keys with enumerable flag, and also prototype keys.\n\n…But all of them start with that list.\n\nIn the example below we use ownKeys trap to make for..in loop over user, and also Object.keys and Object.values, to skip properties starting with an underscore _:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30,\n  _password: \"***\"\n};\n\nuser = new Proxy(user, {\n  ownKeys(target) {\n    return Object.keys(target).filter(key => !key.startsWith('_'));\n  }\n});\n\n// \"ownKeys\" filters out _password\nfor(let key in user) alert(key); // name, then: age\n\n// same effect on these methods:\nalert( Object.keys(user) ); // name,age\nalert( Object.values(user) ); // John,30\n\nSo far, it works.\n\nAlthough, if we return a key that doesn’t exist in the object, Object.keys won’t list it:\n\n\t\nlet user = { };\n\nuser = new Proxy(user, {\n  ownKeys(target) {\n    return ['a', 'b', 'c'];\n  }\n});\n\nalert( Object.keys(user) ); // <empty>\n\nWhy? The reason is simple: Object.keys returns only properties with the enumerable flag. To check for it, it calls the internal method [[GetOwnProperty]] for every property to get its descriptor. And here, as there’s no property, its descriptor is empty, no enumerable flag, so it’s skipped.\n\nFor Object.keys to return a property, we need it to either exist in the object, with the enumerable flag, or we can intercept calls to [[GetOwnProperty]] (the trap getOwnPropertyDescriptor does it), and return a descriptor with enumerable: true.\n\nHere’s an example of that:\n\n\t\nlet user = { };\n\nuser = new Proxy(user, {\n  ownKeys(target) { // called once to get a list of properties\n    return ['a', 'b', 'c'];\n  },\n\n  getOwnPropertyDescriptor(target, prop) { // called for every property\n    return {\n      enumerable: true,\n      configurable: true\n      /* ...other flags, probable \"value:...\" */\n    };\n  }\n\n});\n\nalert( Object.keys(user) ); // a, b, c\n\nLet’s note once again: we only need to intercept [[GetOwnProperty]] if the property is absent in the object.\n\nProtected properties with “deleteProperty” and other traps\n\nThere’s a widespread convention that properties and methods prefixed by an underscore _ are internal. They shouldn’t be accessed from outside the object.\n\nTechnically that’s possible though:\n\n\t\nlet user = {\n  name: \"John\",\n  _password: \"secret\"\n};\n\nalert(user._password); // secret\n\nLet’s use proxies to prevent any access to properties starting with _.\n\nWe’ll need the traps:\n\nget to throw an error when reading such property,\nset to throw an error when writing,\ndeleteProperty to throw an error when deleting,\nownKeys to exclude properties starting with _ from for..in and methods like Object.keys.\n\nHere’s the code:\n\n\t\nlet user = {\n  name: \"John\",\n  _password: \"***\"\n};\n\nuser = new Proxy(user, {\n  get(target, prop) {\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    }\n    let value = target[prop];\n    return (typeof value === 'function') ? value.bind(target) : value; // (*)\n  },\n  set(target, prop, val) { // to intercept property writing\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      target[prop] = val;\n      return true;\n    }\n  },\n  deleteProperty(target, prop) { // to intercept property deletion\n    if (prop.startsWith('_')) {\n      throw new Error(\"Access denied\");\n    } else {\n      delete target[prop];\n      return true;\n    }\n  },\n  ownKeys(target) { // to intercept property list\n    return Object.keys(target).filter(key => !key.startsWith('_'));\n  }\n});\n\n// \"get\" doesn't allow to read _password\ntry {\n  alert(user._password); // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"set\" doesn't allow to write _password\ntry {\n  user._password = \"test\"; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"deleteProperty\" doesn't allow to delete _password\ntry {\n  delete user._password; // Error: Access denied\n} catch(e) { alert(e.message); }\n\n// \"ownKeys\" filters out _password\nfor(let key in user) alert(key); // name\n\nPlease note the important detail in the get trap, in the line (*):\n\nget(target, prop) {\n  // ...\n  let value = target[prop];\n  return (typeof value === 'function') ? value.bind(target) : value; // (*)\n}\n\nWhy do we need a function to call value.bind(target)?\n\nThe reason is that object methods, such as user.checkPassword(), must be able to access _password:\n\nuser = {\n  // ...\n  checkPassword(value) {\n    // object method must be able to read _password\n    return value === this._password;\n  }\n}\n\nA call to user.checkPassword() gets proxied user as this (the object before dot becomes this), so when it tries to access this._password, the get trap activates (it triggers on any property read) and throws an error.\n\nSo we bind the context of object methods to the original object, target, in the line (*). Then their future calls will use target as this, without any traps.\n\nThat solution usually works, but isn’t ideal, as a method may pass the unproxied object somewhere else, and then we’ll get messed up: where’s the original object, and where’s the proxied one?\n\nBesides, an object may be proxied multiple times (multiple proxies may add different “tweaks” to the object), and if we pass an unwrapped object to a method, there may be unexpected consequences.\n\nSo, such a proxy shouldn’t be used everywhere.\n\nPrivate properties of a class\n\nModern JavaScript engines natively support private properties in classes, prefixed with #. They are described in the article Private and protected properties and methods. No proxies required.\n\nSuch properties have their own issues though. In particular, they are not inherited.\n\n“In range” with “has” trap\n\nLet’s see more examples.\n\nWe have a range object:\n\nlet range = {\n  start: 1,\n  end: 10\n};\n\nWe’d like to use the in operator to check that a number is in range.\n\nThe has trap intercepts in calls.\n\nhas(target, property)\n\ntarget – is the target object, passed as the first argument to new Proxy,\nproperty – property name\n\nHere’s the demo:\n\n\t\nlet range = {\n  start: 1,\n  end: 10\n};\n\nrange = new Proxy(range, {\n  has(target, prop) {\n    return prop >= target.start && prop <= target.end;\n  }\n});\n\nalert(5 in range); // true\nalert(50 in range); // false\n\nNice syntactic sugar, isn’t it? And very simple to implement.\n\nWrapping functions: \"apply\"\n\nWe can wrap a proxy around a function as well.\n\nThe apply(target, thisArg, args) trap handles calling a proxy as function:\n\ntarget is the target object (function is an object in JavaScript),\nthisArg is the value of this.\nargs is a list of arguments.\n\nFor example, let’s recall delay(f, ms) decorator, that we did in the article Decorators and forwarding, call/apply.\n\nIn that article we did it without proxies. A call to delay(f, ms) returned a function that forwards all calls to f after ms milliseconds.\n\nHere’s the previous, function-based implementation:\n\n\t\nfunction delay(f, ms) {\n  // return a wrapper that passes the call to f after the timeout\n  return function() { // (*)\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// after this wrapping, calls to sayHi will be delayed for 3 seconds\nsayHi = delay(sayHi, 3000);\n\nsayHi(\"John\"); // Hello, John! (after 3 seconds)\n\nAs we’ve seen already, that mostly works. The wrapper function (*) performs the call after the timeout.\n\nBut a wrapper function does not forward property read/write operations or anything else. After the wrapping, the access is lost to properties of the original functions, such as name, length and others:\n\n\t\nfunction delay(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nalert(sayHi.length); // 1 (function length is the arguments count in its declaration)\n\nsayHi = delay(sayHi, 3000);\n\nalert(sayHi.length); // 0 (in the wrapper declaration, there are zero arguments)\n\nProxy is much more powerful, as it forwards everything to the target object.\n\nLet’s use Proxy instead of a wrapping function:\n\n\t\nfunction delay(f, ms) {\n  return new Proxy(f, {\n    apply(target, thisArg, args) {\n      setTimeout(() => target.apply(thisArg, args), ms);\n    }\n  });\n}\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nsayHi = delay(sayHi, 3000);\n\nalert(sayHi.length); // 1 (*) proxy forwards \"get length\" operation to the target\n\nsayHi(\"John\"); // Hello, John! (after 3 seconds)\n\nThe result is the same, but now not only calls, but all operations on the proxy are forwarded to the original function. So sayHi.length is returned correctly after the wrapping in the line (*).\n\nWe’ve got a “richer” wrapper.\n\nOther traps exist: the full list is in the beginning of this article. Their usage pattern is similar to the above.\n\nReflect\n\nReflect is a built-in object that simplifies creation of Proxy.\n\nIt was said previously that internal methods, such as [[Get]], [[Set]] and others are specification-only, they can’t be called directly.\n\nThe Reflect object makes that somewhat possible. Its methods are minimal wrappers around the internal methods.\n\nHere are examples of operations and Reflect calls that do the same:\n\nOperation\tReflect call\tInternal method\nobj[prop]\tReflect.get(obj, prop)\t[[Get]]\nobj[prop] = value\tReflect.set(obj, prop, value)\t[[Set]]\ndelete obj[prop]\tReflect.deleteProperty(obj, prop)\t[[Delete]]\nnew F(value)\tReflect.construct(F, value)\t[[Construct]]\n…\t…\t…\n\nFor example:\n\n\t\nlet user = {};\n\nReflect.set(user, 'name', 'John');\n\nalert(user.name); // John\n\nIn particular, Reflect allows us to call operators (new, delete…) as functions (Reflect.construct, Reflect.deleteProperty, …). That’s an interesting capability, but here another thing is important.\n\nFor every internal method, trappable by Proxy, there’s a corresponding method in Reflect, with the same name and arguments as the Proxy trap.\n\nSo we can use Reflect to forward an operation to the original object.\n\nIn this example, both traps get and set transparently (as if they didn’t exist) forward reading/writing operations to the object, showing a message:\n\n\t\nlet user = {\n  name: \"John\",\n};\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    alert(`GET ${prop}`);\n    return Reflect.get(target, prop, receiver); // (1)\n  },\n  set(target, prop, val, receiver) {\n    alert(`SET ${prop}=${val}`);\n    return Reflect.set(target, prop, val, receiver); // (2)\n  }\n});\n\nlet name = user.name; // shows \"GET name\"\nuser.name = \"Pete\"; // shows \"SET name=Pete\"\n\nHere:\n\nReflect.get reads an object property.\nReflect.set writes an object property and returns true if successful, false otherwise.\n\nThat is, everything’s simple: if a trap wants to forward the call to the object, it’s enough to call Reflect.<method> with the same arguments.\n\nIn most cases we can do the same without Reflect, for instance, reading a property Reflect.get(target, prop, receiver) can be replaced by target[prop]. There are important nuances though.\n\nProxying a getter\n\nLet’s see an example that demonstrates why Reflect.get is better. And we’ll also see why get/set have the third argument receiver, that we didn’t use before.\n\nWe have an object user with _name property and a getter for it.\n\nHere’s a proxy around it:\n\n\t\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop];\n  }\n});\n\nalert(userProxy.name); // Guest\n\nThe get trap is “transparent” here, it returns the original property, and doesn’t do anything else. That’s enough for our example.\n\nEverything seems to be all right. But let’s make the example a little bit more complex.\n\nAfter inheriting another object admin from user, we can observe the incorrect behavior:\n\n\t\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    return target[prop]; // (*) target = user\n  }\n});\n\nlet admin = {\n  __proto__: userProxy,\n  _name: \"Admin\"\n};\n\n// Expected: Admin\nalert(admin.name); // outputs: Guest (?!?)\n\nReading admin.name should return \"Admin\", not \"Guest\"!\n\nWhat’s the matter? Maybe we did something wrong with the inheritance?\n\nBut if we remove the proxy, then everything will work as expected.\n\nThe problem is actually in the proxy, in the line (*).\n\nWhen we read admin.name, as admin object doesn’t have such own property, the search goes to its prototype.\n\nThe prototype is userProxy.\n\nWhen reading name property from the proxy, its get trap triggers and returns it from the original object as target[prop] in the line (*).\n\nA call to target[prop], when prop is a getter, runs its code in the context this=target. So the result is this._name from the original object target, that is: from user.\n\nTo fix such situations, we need receiver, the third argument of get trap. It keeps the correct this to be passed to a getter. In our case that’s admin.\n\nHow to pass the context for a getter? For a regular function we could use call/apply, but that’s a getter, it’s not “called”, just accessed.\n\nReflect.get can do that. Everything will work right if we use it.\n\nHere’s the corrected variant:\n\n\t\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) { // receiver = admin\n    return Reflect.get(target, prop, receiver); // (*)\n  }\n});\n\n\nlet admin = {\n  __proto__: userProxy,\n  _name: \"Admin\"\n};\n\nalert(admin.name); // Admin\n\nNow receiver that keeps a reference to the correct this (that is admin), is passed to the getter using Reflect.get in the line (*).\n\nWe can rewrite the trap even shorter:\n\nget(target, prop, receiver) {\n  return Reflect.get(...arguments);\n}\n\nReflect calls are named exactly the same way as traps and accept the same arguments. They were specifically designed this way.\n\nSo, return Reflect... provides a safe no-brainer to forward the operation and make sure we don’t forget anything related to that.\n\nProxy limitations\n\nProxies provide a unique way to alter or tweak the behavior of the existing objects at the lowest level. Still, it’s not perfect. There are limitations.\n\nBuilt-in objects: Internal slots\n\nMany built-in objects, for example Map, Set, Date, Promise and others make use of so-called “internal slots”.\n\nThese are like properties, but reserved for internal, specification-only purposes. For instance, Map stores items in the internal slot [[MapData]]. Built-in methods access them directly, not via [[Get]]/[[Set]] internal methods. So Proxy can’t intercept that.\n\nWhy care? They’re internal anyway!\n\nWell, here’s the issue. After a built-in object like that gets proxied, the proxy doesn’t have these internal slots, so built-in methods will fail.\n\nFor example:\n\n\t\nlet map = new Map();\n\nlet proxy = new Proxy(map, {});\n\nproxy.set('test', 1); // Error\n\nInternally, a Map stores all data in its [[MapData]] internal slot. The proxy doesn’t have such a slot. The built-in method Map.prototype.set method tries to access the internal property this.[[MapData]], but because this=proxy, can’t find it in proxy and just fails.\n\nFortunately, there’s a way to fix it:\n\n\t\nlet map = new Map();\n\nlet proxy = new Proxy(map, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n    return typeof value == 'function' ? value.bind(target) : value;\n  }\n});\n\nproxy.set('test', 1);\nalert(proxy.get('test')); // 1 (works!)\n\nNow it works fine, because get trap binds function properties, such as map.set, to the target object (map) itself.\n\nUnlike the previous example, the value of this inside proxy.set(...) will be not proxy, but the original map. So when the internal implementation of set tries to access this.[[MapData]] internal slot, it succeeds.\n\nArray has no internal slots\n\nA notable exception: built-in Array doesn’t use internal slots. That’s for historical reasons, as it appeared so long ago.\n\nSo there’s no such problem when proxying an array.\n\nPrivate fields\n\nA similar thing happens with private class fields.\n\nFor example, getName() method accesses the private #name property and breaks after proxying:\n\n\t\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {});\n\nalert(user.getName()); // Error\n\nThe reason is that private fields are implemented using internal slots. JavaScript does not use [[Get]]/[[Set]] when accessing them.\n\nIn the call getName() the value of this is the proxied user, and it doesn’t have the slot with private fields.\n\nOnce again, the solution with binding the method makes it work:\n\n\t\nclass User {\n  #name = \"Guest\";\n\n  getName() {\n    return this.#name;\n  }\n}\n\nlet user = new User();\n\nuser = new Proxy(user, {\n  get(target, prop, receiver) {\n    let value = Reflect.get(...arguments);\n    return typeof value == 'function' ? value.bind(target) : value;\n  }\n});\n\nalert(user.getName()); // Guest\n\nThat said, the solution has drawbacks, as explained previously: it exposes the original object to the method, potentially allowing it to be passed further and breaking other proxied functionality.\n\nProxy != target\n\nThe proxy and the original object are different objects. That’s natural, right?\n\nSo if we use the original object as a key, and then proxy it, then the proxy can’t be found:\n\n\t\nlet allUsers = new Set();\n\nclass User {\n  constructor(name) {\n    this.name = name;\n    allUsers.add(this);\n  }\n}\n\nlet user = new User(\"John\");\n\nalert(allUsers.has(user)); // true\n\nuser = new Proxy(user, {});\n\nalert(allUsers.has(user)); // false\n\nAs we can see, after proxying we can’t find user in the set allUsers, because the proxy is a different object.\n\nProxies can’t intercept a strict equality test ===\n\nProxies can intercept many operators, such as new (with construct), in (with has), delete (with deleteProperty) and so on.\n\nBut there’s no way to intercept a strict equality test for objects. An object is strictly equal to itself only, and no other value.\n\nSo all operations and built-in classes that compare objects for equality will differentiate between the object and the proxy. No transparent replacement here.\n\nRevocable proxies\n\nA revocable proxy is a proxy that can be disabled.\n\nLet’s say we have a resource, and would like to close access to it any moment.\n\nWhat we can do is to wrap it into a revocable proxy, without any traps. Such a proxy will forward operations to object, and we can disable it at any moment.\n\nThe syntax is:\n\nlet {proxy, revoke} = Proxy.revocable(target, handler)\n\nThe call returns an object with the proxy and revoke function to disable it.\n\nHere’s an example:\n\n\t\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\n// pass the proxy somewhere instead of object...\nalert(proxy.data); // Valuable data\n\n// later in our code\nrevoke();\n\n// the proxy isn't working any more (revoked)\nalert(proxy.data); // Error\n\nA call to revoke() removes all internal references to the target object from the proxy, so they are no longer connected.\n\nInitially, revoke is separate from proxy, so that we can pass proxy around while leaving revoke in the current scope.\n\nWe can also bind revoke method to proxy by setting proxy.revoke = revoke.\n\nAnother option is to create a WeakMap that has proxy as the key and the corresponding revoke as the value, that allows to easily find revoke for a proxy:\n\n\t\nlet revokes = new WeakMap();\n\nlet object = {\n  data: \"Valuable data\"\n};\n\nlet {proxy, revoke} = Proxy.revocable(object, {});\n\nrevokes.set(proxy, revoke);\n\n// ..somewhere else in our code..\nrevoke = revokes.get(proxy);\nrevoke();\n\nalert(proxy.data); // Error (revoked)\n\nWe use WeakMap instead of Map here because it won’t block garbage collection. If a proxy object becomes “unreachable” (e.g. no variable references it any more), WeakMap allows it to be wiped from memory together with its revoke that we won’t need any more.\n\nReferences\nSpecification: Proxy.\nMDN: Proxy.\nSummary\n\nProxy is a wrapper around an object, that forwards operations on it to the object, optionally trapping some of them.\n\nIt can wrap any kind of object, including classes and functions.\n\nThe syntax is:\n\nlet proxy = new Proxy(target, {\n  /* traps */\n});\n\n…Then we should use proxy everywhere instead of target. A proxy doesn’t have its own properties or methods. It traps an operation if the trap is provided, otherwise forwards it to target object.\n\nWe can trap:\n\nReading (get), writing (set), deleting (deleteProperty) a property (even a non-existing one).\nCalling a function (apply trap).\nThe new operator (construct trap).\nMany other operations (the full list is at the beginning of the article and in the docs).\n\nThat allows us to create “virtual” properties and methods, implement default values, observable objects, function decorators and so much more.\n\nWe can also wrap an object multiple times in different proxies, decorating it with various aspects of functionality.\n\nThe Reflect API is designed to complement Proxy. For any Proxy trap, there’s a Reflect call with same arguments. We should use those to forward calls to target objects.\n\nProxies have some limitations:\n\nBuilt-in objects have “internal slots”, access to those can’t be proxied. See the workaround above.\nThe same holds true for private class fields, as they are internally implemented using slots. So proxied method calls must have the target object as this to access them.\nObject equality tests === can’t be intercepted.\nPerformance: benchmarks depend on an engine, but generally accessing a property using a simplest proxy takes a few times longer. In practice that only matters for some “bottleneck” objects though.\nTasks\nError on reading non-existent property\n\nUsually, an attempt to read a non-existent property returns undefined.\n\nCreate a proxy that throws an error for an attempt to read of a non-existent property instead.\n\nThat can help to detect programming mistakes early.\n\nWrite a function wrap(target) that takes an object target and return a proxy that adds this functionality aspect.\n\nThat’s how it should work:\n\nlet user = {\n  name: \"John\"\n};\n\nfunction wrap(target) {\n  return new Proxy(target, {\n      /* your code */\n  });\n}\n\nuser = wrap(user);\n\nalert(user.name); // John\nalert(user.age); // ReferenceError: Property doesn't exist: \"age\"\nsolution\nAccessing array[-1]\n\nIn some programming languages, we can access array elements using negative indexes, counted from the end.\n\nLike this:\n\nlet array = [1, 2, 3];\n\narray[-1]; // 3, the last element\narray[-2]; // 2, one step from the end\narray[-3]; // 1, two steps from the end\n\nIn other words, array[-N] is the same as array[array.length - N].\n\nCreate a proxy to implement that behavior.\n\nThat’s how it should work:\n\nlet array = [1, 2, 3];\n\narray = new Proxy(array, {\n  /* your code */\n});\n\nalert( array[-1] ); // 3\nalert( array[-2] ); // 2\n\n// Other array functionality should be kept \"as is\"\nsolution\nObservable\n\nCreate a function makeObservable(target) that “makes the object observable” by returning a proxy.\n\nHere’s how it should work:\n\n\t\nfunction makeObservable(target) {\n  /* your code */\n}\n\nlet user = {};\nuser = makeObservable(user);\n\nuser.observe((key, value) => {\n  alert(`SET ${key}=${value}`);\n});\n\nuser.name = \"John\"; // alerts: SET name=John\n\nIn other words, an object returned by makeObservable is just like the original one, but also has the method observe(handler) that sets handler function to be called on any property change.\n\nWhenever a property changes, handler(key, value) is called with the name and value of the property.\n\nP.S. In this task, please only take care about writing to a property. Other operations can be implemented in a similar way.\n\nsolution"
  },
  {
    "title": "Dynamic imports",
    "url": "https://javascript.info/modules-dynamic-imports",
    "html": "Export and import statements that we covered in previous chapters are called “static”. The syntax is very simple and strict.\n\nFirst, we can’t dynamically generate any parameters of import.\n\nThe module path must be a primitive string, can’t be a function call. This won’t work:\n\nimport ... from getModuleName(); // Error, only from \"string\" is allowed\n\nSecond, we can’t import conditionally or at run-time:\n\nif(...) {\n  import ...; // Error, not allowed!\n}\n\n{\n  import ...; // Error, we can't put import in any block\n}\n\nThat’s because import/export aim to provide a backbone for the code structure. That’s a good thing, as code structure can be analyzed, modules can be gathered and bundled into one file by special tools, unused exports can be removed (“tree-shaken”). That’s possible only because the structure of imports/exports is simple and fixed.\n\nBut how can we import a module dynamically, on-demand?\n\nThe import() expression\n\nThe import(module) expression loads the module and returns a promise that resolves into a module object that contains all its exports. It can be called from any place in the code.\n\nWe can use it dynamically in any place of the code, for instance:\n\nlet modulePath = prompt(\"Which module to load?\");\n\nimport(modulePath)\n  .then(obj => <module object>)\n  .catch(err => <loading error, e.g. if no such module>)\n\nOr, we could use let module = await import(modulePath) if inside an async function.\n\nFor instance, if we have the following module say.js:\n\n// 📁 say.js\nexport function hi() {\n  alert(`Hello`);\n}\n\nexport function bye() {\n  alert(`Bye`);\n}\n\n…Then dynamic import can be like this:\n\nlet {hi, bye} = await import('./say.js');\n\nhi();\nbye();\n\nOr, if say.js has the default export:\n\n// 📁 say.js\nexport default function() {\n  alert(\"Module loaded (export default)!\");\n}\n\n…Then, in order to access it, we can use default property of the module object:\n\nlet obj = await import('./say.js');\nlet say = obj.default;\n// or, in one line: let {default: say} = await import('./say.js');\n\nsay();\n\nHere’s the full example:\n\nResultsay.jsindex.html\n\t\n<!doctype html>\n<script>\n  async function load() {\n    let say = await import('./say.js');\n    say.hi(); // Hello!\n    say.bye(); // Bye!\n    say.default(); // Module loaded (export default)!\n  }\n</script>\n<button onclick=\"load()\">Click me</button>\nPlease note:\n\nDynamic imports work in regular scripts, they don’t require script type=\"module\".\n\nPlease note:\n\nAlthough import() looks like a function call, it’s a special syntax that just happens to use parentheses (similar to super()).\n\nSo we can’t copy import to a variable or use call/apply with it. It’s not a function."
  },
  {
    "title": "Miscellaneous",
    "url": "https://javascript.info/js-misc",
    "html": "Proxy and Reflect\nEval: run a code string\nCurrying\nReference Type\nBigInt\nUnicode, String internals\nWeakRef and FinalizationRegistry"
  },
  {
    "title": "Async iteration and generators",
    "url": "https://javascript.info/async-iterators-generators",
    "html": "Asynchronous iteration allow us to iterate over data that comes asynchronously, on-demand. Like, for instance, when we download something chunk-by-chunk over a network. And asynchronous generators make it even more convenient.\n\nLet’s see a simple example first, to grasp the syntax, and then review a real-life use case.\n\nRecall iterables\n\nLet’s recall the topic about iterables.\n\nThe idea is that we have an object, such as range here:\n\nlet range = {\n  from: 1,\n  to: 5\n};\n\n…And we’d like to use for..of loop on it, such as for(value of range), to get values from 1 to 5.\n\nIn other words, we want to add an iteration ability to the object.\n\nThat can be implemented using a special method with the name Symbol.iterator:\n\nThis method is called in by the for..of construct when the loop is started, and it should return an object with the next method.\nFor each iteration, the next() method is invoked for the next value.\nThe next() should return a value in the form {done: true/false, value:<loop value>}, where done:true means the end of the loop.\n\nHere’s an implementation for the iterable range:\n\n\t\nlet range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.iterator]() { // called once, in the beginning of for..of\n    return {\n      current: this.from,\n      last: this.to,\n\n      next() { // called every iteration, to get the next value\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1 then 2, then 3, then 4, then 5\n}\n\nIf anything is unclear, please visit the chapter Iterables, it gives all the details about regular iterables.\n\nAsync iterables\n\nAsynchronous iteration is needed when values come asynchronously: after setTimeout or another kind of delay.\n\nThe most common case is that the object needs to make a network request to deliver the next value, we’ll see a real-life example of it a bit later.\n\nTo make an object iterable asynchronously:\n\nUse Symbol.asyncIterator instead of Symbol.iterator.\nThe next() method should return a promise (to be fulfilled with the next value).\nThe async keyword handles it, we can simply make async next().\nTo iterate over such an object, we should use a for await (let item of iterable) loop.\nNote the await word.\n\nAs a starting example, let’s make an iterable range object, similar like the one before, but now it will return values asynchronously, one per second.\n\nAll we need to do is to perform a few replacements in the code above:\n\n\t\nlet range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.asyncIterator]() { // (1)\n    return {\n      current: this.from,\n      last: this.to,\n\n      async next() { // (2)\n\n        // note: we can use \"await\" inside the async next:\n        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)\n\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n(async () => {\n\n  for await (let value of range) { // (4)\n    alert(value); // 1,2,3,4,5\n  }\n\n})()\n\nAs we can see, the structure is similar to regular iterators:\n\nTo make an object asynchronously iterable, it must have a method Symbol.asyncIterator (1).\nThis method must return the object with next() method returning a promise (2).\nThe next() method doesn’t have to be async, it may be a regular method returning a promise, but async allows us to use await, so that’s convenient. Here we just delay for a second (3).\nTo iterate, we use for await(let value of range) (4), namely add “await” after “for”. It calls range[Symbol.asyncIterator]() once, and then its next() for values.\n\nHere’s a small table with the differences:\n\n\tIterators\tAsync iterators\nObject method to provide iterator\tSymbol.iterator\tSymbol.asyncIterator\nnext() return value is\tany value\tPromise\nto loop, use\tfor..of\tfor await..of\nThe spread syntax ... doesn’t work asynchronously\n\nFeatures that require regular, synchronous iterators, don’t work with asynchronous ones.\n\nFor instance, a spread syntax won’t work:\n\nalert( [...range] ); // Error, no Symbol.iterator\n\nThat’s natural, as it expects to find Symbol.iterator, not Symbol.asyncIterator.\n\nIt’s also the case for for..of: the syntax without await needs Symbol.iterator.\n\nRecall generators\n\nNow let’s recall generators, as they allow to make iteration code much shorter. Most of the time, when we’d like to make an iterable, we’ll use generators.\n\nFor sheer simplicity, omitting some important stuff, they are “functions that generate (yield) values”. They are explained in detail in the chapter Generators.\n\nGenerators are labelled with function* (note the star) and use yield to generate a value, then we can use for..of to loop over them.\n\nThis example generates a sequence of values from start to end:\n\n\t\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nfor(let value of generateSequence(1, 5)) {\n  alert(value); // 1, then 2, then 3, then 4, then 5\n}\n\nAs we already know, to make an object iterable, we should add Symbol.iterator to it.\n\nlet range = {\n  from: 1,\n  to: 5,\n  [Symbol.iterator]() {\n    return <object with next to make range iterable>\n  }\n}\n\nA common practice for Symbol.iterator is to return a generator, it makes the code shorter, as you can see:\n\n\t\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // a shorthand for [Symbol.iterator]: function*()\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nfor(let value of range) {\n  alert(value); // 1, then 2, then 3, then 4, then 5\n}\n\nPlease see the chapter Generators if you’d like more details.\n\nIn regular generators we can’t use await. All values must come synchronously, as required by the for..of construct.\n\nWhat if we’d like to generate values asynchronously? From network requests, for instance.\n\nLet’s switch to asynchronous generators to make it possible.\n\nAsync generators (finally)\n\nFor most practical applications, when we’d like to make an object that asynchronously generates a sequence of values, we can use an asynchronous generator.\n\nThe syntax is simple: prepend function* with async. That makes the generator asynchronous.\n\nAnd then use for await (...) to iterate over it, like this:\n\n\t\nasync function* generateSequence(start, end) {\n\n  for (let i = start; i <= end; i++) {\n\n    // Wow, can use await!\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    yield i;\n  }\n\n}\n\n(async () => {\n\n  let generator = generateSequence(1, 5);\n  for await (let value of generator) {\n    alert(value); // 1, then 2, then 3, then 4, then 5 (with delay between)\n  }\n\n})();\n\nAs the generator is asynchronous, we can use await inside it, rely on promises, perform network requests and so on.\n\nUnder-the-hood difference\n\nTechnically, if you’re an advanced reader who remembers the details about generators, there’s an internal difference.\n\nFor async generators, the generator.next() method is asynchronous, it returns promises.\n\nIn a regular generator we’d use result = generator.next() to get values. In an async generator, we should add await, like this:\n\nresult = await generator.next(); // result = {value: ..., done: true/false}\n\nThat’s why async generators work with for await...of.\n\nAsync iterable range\n\nRegular generators can be used as Symbol.iterator to make the iteration code shorter.\n\nSimilar to that, async generators can be used as Symbol.asyncIterator to implement the asynchronous iteration.\n\nFor instance, we can make the range object generate values asynchronously, once per second, by replacing synchronous Symbol.iterator with asynchronous Symbol.asyncIterator:\n\n\t\nlet range = {\n  from: 1,\n  to: 5,\n\n  // this line is same as [Symbol.asyncIterator]: async function*() {\n  async *[Symbol.asyncIterator]() {\n    for(let value = this.from; value <= this.to; value++) {\n\n      // make a pause between values, wait for something\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      yield value;\n    }\n  }\n};\n\n(async () => {\n\n  for await (let value of range) {\n    alert(value); // 1, then 2, then 3, then 4, then 5\n  }\n\n})();\n\nNow values come with a delay of 1 second between them.\n\nPlease note:\n\nTechnically, we can add both Symbol.iterator and Symbol.asyncIterator to the object, so it’s both synchronously (for..of) and asynchronously (for await..of) iterable.\n\nIn practice though, that would be a weird thing to do.\n\nReal-life example: paginated data\n\nSo far we’ve seen basic examples, to gain understanding. Now let’s review a real-life use case.\n\nThere are many online services that deliver paginated data. For instance, when we need a list of users, a request returns a pre-defined count (e.g. 100 users) – “one page”, and provides a URL to the next page.\n\nThis pattern is very common. It’s not about users, but just about anything.\n\nFor instance, GitHub allows us to retrieve commits in the same, paginated fashion:\n\nWe should make a request to fetch in the form https://api.github.com/repos/<repo>/commits.\nIt responds with a JSON of 30 commits, and also provides a link to the next page in the Link header.\nThen we can use that link for the next request, to get more commits, and so on.\n\nFor our code, we’d like to have a simpler way to get commits.\n\nLet’s make a function fetchCommits(repo) that gets commits for us, making requests whenever needed. And let it care about all pagination stuff. For us it’ll be a simple async iteration for await..of.\n\nSo the usage will be like this:\n\nfor await (let commit of fetchCommits(\"username/repository\")) {\n  // process commit\n}\n\nHere’s such function, implemented as async generator:\n\nasync function* fetchCommits(repo) {\n  let url = `https://api.github.com/repos/${repo}/commits`;\n\n  while (url) {\n    const response = await fetch(url, { // (1)\n      headers: {'User-Agent': 'Our script'}, // github needs any user-agent header\n    });\n\n    const body = await response.json(); // (2) response is JSON (array of commits)\n\n    // (3) the URL of the next page is in the headers, extract it\n    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel=\"next\"/);\n    nextPage = nextPage?.[1];\n\n    url = nextPage;\n\n    for(let commit of body) { // (4) yield commits one by one, until the page ends\n      yield commit;\n    }\n  }\n}\n\nMore explanations about how it works:\n\nWe use the browser fetch method to download the commits.\n\nThe initial URL is https://api.github.com/repos/<repo>/commits, and the next page will be in the Link header of the response.\nThe fetch method allows us to supply authorization and other headers if needed – here GitHub requires User-Agent.\n\nThe commits are returned in JSON format.\n\nWe should get the next page URL from the Link header of the response. It has a special format, so we use a regular expression for that (we will learn this feature in Regular expressions).\n\nThe next page URL may look like https://api.github.com/repositories/93253246/commits?page=2. It’s generated by GitHub itself.\n\nThen we yield the received commits one by one, and when they finish, the next while(url) iteration will trigger, making one more request.\n\nAn example of use (shows commit authors in console):\n\n\t\n(async () => {\n\n  let count = 0;\n\n  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {\n\n    console.log(commit.author.login);\n\n    if (++count == 100) { // let's stop at 100 commits\n      break;\n    }\n  }\n\n})();\n\n// Note: If you are running this in an external sandbox, you'll need to paste here the function fetchCommits described above\n\nThat’s just what we wanted.\n\nThe internal mechanics of paginated requests is invisible from the outside. For us it’s just an async generator that returns commits.\n\nSummary\n\nRegular iterators and generators work fine with the data that doesn’t take time to generate.\n\nWhen we expect the data to come asynchronously, with delays, their async counterparts can be used, and for await..of instead of for..of.\n\nSyntax differences between async and regular iterators:\n\n\tIterable\tAsync Iterable\nMethod to provide iterator\tSymbol.iterator\tSymbol.asyncIterator\nnext() return value is\t{value:…, done: true/false}\tPromise that resolves to {value:…, done: true/false}\n\nSyntax differences between async and regular generators:\n\n\tGenerators\tAsync generators\nDeclaration\tfunction*\tasync function*\nnext() return value is\t{value:…, done: true/false}\tPromise that resolves to {value:…, done: true/false}\n\nIn web-development we often meet streams of data, when it flows chunk-by-chunk. For instance, downloading or uploading a big file.\n\nWe can use async generators to process such data. It’s also noteworthy that in some environments, like in browsers, there’s also another API called Streams, that provides special interfaces to work with such streams, to transform the data and to pass it from one stream to another (e.g. download from one place and immediately send elsewhere)."
  },
  {
    "title": "Generators",
    "url": "https://javascript.info/generators",
    "html": "Regular functions return only one, single value (or nothing).\n\nGenerators can return (“yield”) multiple values, one after another, on-demand. They work great with iterables, allowing to create data streams with ease.\n\nGenerator functions\n\nTo create a generator, we need a special syntax construct: function*, so-called “generator function”.\n\nIt looks like this:\n\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nGenerator functions behave differently from regular ones. When such function is called, it doesn’t run its code. Instead it returns a special object, called “generator object”, to manage the execution.\n\nHere, take a look:\n\n\t\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\n// \"generator function\" creates \"generator object\"\nlet generator = generateSequence();\nalert(generator); // [object Generator]\n\nThe function code execution hasn’t started yet:\n\nThe main method of a generator is next(). When called, it runs the execution until the nearest yield <value> statement (value can be omitted, then it’s undefined). Then the function execution pauses, and the yielded value is returned to the outer code.\n\nThe result of next() is always an object with two properties:\n\nvalue: the yielded value.\ndone: true if the function code has finished, otherwise false.\n\nFor instance, here we create the generator and get its first yielded value:\n\n\t\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\nlet one = generator.next();\n\nalert(JSON.stringify(one)); // {value: 1, done: false}\n\nAs of now, we got the first value only, and the function execution is on the second line:\n\nLet’s call generator.next() again. It resumes the code execution and returns the next yield:\n\nlet two = generator.next();\n\nalert(JSON.stringify(two)); // {value: 2, done: false}\n\nAnd, if we call it a third time, the execution reaches the return statement that finishes the function:\n\nlet three = generator.next();\n\nalert(JSON.stringify(three)); // {value: 3, done: true}\n\nNow the generator is done. We should see it from done:true and process value:3 as the final result.\n\nNew calls to generator.next() don’t make sense any more. If we do them, they return the same object: {done: true}.\n\nfunction* f(…) or function *f(…)?\n\nBoth syntaxes are correct.\n\nBut usually the first syntax is preferred, as the star * denotes that it’s a generator function, it describes the kind, not the name, so it should stick with the function keyword.\n\nGenerators are iterable\n\nAs you probably already guessed looking at the next() method, generators are iterable.\n\nWe can loop over their values using for..of:\n\n\t\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  return 3;\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, then 2\n}\n\nLooks a lot nicer than calling .next().value, right?\n\n…But please note: the example above shows 1, then 2, and that’s all. It doesn’t show 3!\n\nIt’s because for..of iteration ignores the last value, when done: true. So, if we want all results to be shown by for..of, we must return them with yield:\n\n\t\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nlet generator = generateSequence();\n\nfor(let value of generator) {\n  alert(value); // 1, then 2, then 3\n}\n\nAs generators are iterable, we can call all related functionality, e.g. the spread syntax ...:\n\n\t\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nlet sequence = [0, ...generateSequence()];\n\nalert(sequence); // 0, 1, 2, 3\n\nIn the code above, ...generateSequence() turns the iterable generator object into an array of items (read more about the spread syntax in the chapter Rest parameters and spread syntax)\n\nUsing generators for iterables\n\nSome time ago, in the chapter Iterables we created an iterable range object that returns values from..to.\n\nHere, let’s remember the code:\n\n\t\nlet range = {\n  from: 1,\n  to: 5,\n\n  // for..of range calls this method once in the very beginning\n  [Symbol.iterator]() {\n    // ...it returns the iterator object:\n    // onward, for..of works only with that object, asking it for next values\n    return {\n      current: this.from,\n      last: this.to,\n\n      // next() is called on each iteration by the for..of loop\n      next() {\n        // it should return the value as an object {done:.., value :...}\n        if (this.current <= this.last) {\n          return { done: false, value: this.current++ };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  }\n};\n\n// iteration over range returns numbers from range.from to range.to\nalert([...range]); // 1,2,3,4,5\n\nWe can use a generator function for iteration by providing it as Symbol.iterator.\n\nHere’s the same range, but much more compact:\n\n\t\nlet range = {\n  from: 1,\n  to: 5,\n\n  *[Symbol.iterator]() { // a shorthand for [Symbol.iterator]: function*()\n    for(let value = this.from; value <= this.to; value++) {\n      yield value;\n    }\n  }\n};\n\nalert( [...range] ); // 1,2,3,4,5\n\nThat works, because range[Symbol.iterator]() now returns a generator, and generator methods are exactly what for..of expects:\n\nit has a .next() method\nthat returns values in the form {value: ..., done: true/false}\n\nThat’s not a coincidence, of course. Generators were added to JavaScript language with iterators in mind, to implement them easily.\n\nThe variant with a generator is much more concise than the original iterable code of range, and keeps the same functionality.\n\nGenerators may generate values forever\n\nIn the examples above we generated finite sequences, but we can also make a generator that yields values forever. For instance, an unending sequence of pseudo-random numbers.\n\nThat surely would require a break (or return) in for..of over such generator. Otherwise, the loop would repeat forever and hang.\n\nGenerator composition\n\nGenerator composition is a special feature of generators that allows to transparently “embed” generators in each other.\n\nFor instance, we have a function that generates a sequence of numbers:\n\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nNow we’d like to reuse it to generate a more complex sequence:\n\nfirst, digits 0..9 (with character codes 48…57),\nfollowed by uppercase alphabet letters A..Z (character codes 65…90)\nfollowed by lowercase alphabet letters a..z (character codes 97…122)\n\nWe can use this sequence e.g. to create passwords by selecting characters from it (could add syntax characters as well), but let’s generate it first.\n\nIn a regular function, to combine results from multiple other functions, we call them, store the results, and then join at the end.\n\nFor generators, there’s a special yield* syntax to “embed” (compose) one generator into another.\n\nThe composed generator:\n\n\t\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generatePasswordCodes() {\n\n  // 0..9\n  yield* generateSequence(48, 57);\n\n  // A..Z\n  yield* generateSequence(65, 90);\n\n  // a..z\n  yield* generateSequence(97, 122);\n\n}\n\nlet str = '';\n\nfor(let code of generatePasswordCodes()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n\nThe yield* directive delegates the execution to another generator. This term means that yield* gen iterates over the generator gen and transparently forwards its yields outside. As if the values were yielded by the outer generator.\n\nThe result is the same as if we inlined the code from nested generators:\n\n\t\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) yield i;\n}\n\nfunction* generateAlphaNum() {\n\n  // yield* generateSequence(48, 57);\n  for (let i = 48; i <= 57; i++) yield i;\n\n  // yield* generateSequence(65, 90);\n  for (let i = 65; i <= 90; i++) yield i;\n\n  // yield* generateSequence(97, 122);\n  for (let i = 97; i <= 122; i++) yield i;\n\n}\n\nlet str = '';\n\nfor(let code of generateAlphaNum()) {\n  str += String.fromCharCode(code);\n}\n\nalert(str); // 0..9A..Za..z\n\nA generator composition is a natural way to insert a flow of one generator into another. It doesn’t use extra memory to store intermediate results.\n\n“yield” is a two-way street\n\nUntil this moment, generators were similar to iterable objects, with a special syntax to generate values. But in fact they are much more powerful and flexible.\n\nThat’s because yield is a two-way street: it not only returns the result to the outside, but also can pass the value inside the generator.\n\nTo do so, we should call generator.next(arg), with an argument. That argument becomes the result of yield.\n\nLet’s see an example:\n\n\t\nfunction* gen() {\n  // Pass a question to the outer code and wait for an answer\n  let result = yield \"2 + 2 = ?\"; // (*)\n\n  alert(result);\n}\n\nlet generator = gen();\n\nlet question = generator.next().value; // <-- yield returns the value\n\ngenerator.next(4); // --> pass the result into the generator\nThe first call generator.next() should be always made without an argument (the argument is ignored if passed). It starts the execution and returns the result of the first yield \"2+2=?\". At this point the generator pauses the execution, while staying on the line (*).\nThen, as shown at the picture above, the result of yield gets into the question variable in the calling code.\nOn generator.next(4), the generator resumes, and 4 gets in as the result: let result = 4.\n\nPlease note, the outer code does not have to immediately call next(4). It may take time. That’s not a problem: the generator will wait.\n\nFor instance:\n\n// resume the generator after some time\nsetTimeout(() => generator.next(4), 1000);\n\nAs we can see, unlike regular functions, a generator and the calling code can exchange results by passing values in next/yield.\n\nTo make things more obvious, here’s another example, with more calls:\n\n\t\nfunction* gen() {\n  let ask1 = yield \"2 + 2 = ?\";\n\n  alert(ask1); // 4\n\n  let ask2 = yield \"3 * 3 = ?\"\n\n  alert(ask2); // 9\n}\n\nlet generator = gen();\n\nalert( generator.next().value ); // \"2 + 2 = ?\"\n\nalert( generator.next(4).value ); // \"3 * 3 = ?\"\n\nalert( generator.next(9).done ); // true\n\nThe execution picture:\n\nThe first .next() starts the execution… It reaches the first yield.\nThe result is returned to the outer code.\nThe second .next(4) passes 4 back to the generator as the result of the first yield, and resumes the execution.\n…It reaches the second yield, that becomes the result of the generator call.\nThe third next(9) passes 9 into the generator as the result of the second yield and resumes the execution that reaches the end of the function, so done: true.\n\nIt’s like a “ping-pong” game. Each next(value) (excluding the first one) passes a value into the generator, that becomes the result of the current yield, and then gets back the result of the next yield.\n\ngenerator.throw\n\nAs we observed in the examples above, the outer code may pass a value into the generator, as the result of yield.\n\n…But it can also initiate (throw) an error there. That’s natural, as an error is a kind of result.\n\nTo pass an error into a yield, we should call generator.throw(err). In that case, the err is thrown in the line with that yield.\n\nFor instance, here the yield of \"2 + 2 = ?\" leads to an error:\n\n\t\nfunction* gen() {\n  try {\n    let result = yield \"2 + 2 = ?\"; // (1)\n\n    alert(\"The execution does not reach here, because the exception is thrown above\");\n  } catch(e) {\n    alert(e); // shows the error\n  }\n}\n\nlet generator = gen();\n\nlet question = generator.next().value;\n\ngenerator.throw(new Error(\"The answer is not found in my database\")); // (2)\n\nThe error, thrown into the generator at line (2) leads to an exception in line (1) with yield. In the example above, try..catch catches it and shows it.\n\nIf we don’t catch it, then just like any exception, it “falls out” the generator into the calling code.\n\nThe current line of the calling code is the line with generator.throw, labelled as (2). So we can catch it here, like this:\n\n\t\nfunction* generate() {\n  let result = yield \"2 + 2 = ?\"; // Error in this line\n}\n\nlet generator = generate();\n\nlet question = generator.next().value;\n\ntry {\n  generator.throw(new Error(\"The answer is not found in my database\"));\n} catch(e) {\n  alert(e); // shows the error\n}\n\nIf we don’t catch the error there, then, as usual, it falls through to the outer calling code (if any) and, if uncaught, kills the script.\n\ngenerator.return\n\ngenerator.return(value) finishes the generator execution and return the given value.\n\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nconst g = gen();\n\ng.next();        // { value: 1, done: false }\ng.return('foo'); // { value: \"foo\", done: true }\ng.next();        // { value: undefined, done: true }\n\nIf we again use generator.return() in a completed generator, it will return that value again (MDN).\n\nOften we don’t use it, as most of time we want to get all returning values, but it can be useful when we want to stop generator in a specific condition.\n\nSummary\nGenerators are created by generator functions function* f(…) {…}.\nInside generators (only) there exists a yield operator.\nThe outer code and the generator may exchange results via next/yield calls.\n\nIn modern JavaScript, generators are rarely used. But sometimes they come in handy, because the ability of a function to exchange data with the calling code during the execution is quite unique. And, surely, they are great for making iterable objects.\n\nAlso, in the next chapter we’ll learn async generators, which are used to read streams of asynchronously generated data (e.g paginated fetches over a network) in for await ... of loops.\n\nIn web-programming we often work with streamed data, so that’s another very important use case.\n\nTasks\nPseudo-random generator\n\nThere are many areas where we need random data.\n\nOne of them is testing. We may need random data: text, numbers, etc. to test things out well.\n\nIn JavaScript, we could use Math.random(). But if something goes wrong, we’d like to be able to repeat the test, using exactly the same data.\n\nFor that, so called “seeded pseudo-random generators” are used. They take a “seed”, the first value, and then generate the next ones using a formula so that the same seed yields the same sequence, and hence the whole flow is easily reproducible. We only need to remember the seed to repeat it.\n\nAn example of such formula, that generates somewhat uniformly distributed values:\n\nnext = previous * 16807 % 2147483647\n\nIf we use 1 as the seed, the values will be:\n\n16807\n282475249\n1622650073\n…and so on…\n\nThe task is to create a generator function pseudoRandom(seed) that takes seed and creates the generator with this formula.\n\nUsage example:\n\nlet generator = pseudoRandom(1);\n\nalert(generator.next().value); // 16807\nalert(generator.next().value); // 282475249\nalert(generator.next().value); // 1622650073\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Generators, advanced iteration",
    "url": "https://javascript.info/generators-iterators",
    "html": "Generators\nAsync iteration and generators"
  },
  {
    "title": "Async/await",
    "url": "https://javascript.info/async-await",
    "html": "There’s a special syntax to work with promises in a more comfortable fashion, called “async/await”. It’s surprisingly easy to understand and use.\n\nAsync functions\n\nLet’s start with the async keyword. It can be placed before a function, like this:\n\nasync function f() {\n  return 1;\n}\n\nThe word “async” before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically.\n\nFor instance, this function returns a resolved promise with the result of 1; let’s test it:\n\n\t\nasync function f() {\n  return 1;\n}\n\nf().then(alert); // 1\n\n…We could explicitly return a promise, which would be the same:\n\n\t\nasync function f() {\n  return Promise.resolve(1);\n}\n\nf().then(alert); // 1\n\nSo, async ensures that the function returns a promise, and wraps non-promises in it. Simple enough, right? But not only that. There’s another keyword, await, that works only inside async functions, and it’s pretty cool.\n\nAwait\n\nThe syntax:\n\n// works only inside async functions\nlet value = await promise;\n\nThe keyword await makes JavaScript wait until that promise settles and returns its result.\n\nHere’s an example with a promise that resolves in 1 second:\n\n\t\nasync function f() {\n\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve(\"done!\"), 1000)\n  });\n\n  let result = await promise; // wait until the promise resolves (*)\n\n  alert(result); // \"done!\"\n}\n\nf();\n\nThe function execution “pauses” at the line (*) and resumes when the promise settles, with result becoming its result. So the code above shows “done!” in one second.\n\nLet’s emphasize: await literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.\n\nIt’s just a more elegant syntax of getting the promise result than promise.then. And, it’s easier to read and write.\n\nCan’t use await in regular functions\n\nIf we try to use await in a non-async function, there would be a syntax error:\n\n\t\nfunction f() {\n  let promise = Promise.resolve(1);\n  let result = await promise; // Syntax error\n}\n\nWe may get this error if we forget to put async before a function. As stated earlier, await only works inside an async function.\n\nLet’s take the showAvatar() example from the chapter Promises chaining and rewrite it using async/await:\n\nWe’ll need to replace .then calls with await.\nAlso we should make the function async for them to work.\n\t\nasync function showAvatar() {\n\n  // read our JSON\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n\n  // read github user\n  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);\n  let githubUser = await githubResponse.json();\n\n  // show the avatar\n  let img = document.createElement('img');\n  img.src = githubUser.avatar_url;\n  img.className = \"promise-avatar-example\";\n  document.body.append(img);\n\n  // wait 3 seconds\n  await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n\n  img.remove();\n\n  return githubUser;\n}\n\nshowAvatar();\n\nPretty clean and easy to read, right? Much better than before.\n\nModern browsers allow top-level await in modules\n\nIn modern browsers, await on top level works just fine, when we’re inside a module. We’ll cover modules in article Modules, introduction.\n\nFor instance:\n\n\t\n// we assume this code runs at top level, inside a module\nlet response = await fetch('/article/promise-chaining/user.json');\nlet user = await response.json();\n\nconsole.log(user);\n\nIf we’re not using modules, or older browsers must be supported, there’s a universal recipe: wrapping into an anonymous async function.\n\nLike this:\n\n(async () => {\n  let response = await fetch('/article/promise-chaining/user.json');\n  let user = await response.json();\n  ...\n})();\nawait accepts “thenables”\n\nLike promise.then, await allows us to use thenable objects (those with a callable then method). The idea is that a third-party object may not be a promise, but promise-compatible: if it supports .then, that’s enough to use it with await.\n\nHere’s a demo Thenable class; the await below accepts its instances:\n\n\t\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve);\n    // resolve with this.num*2 after 1000ms\n    setTimeout(() => resolve(this.num * 2), 1000); // (*)\n  }\n}\n\nasync function f() {\n  // waits for 1 second, then result becomes 2\n  let result = await new Thenable(1);\n  alert(result);\n}\n\nf();\n\nIf await gets a non-promise object with .then, it calls that method providing the built-in functions resolve and reject as arguments (just as it does for a regular Promise executor). Then await waits until one of them is called (in the example above it happens in the line (*)) and then proceeds with the result.\n\nAsync class methods\n\nTo declare an async class method, just prepend it with async:\n\n\t\nclass Waiter {\n  async wait() {\n    return await Promise.resolve(1);\n  }\n}\n\nnew Waiter()\n  .wait()\n  .then(alert); // 1 (this is the same as (result => alert(result)))\n\nThe meaning is the same: it ensures that the returned value is a promise and enables await.\n\nError handling\n\nIf a promise resolves normally, then await promise returns the result. But in the case of a rejection, it throws the error, just as if there were a throw statement at that line.\n\nThis code:\n\nasync function f() {\n  await Promise.reject(new Error(\"Whoops!\"));\n}\n\n…is the same as this:\n\nasync function f() {\n  throw new Error(\"Whoops!\");\n}\n\nIn real situations, the promise may take some time before it rejects. In that case there will be a delay before await throws an error.\n\nWe can catch that error using try..catch, the same way as a regular throw:\n\n\t\nasync function f() {\n\n  try {\n    let response = await fetch('http://no-such-url');\n  } catch(err) {\n    alert(err); // TypeError: failed to fetch\n  }\n}\n\nf();\n\nIn the case of an error, the control jumps to the catch block. We can also wrap multiple lines:\n\n\t\nasync function f() {\n\n  try {\n    let response = await fetch('/no-user-here');\n    let user = await response.json();\n  } catch(err) {\n    // catches errors both in fetch and response.json\n    alert(err);\n  }\n}\n\nf();\n\nIf we don’t have try..catch, then the promise generated by the call of the async function f() becomes rejected. We can append .catch to handle it:\n\n\t\nasync function f() {\n  let response = await fetch('http://no-such-url');\n}\n\n// f() becomes a rejected promise\nf().catch(alert); // TypeError: failed to fetch // (*)\n\nIf we forget to add .catch there, then we get an unhandled promise error (viewable in the console). We can catch such errors using a global unhandledrejection event handler as described in the chapter Error handling with promises.\n\nasync/await and promise.then/catch\n\nWhen we use async/await, we rarely need .then, because await handles the waiting for us. And we can use a regular try..catch instead of .catch. That’s usually (but not always) more convenient.\n\nBut at the top level of the code, when we’re outside any async function, we’re syntactically unable to use await, so it’s a normal practice to add .then/catch to handle the final result or falling-through error, like in the line (*) of the example above.\n\nasync/await works well with Promise.all\n\nWhen we need to wait for multiple promises, we can wrap them in Promise.all and then await:\n\n// wait for the array of results\nlet results = await Promise.all([\n  fetch(url1),\n  fetch(url2),\n  ...\n]);\n\nIn the case of an error, it propagates as usual, from the failed promise to Promise.all, and then becomes an exception that we can catch using try..catch around the call.\n\nSummary\n\nThe async keyword before a function has two effects:\n\nMakes it always return a promise.\nAllows await to be used in it.\n\nThe await keyword before a promise makes JavaScript wait until that promise settles, and then:\n\nIf it’s an error, an exception is generated — same as if throw error were called at that very place.\nOtherwise, it returns the result.\n\nTogether they provide a great framework to write asynchronous code that is easy to both read and write.\n\nWith async/await we rarely need to write promise.then/catch, but we still shouldn’t forget that they are based on promises, because sometimes (e.g. in the outermost scope) we have to use these methods. Also Promise.all is nice when we are waiting for many tasks simultaneously.\n\nTasks\nRewrite using async/await\n\nRewrite this example code from the chapter Promises chaining using async/await instead of .then/catch:\n\n\t\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new Error(response.status);\n      }\n    });\n}\n\nloadJson('https://javascript.info/no-such-user.json')\n  .catch(alert); // Error: 404\nsolution\nRewrite \"rethrow\" with async/await\n\nBelow you can find the “rethrow” example. Rewrite it using async/await instead of .then/catch.\n\nAnd get rid of the recursion in favour of a loop in demoGithubUser: with async/await that becomes easy to do.\n\n\t\nclass HttpError extends Error {\n  constructor(response) {\n    super(`${response.status} for ${response.url}`);\n    this.name = 'HttpError';\n    this.response = response;\n  }\n}\n\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => {\n      if (response.status == 200) {\n        return response.json();\n      } else {\n        throw new HttpError(response);\n      }\n    });\n}\n\n// Ask for a user name until github returns a valid user\nfunction demoGithubUser() {\n  let name = prompt(\"Enter a name?\", \"iliakan\");\n\n  return loadJson(`https://api.github.com/users/${name}`)\n    .then(user => {\n      alert(`Full name: ${user.name}.`);\n      return user;\n    })\n    .catch(err => {\n      if (err instanceof HttpError && err.response.status == 404) {\n        alert(\"No such user, please reenter.\");\n        return demoGithubUser();\n      } else {\n        throw err;\n      }\n    });\n}\n\ndemoGithubUser();\nsolution\nCall async from non-async\n\nWe have a “regular” function called f. How can you call the async function wait() and use its result inside of f?\n\nasync function wait() {\n  await new Promise(resolve => setTimeout(resolve, 1000));\n\n  return 10;\n}\n\nfunction f() {\n  // ...what should you write here?\n  // we need to call async wait() and wait to get 10\n  // remember, we can't use \"await\"\n}\n\nP.S. The task is technically very simple, but the question is quite common for developers new to async/await.\n\nsolution"
  },
  {
    "title": "Microtasks",
    "url": "https://javascript.info/microtask-queue",
    "html": "Promise handlers .then/.catch/.finally are always asynchronous.\n\nEven when a Promise is immediately resolved, the code on the lines below .then/.catch/.finally will still execute before these handlers.\n\nHere’s a demo:\n\n\t\nlet promise = Promise.resolve();\n\npromise.then(() => alert(\"promise done!\"));\n\nalert(\"code finished\"); // this alert shows first\n\nIf you run it, you see code finished first, and then promise done!.\n\nThat’s strange, because the promise is definitely done from the beginning.\n\nWhy did the .then trigger afterwards? What’s going on?\n\nMicrotasks queue\n\nAsynchronous tasks need proper management. For that, the ECMA standard specifies an internal queue PromiseJobs, more often referred to as the “microtask queue” (V8 term).\n\nAs stated in the specification:\n\nThe queue is first-in-first-out: tasks enqueued first are run first.\nExecution of a task is initiated only when nothing else is running.\n\nOr, to put it more simply, when a promise is ready, its .then/catch/finally handlers are put into the queue; they are not executed yet. When the JavaScript engine becomes free from the current code, it takes a task from the queue and executes it.\n\nThat’s why “code finished” in the example above shows first.\n\nPromise handlers always go through this internal queue.\n\nIf there’s a chain with multiple .then/catch/finally, then every one of them is executed asynchronously. That is, it first gets queued, then executed when the current code is complete and previously queued handlers are finished.\n\nWhat if the order matters for us? How can we make code finished appear after promise done?\n\nEasy, just put it into the queue with .then:\n\n\t\nPromise.resolve()\n  .then(() => alert(\"promise done!\"))\n  .then(() => alert(\"code finished\"));\n\nNow the order is as intended.\n\nUnhandled rejection\n\nRemember the unhandledrejection event from the article Error handling with promises?\n\nNow we can see exactly how JavaScript finds out that there was an unhandled rejection.\n\nAn “unhandled rejection” occurs when a promise error is not handled at the end of the microtask queue.\n\nNormally, if we expect an error, we add .catch to the promise chain to handle it:\n\n\t\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\npromise.catch(err => alert('caught'));\n\n// doesn't run: error handled\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n\nBut if we forget to add .catch, then, after the microtask queue is empty, the engine triggers the event:\n\n\t\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\n\n// Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n\nWhat if we handle the error later? Like this:\n\n\t\nlet promise = Promise.reject(new Error(\"Promise Failed!\"));\nsetTimeout(() => promise.catch(err => alert('caught')), 1000);\n\n// Error: Promise Failed!\nwindow.addEventListener('unhandledrejection', event => alert(event.reason));\n\nNow, if we run it, we’ll see Promise Failed! first and then caught.\n\nIf we didn’t know about the microtasks queue, we could wonder: “Why did unhandledrejection handler run? We did catch and handle the error!”\n\nBut now we understand that unhandledrejection is generated when the microtask queue is complete: the engine examines promises and, if any of them is in the “rejected” state, then the event triggers.\n\nIn the example above, .catch added by setTimeout also triggers. But it does so later, after unhandledrejection has already occurred, so it doesn’t change anything.\n\nSummary\n\nPromise handling is always asynchronous, as all promise actions pass through the internal “promise jobs” queue, also called “microtask queue” (V8 term).\n\nSo .then/catch/finally handlers are always called after the current code is finished.\n\nIf we need to guarantee that a piece of code is executed after .then/catch/finally, we can add it into a chained .then call.\n\nIn most Javascript engines, including browsers and Node.js, the concept of microtasks is closely tied with the “event loop” and “macrotasks”. As these have no direct relation to promises, they are covered in another part of the tutorial, in the article Event loop: microtasks and macrotasks."
  },
  {
    "title": "Promisification",
    "url": "https://javascript.info/promisify",
    "html": "“Promisification” is a long word for a simple transformation. It’s the conversion of a function that accepts a callback into a function that returns a promise.\n\nSuch transformations are often required in real-life, as many functions and libraries are callback-based. But promises are more convenient, so it makes sense to promisify them.\n\nFor better understanding, let’s see an example.\n\nFor instance, we have loadScript(src, callback) from the chapter Introduction: callbacks.\n\n\t\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n\n// usage:\n// loadScript('path/script.js', (err, script) => {...})\n\nThe function loads a script with the given src, and then calls callback(err) in case of an error, or callback(null, script) in case of successful loading. That’s a widespread agreement for using callbacks, we saw it before.\n\nLet’s promisify it.\n\nWe’ll make a new function loadScriptPromise(src), that does the same (loads the script), but returns a promise instead of using callbacks.\n\nIn other words, we pass it only src (no callback) and get a promise in return, that resolves with script when the load is successful, and rejects with the error otherwise.\n\nHere it is:\n\nlet loadScriptPromise = function(src) {\n  return new Promise((resolve, reject) => {\n    loadScript(src, (err, script) => {\n      if (err) reject(err);\n      else resolve(script);\n    });\n  });\n};\n\n// usage:\n// loadScriptPromise('path/script.js').then(...)\n\nAs we can see, the new function is a wrapper around the original loadScript function. It calls it providing its own callback that translates to promise resolve/reject.\n\nNow loadScriptPromise fits well in promise-based code. If we like promises more than callbacks (and soon we’ll see more reasons for that), then we will use it instead.\n\nIn practice we may need to promisify more than one function, so it makes sense to use a helper.\n\nWe’ll call it promisify(f): it accepts a to-promisify function f and returns a wrapper function.\n\nfunction promisify(f) {\n  return function (...args) { // return a wrapper-function (*)\n    return new Promise((resolve, reject) => {\n      function callback(err, result) { // our custom callback for f (**)\n        if (err) {\n          reject(err);\n        } else {\n          resolve(result);\n        }\n      }\n\n      args.push(callback); // append our custom callback to the end of f arguments\n\n      f.call(this, ...args); // call the original function\n    });\n  };\n}\n\n// usage:\nlet loadScriptPromise = promisify(loadScript);\nloadScriptPromise(...).then(...);\n\nThe code may look a bit complex, but it’s essentially the same that we wrote above, while promisifying loadScript function.\n\nA call to promisify(f) returns a wrapper around f (*). That wrapper returns a promise and forwards the call to the original f, tracking the result in the custom callback (**).\n\nHere, promisify assumes that the original function expects a callback with exactly two arguments (err, result). That’s what we encounter most often. Then our custom callback is in exactly the right format, and promisify works great for such a case.\n\nBut what if the original f expects a callback with more arguments callback(err, res1, res2, ...)?\n\nWe can improve our helper. Let’s make a more advanced version of promisify.\n\nWhen called as promisify(f) it should work similar to the version above.\nWhen called as promisify(f, true), it should return the promise that resolves with the array of callback results. That’s exactly for callbacks with many arguments.\n// promisify(f, true) to get array of results\nfunction promisify(f, manyArgs = false) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      function callback(err, ...results) { // our custom callback for f\n        if (err) {\n          reject(err);\n        } else {\n          // resolve with all callback results if manyArgs is specified\n          resolve(manyArgs ? results : results[0]);\n        }\n      }\n\n      args.push(callback);\n\n      f.call(this, ...args);\n    });\n  };\n}\n\n// usage:\nf = promisify(f, true);\nf(...).then(arrayOfResults => ..., err => ...);\n\nAs you can see it’s essentially the same as above, but resolve is called with only one or all arguments depending on whether manyArgs is truthy.\n\nFor more exotic callback formats, like those without err at all: callback(result), we can promisify such functions manually without using the helper.\n\nThere are also modules with a bit more flexible promisification functions, e.g. es6-promisify. In Node.js, there’s a built-in util.promisify function for that.\n\nPlease note:\n\nPromisification is a great approach, especially when you use async/await (covered later in the chapter Async/await), but not a total replacement for callbacks.\n\nRemember, a promise may have only one result, but a callback may technically be called many times.\n\nSo promisification is only meant for functions that call the callback once. Further calls will be ignored."
  },
  {
    "title": "Promise API",
    "url": "https://javascript.info/promise-api",
    "html": "There are 6 static methods in the Promise class. We’ll quickly cover their use cases here.\n\nPromise.all\n\nLet’s say we want many promises to execute in parallel and wait until all of them are ready.\n\nFor instance, download several URLs in parallel and process the content once they are all done.\n\nThat’s what Promise.all is for.\n\nThe syntax is:\n\nlet promise = Promise.all(iterable);\n\nPromise.all takes an iterable (usually, an array of promises) and returns a new promise.\n\nThe new promise resolves when all listed promises are resolved, and the array of their results becomes its result.\n\nFor instance, the Promise.all below settles after 3 seconds, and then its result is an array [1, 2, 3]:\n\n\t\nPromise.all([\n  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1\n  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2\n  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3\n]).then(alert); // 1,2,3 when promises are ready: each promise contributes an array member\n\nPlease note that the order of the resulting array members is the same as in its source promises. Even though the first promise takes the longest time to resolve, it’s still first in the array of results.\n\nA common trick is to map an array of job data into an array of promises, and then wrap that into Promise.all.\n\nFor instance, if we have an array of URLs, we can fetch them all like this:\n\n\t\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://api.github.com/users/jeresig'\n];\n\n// map every url to the promise of the fetch\nlet requests = urls.map(url => fetch(url));\n\n// Promise.all waits until all jobs are resolved\nPromise.all(requests)\n  .then(responses => responses.forEach(\n    response => alert(`${response.url}: ${response.status}`)\n  ));\n\nA bigger example with fetching user information for an array of GitHub users by their names (we could fetch an array of goods by their ids, the logic is identical):\n\n\t\nlet names = ['iliakan', 'remy', 'jeresig'];\n\nlet requests = names.map(name => fetch(`https://api.github.com/users/${name}`));\n\nPromise.all(requests)\n  .then(responses => {\n    // all responses are resolved successfully\n    for(let response of responses) {\n      alert(`${response.url}: ${response.status}`); // shows 200 for every url\n    }\n\n    return responses;\n  })\n  // map array of responses into an array of response.json() to read their content\n  .then(responses => Promise.all(responses.map(r => r.json())))\n  // all JSON answers are parsed: \"users\" is the array of them\n  .then(users => users.forEach(user => alert(user.name)));\n\nIf any of the promises is rejected, the promise returned by Promise.all immediately rejects with that error.\n\nFor instance:\n\n\t\nPromise.all([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).catch(alert); // Error: Whoops!\n\nHere the second promise rejects in two seconds. That leads to an immediate rejection of Promise.all, so .catch executes: the rejection error becomes the outcome of the entire Promise.all.\n\nIn case of an error, other promises are ignored\n\nIf one promise rejects, Promise.all immediately rejects, completely forgetting about the other ones in the list. Their results are ignored.\n\nFor example, if there are multiple fetch calls, like in the example above, and one fails, the others will still continue to execute, but Promise.all won’t watch them anymore. They will probably settle, but their results will be ignored.\n\nPromise.all does nothing to cancel them, as there’s no concept of “cancellation” in promises. In another chapter we’ll cover AbortController that can help with that, but it’s not a part of the Promise API.\n\nPromise.all(iterable) allows non-promise “regular” values in iterable\n\nNormally, Promise.all(...) accepts an iterable (in most cases an array) of promises. But if any of those objects is not a promise, it’s passed to the resulting array “as is”.\n\nFor instance, here the results are [1, 2, 3]:\n\n\t\nPromise.all([\n  new Promise((resolve, reject) => {\n    setTimeout(() => resolve(1), 1000)\n  }),\n  2,\n  3\n]).then(alert); // 1, 2, 3\n\nSo we are able to pass ready values to Promise.all where convenient.\n\nPromise.allSettled\nA recent addition\nThis is a recent addition to the language. Old browsers may need polyfills.\n\nPromise.all rejects as a whole if any promise rejects. That’s good for “all or nothing” cases, when we need all results successful to proceed:\n\nPromise.all([\n  fetch('/template.html'),\n  fetch('/style.css'),\n  fetch('/data.json')\n]).then(render); // render method needs results of all fetches\n\nPromise.allSettled just waits for all promises to settle, regardless of the result. The resulting array has:\n\n{status:\"fulfilled\", value:result} for successful responses,\n{status:\"rejected\", reason:error} for errors.\n\nFor example, we’d like to fetch the information about multiple users. Even if one request fails, we’re still interested in the others.\n\nLet’s use Promise.allSettled:\n\n\t\nlet urls = [\n  'https://api.github.com/users/iliakan',\n  'https://api.github.com/users/remy',\n  'https://no-such-url'\n];\n\nPromise.allSettled(urls.map(url => fetch(url)))\n  .then(results => { // (*)\n    results.forEach((result, num) => {\n      if (result.status == \"fulfilled\") {\n        alert(`${urls[num]}: ${result.value.status}`);\n      }\n      if (result.status == \"rejected\") {\n        alert(`${urls[num]}: ${result.reason}`);\n      }\n    });\n  });\n\nThe results in the line (*) above will be:\n\n[\n  {status: 'fulfilled', value: ...response...},\n  {status: 'fulfilled', value: ...response...},\n  {status: 'rejected', reason: ...error object...}\n]\n\nSo for each promise we get its status and value/error.\n\nPolyfill\n\nIf the browser doesn’t support Promise.allSettled, it’s easy to polyfill:\n\nif (!Promise.allSettled) {\n  const rejectHandler = reason => ({ status: 'rejected', reason });\n\n  const resolveHandler = value => ({ status: 'fulfilled', value });\n\n  Promise.allSettled = function (promises) {\n    const convertedPromises = promises.map(p => Promise.resolve(p).then(resolveHandler, rejectHandler));\n    return Promise.all(convertedPromises);\n  };\n}\n\nIn this code, promises.map takes input values, turns them into promises (just in case a non-promise was passed) with p => Promise.resolve(p), and then adds .then handler to every one.\n\nThat handler turns a successful result value into {status:'fulfilled', value}, and an error reason into {status:'rejected', reason}. That’s exactly the format of Promise.allSettled.\n\nNow we can use Promise.allSettled to get the results of all given promises, even if some of them reject.\n\nPromise.race\n\nSimilar to Promise.all, but waits only for the first settled promise and gets its result (or error).\n\nThe syntax is:\n\nlet promise = Promise.race(iterable);\n\nFor instance, here the result will be 1:\n\n\t\nPromise.race([\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 2000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).then(alert); // 1\n\nThe first promise here was fastest, so it became the result. After the first settled promise “wins the race”, all further results/errors are ignored.\n\nPromise.any\n\nSimilar to Promise.race, but waits only for the first fulfilled promise and gets its result. If all of the given promises are rejected, then the returned promise is rejected with AggregateError – a special error object that stores all promise errors in its errors property.\n\nThe syntax is:\n\nlet promise = Promise.any(iterable);\n\nFor instance, here the result will be 1:\n\n\t\nPromise.any([\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Whoops!\")), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),\n  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))\n]).then(alert); // 1\n\nThe first promise here was fastest, but it was rejected, so the second promise became the result. After the first fulfilled promise “wins the race”, all further results are ignored.\n\nHere’s an example when all promises fail:\n\n\t\nPromise.any([\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Ouch!\")), 1000)),\n  new Promise((resolve, reject) => setTimeout(() => reject(new Error(\"Error!\")), 2000))\n]).catch(error => {\n  console.log(error.constructor.name); // AggregateError\n  console.log(error.errors[0]); // Error: Ouch!\n  console.log(error.errors[1]); // Error: Error!\n});\n\nAs you can see, error objects for failed promises are available in the errors property of the AggregateError object.\n\nPromise.resolve/reject\n\nMethods Promise.resolve and Promise.reject are rarely needed in modern code, because async/await syntax (we’ll cover it a bit later) makes them somewhat obsolete.\n\nWe cover them here for completeness and for those who can’t use async/await for some reason.\n\nPromise.resolve\n\nPromise.resolve(value) creates a resolved promise with the result value.\n\nSame as:\n\nlet promise = new Promise(resolve => resolve(value));\n\nThe method is used for compatibility, when a function is expected to return a promise.\n\nFor example, the loadCached function below fetches a URL and remembers (caches) its content. For future calls with the same URL it immediately gets the previous content from cache, but uses Promise.resolve to make a promise of it, so the returned value is always a promise:\n\nlet cache = new Map();\n\nfunction loadCached(url) {\n  if (cache.has(url)) {\n    return Promise.resolve(cache.get(url)); // (*)\n  }\n\n  return fetch(url)\n    .then(response => response.text())\n    .then(text => {\n      cache.set(url,text);\n      return text;\n    });\n}\n\nWe can write loadCached(url).then(…), because the function is guaranteed to return a promise. We can always use .then after loadCached. That’s the purpose of Promise.resolve in the line (*).\n\nPromise.reject\n\nPromise.reject(error) creates a rejected promise with error.\n\nSame as:\n\nlet promise = new Promise((resolve, reject) => reject(error));\n\nIn practice, this method is almost never used.\n\nSummary\n\nThere are 6 static methods of Promise class:\n\nPromise.all(promises) – waits for all promises to resolve and returns an array of their results. If any of the given promises rejects, it becomes the error of Promise.all, and all other results are ignored.\nPromise.allSettled(promises) (recently added method) – waits for all promises to settle and returns their results as an array of objects with:\nstatus: \"fulfilled\" or \"rejected\"\nvalue (if fulfilled) or reason (if rejected).\nPromise.race(promises) – waits for the first promise to settle, and its result/error becomes the outcome.\nPromise.any(promises) (recently added method) – waits for the first promise to fulfill, and its result becomes the outcome. If all of the given promises are rejected, AggregateError becomes the error of Promise.any.\nPromise.resolve(value) – makes a resolved promise with the given value.\nPromise.reject(error) – makes a rejected promise with the given error.\n\nOf all these, Promise.all is probably the most common in practice."
  },
  {
    "title": "Promises chaining",
    "url": "https://javascript.info/promise-chaining",
    "html": "Let’s return to the problem mentioned in the chapter Introduction: callbacks: we have a sequence of asynchronous tasks to be performed one after another — for instance, loading scripts. How can we code it well?\n\nPromises provide a couple of recipes to do that.\n\nIn this chapter we cover promise chaining.\n\nIt looks like this:\n\n\t\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000); // (*)\n\n}).then(function(result) { // (**)\n\n  alert(result); // 1\n  return result * 2;\n\n}).then(function(result) { // (***)\n\n  alert(result); // 2\n  return result * 2;\n\n}).then(function(result) {\n\n  alert(result); // 4\n  return result * 2;\n\n});\n\nThe idea is that the result is passed through the chain of .then handlers.\n\nHere the flow is:\n\nThe initial promise resolves in 1 second (*),\nThen the .then handler is called (**), which in turn creates a new promise (resolved with 2 value).\nThe next then (***) gets the result of the previous one, processes it (doubles) and passes it to the next handler.\n…and so on.\n\nAs the result is passed along the chain of handlers, we can see a sequence of alert calls: 1 → 2 → 4.\n\nThe whole thing works, because every call to a .then returns a new promise, so that we can call the next .then on it.\n\nWhen a handler returns a value, it becomes the result of that promise, so the next .then is called with it.\n\nA classic newbie error: technically we can also add many .then to a single promise. This is not chaining.\n\nFor example:\n\n\t\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(1), 1000);\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\npromise.then(function(result) {\n  alert(result); // 1\n  return result * 2;\n});\n\nWhat we did here is just adding several handlers to one promise. They don’t pass the result to each other; instead they process it independently.\n\nHere’s the picture (compare it with the chaining above):\n\nAll .then on the same promise get the same result – the result of that promise. So in the code above all alert show the same: 1.\n\nIn practice we rarely need multiple handlers for one promise. Chaining is used much more often.\n\nReturning promises\n\nA handler, used in .then(handler) may create and return a promise.\n\nIn that case further handlers wait until it settles, and then get its result.\n\nFor instance:\n\n\t\nnew Promise(function(resolve, reject) {\n\n  setTimeout(() => resolve(1), 1000);\n\n}).then(function(result) {\n\n  alert(result); // 1\n\n  return new Promise((resolve, reject) => { // (*)\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n\n}).then(function(result) { // (**)\n\n  alert(result); // 2\n\n  return new Promise((resolve, reject) => {\n    setTimeout(() => resolve(result * 2), 1000);\n  });\n\n}).then(function(result) {\n\n  alert(result); // 4\n\n});\n\nHere the first .then shows 1 and returns new Promise(…) in the line (*). After one second it resolves, and the result (the argument of resolve, here it’s result * 2) is passed on to the handler of the second .then. That handler is in the line (**), it shows 2 and does the same thing.\n\nSo the output is the same as in the previous example: 1 → 2 → 4, but now with 1 second delay between alert calls.\n\nReturning promises allows us to build chains of asynchronous actions.\n\nExample: loadScript\n\nLet’s use this feature with the promisified loadScript, defined in the previous chapter, to load scripts one by one, in sequence:\n\n\t\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/two.js\");\n  })\n  .then(function(script) {\n    return loadScript(\"/article/promise-chaining/three.js\");\n  })\n  .then(function(script) {\n    // use functions declared in scripts\n    // to show that they indeed loaded\n    one();\n    two();\n    three();\n  });\n\nThis code can be made bit shorter with arrow functions:\n\n\t\nloadScript(\"/article/promise-chaining/one.js\")\n  .then(script => loadScript(\"/article/promise-chaining/two.js\"))\n  .then(script => loadScript(\"/article/promise-chaining/three.js\"))\n  .then(script => {\n    // scripts are loaded, we can use functions declared there\n    one();\n    two();\n    three();\n  });\n\nHere each loadScript call returns a promise, and the next .then runs when it resolves. Then it initiates the loading of the next script. So scripts are loaded one after another.\n\nWe can add more asynchronous actions to the chain. Please note that the code is still “flat” — it grows down, not to the right. There are no signs of the “pyramid of doom”.\n\nTechnically, we could add .then directly to each loadScript, like this:\n\n\t\nloadScript(\"/article/promise-chaining/one.js\").then(script1 => {\n  loadScript(\"/article/promise-chaining/two.js\").then(script2 => {\n    loadScript(\"/article/promise-chaining/three.js\").then(script3 => {\n      // this function has access to variables script1, script2 and script3\n      one();\n      two();\n      three();\n    });\n  });\n});\n\nThis code does the same: loads 3 scripts in sequence. But it “grows to the right”. So we have the same problem as with callbacks.\n\nPeople who start to use promises sometimes don’t know about chaining, so they write it this way. Generally, chaining is preferred.\n\nSometimes it’s ok to write .then directly, because the nested function has access to the outer scope. In the example above the most nested callback has access to all variables script1, script2, script3. But that’s an exception rather than a rule.\n\nThenables\n\nTo be precise, a handler may return not exactly a promise, but a so-called “thenable” object – an arbitrary object that has a method .then. It will be treated the same way as a promise.\n\nThe idea is that 3rd-party libraries may implement “promise-compatible” objects of their own. They can have an extended set of methods, but also be compatible with native promises, because they implement .then.\n\nHere’s an example of a thenable object:\n\n\t\nclass Thenable {\n  constructor(num) {\n    this.num = num;\n  }\n  then(resolve, reject) {\n    alert(resolve); // function() { native code }\n    // resolve with this.num*2 after the 1 second\n    setTimeout(() => resolve(this.num * 2), 1000); // (**)\n  }\n}\n\nnew Promise(resolve => resolve(1))\n  .then(result => {\n    return new Thenable(result); // (*)\n  })\n  .then(alert); // shows 2 after 1000ms\n\nJavaScript checks the object returned by the .then handler in line (*): if it has a callable method named then, then it calls that method providing native functions resolve, reject as arguments (similar to an executor) and waits until one of them is called. In the example above resolve(2) is called after 1 second (**). Then the result is passed further down the chain.\n\nThis feature allows us to integrate custom objects with promise chains without having to inherit from Promise.\n\nBigger example: fetch\n\nIn frontend programming, promises are often used for network requests. So let’s see an extended example of that.\n\nWe’ll use the fetch method to load the information about the user from the remote server. It has a lot of optional parameters covered in separate chapters, but the basic syntax is quite simple:\n\nlet promise = fetch(url);\n\nThis makes a network request to the url and returns a promise. The promise resolves with a response object when the remote server responds with headers, but before the full response is downloaded.\n\nTo read the full response, we should call the method response.text(): it returns a promise that resolves when the full text is downloaded from the remote server, with that text as a result.\n\nThe code below makes a request to user.json and loads its text from the server:\n\n\t\nfetch('/article/promise-chaining/user.json')\n  // .then below runs when the remote server responds\n  .then(function(response) {\n    // response.text() returns a new promise that resolves with the full response text\n    // when it loads\n    return response.text();\n  })\n  .then(function(text) {\n    // ...and here's the content of the remote file\n    alert(text); // {\"name\": \"iliakan\", \"isAdmin\": true}\n  });\n\nThe response object returned from fetch also includes the method response.json() that reads the remote data and parses it as JSON. In our case that’s even more convenient, so let’s switch to it.\n\nWe’ll also use arrow functions for brevity:\n\n\t\n// same as above, but response.json() parses the remote content as JSON\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => alert(user.name)); // iliakan, got user name\n\nNow let’s do something with the loaded user.\n\nFor instance, we can make one more request to GitHub, load the user profile and show the avatar:\n\n\t\n// Make a request for user.json\nfetch('/article/promise-chaining/user.json')\n  // Load it as json\n  .then(response => response.json())\n  // Make a request to GitHub\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  // Load the response as json\n  .then(response => response.json())\n  // Show the avatar image (githubUser.avatar_url) for 3 seconds (maybe animate it)\n  .then(githubUser => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => img.remove(), 3000); // (*)\n  });\n\nThe code works; see comments about the details. However, there’s a potential problem in it, a typical error for those who begin to use promises.\n\nLook at the line (*): how can we do something after the avatar has finished showing and gets removed? For instance, we’d like to show a form for editing that user or something else. As of now, there’s no way.\n\nTo make the chain extendable, we need to return a promise that resolves when the avatar finishes showing.\n\nLike this:\n\n\t\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubUser => new Promise(function(resolve, reject) { // (*)\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser); // (**)\n    }, 3000);\n  }))\n  // triggers after 3 seconds\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n\nThat is, the .then handler in line (*) now returns new Promise, that becomes settled only after the call of resolve(githubUser) in setTimeout (**). The next .then in the chain will wait for that.\n\nAs a good practice, an asynchronous action should always return a promise. That makes it possible to plan actions after it; even if we don’t plan to extend the chain now, we may need it later.\n\nFinally, we can split the code into reusable functions:\n\n\t\nfunction loadJson(url) {\n  return fetch(url)\n    .then(response => response.json());\n}\n\nfunction loadGithubUser(name) {\n  return loadJson(`https://api.github.com/users/${name}`);\n}\n\nfunction showAvatar(githubUser) {\n  return new Promise(function(resolve, reject) {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  });\n}\n\n// Use them:\nloadJson('/article/promise-chaining/user.json')\n  .then(user => loadGithubUser(user.name))\n  .then(showAvatar)\n  .then(githubUser => alert(`Finished showing ${githubUser.name}`));\n  // ...\nSummary\n\nIf a .then (or catch/finally, doesn’t matter) handler returns a promise, the rest of the chain waits until it settles. When it does, its result (or error) is passed further.\n\nHere’s a full picture:\n\nTasks\nPromise: then versus catch\n\nAre these code fragments equal? In other words, do they behave the same way in any circumstances, for any handler functions?\n\npromise.then(f1).catch(f2);\n\nVersus:\n\npromise.then(f1, f2);\nsolution"
  },
  {
    "title": "Error handling with promises",
    "url": "https://javascript.info/promise-error-handling",
    "html": "Promise chains are great at error handling. When a promise rejects, the control jumps to the closest rejection handler. That’s very convenient in practice.\n\nFor instance, in the code below the URL to fetch is wrong (no such site) and .catch handles the error:\n\n\t\nfetch('https://no-such-server.blabla') // rejects\n  .then(response => response.json())\n  .catch(err => alert(err)) // TypeError: failed to fetch (the text may vary)\n\nAs you can see, the .catch doesn’t have to be immediate. It may appear after one or maybe several .then.\n\nOr, maybe, everything is all right with the site, but the response is not valid JSON. The easiest way to catch all errors is to append .catch to the end of chain:\n\n\t\nfetch('/article/promise-chaining/user.json')\n  .then(response => response.json())\n  .then(user => fetch(`https://api.github.com/users/${user.name}`))\n  .then(response => response.json())\n  .then(githubUser => new Promise((resolve, reject) => {\n    let img = document.createElement('img');\n    img.src = githubUser.avatar_url;\n    img.className = \"promise-avatar-example\";\n    document.body.append(img);\n\n    setTimeout(() => {\n      img.remove();\n      resolve(githubUser);\n    }, 3000);\n  }))\n  .catch(error => alert(error.message));\n\nNormally, such .catch doesn’t trigger at all. But if any of the promises above rejects (a network problem or invalid json or whatever), then it would catch it.\n\nImplicit try…catch\n\nThe code of a promise executor and promise handlers has an \"invisible try..catch\" around it. If an exception happens, it gets caught and treated as a rejection.\n\nFor instance, this code:\n\n\t\nnew Promise((resolve, reject) => {\n  throw new Error(\"Whoops!\");\n}).catch(alert); // Error: Whoops!\n\n…Works exactly the same as this:\n\n\t\nnew Promise((resolve, reject) => {\n  reject(new Error(\"Whoops!\"));\n}).catch(alert); // Error: Whoops!\n\nThe \"invisible try..catch\" around the executor automatically catches the error and turns it into rejected promise.\n\nThis happens not only in the executor function, but in its handlers as well. If we throw inside a .then handler, that means a rejected promise, so the control jumps to the nearest error handler.\n\nHere’s an example:\n\n\t\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n  throw new Error(\"Whoops!\"); // rejects the promise\n}).catch(alert); // Error: Whoops!\n\nThis happens for all errors, not just those caused by the throw statement. For example, a programming error:\n\n\t\nnew Promise((resolve, reject) => {\n  resolve(\"ok\");\n}).then((result) => {\n  blabla(); // no such function\n}).catch(alert); // ReferenceError: blabla is not defined\n\nThe final .catch not only catches explicit rejections, but also accidental errors in the handlers above.\n\nRethrowing\n\nAs we already noticed, .catch at the end of the chain is similar to try..catch. We may have as many .then handlers as we want, and then use a single .catch at the end to handle errors in all of them.\n\nIn a regular try..catch we can analyze the error and maybe rethrow it if it can’t be handled. The same thing is possible for promises.\n\nIf we throw inside .catch, then the control goes to the next closest error handler. And if we handle the error and finish normally, then it continues to the next closest successful .then handler.\n\nIn the example below the .catch successfully handles the error:\n\n\t\n// the execution: catch -> then\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) {\n\n  alert(\"The error is handled, continue normally\");\n\n}).then(() => alert(\"Next successful handler runs\"));\n\nHere the .catch block finishes normally. So the next successful .then handler is called.\n\nIn the example below we see the other situation with .catch. The handler (*) catches the error and just can’t handle it (e.g. it only knows how to handle URIError), so it throws it again:\n\n\t\n// the execution: catch -> catch\nnew Promise((resolve, reject) => {\n\n  throw new Error(\"Whoops!\");\n\n}).catch(function(error) { // (*)\n\n  if (error instanceof URIError) {\n    // handle it\n  } else {\n    alert(\"Can't handle such error\");\n\n    throw error; // throwing this or another error jumps to the next catch\n  }\n\n}).then(function() {\n  /* doesn't run here */\n}).catch(error => { // (**)\n\n  alert(`The unknown error has occurred: ${error}`);\n  // don't return anything => execution goes the normal way\n\n});\n\nThe execution jumps from the first .catch (*) to the next one (**) down the chain.\n\nUnhandled rejections\n\nWhat happens when an error is not handled? For instance, we forgot to append .catch to the end of the chain, like here:\n\n\t\nnew Promise(function() {\n  noSuchFunction(); // Error here (no such function)\n})\n  .then(() => {\n    // successful promise handlers, one or more\n  }); // without .catch at the end!\n\nIn case of an error, the promise becomes rejected, and the execution should jump to the closest rejection handler. But there is none. So the error gets “stuck”. There’s no code to handle it.\n\nIn practice, just like with regular unhandled errors in code, it means that something has gone terribly wrong.\n\nWhat happens when a regular error occurs and is not caught by try..catch? The script dies with a message in the console. A similar thing happens with unhandled promise rejections.\n\nThe JavaScript engine tracks such rejections and generates a global error in that case. You can see it in the console if you run the example above.\n\nIn the browser we can catch such errors using the event unhandledrejection:\n\n\t\nwindow.addEventListener('unhandledrejection', function(event) {\n  // the event object has two special properties:\n  alert(event.promise); // [object Promise] - the promise that generated the error\n  alert(event.reason); // Error: Whoops! - the unhandled error object\n});\n\nnew Promise(function() {\n  throw new Error(\"Whoops!\");\n}); // no catch to handle the error\n\nThe event is the part of the HTML standard.\n\nIf an error occurs, and there’s no .catch, the unhandledrejection handler triggers, and gets the event object with the information about the error, so we can do something.\n\nUsually such errors are unrecoverable, so our best way out is to inform the user about the problem and probably report the incident to the server.\n\nIn non-browser environments like Node.js there are other ways to track unhandled errors.\n\nSummary\n.catch handles errors in promises of all kinds: be it a reject() call, or an error thrown in a handler.\n.then also catches errors in the same manner, if given the second argument (which is the error handler).\nWe should place .catch exactly in places where we want to handle errors and know how to handle them. The handler should analyze errors (custom error classes help) and rethrow unknown ones (maybe they are programming mistakes).\nIt’s ok not to use .catch at all, if there’s no way to recover from an error.\nIn any case we should have the unhandledrejection event handler (for browsers, and analogs for other environments) to track unhandled errors and inform the user (and probably our server) about them, so that our app never “just dies”.\nTasks\nError in setTimeout\n\nWhat do you think? Will the .catch trigger? Explain your answer.\n\nnew Promise(function(resolve, reject) {\n  setTimeout(() => {\n    throw new Error(\"Whoops!\");\n  }, 1000);\n}).catch(alert);\nsolution"
  },
  {
    "title": "Promise",
    "url": "https://javascript.info/promise-basics",
    "html": "Imagine that you’re a top singer, and fans ask day and night for your upcoming song.\n\nTo get some relief, you promise to send it to them when it’s published. You give your fans a list. They can fill in their email addresses, so that when the song becomes available, all subscribed parties instantly receive it. And even if something goes very wrong, say, a fire in the studio, so that you can’t publish the song, they will still be notified.\n\nEveryone is happy: you, because the people don’t crowd you anymore, and fans, because they won’t miss the song.\n\nThis is a real-life analogy for things we often have in programming:\n\nA “producing code” that does something and takes time. For instance, some code that loads the data over a network. That’s a “singer”.\nA “consuming code” that wants the result of the “producing code” once it’s ready. Many functions may need that result. These are the “fans”.\nA promise is a special JavaScript object that links the “producing code” and the “consuming code” together. In terms of our analogy: this is the “subscription list”. The “producing code” takes whatever time it needs to produce the promised result, and the “promise” makes that result available to all of the subscribed code when it’s ready.\n\nThe analogy isn’t terribly accurate, because JavaScript promises are more complex than a simple subscription list: they have additional features and limitations. But it’s fine to begin with.\n\nThe constructor syntax for a promise object is:\n\nlet promise = new Promise(function(resolve, reject) {\n  // executor (the producing code, \"singer\")\n});\n\nThe function passed to new Promise is called the executor. When new Promise is created, the executor runs automatically. It contains the producing code which should eventually produce the result. In terms of the analogy above: the executor is the “singer”.\n\nIts arguments resolve and reject are callbacks provided by JavaScript itself. Our code is only inside the executor.\n\nWhen the executor obtains the result, be it soon or late, doesn’t matter, it should call one of these callbacks:\n\nresolve(value) — if the job is finished successfully, with result value.\nreject(error) — if an error has occurred, error is the error object.\n\nSo to summarize: the executor runs automatically and attempts to perform a job. When it is finished with the attempt, it calls resolve if it was successful or reject if there was an error.\n\nThe promise object returned by the new Promise constructor has these internal properties:\n\nstate — initially \"pending\", then changes to either \"fulfilled\" when resolve is called or \"rejected\" when reject is called.\nresult — initially undefined, then changes to value when resolve(value) is called or error when reject(error) is called.\n\nSo the executor eventually moves promise to one of these states:\n\nLater we’ll see how “fans” can subscribe to these changes.\n\nHere’s an example of a promise constructor and a simple executor function with “producing code” that takes time (via setTimeout):\n\n\t\nlet promise = new Promise(function(resolve, reject) {\n  // the function is executed automatically when the promise is constructed\n\n  // after 1 second signal that the job is done with the result \"done\"\n  setTimeout(() => resolve(\"done\"), 1000);\n});\n\nWe can see two things by running the code above:\n\nThe executor is called automatically and immediately (by new Promise).\n\nThe executor receives two arguments: resolve and reject. These functions are pre-defined by the JavaScript engine, so we don’t need to create them. We should only call one of them when ready.\n\nAfter one second of “processing”, the executor calls resolve(\"done\") to produce the result. This changes the state of the promise object:\n\nThat was an example of a successful job completion, a “fulfilled promise”.\n\nAnd now an example of the executor rejecting the promise with an error:\n\nlet promise = new Promise(function(resolve, reject) {\n  // after 1 second signal that the job is finished with an error\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\nThe call to reject(...) moves the promise object to \"rejected\" state:\n\nTo summarize, the executor should perform a job (usually something that takes time) and then call resolve or reject to change the state of the corresponding promise object.\n\nA promise that is either resolved or rejected is called “settled”, as opposed to an initially “pending” promise.\n\nThere can be only a single result or an error\n\nThe executor should call only one resolve or one reject. Any state change is final.\n\nAll further calls of resolve and reject are ignored:\n\nlet promise = new Promise(function(resolve, reject) {\n  resolve(\"done\");\n\n  reject(new Error(\"…\")); // ignored\n  setTimeout(() => resolve(\"…\")); // ignored\n});\n\nThe idea is that a job done by the executor may have only one result or an error.\n\nAlso, resolve/reject expect only one argument (or none) and will ignore additional arguments.\n\nReject with Error objects\n\nIn case something goes wrong, the executor should call reject. That can be done with any type of argument (just like resolve). But it is recommended to use Error objects (or objects that inherit from Error). The reasoning for that will soon become apparent.\n\nImmediately calling resolve/reject\n\nIn practice, an executor usually does something asynchronously and calls resolve/reject after some time, but it doesn’t have to. We also can call resolve or reject immediately, like this:\n\nlet promise = new Promise(function(resolve, reject) {\n  // not taking our time to do the job\n  resolve(123); // immediately give the result: 123\n});\n\nFor instance, this might happen when we start to do a job but then see that everything has already been completed and cached.\n\nThat’s fine. We immediately have a resolved promise.\n\nThe state and result are internal\n\nThe properties state and result of the Promise object are internal. We can’t directly access them. We can use the methods .then/.catch/.finally for that. They are described below.\n\nConsumers: then, catch\n\nA Promise object serves as a link between the executor (the “producing code” or “singer”) and the consuming functions (the “fans”), which will receive the result or error. Consuming functions can be registered (subscribed) using the methods .then and .catch.\n\nthen\n\nThe most important, fundamental one is .then.\n\nThe syntax is:\n\npromise.then(\n  function(result) { /* handle a successful result */ },\n  function(error) { /* handle an error */ }\n);\n\nThe first argument of .then is a function that runs when the promise is resolved and receives the result.\n\nThe second argument of .then is a function that runs when the promise is rejected and receives the error.\n\nFor instance, here’s a reaction to a successfully resolved promise:\n\n\t\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\n// resolve runs the first function in .then\npromise.then(\n  result => alert(result), // shows \"done!\" after 1 second\n  error => alert(error) // doesn't run\n);\n\nThe first function was executed.\n\nAnd in the case of a rejection, the second one:\n\n\t\nlet promise = new Promise(function(resolve, reject) {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n// reject runs the second function in .then\npromise.then(\n  result => alert(result), // doesn't run\n  error => alert(error) // shows \"Error: Whoops!\" after 1 second\n);\n\nIf we’re interested only in successful completions, then we can provide only one function argument to .then:\n\n\t\nlet promise = new Promise(resolve => {\n  setTimeout(() => resolve(\"done!\"), 1000);\n});\n\npromise.then(alert); // shows \"done!\" after 1 second\ncatch\n\nIf we’re interested only in errors, then we can use null as the first argument: .then(null, errorHandlingFunction). Or we can use .catch(errorHandlingFunction), which is exactly the same:\n\n\t\nlet promise = new Promise((resolve, reject) => {\n  setTimeout(() => reject(new Error(\"Whoops!\")), 1000);\n});\n\n// .catch(f) is the same as promise.then(null, f)\npromise.catch(alert); // shows \"Error: Whoops!\" after 1 second\n\nThe call .catch(f) is a complete analog of .then(null, f), it’s just a shorthand.\n\nCleanup: finally\n\nJust like there’s a finally clause in a regular try {...} catch {...}, there’s finally in promises.\n\nThe call .finally(f) is similar to .then(f, f) in the sense that f runs always, when the promise is settled: be it resolve or reject.\n\nThe idea of finally is to set up a handler for performing cleanup/finalizing after the previous operations are complete.\n\nE.g. stopping loading indicators, closing no longer needed connections, etc.\n\nThink of it as a party finisher. No matter was a party good or bad, how many friends were in it, we still need (or at least should) do a cleanup after it.\n\nThe code may look like this:\n\nnew Promise((resolve, reject) => {\n  /* do something that takes time, and then call resolve or maybe reject */\n})\n  // runs when the promise is settled, doesn't matter successfully or not\n  .finally(() => stop loading indicator)\n  // so the loading indicator is always stopped before we go on\n  .then(result => show result, err => show error)\n\nPlease note that finally(f) isn’t exactly an alias of then(f,f) though.\n\nThere are important differences:\n\nA finally handler has no arguments. In finally we don’t know whether the promise is successful or not. That’s all right, as our task is usually to perform “general” finalizing procedures.\n\nPlease take a look at the example above: as you can see, the finally handler has no arguments, and the promise outcome is handled by the next handler.\n\nA finally handler “passes through” the result or error to the next suitable handler.\n\nFor instance, here the result is passed through finally to then:\n\n\t\nnew Promise((resolve, reject) => {\n  setTimeout(() => resolve(\"value\"), 2000);\n})\n  .finally(() => alert(\"Promise ready\")) // triggers first\n  .then(result => alert(result)); // <-- .then shows \"value\"\n\nAs you can see, the value returned by the first promise is passed through finally to the next then.\n\nThat’s very convenient, because finally is not meant to process a promise result. As said, it’s a place to do generic cleanup, no matter what the outcome was.\n\nAnd here’s an example of an error, for us to see how it’s passed through finally to catch:\n\n\t\nnew Promise((resolve, reject) => {\n  throw new Error(\"error\");\n})\n  .finally(() => alert(\"Promise ready\")) // triggers first\n  .catch(err => alert(err));  // <-- .catch shows the error\n\nA finally handler also shouldn’t return anything. If it does, the returned value is silently ignored.\n\nThe only exception to this rule is when a finally handler throws an error. Then this error goes to the next handler, instead of any previous outcome.\n\nTo summarize:\n\nA finally handler doesn’t get the outcome of the previous handler (it has no arguments). This outcome is passed through instead, to the next suitable handler.\nIf a finally handler returns something, it’s ignored.\nWhen finally throws an error, then the execution goes to the nearest error handler.\n\nThese features are helpful and make things work just the right way if we use finally how it’s supposed to be used: for generic cleanup procedures.\n\nWe can attach handlers to settled promises\n\nIf a promise is pending, .then/catch/finally handlers wait for its outcome.\n\nSometimes, it might be that a promise is already settled when we add a handler to it.\n\nIn such case, these handlers just run immediately:\n\n\t\n// the promise becomes resolved immediately upon creation\nlet promise = new Promise(resolve => resolve(\"done!\"));\n\npromise.then(alert); // done! (shows up right now)\n\nNote that this makes promises more powerful than the real life “subscription list” scenario. If the singer has already released their song and then a person signs up on the subscription list, they probably won’t receive that song. Subscriptions in real life must be done prior to the event.\n\nPromises are more flexible. We can add handlers any time: if the result is already there, they just execute.\n\nExample: loadScript\n\nNext, let’s see more practical examples of how promises can help us write asynchronous code.\n\nWe’ve got the loadScript function for loading a script from the previous chapter.\n\nHere’s the callback-based variant, just to remind us of it:\n\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n\nLet’s rewrite it using Promises.\n\nThe new function loadScript will not require a callback. Instead, it will create and return a Promise object that resolves when the loading is complete. The outer code can add handlers (subscribing functions) to it using .then:\n\n\t\nfunction loadScript(src) {\n  return new Promise(function(resolve, reject) {\n    let script = document.createElement('script');\n    script.src = src;\n\n    script.onload = () => resolve(script);\n    script.onerror = () => reject(new Error(`Script load error for ${src}`));\n\n    document.head.append(script);\n  });\n}\n\nUsage:\n\n\t\nlet promise = loadScript(\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\");\n\npromise.then(\n  script => alert(`${script.src} is loaded!`),\n  error => alert(`Error: ${error.message}`)\n);\n\npromise.then(script => alert('Another handler...'));\n\nWe can immediately see a few benefits over the callback-based pattern:\n\nPromises\tCallbacks\nPromises allow us to do things in the natural order. First, we run loadScript(script), and .then we write what to do with the result.\tWe must have a callback function at our disposal when calling loadScript(script, callback). In other words, we must know what to do with the result before loadScript is called.\nWe can call .then on a Promise as many times as we want. Each time, we’re adding a new “fan”, a new subscribing function, to the “subscription list”. More about this in the next chapter: Promises chaining.\tThere can be only one callback.\n\nSo promises give us better code flow and flexibility. But there’s more. We’ll see that in the next chapters.\n\nTasks\nRe-resolve a promise?\n\nWhat’s the output of the code below?\n\nlet promise = new Promise(function(resolve, reject) {\n  resolve(1);\n\n  setTimeout(() => resolve(2), 1000);\n});\n\npromise.then(alert);\nsolution\nDelay with a promise\n\nThe built-in function setTimeout uses callbacks. Create a promise-based alternative.\n\nThe function delay(ms) should return a promise. That promise should resolve after ms milliseconds, so that we can add .then to it, like this:\n\nfunction delay(ms) {\n  // your code\n}\n\ndelay(3000).then(() => alert('runs after 3 seconds'));\nsolution\nAnimated circle with promise\n\nRewrite the showCircle function in the solution of the task Animated circle with callback so that it returns a promise instead of accepting a callback.\n\nThe new usage:\n\nshowCircle(150, 150, 100).then(div => {\n  div.classList.add('message-ball');\n  div.append(\"Hello, world!\");\n});\n\nTake the solution of the task Animated circle with callback as the base.\n\nsolution"
  },
  {
    "title": "Introduction: callbacks",
    "url": "https://javascript.info/callbacks",
    "html": "We use browser methods in examples here\n\nTo demonstrate the use of callbacks, promises and other abstract concepts, we’ll be using some browser methods: specifically, loading scripts and performing simple document manipulations.\n\nIf you’re not familiar with these methods, and their usage in the examples is confusing, you may want to read a few chapters from the next part of the tutorial.\n\nAlthough, we’ll try to make things clear anyway. There won’t be anything really complex browser-wise.\n\nMany functions are provided by JavaScript host environments that allow you to schedule asynchronous actions. In other words, actions that we initiate now, but they finish later.\n\nFor instance, one such function is the setTimeout function.\n\nThere are other real-world examples of asynchronous actions, e.g. loading scripts and modules (we’ll cover them in later chapters).\n\nTake a look at the function loadScript(src), that loads a script with the given src:\n\nfunction loadScript(src) {\n  // creates a <script> tag and append it to the page\n  // this causes the script with given src to start loading and run when complete\n  let script = document.createElement('script');\n  script.src = src;\n  document.head.append(script);\n}\n\nIt inserts into the document a new, dynamically created, tag <script src=\"…\"> with the given src. The browser automatically starts loading it and executes when complete.\n\nWe can use this function like this:\n\n// load and execute the script at the given path\nloadScript('/my/script.js');\n\nThe script is executed “asynchronously”, as it starts loading now, but runs later, when the function has already finished.\n\nIf there’s any code below loadScript(…), it doesn’t wait until the script loading finishes.\n\nloadScript('/my/script.js');\n// the code below loadScript\n// doesn't wait for the script loading to finish\n// ...\n\nLet’s say we need to use the new script as soon as it loads. It declares new functions, and we want to run them.\n\nBut if we do that immediately after the loadScript(…) call, that wouldn’t work:\n\nloadScript('/my/script.js'); // the script has \"function newFunction() {…}\"\n\nnewFunction(); // no such function!\n\nNaturally, the browser probably didn’t have time to load the script. As of now, the loadScript function doesn’t provide a way to track the load completion. The script loads and eventually runs, that’s all. But we’d like to know when it happens, to use new functions and variables from that script.\n\nLet’s add a callback function as a second argument to loadScript that should execute when the script loads:\n\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(script);\n\n  document.head.append(script);\n}\n\nThe onload event is described in the article Resource loading: onload and onerror, it basically executes a function after the script is loaded and executed.\n\nNow if we want to call new functions from the script, we should write that in the callback:\n\nloadScript('/my/script.js', function() {\n  // the callback runs after the script is loaded\n  newFunction(); // so now it works\n  ...\n});\n\nThat’s the idea: the second argument is a function (usually anonymous) that runs when the action is completed.\n\nHere’s a runnable example with a real script:\n\n\t\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.onload = () => callback(script);\n  document.head.append(script);\n}\n\nloadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {\n  alert(`Cool, the script ${script.src} is loaded`);\n  alert( _ ); // _ is a function declared in the loaded script\n});\n\nThat’s called a “callback-based” style of asynchronous programming. A function that does something asynchronously should provide a callback argument where we put the function to run after it’s complete.\n\nHere we did it in loadScript, but of course it’s a general approach.\n\nCallback in callback\n\nHow can we load two scripts sequentially: the first one, and then the second one after it?\n\nThe natural solution would be to put the second loadScript call inside the callback, like this:\n\nloadScript('/my/script.js', function(script) {\n\n  alert(`Cool, the ${script.src} is loaded, let's load one more`);\n\n  loadScript('/my/script2.js', function(script) {\n    alert(`Cool, the second script is loaded`);\n  });\n\n});\n\nAfter the outer loadScript is complete, the callback initiates the inner one.\n\nWhat if we want one more script…?\n\nloadScript('/my/script.js', function(script) {\n\n  loadScript('/my/script2.js', function(script) {\n\n    loadScript('/my/script3.js', function(script) {\n      // ...continue after all scripts are loaded\n    });\n\n  });\n\n});\n\nSo, every new action is inside a callback. That’s fine for few actions, but not good for many, so we’ll see other variants soon.\n\nHandling errors\n\nIn the above examples we didn’t consider errors. What if the script loading fails? Our callback should be able to react on that.\n\nHere’s an improved version of loadScript that tracks loading errors:\n\nfunction loadScript(src, callback) {\n  let script = document.createElement('script');\n  script.src = src;\n\n  script.onload = () => callback(null, script);\n  script.onerror = () => callback(new Error(`Script load error for ${src}`));\n\n  document.head.append(script);\n}\n\nIt calls callback(null, script) for successful load and callback(error) otherwise.\n\nThe usage:\n\nloadScript('/my/script.js', function(error, script) {\n  if (error) {\n    // handle error\n  } else {\n    // script loaded successfully\n  }\n});\n\nOnce again, the recipe that we used for loadScript is actually quite common. It’s called the “error-first callback” style.\n\nThe convention is:\n\nThe first argument of the callback is reserved for an error if it occurs. Then callback(err) is called.\nThe second argument (and the next ones if needed) are for the successful result. Then callback(null, result1, result2…) is called.\n\nSo the single callback function is used both for reporting errors and passing back results.\n\nPyramid of Doom\n\nAt first glance, it looks like a viable approach to asynchronous coding. And indeed it is. For one or maybe two nested calls it looks fine.\n\nBut for multiple asynchronous actions that follow one after another, we’ll have code like this:\n\nloadScript('1.js', function(error, script) {\n\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', function(error, script) {\n      if (error) {\n        handleError(error);\n      } else {\n        // ...\n        loadScript('3.js', function(error, script) {\n          if (error) {\n            handleError(error);\n          } else {\n            // ...continue after all scripts are loaded (*)\n          }\n        });\n\n      }\n    });\n  }\n});\n\nIn the code above:\n\nWe load 1.js, then if there’s no error…\nWe load 2.js, then if there’s no error…\nWe load 3.js, then if there’s no error – do something else (*).\n\nAs calls become more nested, the code becomes deeper and increasingly more difficult to manage, especially if we have real code instead of ... that may include more loops, conditional statements and so on.\n\nThat’s sometimes called “callback hell” or “pyramid of doom.”\n\nThe “pyramid” of nested calls grows to the right with every asynchronous action. Soon it spirals out of control.\n\nSo this way of coding isn’t very good.\n\nWe can try to alleviate the problem by making every action a standalone function, like this:\n\nloadScript('1.js', step1);\n\nfunction step1(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('2.js', step2);\n  }\n}\n\nfunction step2(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...\n    loadScript('3.js', step3);\n  }\n}\n\nfunction step3(error, script) {\n  if (error) {\n    handleError(error);\n  } else {\n    // ...continue after all scripts are loaded (*)\n  }\n}\n\nSee? It does the same thing, and there’s no deep nesting now because we made every action a separate top-level function.\n\nIt works, but the code looks like a torn apart spreadsheet. It’s difficult to read, and you probably noticed that one needs to eye-jump between pieces while reading it. That’s inconvenient, especially if the reader is not familiar with the code and doesn’t know where to eye-jump.\n\nAlso, the functions named step* are all of single use, they are created only to avoid the “pyramid of doom.” No one is going to reuse them outside of the action chain. So there’s a bit of namespace cluttering here.\n\nWe’d like to have something better.\n\nLuckily, there are other ways to avoid such pyramids. One of the best ways is to use “promises”, described in the next chapter."
  },
  {
    "title": "Promises, async/await",
    "url": "https://javascript.info/async",
    "html": "Introduction: callbacks\nPromise\nPromises chaining\nError handling with promises\nPromise API\nPromisification\nMicrotasks\nAsync/await"
  },
  {
    "title": "Extending built-in classes",
    "url": "https://javascript.info/extend-natives",
    "html": "Built-in classes like Array, Map and others are extendable also.\n\nFor instance, here PowerArray inherits from the native Array:\n\n\t\n// add one more method to it (can do more)\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\nlet filteredArr = arr.filter(item => item >= 10);\nalert(filteredArr); // 10, 50\nalert(filteredArr.isEmpty()); // false\n\nPlease note a very interesting thing. Built-in methods like filter, map and others – return new objects of exactly the inherited type PowerArray. Their internal implementation uses the object’s constructor property for that.\n\nIn the example above,\n\narr.constructor === PowerArray\n\nWhen arr.filter() is called, it internally creates the new array of results using exactly arr.constructor, not basic Array. That’s actually very cool, because we can keep using PowerArray methods further on the result.\n\nEven more, we can customize that behavior.\n\nWe can add a special static getter Symbol.species to the class. If it exists, it should return the constructor that JavaScript will use internally to create new entities in map, filter and so on.\n\nIf we’d like built-in methods like map or filter to return regular arrays, we can return Array in Symbol.species, like here:\n\n\t\nclass PowerArray extends Array {\n  isEmpty() {\n    return this.length === 0;\n  }\n\n  // built-in methods will use this as the constructor\n  static get [Symbol.species]() {\n    return Array;\n  }\n}\n\nlet arr = new PowerArray(1, 2, 5, 10, 50);\nalert(arr.isEmpty()); // false\n\n// filter creates new array using arr.constructor[Symbol.species] as constructor\nlet filteredArr = arr.filter(item => item >= 10);\n\n// filteredArr is not PowerArray, but Array\nalert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty is not a function\n\nAs you can see, now .filter returns Array. So the extended functionality is not passed any further.\n\nOther collections work similarly\n\nOther collections, such as Map and Set, work alike. They also use Symbol.species.\n\nNo static inheritance in built-ins\n\nBuilt-in objects have their own static methods, for instance Object.keys, Array.isArray etc.\n\nAs we already know, native classes extend each other. For instance, Array extends Object.\n\nNormally, when one class extends another, both static and non-static methods are inherited. That was thoroughly explained in the article Static properties and methods.\n\nBut built-in classes are an exception. They don’t inherit statics from each other.\n\nFor example, both Array and Date inherit from Object, so their instances have methods from Object.prototype. But Array.[[Prototype]] does not reference Object, so there’s no, for instance, Array.keys() (or Date.keys()) static method.\n\nHere’s the picture structure for Date and Object:\n\nAs you can see, there’s no link between Date and Object. They are independent, only Date.prototype inherits from Object.prototype.\n\nThat’s an important difference of inheritance between built-in objects compared to what we get with extends."
  },
  {
    "title": "Error handling, \"try...catch\"",
    "url": "https://javascript.info/try-catch",
    "html": "No matter how great we are at programming, sometimes our scripts have errors. They may occur because of our mistakes, an unexpected user input, an erroneous server response, and for a thousand other reasons.\n\nUsually, a script “dies” (immediately stops) in case of an error, printing it to console.\n\nBut there’s a syntax construct try...catch that allows us to “catch” errors so the script can, instead of dying, do something more reasonable.\n\nThe “try…catch” syntax\n\nThe try...catch construct has two main blocks: try, and then catch:\n\ntry {\n\n  // code...\n\n} catch (err) {\n\n  // error handling\n\n}\n\nIt works like this:\n\nFirst, the code in try {...} is executed.\nIf there were no errors, then catch (err) is ignored: the execution reaches the end of try and goes on, skipping catch.\nIf an error occurs, then the try execution is stopped, and control flows to the beginning of catch (err). The err variable (we can use any name for it) will contain an error object with details about what happened.\n\nSo, an error inside the try {...} block does not kill the script – we have a chance to handle it in catch.\n\nLet’s look at some examples.\n\nAn errorless example: shows alert (1) and (2):\n\n\t\ntry {\n\n  alert('Start of try runs');  // (1) <--\n\n  // ...no errors here\n\n  alert('End of try runs');   // (2) <--\n\n} catch (err) {\n\n  alert('Catch is ignored, because there are no errors'); // (3)\n\n}\n\nAn example with an error: shows (1) and (3):\n\n\t\ntry {\n\n  alert('Start of try runs');  // (1) <--\n\n  lalala; // error, variable is not defined!\n\n  alert('End of try (never reached)');  // (2)\n\n} catch (err) {\n\n  alert(`Error has occurred!`); // (3) <--\n\n}\ntry...catch only works for runtime errors\n\nFor try...catch to work, the code must be runnable. In other words, it should be valid JavaScript.\n\nIt won’t work if the code is syntactically wrong, for instance it has unmatched curly braces:\n\n\t\ntry {\n  {{{{{{{{{{{{\n} catch (err) {\n  alert(\"The engine can't understand this code, it's invalid\");\n}\n\nThe JavaScript engine first reads the code, and then runs it. The errors that occur on the reading phase are called “parse-time” errors and are unrecoverable (from inside that code). That’s because the engine can’t understand the code.\n\nSo, try...catch can only handle errors that occur in valid code. Such errors are called “runtime errors” or, sometimes, “exceptions”.\n\ntry...catch works synchronously\n\nIf an exception happens in “scheduled” code, like in setTimeout, then try...catch won’t catch it:\n\n\t\ntry {\n  setTimeout(function() {\n    noSuchVariable; // script will die here\n  }, 1000);\n} catch (err) {\n  alert( \"won't work\" );\n}\n\nThat’s because the function itself is executed later, when the engine has already left the try...catch construct.\n\nTo catch an exception inside a scheduled function, try...catch must be inside that function:\n\n\t\nsetTimeout(function() {\n  try {\n    noSuchVariable; // try...catch handles the error!\n  } catch {\n    alert( \"error is caught here!\" );\n  }\n}, 1000);\nError object\n\nWhen an error occurs, JavaScript generates an object containing the details about it. The object is then passed as an argument to catch:\n\ntry {\n  // ...\n} catch (err) { // <-- the \"error object\", could use another word instead of err\n  // ...\n}\n\nFor all built-in errors, the error object has two main properties:\n\nname\nError name. For instance, for an undefined variable that’s \"ReferenceError\".\nmessage\nTextual message about error details.\n\nThere are other non-standard properties available in most environments. One of most widely used and supported is:\n\nstack\nCurrent call stack: a string with information about the sequence of nested calls that led to the error. Used for debugging purposes.\n\nFor instance:\n\n\t\ntry {\n  lalala; // error, variable is not defined!\n} catch (err) {\n  alert(err.name); // ReferenceError\n  alert(err.message); // lalala is not defined\n  alert(err.stack); // ReferenceError: lalala is not defined at (...call stack)\n\n  // Can also show an error as a whole\n  // The error is converted to string as \"name: message\"\n  alert(err); // ReferenceError: lalala is not defined\n}\nOptional “catch” binding\nA recent addition\nThis is a recent addition to the language. Old browsers may need polyfills.\n\nIf we don’t need error details, catch may omit it:\n\ntry {\n  // ...\n} catch { // <-- without (err)\n  // ...\n}\nUsing “try…catch”\n\nLet’s explore a real-life use case of try...catch.\n\nAs we already know, JavaScript supports the JSON.parse(str) method to read JSON-encoded values.\n\nUsually it’s used to decode data received over the network, from the server or another source.\n\nWe receive it and call JSON.parse like this:\n\n\t\nlet json = '{\"name\":\"John\", \"age\": 30}'; // data from the server\n\nlet user = JSON.parse(json); // convert the text representation to JS object\n\n// now user is an object with properties from the string\nalert( user.name ); // John\nalert( user.age );  // 30\n\nYou can find more detailed information about JSON in the JSON methods, toJSON chapter.\n\nIf json is malformed, JSON.parse generates an error, so the script “dies”.\n\nShould we be satisfied with that? Of course not!\n\nThis way, if something’s wrong with the data, the visitor will never know that (unless they open the developer console). And people really don’t like when something “just dies” without any error message.\n\nLet’s use try...catch to handle the error:\n\n\t\nlet json = \"{ bad json }\";\n\ntry {\n\n  let user = JSON.parse(json); // <-- when an error occurs...\n  alert( user.name ); // doesn't work\n\n} catch (err) {\n  // ...the execution jumps here\n  alert( \"Our apologies, the data has errors, we'll try to request it one more time.\" );\n  alert( err.name );\n  alert( err.message );\n}\n\nHere we use the catch block only to show the message, but we can do much more: send a new network request, suggest an alternative to the visitor, send information about the error to a logging facility, … . All much better than just dying.\n\nThrowing our own errors\n\nWhat if json is syntactically correct, but doesn’t have a required name property?\n\nLike this:\n\n\t\nlet json = '{ \"age\": 30 }'; // incomplete data\n\ntry {\n\n  let user = JSON.parse(json); // <-- no errors\n  alert( user.name ); // no name!\n\n} catch (err) {\n  alert( \"doesn't execute\" );\n}\n\nHere JSON.parse runs normally, but the absence of name is actually an error for us.\n\nTo unify error handling, we’ll use the throw operator.\n\n“Throw” operator\n\nThe throw operator generates an error.\n\nThe syntax is:\n\nthrow <error object>\n\nTechnically, we can use anything as an error object. That may be even a primitive, like a number or a string, but it’s better to use objects, preferably with name and message properties (to stay somewhat compatible with built-in errors).\n\nJavaScript has many built-in constructors for standard errors: Error, SyntaxError, ReferenceError, TypeError and others. We can use them to create error objects as well.\n\nTheir syntax is:\n\nlet error = new Error(message);\n// or\nlet error = new SyntaxError(message);\nlet error = new ReferenceError(message);\n// ...\n\nFor built-in errors (not for any objects, just for errors), the name property is exactly the name of the constructor. And message is taken from the argument.\n\nFor instance:\n\n\t\nlet error = new Error(\"Things happen o_O\");\n\nalert(error.name); // Error\nalert(error.message); // Things happen o_O\n\nLet’s see what kind of error JSON.parse generates:\n\n\t\ntry {\n  JSON.parse(\"{ bad json o_O }\");\n} catch (err) {\n  alert(err.name); // SyntaxError\n  alert(err.message); // Unexpected token b in JSON at position 2\n}\n\nAs we can see, that’s a SyntaxError.\n\nAnd in our case, the absence of name is an error, as users must have a name.\n\nSo let’s throw it:\n\n\t\nlet json = '{ \"age\": 30 }'; // incomplete data\n\ntry {\n\n  let user = JSON.parse(json); // <-- no errors\n\n  if (!user.name) {\n    throw new SyntaxError(\"Incomplete data: no name\"); // (*)\n  }\n\n  alert( user.name );\n\n} catch (err) {\n  alert( \"JSON Error: \" + err.message ); // JSON Error: Incomplete data: no name\n}\n\nIn the line (*), the throw operator generates a SyntaxError with the given message, the same way as JavaScript would generate it itself. The execution of try immediately stops and the control flow jumps into catch.\n\nNow catch became a single place for all error handling: both for JSON.parse and other cases.\n\nRethrowing\n\nIn the example above we use try...catch to handle incorrect data. But is it possible that another unexpected error occurs within the try {...} block? Like a programming error (variable is not defined) or something else, not just this “incorrect data” thing.\n\nFor example:\n\n\t\nlet json = '{ \"age\": 30 }'; // incomplete data\n\ntry {\n  user = JSON.parse(json); // <-- forgot to put \"let\" before user\n\n  // ...\n} catch (err) {\n  alert(\"JSON Error: \" + err); // JSON Error: ReferenceError: user is not defined\n  // (no JSON Error actually)\n}\n\nOf course, everything’s possible! Programmers do make mistakes. Even in open-source utilities used by millions for decades – suddenly a bug may be discovered that leads to terrible hacks.\n\nIn our case, try...catch is placed to catch “incorrect data” errors. But by its nature, catch gets all errors from try. Here it gets an unexpected error, but still shows the same \"JSON Error\" message. That’s wrong and also makes the code more difficult to debug.\n\nTo avoid such problems, we can employ the “rethrowing” technique. The rule is simple:\n\nCatch should only process errors that it knows and “rethrow” all others.\n\nThe “rethrowing” technique can be explained in more detail as:\n\nCatch gets all errors.\nIn the catch (err) {...} block we analyze the error object err.\nIf we don’t know how to handle it, we do throw err.\n\nUsually, we can check the error type using the instanceof operator:\n\n\t\ntry {\n  user = { /*...*/ };\n} catch (err) {\n  if (err instanceof ReferenceError) {\n    alert('ReferenceError'); // \"ReferenceError\" for accessing an undefined variable\n  }\n}\n\nWe can also get the error class name from err.name property. All native errors have it. Another option is to read err.constructor.name.\n\nIn the code below, we use rethrowing so that catch only handles SyntaxError:\n\n\t\nlet json = '{ \"age\": 30 }'; // incomplete data\ntry {\n\n  let user = JSON.parse(json);\n\n  if (!user.name) {\n    throw new SyntaxError(\"Incomplete data: no name\");\n  }\n\n  blabla(); // unexpected error\n\n  alert( user.name );\n\n} catch (err) {\n\n  if (err instanceof SyntaxError) {\n    alert( \"JSON Error: \" + err.message );\n  } else {\n    throw err; // rethrow (*)\n  }\n\n}\n\nThe error throwing on line (*) from inside catch block “falls out” of try...catch and can be either caught by an outer try...catch construct (if it exists), or it kills the script.\n\nSo the catch block actually handles only errors that it knows how to deal with and “skips” all others.\n\nThe example below demonstrates how such errors can be caught by one more level of try...catch:\n\n\t\nfunction readData() {\n  let json = '{ \"age\": 30 }';\n\n  try {\n    // ...\n    blabla(); // error!\n  } catch (err) {\n    // ...\n    if (!(err instanceof SyntaxError)) {\n      throw err; // rethrow (don't know how to deal with it)\n    }\n  }\n}\n\ntry {\n  readData();\n} catch (err) {\n  alert( \"External catch got: \" + err ); // caught it!\n}\n\nHere readData only knows how to handle SyntaxError, while the outer try...catch knows how to handle everything.\n\ntry…catch…finally\n\nWait, that’s not all.\n\nThe try...catch construct may have one more code clause: finally.\n\nIf it exists, it runs in all cases:\n\nafter try, if there were no errors,\nafter catch, if there were errors.\n\nThe extended syntax looks like this:\n\ntry {\n   ... try to execute the code ...\n} catch (err) {\n   ... handle errors ...\n} finally {\n   ... execute always ...\n}\n\nTry running this code:\n\n\t\ntry {\n  alert( 'try' );\n  if (confirm('Make an error?')) BAD_CODE();\n} catch (err) {\n  alert( 'catch' );\n} finally {\n  alert( 'finally' );\n}\n\nThe code has two ways of execution:\n\nIf you answer “Yes” to “Make an error?”, then try -> catch -> finally.\nIf you say “No”, then try -> finally.\n\nThe finally clause is often used when we start doing something and want to finalize it in any case of outcome.\n\nFor instance, we want to measure the time that a Fibonacci numbers function fib(n) takes. Naturally, we can start measuring before it runs and finish afterwards. But what if there’s an error during the function call? In particular, the implementation of fib(n) in the code below returns an error for negative or non-integer numbers.\n\nThe finally clause is a great place to finish the measurements no matter what.\n\nHere finally guarantees that the time will be measured correctly in both situations – in case of a successful execution of fib and in case of an error in it:\n\n\t\nlet num = +prompt(\"Enter a positive integer number?\", 35)\n\nlet diff, result;\n\nfunction fib(n) {\n  if (n < 0 || Math.trunc(n) != n) {\n    throw new Error(\"Must not be negative, and also an integer.\");\n  }\n  return n <= 1 ? n : fib(n - 1) + fib(n - 2);\n}\n\nlet start = Date.now();\n\ntry {\n  result = fib(num);\n} catch (err) {\n  result = 0;\n} finally {\n  diff = Date.now() - start;\n}\n\nalert(result || \"error occurred\");\n\nalert( `execution took ${diff}ms` );\n\nYou can check by running the code with entering 35 into prompt – it executes normally, finally after try. And then enter -1 – there will be an immediate error, and the execution will take 0ms. Both measurements are done correctly.\n\nIn other words, the function may finish with return or throw, that doesn’t matter. The finally clause executes in both cases.\n\nVariables are local inside try...catch...finally\n\nPlease note that result and diff variables in the code above are declared before try...catch.\n\nOtherwise, if we declared let in try block, it would only be visible inside of it.\n\nfinally and return\n\nThe finally clause works for any exit from try...catch. That includes an explicit return.\n\nIn the example below, there’s a return in try. In this case, finally is executed just before the control returns to the outer code.\n\n\t\nfunction func() {\n\n  try {\n    return 1;\n\n  } catch (err) {\n    /* ... */\n  } finally {\n    alert( 'finally' );\n  }\n}\n\nalert( func() ); // first works alert from finally, and then this one\ntry...finally\n\nThe try...finally construct, without catch clause, is also useful. We apply it when we don’t want to handle errors here (let them fall through), but want to be sure that processes that we started are finalized.\n\nfunction func() {\n  // start doing something that needs completion (like measurements)\n  try {\n    // ...\n  } finally {\n    // complete that thing even if all dies\n  }\n}\n\nIn the code above, an error inside try always falls out, because there’s no catch. But finally works before the execution flow leaves the function.\n\nGlobal catch\nEnvironment-specific\n\nThe information from this section is not a part of the core JavaScript.\n\nLet’s imagine we’ve got a fatal error outside of try...catch, and the script died. Like a programming error or some other terrible thing.\n\nIs there a way to react on such occurrences? We may want to log the error, show something to the user (normally they don’t see error messages), etc.\n\nThere is none in the specification, but environments usually provide it, because it’s really useful. For instance, Node.js has process.on(\"uncaughtException\") for that. And in the browser we can assign a function to the special window.onerror property, that will run in case of an uncaught error.\n\nThe syntax:\n\nwindow.onerror = function(message, url, line, col, error) {\n  // ...\n};\nmessage\nError message.\nurl\nURL of the script where error happened.\nline, col\nLine and column numbers where error happened.\nerror\nError object.\n\nFor instance:\n\n\t\n<script>\n  window.onerror = function(message, url, line, col, error) {\n    alert(`${message}\\n At ${line}:${col} of ${url}`);\n  };\n\n  function readData() {\n    badFunc(); // Whoops, something went wrong!\n  }\n\n  readData();\n</script>\n\nThe role of the global handler window.onerror is usually not to recover the script execution – that’s probably impossible in case of programming errors, but to send the error message to developers.\n\nThere are also web-services that provide error-logging for such cases, like https://errorception.com or https://www.muscula.com.\n\nThey work like this:\n\nWe register at the service and get a piece of JS (or a script URL) from them to insert on pages.\nThat JS script sets a custom window.onerror function.\nWhen an error occurs, it sends a network request about it to the service.\nWe can log in to the service web interface and see errors.\nSummary\n\nThe try...catch construct allows to handle runtime errors. It literally allows to “try” running the code and “catch” errors that may occur in it.\n\nThe syntax is:\n\ntry {\n  // run this code\n} catch (err) {\n  // if an error happened, then jump here\n  // err is the error object\n} finally {\n  // do in any case after try/catch\n}\n\nThere may be no catch section or no finally, so shorter constructs try...catch and try...finally are also valid.\n\nError objects have following properties:\n\nmessage – the human-readable error message.\nname – the string with error name (error constructor name).\nstack (non-standard, but well-supported) – the stack at the moment of error creation.\n\nIf an error object is not needed, we can omit it by using catch { instead of catch (err) {.\n\nWe can also generate our own errors using the throw operator. Technically, the argument of throw can be anything, but usually it’s an error object inheriting from the built-in Error class. More on extending errors in the next chapter.\n\nRethrowing is a very important pattern of error handling: a catch block usually expects and knows how to handle the particular error type, so it should rethrow errors it doesn’t know.\n\nEven if we don’t have try...catch, most environments allow us to setup a “global” error handler to catch errors that “fall out”. In-browser, that’s window.onerror.\n\nTasks\nFinally or just the code?\nimportance: 5\n\nCompare the two code fragments.\n\nThe first one uses finally to execute the code after try...catch:\n\ntry {\n  work work\n} catch (err) {\n  handle errors\n} finally {\n  cleanup the working space\n}\n\nThe second fragment puts the cleaning right after try...catch:\n\ntry {\n  work work\n} catch (err) {\n  handle errors\n}\n\ncleanup the working space\n\nWe definitely need the cleanup after the work, doesn’t matter if there was an error or not.\n\nIs there an advantage here in using finally or both code fragments are equal? If there is such an advantage, then give an example when it matters.\n\nsolution"
  },
  {
    "title": "Error handling",
    "url": "https://javascript.info/error-handling",
    "html": "Error handling, \"try...catch\"\nCustom errors, extending Error"
  },
  {
    "title": "Mixins",
    "url": "https://javascript.info/mixins",
    "html": "In JavaScript we can only inherit from a single object. There can be only one [[Prototype]] for an object. And a class may extend only one other class.\n\nBut sometimes that feels limiting. For instance, we have a class StreetSweeper and a class Bicycle, and want to make their mix: a StreetSweepingBicycle.\n\nOr we have a class User and a class EventEmitter that implements event generation, and we’d like to add the functionality of EventEmitter to User, so that our users can emit events.\n\nThere’s a concept that can help here, called “mixins”.\n\nAs defined in Wikipedia, a mixin is a class containing methods that can be used by other classes without a need to inherit from it.\n\nIn other words, a mixin provides methods that implement a certain behavior, but we do not use it alone, we use it to add the behavior to other classes.\n\nA mixin example\n\nThe simplest way to implement a mixin in JavaScript is to make an object with useful methods, so that we can easily merge them into a prototype of any class.\n\nFor instance here the mixin sayHiMixin is used to add some “speech” for User:\n\n\t\n// mixin\nlet sayHiMixin = {\n  sayHi() {\n    alert(`Hello ${this.name}`);\n  },\n  sayBye() {\n    alert(`Bye ${this.name}`);\n  }\n};\n\n// usage:\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// copy the methods\nObject.assign(User.prototype, sayHiMixin);\n\n// now User can say hi\nnew User(\"Dude\").sayHi(); // Hello Dude!\n\nThere’s no inheritance, but a simple method copying. So User may inherit from another class and also include the mixin to “mix-in” the additional methods, like this:\n\nclass User extends Person {\n  // ...\n}\n\nObject.assign(User.prototype, sayHiMixin);\n\nMixins can make use of inheritance inside themselves.\n\nFor instance, here sayHiMixin inherits from sayMixin:\n\n\t\nlet sayMixin = {\n  say(phrase) {\n    alert(phrase);\n  }\n};\n\nlet sayHiMixin = {\n  __proto__: sayMixin, // (or we could use Object.setPrototypeOf to set the prototype here)\n\n  sayHi() {\n    // call parent method\n    super.say(`Hello ${this.name}`); // (*)\n  },\n  sayBye() {\n    super.say(`Bye ${this.name}`); // (*)\n  }\n};\n\nclass User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// copy the methods\nObject.assign(User.prototype, sayHiMixin);\n\n// now User can say hi\nnew User(\"Dude\").sayHi(); // Hello Dude!\n\nPlease note that the call to the parent method super.say() from sayHiMixin (at lines labelled with (*)) looks for the method in the prototype of that mixin, not the class.\n\nHere’s the diagram (see the right part):\n\nThat’s because methods sayHi and sayBye were initially created in sayHiMixin. So even though they got copied, their [[HomeObject]] internal property references sayHiMixin, as shown in the picture above.\n\nAs super looks for parent methods in [[HomeObject]].[[Prototype]], that means it searches sayHiMixin.[[Prototype]].\n\nEventMixin\n\nNow let’s make a mixin for real life.\n\nAn important feature of many browser objects (for instance) is that they can generate events. Events are a great way to “broadcast information” to anyone who wants it. So let’s make a mixin that allows us to easily add event-related functions to any class/object.\n\nThe mixin will provide a method .trigger(name, [...data]) to “generate an event” when something important happens to it. The name argument is a name of the event, optionally followed by additional arguments with event data.\nAlso the method .on(name, handler) that adds handler function as the listener to events with the given name. It will be called when an event with the given name triggers, and get the arguments from the .trigger call.\n…And the method .off(name, handler) that removes the handler listener.\n\nAfter adding the mixin, an object user will be able to generate an event \"login\" when the visitor logs in. And another object, say, calendar may want to listen for such events to load the calendar for the logged-in person.\n\nOr, a menu can generate the event \"select\" when a menu item is selected, and other objects may assign handlers to react on that event. And so on.\n\nHere’s the code:\n\n\t\nlet eventMixin = {\n  /**\n   * Subscribe to event, usage:\n   *  menu.on('select', function(item) { ... }\n  */\n  on(eventName, handler) {\n    if (!this._eventHandlers) this._eventHandlers = {};\n    if (!this._eventHandlers[eventName]) {\n      this._eventHandlers[eventName] = [];\n    }\n    this._eventHandlers[eventName].push(handler);\n  },\n\n  /**\n   * Cancel the subscription, usage:\n   *  menu.off('select', handler)\n   */\n  off(eventName, handler) {\n    let handlers = this._eventHandlers?.[eventName];\n    if (!handlers) return;\n    for (let i = 0; i < handlers.length; i++) {\n      if (handlers[i] === handler) {\n        handlers.splice(i--, 1);\n      }\n    }\n  },\n\n  /**\n   * Generate an event with the given name and data\n   *  this.trigger('select', data1, data2);\n   */\n  trigger(eventName, ...args) {\n    if (!this._eventHandlers?.[eventName]) {\n      return; // no handlers for that event name\n    }\n\n    // call the handlers\n    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));\n  }\n};\n.on(eventName, handler) – assigns function handler to run when the event with that name occurs. Technically, there’s an _eventHandlers property that stores an array of handlers for each event name, and it just adds it to the list.\n.off(eventName, handler) – removes the function from the handlers list.\n.trigger(eventName, ...args) – generates the event: all handlers from _eventHandlers[eventName] are called, with a list of arguments ...args.\n\nUsage:\n\n\t\n// Make a class\nclass Menu {\n  choose(value) {\n    this.trigger(\"select\", value);\n  }\n}\n// Add the mixin with event-related methods\nObject.assign(Menu.prototype, eventMixin);\n\nlet menu = new Menu();\n\n// add a handler, to be called on selection:\nmenu.on(\"select\", value => alert(`Value selected: ${value}`));\n\n// triggers the event => the handler above runs and shows:\n// Value selected: 123\nmenu.choose(\"123\");\n\nNow, if we’d like any code to react to a menu selection, we can listen for it with menu.on(...).\n\nAnd eventMixin mixin makes it easy to add such behavior to as many classes as we’d like, without interfering with the inheritance chain.\n\nSummary\n\nMixin – is a generic object-oriented programming term: a class that contains methods for other classes.\n\nSome other languages allow multiple inheritance. JavaScript does not support multiple inheritance, but mixins can be implemented by copying methods into prototype.\n\nWe can use mixins as a way to augment a class by adding multiple behaviors, like event-handling as we have seen above.\n\nMixins may become a point of conflict if they accidentally overwrite existing class methods. So generally one should think well about the naming methods of a mixin, to minimize the probability of that happening."
  },
  {
    "title": "Custom errors, extending Error",
    "url": "https://javascript.info/custom-errors",
    "html": "When we develop something, we often need our own error classes to reflect specific things that may go wrong in our tasks. For errors in network operations we may need HttpError, for database operations DbError, for searching operations NotFoundError and so on.\n\nOur errors should support basic error properties like message, name and, preferably, stack. But they also may have other properties of their own, e.g. HttpError objects may have a statusCode property with a value like 404 or 403 or 500.\n\nJavaScript allows to use throw with any argument, so technically our custom error classes don’t need to inherit from Error. But if we inherit, then it becomes possible to use obj instanceof Error to identify error objects. So it’s better to inherit from it.\n\nAs the application grows, our own errors naturally form a hierarchy. For instance, HttpTimeoutError may inherit from HttpError, and so on.\n\nExtending Error\n\nAs an example, let’s consider a function readUser(json) that should read JSON with user data.\n\nHere’s an example of how a valid json may look:\n\nlet json = `{ \"name\": \"John\", \"age\": 30 }`;\n\nInternally, we’ll use JSON.parse. If it receives malformed json, then it throws SyntaxError. But even if json is syntactically correct, that doesn’t mean that it’s a valid user, right? It may miss the necessary data. For instance, it may not have name and age properties that are essential for our users.\n\nOur function readUser(json) will not only read JSON, but check (“validate”) the data. If there are no required fields, or the format is wrong, then that’s an error. And that’s not a SyntaxError, because the data is syntactically correct, but another kind of error. We’ll call it ValidationError and create a class for it. An error of that kind should also carry the information about the offending field.\n\nOur ValidationError class should inherit from the Error class.\n\nThe Error class is built-in, but here’s its approximate code so we can understand what we’re extending:\n\n// The \"pseudocode\" for the built-in Error class defined by JavaScript itself\nclass Error {\n  constructor(message) {\n    this.message = message;\n    this.name = \"Error\"; // (different names for different built-in error classes)\n    this.stack = <call stack>; // non-standard, but most environments support it\n  }\n}\n\nNow let’s inherit ValidationError from it and try it in action:\n\n\t\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message); // (1)\n    this.name = \"ValidationError\"; // (2)\n  }\n}\n\nfunction test() {\n  throw new ValidationError(\"Whoops!\");\n}\n\ntry {\n  test();\n} catch(err) {\n  alert(err.message); // Whoops!\n  alert(err.name); // ValidationError\n  alert(err.stack); // a list of nested calls with line numbers for each\n}\n\nPlease note: in the line (1) we call the parent constructor. JavaScript requires us to call super in the child constructor, so that’s obligatory. The parent constructor sets the message property.\n\nThe parent constructor also sets the name property to \"Error\", so in the line (2) we reset it to the right value.\n\nLet’s try to use it in readUser(json):\n\n\t\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\n// Usage\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new ValidationError(\"No field: age\");\n  }\n  if (!user.name) {\n    throw new ValidationError(\"No field: name\");\n  }\n\n  return user;\n}\n\n// Working example with try..catch\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n    alert(\"Invalid data: \" + err.message); // Invalid data: No field: name\n  } else if (err instanceof SyntaxError) { // (*)\n    alert(\"JSON Syntax Error: \" + err.message);\n  } else {\n    throw err; // unknown error, rethrow it (**)\n  }\n}\n\nThe try..catch block in the code above handles both our ValidationError and the built-in SyntaxError from JSON.parse.\n\nPlease take a look at how we use instanceof to check for the specific error type in the line (*).\n\nWe could also look at err.name, like this:\n\n// ...\n// instead of (err instanceof SyntaxError)\n} else if (err.name == \"SyntaxError\") { // (*)\n// ...\n\nThe instanceof version is much better, because in the future we are going to extend ValidationError, make subtypes of it, like PropertyRequiredError. And instanceof check will continue to work for new inheriting classes. So that’s future-proof.\n\nAlso it’s important that if catch meets an unknown error, then it rethrows it in the line (**). The catch block only knows how to handle validation and syntax errors, other kinds (caused by a typo in the code or other unknown reasons) should fall through.\n\nFurther inheritance\n\nThe ValidationError class is very generic. Many things may go wrong. The property may be absent or it may be in a wrong format (like a string value for age instead of a number). Let’s make a more concrete class PropertyRequiredError, exactly for absent properties. It will carry additional information about the property that’s missing.\n\n\t\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"No property: \" + property);\n    this.name = \"PropertyRequiredError\";\n    this.property = property;\n  }\n}\n\n// Usage\nfunction readUser(json) {\n  let user = JSON.parse(json);\n\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n\n  return user;\n}\n\n// Working example with try..catch\n\ntry {\n  let user = readUser('{ \"age\": 25 }');\n} catch (err) {\n  if (err instanceof ValidationError) {\n    alert(\"Invalid data: \" + err.message); // Invalid data: No property: name\n    alert(err.name); // PropertyRequiredError\n    alert(err.property); // name\n  } else if (err instanceof SyntaxError) {\n    alert(\"JSON Syntax Error: \" + err.message);\n  } else {\n    throw err; // unknown error, rethrow it\n  }\n}\n\nThe new class PropertyRequiredError is easy to use: we only need to pass the property name: new PropertyRequiredError(property). The human-readable message is generated by the constructor.\n\nPlease note that this.name in PropertyRequiredError constructor is again assigned manually. That may become a bit tedious – to assign this.name = <class name> in every custom error class. We can avoid it by making our own “basic error” class that assigns this.name = this.constructor.name. And then inherit all our custom errors from it.\n\nLet’s call it MyError.\n\nHere’s the code with MyError and other custom error classes, simplified:\n\n\t\nclass MyError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n}\n\nclass ValidationError extends MyError { }\n\nclass PropertyRequiredError extends ValidationError {\n  constructor(property) {\n    super(\"No property: \" + property);\n    this.property = property;\n  }\n}\n\n// name is correct\nalert( new PropertyRequiredError(\"field\").name ); // PropertyRequiredError\n\nNow custom errors are much shorter, especially ValidationError, as we got rid of the \"this.name = ...\" line in the constructor.\n\nWrapping exceptions\n\nThe purpose of the function readUser in the code above is “to read the user data”. There may occur different kinds of errors in the process. Right now we have SyntaxError and ValidationError, but in the future readUser function may grow and probably generate other kinds of errors.\n\nThe code which calls readUser should handle these errors. Right now it uses multiple ifs in the catch block, that check the class and handle known errors and rethrow the unknown ones.\n\nThe scheme is like this:\n\ntry {\n  ...\n  readUser()  // the potential error source\n  ...\n} catch (err) {\n  if (err instanceof ValidationError) {\n    // handle validation errors\n  } else if (err instanceof SyntaxError) {\n    // handle syntax errors\n  } else {\n    throw err; // unknown error, rethrow it\n  }\n}\n\nIn the code above we can see two types of errors, but there can be more.\n\nIf the readUser function generates several kinds of errors, then we should ask ourselves: do we really want to check for all error types one-by-one every time?\n\nOften the answer is “No”: we’d like to be “one level above all that”. We just want to know if there was a “data reading error” – why exactly it happened is often irrelevant (the error message describes it). Or, even better, we’d like to have a way to get the error details, but only if we need to.\n\nThe technique that we describe here is called “wrapping exceptions”.\n\nWe’ll make a new class ReadError to represent a generic “data reading” error.\nThe function readUser will catch data reading errors that occur inside it, such as ValidationError and SyntaxError, and generate a ReadError instead.\nThe ReadError object will keep the reference to the original error in its cause property.\n\nThen the code that calls readUser will only have to check for ReadError, not for every kind of data reading errors. And if it needs more details of an error, it can check its cause property.\n\nHere’s the code that defines ReadError and demonstrates its use in readUser and try..catch:\n\n\t\nclass ReadError extends Error {\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    this.name = 'ReadError';\n  }\n}\n\nclass ValidationError extends Error { /*...*/ }\nclass PropertyRequiredError extends ValidationError { /* ... */ }\n\nfunction validateUser(user) {\n  if (!user.age) {\n    throw new PropertyRequiredError(\"age\");\n  }\n\n  if (!user.name) {\n    throw new PropertyRequiredError(\"name\");\n  }\n}\n\nfunction readUser(json) {\n  let user;\n\n  try {\n    user = JSON.parse(json);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new ReadError(\"Syntax Error\", err);\n    } else {\n      throw err;\n    }\n  }\n\n  try {\n    validateUser(user);\n  } catch (err) {\n    if (err instanceof ValidationError) {\n      throw new ReadError(\"Validation Error\", err);\n    } else {\n      throw err;\n    }\n  }\n\n}\n\ntry {\n  readUser('{bad json}');\n} catch (e) {\n  if (e instanceof ReadError) {\n    alert(e);\n    // Original error: SyntaxError: Unexpected token b in JSON at position 1\n    alert(\"Original error: \" + e.cause);\n  } else {\n    throw e;\n  }\n}\n\nIn the code above, readUser works exactly as described – catches syntax and validation errors and throws ReadError errors instead (unknown errors are rethrown as usual).\n\nSo the outer code checks instanceof ReadError and that’s it. No need to list all possible error types.\n\nThe approach is called “wrapping exceptions”, because we take “low level” exceptions and “wrap” them into ReadError that is more abstract. It is widely used in object-oriented programming.\n\nSummary\nWe can inherit from Error and other built-in error classes normally. We just need to take care of the name property and don’t forget to call super.\nWe can use instanceof to check for particular errors. It also works with inheritance. But sometimes we have an error object coming from a 3rd-party library and there’s no easy way to get its class. Then name property can be used for such checks.\nWrapping exceptions is a widespread technique: a function handles low-level exceptions and creates higher-level errors instead of various low-level ones. Low-level exceptions sometimes become properties of that object like err.cause in the examples above, but that’s not strictly required.\nTasks\nInherit from SyntaxError\nimportance: 5\n\nCreate a class FormatError that inherits from the built-in SyntaxError class.\n\nIt should support message, name and stack properties.\n\nUsage example:\n\nlet err = new FormatError(\"formatting error\");\n\nalert( err.message ); // formatting error\nalert( err.name ); // FormatError\nalert( err.stack ); // stack\n\nalert( err instanceof FormatError ); // true\nalert( err instanceof SyntaxError ); // true (because inherits from SyntaxError)\nsolution"
  },
  {
    "title": "Class checking: \"instanceof\"",
    "url": "https://javascript.info/instanceof",
    "html": "The instanceof operator allows to check whether an object belongs to a certain class. It also takes inheritance into account.\n\nSuch a check may be necessary in many cases. For example, it can be used for building a polymorphic function, the one that treats arguments differently depending on their type.\n\nThe instanceof operator\n\nThe syntax is:\n\nobj instanceof Class\n\nIt returns true if obj belongs to the Class or a class inheriting from it.\n\nFor instance:\n\n\t\nclass Rabbit {}\nlet rabbit = new Rabbit();\n\n// is it an object of Rabbit class?\nalert( rabbit instanceof Rabbit ); // true\n\nIt also works with constructor functions:\n\n\t\n// instead of class\nfunction Rabbit() {}\n\nalert( new Rabbit() instanceof Rabbit ); // true\n\n…And with built-in classes like Array:\n\n\t\nlet arr = [1, 2, 3];\nalert( arr instanceof Array ); // true\nalert( arr instanceof Object ); // true\n\nPlease note that arr also belongs to the Object class. That’s because Array prototypically inherits from Object.\n\nNormally, instanceof examines the prototype chain for the check. We can also set a custom logic in the static method Symbol.hasInstance.\n\nThe algorithm of obj instanceof Class works roughly as follows:\n\nIf there’s a static method Symbol.hasInstance, then just call it: Class[Symbol.hasInstance](obj). It should return either true or false, and we’re done. That’s how we can customize the behavior of instanceof.\n\nFor example:\n\n\t\n// setup instanceOf check that assumes that\n// anything with canEat property is an animal\nclass Animal {\n  static [Symbol.hasInstance](obj) {\n    if (obj.canEat) return true;\n  }\n}\n\nlet obj = { canEat: true };\n\nalert(obj instanceof Animal); // true: Animal[Symbol.hasInstance](obj) is called\n\nMost classes do not have Symbol.hasInstance. In that case, the standard logic is used: obj instanceOf Class checks whether Class.prototype is equal to one of the prototypes in the obj prototype chain.\n\nIn other words, compare one after another:\n\nobj.__proto__ === Class.prototype?\nobj.__proto__.__proto__ === Class.prototype?\nobj.__proto__.__proto__.__proto__ === Class.prototype?\n...\n// if any answer is true, return true\n// otherwise, if we reached the end of the chain, return false\n\nIn the example above rabbit.__proto__ === Rabbit.prototype, so that gives the answer immediately.\n\nIn the case of an inheritance, the match will be at the second step:\n\n\t\nclass Animal {}\nclass Rabbit extends Animal {}\n\nlet rabbit = new Rabbit();\nalert(rabbit instanceof Animal); // true\n\n// rabbit.__proto__ === Animal.prototype (no match)\n// rabbit.__proto__.__proto__ === Animal.prototype (match!)\n\nHere’s the illustration of what rabbit instanceof Animal compares with Animal.prototype:\n\nBy the way, there’s also a method objA.isPrototypeOf(objB), that returns true if objA is somewhere in the chain of prototypes for objB. So the test of obj instanceof Class can be rephrased as Class.prototype.isPrototypeOf(obj).\n\nIt’s funny, but the Class constructor itself does not participate in the check! Only the chain of prototypes and Class.prototype matters.\n\nThat can lead to interesting consequences when a prototype property is changed after the object is created.\n\nLike here:\n\n\t\nfunction Rabbit() {}\nlet rabbit = new Rabbit();\n\n// changed the prototype\nRabbit.prototype = {};\n\n// ...not a rabbit any more!\nalert( rabbit instanceof Rabbit ); // false\nBonus: Object.prototype.toString for the type\n\nWe already know that plain objects are converted to string as [object Object]:\n\n\t\nlet obj = {};\n\nalert(obj); // [object Object]\nalert(obj.toString()); // the same\n\nThat’s their implementation of toString. But there’s a hidden feature that makes toString actually much more powerful than that. We can use it as an extended typeof and an alternative for instanceof.\n\nSounds strange? Indeed. Let’s demystify.\n\nBy specification, the built-in toString can be extracted from the object and executed in the context of any other value. And its result depends on that value.\n\nFor a number, it will be [object Number]\nFor a boolean, it will be [object Boolean]\nFor null: [object Null]\nFor undefined: [object Undefined]\nFor arrays: [object Array]\n…etc (customizable).\n\nLet’s demonstrate:\n\n\t\n// copy toString method into a variable for convenience\nlet objectToString = Object.prototype.toString;\n\n// what type is this?\nlet arr = [];\n\nalert( objectToString.call(arr) ); // [object Array]\n\nHere we used call as described in the chapter Decorators and forwarding, call/apply to execute the function objectToString in the context this=arr.\n\nInternally, the toString algorithm examines this and returns the corresponding result. More examples:\n\n\t\nlet s = Object.prototype.toString;\n\nalert( s.call(123) ); // [object Number]\nalert( s.call(null) ); // [object Null]\nalert( s.call(alert) ); // [object Function]\nSymbol.toStringTag\n\nThe behavior of Object toString can be customized using a special object property Symbol.toStringTag.\n\nFor instance:\n\n\t\nlet user = {\n  [Symbol.toStringTag]: \"User\"\n};\n\nalert( {}.toString.call(user) ); // [object User]\n\nFor most environment-specific objects, there is such a property. Here are some browser specific examples:\n\n\t\n// toStringTag for the environment-specific object and class:\nalert( window[Symbol.toStringTag]); // Window\nalert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest\n\nalert( {}.toString.call(window) ); // [object Window]\nalert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]\n\nAs you can see, the result is exactly Symbol.toStringTag (if exists), wrapped into [object ...].\n\nAt the end we have “typeof on steroids” that not only works for primitive data types, but also for built-in objects and even can be customized.\n\nWe can use {}.toString.call instead of instanceof for built-in objects when we want to get the type as a string rather than just to check.\n\nSummary\n\nLet’s summarize the type-checking methods that we know:\n\n\tworks for\treturns\ntypeof\tprimitives\tstring\n{}.toString\tprimitives, built-in objects, objects with Symbol.toStringTag\tstring\ninstanceof\tobjects\ttrue/false\n\nAs we can see, {}.toString is technically a “more advanced” typeof.\n\nAnd instanceof operator really shines when we are working with a class hierarchy and want to check for the class taking into account inheritance.\n\nTasks\nStrange instanceof\nimportance: 5\n\nIn the code below, why does instanceof return true? We can easily see that a is not created by B().\n\n\t\nfunction A() {}\nfunction B() {}\n\nA.prototype = B.prototype = {};\n\nlet a = new A();\n\nalert( a instanceof B ); // true\nsolution"
  },
  {
    "title": "Private and protected properties and methods",
    "url": "https://javascript.info/private-protected-properties-methods",
    "html": "One of the most important principles of object oriented programming – delimiting internal interface from the external one.\n\nThat is “a must” practice in developing anything more complex than a “hello world” app.\n\nTo understand this, let’s break away from development and turn our eyes into the real world.\n\nUsually, devices that we’re using are quite complex. But delimiting the internal interface from the external one allows to use them without problems.\n\nA real-life example\n\nFor instance, a coffee machine. Simple from outside: a button, a display, a few holes…And, surely, the result – great coffee! :)\n\nBut inside… (a picture from the repair manual)\n\nA lot of details. But we can use it without knowing anything.\n\nCoffee machines are quite reliable, aren’t they? We can use one for years, and only if something goes wrong – bring it for repairs.\n\nThe secret of reliability and simplicity of a coffee machine – all details are well-tuned and hidden inside.\n\nIf we remove the protective cover from the coffee machine, then using it will be much more complex (where to press?), and dangerous (it can electrocute).\n\nAs we’ll see, in programming objects are like coffee machines.\n\nBut in order to hide inner details, we’ll use not a protective cover, but rather special syntax of the language and conventions.\n\nInternal and external interface\n\nIn object-oriented programming, properties and methods are split into two groups:\n\nInternal interface – methods and properties, accessible from other methods of the class, but not from the outside.\nExternal interface – methods and properties, accessible also from outside the class.\n\nIf we continue the analogy with the coffee machine – what’s hidden inside: a boiler tube, heating element, and so on – is its internal interface.\n\nAn internal interface is used for the object to work, its details use each other. For instance, a boiler tube is attached to the heating element.\n\nBut from the outside a coffee machine is closed by the protective cover, so that no one can reach those. Details are hidden and inaccessible. We can use its features via the external interface.\n\nSo, all we need to use an object is to know its external interface. We may be completely unaware how it works inside, and that’s great.\n\nThat was a general introduction.\n\nIn JavaScript, there are two types of object fields (properties and methods):\n\nPublic: accessible from anywhere. They comprise the external interface. Until now we were only using public properties and methods.\nPrivate: accessible only from inside the class. These are for the internal interface.\n\nIn many other languages there also exist “protected” fields: accessible only from inside the class and those extending it (like private, but plus access from inheriting classes). They are also useful for the internal interface. They are in a sense more widespread than private ones, because we usually want inheriting classes to gain access to them.\n\nProtected fields are not implemented in JavaScript on the language level, but in practice they are very convenient, so they are emulated.\n\nNow we’ll make a coffee machine in JavaScript with all these types of properties. A coffee machine has a lot of details, we won’t model them to stay simple (though we could).\n\nProtecting “waterAmount”\n\nLet’s make a simple coffee machine class first:\n\n\t\nclass CoffeeMachine {\n  waterAmount = 0; // the amount of water inside\n\n  constructor(power) {\n    this.power = power;\n    alert( `Created a coffee-machine, power: ${power}` );\n  }\n\n}\n\n// create the coffee machine\nlet coffeeMachine = new CoffeeMachine(100);\n\n// add water\ncoffeeMachine.waterAmount = 200;\n\nRight now the properties waterAmount and power are public. We can easily get/set them from the outside to any value.\n\nLet’s change waterAmount property to protected to have more control over it. For instance, we don’t want anyone to set it below zero.\n\nProtected properties are usually prefixed with an underscore _.\n\nThat is not enforced on the language level, but there’s a well-known convention between programmers that such properties and methods should not be accessed from the outside.\n\nSo our property will be called _waterAmount:\n\n\t\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  set waterAmount(value) {\n    if (value < 0) {\n      value = 0;\n    }\n    this._waterAmount = value;\n  }\n\n  get waterAmount() {\n    return this._waterAmount;\n  }\n\n  constructor(power) {\n    this._power = power;\n  }\n\n}\n\n// create the coffee machine\nlet coffeeMachine = new CoffeeMachine(100);\n\n// add water\ncoffeeMachine.waterAmount = -10; // _waterAmount will become 0, not -10\n\nNow the access is under control, so setting the water amount below zero becomes impossible.\n\nRead-only “power”\n\nFor power property, let’s make it read-only. It sometimes happens that a property must be set at creation time only, and then never modified.\n\nThat’s exactly the case for a coffee machine: power never changes.\n\nTo do so, we only need to make getter, but not the setter:\n\n\t\nclass CoffeeMachine {\n  // ...\n\n  constructor(power) {\n    this._power = power;\n  }\n\n  get power() {\n    return this._power;\n  }\n\n}\n\n// create the coffee machine\nlet coffeeMachine = new CoffeeMachine(100);\n\nalert(`Power is: ${coffeeMachine.power}W`); // Power is: 100W\n\ncoffeeMachine.power = 25; // Error (no setter)\nGetter/setter functions\n\nHere we used getter/setter syntax.\n\nBut most of the time get.../set... functions are preferred, like this:\n\nclass CoffeeMachine {\n  _waterAmount = 0;\n\n  setWaterAmount(value) {\n    if (value < 0) value = 0;\n    this._waterAmount = value;\n  }\n\n  getWaterAmount() {\n    return this._waterAmount;\n  }\n}\n\nnew CoffeeMachine().setWaterAmount(100);\n\nThat looks a bit longer, but functions are more flexible. They can accept multiple arguments (even if we don’t need them right now).\n\nOn the other hand, get/set syntax is shorter, so ultimately there’s no strict rule, it’s up to you to decide.\n\nProtected fields are inherited\n\nIf we inherit class MegaMachine extends CoffeeMachine, then nothing prevents us from accessing this._waterAmount or this._power from the methods of the new class.\n\nSo protected fields are naturally inheritable. Unlike private ones that we’ll see below.\n\nPrivate “#waterLimit”\nA recent addition\nThis is a recent addition to the language. Not supported in JavaScript engines, or supported partially yet, requires polyfilling.\n\nThere’s a finished JavaScript proposal, almost in the standard, that provides language-level support for private properties and methods.\n\nPrivates should start with #. They are only accessible from inside the class.\n\nFor instance, here’s a private #waterLimit property and the water-checking private method #fixWaterAmount:\n\n\t\nclass CoffeeMachine {\n  #waterLimit = 200;\n\n  #fixWaterAmount(value) {\n    if (value < 0) return 0;\n    if (value > this.#waterLimit) return this.#waterLimit;\n  }\n\n  setWaterAmount(value) {\n    this.#waterLimit = this.#fixWaterAmount(value);\n  }\n\n}\n\nlet coffeeMachine = new CoffeeMachine();\n\n// can't access privates from outside of the class\ncoffeeMachine.#fixWaterAmount(123); // Error\ncoffeeMachine.#waterLimit = 1000; // Error\n\nOn the language level, # is a special sign that the field is private. We can’t access it from outside or from inheriting classes.\n\nPrivate fields do not conflict with public ones. We can have both private #waterAmount and public waterAmount fields at the same time.\n\nFor instance, let’s make waterAmount an accessor for #waterAmount:\n\n\t\nclass CoffeeMachine {\n\n  #waterAmount = 0;\n\n  get waterAmount() {\n    return this.#waterAmount;\n  }\n\n  set waterAmount(value) {\n    if (value < 0) value = 0;\n    this.#waterAmount = value;\n  }\n}\n\nlet machine = new CoffeeMachine();\n\nmachine.waterAmount = 100;\nalert(machine.#waterAmount); // Error\n\nUnlike protected ones, private fields are enforced by the language itself. That’s a good thing.\n\nBut if we inherit from CoffeeMachine, then we’ll have no direct access to #waterAmount. We’ll need to rely on waterAmount getter/setter:\n\nclass MegaCoffeeMachine extends CoffeeMachine {\n  method() {\n    alert( this.#waterAmount ); // Error: can only access from CoffeeMachine\n  }\n}\n\nIn many scenarios such limitation is too severe. If we extend a CoffeeMachine, we may have legitimate reasons to access its internals. That’s why protected fields are used more often, even though they are not supported by the language syntax.\n\nPrivate fields are not available as this[name]\n\nPrivate fields are special.\n\nAs we know, usually we can access fields using this[name]:\n\nclass User {\n  ...\n  sayHi() {\n    let fieldName = \"name\";\n    alert(`Hello, ${this[fieldName]}`);\n  }\n}\n\nWith private fields that’s impossible: this['#name'] doesn’t work. That’s a syntax limitation to ensure privacy.\n\nSummary\n\nIn terms of OOP, delimiting of the internal interface from the external one is called encapsulation.\n\nIt gives the following benefits:\n\nProtection for users, so that they don’t shoot themselves in the foot\n\nImagine, there’s a team of developers using a coffee machine. It was made by the “Best CoffeeMachine” company, and works fine, but a protective cover was removed. So the internal interface is exposed.\n\nAll developers are civilized – they use the coffee machine as intended. But one of them, John, decided that he’s the smartest one, and made some tweaks in the coffee machine internals. So the coffee machine failed two days later.\n\nThat’s surely not John’s fault, but rather the person who removed the protective cover and let John do his manipulations.\n\nThe same in programming. If a user of a class will change things not intended to be changed from the outside – the consequences are unpredictable.\n\nSupportable\n\nThe situation in programming is more complex than with a real-life coffee machine, because we don’t just buy it once. The code constantly undergoes development and improvement.\n\nIf we strictly delimit the internal interface, then the developer of the class can freely change its internal properties and methods, even without informing the users.\n\nIf you’re a developer of such class, it’s great to know that private methods can be safely renamed, their parameters can be changed, and even removed, because no external code depends on them.\n\nFor users, when a new version comes out, it may be a total overhaul internally, but still simple to upgrade if the external interface is the same.\n\nHiding complexity\n\nPeople adore using things that are simple. At least from outside. What’s inside is a different thing.\n\nProgrammers are not an exception.\n\nIt’s always convenient when implementation details are hidden, and a simple, well-documented external interface is available.\n\nTo hide an internal interface we use either protected or private properties:\n\nProtected fields start with _. That’s a well-known convention, not enforced at the language level. Programmers should only access a field starting with _ from its class and classes inheriting from it.\nPrivate fields start with #. JavaScript makes sure we can only access those from inside the class.\n\nRight now, private fields are not well-supported among browsers, but can be polyfilled."
  },
  {
    "title": "Class inheritance",
    "url": "https://javascript.info/class-inheritance",
    "html": "Class inheritance is a way for one class to extend another class.\n\nSo we can create new functionality on top of the existing.\n\nThe “extends” keyword\n\nLet’s say we have class Animal:\n\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  run(speed) {\n    this.speed = speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stands still.`);\n  }\n}\n\nlet animal = new Animal(\"My animal\");\n\nHere’s how we can represent animal object and Animal class graphically:\n\n…And we would like to create another class Rabbit.\n\nAs rabbits are animals, Rabbit class should be based on Animal, have access to animal methods, so that rabbits can do what “generic” animals can do.\n\nThe syntax to extend another class is: class Child extends Parent.\n\nLet’s create class Rabbit that inherits from Animal:\n\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.hide(); // White Rabbit hides!\n\nObject of Rabbit class have access both to Rabbit methods, such as rabbit.hide(), and also to Animal methods, such as rabbit.run().\n\nInternally, extends keyword works using the good old prototype mechanics. It sets Rabbit.prototype.[[Prototype]] to Animal.prototype. So, if a method is not found in Rabbit.prototype, JavaScript takes it from Animal.prototype.\n\nFor instance, to find rabbit.run method, the engine checks (bottom-up on the picture):\n\nThe rabbit object (has no run).\nIts prototype, that is Rabbit.prototype (has hide, but not run).\nIts prototype, that is (due to extends) Animal.prototype, that finally has the run method.\n\nAs we can recall from the chapter Native prototypes, JavaScript itself uses prototypal inheritance for built-in objects. E.g. Date.prototype.[[Prototype]] is Object.prototype. That’s why dates have access to generic object methods.\n\nAny expression is allowed after extends\n\nClass syntax allows to specify not just a class, but any expression after extends.\n\nFor instance, a function call that generates the parent class:\n\n\t\nfunction f(phrase) {\n  return class {\n    sayHi() { alert(phrase); }\n  };\n}\n\nclass User extends f(\"Hello\") {}\n\nnew User().sayHi(); // Hello\n\nHere class User inherits from the result of f(\"Hello\").\n\nThat may be useful for advanced programming patterns when we use functions to generate classes depending on many conditions and can inherit from them.\n\nOverriding a method\n\nNow let’s move forward and override a method. By default, all methods that are not specified in class Rabbit are taken directly “as is” from class Animal.\n\nBut if we specify our own method in Rabbit, such as stop() then it will be used instead:\n\nclass Rabbit extends Animal {\n  stop() {\n    // ...now this will be used for rabbit.stop()\n    // instead of stop() from class Animal\n  }\n}\n\nUsually, however, we don’t want to totally replace a parent method, but rather to build on top of it to tweak or extend its functionality. We do something in our method, but call the parent method before/after it or in the process.\n\nClasses provide \"super\" keyword for that.\n\nsuper.method(...) to call a parent method.\nsuper(...) to call a parent constructor (inside our constructor only).\n\nFor instance, let our rabbit autohide when stopped:\n\n\t\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  run(speed) {\n    this.speed = speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  stop() {\n    this.speed = 0;\n    alert(`${this.name} stands still.`);\n  }\n\n}\n\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n\n  stop() {\n    super.stop(); // call parent stop\n    this.hide(); // and then hide\n  }\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nrabbit.run(5); // White Rabbit runs with speed 5.\nrabbit.stop(); // White Rabbit stands still. White Rabbit hides!\n\nNow Rabbit has the stop method that calls the parent super.stop() in the process.\n\nArrow functions have no super\n\nAs was mentioned in the chapter Arrow functions revisited, arrow functions do not have super.\n\nIf accessed, it’s taken from the outer function. For instance:\n\nclass Rabbit extends Animal {\n  stop() {\n    setTimeout(() => super.stop(), 1000); // call parent stop after 1sec\n  }\n}\n\nThe super in the arrow function is the same as in stop(), so it works as intended. If we specified a “regular” function here, there would be an error:\n\n// Unexpected super\nsetTimeout(function() { super.stop() }, 1000);\nOverriding constructor\n\nWith constructors it gets a little bit tricky.\n\nUntil now, Rabbit did not have its own constructor.\n\nAccording to the specification, if a class extends another class and has no constructor, then the following “empty” constructor is generated:\n\nclass Rabbit extends Animal {\n  // generated for extending classes without own constructors\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nAs we can see, it basically calls the parent constructor passing it all the arguments. That happens if we don’t write a constructor of our own.\n\nNow let’s add a custom constructor to Rabbit. It will specify the earLength in addition to name:\n\n\t\nclass Animal {\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n  constructor(name, earLength) {\n    this.speed = 0;\n    this.name = name;\n    this.earLength = earLength;\n  }\n\n  // ...\n}\n\n// Doesn't work!\nlet rabbit = new Rabbit(\"White Rabbit\", 10); // Error: this is not defined.\n\nWhoops! We’ve got an error. Now we can’t create rabbits. What went wrong?\n\nThe short answer is:\n\nConstructors in inheriting classes must call super(...), and (!) do it before using this.\n\n…But why? What’s going on here? Indeed, the requirement seems strange.\n\nOf course, there’s an explanation. Let’s get into details, so you’ll really understand what’s going on.\n\nIn JavaScript, there’s a distinction between a constructor function of an inheriting class (so-called “derived constructor”) and other functions. A derived constructor has a special internal property [[ConstructorKind]]:\"derived\". That’s a special internal label.\n\nThat label affects its behavior with new.\n\nWhen a regular function is executed with new, it creates an empty object and assigns it to this.\nBut when a derived constructor runs, it doesn’t do this. It expects the parent constructor to do this job.\n\nSo a derived constructor must call super in order to execute its parent (base) constructor, otherwise the object for this won’t be created. And we’ll get an error.\n\nFor the Rabbit constructor to work, it needs to call super() before using this, like here:\n\n\t\nclass Animal {\n\n  constructor(name) {\n    this.speed = 0;\n    this.name = name;\n  }\n\n  // ...\n}\n\nclass Rabbit extends Animal {\n\n  constructor(name, earLength) {\n    super(name);\n    this.earLength = earLength;\n  }\n\n  // ...\n}\n\n// now fine\nlet rabbit = new Rabbit(\"White Rabbit\", 10);\nalert(rabbit.name); // White Rabbit\nalert(rabbit.earLength); // 10\nOverriding class fields: a tricky note\nAdvanced note\n\nThis note assumes you have a certain experience with classes, maybe in other programming languages.\n\nIt provides better insight into the language and also explains the behavior that might be a source of bugs (but not very often).\n\nIf you find it difficult to understand, just go on, continue reading, then return to it some time later.\n\nWe can override not only methods, but also class fields.\n\nAlthough, there’s a tricky behavior when we access an overridden field in parent constructor, quite different from most other programming languages.\n\nConsider this example:\n\n\t\nclass Animal {\n  name = 'animal';\n\n  constructor() {\n    alert(this.name); // (*)\n  }\n}\n\nclass Rabbit extends Animal {\n  name = 'rabbit';\n}\n\nnew Animal(); // animal\nnew Rabbit(); // animal\n\nHere, class Rabbit extends Animal and overrides the name field with its own value.\n\nThere’s no own constructor in Rabbit, so Animal constructor is called.\n\nWhat’s interesting is that in both cases: new Animal() and new Rabbit(), the alert in the line (*) shows animal.\n\nIn other words, the parent constructor always uses its own field value, not the overridden one.\n\nWhat’s odd about it?\n\nIf it’s not clear yet, please compare with methods.\n\nHere’s the same code, but instead of this.name field we call this.showName() method:\n\n\t\nclass Animal {\n  showName() {  // instead of this.name = 'animal'\n    alert('animal');\n  }\n\n  constructor() {\n    this.showName(); // instead of alert(this.name);\n  }\n}\n\nclass Rabbit extends Animal {\n  showName() {\n    alert('rabbit');\n  }\n}\n\nnew Animal(); // animal\nnew Rabbit(); // rabbit\n\nPlease note: now the output is different.\n\nAnd that’s what we naturally expect. When the parent constructor is called in the derived class, it uses the overridden method.\n\n…But for class fields it’s not so. As said, the parent constructor always uses the parent field.\n\nWhy is there a difference?\n\nWell, the reason is the field initialization order. The class field is initialized:\n\nBefore constructor for the base class (that doesn’t extend anything),\nImmediately after super() for the derived class.\n\nIn our case, Rabbit is the derived class. There’s no constructor() in it. As said previously, that’s the same as if there was an empty constructor with only super(...args).\n\nSo, new Rabbit() calls super(), thus executing the parent constructor, and (per the rule for derived classes) only after that its class fields are initialized. At the time of the parent constructor execution, there are no Rabbit class fields yet, that’s why Animal fields are used.\n\nThis subtle difference between fields and methods is specific to JavaScript.\n\nLuckily, this behavior only reveals itself if an overridden field is used in the parent constructor. Then it may be difficult to understand what’s going on, so we’re explaining it here.\n\nIf it becomes a problem, one can fix it by using methods or getters/setters instead of fields.\n\nSuper: internals, [[HomeObject]]\nAdvanced information\n\nIf you’re reading the tutorial for the first time – this section may be skipped.\n\nIt’s about the internal mechanisms behind inheritance and super.\n\nLet’s get a little deeper under the hood of super. We’ll see some interesting things along the way.\n\nFirst to say, from all that we’ve learned till now, it’s impossible for super to work at all!\n\nYeah, indeed, let’s ask ourselves, how it should technically work? When an object method runs, it gets the current object as this. If we call super.method() then, the engine needs to get the method from the prototype of the current object. But how?\n\nThe task may seem simple, but it isn’t. The engine knows the current object this, so it could get the parent method as this.__proto__.method. Unfortunately, such a “naive” solution won’t work.\n\nLet’s demonstrate the problem. Without classes, using plain objects for the sake of simplicity.\n\nYou may skip this part and go below to the [[HomeObject]] subsection if you don’t want to know the details. That won’t harm. Or read on if you’re interested in understanding things in-depth.\n\nIn the example below, rabbit.__proto__ = animal. Now let’s try: in rabbit.eat() we’ll call animal.eat(), using this.__proto__:\n\n\t\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {\n    // that's how super.eat() could presumably work\n    this.__proto__.eat.call(this); // (*)\n  }\n};\n\nrabbit.eat(); // Rabbit eats.\n\nAt the line (*) we take eat from the prototype (animal) and call it in the context of the current object. Please note that .call(this) is important here, because a simple this.__proto__.eat() would execute parent eat in the context of the prototype, not the current object.\n\nAnd in the code above it actually works as intended: we have the correct alert.\n\nNow let’s add one more object to the chain. We’ll see how things break:\n\n\t\nlet animal = {\n  name: \"Animal\",\n  eat() {\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat() {\n    // ...bounce around rabbit-style and call parent (animal) method\n    this.__proto__.eat.call(this); // (*)\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  eat() {\n    // ...do something with long ears and call parent (rabbit) method\n    this.__proto__.eat.call(this); // (**)\n  }\n};\n\nlongEar.eat(); // Error: Maximum call stack size exceeded\n\nThe code doesn’t work anymore! We can see the error trying to call longEar.eat().\n\nIt may be not that obvious, but if we trace longEar.eat() call, then we can see why. In both lines (*) and (**) the value of this is the current object (longEar). That’s essential: all object methods get the current object as this, not a prototype or something.\n\nSo, in both lines (*) and (**) the value of this.__proto__ is exactly the same: rabbit. They both call rabbit.eat without going up the chain in the endless loop.\n\nHere’s the picture of what happens:\n\nInside longEar.eat(), the line (**) calls rabbit.eat providing it with this=longEar.\n\n// inside longEar.eat() we have this = longEar\nthis.__proto__.eat.call(this) // (**)\n// becomes\nlongEar.__proto__.eat.call(this)\n// that is\nrabbit.eat.call(this);\n\nThen in the line (*) of rabbit.eat, we’d like to pass the call even higher in the chain, but this=longEar, so this.__proto__.eat is again rabbit.eat!\n\n// inside rabbit.eat() we also have this = longEar\nthis.__proto__.eat.call(this) // (*)\n// becomes\nlongEar.__proto__.eat.call(this)\n// or (again)\nrabbit.eat.call(this);\n\n…So rabbit.eat calls itself in the endless loop, because it can’t ascend any further.\n\nThe problem can’t be solved by using this alone.\n\n[[HomeObject]]\n\nTo provide the solution, JavaScript adds one more special internal property for functions: [[HomeObject]].\n\nWhen a function is specified as a class or object method, its [[HomeObject]] property becomes that object.\n\nThen super uses it to resolve the parent prototype and its methods.\n\nLet’s see how it works, first with plain objects:\n\n\t\nlet animal = {\n  name: \"Animal\",\n  eat() {         // animal.eat.[[HomeObject]] == animal\n    alert(`${this.name} eats.`);\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  name: \"Rabbit\",\n  eat() {         // rabbit.eat.[[HomeObject]] == rabbit\n    super.eat();\n  }\n};\n\nlet longEar = {\n  __proto__: rabbit,\n  name: \"Long Ear\",\n  eat() {         // longEar.eat.[[HomeObject]] == longEar\n    super.eat();\n  }\n};\n\n// works correctly\nlongEar.eat();  // Long Ear eats.\n\nIt works as intended, due to [[HomeObject]] mechanics. A method, such as longEar.eat, knows its [[HomeObject]] and takes the parent method from its prototype. Without any use of this.\n\nMethods are not “free”\n\nAs we’ve known before, generally functions are “free”, not bound to objects in JavaScript. So they can be copied between objects and called with another this.\n\nThe very existence of [[HomeObject]] violates that principle, because methods remember their objects. [[HomeObject]] can’t be changed, so this bond is forever.\n\nThe only place in the language where [[HomeObject]] is used – is super. So, if a method does not use super, then we can still consider it free and copy between objects. But with super things may go wrong.\n\nHere’s the demo of a wrong super result after copying:\n\n\t\nlet animal = {\n  sayHi() {\n    alert(`I'm an animal`);\n  }\n};\n\n// rabbit inherits from animal\nlet rabbit = {\n  __proto__: animal,\n  sayHi() {\n    super.sayHi();\n  }\n};\n\nlet plant = {\n  sayHi() {\n    alert(\"I'm a plant\");\n  }\n};\n\n// tree inherits from plant\nlet tree = {\n  __proto__: plant,\n  sayHi: rabbit.sayHi // (*)\n};\n\ntree.sayHi();  // I'm an animal (?!?)\n\nA call to tree.sayHi() shows “I’m an animal”. Definitely wrong.\n\nThe reason is simple:\n\nIn the line (*), the method tree.sayHi was copied from rabbit. Maybe we just wanted to avoid code duplication?\nIts [[HomeObject]] is rabbit, as it was created in rabbit. There’s no way to change [[HomeObject]].\nThe code of tree.sayHi() has super.sayHi() inside. It goes up from rabbit and takes the method from animal.\n\nHere’s the diagram of what happens:\n\nMethods, not function properties\n\n[[HomeObject]] is defined for methods both in classes and in plain objects. But for objects, methods must be specified exactly as method(), not as \"method: function()\".\n\nThe difference may be non-essential for us, but it’s important for JavaScript.\n\nIn the example below a non-method syntax is used for comparison. [[HomeObject]] property is not set and the inheritance doesn’t work:\n\n\t\nlet animal = {\n  eat: function() { // intentionally writing like this instead of eat() {...\n    // ...\n  }\n};\n\nlet rabbit = {\n  __proto__: animal,\n  eat: function() {\n    super.eat();\n  }\n};\n\nrabbit.eat();  // Error calling super (because there's no [[HomeObject]])\nSummary\nTo extend a class: class Child extends Parent:\nThat means Child.prototype.__proto__ will be Parent.prototype, so methods are inherited.\nWhen overriding a constructor:\nWe must call parent constructor as super() in Child constructor before using this.\nWhen overriding another method:\nWe can use super.method() in a Child method to call Parent method.\nInternals:\nMethods remember their class/object in the internal [[HomeObject]] property. That’s how super resolves parent methods.\nSo it’s not safe to copy a method with super from one object to another.\n\nAlso:\n\nArrow functions don’t have their own this or super, so they transparently fit into the surrounding context.\nTasks\nError creating an instance\nimportance: 5\n\nHere’s the code with Rabbit extending Animal.\n\nUnfortunately, Rabbit objects can’t be created. What’s wrong? Fix it.\n\n\t\nclass Animal {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nclass Rabbit extends Animal {\n  constructor(name) {\n    this.name = name;\n    this.created = Date.now();\n  }\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\"); // Error: this is not defined\nalert(rabbit.name);\nsolution\nExtended clock\nimportance: 5\n\nWe’ve got a Clock class. As of now, it prints the time every second.\n\nclass Clock {\n  constructor({ template }) {\n    this.template = template;\n  }\n\n  render() {\n    let date = new Date();\n\n    let hours = date.getHours();\n    if (hours < 10) hours = '0' + hours;\n\n    let mins = date.getMinutes();\n    if (mins < 10) mins = '0' + mins;\n\n    let secs = date.getSeconds();\n    if (secs < 10) secs = '0' + secs;\n\n    let output = this.template\n      .replace('h', hours)\n      .replace('m', mins)\n      .replace('s', secs);\n\n    console.log(output);\n  }\n\n  stop() {\n    clearInterval(this.timer);\n  }\n\n  start() {\n    this.render();\n    this.timer = setInterval(() => this.render(), 1000);\n  }\n}\n\nCreate a new class ExtendedClock that inherits from Clock and adds the parameter precision – the number of ms between “ticks”. Should be 1000 (1 second) by default.\n\nYour code should be in the file extended-clock.js\nDon’t modify the original clock.js. Extend it.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Static properties and methods",
    "url": "https://javascript.info/static-properties-methods",
    "html": "We can also assign a method to the class as a whole. Such methods are called static.\n\nIn a class declaration, they are prepended by static keyword, like this:\n\n\t\nclass User {\n  static staticMethod() {\n    alert(this === User);\n  }\n}\n\nUser.staticMethod(); // true\n\nThat actually does the same as assigning it as a property directly:\n\n\t\nclass User { }\n\nUser.staticMethod = function() {\n  alert(this === User);\n};\n\nUser.staticMethod(); // true\n\nThe value of this in User.staticMethod() call is the class constructor User itself (the “object before dot” rule).\n\nUsually, static methods are used to implement functions that belong to the class as a whole, but not to any particular object of it.\n\nFor instance, we have Article objects and need a function to compare them.\n\nA natural solution would be to add Article.compare static method:\n\n\t\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n  static compare(articleA, articleB) {\n    return articleA.date - articleB.date;\n  }\n}\n\n// usage\nlet articles = [\n  new Article(\"HTML\", new Date(2019, 1, 1)),\n  new Article(\"CSS\", new Date(2019, 0, 1)),\n  new Article(\"JavaScript\", new Date(2019, 11, 1))\n];\n\narticles.sort(Article.compare);\n\nalert( articles[0].title ); // CSS\n\nHere Article.compare method stands “above” articles, as a means to compare them. It’s not a method of an article, but rather of the whole class.\n\nAnother example would be a so-called “factory” method.\n\nLet’s say, we need multiple ways to create an article:\n\nCreate by given parameters (title, date etc).\nCreate an empty article with today’s date.\n…or else somehow.\n\nThe first way can be implemented by the constructor. And for the second one we can make a static method of the class.\n\nSuch as Article.createTodays() here:\n\n\t\nclass Article {\n  constructor(title, date) {\n    this.title = title;\n    this.date = date;\n  }\n\n  static createTodays() {\n    // remember, this = Article\n    return new this(\"Today's digest\", new Date());\n  }\n}\n\nlet article = Article.createTodays();\n\nalert( article.title ); // Today's digest\n\nNow every time we need to create a today’s digest, we can call Article.createTodays(). Once again, that’s not a method of an article, but a method of the whole class.\n\nStatic methods are also used in database-related classes to search/save/remove entries from the database, like this:\n\n// assuming Article is a special class for managing articles\n// static method to remove the article by id:\nArticle.remove({id: 12345});\nStatic methods aren’t available for individual objects\n\nStatic methods are callable on classes, not on individual objects.\n\nE.g. such code won’t work:\n\n// ...\narticle.createTodays(); /// Error: article.createTodays is not a function\nStatic properties\nA recent addition\nThis is a recent addition to the language. Examples work in the recent Chrome.\n\nStatic properties are also possible, they look like regular class properties, but prepended by static:\n\n\t\nclass Article {\n  static publisher = \"Ilya Kantor\";\n}\n\nalert( Article.publisher ); // Ilya Kantor\n\nThat is the same as a direct assignment to Article:\n\nArticle.publisher = \"Ilya Kantor\";\nInheritance of static properties and methods\n\nStatic properties and methods are inherited.\n\nFor instance, Animal.compare and Animal.planet in the code below are inherited and accessible as Rabbit.compare and Rabbit.planet:\n\n\t\nclass Animal {\n  static planet = \"Earth\";\n\n  constructor(name, speed) {\n    this.speed = speed;\n    this.name = name;\n  }\n\n  run(speed = 0) {\n    this.speed += speed;\n    alert(`${this.name} runs with speed ${this.speed}.`);\n  }\n\n  static compare(animalA, animalB) {\n    return animalA.speed - animalB.speed;\n  }\n\n}\n\n// Inherit from Animal\nclass Rabbit extends Animal {\n  hide() {\n    alert(`${this.name} hides!`);\n  }\n}\n\nlet rabbits = [\n  new Rabbit(\"White Rabbit\", 10),\n  new Rabbit(\"Black Rabbit\", 5)\n];\n\nrabbits.sort(Rabbit.compare);\n\nrabbits[0].run(); // Black Rabbit runs with speed 5.\n\nalert(Rabbit.planet); // Earth\n\nNow when we call Rabbit.compare, the inherited Animal.compare will be called.\n\nHow does it work? Again, using prototypes. As you might have already guessed, extends gives Rabbit the [[Prototype]] reference to Animal.\n\nSo, Rabbit extends Animal creates two [[Prototype]] references:\n\nRabbit function prototypally inherits from Animal function.\nRabbit.prototype prototypally inherits from Animal.prototype.\n\nAs a result, inheritance works both for regular and static methods.\n\nHere, let’s check that by code:\n\n\t\nclass Animal {}\nclass Rabbit extends Animal {}\n\n// for statics\nalert(Rabbit.__proto__ === Animal); // true\n\n// for regular methods\nalert(Rabbit.prototype.__proto__ === Animal.prototype); // true\nSummary\n\nStatic methods are used for the functionality that belongs to the class “as a whole”. It doesn’t relate to a concrete class instance.\n\nFor example, a method for comparison Article.compare(article1, article2) or a factory method Article.createTodays().\n\nThey are labeled by the word static in class declaration.\n\nStatic properties are used when we’d like to store class-level data, also not bound to an instance.\n\nThe syntax is:\n\nclass MyClass {\n  static property = ...;\n\n  static method() {\n    ...\n  }\n}\n\nTechnically, static declaration is the same as assigning to the class itself:\n\nMyClass.property = ...\nMyClass.method = ...\n\nStatic properties and methods are inherited.\n\nFor class B extends A the prototype of the class B itself points to A: B.[[Prototype]] = A. So if a field is not found in B, the search continues in A.\n\nTasks\nClass extends Object?\nimportance: 3\n\nAs we know, all objects normally inherit from Object.prototype and get access to “generic” object methods like hasOwnProperty etc.\n\nFor instance:\n\n\t\nclass Rabbit {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\n// hasOwnProperty method is from Object.prototype\nalert( rabbit.hasOwnProperty('name') ); // true\n\nBut if we spell it out explicitly like \"class Rabbit extends Object\", then the result would be different from a simple \"class Rabbit\"?\n\nWhat’s the difference?\n\nHere’s an example of such code (it doesn’t work – why? fix it?):\n\nclass Rabbit extends Object {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nlet rabbit = new Rabbit(\"Rab\");\n\nalert( rabbit.hasOwnProperty('name') ); // Error\nsolution"
  },
  {
    "title": "Class basic syntax",
    "url": "https://javascript.info/class",
    "html": "In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).\n\nWikipedia\n\nIn practice, we often need to create many objects of the same kind, like users, or goods or whatever.\n\nAs we already know from the chapter Constructor, operator \"new\", new function can help with that.\n\nBut in the modern JavaScript, there’s a more advanced “class” construct, that introduces great new features which are useful for object-oriented programming.\n\nThe “class” syntax\n\nThe basic syntax is:\n\nclass MyClass {\n  // class methods\n  constructor() { ... }\n  method1() { ... }\n  method2() { ... }\n  method3() { ... }\n  ...\n}\n\nThen use new MyClass() to create a new object with all the listed methods.\n\nThe constructor() method is called automatically by new, so we can initialize the object there.\n\nFor example:\n\n\t\nclass User {\n\n  constructor(name) {\n    this.name = name;\n  }\n\n  sayHi() {\n    alert(this.name);\n  }\n\n}\n\n// Usage:\nlet user = new User(\"John\");\nuser.sayHi();\n\nWhen new User(\"John\") is called:\n\nA new object is created.\nThe constructor runs with the given argument and assigns it to this.name.\n\n…Then we can call object methods, such as user.sayHi().\n\nNo comma between class methods\n\nA common pitfall for novice developers is to put a comma between class methods, which would result in a syntax error.\n\nThe notation here is not to be confused with object literals. Within the class, no commas are required.\n\nWhat is a class?\n\nSo, what exactly is a class? That’s not an entirely new language-level entity, as one might think.\n\nLet’s unveil any magic and see what a class really is. That’ll help in understanding many complex aspects.\n\nIn JavaScript, a class is a kind of function.\n\nHere, take a look:\n\n\t\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// proof: User is a function\nalert(typeof User); // function\n\nWhat class User {...} construct really does is:\n\nCreates a function named User, that becomes the result of the class declaration. The function code is taken from the constructor method (assumed empty if we don’t write such method).\nStores class methods, such as sayHi, in User.prototype.\n\nAfter new User object is created, when we call its method, it’s taken from the prototype, just as described in the chapter F.prototype. So the object has access to class methods.\n\nWe can illustrate the result of class User declaration as:\n\nHere’s the code to introspect it:\n\n\t\nclass User {\n  constructor(name) { this.name = name; }\n  sayHi() { alert(this.name); }\n}\n\n// class is a function\nalert(typeof User); // function\n\n// ...or, more precisely, the constructor method\nalert(User === User.prototype.constructor); // true\n\n// The methods are in User.prototype, e.g:\nalert(User.prototype.sayHi); // the code of the sayHi method\n\n// there are exactly two methods in the prototype\nalert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi\nNot just a syntactic sugar\n\nSometimes people say that class is a “syntactic sugar” (syntax that is designed to make things easier to read, but doesn’t introduce anything new), because we could actually declare the same thing without using the class keyword at all:\n\n\t\n// rewriting class User in pure functions\n\n// 1. Create constructor function\nfunction User(name) {\n  this.name = name;\n}\n// a function prototype has \"constructor\" property by default,\n// so we don't need to create it\n\n// 2. Add the method to prototype\nUser.prototype.sayHi = function() {\n  alert(this.name);\n};\n\n// Usage:\nlet user = new User(\"John\");\nuser.sayHi();\n\nThe result of this definition is about the same. So, there are indeed reasons why class can be considered a syntactic sugar to define a constructor together with its prototype methods.\n\nStill, there are important differences.\n\nFirst, a function created by class is labelled by a special internal property [[IsClassConstructor]]: true. So it’s not entirely the same as creating it manually.\n\nThe language checks for that property in a variety of places. For example, unlike a regular function, it must be called with new:\n\n\t\nclass User {\n  constructor() {}\n}\n\nalert(typeof User); // function\nUser(); // Error: Class constructor User cannot be invoked without 'new'\n\nAlso, a string representation of a class constructor in most JavaScript engines starts with the “class…”\n\n\t\nclass User {\n  constructor() {}\n}\n\nalert(User); // class User { ... }\n\nThere are other differences, we’ll see them soon.\n\nClass methods are non-enumerable. A class definition sets enumerable flag to false for all methods in the \"prototype\".\n\nThat’s good, because if we for..in over an object, we usually don’t want its class methods.\n\nClasses always use strict. All code inside the class construct is automatically in strict mode.\n\nBesides, class syntax brings many other features that we’ll explore later.\n\nClass Expression\n\nJust like functions, classes can be defined inside another expression, passed around, returned, assigned, etc.\n\nHere’s an example of a class expression:\n\nlet User = class {\n  sayHi() {\n    alert(\"Hello\");\n  }\n};\n\nSimilar to Named Function Expressions, class expressions may have a name.\n\nIf a class expression has a name, it’s visible inside the class only:\n\n\t\n// \"Named Class Expression\"\n// (no such term in the spec, but that's similar to Named Function Expression)\nlet User = class MyClass {\n  sayHi() {\n    alert(MyClass); // MyClass name is visible only inside the class\n  }\n};\n\nnew User().sayHi(); // works, shows MyClass definition\n\nalert(MyClass); // error, MyClass name isn't visible outside of the class\n\nWe can even make classes dynamically “on-demand”, like this:\n\n\t\nfunction makeClass(phrase) {\n  // declare a class and return it\n  return class {\n    sayHi() {\n      alert(phrase);\n    }\n  };\n}\n\n// Create a new class\nlet User = makeClass(\"Hello\");\n\nnew User().sayHi(); // Hello\nGetters/setters\n\nJust like literal objects, classes may include getters/setters, computed properties etc.\n\nHere’s an example for user.name implemented using get/set:\n\n\t\nclass User {\n\n  constructor(name) {\n    // invokes the setter\n    this.name = name;\n  }\n\n  get name() {\n    return this._name;\n  }\n\n  set name(value) {\n    if (value.length < 4) {\n      alert(\"Name is too short.\");\n      return;\n    }\n    this._name = value;\n  }\n\n}\n\nlet user = new User(\"John\");\nalert(user.name); // John\n\nuser = new User(\"\"); // Name is too short.\n\nTechnically, such class declaration works by creating getters and setters in User.prototype.\n\nComputed names […]\n\nHere’s an example with a computed method name using brackets [...]:\n\n\t\nclass User {\n\n  ['say' + 'Hi']() {\n    alert(\"Hello\");\n  }\n\n}\n\nnew User().sayHi();\n\nSuch features are easy to remember, as they resemble that of literal objects.\n\nClass fields\nOld browsers may need a polyfill\n\nClass fields are a recent addition to the language.\n\nPreviously, our classes only had methods.\n\n“Class fields” is a syntax that allows to add any properties.\n\nFor instance, let’s add name property to class User:\n\n\t\nclass User {\n  name = \"John\";\n\n  sayHi() {\n    alert(`Hello, ${this.name}!`);\n  }\n}\n\nnew User().sayHi(); // Hello, John!\n\nSo, we just write \" = \" in the declaration, and that’s it.\n\nThe important difference of class fields is that they are set on individual objects, not User.prototype:\n\n\t\nclass User {\n  name = \"John\";\n}\n\nlet user = new User();\nalert(user.name); // John\nalert(User.prototype.name); // undefined\n\nWe can also assign values using more complex expressions and function calls:\n\n\t\nclass User {\n  name = prompt(\"Name, please?\", \"John\");\n}\n\nlet user = new User();\nalert(user.name); // John\nMaking bound methods with class fields\n\nAs demonstrated in the chapter Function binding functions in JavaScript have a dynamic this. It depends on the context of the call.\n\nSo if an object method is passed around and called in another context, this won’t be a reference to its object any more.\n\nFor instance, this code will show undefined:\n\n\t\nclass Button {\n  constructor(value) {\n    this.value = value;\n  }\n\n  click() {\n    alert(this.value);\n  }\n}\n\nlet button = new Button(\"hello\");\n\nsetTimeout(button.click, 1000); // undefined\n\nThe problem is called \"losing this\".\n\nThere are two approaches to fixing it, as discussed in the chapter Function binding:\n\nPass a wrapper-function, such as setTimeout(() => button.click(), 1000).\nBind the method to object, e.g. in the constructor.\n\nClass fields provide another, quite elegant syntax:\n\n\t\nclass Button {\n  constructor(value) {\n    this.value = value;\n  }\n  click = () => {\n    alert(this.value);\n  }\n}\n\nlet button = new Button(\"hello\");\n\nsetTimeout(button.click, 1000); // hello\n\nThe class field click = () => {...} is created on a per-object basis, there’s a separate function for each Button object, with this inside it referencing that object. We can pass button.click around anywhere, and the value of this will always be correct.\n\nThat’s especially useful in browser environment, for event listeners.\n\nSummary\n\nThe basic class syntax looks like this:\n\nclass MyClass {\n  prop = value; // property\n\n  constructor(...) { // constructor\n    // ...\n  }\n\n  method(...) {} // method\n\n  get something(...) {} // getter method\n  set something(...) {} // setter method\n\n  [Symbol.iterator]() {} // method with computed name (symbol here)\n  // ...\n}\n\nMyClass is technically a function (the one that we provide as constructor), while methods, getters and setters are written to MyClass.prototype.\n\nIn the next chapters we’ll learn more about classes, including inheritance and other features.\n\nTasks\nRewrite to class\nimportance: 5\n\nThe Clock class (see the sandbox) is written in functional style. Rewrite it in the “class” syntax.\n\nP.S. The clock ticks in the console, open it to see.\n\nOpen a sandbox for the task.\n\nsolution"
  },
  {
    "title": "Classes",
    "url": "https://javascript.info/classes",
    "html": "Class basic syntax\nClass inheritance\nStatic properties and methods\nPrivate and protected properties and methods\nExtending built-in classes\nClass checking: \"instanceof\"\nMixins"
  },
  {
    "title": "Prototype methods, objects without __proto__",
    "url": "https://javascript.info/prototype-methods",
    "html": "In the first chapter of this section, we mentioned that there are modern methods to setup a prototype.\n\nSetting or reading the prototype with obj.__proto__ is considered outdated and somewhat deprecated (moved to the so-called “Annex B” of the JavaScript standard, meant for browsers only).\n\nThe modern methods to get/set a prototype are:\n\nObject.getPrototypeOf(obj) – returns the [[Prototype]] of obj.\nObject.setPrototypeOf(obj, proto) – sets the [[Prototype]] of obj to proto.\n\nThe only usage of __proto__, that’s not frowned upon, is as a property when creating a new object: { __proto__: ... }.\n\nAlthough, there’s a special method for this too:\n\nObject.create(proto, [descriptors]) – creates an empty object with given proto as [[Prototype]] and optional property descriptors.\n\nFor instance:\n\n\t\nlet animal = {\n  eats: true\n};\n\n// create a new object with animal as a prototype\nlet rabbit = Object.create(animal); // same as {__proto__: animal}\n\nalert(rabbit.eats); // true\n\nalert(Object.getPrototypeOf(rabbit) === animal); // true\n\nObject.setPrototypeOf(rabbit, {}); // change the prototype of rabbit to {}\n\nThe Object.create method is a bit more powerful, as it has an optional second argument: property descriptors.\n\nWe can provide additional properties to the new object there, like this:\n\n\t\nlet animal = {\n  eats: true\n};\n\nlet rabbit = Object.create(animal, {\n  jumps: {\n    value: true\n  }\n});\n\nalert(rabbit.jumps); // true\n\nThe descriptors are in the same format as described in the chapter Property flags and descriptors.\n\nWe can use Object.create to perform an object cloning more powerful than copying properties in for..in:\n\nlet clone = Object.create(\n  Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)\n);\n\nThis call makes a truly exact copy of obj, including all properties: enumerable and non-enumerable, data properties and setters/getters – everything, and with the right [[Prototype]].\n\nBrief history\n\nThere’re so many ways to manage [[Prototype]]. How did that happen? Why?\n\nThat’s for historical reasons.\n\nThe prototypal inheritance was in the language since its dawn, but the ways to manage it evolved over time.\n\nThe prototype property of a constructor function has worked since very ancient times. It’s the oldest way to create objects with a given prototype.\nLater, in the year 2012, Object.create appeared in the standard. It gave the ability to create objects with a given prototype, but did not provide the ability to get/set it. Some browsers implemented the non-standard __proto__ accessor that allowed the user to get/set a prototype at any time, to give more flexibility to developers.\nLater, in the year 2015, Object.setPrototypeOf and Object.getPrototypeOf were added to the standard, to perform the same functionality as __proto__. As __proto__ was de-facto implemented everywhere, it was kind-of deprecated and made its way to the Annex B of the standard, that is: optional for non-browser environments.\nLater, in the year 2022, it was officially allowed to use __proto__ in object literals {...} (moved out of Annex B), but not as a getter/setter obj.__proto__ (still in Annex B).\n\nWhy was __proto__ replaced by the functions getPrototypeOf/setPrototypeOf?\n\nWhy was __proto__ partially rehabilitated and its usage allowed in {...}, but not as a getter/setter?\n\nThat’s an interesting question, requiring us to understand why __proto__ is bad.\n\nAnd soon we’ll get the answer.\n\nDon’t change [[Prototype]] on existing objects if speed matters\n\nTechnically, we can get/set [[Prototype]] at any time. But usually we only set it once at the object creation time and don’t modify it anymore: rabbit inherits from animal, and that is not going to change.\n\nAnd JavaScript engines are highly optimized for this. Changing a prototype “on-the-fly” with Object.setPrototypeOf or obj.__proto__= is a very slow operation as it breaks internal optimizations for object property access operations. So avoid it unless you know what you’re doing, or JavaScript speed totally doesn’t matter for you.\n\n\"Very plain\" objects\n\nAs we know, objects can be used as associative arrays to store key/value pairs.\n\n…But if we try to store user-provided keys in it (for instance, a user-entered dictionary), we can see an interesting glitch: all keys work fine except \"__proto__\".\n\nCheck out the example:\n\n\t\nlet obj = {};\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // [object Object], not \"some value\"!\n\nHere, if the user types in __proto__, the assignment in line 4 is ignored!\n\nThat could surely be surprising for a non-developer, but pretty understandable for us. The __proto__ property is special: it must be either an object or null. A string can not become a prototype. That’s why an assignment a string to __proto__ is ignored.\n\nBut we didn’t intend to implement such behavior, right? We want to store key/value pairs, and the key named \"__proto__\" was not properly saved. So that’s a bug!\n\nHere the consequences are not terrible. But in other cases we may be storing objects instead of strings in obj, and then the prototype will indeed be changed. As a result, the execution will go wrong in totally unexpected ways.\n\nWhat’s worse – usually developers do not think about such possibility at all. That makes such bugs hard to notice and even turn them into vulnerabilities, especially when JavaScript is used on server-side.\n\nUnexpected things also may happen when assigning to obj.toString, as it’s a built-in object method.\n\nHow can we avoid this problem?\n\nFirst, we can just switch to using Map for storage instead of plain objects, then everything’s fine:\n\n\t\nlet map = new Map();\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nmap.set(key, \"some value\");\n\nalert(map.get(key)); // \"some value\" (as intended)\n\n…But Object syntax is often more appealing, as it’s more concise.\n\nFortunately, we can use objects, because language creators gave thought to that problem long ago.\n\nAs we know, __proto__ is not a property of an object, but an accessor property of Object.prototype:\n\nSo, if obj.__proto__ is read or set, the corresponding getter/setter is called from its prototype, and it gets/sets [[Prototype]].\n\nAs it was said in the beginning of this tutorial section: __proto__ is a way to access [[Prototype]], it is not [[Prototype]] itself.\n\nNow, if we intend to use an object as an associative array and be free of such problems, we can do it with a little trick:\n\n\t\nlet obj = Object.create(null);\n// or: obj = { __proto__: null }\n\nlet key = prompt(\"What's the key?\", \"__proto__\");\nobj[key] = \"some value\";\n\nalert(obj[key]); // \"some value\"\n\nObject.create(null) creates an empty object without a prototype ([[Prototype]] is null):\n\nSo, there is no inherited getter/setter for __proto__. Now it is processed as a regular data property, so the example above works right.\n\nWe can call such objects “very plain” or “pure dictionary” objects, because they are even simpler than the regular plain object {...}.\n\nA downside is that such objects lack any built-in object methods, e.g. toString:\n\n\t\nlet obj = Object.create(null);\n\nalert(obj); // Error (no toString)\n\n…But that’s usually fine for associative arrays.\n\nNote that most object-related methods are Object.something(...), like Object.keys(obj) – they are not in the prototype, so they will keep working on such objects:\n\n\t\nlet chineseDictionary = Object.create(null);\nchineseDictionary.hello = \"你好\";\nchineseDictionary.bye = \"再见\";\n\nalert(Object.keys(chineseDictionary)); // hello,bye\nSummary\n\nTo create an object with the given prototype, use:\n\nliteral syntax: { __proto__: ... }, allows to specify multiple properties\nor Object.create(proto, [descriptors]), allows to specify property descriptors.\n\nThe Object.create provides an easy way to shallow-copy an object with all descriptors:\n\nlet clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n\nModern methods to get/set the prototype are:\n\nObject.getPrototypeOf(obj) – returns the [[Prototype]] of obj (same as __proto__ getter).\nObject.setPrototypeOf(obj, proto) – sets the [[Prototype]] of obj to proto (same as __proto__ setter).\n\nGetting/setting the prototype using the built-in __proto__ getter/setter isn’t recommended, it’s now in the Annex B of the specification.\n\nWe also covered prototype-less objects, created with Object.create(null) or {__proto__: null}.\n\nThese objects are used as dictionaries, to store any (possibly user-generated) keys.\n\nNormally, objects inherit built-in methods and __proto__ getter/setter from Object.prototype, making corresponding keys “occupied” and potentially causing side effects. With null prototype, objects are truly empty.\n\nTasks\nAdd toString to the dictionary\nimportance: 5\n\nThere’s an object dictionary, created as Object.create(null), to store any key/value pairs.\n\nAdd method dictionary.toString() into it, that should return a comma-delimited list of keys. Your toString should not show up in for..in over the object.\n\nHere’s how it should work:\n\nlet dictionary = Object.create(null);\n\n// your code to add dictionary.toString method\n\n// add some data\ndictionary.apple = \"Apple\";\ndictionary.__proto__ = \"test\"; // __proto__ is a regular property key here\n\n// only apple and __proto__ are in the loop\nfor(let key in dictionary) {\n  alert(key); // \"apple\", then \"__proto__\"\n}\n\n// your toString in action\nalert(dictionary); // \"apple,__proto__\"\nsolution\nThe difference between calls\nimportance: 5\n\nLet’s create a new rabbit object:\n\nfunction Rabbit(name) {\n  this.name = name;\n}\nRabbit.prototype.sayHi = function() {\n  alert(this.name);\n};\n\nlet rabbit = new Rabbit(\"Rabbit\");\n\nThese calls do the same thing or not?\n\nrabbit.sayHi();\nRabbit.prototype.sayHi();\nObject.getPrototypeOf(rabbit).sayHi();\nrabbit.__proto__.sayHi();\nsolution"
  },
  {
    "title": "Native prototypes",
    "url": "https://javascript.info/native-prototypes",
    "html": "The \"prototype\" property is widely used by the core of JavaScript itself. All built-in constructor functions use it.\n\nFirst we’ll look at the details, and then how to use it for adding new capabilities to built-in objects.\n\nObject.prototype\n\nLet’s say we output an empty object:\n\n\t\nlet obj = {};\nalert( obj ); // \"[object Object]\" ?\n\nWhere’s the code that generates the string \"[object Object]\"? That’s a built-in toString method, but where is it? The obj is empty!\n\n…But the short notation obj = {} is the same as obj = new Object(), where Object is a built-in object constructor function, with its own prototype referencing a huge object with toString and other methods.\n\nHere’s what’s going on:\n\nWhen new Object() is called (or a literal object {...} is created), the [[Prototype]] of it is set to Object.prototype according to the rule that we discussed in the previous chapter:\n\nSo then when obj.toString() is called the method is taken from Object.prototype.\n\nWe can check it like this:\n\n\t\nlet obj = {};\n\nalert(obj.__proto__ === Object.prototype); // true\n\nalert(obj.toString === obj.__proto__.toString); //true\nalert(obj.toString === Object.prototype.toString); //true\n\nPlease note that there is no more [[Prototype]] in the chain above Object.prototype:\n\n\t\nalert(Object.prototype.__proto__); // null\nOther built-in prototypes\n\nOther built-in objects such as Array, Date, Function and others also keep methods in prototypes.\n\nFor instance, when we create an array [1, 2, 3], the default new Array() constructor is used internally. So Array.prototype becomes its prototype and provides methods. That’s very memory-efficient.\n\nBy specification, all of the built-in prototypes have Object.prototype on the top. That’s why some people say that “everything inherits from objects”.\n\nHere’s the overall picture (for 3 built-ins to fit):\n\nLet’s check the prototypes manually:\n\n\t\nlet arr = [1, 2, 3];\n\n// it inherits from Array.prototype?\nalert( arr.__proto__ === Array.prototype ); // true\n\n// then from Object.prototype?\nalert( arr.__proto__.__proto__ === Object.prototype ); // true\n\n// and null on the top.\nalert( arr.__proto__.__proto__.__proto__ ); // null\n\nSome methods in prototypes may overlap, for instance, Array.prototype has its own toString that lists comma-delimited elements:\n\n\t\nlet arr = [1, 2, 3]\nalert(arr); // 1,2,3 <-- the result of Array.prototype.toString\n\nAs we’ve seen before, Object.prototype has toString as well, but Array.prototype is closer in the chain, so the array variant is used.\n\nIn-browser tools like Chrome developer console also show inheritance (console.dir may need to be used for built-in objects):\n\nOther built-in objects also work the same way. Even functions – they are objects of a built-in Function constructor, and their methods (call/apply and others) are taken from Function.prototype. Functions have their own toString too.\n\n\t\nfunction f() {}\n\nalert(f.__proto__ == Function.prototype); // true\nalert(f.__proto__.__proto__ == Object.prototype); // true, inherit from objects\nPrimitives\n\nThe most intricate thing happens with strings, numbers and booleans.\n\nAs we remember, they are not objects. But if we try to access their properties, temporary wrapper objects are created using built-in constructors String, Number and Boolean. They provide the methods and disappear.\n\nThese objects are created invisibly to us and most engines optimize them out, but the specification describes it exactly this way. Methods of these objects also reside in prototypes, available as String.prototype, Number.prototype and Boolean.prototype.\n\nValues null and undefined have no object wrappers\n\nSpecial values null and undefined stand apart. They have no object wrappers, so methods and properties are not available for them. And there are no corresponding prototypes either.\n\nChanging native prototypes\n\nNative prototypes can be modified. For instance, if we add a method to String.prototype, it becomes available to all strings:\n\n\t\nString.prototype.show = function() {\n  alert(this);\n};\n\n\"BOOM!\".show(); // BOOM!\n\nDuring the process of development, we may have ideas for new built-in methods we’d like to have, and we may be tempted to add them to native prototypes. But that is generally a bad idea.\n\nImportant:\n\nPrototypes are global, so it’s easy to get a conflict. If two libraries add a method String.prototype.show, then one of them will be overwriting the method of the other.\n\nSo, generally, modifying a native prototype is considered a bad idea.\n\nIn modern programming, there is only one case where modifying native prototypes is approved. That’s polyfilling.\n\nPolyfilling is a term for making a substitute for a method that exists in the JavaScript specification, but is not yet supported by a particular JavaScript engine.\n\nWe may then implement it manually and populate the built-in prototype with it.\n\nFor instance:\n\n\t\nif (!String.prototype.repeat) { // if there's no such method\n  // add it to the prototype\n\n  String.prototype.repeat = function(n) {\n    // repeat the string n times\n\n    // actually, the code should be a little bit more complex than that\n    // (the full algorithm is in the specification)\n    // but even an imperfect polyfill is often considered good enough\n    return new Array(n + 1).join(this);\n  };\n}\n\nalert( \"La\".repeat(3) ); // LaLaLa\nBorrowing from prototypes\n\nIn the chapter Decorators and forwarding, call/apply we talked about method borrowing.\n\nThat’s when we take a method from one object and copy it into another.\n\nSome methods of native prototypes are often borrowed.\n\nFor instance, if we’re making an array-like object, we may want to copy some Array methods to it.\n\nE.g.\n\n\t\nlet obj = {\n  0: \"Hello\",\n  1: \"world!\",\n  length: 2,\n};\n\nobj.join = Array.prototype.join;\n\nalert( obj.join(',') ); // Hello,world!\n\nIt works because the internal algorithm of the built-in join method only cares about the correct indexes and the length property. It doesn’t check if the object is indeed an array. Many built-in methods are like that.\n\nAnother possibility is to inherit by setting obj.__proto__ to Array.prototype, so all Array methods are automatically available in obj.\n\nBut that’s impossible if obj already inherits from another object. Remember, we only can inherit from one object at a time.\n\nBorrowing methods is flexible, it allows to mix functionalities from different objects if needed.\n\nSummary\nAll built-in objects follow the same pattern:\nThe methods are stored in the prototype (Array.prototype, Object.prototype, Date.prototype, etc.)\nThe object itself stores only the data (array items, object properties, the date)\nPrimitives also store methods in prototypes of wrapper objects: Number.prototype, String.prototype and Boolean.prototype. Only undefined and null do not have wrapper objects\nBuilt-in prototypes can be modified or populated with new methods. But it’s not recommended to change them. The only allowable case is probably when we add-in a new standard, but it’s not yet supported by the JavaScript engine\nTasks\nAdd method \"f.defer(ms)\" to functions\nimportance: 5\n\nAdd to the prototype of all functions the method defer(ms), that runs the function after ms milliseconds.\n\nAfter you do it, such code should work:\n\nfunction f() {\n  alert(\"Hello!\");\n}\n\nf.defer(1000); // shows \"Hello!\" after 1 second\nsolution\nAdd the decorating \"defer()\" to functions\nimportance: 4\n\nAdd to the prototype of all functions the method defer(ms), that returns a wrapper, delaying the call by ms milliseconds.\n\nHere’s an example of how it should work:\n\nfunction f(a, b) {\n  alert( a + b );\n}\n\nf.defer(1000)(1, 2); // shows 3 after 1 second\n\nPlease note that the arguments should be passed to the original function.\n\nsolution"
  },
  {
    "title": "F.prototype",
    "url": "https://javascript.info/function-prototype",
    "html": "Remember, new objects can be created with a constructor function, like new F().\n\nIf F.prototype is an object, then the new operator uses it to set [[Prototype]] for the new object.\n\nPlease note:\n\nJavaScript had prototypal inheritance from the beginning. It was one of the core features of the language.\n\nBut in the old times, there was no direct access to it. The only thing that worked reliably was a \"prototype\" property of the constructor function, described in this chapter. So there are many scripts that still use it.\n\nPlease note that F.prototype here means a regular property named \"prototype\" on F. It sounds something similar to the term “prototype”, but here we really mean a regular property with this name.\n\nHere’s the example:\n\n\t\nlet animal = {\n  eats: true\n};\n\nfunction Rabbit(name) {\n  this.name = name;\n}\n\nRabbit.prototype = animal;\n\nlet rabbit = new Rabbit(\"White Rabbit\"); //  rabbit.__proto__ == animal\n\nalert( rabbit.eats ); // true\n\nSetting Rabbit.prototype = animal literally states the following: \"When a new Rabbit is created, assign its [[Prototype]] to animal\".\n\nThat’s the resulting picture:\n\nOn the picture, \"prototype\" is a horizontal arrow, meaning a regular property, and [[Prototype]] is vertical, meaning the inheritance of rabbit from animal.\n\nF.prototype only used at new F time\n\nF.prototype property is only used when new F is called, it assigns [[Prototype]] of the new object.\n\nIf, after the creation, F.prototype property changes (F.prototype = <another object>), then new objects created by new F will have another object as [[Prototype]], but already existing objects keep the old one.\n\nDefault F.prototype, constructor property\n\nEvery function has the \"prototype\" property even if we don’t supply it.\n\nThe default \"prototype\" is an object with the only property constructor that points back to the function itself.\n\nLike this:\n\nfunction Rabbit() {}\n\n/* default prototype\nRabbit.prototype = { constructor: Rabbit };\n*/\n\nWe can check it:\n\n\t\nfunction Rabbit() {}\n// by default:\n// Rabbit.prototype = { constructor: Rabbit }\n\nalert( Rabbit.prototype.constructor == Rabbit ); // true\n\nNaturally, if we do nothing, the constructor property is available to all rabbits through [[Prototype]]:\n\n\t\nfunction Rabbit() {}\n// by default:\n// Rabbit.prototype = { constructor: Rabbit }\n\nlet rabbit = new Rabbit(); // inherits from {constructor: Rabbit}\n\nalert(rabbit.constructor == Rabbit); // true (from prototype)\n\nWe can use constructor property to create a new object using the same constructor as the existing one.\n\nLike here:\n\n\t\nfunction Rabbit(name) {\n  this.name = name;\n  alert(name);\n}\n\nlet rabbit = new Rabbit(\"White Rabbit\");\n\nlet rabbit2 = new rabbit.constructor(\"Black Rabbit\");\n\nThat’s handy when we have an object, don’t know which constructor was used for it (e.g. it comes from a 3rd party library), and we need to create another one of the same kind.\n\nBut probably the most important thing about \"constructor\" is that…\n\n…JavaScript itself does not ensure the right \"constructor\" value.\n\nYes, it exists in the default \"prototype\" for functions, but that’s all. What happens with it later – is totally on us.\n\nIn particular, if we replace the default prototype as a whole, then there will be no \"constructor\" in it.\n\nFor instance:\n\n\t\nfunction Rabbit() {}\nRabbit.prototype = {\n  jumps: true\n};\n\nlet rabbit = new Rabbit();\nalert(rabbit.constructor === Rabbit); // false\n\nSo, to keep the right \"constructor\" we can choose to add/remove properties to the default \"prototype\" instead of overwriting it as a whole:\n\nfunction Rabbit() {}\n\n// Not overwrite Rabbit.prototype totally\n// just add to it\nRabbit.prototype.jumps = true\n// the default Rabbit.prototype.constructor is preserved\n\nOr, alternatively, recreate the constructor property manually:\n\nRabbit.prototype = {\n  jumps: true,\n  constructor: Rabbit\n};\n\n// now constructor is also correct, because we added it\nSummary\n\nIn this chapter we briefly described the way of setting a [[Prototype]] for objects created via a constructor function. Later we’ll see more advanced programming patterns that rely on it.\n\nEverything is quite simple, just a few notes to make things clear:\n\nThe F.prototype property (don’t mistake it for [[Prototype]]) sets [[Prototype]] of new objects when new F() is called.\nThe value of F.prototype should be either an object or null: other values won’t work.\nThe \"prototype\" property only has such a special effect when set on a constructor function, and invoked with new.\n\nOn regular objects the prototype is nothing special:\n\nlet user = {\n  name: \"John\",\n  prototype: \"Bla-bla\" // no magic at all\n};\n\nBy default all functions have F.prototype = { constructor: F }, so we can get the constructor of an object by accessing its \"constructor\" property.\n\nTasks\nChanging \"prototype\"\nimportance: 5\n\nIn the code below we create new Rabbit, and then try to modify its prototype.\n\nIn the start, we have this code:\n\n\t\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\nalert( rabbit.eats ); // true\n\nWe added one more string (emphasized). What will alert show now?\n\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\nRabbit.prototype = {};\n\nalert( rabbit.eats ); // ?\n\n…And if the code is like this (replaced one line)?\n\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\nRabbit.prototype.eats = false;\n\nalert( rabbit.eats ); // ?\n\nAnd like this (replaced one line)?\n\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\ndelete rabbit.eats;\n\nalert( rabbit.eats ); // ?\n\nThe last variant:\n\nfunction Rabbit() {}\nRabbit.prototype = {\n  eats: true\n};\n\nlet rabbit = new Rabbit();\n\ndelete Rabbit.prototype.eats;\n\nalert( rabbit.eats ); // ?\nsolution\nCreate an object with the same constructor\nimportance: 5\n\nImagine, we have an arbitrary object obj, created by a constructor function – we don’t know which one, but we’d like to create a new object using it.\n\nCan we do it like that?\n\nlet obj2 = new obj.constructor();\n\nGive an example of a constructor function for obj which lets such code work right. And an example that makes it work wrong.\n\nsolution"
  },
  {
    "title": "Prototypal inheritance",
    "url": "https://javascript.info/prototype-inheritance",
    "html": "In programming, we often want to take something and extend it.\n\nFor instance, we have a user object with its properties and methods, and want to make admin and guest as slightly modified variants of it. We’d like to reuse what we have in user, not copy/reimplement its methods, just build a new object on top of it.\n\nPrototypal inheritance is a language feature that helps in that.\n\n[[Prototype]]\n\nIn JavaScript, objects have a special hidden property [[Prototype]] (as named in the specification), that is either null or references another object. That object is called “a prototype”:\n\nWhen we read a property from object, and it’s missing, JavaScript automatically takes it from the prototype. In programming, this is called “prototypal inheritance”. And soon we’ll study many examples of such inheritance, as well as cooler language features built upon it.\n\nThe property [[Prototype]] is internal and hidden, but there are many ways to set it.\n\nOne of them is to use the special name __proto__, like this:\n\n\t\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\nrabbit.__proto__ = animal; // sets rabbit.[[Prototype]] = animal\n\nNow if we read a property from rabbit, and it’s missing, JavaScript will automatically take it from animal.\n\nFor instance:\n\nlet animal = {\n  eats: true\n};\nlet rabbit = {\n  jumps: true\n};\n\nrabbit.__proto__ = animal; // (*)\n\n// we can find both properties in rabbit now:\nalert( rabbit.eats ); // true (**)\nalert( rabbit.jumps ); // true\n\nHere the line (*) sets animal to be the prototype of rabbit.\n\nThen, when alert tries to read property rabbit.eats (**), it’s not in rabbit, so JavaScript follows the [[Prototype]] reference and finds it in animal (look from the bottom up):\n\nHere we can say that \"animal is the prototype of rabbit\" or \"rabbit prototypically inherits from animal\".\n\nSo if animal has a lot of useful properties and methods, then they become automatically available in rabbit. Such properties are called “inherited”.\n\nIf we have a method in animal, it can be called on rabbit:\n\n\t\nlet animal = {\n  eats: true,\n  walk() {\n    alert(\"Animal walk\");\n  }\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n// walk is taken from the prototype\nrabbit.walk(); // Animal walk\n\nThe method is automatically taken from the prototype, like this:\n\nThe prototype chain can be longer:\n\n\t\nlet animal = {\n  eats: true,\n  walk() {\n    alert(\"Animal walk\");\n  }\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nlet longEar = {\n  earLength: 10,\n  __proto__: rabbit\n};\n\n// walk is taken from the prototype chain\nlongEar.walk(); // Animal walk\nalert(longEar.jumps); // true (from rabbit)\n\nNow if we read something from longEar, and it’s missing, JavaScript will look for it in rabbit, and then in animal.\n\nThere are only two limitations:\n\nThe references can’t go in circles. JavaScript will throw an error if we try to assign __proto__ in a circle.\nThe value of __proto__ can be either an object or null. Other types are ignored.\n\nAlso it may be obvious, but still: there can be only one [[Prototype]]. An object may not inherit from two others.\n\n__proto__ is a historical getter/setter for [[Prototype]]\n\nIt’s a common mistake of novice developers not to know the difference between these two.\n\nPlease note that __proto__ is not the same as the internal [[Prototype]] property. It’s a getter/setter for [[Prototype]]. Later we’ll see situations where it matters, for now let’s just keep it in mind, as we build our understanding of JavaScript language.\n\nThe __proto__ property is a bit outdated. It exists for historical reasons, modern JavaScript suggests that we should use Object.getPrototypeOf/Object.setPrototypeOf functions instead that get/set the prototype. We’ll also cover these functions later.\n\nBy the specification, __proto__ must only be supported by browsers. In fact though, all environments including server-side support __proto__, so we’re quite safe using it.\n\nAs the __proto__ notation is a bit more intuitively obvious, we use it in the examples.\n\nWriting doesn’t use prototype\n\nThe prototype is only used for reading properties.\n\nWrite/delete operations work directly with the object.\n\nIn the example below, we assign its own walk method to rabbit:\n\n\t\nlet animal = {\n  eats: true,\n  walk() {\n    /* this method won't be used by rabbit */\n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\nrabbit.walk = function() {\n  alert(\"Rabbit! Bounce-bounce!\");\n};\n\nrabbit.walk(); // Rabbit! Bounce-bounce!\n\nFrom now on, rabbit.walk() call finds the method immediately in the object and executes it, without using the prototype:\n\nAccessor properties are an exception, as assignment is handled by a setter function. So writing to such a property is actually the same as calling a function.\n\nFor that reason admin.fullName works correctly in the code below:\n\n\t\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  },\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nlet admin = {\n  __proto__: user,\n  isAdmin: true\n};\n\nalert(admin.fullName); // John Smith (*)\n\n// setter triggers!\nadmin.fullName = \"Alice Cooper\"; // (**)\n\nalert(admin.fullName); // Alice Cooper, state of admin modified\nalert(user.fullName); // John Smith, state of user protected\n\nHere in the line (*) the property admin.fullName has a getter in the prototype user, so it is called. And in the line (**) the property has a setter in the prototype, so it is called.\n\nThe value of “this”\n\nAn interesting question may arise in the example above: what’s the value of this inside set fullName(value)? Where are the properties this.name and this.surname written: into user or admin?\n\nThe answer is simple: this is not affected by prototypes at all.\n\nNo matter where the method is found: in an object or its prototype. In a method call, this is always the object before the dot.\n\nSo, the setter call admin.fullName= uses admin as this, not user.\n\nThat is actually a super-important thing, because we may have a big object with many methods, and have objects that inherit from it. And when the inheriting objects run the inherited methods, they will modify only their own states, not the state of the big object.\n\nFor instance, here animal represents a “method storage”, and rabbit makes use of it.\n\nThe call rabbit.sleep() sets this.isSleeping on the rabbit object:\n\n\t\n// animal has methods\nlet animal = {\n  walk() {\n    if (!this.isSleeping) {\n      alert(`I walk`);\n    }\n  },\n  sleep() {\n    this.isSleeping = true;\n  }\n};\n\nlet rabbit = {\n  name: \"White Rabbit\",\n  __proto__: animal\n};\n\n// modifies rabbit.isSleeping\nrabbit.sleep();\n\nalert(rabbit.isSleeping); // true\nalert(animal.isSleeping); // undefined (no such property in the prototype)\n\nThe resulting picture:\n\nIf we had other objects, like bird, snake, etc., inheriting from animal, they would also gain access to methods of animal. But this in each method call would be the corresponding object, evaluated at the call-time (before dot), not animal. So when we write data into this, it is stored into these objects.\n\nAs a result, methods are shared, but the object state is not.\n\nfor…in loop\n\nThe for..in loop iterates over inherited properties too.\n\nFor instance:\n\n\t\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\n// Object.keys only returns own keys\nalert(Object.keys(rabbit)); // jumps\n\n// for..in loops over both own and inherited keys\nfor(let prop in rabbit) alert(prop); // jumps, then eats\n\nIf that’s not what we want, and we’d like to exclude inherited properties, there’s a built-in method obj.hasOwnProperty(key): it returns true if obj has its own (not inherited) property named key.\n\nSo we can filter out inherited properties (or do something else with them):\n\n\t\nlet animal = {\n  eats: true\n};\n\nlet rabbit = {\n  jumps: true,\n  __proto__: animal\n};\n\nfor(let prop in rabbit) {\n  let isOwn = rabbit.hasOwnProperty(prop);\n\n  if (isOwn) {\n    alert(`Our: ${prop}`); // Our: jumps\n  } else {\n    alert(`Inherited: ${prop}`); // Inherited: eats\n  }\n}\n\nHere we have the following inheritance chain: rabbit inherits from animal, that inherits from Object.prototype (because animal is a literal object {...}, so it’s by default), and then null above it:\n\nNote, there’s one funny thing. Where is the method rabbit.hasOwnProperty coming from? We did not define it. Looking at the chain we can see that the method is provided by Object.prototype.hasOwnProperty. In other words, it’s inherited.\n\n…But why does hasOwnProperty not appear in the for..in loop like eats and jumps do, if for..in lists inherited properties?\n\nThe answer is simple: it’s not enumerable. Just like all other properties of Object.prototype, it has enumerable:false flag. And for..in only lists enumerable properties. That’s why it and the rest of the Object.prototype properties are not listed.\n\nAlmost all other key/value-getting methods ignore inherited properties\n\nAlmost all other key/value-getting methods, such as Object.keys, Object.values and so on ignore inherited properties.\n\nThey only operate on the object itself. Properties from the prototype are not taken into account.\n\nSummary\nIn JavaScript, all objects have a hidden [[Prototype]] property that’s either another object or null.\nWe can use obj.__proto__ to access it (a historical getter/setter, there are other ways, to be covered soon).\nThe object referenced by [[Prototype]] is called a “prototype”.\nIf we want to read a property of obj or call a method, and it doesn’t exist, then JavaScript tries to find it in the prototype.\nWrite/delete operations act directly on the object, they don’t use the prototype (assuming it’s a data property, not a setter).\nIf we call obj.method(), and the method is taken from the prototype, this still references obj. So methods always work with the current object even if they are inherited.\nThe for..in loop iterates over both its own and its inherited properties. All other key/value-getting methods only operate on the object itself.\nTasks\nWorking with prototype\nimportance: 5\n\nHere’s the code that creates a pair of objects, then modifies them.\n\nWhich values are shown in the process?\n\nlet animal = {\n  jumps: null\n};\nlet rabbit = {\n  __proto__: animal,\n  jumps: true\n};\n\nalert( rabbit.jumps ); // ? (1)\n\ndelete rabbit.jumps;\n\nalert( rabbit.jumps ); // ? (2)\n\ndelete animal.jumps;\n\nalert( rabbit.jumps ); // ? (3)\n\nThere should be 3 answers.\n\nsolution\nSearching algorithm\nimportance: 5\n\nThe task has two parts.\n\nGiven the following objects:\n\nlet head = {\n  glasses: 1\n};\n\nlet table = {\n  pen: 3\n};\n\nlet bed = {\n  sheet: 1,\n  pillow: 2\n};\n\nlet pockets = {\n  money: 2000\n};\nUse __proto__ to assign prototypes in a way that any property lookup will follow the path: pockets → bed → table → head. For instance, pockets.pen should be 3 (found in table), and bed.glasses should be 1 (found in head).\nAnswer the question: is it faster to get glasses as pockets.glasses or head.glasses? Benchmark if needed.\nsolution\nWhere does it write?\nimportance: 5\n\nWe have rabbit inheriting from animal.\n\nIf we call rabbit.eat(), which object receives the full property: animal or rabbit?\n\nlet animal = {\n  eat() {\n    this.full = true;\n  }\n};\n\nlet rabbit = {\n  __proto__: animal\n};\n\nrabbit.eat();\nsolution\nWhy are both hamsters full?\nimportance: 5\n\nWe have two hamsters: speedy and lazy inheriting from the general hamster object.\n\nWhen we feed one of them, the other one is also full. Why? How can we fix it?\n\n\t\nlet hamster = {\n  stomach: [],\n\n  eat(food) {\n    this.stomach.push(food);\n  }\n};\n\nlet speedy = {\n  __proto__: hamster\n};\n\nlet lazy = {\n  __proto__: hamster\n};\n\n// This one found the food\nspeedy.eat(\"apple\");\nalert( speedy.stomach ); // apple\n\n// This one also has it, why? fix please.\nalert( lazy.stomach ); // apple\nsolution"
  },
  {
    "title": "Prototypes, inheritance",
    "url": "https://javascript.info/prototypes",
    "html": "Prototypal inheritance\nF.prototype\nNative prototypes\nPrototype methods, objects without __proto__"
  },
  {
    "title": "Property getters and setters",
    "url": "https://javascript.info/property-accessors",
    "html": "There are two kinds of object properties.\n\nThe first kind is data properties. We already know how to work with them. All properties that we’ve been using until now were data properties.\n\nThe second type of property is something new. It’s an accessor property. They are essentially functions that execute on getting and setting a value, but look like regular properties to an external code.\n\nGetters and setters\n\nAccessor properties are represented by “getter” and “setter” methods. In an object literal they are denoted by get and set:\n\nlet obj = {\n  get propName() {\n    // getter, the code executed on getting obj.propName\n  },\n\n  set propName(value) {\n    // setter, the code executed on setting obj.propName = value\n  }\n};\n\nThe getter works when obj.propName is read, the setter – when it is assigned.\n\nFor instance, we have a user object with name and surname:\n\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n\nNow we want to add a fullName property, that should be \"John Smith\". Of course, we don’t want to copy-paste existing information, so we can implement it as an accessor:\n\n\t\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  }\n};\n\nalert(user.fullName); // John Smith\n\nFrom the outside, an accessor property looks like a regular one. That’s the idea of accessor properties. We don’t call user.fullName as a function, we read it normally: the getter runs behind the scenes.\n\nAs of now, fullName has only a getter. If we attempt to assign user.fullName=, there will be an error:\n\n\t\nlet user = {\n  get fullName() {\n    return `...`;\n  }\n};\n\nuser.fullName = \"Test\"; // Error (property has only a getter)\n\nLet’s fix it by adding a setter for user.fullName:\n\n\t\nlet user = {\n  name: \"John\",\n  surname: \"Smith\",\n\n  get fullName() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set fullName(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n};\n\n// set fullName is executed with the given value.\nuser.fullName = \"Alice Cooper\";\n\nalert(user.name); // Alice\nalert(user.surname); // Cooper\n\nAs the result, we have a “virtual” property fullName. It is readable and writable.\n\nAccessor descriptors\n\nDescriptors for accessor properties are different from those for data properties.\n\nFor accessor properties, there is no value or writable, but instead there are get and set functions.\n\nThat is, an accessor descriptor may have:\n\nget – a function without arguments, that works when a property is read,\nset – a function with one argument, that is called when the property is set,\nenumerable – same as for data properties,\nconfigurable – same as for data properties.\n\nFor instance, to create an accessor fullName with defineProperty, we can pass a descriptor with get and set:\n\n\t\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\n\nObject.defineProperty(user, 'fullName', {\n  get() {\n    return `${this.name} ${this.surname}`;\n  },\n\n  set(value) {\n    [this.name, this.surname] = value.split(\" \");\n  }\n});\n\nalert(user.fullName); // John Smith\n\nfor(let key in user) alert(key); // name, surname\n\nPlease note that a property can be either an accessor (has get/set methods) or a data property (has a value), not both.\n\nIf we try to supply both get and value in the same descriptor, there will be an error:\n\n\t\n// Error: Invalid property descriptor.\nObject.defineProperty({}, 'prop', {\n  get() {\n    return 1\n  },\n\n  value: 2\n});\nSmarter getters/setters\n\nGetters/setters can be used as wrappers over “real” property values to gain more control over operations with them.\n\nFor instance, if we want to forbid too short names for user, we can have a setter name and keep the value in a separate property _name:\n\n\t\nlet user = {\n  get name() {\n    return this._name;\n  },\n\n  set name(value) {\n    if (value.length < 4) {\n      alert(\"Name is too short, need at least 4 characters\");\n      return;\n    }\n    this._name = value;\n  }\n};\n\nuser.name = \"Pete\";\nalert(user.name); // Pete\n\nuser.name = \"\"; // Name is too short...\n\nSo, the name is stored in _name property, and the access is done via getter and setter.\n\nTechnically, external code is able to access the name directly by using user._name. But there is a widely known convention that properties starting with an underscore \"_\" are internal and should not be touched from outside the object.\n\nUsing for compatibility\n\nOne of the great uses of accessors is that they allow to take control over a “regular” data property at any moment by replacing it with a getter and a setter and tweak its behavior.\n\nImagine we started implementing user objects using data properties name and age:\n\nfunction User(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nlet john = new User(\"John\", 25);\n\nalert( john.age ); // 25\n\n…But sooner or later, things may change. Instead of age we may decide to store birthday, because it’s more precise and convenient:\n\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n\nNow what to do with the old code that still uses age property?\n\nWe can try to find all such places and fix them, but that takes time and can be hard to do if that code is used by many other people. And besides, age is a nice thing to have in user, right?\n\nLet’s keep it.\n\nAdding a getter for age solves the problem:\n\n\t\nfunction User(name, birthday) {\n  this.name = name;\n  this.birthday = birthday;\n\n  // age is calculated from the current date and birthday\n  Object.defineProperty(this, \"age\", {\n    get() {\n      let todayYear = new Date().getFullYear();\n      return todayYear - this.birthday.getFullYear();\n    }\n  });\n}\n\nlet john = new User(\"John\", new Date(1992, 6, 1));\n\nalert( john.birthday ); // birthday is available\nalert( john.age );      // ...as well as the age\n\nNow the old code works too and we’ve got a nice additional property."
  },
  {
    "title": "Property flags and descriptors",
    "url": "https://javascript.info/property-descriptors",
    "html": "As we know, objects can store properties.\n\nUntil now, a property was a simple “key-value” pair to us. But an object property is actually a more flexible and powerful thing.\n\nIn this chapter we’ll study additional configuration options, and in the next we’ll see how to invisibly turn them into getter/setter functions.\n\nProperty flags\n\nObject properties, besides a value, have three special attributes (so-called “flags”):\n\nwritable – if true, the value can be changed, otherwise it’s read-only.\nenumerable – if true, then listed in loops, otherwise not listed.\nconfigurable – if true, the property can be deleted and these attributes can be modified, otherwise not.\n\nWe didn’t see them yet, because generally they do not show up. When we create a property “the usual way”, all of them are true. But we also can change them anytime.\n\nFirst, let’s see how to get those flags.\n\nThe method Object.getOwnPropertyDescriptor allows to query the full information about a property.\n\nThe syntax is:\n\nlet descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\nobj\nThe object to get information from.\npropertyName\nThe name of the property.\n\nThe returned value is a so-called “property descriptor” object: it contains the value and all the flags.\n\nFor instance:\n\n\t\nlet user = {\n  name: \"John\"\n};\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/* property descriptor:\n{\n  \"value\": \"John\",\n  \"writable\": true,\n  \"enumerable\": true,\n  \"configurable\": true\n}\n*/\n\nTo change the flags, we can use Object.defineProperty.\n\nThe syntax is:\n\nObject.defineProperty(obj, propertyName, descriptor)\nobj, propertyName\nThe object and its property to apply the descriptor.\ndescriptor\nProperty descriptor object to apply.\n\nIf the property exists, defineProperty updates its flags. Otherwise, it creates the property with the given value and flags; in that case, if a flag is not supplied, it is assumed false.\n\nFor instance, here a property name is created with all falsy flags:\n\n\t\nlet user = {};\n\nObject.defineProperty(user, \"name\", {\n  value: \"John\"\n});\n\nlet descriptor = Object.getOwnPropertyDescriptor(user, 'name');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": \"John\",\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n}\n */\n\nCompare it with “normally created” user.name above: now all flags are falsy. If that’s not what we want then we’d better set them to true in descriptor.\n\nNow let’s see effects of the flags by example.\n\nNon-writable\n\nLet’s make user.name non-writable (can’t be reassigned) by changing writable flag:\n\n\t\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n  writable: false\n});\n\nuser.name = \"Pete\"; // Error: Cannot assign to read only property 'name'\n\nNow no one can change the name of our user, unless they apply their own defineProperty to override ours.\n\nErrors appear only in strict mode\n\nIn non-strict mode, no errors occur when writing to non-writable properties and such. But the operation still won’t succeed. Flag-violating actions are just silently ignored in non-strict.\n\nHere’s the same example, but the property is created from scratch:\n\n\t\nlet user = { };\n\nObject.defineProperty(user, \"name\", {\n  value: \"John\",\n  // for new properties we need to explicitly list what's true\n  enumerable: true,\n  configurable: true\n});\n\nalert(user.name); // John\nuser.name = \"Pete\"; // Error\nNon-enumerable\n\nNow let’s add a custom toString to user.\n\nNormally, a built-in toString for objects is non-enumerable, it does not show up in for..in. But if we add a toString of our own, then by default it shows up in for..in, like this:\n\n\t\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\n// By default, both our properties are listed:\nfor (let key in user) alert(key); // name, toString\n\nIf we don’t like it, then we can set enumerable:false. Then it won’t appear in a for..in loop, just like the built-in one:\n\n\t\nlet user = {\n  name: \"John\",\n  toString() {\n    return this.name;\n  }\n};\n\nObject.defineProperty(user, \"toString\", {\n  enumerable: false\n});\n\n// Now our toString disappears:\nfor (let key in user) alert(key); // name\n\nNon-enumerable properties are also excluded from Object.keys:\n\nalert(Object.keys(user)); // name\nNon-configurable\n\nThe non-configurable flag (configurable:false) is sometimes preset for built-in objects and properties.\n\nA non-configurable property can’t be deleted, its attributes can’t be modified.\n\nFor instance, Math.PI is non-writable, non-enumerable and non-configurable:\n\n\t\nlet descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');\n\nalert( JSON.stringify(descriptor, null, 2 ) );\n/*\n{\n  \"value\": 3.141592653589793,\n  \"writable\": false,\n  \"enumerable\": false,\n  \"configurable\": false\n}\n*/\n\nSo, a programmer is unable to change the value of Math.PI or overwrite it.\n\n\t\nMath.PI = 3; // Error, because it has writable: false\n\n// delete Math.PI won't work either\n\nWe also can’t change Math.PI to be writable again:\n\n\t\n// Error, because of configurable: false\nObject.defineProperty(Math, \"PI\", { writable: true });\n\nThere’s absolutely nothing we can do with Math.PI.\n\nMaking a property non-configurable is a one-way road. We cannot change it back with defineProperty.\n\nPlease note: configurable: false prevents changes of property flags and its deletion, while allowing to change its value.\n\nHere user.name is non-configurable, but we can still change it (as it’s writable):\n\n\t\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n  configurable: false\n});\n\nuser.name = \"Pete\"; // works fine\ndelete user.name; // Error\n\nAnd here we make user.name a “forever sealed” constant, just like the built-in Math.PI:\n\n\t\nlet user = {\n  name: \"John\"\n};\n\nObject.defineProperty(user, \"name\", {\n  writable: false,\n  configurable: false\n});\n\n// won't be able to change user.name or its flags\n// all this won't work:\nuser.name = \"Pete\";\ndelete user.name;\nObject.defineProperty(user, \"name\", { value: \"Pete\" });\nThe only attribute change possible: writable true → false\n\nThere’s a minor exception about changing flags.\n\nWe can change writable: true to false for a non-configurable property, thus preventing its value modification (to add another layer of protection). Not the other way around though.\n\nObject.defineProperties\n\nThere’s a method Object.defineProperties(obj, descriptors) that allows to define many properties at once.\n\nThe syntax is:\n\nObject.defineProperties(obj, {\n  prop1: descriptor1,\n  prop2: descriptor2\n  // ...\n});\n\nFor instance:\n\nObject.defineProperties(user, {\n  name: { value: \"John\", writable: false },\n  surname: { value: \"Smith\", writable: false },\n  // ...\n});\n\nSo, we can set many properties at once.\n\nObject.getOwnPropertyDescriptors\n\nTo get all property descriptors at once, we can use the method Object.getOwnPropertyDescriptors(obj).\n\nTogether with Object.defineProperties it can be used as a “flags-aware” way of cloning an object:\n\nlet clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));\n\nNormally when we clone an object, we use an assignment to copy properties, like this:\n\nfor (let key in user) {\n  clone[key] = user[key]\n}\n\n…But that does not copy flags. So if we want a “better” clone then Object.defineProperties is preferred.\n\nAnother difference is that for..in ignores symbolic and non-enumerable properties, but Object.getOwnPropertyDescriptors returns all property descriptors including symbolic and non-enumerable ones.\n\nSealing an object globally\n\nProperty descriptors work at the level of individual properties.\n\nThere are also methods that limit access to the whole object:\n\nObject.preventExtensions(obj)\nForbids the addition of new properties to the object.\nObject.seal(obj)\nForbids adding/removing of properties. Sets configurable: false for all existing properties.\nObject.freeze(obj)\nForbids adding/removing/changing of properties. Sets configurable: false, writable: false for all existing properties.\n\nAnd also there are tests for them:\n\nObject.isExtensible(obj)\nReturns false if adding properties is forbidden, otherwise true.\nObject.isSealed(obj)\nReturns true if adding/removing properties is forbidden, and all existing properties have configurable: false.\nObject.isFrozen(obj)\nReturns true if adding/removing/changing properties is forbidden, and all current properties are configurable: false, writable: false.\n\nThese methods are rarely used in practice."
  },
  {
    "title": "Object properties configuration",
    "url": "https://javascript.info/object-properties",
    "html": "In this section we return to objects and study their properties even more in-depth.\n\nProperty flags and descriptors\nProperty getters and setters"
  },
  {
    "title": "Function binding",
    "url": "https://javascript.info/bind",
    "html": "When passing object methods as callbacks, for instance to setTimeout, there’s a known problem: \"losing this\".\n\nIn this chapter we’ll see the ways to fix it.\n\nLosing “this”\n\nWe’ve already seen examples of losing this. Once a method is passed somewhere separately from the object – this is lost.\n\nHere’s how it may happen with setTimeout:\n\n\t\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\nsetTimeout(user.sayHi, 1000); // Hello, undefined!\n\nAs we can see, the output shows not “John” as this.firstName, but undefined!\n\nThat’s because setTimeout got the function user.sayHi, separately from the object. The last line can be rewritten as:\n\nlet f = user.sayHi;\nsetTimeout(f, 1000); // lost user context\n\nThe method setTimeout in-browser is a little special: it sets this=window for the function call (for Node.js, this becomes the timer object, but doesn’t really matter here). So for this.firstName it tries to get window.firstName, which does not exist. In other similar cases, usually this just becomes undefined.\n\nThe task is quite typical – we want to pass an object method somewhere else (here – to the scheduler) where it will be called. How to make sure that it will be called in the right context?\n\nSolution 1: a wrapper\n\nThe simplest solution is to use a wrapping function:\n\n\t\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\nsetTimeout(function() {\n  user.sayHi(); // Hello, John!\n}, 1000);\n\nNow it works, because it receives user from the outer lexical environment, and then calls the method normally.\n\nThe same, but shorter:\n\nsetTimeout(() => user.sayHi(), 1000); // Hello, John!\n\nLooks fine, but a slight vulnerability appears in our code structure.\n\nWhat if before setTimeout triggers (there’s one second delay!) user changes value? Then, suddenly, it will call the wrong object!\n\n\t\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\nsetTimeout(() => user.sayHi(), 1000);\n\n// ...the value of user changes within 1 second\nuser = {\n  sayHi() { alert(\"Another user in setTimeout!\"); }\n};\n\n// Another user in setTimeout!\n\nThe next solution guarantees that such thing won’t happen.\n\nSolution 2: bind\n\nFunctions provide a built-in method bind that allows to fix this.\n\nThe basic syntax is:\n\n// more complex syntax will come a little later\nlet boundFunc = func.bind(context);\n\nThe result of func.bind(context) is a special function-like “exotic object”, that is callable as function and transparently passes the call to func setting this=context.\n\nIn other words, calling boundFunc is like func with fixed this.\n\nFor instance, here funcUser passes a call to func with this=user:\n\n\t\nlet user = {\n  firstName: \"John\"\n};\n\nfunction func() {\n  alert(this.firstName);\n}\n\nlet funcUser = func.bind(user);\nfuncUser(); // John\n\nHere func.bind(user) as a “bound variant” of func, with fixed this=user.\n\nAll arguments are passed to the original func “as is”, for instance:\n\n\t\nlet user = {\n  firstName: \"John\"\n};\n\nfunction func(phrase) {\n  alert(phrase + ', ' + this.firstName);\n}\n\n// bind this to user\nlet funcUser = func.bind(user);\n\nfuncUser(\"Hello\"); // Hello, John (argument \"Hello\" is passed, and this=user)\n\nNow let’s try with an object method:\n\n\t\nlet user = {\n  firstName: \"John\",\n  sayHi() {\n    alert(`Hello, ${this.firstName}!`);\n  }\n};\n\nlet sayHi = user.sayHi.bind(user); // (*)\n\n// can run it without an object\nsayHi(); // Hello, John!\n\nsetTimeout(sayHi, 1000); // Hello, John!\n\n// even if the value of user changes within 1 second\n// sayHi uses the pre-bound value which is reference to the old user object\nuser = {\n  sayHi() { alert(\"Another user in setTimeout!\"); }\n};\n\nIn the line (*) we take the method user.sayHi and bind it to user. The sayHi is a “bound” function, that can be called alone or passed to setTimeout – doesn’t matter, the context will be right.\n\nHere we can see that arguments are passed “as is”, only this is fixed by bind:\n\n\t\nlet user = {\n  firstName: \"John\",\n  say(phrase) {\n    alert(`${phrase}, ${this.firstName}!`);\n  }\n};\n\nlet say = user.say.bind(user);\n\nsay(\"Hello\"); // Hello, John! (\"Hello\" argument is passed to say)\nsay(\"Bye\"); // Bye, John! (\"Bye\" is passed to say)\nConvenience method: bindAll\n\nIf an object has many methods and we plan to actively pass it around, then we could bind them all in a loop:\n\nfor (let key in user) {\n  if (typeof user[key] == 'function') {\n    user[key] = user[key].bind(user);\n  }\n}\n\nJavaScript libraries also provide functions for convenient mass binding , e.g. _.bindAll(object, methodNames) in lodash.\n\nPartial functions\n\nUntil now we have only been talking about binding this. Let’s take it a step further.\n\nWe can bind not only this, but also arguments. That’s rarely done, but sometimes can be handy.\n\nThe full syntax of bind:\n\nlet bound = func.bind(context, [arg1], [arg2], ...);\n\nIt allows to bind context as this and starting arguments of the function.\n\nFor instance, we have a multiplication function mul(a, b):\n\nfunction mul(a, b) {\n  return a * b;\n}\n\nLet’s use bind to create a function double on its base:\n\n\t\nfunction mul(a, b) {\n  return a * b;\n}\n\nlet double = mul.bind(null, 2);\n\nalert( double(3) ); // = mul(2, 3) = 6\nalert( double(4) ); // = mul(2, 4) = 8\nalert( double(5) ); // = mul(2, 5) = 10\n\nThe call to mul.bind(null, 2) creates a new function double that passes calls to mul, fixing null as the context and 2 as the first argument. Further arguments are passed “as is”.\n\nThat’s called partial function application – we create a new function by fixing some parameters of the existing one.\n\nPlease note that we actually don’t use this here. But bind requires it, so we must put in something like null.\n\nThe function triple in the code below triples the value:\n\n\t\nfunction mul(a, b) {\n  return a * b;\n}\n\nlet triple = mul.bind(null, 3);\n\nalert( triple(3) ); // = mul(3, 3) = 9\nalert( triple(4) ); // = mul(3, 4) = 12\nalert( triple(5) ); // = mul(3, 5) = 15\n\nWhy do we usually make a partial function?\n\nThe benefit is that we can create an independent function with a readable name (double, triple). We can use it and not provide the first argument every time as it’s fixed with bind.\n\nIn other cases, partial application is useful when we have a very generic function and want a less universal variant of it for convenience.\n\nFor instance, we have a function send(from, to, text). Then, inside a user object we may want to use a partial variant of it: sendTo(to, text) that sends from the current user.\n\nGoing partial without context\n\nWhat if we’d like to fix some arguments, but not the context this? For example, for an object method.\n\nThe native bind does not allow that. We can’t just omit the context and jump to arguments.\n\nFortunately, a function partial for binding only arguments can be easily implemented.\n\nLike this:\n\n\t\nfunction partial(func, ...argsBound) {\n  return function(...args) { // (*)\n    return func.call(this, ...argsBound, ...args);\n  }\n}\n\n// Usage:\nlet user = {\n  firstName: \"John\",\n  say(time, phrase) {\n    alert(`[${time}] ${this.firstName}: ${phrase}!`);\n  }\n};\n\n// add a partial method with fixed time\nuser.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());\n\nuser.sayNow(\"Hello\");\n// Something like:\n// [10:00] John: Hello!\n\nThe result of partial(func[, arg1, arg2...]) call is a wrapper (*) that calls func with:\n\nSame this as it gets (for user.sayNow call it’s user)\nThen gives it ...argsBound – arguments from the partial call (\"10:00\")\nThen gives it ...args – arguments given to the wrapper (\"Hello\")\n\nSo easy to do it with the spread syntax, right?\n\nAlso there’s a ready _.partial implementation from lodash library.\n\nSummary\n\nMethod func.bind(context, ...args) returns a “bound variant” of function func that fixes the context this and first arguments if given.\n\nUsually we apply bind to fix this for an object method, so that we can pass it somewhere. For example, to setTimeout.\n\nWhen we fix some arguments of an existing function, the resulting (less universal) function is called partially applied or partial.\n\nPartials are convenient when we don’t want to repeat the same argument over and over again. Like if we have a send(from, to) function, and from should always be the same for our task, we can get a partial and go on with it.\n\nTasks\nBound function as a method\nimportance: 5\n\nWhat will be the output?\n\nfunction f() {\n  alert( this ); // ?\n}\n\nlet user = {\n  g: f.bind(null)\n};\n\nuser.g();\nsolution\nSecond bind\nimportance: 5\n\nCan we change this by additional binding?\n\nWhat will be the output?\n\nfunction f() {\n  alert(this.name);\n}\n\nf = f.bind( {name: \"John\"} ).bind( {name: \"Ann\" } );\n\nf();\nsolution\nFunction property after bind\nimportance: 5\n\nThere’s a value in the property of a function. Will it change after bind? Why, or why not?\n\n\t\nfunction sayHi() {\n  alert( this.name );\n}\nsayHi.test = 5;\n\nlet bound = sayHi.bind({\n  name: \"John\"\n});\n\nalert( bound.test ); // what will be the output? why?\nsolution\nFix a function that loses \"this\"\nimportance: 5\n\nThe call to askPassword() in the code below should check the password and then call user.loginOk/loginFail depending on the answer.\n\nBut it leads to an error. Why?\n\nFix the highlighted line for everything to start working right (other lines are not to be changed).\n\n\t\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  loginOk() {\n    alert(`${this.name} logged in`);\n  },\n\n  loginFail() {\n    alert(`${this.name} failed to log in`);\n  },\n\n};\n\naskPassword(user.loginOk, user.loginFail);\nsolution\nPartial application for login\nimportance: 5\n\nThe task is a little more complex variant of Fix a function that loses \"this\".\n\nThe user object was modified. Now instead of two functions loginOk/loginFail, it has a single function user.login(true/false).\n\nWhat should we pass askPassword in the code below, so that it calls user.login(true) as ok and user.login(false) as fail?\n\nfunction askPassword(ok, fail) {\n  let password = prompt(\"Password?\", '');\n  if (password == \"rockstar\") ok();\n  else fail();\n}\n\nlet user = {\n  name: 'John',\n\n  login(result) {\n    alert( this.name + (result ? ' logged in' : ' failed to log in') );\n  }\n};\n\naskPassword(?, ?); // ?\n\nYour changes should only modify the highlighted fragment.\n\nsolution"
  },
  {
    "title": "Decorators and forwarding, call/apply",
    "url": "https://javascript.info/call-apply-decorators",
    "html": "JavaScript gives exceptional flexibility when dealing with functions. They can be passed around, used as objects, and now we’ll see how to forward calls between them and decorate them.\n\nTransparent caching\n\nLet’s say we have a function slow(x) which is CPU-heavy, but its results are stable. In other words, for the same x it always returns the same result.\n\nIf the function is called often, we may want to cache (remember) the results to avoid spending extra-time on recalculations.\n\nBut instead of adding that functionality into slow() we’ll create a wrapper function, that adds caching. As we’ll see, there are many benefits of doing so.\n\nHere’s the code, and explanations follow:\n\n\t\nfunction slow(x) {\n  // there can be a heavy CPU-intensive job here\n  alert(`Called with ${x}`);\n  return x;\n}\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n\n  return function(x) {\n    if (cache.has(x)) {    // if there's such key in cache\n      return cache.get(x); // read the result from it\n    }\n\n    let result = func(x);  // otherwise call func\n\n    cache.set(x, result);  // and cache (remember) the result\n    return result;\n  };\n}\n\nslow = cachingDecorator(slow);\n\nalert( slow(1) ); // slow(1) is cached and the result returned\nalert( \"Again: \" + slow(1) ); // slow(1) result returned from cache\n\nalert( slow(2) ); // slow(2) is cached and the result returned\nalert( \"Again: \" + slow(2) ); // slow(2) result returned from cache\n\nIn the code above cachingDecorator is a decorator: a special function that takes another function and alters its behavior.\n\nThe idea is that we can call cachingDecorator for any function, and it will return the caching wrapper. That’s great, because we can have many functions that could use such a feature, and all we need to do is to apply cachingDecorator to them.\n\nBy separating caching from the main function code we also keep the main code simpler.\n\nThe result of cachingDecorator(func) is a “wrapper”: function(x) that “wraps” the call of func(x) into caching logic:\n\nFrom an outside code, the wrapped slow function still does the same. It just got a caching aspect added to its behavior.\n\nTo summarize, there are several benefits of using a separate cachingDecorator instead of altering the code of slow itself:\n\nThe cachingDecorator is reusable. We can apply it to another function.\nThe caching logic is separate, it did not increase the complexity of slow itself (if there was any).\nWe can combine multiple decorators if needed (other decorators will follow).\nUsing “func.call” for the context\n\nThe caching decorator mentioned above is not suited to work with object methods.\n\nFor instance, in the code below worker.slow() stops working after the decoration:\n\n\t\n// we'll make worker.slow caching\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    // scary CPU-heavy task here\n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\n// same code as before\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n    let result = func(x); // (**)\n    cache.set(x, result);\n    return result;\n  };\n}\n\nalert( worker.slow(1) ); // the original method works\n\nworker.slow = cachingDecorator(worker.slow); // now make it caching\n\nalert( worker.slow(2) ); // Whoops! Error: Cannot read property 'someMethod' of undefined\n\nThe error occurs in the line (*) that tries to access this.someMethod and fails. Can you see why?\n\nThe reason is that the wrapper calls the original function as func(x) in the line (**). And, when called like that, the function gets this = undefined.\n\nWe would observe a similar symptom if we tried to run:\n\nlet func = worker.slow;\nfunc(2);\n\nSo, the wrapper passes the call to the original method, but without the context this. Hence the error.\n\nLet’s fix it.\n\nThere’s a special built-in function method func.call(context, …args) that allows to call a function explicitly setting this.\n\nThe syntax is:\n\nfunc.call(context, arg1, arg2, ...)\n\nIt runs func providing the first argument as this, and the next as the arguments.\n\nTo put it simply, these two calls do almost the same:\n\nfunc(1, 2, 3);\nfunc.call(obj, 1, 2, 3)\n\nThey both call func with arguments 1, 2 and 3. The only difference is that func.call also sets this to obj.\n\nAs an example, in the code below we call sayHi in the context of different objects: sayHi.call(user) runs sayHi providing this=user, and the next line sets this=admin:\n\n\t\nfunction sayHi() {\n  alert(this.name);\n}\n\nlet user = { name: \"John\" };\nlet admin = { name: \"Admin\" };\n\n// use call to pass different objects as \"this\"\nsayHi.call( user ); // John\nsayHi.call( admin ); // Admin\n\nAnd here we use call to call say with the given context and phrase:\n\n\t\nfunction say(phrase) {\n  alert(this.name + ': ' + phrase);\n}\n\nlet user = { name: \"John\" };\n\n// user becomes this, and \"Hello\" becomes the first argument\nsay.call( user, \"Hello\" ); // John: Hello\n\nIn our case, we can use call in the wrapper to pass the context to the original function:\n\n\t\nlet worker = {\n  someMethod() {\n    return 1;\n  },\n\n  slow(x) {\n    alert(\"Called with \" + x);\n    return x * this.someMethod(); // (*)\n  }\n};\n\nfunction cachingDecorator(func) {\n  let cache = new Map();\n  return function(x) {\n    if (cache.has(x)) {\n      return cache.get(x);\n    }\n    let result = func.call(this, x); // \"this\" is passed correctly now\n    cache.set(x, result);\n    return result;\n  };\n}\n\nworker.slow = cachingDecorator(worker.slow); // now make it caching\n\nalert( worker.slow(2) ); // works\nalert( worker.slow(2) ); // works, doesn't call the original (cached)\n\nNow everything is fine.\n\nTo make it all clear, let’s see more deeply how this is passed along:\n\nAfter the decoration worker.slow is now the wrapper function (x) { ... }.\nSo when worker.slow(2) is executed, the wrapper gets 2 as an argument and this=worker (it’s the object before dot).\nInside the wrapper, assuming the result is not yet cached, func.call(this, x) passes the current this (=worker) and the current argument (=2) to the original method.\nGoing multi-argument\n\nNow let’s make cachingDecorator even more universal. Till now it was working only with single-argument functions.\n\nNow how to cache the multi-argument worker.slow method?\n\nlet worker = {\n  slow(min, max) {\n    return min + max; // scary CPU-hogger is assumed\n  }\n};\n\n// should remember same-argument calls\nworker.slow = cachingDecorator(worker.slow);\n\nPreviously, for a single argument x we could just cache.set(x, result) to save the result and cache.get(x) to retrieve it. But now we need to remember the result for a combination of arguments (min,max). The native Map takes single value only as the key.\n\nThere are many solutions possible:\n\nImplement a new (or use a third-party) map-like data structure that is more versatile and allows multi-keys.\nUse nested maps: cache.set(min) will be a Map that stores the pair (max, result). So we can get result as cache.get(min).get(max).\nJoin two values into one. In our particular case we can just use a string \"min,max\" as the Map key. For flexibility, we can allow to provide a hashing function for the decorator, that knows how to make one value from many.\n\nFor many practical applications, the 3rd variant is good enough, so we’ll stick to it.\n\nAlso we need to pass not just x, but all arguments in func.call. Let’s recall that in a function() we can get a pseudo-array of its arguments as arguments, so func.call(this, x) should be replaced with func.call(this, ...arguments).\n\nHere’s a more powerful cachingDecorator:\n\n\t\nlet worker = {\n  slow(min, max) {\n    alert(`Called with ${min},${max}`);\n    return min + max;\n  }\n};\n\nfunction cachingDecorator(func, hash) {\n  let cache = new Map();\n  return function() {\n    let key = hash(arguments); // (*)\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    let result = func.call(this, ...arguments); // (**)\n\n    cache.set(key, result);\n    return result;\n  };\n}\n\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n\nworker.slow = cachingDecorator(worker.slow, hash);\n\nalert( worker.slow(3, 5) ); // works\nalert( \"Again \" + worker.slow(3, 5) ); // same (cached)\n\nNow it works with any number of arguments (though the hash function would also need to be adjusted to allow any number of arguments. An interesting way to handle this will be covered below).\n\nThere are two changes:\n\nIn the line (*) it calls hash to create a single key from arguments. Here we use a simple “joining” function that turns arguments (3, 5) into the key \"3,5\". More complex cases may require other hashing functions.\nThen (**) uses func.call(this, ...arguments) to pass both the context and all arguments the wrapper got (not just the first one) to the original function.\nfunc.apply\n\nInstead of func.call(this, ...arguments) we could use func.apply(this, arguments).\n\nThe syntax of built-in method func.apply is:\n\nfunc.apply(context, args)\n\nIt runs the func setting this=context and using an array-like object args as the list of arguments.\n\nThe only syntax difference between call and apply is that call expects a list of arguments, while apply takes an array-like object with them.\n\nSo these two calls are almost equivalent:\n\nfunc.call(context, ...args);\nfunc.apply(context, args);\n\nThey perform the same call of func with given context and arguments.\n\nThere’s only a subtle difference regarding args:\n\nThe spread syntax ... allows to pass iterable args as the list to call.\nThe apply accepts only array-like args.\n\n…And for objects that are both iterable and array-like, such as a real array, we can use any of them, but apply will probably be faster, because most JavaScript engines internally optimize it better.\n\nPassing all arguments along with the context to another function is called call forwarding.\n\nThat’s the simplest form of it:\n\nlet wrapper = function() {\n  return func.apply(this, arguments);\n};\n\nWhen an external code calls such wrapper, it is indistinguishable from the call of the original function func.\n\nBorrowing a method\n\nNow let’s make one more minor improvement in the hashing function:\n\nfunction hash(args) {\n  return args[0] + ',' + args[1];\n}\n\nAs of now, it works only on two arguments. It would be better if it could glue any number of args.\n\nThe natural solution would be to use arr.join method:\n\nfunction hash(args) {\n  return args.join();\n}\n\n…Unfortunately, that won’t work. Because we are calling hash(arguments), and arguments object is both iterable and array-like, but not a real array.\n\nSo calling join on it would fail, as we can see below:\n\n\t\nfunction hash() {\n  alert( arguments.join() ); // Error: arguments.join is not a function\n}\n\nhash(1, 2);\n\nStill, there’s an easy way to use array join:\n\n\t\nfunction hash() {\n  alert( [].join.call(arguments) ); // 1,2\n}\n\nhash(1, 2);\n\nThe trick is called method borrowing.\n\nWe take (borrow) a join method from a regular array ([].join) and use [].join.call to run it in the context of arguments.\n\nWhy does it work?\n\nThat’s because the internal algorithm of the native method arr.join(glue) is very simple.\n\nTaken from the specification almost “as-is”:\n\nLet glue be the first argument or, if no arguments, then a comma \",\".\nLet result be an empty string.\nAppend this[0] to result.\nAppend glue and this[1].\nAppend glue and this[2].\n…Do so until this.length items are glued.\nReturn result.\n\nSo, technically it takes this and joins this[0], this[1] …etc together. It’s intentionally written in a way that allows any array-like this (not a coincidence, many methods follow this practice). That’s why it also works with this=arguments.\n\nDecorators and function properties\n\nIt is generally safe to replace a function or a method with a decorated one, except for one little thing. If the original function had properties on it, like func.calledCount or whatever, then the decorated one will not provide them. Because that is a wrapper. So one needs to be careful if one uses them.\n\nE.g. in the example above if slow function had any properties on it, then cachingDecorator(slow) is a wrapper without them.\n\nSome decorators may provide their own properties. E.g. a decorator may count how many times a function was invoked and how much time it took, and expose this information via wrapper properties.\n\nThere exists a way to create decorators that keep access to function properties, but this requires using a special Proxy object to wrap a function. We’ll discuss it later in the article Proxy and Reflect.\n\nSummary\n\nDecorator is a wrapper around a function that alters its behavior. The main job is still carried out by the function.\n\nDecorators can be seen as “features” or “aspects” that can be added to a function. We can add one or add many. And all this without changing its code!\n\nTo implement cachingDecorator, we studied methods:\n\nfunc.call(context, arg1, arg2…) – calls func with given context and arguments.\nfunc.apply(context, args) – calls func passing context as this and array-like args into a list of arguments.\n\nThe generic call forwarding is usually done with apply:\n\nlet wrapper = function() {\n  return original.apply(this, arguments);\n};\n\nWe also saw an example of method borrowing when we take a method from an object and call it in the context of another object. It is quite common to take array methods and apply them to arguments. The alternative is to use rest parameters object that is a real array.\n\nThere are many decorators there in the wild. Check how well you got them by solving the tasks of this chapter.\n\nTasks\nSpy decorator\nimportance: 5\n\nCreate a decorator spy(func) that should return a wrapper that saves all calls to function in its calls property.\n\nEvery call is saved as an array of arguments.\n\nFor instance:\n\nfunction work(a, b) {\n  alert( a + b ); // work is an arbitrary function or method\n}\n\nwork = spy(work);\n\nwork(1, 2); // 3\nwork(4, 5); // 9\n\nfor (let args of work.calls) {\n  alert( 'call:' + args.join() ); // \"call:1,2\", \"call:4,5\"\n}\n\nP.S. That decorator is sometimes useful for unit-testing. Its advanced form is sinon.spy in Sinon.JS library.\n\nOpen a sandbox with tests.\n\nsolution\nDelaying decorator\nimportance: 5\n\nCreate a decorator delay(f, ms) that delays each call of f by ms milliseconds.\n\nFor instance:\n\nfunction f(x) {\n  alert(x);\n}\n\n// create wrappers\nlet f1000 = delay(f, 1000);\nlet f1500 = delay(f, 1500);\n\nf1000(\"test\"); // shows \"test\" after 1000ms\nf1500(\"test\"); // shows \"test\" after 1500ms\n\nIn other words, delay(f, ms) returns a \"delayed by ms\" variant of f.\n\nIn the code above, f is a function of a single argument, but your solution should pass all arguments and the context this.\n\nOpen a sandbox with tests.\n\nsolution\nDebounce decorator\nimportance: 5\n\nThe result of debounce(f, ms) decorator is a wrapper that suspends calls to f until there’s ms milliseconds of inactivity (no calls, “cooldown period”), then invokes f once with the latest arguments.\n\nIn other words, debounce is like a secretary that accepts “phone calls”, and waits until there’s ms milliseconds of being quiet. And only then it transfers the latest call information to “the boss” (calls the actual f).\n\nFor instance, we had a function f and replaced it with f = debounce(f, 1000).\n\nThen if the wrapped function is called at 0ms, 200ms and 500ms, and then there are no calls, then the actual f will be only called once, at 1500ms. That is: after the cooldown period of 1000ms from the last call.\n\n…And it will get the arguments of the very last call, other calls are ignored.\n\nHere’s the code for it (uses the debounce decorator from the Lodash library):\n\nlet f = _.debounce(alert, 1000);\n\nf(\"a\");\nsetTimeout( () => f(\"b\"), 200);\nsetTimeout( () => f(\"c\"), 500);\n// debounced function waits 1000ms after the last call and then runs: alert(\"c\")\n\nNow a practical example. Let’s say, the user types something, and we’d like to send a request to the server when the input is finished.\n\nThere’s no point in sending the request for every character typed. Instead we’d like to wait, and then process the whole result.\n\nIn a web-browser, we can setup an event handler – a function that’s called on every change of an input field. Normally, an event handler is called very often, for every typed key. But if we debounce it by 1000ms, then it will be only called once, after 1000ms after the last input.\n\nIn this live example, the handler puts the result into a box below, try it:\n\nSee? The second input calls the debounced function, so its content is processed after 1000ms from the last input.\n\nSo, debounce is a great way to process a sequence of events: be it a sequence of key presses, mouse movements or something else.\n\nIt waits the given time after the last call, and then runs its function, that can process the result.\n\nThe task is to implement debounce decorator.\n\nHint: that’s just a few lines if you think about it :)\n\nOpen a sandbox with tests.\n\nsolution\nThrottle decorator\nimportance: 5\n\nCreate a “throttling” decorator throttle(f, ms) – that returns a wrapper.\n\nWhen it’s called multiple times, it passes the call to f at maximum once per ms milliseconds.\n\nCompared to the debounce decorator, the behavior is completely different:\n\ndebounce runs the function once after the “cooldown” period. Good for processing the final result.\nthrottle runs it not more often than given ms time. Good for regular updates that shouldn’t be very often.\n\nIn other words, throttle is like a secretary that accepts phone calls, but bothers the boss (calls the actual f) not more often than once per ms milliseconds.\n\nLet’s check the real-life application to better understand that requirement and to see where it comes from.\n\nFor instance, we want to track mouse movements.\n\nIn a browser we can setup a function to run at every mouse movement and get the pointer location as it moves. During an active mouse usage, this function usually runs very frequently, can be something like 100 times per second (every 10 ms). We’d like to update some information on the web-page when the pointer moves.\n\n…But updating function update() is too heavy to do it on every micro-movement. There is also no sense in updating more often than once per 100ms.\n\nSo we’ll wrap it into the decorator: use throttle(update, 100) as the function to run on each mouse move instead of the original update(). The decorator will be called often, but forward the call to update() at maximum once per 100ms.\n\nVisually, it will look like this:\n\nFor the first mouse movement the decorated variant immediately passes the call to update. That’s important, the user sees our reaction to their move immediately.\nThen as the mouse moves on, until 100ms nothing happens. The decorated variant ignores calls.\nAt the end of 100ms – one more update happens with the last coordinates.\nThen, finally, the mouse stops somewhere. The decorated variant waits until 100ms expire and then runs update with last coordinates. So, quite important, the final mouse coordinates are processed.\n\nA code example:\n\nfunction f(a) {\n  console.log(a);\n}\n\n// f1000 passes calls to f at maximum once per 1000 ms\nlet f1000 = throttle(f, 1000);\n\nf1000(1); // shows 1\nf1000(2); // (throttling, 1000ms not out yet)\nf1000(3); // (throttling, 1000ms not out yet)\n\n// when 1000 ms time out...\n// ...outputs 3, intermediate value 2 was ignored\n\nP.S. Arguments and the context this passed to f1000 should be passed to the original f.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Arrow functions revisited",
    "url": "https://javascript.info/arrow-functions",
    "html": "Let’s revisit arrow functions.\n\nArrow functions are not just a “shorthand” for writing small stuff. They have some very specific and useful features.\n\nJavaScript is full of situations where we need to write a small function that’s executed somewhere else.\n\nFor instance:\n\narr.forEach(func) – func is executed by forEach for every array item.\nsetTimeout(func) – func is executed by the built-in scheduler.\n…there are more.\n\nIt’s in the very spirit of JavaScript to create a function and pass it somewhere.\n\nAnd in such functions we usually don’t want to leave the current context. That’s where arrow functions come in handy.\n\nArrow functions have no “this”\n\nAs we remember from the chapter Object methods, \"this\", arrow functions do not have this. If this is accessed, it is taken from the outside.\n\nFor instance, we can use it to iterate inside an object method:\n\n\t\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n    this.students.forEach(\n      student => alert(this.title + ': ' + student)\n    );\n  }\n};\n\ngroup.showList();\n\nHere in forEach, the arrow function is used, so this.title in it is exactly the same as in the outer method showList. That is: group.title.\n\nIf we used a “regular” function, there would be an error:\n\n\t\nlet group = {\n  title: \"Our Group\",\n  students: [\"John\", \"Pete\", \"Alice\"],\n\n  showList() {\n    this.students.forEach(function(student) {\n      // Error: Cannot read property 'title' of undefined\n      alert(this.title + ': ' + student);\n    });\n  }\n};\n\ngroup.showList();\n\nThe error occurs because forEach runs functions with this=undefined by default, so the attempt to access undefined.title is made.\n\nThat doesn’t affect arrow functions, because they just don’t have this.\n\nArrow functions can’t run with new\n\nNot having this naturally means another limitation: arrow functions can’t be used as constructors. They can’t be called with new.\n\nArrow functions VS bind\n\nThere’s a subtle difference between an arrow function => and a regular function called with .bind(this):\n\n.bind(this) creates a “bound version” of the function.\nThe arrow => doesn’t create any binding. The function simply doesn’t have this. The lookup of this is made exactly the same way as a regular variable search: in the outer lexical environment.\nArrows have no “arguments”\n\nArrow functions also have no arguments variable.\n\nThat’s great for decorators, when we need to forward a call with the current this and arguments.\n\nFor instance, defer(f, ms) gets a function and returns a wrapper around it that delays the call by ms milliseconds:\n\n\t\nfunction defer(f, ms) {\n  return function() {\n    setTimeout(() => f.apply(this, arguments), ms);\n  };\n}\n\nfunction sayHi(who) {\n  alert('Hello, ' + who);\n}\n\nlet sayHiDeferred = defer(sayHi, 2000);\nsayHiDeferred(\"John\"); // Hello, John after 2 seconds\n\nThe same without an arrow function would look like:\n\nfunction defer(f, ms) {\n  return function(...args) {\n    let ctx = this;\n    setTimeout(function() {\n      return f.apply(ctx, args);\n    }, ms);\n  };\n}\n\nHere we had to create additional variables args and ctx so that the function inside setTimeout could take them.\n\nSummary\n\nArrow functions:\n\nDo not have this\nDo not have arguments\nCan’t be called with new\nThey also don’t have super, but we didn’t study it yet. We will on the chapter Class inheritance\n\nThat’s because they are meant for short pieces of code that do not have their own “context”, but rather work in the current one. And they really shine in that use case."
  },
  {
    "title": "Scheduling: setTimeout and setInterval",
    "url": "https://javascript.info/settimeout-setinterval",
    "html": "We may decide to execute a function not right now, but at a certain time later. That’s called “scheduling a call”.\n\nThere are two methods for it:\n\nsetTimeout allows us to run a function once after the interval of time.\nsetInterval allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.\n\nThese methods are not a part of JavaScript specification. But most environments have the internal scheduler and provide these methods. In particular, they are supported in all browsers and Node.js.\n\nsetTimeout\n\nThe syntax:\n\nlet timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)\n\nParameters:\n\nfunc|code\nFunction or a string of code to execute. Usually, that’s a function. For historical reasons, a string of code can be passed, but that’s not recommended.\ndelay\nThe delay before run, in milliseconds (1000 ms = 1 second), by default 0.\narg1, arg2…\nArguments for the function\n\nFor instance, this code calls sayHi() after one second:\n\n\t\nfunction sayHi() {\n  alert('Hello');\n}\n\nsetTimeout(sayHi, 1000);\n\nWith arguments:\n\n\t\nfunction sayHi(phrase, who) {\n  alert( phrase + ', ' + who );\n}\n\nsetTimeout(sayHi, 1000, \"Hello\", \"John\"); // Hello, John\n\nIf the first argument is a string, then JavaScript creates a function from it.\n\nSo, this will also work:\n\n\t\nsetTimeout(\"alert('Hello')\", 1000);\n\nBut using strings is not recommended, use arrow functions instead of them, like this:\n\n\t\nsetTimeout(() => alert('Hello'), 1000);\nPass a function, but don’t run it\n\nNovice developers sometimes make a mistake by adding brackets () after the function:\n\n// wrong!\nsetTimeout(sayHi(), 1000);\n\nThat doesn’t work, because setTimeout expects a reference to a function. And here sayHi() runs the function, and the result of its execution is passed to setTimeout. In our case the result of sayHi() is undefined (the function returns nothing), so nothing is scheduled.\n\nCanceling with clearTimeout\n\nA call to setTimeout returns a “timer identifier” timerId that we can use to cancel the execution.\n\nThe syntax to cancel:\n\nlet timerId = setTimeout(...);\nclearTimeout(timerId);\n\nIn the code below, we schedule the function and then cancel it (changed our mind). As a result, nothing happens:\n\n\t\nlet timerId = setTimeout(() => alert(\"never happens\"), 1000);\nalert(timerId); // timer identifier\n\nclearTimeout(timerId);\nalert(timerId); // same identifier (doesn't become null after canceling)\n\nAs we can see from alert output, in a browser the timer identifier is a number. In other environments, this can be something else. For instance, Node.js returns a timer object with additional methods.\n\nAgain, there is no universal specification for these methods, so that’s fine.\n\nFor browsers, timers are described in the timers section of HTML Living Standard.\n\nsetInterval\n\nThe setInterval method has the same syntax as setTimeout:\n\nlet timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)\n\nAll arguments have the same meaning. But unlike setTimeout it runs the function not only once, but regularly after the given interval of time.\n\nTo stop further calls, we should call clearInterval(timerId).\n\nThe following example will show the message every 2 seconds. After 5 seconds, the output is stopped:\n\n\t\n// repeat with the interval of 2 seconds\nlet timerId = setInterval(() => alert('tick'), 2000);\n\n// after 5 seconds stop\nsetTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);\nTime goes on while alert is shown\n\nIn most browsers, including Chrome and Firefox the internal timer continues “ticking” while showing alert/confirm/prompt.\n\nSo if you run the code above and don’t dismiss the alert window for some time, then the next alert will be shown immediately as you do it. The actual interval between alerts will be shorter than 2 seconds.\n\nNested setTimeout\n\nThere are two ways of running something regularly.\n\nOne is setInterval. The other one is a nested setTimeout, like this:\n\n/** instead of:\nlet timerId = setInterval(() => alert('tick'), 2000);\n*/\n\nlet timerId = setTimeout(function tick() {\n  alert('tick');\n  timerId = setTimeout(tick, 2000); // (*)\n}, 2000);\n\nThe setTimeout above schedules the next call right at the end of the current one (*).\n\nThe nested setTimeout is a more flexible method than setInterval. This way the next call may be scheduled differently, depending on the results of the current one.\n\nFor instance, we need to write a service that sends a request to the server every 5 seconds asking for data, but in case the server is overloaded, it should increase the interval to 10, 20, 40 seconds…\n\nHere’s the pseudocode:\n\nlet delay = 5000;\n\nlet timerId = setTimeout(function request() {\n  ...send request...\n\n  if (request failed due to server overload) {\n    // increase the interval to the next run\n    delay *= 2;\n  }\n\n  timerId = setTimeout(request, delay);\n\n}, delay);\n\nAnd if the functions that we’re scheduling are CPU-hungry, then we can measure the time taken by the execution and plan the next call sooner or later.\n\nNested setTimeout allows to set the delay between the executions more precisely than setInterval.\n\nLet’s compare two code fragments. The first one uses setInterval:\n\nlet i = 1;\nsetInterval(function() {\n  func(i++);\n}, 100);\n\nThe second one uses nested setTimeout:\n\nlet i = 1;\nsetTimeout(function run() {\n  func(i++);\n  setTimeout(run, 100);\n}, 100);\n\nFor setInterval the internal scheduler will run func(i++) every 100ms:\n\nDid you notice?\n\nThe real delay between func calls for setInterval is less than in the code!\n\nThat’s normal, because the time taken by func's execution “consumes” a part of the interval.\n\nIt is possible that func's execution turns out to be longer than we expected and takes more than 100ms.\n\nIn this case the engine waits for func to complete, then checks the scheduler and if the time is up, runs it again immediately.\n\nIn the edge case, if the function always executes longer than delay ms, then the calls will happen without a pause at all.\n\nAnd here is the picture for the nested setTimeout:\n\nThe nested setTimeout guarantees the fixed delay (here 100ms).\n\nThat’s because a new call is planned at the end of the previous one.\n\nGarbage collection and setInterval/setTimeout callback\n\nWhen a function is passed in setInterval/setTimeout, an internal reference is created to it and saved in the scheduler. It prevents the function from being garbage collected, even if there are no other references to it.\n\n// the function stays in memory until the scheduler calls it\nsetTimeout(function() {...}, 100);\n\nFor setInterval the function stays in memory until clearInterval is called.\n\nThere’s a side effect. A function references the outer lexical environment, so, while it lives, outer variables live too. They may take much more memory than the function itself. So when we don’t need the scheduled function anymore, it’s better to cancel it, even if it’s very small.\n\nZero delay setTimeout\n\nThere’s a special use case: setTimeout(func, 0), or just setTimeout(func).\n\nThis schedules the execution of func as soon as possible. But the scheduler will invoke it only after the currently executing script is complete.\n\nSo the function is scheduled to run “right after” the current script.\n\nFor instance, this outputs “Hello”, then immediately “World”:\n\n\t\nsetTimeout(() => alert(\"World\"));\n\nalert(\"Hello\");\n\nThe first line “puts the call into calendar after 0ms”. But the scheduler will only “check the calendar” after the current script is complete, so \"Hello\" is first, and \"World\" – after it.\n\nThere are also advanced browser-related use cases of zero-delay timeout, that we’ll discuss in the chapter Event loop: microtasks and macrotasks.\n\nZero delay is in fact not zero (in a browser)\n\nIn the browser, there’s a limitation of how often nested timers can run. The HTML Living Standard says: “after five nested timers, the interval is forced to be at least 4 milliseconds.”.\n\nLet’s demonstrate what it means with the example below. The setTimeout call in it re-schedules itself with zero delay. Each call remembers the real time from the previous one in the times array. What do the real delays look like? Let’s see:\n\n\t\nlet start = Date.now();\nlet times = [];\n\nsetTimeout(function run() {\n  times.push(Date.now() - start); // remember delay from the previous call\n\n  if (start + 100 < Date.now()) alert(times); // show the delays after 100ms\n  else setTimeout(run); // else re-schedule\n});\n\n// an example of the output:\n// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100\n\nFirst timers run immediately (just as written in the spec), and then we see 9, 15, 20, 24.... The 4+ ms obligatory delay between invocations comes into play.\n\nThe similar thing happens if we use setInterval instead of setTimeout: setInterval(f) runs f few times with zero-delay, and afterwards with 4+ ms delay.\n\nThat limitation comes from ancient times and many scripts rely on it, so it exists for historical reasons.\n\nFor server-side JavaScript, that limitation does not exist, and there exist other ways to schedule an immediate asynchronous job, like setImmediate for Node.js. So this note is browser-specific.\n\nSummary\nMethods setTimeout(func, delay, ...args) and setInterval(func, delay, ...args) allow us to run the func once/regularly after delay milliseconds.\nTo cancel the execution, we should call clearTimeout/clearInterval with the value returned by setTimeout/setInterval.\nNested setTimeout calls are a more flexible alternative to setInterval, allowing us to set the time between executions more precisely.\nZero delay scheduling with setTimeout(func, 0) (the same as setTimeout(func)) is used to schedule the call “as soon as possible, but after the current script is complete”.\nThe browser limits the minimal delay for five or more nested calls of setTimeout or for setInterval (after 5th call) to 4ms. That’s for historical reasons.\n\nPlease note that all scheduling methods do not guarantee the exact delay.\n\nFor example, the in-browser timer may slow down for a lot of reasons:\n\nThe CPU is overloaded.\nThe browser tab is in the background mode.\nThe laptop is on battery saving mode.\n\nAll that may increase the minimal timer resolution (the minimal delay) to 300ms or even 1000ms depending on the browser and OS-level performance settings.\n\nTasks\nOutput every second\nimportance: 5\n\nWrite a function printNumbers(from, to) that outputs a number every second, starting from from and ending with to.\n\nMake two variants of the solution.\n\nUsing setInterval.\nUsing nested setTimeout.\nsolution\nWhat will setTimeout show?\nimportance: 5\n\nIn the code below there’s a setTimeout call scheduled, then a heavy calculation is run, that takes more than 100ms to finish.\n\nWhen will the scheduled function run?\n\nAfter the loop.\nBefore the loop.\nIn the beginning of the loop.\n\nWhat is alert going to show?\n\nlet i = 0;\n\nsetTimeout(() => alert(i), 100); // ?\n\n// assume that the time to execute this function is >100ms\nfor(let j = 0; j < 100000000; j++) {\n  i++;\n}\nsolution"
  },
  {
    "title": "The \"new Function\" syntax",
    "url": "https://javascript.info/new-function",
    "html": "There’s one more way to create a function. It’s rarely used, but sometimes there’s no alternative.\n\nSyntax\n\nThe syntax for creating a function:\n\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n\nThe function is created with the arguments arg1...argN and the given functionBody.\n\nIt’s easier to understand by looking at an example. Here’s a function with two arguments:\n\n\t\nlet sum = new Function('a', 'b', 'return a + b');\n\nalert( sum(1, 2) ); // 3\n\nAnd here there’s a function without arguments, with only the function body:\n\n\t\nlet sayHi = new Function('alert(\"Hello\")');\n\nsayHi(); // Hello\n\nThe major difference from other ways we’ve seen is that the function is created literally from a string, that is passed at run time.\n\nAll previous declarations required us, programmers, to write the function code in the script.\n\nBut new Function allows to turn any string into a function. For example, we can receive a new function from a server and then execute it:\n\nlet str = ... receive the code from a server dynamically ...\n\nlet func = new Function(str);\nfunc();\n\nIt is used in very specific cases, like when we receive code from a server, or to dynamically compile a function from a template, in complex web-applications.\n\nClosure\n\nUsually, a function remembers where it was born in the special property [[Environment]]. It references the Lexical Environment from where it’s created (we covered that in the chapter Variable scope, closure).\n\nBut when a function is created using new Function, its [[Environment]] is set to reference not the current Lexical Environment, but the global one.\n\nSo, such function doesn’t have access to outer variables, only to the global ones.\n\n\t\nfunction getFunc() {\n  let value = \"test\";\n\n  let func = new Function('alert(value)');\n\n  return func;\n}\n\ngetFunc()(); // error: value is not defined\n\nCompare it with the regular behavior:\n\n\t\nfunction getFunc() {\n  let value = \"test\";\n\n  let func = function() { alert(value); };\n\n  return func;\n}\n\ngetFunc()(); // \"test\", from the Lexical Environment of getFunc\n\nThis special feature of new Function looks strange, but appears very useful in practice.\n\nImagine that we must create a function from a string. The code of that function is not known at the time of writing the script (that’s why we don’t use regular functions), but will be known in the process of execution. We may receive it from the server or from another source.\n\nOur new function needs to interact with the main script.\n\nWhat if it could access the outer variables?\n\nThe problem is that before JavaScript is published to production, it’s compressed using a minifier – a special program that shrinks code by removing extra comments, spaces and – what’s important, renames local variables into shorter ones.\n\nFor instance, if a function has let userName, minifier replaces it with let a (or another letter if this one is occupied), and does it everywhere. That’s usually a safe thing to do, because the variable is local, nothing outside the function can access it. And inside the function, minifier replaces every mention of it. Minifiers are smart, they analyze the code structure, so they don’t break anything. They’re not just a dumb find-and-replace.\n\nSo if new Function had access to outer variables, it would be unable to find renamed userName.\n\nIf new Function had access to outer variables, it would have problems with minifiers.\n\nBesides, such code would be architecturally bad and prone to errors.\n\nTo pass something to a function, created as new Function, we should use its arguments.\n\nSummary\n\nThe syntax:\n\nlet func = new Function ([arg1, arg2, ...argN], functionBody);\n\nFor historical reasons, arguments can also be given as a comma-separated list.\n\nThese three declarations mean the same:\n\nnew Function('a', 'b', 'return a + b'); // basic syntax\nnew Function('a,b', 'return a + b'); // comma-separated\nnew Function('a , b', 'return a + b'); // comma-separated with spaces\n\nFunctions created with new Function, have [[Environment]] referencing the global Lexical Environment, not the outer one. Hence, they cannot use outer variables. But that’s actually good, because it insures us from errors. Passing parameters explicitly is a much better method architecturally and causes no problems with minifiers."
  },
  {
    "title": "Function object, NFE",
    "url": "https://javascript.info/function-object",
    "html": "As we already know, a function in JavaScript is a value.\n\nEvery value in JavaScript has a type. What type is a function?\n\nIn JavaScript, functions are objects.\n\nA good way to imagine functions is as callable “action objects”. We can not only call them, but also treat them as objects: add/remove properties, pass by reference etc.\n\nThe “name” property\n\nFunction objects contain some useable properties.\n\nFor instance, a function’s name is accessible as the “name” property:\n\n\t\nfunction sayHi() {\n  alert(\"Hi\");\n}\n\nalert(sayHi.name); // sayHi\n\nWhat’s kind of funny, the name-assigning logic is smart. It also assigns the correct name to a function even if it’s created without one, and then immediately assigned:\n\n\t\nlet sayHi = function() {\n  alert(\"Hi\");\n};\n\nalert(sayHi.name); // sayHi (there's a name!)\n\nIt also works if the assignment is done via a default value:\n\n\t\nfunction f(sayHi = function() {}) {\n  alert(sayHi.name); // sayHi (works!)\n}\n\nf();\n\nIn the specification, this feature is called a “contextual name”. If the function does not provide one, then in an assignment it is figured out from the context.\n\nObject methods have names too:\n\n\t\nlet user = {\n\n  sayHi() {\n    // ...\n  },\n\n  sayBye: function() {\n    // ...\n  }\n\n}\n\nalert(user.sayHi.name); // sayHi\nalert(user.sayBye.name); // sayBye\n\nThere’s no magic though. There are cases when there’s no way to figure out the right name. In that case, the name property is empty, like here:\n\n\t\n// function created inside array\nlet arr = [function() {}];\n\nalert( arr[0].name ); // <empty string>\n// the engine has no way to set up the right name, so there is none\n\nIn practice, however, most functions do have a name.\n\nThe “length” property\n\nThere is another built-in property “length” that returns the number of function parameters, for instance:\n\n\t\nfunction f1(a) {}\nfunction f2(a, b) {}\nfunction many(a, b, ...more) {}\n\nalert(f1.length); // 1\nalert(f2.length); // 2\nalert(many.length); // 2\n\nHere we can see that rest parameters are not counted.\n\nThe length property is sometimes used for introspection in functions that operate on other functions.\n\nFor instance, in the code below the ask function accepts a question to ask and an arbitrary number of handler functions to call.\n\nOnce a user provides their answer, the function calls the handlers. We can pass two kinds of handlers:\n\nA zero-argument function, which is only called when the user gives a positive answer.\nA function with arguments, which is called in either case and returns an answer.\n\nTo call handler the right way, we examine the handler.length property.\n\nThe idea is that we have a simple, no-arguments handler syntax for positive cases (most frequent variant), but are able to support universal handlers as well:\n\n\t\nfunction ask(question, ...handlers) {\n  let isYes = confirm(question);\n\n  for(let handler of handlers) {\n    if (handler.length == 0) {\n      if (isYes) handler();\n    } else {\n      handler(isYes);\n    }\n  }\n\n}\n\n// for positive answer, both handlers are called\n// for negative answer, only the second one\nask(\"Question?\", () => alert('You said yes'), result => alert(result));\n\nThis is a particular case of so-called polymorphism – treating arguments differently depending on their type or, in our case depending on the length. The idea does have a use in JavaScript libraries.\n\nCustom properties\n\nWe can also add properties of our own.\n\nHere we add the counter property to track the total calls count:\n\n\t\nfunction sayHi() {\n  alert(\"Hi\");\n\n  // let's count how many times we run\n  sayHi.counter++;\n}\nsayHi.counter = 0; // initial value\n\nsayHi(); // Hi\nsayHi(); // Hi\n\nalert( `Called ${sayHi.counter} times` ); // Called 2 times\nA property is not a variable\n\nA property assigned to a function like sayHi.counter = 0 does not define a local variable counter inside it. In other words, a property counter and a variable let counter are two unrelated things.\n\nWe can treat a function as an object, store properties in it, but that has no effect on its execution. Variables are not function properties and vice versa. These are just parallel worlds.\n\nFunction properties can replace closures sometimes. For instance, we can rewrite the counter function example from the chapter Variable scope, closure to use a function property:\n\n\t\nfunction makeCounter() {\n  // instead of:\n  // let count = 0\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\nalert( counter() ); // 0\nalert( counter() ); // 1\n\nThe count is now stored in the function directly, not in its outer Lexical Environment.\n\nIs it better or worse than using a closure?\n\nThe main difference is that if the value of count lives in an outer variable, then external code is unable to access it. Only nested functions may modify it. And if it’s bound to a function, then such a thing is possible:\n\n\t\nfunction makeCounter() {\n\n  function counter() {\n    return counter.count++;\n  };\n\n  counter.count = 0;\n\n  return counter;\n}\n\nlet counter = makeCounter();\n\ncounter.count = 10;\nalert( counter() ); // 10\n\nSo the choice of implementation depends on our aims.\n\nNamed Function Expression\n\nNamed Function Expression, or NFE, is a term for Function Expressions that have a name.\n\nFor instance, let’s take an ordinary Function Expression:\n\nlet sayHi = function(who) {\n  alert(`Hello, ${who}`);\n};\n\nAnd add a name to it:\n\nlet sayHi = function func(who) {\n  alert(`Hello, ${who}`);\n};\n\nDid we achieve anything here? What’s the purpose of that additional \"func\" name?\n\nFirst let’s note, that we still have a Function Expression. Adding the name \"func\" after function did not make it a Function Declaration, because it is still created as a part of an assignment expression.\n\nAdding such a name also did not break anything.\n\nThe function is still available as sayHi():\n\n\t\nlet sayHi = function func(who) {\n  alert(`Hello, ${who}`);\n};\n\nsayHi(\"John\"); // Hello, John\n\nThere are two special things about the name func, that are the reasons for it:\n\nIt allows the function to reference itself internally.\nIt is not visible outside of the function.\n\nFor instance, the function sayHi below calls itself again with \"Guest\" if no who is provided:\n\n\t\nlet sayHi = function func(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n    func(\"Guest\"); // use func to re-call itself\n  }\n};\n\nsayHi(); // Hello, Guest\n\n// But this won't work:\nfunc(); // Error, func is not defined (not visible outside of the function)\n\nWhy do we use func? Maybe just use sayHi for the nested call?\n\nActually, in most cases we can:\n\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n    sayHi(\"Guest\");\n  }\n};\n\nThe problem with that code is that sayHi may change in the outer code. If the function gets assigned to another variable instead, the code will start to give errors:\n\n\t\nlet sayHi = function(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n    sayHi(\"Guest\"); // Error: sayHi is not a function\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Error, the nested sayHi call doesn't work any more!\n\nThat happens because the function takes sayHi from its outer lexical environment. There’s no local sayHi, so the outer variable is used. And at the moment of the call that outer sayHi is null.\n\nThe optional name which we can put into the Function Expression is meant to solve exactly these kinds of problems.\n\nLet’s use it to fix our code:\n\n\t\nlet sayHi = function func(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n    func(\"Guest\"); // Now all fine\n  }\n};\n\nlet welcome = sayHi;\nsayHi = null;\n\nwelcome(); // Hello, Guest (nested call works)\n\nNow it works, because the name \"func\" is function-local. It is not taken from outside (and not visible there). The specification guarantees that it will always reference the current function.\n\nThe outer code still has its variable sayHi or welcome. And func is an “internal function name”, the way for the function to can call itself reliably.\n\nThere’s no such thing for Function Declaration\n\nThe “internal name” feature described here is only available for Function Expressions, not for Function Declarations. For Function Declarations, there is no syntax for adding an “internal” name.\n\nSometimes, when we need a reliable internal name, it’s the reason to rewrite a Function Declaration to Named Function Expression form.\n\nSummary\n\nFunctions are objects.\n\nHere we covered their properties:\n\nname – the function name. Usually taken from the function definition, but if there’s none, JavaScript tries to guess it from the context (e.g. an assignment).\nlength – the number of arguments in the function definition. Rest parameters are not counted.\n\nIf the function is declared as a Function Expression (not in the main code flow), and it carries the name, then it is called a Named Function Expression. The name can be used inside to reference itself, for recursive calls or such.\n\nAlso, functions may carry additional properties. Many well-known JavaScript libraries make great use of this feature.\n\nThey create a “main” function and attach many other “helper” functions to it. For instance, the jQuery library creates a function named $. The lodash library creates a function _, and then adds _.clone, _.keyBy and other properties to it (see the docs when you want to learn more about them). Actually, they do it to lessen their pollution of the global space, so that a single library gives only one global variable. That reduces the possibility of naming conflicts.\n\nSo, a function can do a useful job by itself and also carry a bunch of other functionality in properties.\n\nTasks\nSet and decrease for counter\nimportance: 5\n\nModify the code of makeCounter() so that the counter can also decrease and set the number:\n\ncounter() should return the next number (as before).\ncounter.set(value) should set the counter to value.\ncounter.decrease() should decrease the counter by 1.\n\nSee the sandbox code for the complete usage example.\n\nP.S. You can use either a closure or the function property to keep the current count. Or write both variants.\n\nOpen a sandbox with tests.\n\nsolution\nSum with an arbitrary amount of brackets\nimportance: 2\n\nWrite function sum that would work like this:\n\nsum(1)(2) == 3; // 1 + 2\nsum(1)(2)(3) == 6; // 1 + 2 + 3\nsum(5)(-1)(2) == 6\nsum(6)(-1)(-2)(-3) == 0\nsum(0)(1)(2)(3)(4)(5) == 15\n\nP.S. Hint: you may need to setup custom object to primitive conversion for your function.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Variable scope, closure",
    "url": "https://javascript.info/closure",
    "html": "JavaScript is a very function-oriented language. It gives us a lot of freedom. A function can be created at any moment, passed as an argument to another function, and then called from a totally different place of code later.\n\nWe already know that a function can access variables outside of it (“outer” variables).\n\nBut what happens if outer variables change since a function is created? Will the function get newer values or the old ones?\n\nAnd what if a function is passed along as an argument and called from another place of code, will it get access to outer variables at the new place?\n\nLet’s expand our knowledge to understand these scenarios and more complex ones.\n\nWe’ll talk about let/const variables here\n\nIn JavaScript, there are 3 ways to declare a variable: let, const (the modern ones), and var (the remnant of the past).\n\nIn this article we’ll use let variables in examples.\nVariables, declared with const, behave the same, so this article is about const too.\nThe old var has some notable differences, they will be covered in the article The old \"var\".\nCode blocks\n\nIf a variable is declared inside a code block {...}, it’s only visible inside that block.\n\nFor example:\n\n\t\n{\n  // do some job with local variables that should not be seen outside\n\n  let message = \"Hello\"; // only visible in this block\n\n  alert(message); // Hello\n}\n\nalert(message); // Error: message is not defined\n\nWe can use this to isolate a piece of code that does its own task, with variables that only belong to it:\n\n\t\n{\n  // show message\n  let message = \"Hello\";\n  alert(message);\n}\n\n{\n  // show another message\n  let message = \"Goodbye\";\n  alert(message);\n}\nThere’d be an error without blocks\n\nPlease note, without separate blocks there would be an error, if we use let with the existing variable name:\n\n\t\n// show message\nlet message = \"Hello\";\nalert(message);\n\n// show another message\nlet message = \"Goodbye\"; // Error: variable already declared\nalert(message);\n\nFor if, for, while and so on, variables declared in {...} are also only visible inside:\n\n\t\nif (true) {\n  let phrase = \"Hello!\";\n\n  alert(phrase); // Hello!\n}\n\nalert(phrase); // Error, no such variable!\n\nHere, after if finishes, the alert below won’t see the phrase, hence the error.\n\nThat’s great, as it allows us to create block-local variables, specific to an if branch.\n\nThe similar thing holds true for for and while loops:\n\n\t\nfor (let i = 0; i < 3; i++) {\n  // the variable i is only visible inside this for\n  alert(i); // 0, then 1, then 2\n}\n\nalert(i); // Error, no such variable\n\nVisually, let i is outside of {...}. But the for construct is special here: the variable, declared inside it, is considered a part of the block.\n\nNested functions\n\nA function is called “nested” when it is created inside another function.\n\nIt is easily possible to do this with JavaScript.\n\nWe can use it to organize our code, like this:\n\nfunction sayHiBye(firstName, lastName) {\n\n  // helper nested function to use below\n  function getFullName() {\n    return firstName + \" \" + lastName;\n  }\n\n  alert( \"Hello, \" + getFullName() );\n  alert( \"Bye, \" + getFullName() );\n\n}\n\nHere the nested function getFullName() is made for convenience. It can access the outer variables and so can return the full name. Nested functions are quite common in JavaScript.\n\nWhat’s much more interesting, a nested function can be returned: either as a property of a new object or as a result by itself. It can then be used somewhere else. No matter where, it still has access to the same outer variables.\n\nBelow, makeCounter creates the “counter” function that returns the next number on each invocation:\n\n\t\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\nalert( counter() ); // 2\n\nDespite being simple, slightly modified variants of that code have practical uses, for instance, as a random number generator to generate random values for automated tests.\n\nHow does this work? If we create multiple counters, will they be independent? What’s going on with the variables here?\n\nUnderstanding such things is great for the overall knowledge of JavaScript and beneficial for more complex scenarios. So let’s go a bit in-depth.\n\nLexical Environment\nHere be dragons!\n\nThe in-depth technical explanation lies ahead.\n\nAs far as I’d like to avoid low-level language details, any understanding without them would be lacking and incomplete, so get ready.\n\nFor clarity, the explanation is split into multiple steps.\n\nStep 1. Variables\n\nIn JavaScript, every running function, code block {...}, and the script as a whole have an internal (hidden) associated object known as the Lexical Environment.\n\nThe Lexical Environment object consists of two parts:\n\nEnvironment Record – an object that stores all local variables as its properties (and some other information like the value of this).\nA reference to the outer lexical environment, the one associated with the outer code.\n\nA “variable” is just a property of the special internal object, Environment Record. “To get or change a variable” means “to get or change a property of that object”.\n\nIn this simple code without functions, there is only one Lexical Environment:\n\nThis is the so-called global Lexical Environment, associated with the whole script.\n\nOn the picture above, the rectangle means Environment Record (variable store) and the arrow means the outer reference. The global Lexical Environment has no outer reference, that’s why the arrow points to null.\n\nAs the code starts executing and goes on, the Lexical Environment changes.\n\nHere’s a little bit longer code:\n\nRectangles on the right-hand side demonstrate how the global Lexical Environment changes during the execution:\n\nWhen the script starts, the Lexical Environment is pre-populated with all declared variables.\nInitially, they are in the “Uninitialized” state. That’s a special internal state, it means that the engine knows about the variable, but it cannot be referenced until it has been declared with let. It’s almost the same as if the variable didn’t exist.\nThen let phrase definition appears. There’s no assignment yet, so its value is undefined. We can use the variable from this point forward.\nphrase is assigned a value.\nphrase changes the value.\n\nEverything looks simple for now, right?\n\nA variable is a property of a special internal object, associated with the currently executing block/function/script.\nWorking with variables is actually working with the properties of that object.\nLexical Environment is a specification object\n\n“Lexical Environment” is a specification object: it only exists “theoretically” in the language specification to describe how things work. We can’t get this object in our code and manipulate it directly.\n\nJavaScript engines also may optimize it, discard variables that are unused to save memory and perform other internal tricks, as long as the visible behavior remains as described.\n\nStep 2. Function Declarations\n\nA function is also a value, like a variable.\n\nThe difference is that a Function Declaration is instantly fully initialized.\n\nWhen a Lexical Environment is created, a Function Declaration immediately becomes a ready-to-use function (unlike let, that is unusable till the declaration).\n\nThat’s why we can use a function, declared as Function Declaration, even before the declaration itself.\n\nFor example, here’s the initial state of the global Lexical Environment when we add a function:\n\nNaturally, this behavior only applies to Function Declarations, not Function Expressions where we assign a function to a variable, such as let say = function(name)....\n\nStep 3. Inner and outer Lexical Environment\n\nWhen a function runs, at the beginning of the call, a new Lexical Environment is created automatically to store local variables and parameters of the call.\n\nFor instance, for say(\"John\"), it looks like this (the execution is at the line, labelled with an arrow):\n\nDuring the function call we have two Lexical Environments: the inner one (for the function call) and the outer one (global):\n\nThe inner Lexical Environment corresponds to the current execution of say. It has a single property: name, the function argument. We called say(\"John\"), so the value of the name is \"John\".\nThe outer Lexical Environment is the global Lexical Environment. It has the phrase variable and the function itself.\n\nThe inner Lexical Environment has a reference to the outer one.\n\nWhen the code wants to access a variable – the inner Lexical Environment is searched first, then the outer one, then the more outer one and so on until the global one.\n\nIf a variable is not found anywhere, that’s an error in strict mode (without use strict, an assignment to a non-existing variable creates a new global variable, for compatibility with old code).\n\nIn this example the search proceeds as follows:\n\nFor the name variable, the alert inside say finds it immediately in the inner Lexical Environment.\nWhen it wants to access phrase, then there is no phrase locally, so it follows the reference to the outer Lexical Environment and finds it there.\nStep 4. Returning a function\n\nLet’s return to the makeCounter example.\n\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\n\nAt the beginning of each makeCounter() call, a new Lexical Environment object is created, to store variables for this makeCounter run.\n\nSo we have two nested Lexical Environments, just like in the example above:\n\nWhat’s different is that, during the execution of makeCounter(), a tiny nested function is created of only one line: return count++. We don’t run it yet, only create.\n\nAll functions remember the Lexical Environment in which they were made. Technically, there’s no magic here: all functions have the hidden property named [[Environment]], that keeps the reference to the Lexical Environment where the function was created:\n\nSo, counter.[[Environment]] has the reference to {count: 0} Lexical Environment. That’s how the function remembers where it was created, no matter where it’s called. The [[Environment]] reference is set once and forever at function creation time.\n\nLater, when counter() is called, a new Lexical Environment is created for the call, and its outer Lexical Environment reference is taken from counter.[[Environment]]:\n\nNow when the code inside counter() looks for count variable, it first searches its own Lexical Environment (empty, as there are no local variables there), then the Lexical Environment of the outer makeCounter() call, where it finds and changes it.\n\nA variable is updated in the Lexical Environment where it lives.\n\nHere’s the state after the execution:\n\nIf we call counter() multiple times, the count variable will be increased to 2, 3 and so on, at the same place.\n\nClosure\n\nThere is a general programming term “closure”, that developers generally should know.\n\nA closure is a function that remembers its outer variables and can access them. In some languages, that’s not possible, or a function should be written in a special way to make it happen. But as explained above, in JavaScript, all functions are naturally closures (there is only one exception, to be covered in The \"new Function\" syntax).\n\nThat is: they automatically remember where they were created using a hidden [[Environment]] property, and then their code can access outer variables.\n\nWhen on an interview, a frontend developer gets a question about “what’s a closure?”, a valid answer would be a definition of the closure and an explanation that all functions in JavaScript are closures, and maybe a few more words about technical details: the [[Environment]] property and how Lexical Environments work.\n\nGarbage collection\n\nUsually, a Lexical Environment is removed from memory with all the variables after the function call finishes. That’s because there are no references to it. As any JavaScript object, it’s only kept in memory while it’s reachable.\n\nHowever, if there’s a nested function that is still reachable after the end of a function, then it has [[Environment]] property that references the lexical environment.\n\nIn that case the Lexical Environment is still reachable even after the completion of the function, so it stays alive.\n\nFor example:\n\nfunction f() {\n  let value = 123;\n\n  return function() {\n    alert(value);\n  }\n}\n\nlet g = f(); // g.[[Environment]] stores a reference to the Lexical Environment\n// of the corresponding f() call\n\nPlease note that if f() is called many times, and resulting functions are saved, then all corresponding Lexical Environment objects will also be retained in memory. In the code below, all 3 of them:\n\nfunction f() {\n  let value = Math.random();\n\n  return function() { alert(value); };\n}\n\n// 3 functions in array, every one of them links to Lexical Environment\n// from the corresponding f() run\nlet arr = [f(), f(), f()];\n\nA Lexical Environment object dies when it becomes unreachable (just like any other object). In other words, it exists only while there’s at least one nested function referencing it.\n\nIn the code below, after the nested function is removed, its enclosing Lexical Environment (and hence the value) is cleaned from memory:\n\nfunction f() {\n  let value = 123;\n\n  return function() {\n    alert(value);\n  }\n}\n\nlet g = f(); // while g function exists, the value stays in memory\n\ng = null; // ...and now the memory is cleaned up\nReal-life optimizations\n\nAs we’ve seen, in theory while a function is alive, all outer variables are also retained.\n\nBut in practice, JavaScript engines try to optimize that. They analyze variable usage and if it’s obvious from the code that an outer variable is not used – it is removed.\n\nAn important side effect in V8 (Chrome, Edge, Opera) is that such variable will become unavailable in debugging.\n\nTry running the example below in Chrome with the Developer Tools open.\n\nWhen it pauses, in the console type alert(value).\n\n\t\nfunction f() {\n  let value = Math.random();\n\n  function g() {\n    debugger; // in console: type alert(value); No such variable!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n\nAs you could see – there is no such variable! In theory, it should be accessible, but the engine optimized it out.\n\nThat may lead to funny (if not such time-consuming) debugging issues. One of them – we can see a same-named outer variable instead of the expected one:\n\n\t\nlet value = \"Surprise!\";\n\nfunction f() {\n  let value = \"the closest value\";\n\n  function g() {\n    debugger; // in console: type alert(value); Surprise!\n  }\n\n  return g;\n}\n\nlet g = f();\ng();\n\nThis feature of V8 is good to know. If you are debugging with Chrome/Edge/Opera, sooner or later you will meet it.\n\nThat is not a bug in the debugger, but rather a special feature of V8. Perhaps it will be changed sometime. You can always check for it by running the examples on this page.\n\nTasks\nDoes a function pickup latest changes?\nimportance: 5\n\nThe function sayHi uses an external variable name. When the function runs, which value is it going to use?\n\nlet name = \"John\";\n\nfunction sayHi() {\n  alert(\"Hi, \" + name);\n}\n\nname = \"Pete\";\n\nsayHi(); // what will it show: \"John\" or \"Pete\"?\n\nSuch situations are common both in browser and server-side development. A function may be scheduled to execute later than it is created, for instance after a user action or a network request.\n\nSo, the question is: does it pick up the latest changes?\n\nsolution\nWhich variables are available?\nimportance: 5\n\nThe function makeWorker below makes another function and returns it. That new function can be called from somewhere else.\n\nWill it have access to the outer variables from its creation place, or the invocation place, or both?\n\nfunction makeWorker() {\n  let name = \"Pete\";\n\n  return function() {\n    alert(name);\n  };\n}\n\nlet name = \"John\";\n\n// create a function\nlet work = makeWorker();\n\n// call it\nwork(); // what will it show?\n\nWhich value it will show? “Pete” or “John”?\n\nsolution\nAre counters independent?\nimportance: 5\n\nHere we make two counters: counter and counter2 using the same makeCounter function.\n\nAre they independent? What is the second counter going to show? 0,1 or 2,3 or something else?\n\nfunction makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\nlet counter2 = makeCounter();\n\nalert( counter() ); // 0\nalert( counter() ); // 1\n\nalert( counter2() ); // ?\nalert( counter2() ); // ?\nsolution\nCounter object\nimportance: 5\n\nHere a counter object is made with the help of the constructor function.\n\nWill it work? What will it show?\n\nfunction Counter() {\n  let count = 0;\n\n  this.up = function() {\n    return ++count;\n  };\n  this.down = function() {\n    return --count;\n  };\n}\n\nlet counter = new Counter();\n\nalert( counter.up() ); // ?\nalert( counter.up() ); // ?\nalert( counter.down() ); // ?\nsolution\nFunction in if\nimportance: 5\n\nLook at the code. What will be the result of the call at the last line?\n\n\t\nlet phrase = \"Hello\";\n\nif (true) {\n  let user = \"John\";\n\n  function sayHi() {\n    alert(`${phrase}, ${user}`);\n  }\n}\n\nsayHi();\nsolution\nSum with closures\nimportance: 4\n\nWrite function sum that works like this: sum(a)(b) = a+b.\n\nYes, exactly this way, using double parentheses (not a mistype).\n\nFor instance:\n\nsum(1)(2) = 3\nsum(5)(-1) = 4\nsolution\nIs variable visible?\nimportance: 4\n\nWhat will be the result of this code?\n\nlet x = 1;\n\nfunction func() {\n  console.log(x); // ?\n\n  let x = 2;\n}\n\nfunc();\n\nP.S. There’s a pitfall in this task. The solution is not obvious.\n\nsolution\nFilter through function\nimportance: 5\n\nWe have a built-in method arr.filter(f) for arrays. It filters all elements through the function f. If it returns true, then that element is returned in the resulting array.\n\nMake a set of “ready to use” filters:\n\ninBetween(a, b) – between a and b or equal to them (inclusively).\ninArray([...]) – in the given array.\n\nThe usage must be like this:\n\narr.filter(inBetween(3,6)) – selects only values between 3 and 6.\narr.filter(inArray([1,2,3])) – selects only elements matching with one of the members of [1,2,3].\n\nFor instance:\n\n/* .. your code for inBetween and inArray */\nlet arr = [1, 2, 3, 4, 5, 6, 7];\n\nalert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6\n\nalert( arr.filter(inArray([1, 2, 10])) ); // 1,2\n\nOpen a sandbox with tests.\n\nsolution\nSort by field\nimportance: 5\n\nWe’ve got an array of objects to sort:\n\nlet users = [\n  { name: \"John\", age: 20, surname: \"Johnson\" },\n  { name: \"Pete\", age: 18, surname: \"Peterson\" },\n  { name: \"Ann\", age: 19, surname: \"Hathaway\" }\n];\n\nThe usual way to do that would be:\n\n// by name (Ann, John, Pete)\nusers.sort((a, b) => a.name > b.name ? 1 : -1);\n\n// by age (Pete, Ann, John)\nusers.sort((a, b) => a.age > b.age ? 1 : -1);\n\nCan we make it even less verbose, like this?\n\nusers.sort(byField('name'));\nusers.sort(byField('age'));\n\nSo, instead of writing a function, just put byField(fieldName).\n\nWrite the function byField that can be used for that.\n\nOpen a sandbox with tests.\n\nsolution\nArmy of functions\nimportance: 5\n\nThe following code creates an array of shooters.\n\nEvery function is meant to output its number. But something is wrong…\n\n\t\nfunction makeArmy() {\n  let shooters = [];\n\n  let i = 0;\n  while (i < 10) {\n    let shooter = function() { // create a shooter function,\n      alert( i ); // that should show its number\n    };\n    shooters.push(shooter); // and add it to the array\n    i++;\n  }\n\n  // ...and return the array of shooters\n  return shooters;\n}\n\nlet army = makeArmy();\n\n// all shooters show 10 instead of their numbers 0, 1, 2, 3...\narmy[0](); // 10 from the shooter number 0\narmy[1](); // 10 from the shooter number 1\narmy[2](); // 10 ...and so on.\n\nWhy do all of the shooters show the same value?\n\nFix the code so that they work as intended.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Global object",
    "url": "https://javascript.info/global-object",
    "html": "The global object provides variables and functions that are available anywhere. By default, those that are built into the language or the environment.\n\nIn a browser it is named window, for Node.js it is global, for other environments it may have another name.\n\nRecently, globalThis was added to the language, as a standardized name for a global object, that should be supported across all environments. It’s supported in all major browsers.\n\nWe’ll use window here, assuming that our environment is a browser. If your script may run in other environments, it’s better to use globalThis instead.\n\nAll properties of the global object can be accessed directly:\n\n\t\nalert(\"Hello\");\n// is the same as\nwindow.alert(\"Hello\");\n\nIn a browser, global functions and variables declared with var (not let/const!) become the property of the global object:\n\n\t\nvar gVar = 5;\n\nalert(window.gVar); // 5 (became a property of the global object)\n\nFunction declarations have the same effect (statements with function keyword in the main code flow, not function expressions).\n\nPlease don’t rely on that! This behavior exists for compatibility reasons. Modern scripts use JavaScript modules where such a thing doesn’t happen.\n\nIf we used let instead, such thing wouldn’t happen:\n\n\t\nlet gLet = 5;\n\nalert(window.gLet); // undefined (doesn't become a property of the global object)\n\nIf a value is so important that you’d like to make it available globally, write it directly as a property:\n\n\t\n// make current user information global, to let all scripts access it\nwindow.currentUser = {\n  name: \"John\"\n};\n\n// somewhere else in code\nalert(currentUser.name);  // John\n\n// or, if we have a local variable with the name \"currentUser\"\n// get it from window explicitly (safe!)\nalert(window.currentUser.name); // John\n\nThat said, using global variables is generally discouraged. There should be as few global variables as possible. The code design where a function gets “input” variables and produces certain “outcome” is clearer, less prone to errors and easier to test than if it uses outer or global variables.\n\nUsing for polyfills\n\nWe use the global object to test for support of modern language features.\n\nFor instance, test if a built-in Promise object exists (it doesn’t in really old browsers):\n\n\t\nif (!window.Promise) {\n  alert(\"Your browser is really old!\");\n}\n\nIf there’s none (say, we’re in an old browser), we can create “polyfills”: add functions that are not supported by the environment, but exist in the modern standard.\n\n\t\nif (!window.Promise) {\n  window.Promise = ... // custom implementation of the modern language feature\n}\nSummary\n\nThe global object holds variables that should be available everywhere.\n\nThat includes JavaScript built-ins, such as Array and environment-specific values, such as window.innerHeight – the window height in the browser.\n\nThe global object has a universal name globalThis.\n\n…But more often is referred by “old-school” environment-specific names, such as window (browser) and global (Node.js).\n\nWe should store values in the global object only if they’re truly global for our project. And keep their number at minimum.\n\nIn-browser, unless we’re using modules, global functions and variables declared with var become a property of the global object.\n\nTo make our code future-proof and easier to understand, we should access properties of the global object directly, as window.x."
  },
  {
    "title": "The old \"var\"",
    "url": "https://javascript.info/var",
    "html": "This article is for understanding old scripts\n\nThe information in this article is useful for understanding old scripts.\n\nThat’s not how we write new code.\n\nIn the very first chapter about variables, we mentioned three ways of variable declaration:\n\nlet\nconst\nvar\n\nThe var declaration is similar to let. Most of the time we can replace let by var or vice-versa and expect things to work:\n\n\t\nvar message = \"Hi\";\nalert(message); // Hi\n\nBut internally var is a very different beast, that originates from very old times. It’s generally not used in modern scripts, but still lurks in the old ones.\n\nIf you don’t plan on meeting such scripts you may even skip this chapter or postpone it.\n\nOn the other hand, it’s important to understand differences when migrating old scripts from var to let, to avoid odd errors.\n\n“var” has no block scope\n\nVariables, declared with var, are either function-scoped or global-scoped. They are visible through blocks.\n\nFor instance:\n\n\t\nif (true) {\n  var test = true; // use \"var\" instead of \"let\"\n}\n\nalert(test); // true, the variable lives after if\n\nAs var ignores code blocks, we’ve got a global variable test.\n\nIf we used let test instead of var test, then the variable would only be visible inside if:\n\n\t\nif (true) {\n  let test = true; // use \"let\"\n}\n\nalert(test); // ReferenceError: test is not defined\n\nThe same thing for loops: var cannot be block- or loop-local:\n\n\t\nfor (var i = 0; i < 10; i++) {\n  var one = 1;\n  // ...\n}\n\nalert(i);   // 10, \"i\" is visible after loop, it's a global variable\nalert(one); // 1, \"one\" is visible after loop, it's a global variable\n\nIf a code block is inside a function, then var becomes a function-level variable:\n\n\t\nfunction sayHi() {\n  if (true) {\n    var phrase = \"Hello\";\n  }\n\n  alert(phrase); // works\n}\n\nsayHi();\nalert(phrase); // ReferenceError: phrase is not defined\n\nAs we can see, var pierces through if, for or other code blocks. That’s because a long time ago in JavaScript, blocks had no Lexical Environments, and var is a remnant of that.\n\n“var” tolerates redeclarations\n\nIf we declare the same variable with let twice in the same scope, that’s an error:\n\n\t\nlet user;\nlet user; // SyntaxError: 'user' has already been declared\n\nWith var, we can redeclare a variable any number of times. If we use var with an already-declared variable, it’s just ignored:\n\n\t\nvar user = \"Pete\";\n\nvar user = \"John\"; // this \"var\" does nothing (already declared)\n// ...it doesn't trigger an error\n\nalert(user); // John\n“var” variables can be declared below their use\n\nvar declarations are processed when the function starts (or script starts for globals).\n\nIn other words, var variables are defined from the beginning of the function, no matter where the definition is (assuming that the definition is not in the nested function).\n\nSo this code:\n\n\t\nfunction sayHi() {\n  phrase = \"Hello\";\n\n  alert(phrase);\n\n  var phrase;\n}\nsayHi();\n\n…Is technically the same as this (moved var phrase above):\n\n\t\nfunction sayHi() {\n  var phrase;\n\n  phrase = \"Hello\";\n\n  alert(phrase);\n}\nsayHi();\n\n…Or even as this (remember, code blocks are ignored):\n\n\t\nfunction sayHi() {\n  phrase = \"Hello\"; // (*)\n\n  if (false) {\n    var phrase;\n  }\n\n  alert(phrase);\n}\nsayHi();\n\nPeople also call such behavior “hoisting” (raising), because all var are “hoisted” (raised) to the top of the function.\n\nSo in the example above, if (false) branch never executes, but that doesn’t matter. The var inside it is processed in the beginning of the function, so at the moment of (*) the variable exists.\n\nDeclarations are hoisted, but assignments are not.\n\nThat’s best demonstrated with an example:\n\n\t\nfunction sayHi() {\n  alert(phrase);\n\n  var phrase = \"Hello\";\n}\n\nsayHi();\n\nThe line var phrase = \"Hello\" has two actions in it:\n\nVariable declaration var\nVariable assignment =.\n\nThe declaration is processed at the start of function execution (“hoisted”), but the assignment always works at the place where it appears. So the code works essentially like this:\n\n\t\nfunction sayHi() {\n  var phrase; // declaration works at the start...\n\n  alert(phrase); // undefined\n\n  phrase = \"Hello\"; // ...assignment - when the execution reaches it.\n}\n\nsayHi();\n\nBecause all var declarations are processed at the function start, we can reference them at any place. But variables are undefined until the assignments.\n\nIn both examples above, alert runs without an error, because the variable phrase exists. But its value is not yet assigned, so it shows undefined.\n\nIIFE\n\nIn the past, as there was only var, and it has no block-level visibility, programmers invented a way to emulate it. What they did was called “immediately-invoked function expressions” (abbreviated as IIFE).\n\nThat’s not something we should use nowadays, but you can find them in old scripts.\n\nAn IIFE looks like this:\n\n\t\n(function() {\n\n  var message = \"Hello\";\n\n  alert(message); // Hello\n\n})();\n\nHere, a Function Expression is created and immediately called. So the code executes right away and has its own private variables.\n\nThe Function Expression is wrapped with parenthesis (function {...}), because when JavaScript engine encounters \"function\" in the main code, it understands it as the start of a Function Declaration. But a Function Declaration must have a name, so this kind of code will give an error:\n\n\t\n// Tries to declare and immediately call a function\nfunction() { // <-- SyntaxError: Function statements require a function name\n\n  var message = \"Hello\";\n\n  alert(message); // Hello\n\n}();\n\nEven if we say: “okay, let’s add a name”, that won’t work, as JavaScript does not allow Function Declarations to be called immediately:\n\n\t\n// syntax error because of parentheses below\nfunction go() {\n\n}(); // <-- can't call Function Declaration immediately\n\nSo, the parentheses around the function is a trick to show JavaScript that the function is created in the context of another expression, and hence it’s a Function Expression: it needs no name and can be called immediately.\n\nThere exist other ways besides parentheses to tell JavaScript that we mean a Function Expression:\n\n\t\n// Ways to create IIFE\n\n(function() {\n  alert(\"Parentheses around the function\");\n})();\n\n(function() {\n  alert(\"Parentheses around the whole thing\");\n}());\n\n!function() {\n  alert(\"Bitwise NOT operator starts the expression\");\n}();\n\n+function() {\n  alert(\"Unary plus starts the expression\");\n}();\n\nIn all the above cases we declare a Function Expression and run it immediately. Let’s note again: nowadays there’s no reason to write such code.\n\nSummary\n\nThere are two main differences of var compared to let/const:\n\nvar variables have no block scope, their visibility is scoped to current function, or global, if declared outside function.\nvar declarations are processed at function start (script start for globals).\n\nThere’s one more very minor difference related to the global object, that we’ll cover in the next chapter.\n\nThese differences make var worse than let most of the time. Block-level variables is such a great thing. That’s why let was introduced in the standard long ago, and is now a major way (along with const) to declare a variable."
  },
  {
    "title": "Rest parameters and spread syntax",
    "url": "https://javascript.info/rest-parameters-spread",
    "html": "Many JavaScript built-in functions support an arbitrary number of arguments.\n\nFor instance:\n\nMath.max(arg1, arg2, ..., argN) – returns the greatest of the arguments.\nObject.assign(dest, src1, ..., srcN) – copies properties from src1..N into dest.\n…and so on.\n\nIn this chapter we’ll learn how to do the same. And also, how to pass arrays to such functions as parameters.\n\nRest parameters ...\n\nA function can be called with any number of arguments, no matter how it is defined.\n\nLike here:\n\n\t\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert( sum(1, 2, 3, 4, 5) );\n\nThere will be no error because of “excessive” arguments. But of course in the result only the first two will be counted, so the result in the code above is 3.\n\nThe rest of the parameters can be included in the function definition by using three dots ... followed by the name of the array that will contain them. The dots literally mean “gather the remaining parameters into an array”.\n\nFor instance, to gather all arguments into array args:\n\n\t\nfunction sumAll(...args) { // args is the name for the array\n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nalert( sumAll(1) ); // 1\nalert( sumAll(1, 2) ); // 3\nalert( sumAll(1, 2, 3) ); // 6\n\nWe can choose to get the first parameters as variables, and gather only the rest.\n\nHere the first two arguments go into variables and the rest go into titles array:\n\n\t\nfunction showName(firstName, lastName, ...titles) {\n  alert( firstName + ' ' + lastName ); // Julius Caesar\n\n  // the rest go into titles array\n  // i.e. titles = [\"Consul\", \"Imperator\"]\n  alert( titles[0] ); // Consul\n  alert( titles[1] ); // Imperator\n  alert( titles.length ); // 2\n}\n\nshowName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\");\nThe rest parameters must be at the end\n\nThe rest parameters gather all remaining arguments, so the following does not make sense and causes an error:\n\nfunction f(arg1, ...rest, arg2) { // arg2 after ...rest ?!\n  // error\n}\n\nThe ...rest must always be last.\n\nThe “arguments” variable\n\nThere is also a special array-like object named arguments that contains all arguments by their index.\n\nFor instance:\n\n\t\nfunction showName() {\n  alert( arguments.length );\n  alert( arguments[0] );\n  alert( arguments[1] );\n\n  // it's iterable\n  // for(let arg of arguments) alert(arg);\n}\n\n// shows: 2, Julius, Caesar\nshowName(\"Julius\", \"Caesar\");\n\n// shows: 1, Ilya, undefined (no second argument)\nshowName(\"Ilya\");\n\nIn old times, rest parameters did not exist in the language, and using arguments was the only way to get all arguments of the function. And it still works, we can find it in the old code.\n\nBut the downside is that although arguments is both array-like and iterable, it’s not an array. It does not support array methods, so we can’t call arguments.map(...) for example.\n\nAlso, it always contains all arguments. We can’t capture them partially, like we did with rest parameters.\n\nSo when we need these features, then rest parameters are preferred.\n\nArrow functions do not have \"arguments\"\n\nIf we access the arguments object from an arrow function, it takes them from the outer “normal” function.\n\nHere’s an example:\n\n\t\nfunction f() {\n  let showArg = () => alert(arguments[0]);\n  showArg();\n}\n\nf(1); // 1\n\nAs we remember, arrow functions don’t have their own this. Now we know they don’t have the special arguments object either.\n\nSpread syntax\n\nWe’ve just seen how to get an array from the list of parameters.\n\nBut sometimes we need to do exactly the reverse.\n\nFor instance, there’s a built-in function Math.max that returns the greatest number from a list:\n\n\t\nalert( Math.max(3, 5, 1) ); // 5\n\nNow let’s say we have an array [3, 5, 1]. How do we call Math.max with it?\n\nPassing it “as is” won’t work, because Math.max expects a list of numeric arguments, not a single array:\n\n\t\nlet arr = [3, 5, 1];\n\nalert( Math.max(arr) ); // NaN\n\nAnd surely we can’t manually list items in the code Math.max(arr[0], arr[1], arr[2]), because we may be unsure how many there are. As our script executes, there could be a lot, or there could be none. And that would get ugly.\n\nSpread syntax to the rescue! It looks similar to rest parameters, also using ..., but does quite the opposite.\n\nWhen ...arr is used in the function call, it “expands” an iterable object arr into the list of arguments.\n\nFor Math.max:\n\n\t\nlet arr = [3, 5, 1];\n\nalert( Math.max(...arr) ); // 5 (spread turns array into a list of arguments)\n\nWe also can pass multiple iterables this way:\n\n\t\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(...arr1, ...arr2) ); // 8\n\nWe can even combine the spread syntax with normal values:\n\n\t\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25\n\nAlso, the spread syntax can be used to merge arrays:\n\n\t\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\nlet merged = [0, ...arr, 2, ...arr2];\n\nalert(merged); // 0,3,5,1,2,8,9,15 (0, then arr, then 2, then arr2)\n\nIn the examples above we used an array to demonstrate the spread syntax, but any iterable will do.\n\nFor instance, here we use the spread syntax to turn the string into array of characters:\n\n\t\nlet str = \"Hello\";\n\nalert( [...str] ); // H,e,l,l,o\n\nThe spread syntax internally uses iterators to gather elements, the same way as for..of does.\n\nSo, for a string, for..of returns characters and ...str becomes \"H\",\"e\",\"l\",\"l\",\"o\". The list of characters is passed to array initializer [...str].\n\nFor this particular task we could also use Array.from, because it converts an iterable (like a string) into an array:\n\n\t\nlet str = \"Hello\";\n\n// Array.from converts an iterable into an array\nalert( Array.from(str) ); // H,e,l,l,o\n\nThe result is the same as [...str].\n\nBut there’s a subtle difference between Array.from(obj) and [...obj]:\n\nArray.from operates on both array-likes and iterables.\nThe spread syntax works only with iterables.\n\nSo, for the task of turning something into an array, Array.from tends to be more universal.\n\nCopy an array/object\n\nRemember when we talked about Object.assign() in the past?\n\nIt is possible to do the same thing with the spread syntax.\n\n\t\nlet arr = [1, 2, 3];\n\nlet arrCopy = [...arr]; // spread the array into a list of parameters\n                        // then put the result into a new array\n\n// do the arrays have the same contents?\nalert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true\n\n// are the arrays equal?\nalert(arr === arrCopy); // false (not same reference)\n\n// modifying our initial array does not modify the copy:\narr.push(4);\nalert(arr); // 1, 2, 3, 4\nalert(arrCopy); // 1, 2, 3\n\nNote that it is possible to do the same thing to make a copy of an object:\n\n\t\nlet obj = { a: 1, b: 2, c: 3 };\n\nlet objCopy = { ...obj }; // spread the object into a list of parameters\n                          // then return the result in a new object\n\n// do the objects have the same contents?\nalert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true\n\n// are the objects equal?\nalert(obj === objCopy); // false (not same reference)\n\n// modifying our initial object does not modify the copy:\nobj.d = 4;\nalert(JSON.stringify(obj)); // {\"a\":1,\"b\":2,\"c\":3,\"d\":4}\nalert(JSON.stringify(objCopy)); // {\"a\":1,\"b\":2,\"c\":3}\n\nThis way of copying an object is much shorter than let objCopy = Object.assign({}, obj) or for an array let arrCopy = Object.assign([], arr) so we prefer to use it whenever we can.\n\nSummary\n\nWhen we see \"...\" in the code, it is either rest parameters or the spread syntax.\n\nThere’s an easy way to distinguish between them:\n\nWhen ... is at the end of function parameters, it’s “rest parameters” and gathers the rest of the list of arguments into an array.\nWhen ... occurs in a function call or alike, it’s called a “spread syntax” and expands an array into a list.\n\nUse patterns:\n\nRest parameters are used to create functions that accept any number of arguments.\nThe spread syntax is used to pass an array to functions that normally require a list of many arguments.\n\nTogether they help to travel between a list and an array of parameters with ease.\n\nAll arguments of a function call are also available in “old-style” arguments: array-like iterable object."
  },
  {
    "title": "JSON methods, toJSON",
    "url": "https://javascript.info/json",
    "html": "Let’s say we have a complex object, and we’d like to convert it into a string, to send it over a network, or just to output it for logging purposes.\n\nNaturally, such a string should include all important properties.\n\nWe could implement the conversion like this:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  toString() {\n    return `{name: \"${this.name}\", age: ${this.age}}`;\n  }\n};\n\nalert(user); // {name: \"John\", age: 30}\n\n…But in the process of development, new properties are added, old properties are renamed and removed. Updating such toString every time can become a pain. We could try to loop over properties in it, but what if the object is complex and has nested objects in properties? We’d need to implement their conversion as well.\n\nLuckily, there’s no need to write the code to handle all this. The task has been solved already.\n\nJSON.stringify\n\nThe JSON (JavaScript Object Notation) is a general format to represent values and objects. It is described as in RFC 4627 standard. Initially it was made for JavaScript, but many other languages have libraries to handle it as well. So it’s easy to use JSON for data exchange when the client uses JavaScript and the server is written on Ruby/PHP/Java/Whatever.\n\nJavaScript provides methods:\n\nJSON.stringify to convert objects into JSON.\nJSON.parse to convert JSON back into an object.\n\nFor instance, here we JSON.stringify a student:\n\n\t\nlet student = {\n  name: 'John',\n  age: 30,\n  isAdmin: false,\n  courses: ['html', 'css', 'js'],\n  spouse: null\n};\n\nlet json = JSON.stringify(student);\n\nalert(typeof json); // we've got a string!\n\nalert(json);\n/* JSON-encoded object:\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"isAdmin\": false,\n  \"courses\": [\"html\", \"css\", \"js\"],\n  \"spouse\": null\n}\n*/\n\nThe method JSON.stringify(student) takes the object and converts it into a string.\n\nThe resulting json string is called a JSON-encoded or serialized or stringified or marshalled object. We are ready to send it over the wire or put into a plain data store.\n\nPlease note that a JSON-encoded object has several important differences from the object literal:\n\nStrings use double quotes. No single quotes or backticks in JSON. So 'John' becomes \"John\".\nObject property names are double-quoted also. That’s obligatory. So age:30 becomes \"age\":30.\n\nJSON.stringify can be applied to primitives as well.\n\nJSON supports following data types:\n\nObjects { ... }\nArrays [ ... ]\nPrimitives:\nstrings,\nnumbers,\nboolean values true/false,\nnull.\n\nFor instance:\n\n\t\n// a number in JSON is just a number\nalert( JSON.stringify(1) ) // 1\n\n// a string in JSON is still a string, but double-quoted\nalert( JSON.stringify('test') ) // \"test\"\n\nalert( JSON.stringify(true) ); // true\n\nalert( JSON.stringify([1, 2, 3]) ); // [1,2,3]\n\nJSON is data-only language-independent specification, so some JavaScript-specific object properties are skipped by JSON.stringify.\n\nNamely:\n\nFunction properties (methods).\nSymbolic keys and values.\nProperties that store undefined.\n\t\nlet user = {\n  sayHi() { // ignored\n    alert(\"Hello\");\n  },\n  [Symbol(\"id\")]: 123, // ignored\n  something: undefined // ignored\n};\n\nalert( JSON.stringify(user) ); // {} (empty object)\n\nUsually that’s fine. If that’s not what we want, then soon we’ll see how to customize the process.\n\nThe great thing is that nested objects are supported and converted automatically.\n\nFor instance:\n\n\t\nlet meetup = {\n  title: \"Conference\",\n  room: {\n    number: 23,\n    participants: [\"john\", \"ann\"]\n  }\n};\n\nalert( JSON.stringify(meetup) );\n/* The whole structure is stringified:\n{\n  \"title\":\"Conference\",\n  \"room\":{\"number\":23,\"participants\":[\"john\",\"ann\"]},\n}\n*/\n\nThe important limitation: there must be no circular references.\n\nFor instance:\n\n\t\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [\"john\", \"ann\"]\n};\n\nmeetup.place = room;       // meetup references room\nroom.occupiedBy = meetup; // room references meetup\n\nJSON.stringify(meetup); // Error: Converting circular structure to JSON\n\nHere, the conversion fails, because of circular reference: room.occupiedBy references meetup, and meetup.place references room:\n\nExcluding and transforming: replacer\n\nThe full syntax of JSON.stringify is:\n\nlet json = JSON.stringify(value[, replacer, space])\nvalue\nA value to encode.\nreplacer\nArray of properties to encode or a mapping function function(key, value).\nspace\nAmount of space to use for formatting\n\nMost of the time, JSON.stringify is used with the first argument only. But if we need to fine-tune the replacement process, like to filter out circular references, we can use the second argument of JSON.stringify.\n\nIf we pass an array of properties to it, only these properties will be encoded.\n\nFor instance:\n\n\t\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup references room\n};\n\nroom.occupiedBy = meetup; // room references meetup\n\nalert( JSON.stringify(meetup, ['title', 'participants']) );\n// {\"title\":\"Conference\",\"participants\":[{},{}]}\n\nHere we are probably too strict. The property list is applied to the whole object structure. So the objects in participants are empty, because name is not in the list.\n\nLet’s include in the list every property except room.occupiedBy that would cause the circular reference:\n\n\t\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup references room\n};\n\nroom.occupiedBy = meetup; // room references meetup\n\nalert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );\n/*\n{\n  \"title\":\"Conference\",\n  \"participants\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\n\nNow everything except occupiedBy is serialized. But the list of properties is quite long.\n\nFortunately, we can use a function instead of an array as the replacer.\n\nThe function will be called for every (key, value) pair and should return the “replaced” value, which will be used instead of the original one. Or undefined if the value is to be skipped.\n\nIn our case, we can return value “as is” for everything except occupiedBy. To ignore occupiedBy, the code below returns undefined:\n\n\t\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  participants: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room // meetup references room\n};\n\nroom.occupiedBy = meetup; // room references meetup\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  alert(`${key}: ${value}`);\n  return (key == 'occupiedBy') ? undefined : value;\n}));\n\n/* key:value pairs that come to replacer:\n:             [object Object]\ntitle:        Conference\nparticipants: [object Object],[object Object]\n0:            [object Object]\nname:         John\n1:            [object Object]\nname:         Alice\nplace:        [object Object]\nnumber:       23\noccupiedBy: [object Object]\n*/\n\nPlease note that replacer function gets every key/value pair including nested objects and array items. It is applied recursively. The value of this inside replacer is the object that contains the current property.\n\nThe first call is special. It is made using a special “wrapper object”: {\"\": meetup}. In other words, the first (key, value) pair has an empty key, and the value is the target object as a whole. That’s why the first line is \":[object Object]\" in the example above.\n\nThe idea is to provide as much power for replacer as possible: it has a chance to analyze and replace/skip even the whole object if necessary.\n\nFormatting: space\n\nThe third argument of JSON.stringify(value, replacer, space) is the number of spaces to use for pretty formatting.\n\nPreviously, all stringified objects had no indents and extra spaces. That’s fine if we want to send an object over a network. The space argument is used exclusively for a nice output.\n\nHere space = 2 tells JavaScript to show nested objects on multiple lines, with indentation of 2 spaces inside an object:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\n\nalert(JSON.stringify(user, null, 2));\n/* two-space indents:\n{\n  \"name\": \"John\",\n  \"age\": 25,\n  \"roles\": {\n    \"isAdmin\": false,\n    \"isEditor\": true\n  }\n}\n*/\n\n/* for JSON.stringify(user, null, 4) the result would be more indented:\n{\n    \"name\": \"John\",\n    \"age\": 25,\n    \"roles\": {\n        \"isAdmin\": false,\n        \"isEditor\": true\n    }\n}\n*/\n\nThe third argument can also be a string. In this case, the string is used for indentation instead of a number of spaces.\n\nThe space parameter is used solely for logging and nice-output purposes.\n\nCustom “toJSON”\n\nLike toString for string conversion, an object may provide method toJSON for to-JSON conversion. JSON.stringify automatically calls it if available.\n\nFor instance:\n\n\t\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  date: new Date(Date.UTC(2017, 0, 1)),\n  room\n};\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n    \"date\":\"2017-01-01T00:00:00.000Z\",  // (1)\n    \"room\": {\"number\":23}               // (2)\n  }\n*/\n\nHere we can see that date (1) became a string. That’s because all dates have a built-in toJSON method which returns such kind of string.\n\nNow let’s add a custom toJSON for our object room (2):\n\n\t\nlet room = {\n  number: 23,\n  toJSON() {\n    return this.number;\n  }\n};\n\nlet meetup = {\n  title: \"Conference\",\n  room\n};\n\nalert( JSON.stringify(room) ); // 23\n\nalert( JSON.stringify(meetup) );\n/*\n  {\n    \"title\":\"Conference\",\n    \"room\": 23\n  }\n*/\n\nAs we can see, toJSON is used both for the direct call JSON.stringify(room) and when room is nested in another encoded object.\n\nJSON.parse\n\nTo decode a JSON-string, we need another method named JSON.parse.\n\nThe syntax:\n\nlet value = JSON.parse(str, [reviver]);\nstr\nJSON-string to parse.\nreviver\nOptional function(key,value) that will be called for each (key, value) pair and can transform the value.\n\nFor instance:\n\n\t\n// stringified array\nlet numbers = \"[0, 1, 2, 3]\";\n\nnumbers = JSON.parse(numbers);\n\nalert( numbers[1] ); // 1\n\nOr for nested objects:\n\n\t\nlet userData = '{ \"name\": \"John\", \"age\": 35, \"isAdmin\": false, \"friends\": [0,1,2,3] }';\n\nlet user = JSON.parse(userData);\n\nalert( user.friends[1] ); // 1\n\nThe JSON may be as complex as necessary, objects and arrays can include other objects and arrays. But they must obey the same JSON format.\n\nHere are typical mistakes in hand-written JSON (sometimes we have to write it for debugging purposes):\n\nlet json = `{\n  name: \"John\",                     // mistake: property name without quotes\n  \"surname\": 'Smith',               // mistake: single quotes in value (must be double)\n  'isAdmin': false                  // mistake: single quotes in key (must be double)\n  \"birthday\": new Date(2000, 2, 3), // mistake: no \"new\" is allowed, only bare values\n  \"friends\": [0,1,2,3]              // here all fine\n}`;\n\nBesides, JSON does not support comments. Adding a comment to JSON makes it invalid.\n\nThere’s another format named JSON5, which allows unquoted keys, comments etc. But this is a standalone library, not in the specification of the language.\n\nThe regular JSON is that strict not because its developers are lazy, but to allow easy, reliable and very fast implementations of the parsing algorithm.\n\nUsing reviver\n\nImagine, we got a stringified meetup object from the server.\n\nIt looks like this:\n\n// title: (meetup title), date: (meetup date)\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\n…And now we need to deserialize it, to turn back into JavaScript object.\n\nLet’s do it by calling JSON.parse:\n\n\t\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\nlet meetup = JSON.parse(str);\n\nalert( meetup.date.getDate() ); // Error!\n\nWhoops! An error!\n\nThe value of meetup.date is a string, not a Date object. How could JSON.parse know that it should transform that string into a Date?\n\nLet’s pass to JSON.parse the reviving function as the second argument, that returns all values “as is”, but date will become a Date:\n\n\t\nlet str = '{\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"}';\n\nlet meetup = JSON.parse(str, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n\nalert( meetup.date.getDate() ); // now works!\n\nBy the way, that works for nested objects as well:\n\n\t\nlet schedule = `{\n  \"meetups\": [\n    {\"title\":\"Conference\",\"date\":\"2017-11-30T12:00:00.000Z\"},\n    {\"title\":\"Birthday\",\"date\":\"2017-04-18T12:00:00.000Z\"}\n  ]\n}`;\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == 'date') return new Date(value);\n  return value;\n});\n\nalert( schedule.meetups[1].date.getDate() ); // works!\nSummary\nJSON is a data format that has its own independent standard and libraries for most programming languages.\nJSON supports plain objects, arrays, strings, numbers, booleans, and null.\nJavaScript provides methods JSON.stringify to serialize into JSON and JSON.parse to read from JSON.\nBoth methods support transformer functions for smart reading/writing.\nIf an object has toJSON, then it is called by JSON.stringify.\nTasks\nTurn the object into JSON and back\nimportance: 5\n\nTurn the user into JSON and then read it back into another variable.\n\nlet user = {\n  name: \"John Smith\",\n  age: 35\n};\nsolution\nExclude backreferences\nimportance: 5\n\nIn simple cases of circular references, we can exclude an offending property from serialization by its name.\n\nBut sometimes we can’t just use the name, as it may be used both in circular references and normal properties. So we can check the property by its value.\n\nWrite replacer function to stringify everything, but remove properties that reference meetup:\n\n\t\nlet room = {\n  number: 23\n};\n\nlet meetup = {\n  title: \"Conference\",\n  occupiedBy: [{name: \"John\"}, {name: \"Alice\"}],\n  place: room\n};\n\n// circular references\nroom.occupiedBy = meetup;\nmeetup.self = meetup;\n\nalert( JSON.stringify(meetup, function replacer(key, value) {\n  /* your code */\n}));\n\n/* result should be:\n{\n  \"title\":\"Conference\",\n  \"occupiedBy\":[{\"name\":\"John\"},{\"name\":\"Alice\"}],\n  \"place\":{\"number\":23}\n}\n*/\nsolution"
  },
  {
    "title": "Recursion and stack",
    "url": "https://javascript.info/recursion",
    "html": "Let’s return to functions and study them more in-depth.\n\nOur first topic will be recursion.\n\nIf you are not new to programming, then it is probably familiar and you could skip this chapter.\n\nRecursion is a programming pattern that is useful in situations when a task can be naturally split into several tasks of the same kind, but simpler. Or when a task can be simplified into an easy action plus a simpler variant of the same task. Or, as we’ll see soon, to deal with certain data structures.\n\nWhen a function solves a task, in the process it can call many other functions. A partial case of this is when a function calls itself. That’s called recursion.\n\nTwo ways of thinking\n\nFor something simple to start with – let’s write a function pow(x, n) that raises x to a natural power of n. In other words, multiplies x by itself n times.\n\npow(2, 2) = 4\npow(2, 3) = 8\npow(2, 4) = 16\n\nThere are two ways to implement it.\n\nIterative thinking: the for loop:\n\n\t\nfunction pow(x, n) {\n  let result = 1;\n\n  // multiply result by x n times in the loop\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nalert( pow(2, 3) ); // 8\n\nRecursive thinking: simplify the task and call self:\n\n\t\nfunction pow(x, n) {\n  if (n == 1) {\n    return x;\n  } else {\n    return x * pow(x, n - 1);\n  }\n}\n\nalert( pow(2, 3) ); // 8\n\nPlease note how the recursive variant is fundamentally different.\n\nWhen pow(x, n) is called, the execution splits into two branches:\n\n              if n==1  = x\n             /\npow(x, n) =\n             \\\n              else     = x * pow(x, n - 1)\nIf n == 1, then everything is trivial. It is called the base of recursion, because it immediately produces the obvious result: pow(x, 1) equals x.\nOtherwise, we can represent pow(x, n) as x * pow(x, n - 1). In maths, one would write xn = x * xn-1. This is called a recursive step: we transform the task into a simpler action (multiplication by x) and a simpler call of the same task (pow with lower n). Next steps simplify it further and further until n reaches 1.\n\nWe can also say that pow recursively calls itself till n == 1.\n\nFor example, to calculate pow(2, 4) the recursive variant does these steps:\n\npow(2, 4) = 2 * pow(2, 3)\npow(2, 3) = 2 * pow(2, 2)\npow(2, 2) = 2 * pow(2, 1)\npow(2, 1) = 2\n\nSo, the recursion reduces a function call to a simpler one, and then – to even more simpler, and so on, until the result becomes obvious.\n\nRecursion is usually shorter\n\nA recursive solution is usually shorter than an iterative one.\n\nHere we can rewrite the same using the conditional operator ? instead of if to make pow(x, n) more terse and still very readable:\n\n\t\nfunction pow(x, n) {\n  return (n == 1) ? x : (x * pow(x, n - 1));\n}\n\nThe maximal number of nested calls (including the first one) is called recursion depth. In our case, it will be exactly n.\n\nThe maximal recursion depth is limited by JavaScript engine. We can rely on it being 10000, some engines allow more, but 100000 is probably out of limit for the majority of them. There are automatic optimizations that help alleviate this (“tail calls optimizations”), but they are not yet supported everywhere and work only in simple cases.\n\nThat limits the application of recursion, but it still remains very wide. There are many tasks where recursive way of thinking gives simpler code, easier to maintain.\n\nThe execution context and stack\n\nNow let’s examine how recursive calls work. For that we’ll look under the hood of functions.\n\nThe information about the process of execution of a running function is stored in its execution context.\n\nThe execution context is an internal data structure that contains details about the execution of a function: where the control flow is now, the current variables, the value of this (we don’t use it here) and few other internal details.\n\nOne function call has exactly one execution context associated with it.\n\nWhen a function makes a nested call, the following happens:\n\nThe current function is paused.\nThe execution context associated with it is remembered in a special data structure called execution context stack.\nThe nested call executes.\nAfter it ends, the old execution context is retrieved from the stack, and the outer function is resumed from where it stopped.\n\nLet’s see what happens during the pow(2, 3) call.\n\npow(2, 3)\n\nIn the beginning of the call pow(2, 3) the execution context will store variables: x = 2, n = 3, the execution flow is at line 1 of the function.\n\nWe can sketch it as:\n\nContext: { x: 2, n: 3, at line 1 } pow(2, 3)\n\nThat’s when the function starts to execute. The condition n == 1 is falsy, so the flow continues into the second branch of if:\n\n\t\nfunction pow(x, n) {\n  if (n == 1) {\n    return x;\n  } else {\n    return x * pow(x, n - 1);\n  }\n}\n\nalert( pow(2, 3) );\n\nThe variables are same, but the line changes, so the context is now:\n\nContext: { x: 2, n: 3, at line 5 } pow(2, 3)\n\nTo calculate x * pow(x, n - 1), we need to make a subcall of pow with new arguments pow(2, 2).\n\npow(2, 2)\n\nTo do a nested call, JavaScript remembers the current execution context in the execution context stack.\n\nHere we call the same function pow, but it absolutely doesn’t matter. The process is the same for all functions:\n\nThe current context is “remembered” on top of the stack.\nThe new context is created for the subcall.\nWhen the subcall is finished – the previous context is popped from the stack, and its execution continues.\n\nHere’s the context stack when we entered the subcall pow(2, 2):\n\nContext: { x: 2, n: 2, at line 1 } pow(2, 2)\nContext: { x: 2, n: 3, at line 5 } pow(2, 3)\n\nThe new current execution context is on top (and bold), and previous remembered contexts are below.\n\nWhen we finish the subcall – it is easy to resume the previous context, because it keeps both variables and the exact place of the code where it stopped.\n\nPlease note:\n\nHere in the picture we use the word “line”, as in our example there’s only one subcall in line, but generally a single line of code may contain multiple subcalls, like pow(…) + pow(…) + somethingElse(…).\n\nSo it would be more precise to say that the execution resumes “immediately after the subcall”.\n\npow(2, 1)\n\nThe process repeats: a new subcall is made at line 5, now with arguments x=2, n=1.\n\nA new execution context is created, the previous one is pushed on top of the stack:\n\nContext: { x: 2, n: 1, at line 1 } pow(2, 1)\nContext: { x: 2, n: 2, at line 5 } pow(2, 2)\nContext: { x: 2, n: 3, at line 5 } pow(2, 3)\n\nThere are 2 old contexts now and 1 currently running for pow(2, 1).\n\nThe exit\n\nDuring the execution of pow(2, 1), unlike before, the condition n == 1 is truthy, so the first branch of if works:\n\nfunction pow(x, n) {\n  if (n == 1) {\n    return x;\n  } else {\n    return x * pow(x, n - 1);\n  }\n}\n\nThere are no more nested calls, so the function finishes, returning 2.\n\nAs the function finishes, its execution context is not needed anymore, so it’s removed from the memory. The previous one is restored off the top of the stack:\n\nContext: { x: 2, n: 2, at line 5 } pow(2, 2)\nContext: { x: 2, n: 3, at line 5 } pow(2, 3)\n\nThe execution of pow(2, 2) is resumed. It has the result of the subcall pow(2, 1), so it also can finish the evaluation of x * pow(x, n - 1), returning 4.\n\nThen the previous context is restored:\n\nContext: { x: 2, n: 3, at line 5 } pow(2, 3)\n\nWhen it finishes, we have a result of pow(2, 3) = 8.\n\nThe recursion depth in this case was: 3.\n\nAs we can see from the illustrations above, recursion depth equals the maximal number of context in the stack.\n\nNote the memory requirements. Contexts take memory. In our case, raising to the power of n actually requires the memory for n contexts, for all lower values of n.\n\nA loop-based algorithm is more memory-saving:\n\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nThe iterative pow uses a single context changing i and result in the process. Its memory requirements are small, fixed and do not depend on n.\n\nAny recursion can be rewritten as a loop. The loop variant usually can be made more effective.\n\n…But sometimes the rewrite is non-trivial, especially when a function uses different recursive subcalls depending on conditions and merges their results or when the branching is more intricate. And the optimization may be unneeded and totally not worth the efforts.\n\nRecursion can give a shorter code, easier to understand and support. Optimizations are not required in every place, mostly we need a good code, that’s why it’s used.\n\nRecursive traversals\n\nAnother great application of the recursion is a recursive traversal.\n\nImagine, we have a company. The staff structure can be presented as an object:\n\nlet company = {\n  sales: [{\n    name: 'John',\n    salary: 1000\n  }, {\n    name: 'Alice',\n    salary: 1600\n  }],\n\n  development: {\n    sites: [{\n      name: 'Peter',\n      salary: 2000\n    }, {\n      name: 'Alex',\n      salary: 1800\n    }],\n\n    internals: [{\n      name: 'Jack',\n      salary: 1300\n    }]\n  }\n};\n\nIn other words, a company has departments.\n\nA department may have an array of staff. For instance, sales department has 2 employees: John and Alice.\n\nOr a department may split into subdepartments, like development has two branches: sites and internals. Each of them has their own staff.\n\nIt is also possible that when a subdepartment grows, it divides into subsubdepartments (or teams).\n\nFor instance, the sites department in the future may be split into teams for siteA and siteB. And they, potentially, can split even more. That’s not on the picture, just something to have in mind.\n\nNow let’s say we want a function to get the sum of all salaries. How can we do that?\n\nAn iterative approach is not easy, because the structure is not simple. The first idea may be to make a for loop over company with nested subloop over 1st level departments. But then we need more nested subloops to iterate over the staff in 2nd level departments like sites… And then another subloop inside those for 3rd level departments that might appear in the future? If we put 3-4 nested subloops in the code to traverse a single object, it becomes rather ugly.\n\nLet’s try recursion.\n\nAs we can see, when our function gets a department to sum, there are two possible cases:\n\nEither it’s a “simple” department with an array of people – then we can sum the salaries in a simple loop.\nOr it’s an object with N subdepartments – then we can make N recursive calls to get the sum for each of the subdeps and combine the results.\n\nThe 1st case is the base of recursion, the trivial case, when we get an array.\n\nThe 2nd case when we get an object is the recursive step. A complex task is split into subtasks for smaller departments. They may in turn split again, but sooner or later the split will finish at (1).\n\nThe algorithm is probably even easier to read from the code:\n\n\t\nlet company = { // the same object, compressed for brevity\n  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],\n  development: {\n    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],\n    internals: [{name: 'Jack', salary: 1300}]\n  }\n};\n\n// The function to do the job\nfunction sumSalaries(department) {\n  if (Array.isArray(department)) { // case (1)\n    return department.reduce((prev, current) => prev + current.salary, 0); // sum the array\n  } else { // case (2)\n    let sum = 0;\n    for (let subdep of Object.values(department)) {\n      sum += sumSalaries(subdep); // recursively call for subdepartments, sum the results\n    }\n    return sum;\n  }\n}\n\nalert(sumSalaries(company)); // 7700\n\nThe code is short and easy to understand (hopefully?). That’s the power of recursion. It also works for any level of subdepartment nesting.\n\nHere’s the diagram of calls:\n\nWe can easily see the principle: for an object {...} subcalls are made, while arrays [...] are the “leaves” of the recursion tree, they give immediate result.\n\nNote that the code uses smart features that we’ve covered before:\n\nMethod arr.reduce explained in the chapter Array methods to get the sum of the array.\nLoop for(val of Object.values(obj)) to iterate over object values: Object.values returns an array of them.\nRecursive structures\n\nA recursive (recursively-defined) data structure is a structure that replicates itself in parts.\n\nWe’ve just seen it in the example of a company structure above.\n\nA company department is:\n\nEither an array of people.\nOr an object with departments.\n\nFor web-developers there are much better-known examples: HTML and XML documents.\n\nIn the HTML document, an HTML-tag may contain a list of:\n\nText pieces.\nHTML-comments.\nOther HTML-tags (that in turn may contain text pieces/comments or other tags etc).\n\nThat’s once again a recursive definition.\n\nFor better understanding, we’ll cover one more recursive structure named “Linked list” that might be a better alternative for arrays in some cases.\n\nLinked list\n\nImagine, we want to store an ordered list of objects.\n\nThe natural choice would be an array:\n\nlet arr = [obj1, obj2, obj3];\n\n…But there’s a problem with arrays. The “delete element” and “insert element” operations are expensive. For instance, arr.unshift(obj) operation has to renumber all elements to make room for a new obj, and if the array is big, it takes time. Same with arr.shift().\n\nThe only structural modifications that do not require mass-renumbering are those that operate with the end of array: arr.push/pop. So an array can be quite slow for big queues, when we have to work with the beginning.\n\nAlternatively, if we really need fast insertion/deletion, we can choose another data structure called a linked list.\n\nThe linked list element is recursively defined as an object with:\n\nvalue.\nnext property referencing the next linked list element or null if that’s the end.\n\nFor instance:\n\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nGraphical representation of the list:\n\nAn alternative code for creation:\n\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\nlist.next.next.next.next = null;\n\nHere we can even more clearly see that there are multiple objects, each one has the value and next pointing to the neighbour. The list variable is the first object in the chain, so following next pointers from it we can reach any element.\n\nThe list can be easily split into multiple parts and later joined back:\n\nlet secondList = list.next.next;\nlist.next.next = null;\n\nTo join:\n\nlist.next.next = secondList;\n\nAnd surely we can insert or remove items in any place.\n\nFor instance, to prepend a new value, we need to update the head of the list:\n\nlet list = { value: 1 };\nlist.next = { value: 2 };\nlist.next.next = { value: 3 };\nlist.next.next.next = { value: 4 };\n\n// prepend the new value to the list\nlist = { value: \"new item\", next: list };\n\nTo remove a value from the middle, change next of the previous one:\n\nlist.next = list.next.next;\n\nWe made list.next jump over 1 to value 2. The value 1 is now excluded from the chain. If it’s not stored anywhere else, it will be automatically removed from the memory.\n\nUnlike arrays, there’s no mass-renumbering, we can easily rearrange elements.\n\nNaturally, lists are not always better than arrays. Otherwise everyone would use only lists.\n\nThe main drawback is that we can’t easily access an element by its number. In an array that’s easy: arr[n] is a direct reference. But in the list we need to start from the first item and go next N times to get the Nth element.\n\n…But we don’t always need such operations. For instance, when we need a queue or even a deque – the ordered structure that must allow very fast adding/removing elements from both ends, but access to its middle is not needed.\n\nLists can be enhanced:\n\nWe can add property prev in addition to next to reference the previous element, to move back easily.\nWe can also add a variable named tail referencing the last element of the list (and update it when adding/removing elements from the end).\n…The data structure may vary according to our needs.\nSummary\n\nTerms:\n\nRecursion is a programming term that means calling a function from itself. Recursive functions can be used to solve tasks in elegant ways.\n\nWhen a function calls itself, that’s called a recursion step. The basis of recursion is function arguments that make the task so simple that the function does not make further calls.\n\nA recursively-defined data structure is a data structure that can be defined using itself.\n\nFor instance, the linked list can be defined as a data structure consisting of an object referencing a list (or null).\n\nlist = { value, next -> list }\n\nTrees like HTML elements tree or the department tree from this chapter are also naturally recursive: they have branches and every branch can have other branches.\n\nRecursive functions can be used to walk them as we’ve seen in the sumSalary example.\n\nAny recursive function can be rewritten into an iterative one. And that’s sometimes required to optimize stuff. But for many tasks a recursive solution is fast enough and easier to write and support.\n\nTasks\nSum all numbers till the given one\nimportance: 5\n\nWrite a function sumTo(n) that calculates the sum of numbers 1 + 2 + ... + n.\n\nFor instance:\n\nsumTo(1) = 1\nsumTo(2) = 2 + 1 = 3\nsumTo(3) = 3 + 2 + 1 = 6\nsumTo(4) = 4 + 3 + 2 + 1 = 10\n...\nsumTo(100) = 100 + 99 + ... + 2 + 1 = 5050\n\nMake 3 solution variants:\n\nUsing a for loop.\nUsing a recursion, cause sumTo(n) = n + sumTo(n-1) for n > 1.\nUsing the arithmetic progression formula.\n\nAn example of the result:\n\nfunction sumTo(n) { /*... your code ... */ }\n\nalert( sumTo(100) ); // 5050\n\nP.S. Which solution variant is the fastest? The slowest? Why?\n\nP.P.S. Can we use recursion to count sumTo(100000)?\n\nsolution\nCalculate factorial\nimportance: 4\n\nThe factorial of a natural number is a number multiplied by \"number minus one\", then by \"number minus two\", and so on till 1. The factorial of n is denoted as n!\n\nWe can write a definition of factorial like this:\n\nn! = n * (n - 1) * (n - 2) * ...*1\n\nValues of factorials for different n:\n\n1! = 1\n2! = 2 * 1 = 2\n3! = 3 * 2 * 1 = 6\n4! = 4 * 3 * 2 * 1 = 24\n5! = 5 * 4 * 3 * 2 * 1 = 120\n\nThe task is to write a function factorial(n) that calculates n! using recursive calls.\n\nalert( factorial(5) ); // 120\n\nP.S. Hint: n! can be written as n * (n-1)! For instance: 3! = 3*2! = 3*2*1! = 6\n\nsolution\nFibonacci numbers\nimportance: 5\n\nThe sequence of Fibonacci numbers has the formula Fn = Fn-1 + Fn-2. In other words, the next number is a sum of the two preceding ones.\n\nFirst two numbers are 1, then 2(1+1), then 3(1+2), 5(2+3) and so on: 1, 1, 2, 3, 5, 8, 13, 21....\n\nFibonacci numbers are related to the Golden ratio and many natural phenomena around us.\n\nWrite a function fib(n) that returns the n-th Fibonacci number.\n\nAn example of work:\n\nfunction fib(n) { /* your code */ }\n\nalert(fib(3)); // 2\nalert(fib(7)); // 13\nalert(fib(77)); // 5527939700884757\n\nP.S. The function should be fast. The call to fib(77) should take no more than a fraction of a second.\n\nsolution\nOutput a single-linked list\nimportance: 5\n\nLet’s say we have a single-linked list (as described in the chapter Recursion and stack):\n\nlet list = {\n  value: 1,\n  next: {\n    value: 2,\n    next: {\n      value: 3,\n      next: {\n        value: 4,\n        next: null\n      }\n    }\n  }\n};\n\nWrite a function printList(list) that outputs list items one-by-one.\n\nMake two variants of the solution: using a loop and using recursion.\n\nWhat’s better: with recursion or without it?\n\nsolution\nOutput a single-linked list in the reverse order\nimportance: 5\n\nOutput a single-linked list from the previous task Output a single-linked list in the reverse order.\n\nMake two solutions: using a loop and using a recursion.\n\nsolution"
  },
  {
    "title": "Date and time",
    "url": "https://javascript.info/date",
    "html": "Let’s meet a new built-in object: Date. It stores the date, time and provides methods for date/time management.\n\nFor instance, we can use it to store creation/modification times, to measure time, or just to print out the current date.\n\nCreation\n\nTo create a new Date object call new Date() with one of the following arguments:\n\nnew Date()\n\nWithout arguments – create a Date object for the current date and time:\n\n\t\nlet now = new Date();\nalert( now ); // shows current date/time\nnew Date(milliseconds)\n\nCreate a Date object with the time equal to number of milliseconds (1/1000 of a second) passed after the Jan 1st of 1970 UTC+0.\n\n\t\n// 0 means 01.01.1970 UTC+0\nlet Jan01_1970 = new Date(0);\nalert( Jan01_1970 );\n\n// now add 24 hours, get 02.01.1970 UTC+0\nlet Jan02_1970 = new Date(24 * 3600 * 1000);\nalert( Jan02_1970 );\n\nAn integer number representing the number of milliseconds that has passed since the beginning of 1970 is called a timestamp.\n\nIt’s a lightweight numeric representation of a date. We can always create a date from a timestamp using new Date(timestamp) and convert the existing Date object to a timestamp using the date.getTime() method (see below).\n\nDates before 01.01.1970 have negative timestamps, e.g.:\n\n\t\n// 31 Dec 1969\nlet Dec31_1969 = new Date(-24 * 3600 * 1000);\nalert( Dec31_1969 );\nnew Date(datestring)\n\nIf there is a single argument, and it’s a string, then it is parsed automatically. The algorithm is the same as Date.parse uses, we’ll cover it later.\n\n\t\nlet date = new Date(\"2017-01-26\");\nalert(date);\n// The time is not set, so it's assumed to be midnight GMT and\n// is adjusted according to the timezone the code is run in\n// So the result could be\n// Thu Jan 26 2017 11:00:00 GMT+1100 (Australian Eastern Daylight Time)\n// or\n// Wed Jan 25 2017 16:00:00 GMT-0800 (Pacific Standard Time)\nnew Date(year, month, date, hours, minutes, seconds, ms)\n\nCreate the date with the given components in the local time zone. Only the first two arguments are obligatory.\n\nThe year should have 4 digits. For compatibility, 2 digits are also accepted and considered 19xx, e.g. 98 is the same as 1998 here, but always using 4 digits is strongly encouraged.\nThe month count starts with 0 (Jan), up to 11 (Dec).\nThe date parameter is actually the day of month, if absent then 1 is assumed.\nIf hours/minutes/seconds/ms is absent, they are assumed to be equal 0.\n\nFor instance:\n\nnew Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00\nnew Date(2011, 0, 1); // the same, hours etc are 0 by default\n\nThe maximal precision is 1 ms (1/1000 sec):\n\n\t\nlet date = new Date(2011, 0, 1, 2, 3, 4, 567);\nalert( date ); // 1.01.2011, 02:03:04.567\nAccess date components\n\nThere are methods to access the year, month and so on from the Date object:\n\ngetFullYear()\nGet the year (4 digits)\ngetMonth()\nGet the month, from 0 to 11.\ngetDate()\nGet the day of month, from 1 to 31, the name of the method does look a little bit strange.\ngetHours(), getMinutes(), getSeconds(), getMilliseconds()\nGet the corresponding time components.\nNot getYear(), but getFullYear()\n\nMany JavaScript engines implement a non-standard method getYear(). This method is deprecated. It returns 2-digit year sometimes. Please never use it. There is getFullYear() for the year.\n\nAdditionally, we can get a day of week:\n\ngetDay()\nGet the day of week, from 0 (Sunday) to 6 (Saturday). The first day is always Sunday, in some countries that’s not so, but can’t be changed.\n\nAll the methods above return the components relative to the local time zone.\n\nThere are also their UTC-counterparts, that return day, month, year and so on for the time zone UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Just insert the \"UTC\" right after \"get\".\n\nIf your local time zone is shifted relative to UTC, then the code below shows different hours:\n\n\t\n// current date\nlet date = new Date();\n\n// the hour in your current time zone\nalert( date.getHours() );\n\n// the hour in UTC+0 time zone (London time without daylight savings)\nalert( date.getUTCHours() );\n\nBesides the given methods, there are two special ones that do not have a UTC-variant:\n\ngetTime()\n\nReturns the timestamp for the date – a number of milliseconds passed from the January 1st of 1970 UTC+0.\n\ngetTimezoneOffset()\n\nReturns the difference between UTC and the local time zone, in minutes:\n\n\t\n// if you are in timezone UTC-1, outputs 60\n// if you are in timezone UTC+3, outputs -180\nalert( new Date().getTimezoneOffset() );\nSetting date components\n\nThe following methods allow to set date/time components:\n\nsetFullYear(year, [month], [date])\nsetMonth(month, [date])\nsetDate(date)\nsetHours(hour, [min], [sec], [ms])\nsetMinutes(min, [sec], [ms])\nsetSeconds(sec, [ms])\nsetMilliseconds(ms)\nsetTime(milliseconds) (sets the whole date by milliseconds since 01.01.1970 UTC)\n\nEvery one of them except setTime() has a UTC-variant, for instance: setUTCHours().\n\nAs we can see, some methods can set multiple components at once, for example setHours. The components that are not mentioned are not modified.\n\nFor instance:\n\n\t\nlet today = new Date();\n\ntoday.setHours(0);\nalert(today); // still today, but the hour is changed to 0\n\ntoday.setHours(0, 0, 0, 0);\nalert(today); // still today, now 00:00:00 sharp.\nAutocorrection\n\nThe autocorrection is a very handy feature of Date objects. We can set out-of-range values, and it will auto-adjust itself.\n\nFor instance:\n\n\t\nlet date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?\nalert(date); // ...is 1st Feb 2013!\n\nOut-of-range date components are distributed automatically.\n\nLet’s say we need to increase the date “28 Feb 2016” by 2 days. It may be “2 Mar” or “1 Mar” in case of a leap-year. We don’t need to think about it. Just add 2 days. The Date object will do the rest:\n\n\t\nlet date = new Date(2016, 1, 28);\ndate.setDate(date.getDate() + 2);\n\nalert( date ); // 1 Mar 2016\n\nThat feature is often used to get the date after the given period of time. For instance, let’s get the date for “70 seconds after now”:\n\n\t\nlet date = new Date();\ndate.setSeconds(date.getSeconds() + 70);\n\nalert( date ); // shows the correct date\n\nWe can also set zero or even negative values. For example:\n\n\t\nlet date = new Date(2016, 0, 2); // 2 Jan 2016\n\ndate.setDate(1); // set day 1 of month\nalert( date );\n\ndate.setDate(0); // min day is 1, so the last day of the previous month is assumed\nalert( date ); // 31 Dec 2015\nDate to number, date diff\n\nWhen a Date object is converted to number, it becomes the timestamp same as date.getTime():\n\n\t\nlet date = new Date();\nalert(+date); // the number of milliseconds, same as date.getTime()\n\nThe important side effect: dates can be subtracted, the result is their difference in ms.\n\nThat can be used for time measurements:\n\n\t\nlet start = new Date(); // start measuring time\n\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\nlet end = new Date(); // end measuring time\n\nalert( `The loop took ${end - start} ms` );\nDate.now()\n\nIf we only want to measure time, we don’t need the Date object.\n\nThere’s a special method Date.now() that returns the current timestamp.\n\nIt is semantically equivalent to new Date().getTime(), but it doesn’t create an intermediate Date object. So it’s faster and doesn’t put pressure on garbage collection.\n\nIt is used mostly for convenience or when performance matters, like in games in JavaScript or other specialized applications.\n\nSo this is probably better:\n\n\t\nlet start = Date.now(); // milliseconds count from 1 Jan 1970\n\n// do the job\nfor (let i = 0; i < 100000; i++) {\n  let doSomething = i * i * i;\n}\n\nlet end = Date.now(); // done\n\nalert( `The loop took ${end - start} ms` ); // subtract numbers, not dates\nBenchmarking\n\nIf we want a reliable benchmark of CPU-hungry function, we should be careful.\n\nFor instance, let’s measure two functions that calculate the difference between two dates: which one is faster?\n\nSuch performance measurements are often called “benchmarks”.\n\n// we have date1 and date2, which function faster returns their difference in ms?\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\n// or\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nThese two do exactly the same thing, but one of them uses an explicit date.getTime() to get the date in ms, and the other one relies on a date-to-number transform. Their result is always the same.\n\nSo, which one is faster?\n\nThe first idea may be to run them many times in a row and measure the time difference. For our case, functions are very simple, so we have to do it at least 100000 times.\n\nLet’s measure:\n\n\t\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nalert( 'Time of diffSubtract: ' + bench(diffSubtract) + 'ms' );\nalert( 'Time of diffGetTime: ' + bench(diffGetTime) + 'ms' );\n\nWow! Using getTime() is so much faster! That’s because there’s no type conversion, it is much easier for engines to optimize.\n\nOkay, we have something. But that’s not a good benchmark yet.\n\nImagine that at the time of running bench(diffSubtract) CPU was doing something in parallel, and it was taking resources. And by the time of running bench(diffGetTime) that work has finished.\n\nA pretty real scenario for a modern multi-process OS.\n\nAs a result, the first benchmark will have less CPU resources than the second. That may lead to wrong results.\n\nFor more reliable benchmarking, the whole pack of benchmarks should be rerun multiple times.\n\nFor example, like this:\n\n\t\nfunction diffSubtract(date1, date2) {\n  return date2 - date1;\n}\n\nfunction diffGetTime(date1, date2) {\n  return date2.getTime() - date1.getTime();\n}\n\nfunction bench(f) {\n  let date1 = new Date(0);\n  let date2 = new Date();\n\n  let start = Date.now();\n  for (let i = 0; i < 100000; i++) f(date1, date2);\n  return Date.now() - start;\n}\n\nlet time1 = 0;\nlet time2 = 0;\n\n// run bench(diffSubtract) and bench(diffGetTime) each 10 times alternating\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\n\nalert( 'Total time for diffSubtract: ' + time1 );\nalert( 'Total time for diffGetTime: ' + time2 );\n\nModern JavaScript engines start applying advanced optimizations only to “hot code” that executes many times (no need to optimize rarely executed things). So, in the example above, first executions are not well-optimized. We may want to add a heat-up run:\n\n// added for \"heating up\" prior to the main loop\nbench(diffSubtract);\nbench(diffGetTime);\n\n// now benchmark\nfor (let i = 0; i < 10; i++) {\n  time1 += bench(diffSubtract);\n  time2 += bench(diffGetTime);\n}\nBe careful doing microbenchmarking\n\nModern JavaScript engines perform many optimizations. They may tweak results of “artificial tests” compared to “normal usage”, especially when we benchmark something very small, such as how an operator works, or a built-in function. So if you seriously want to understand performance, then please study how the JavaScript engine works. And then you probably won’t need microbenchmarks at all.\n\nThe great pack of articles about V8 can be found at https://mrale.ph.\n\nDate.parse from a string\n\nThe method Date.parse(str) can read a date from a string.\n\nThe string format should be: YYYY-MM-DDTHH:mm:ss.sssZ, where:\n\nYYYY-MM-DD – is the date: year-month-day.\nThe character \"T\" is used as the delimiter.\nHH:mm:ss.sss – is the time: hours, minutes, seconds and milliseconds.\nThe optional 'Z' part denotes the time zone in the format +-hh:mm. A single letter Z would mean UTC+0.\n\nShorter variants are also possible, like YYYY-MM-DD or YYYY-MM or even YYYY.\n\nThe call to Date.parse(str) parses the string in the given format and returns the timestamp (number of milliseconds from 1 Jan 1970 UTC+0). If the format is invalid, returns NaN.\n\nFor instance:\n\n\t\nlet ms = Date.parse('2012-01-26T13:51:50.417-07:00');\n\nalert(ms); // 1327611110417  (timestamp)\n\nWe can instantly create a new Date object from the timestamp:\n\n\t\nlet date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );\n\nalert(date);\nSummary\nDate and time in JavaScript are represented with the Date object. We can’t create “only date” or “only time”: Date objects always carry both.\nMonths are counted from zero (yes, January is a zero month).\nDays of week in getDay() are also counted from zero (that’s Sunday).\nDate auto-corrects itself when out-of-range components are set. Good for adding/subtracting days/months/hours.\nDates can be subtracted, giving their difference in milliseconds. That’s because a Date becomes the timestamp when converted to a number.\nUse Date.now() to get the current timestamp fast.\n\nNote that unlike many other systems, timestamps in JavaScript are in milliseconds, not in seconds.\n\nSometimes we need more precise time measurements. JavaScript itself does not have a way to measure time in microseconds (1 millionth of a second), but most environments provide it. For instance, browser has performance.now() that gives the number of milliseconds from the start of page loading with microsecond precision (3 digits after the point):\n\n\t\nalert(`Loading started ${performance.now()}ms ago`);\n// Something like: \"Loading started 34731.26000000001ms ago\"\n// .26 is microseconds (260 microseconds)\n// more than 3 digits after the decimal point are precision errors, only the first 3 are correct\n\nNode.js has microtime module and other ways. Technically, almost any device and environment allows to get more precision, it’s just not in Date.\n\nTasks\nCreate a date\nimportance: 5\n\nCreate a Date object for the date: Feb 20, 2012, 3:12am. The time zone is local.\n\nShow it using alert.\n\nsolution\nShow a weekday\nimportance: 5\n\nWrite a function getWeekDay(date) to show the weekday in short format: ‘MO’, ‘TU’, ‘WE’, ‘TH’, ‘FR’, ‘SA’, ‘SU’.\n\nFor instance:\n\nlet date = new Date(2012, 0, 3);  // 3 Jan 2012\nalert( getWeekDay(date) );        // should output \"TU\"\n\nOpen a sandbox with tests.\n\nsolution\nEuropean weekday\nimportance: 5\n\nEuropean countries have days of week starting with Monday (number 1), then Tuesday (number 2) and till Sunday (number 7). Write a function getLocalDay(date) that returns the “European” day of week for date.\n\nlet date = new Date(2012, 0, 3);  // 3 Jan 2012\nalert( getLocalDay(date) );       // tuesday, should show 2\n\nOpen a sandbox with tests.\n\nsolution\nWhich day of month was many days ago?\nimportance: 4\n\nCreate a function getDateAgo(date, days) to return the day of month days ago from the date.\n\nFor instance, if today is 20th, then getDateAgo(new Date(), 1) should be 19th and getDateAgo(new Date(), 2) should be 18th.\n\nShould work reliably for days=365 or more:\n\nlet date = new Date(2015, 0, 2);\n\nalert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)\nalert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)\nalert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)\n\nP.S. The function should not modify the given date.\n\nOpen a sandbox with tests.\n\nsolution\nLast day of month?\nimportance: 5\n\nWrite a function getLastDayOfMonth(year, month) that returns the last day of month. Sometimes it is 30th, 31st or even 28/29th for Feb.\n\nParameters:\n\nyear – four-digits year, for instance 2012.\nmonth – month, from 0 to 11.\n\nFor instance, getLastDayOfMonth(2012, 1) = 29 (leap year, Feb).\n\nOpen a sandbox with tests.\n\nsolution\nHow many seconds have passed today?\nimportance: 5\n\nWrite a function getSecondsToday() that returns the number of seconds from the beginning of today.\n\nFor instance, if now were 10:00 am, and there was no daylight savings shift, then:\n\ngetSecondsToday() == 36000 // (3600 * 10)\n\nThe function should work in any day. That is, it should not have a hard-coded value of “today”.\n\nsolution\nHow many seconds till tomorrow?\nimportance: 5\n\nCreate a function getSecondsToTomorrow() that returns the number of seconds till tomorrow.\n\nFor instance, if now is 23:00, then:\n\ngetSecondsToTomorrow() == 3600\n\nP.S. The function should work at any day, the “today” is not hardcoded.\n\nsolution\nFormat the relative date\nimportance: 4\n\nWrite a function formatDate(date) that should format date as follows:\n\nIf since date passed less than 1 second, then \"right now\".\nOtherwise, if since date passed less than 1 minute, then \"n sec. ago\".\nOtherwise, if less than an hour, then \"m min. ago\".\nOtherwise, the full date in the format \"DD.MM.YY HH:mm\". That is: \"day.month.year hours:minutes\", all in 2-digit format, e.g. 31.12.16 10:00.\n\nFor instance:\n\nalert( formatDate(new Date(new Date - 1)) ); // \"right now\"\n\nalert( formatDate(new Date(new Date - 30 * 1000)) ); // \"30 sec. ago\"\n\nalert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // \"5 min. ago\"\n\n// yesterday's date like 31.12.16 20:00\nalert( formatDate(new Date(new Date - 86400 * 1000)) );\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Destructuring assignment",
    "url": "https://javascript.info/destructuring-assignment",
    "html": "The two most used data structures in JavaScript are Object and Array.\n\nObjects allow us to create a single entity that stores data items by key.\nArrays allow us to gather data items into an ordered list.\n\nAlthough, when we pass those to a function, it may need not be an object/array as a whole. It may need individual pieces.\n\nDestructuring assignment is a special syntax that allows us to “unpack” arrays or objects into a bunch of variables, as sometimes that’s more convenient.\n\nDestructuring also works great with complex functions that have a lot of parameters, default values, and so on. Soon we’ll see that.\n\nArray destructuring\n\nHere’s an example of how an array is destructured into variables:\n\n// we have an array with the name and surname\nlet arr = [\"John\", \"Smith\"]\n\n// destructuring assignment\n// sets firstName = arr[0]\n// and surname = arr[1]\nlet [firstName, surname] = arr;\n\nalert(firstName); // John\nalert(surname);  // Smith\n\nNow we can work with variables instead of array members.\n\nIt looks great when combined with split or other array-returning methods:\n\n\t\nlet [firstName, surname] = \"John Smith\".split(' ');\nalert(firstName); // John\nalert(surname);  // Smith\n\nAs you can see, the syntax is simple. There are several peculiar details though. Let’s see more examples, to better understand it.\n\n“Destructuring” does not mean “destructive”.\n\nIt’s called “destructuring assignment,” because it “destructurizes” by copying items into variables. But the array itself is not modified.\n\nIt’s just a shorter way to write:\n\n// let [firstName, surname] = arr;\nlet firstName = arr[0];\nlet surname = arr[1];\nIgnore elements using commas\n\nUnwanted elements of the array can also be thrown away via an extra comma:\n\n\t\n// second element is not needed\nlet [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n\nalert( title ); // Consul\n\nIn the code above, the second element of the array is skipped, the third one is assigned to title, and the rest of the array items is also skipped (as there are no variables for them).\n\nWorks with any iterable on the right-side\n\n…Actually, we can use it with any iterable, not only arrays:\n\nlet [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"]\nlet [one, two, three] = new Set([1, 2, 3]);\n\nThat works, because internally a destructuring assignment works by iterating over the right value. It’s a kind of syntax sugar for calling for..of over the value to the right of = and assigning the values.\n\nAssign to anything at the left-side\n\nWe can use any “assignables” on the left side.\n\nFor instance, an object property:\n\n\t\nlet user = {};\n[user.name, user.surname] = \"John Smith\".split(' ');\n\nalert(user.name); // John\nalert(user.surname); // Smith\nLooping with .entries()\n\nIn the previous chapter we saw the Object.entries(obj) method.\n\nWe can use it with destructuring to loop over keys-and-values of an object:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// loop over keys-and-values\nfor (let [key, value] of Object.entries(user)) {\n  alert(`${key}:${value}`); // name:John, then age:30\n}\n\nThe similar code for a Map is simpler, as it’s iterable:\n\n\t\nlet user = new Map();\nuser.set(\"name\", \"John\");\nuser.set(\"age\", \"30\");\n\n// Map iterates as [key, value] pairs, very convenient for destructuring\nfor (let [key, value] of user) {\n  alert(`${key}:${value}`); // name:John, then age:30\n}\nSwap variables trick\n\nThere’s a well-known trick for swapping values of two variables using a destructuring assignment:\n\n\t\nlet guest = \"Jane\";\nlet admin = \"Pete\";\n\n// Let's swap the values: make guest=Pete, admin=Jane\n[guest, admin] = [admin, guest];\n\nalert(`${guest} ${admin}`); // Pete Jane (successfully swapped!)\n\nHere we create a temporary array of two variables and immediately destructure it in swapped order.\n\nWe can swap more than two variables this way.\n\nThe rest ‘…’\n\nUsually, if the array is longer than the list at the left, the “extra” items are omitted.\n\nFor example, here only two items are taken, and the rest is just ignored:\n\n\t\nlet [name1, name2] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n\nalert(name1); // Julius\nalert(name2); // Caesar\n// Further items aren't assigned anywhere\n\nIf we’d like also to gather all that follows – we can add one more parameter that gets “the rest” using three dots \"...\":\n\n\t\nlet [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n\n// rest is array of items, starting from the 3rd one\nalert(rest[0]); // Consul\nalert(rest[1]); // of the Roman Republic\nalert(rest.length); // 2\n\nThe value of rest is the array of the remaining array elements.\n\nWe can use any other variable name in place of rest, just make sure it has three dots before it and goes last in the destructuring assignment.\n\n\t\nlet [name1, name2, ...titles] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n// now titles = [\"Consul\", \"of the Roman Republic\"]\nDefault values\n\nIf the array is shorter than the list of variables at the left, there’ll be no errors. Absent values are considered undefined:\n\n\t\nlet [firstName, surname] = [];\n\nalert(firstName); // undefined\nalert(surname); // undefined\n\nIf we want a “default” value to replace the missing one, we can provide it using =:\n\n\t\n// default values\nlet [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"];\n\nalert(name);    // Julius (from array)\nalert(surname); // Anonymous (default used)\n\nDefault values can be more complex expressions or even function calls. They are evaluated only if the value is not provided.\n\nFor instance, here we use the prompt function for two defaults:\n\n\t\n// runs only prompt for surname\nlet [name = prompt('name?'), surname = prompt('surname?')] = [\"Julius\"];\n\nalert(name);    // Julius (from array)\nalert(surname); // whatever prompt gets\n\nPlease note: the prompt will run only for the missing value (surname).\n\nObject destructuring\n\nThe destructuring assignment also works with objects.\n\nThe basic syntax is:\n\nlet {var1, var2} = {var1:…, var2:…}\n\nWe should have an existing object on the right side, that we want to split into variables. The left side contains an object-like “pattern” for corresponding properties. In the simplest case, that’s a list of variable names in {...}.\n\nFor instance:\n\n\t\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\nlet {title, width, height} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n\nProperties options.title, options.width and options.height are assigned to the corresponding variables.\n\nThe order does not matter. This works too:\n\n// changed the order in let {...}\nlet {height, width, title} = { title: \"Menu\", height: 200, width: 100 }\n\nThe pattern on the left side may be more complex and specify the mapping between properties and variables.\n\nIf we want to assign a property to a variable with another name, for instance, make options.width go into the variable named w, then we can set the variable name using a colon:\n\n\t\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n// { sourceProperty: targetVariable }\nlet {width: w, height: h, title} = options;\n\n// width -> w\n// height -> h\n// title -> title\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n\nThe colon shows “what : goes where”. In the example above the property width goes to w, property height goes to h, and title is assigned to the same name.\n\nFor potentially missing properties we can set default values using \"=\", like this:\n\n\t\nlet options = {\n  title: \"Menu\"\n};\n\nlet {width = 100, height = 200, title} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n\nJust like with arrays or function parameters, default values can be any expressions or even function calls. They will be evaluated if the value is not provided.\n\nIn the code below prompt asks for width, but not for title:\n\n\t\nlet options = {\n  title: \"Menu\"\n};\n\nlet {width = prompt(\"width?\"), title = prompt(\"title?\")} = options;\n\nalert(title);  // Menu\nalert(width);  // (whatever the result of prompt is)\n\nWe also can combine both the colon and equality:\n\n\t\nlet options = {\n  title: \"Menu\"\n};\n\nlet {width: w = 100, height: h = 200, title} = options;\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n\nIf we have a complex object with many properties, we can extract only what we need:\n\n\t\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n// only extract title as a variable\nlet { title } = options;\n\nalert(title); // Menu\nThe rest pattern “…”\n\nWhat if the object has more properties than we have variables? Can we take some and then assign the “rest” somewhere?\n\nWe can use the rest pattern, just like we did with arrays. It’s not supported by some older browsers (IE, use Babel to polyfill it), but works in modern ones.\n\nIt looks like this:\n\n\t\nlet options = {\n  title: \"Menu\",\n  height: 200,\n  width: 100\n};\n\n// title = property named title\n// rest = object with the rest of properties\nlet {title, ...rest} = options;\n\n// now title=\"Menu\", rest={height: 200, width: 100}\nalert(rest.height);  // 200\nalert(rest.width);   // 100\nGotcha if there’s no let\n\nIn the examples above variables were declared right in the assignment: let {…} = {…}. Of course, we could use existing variables too, without let. But there’s a catch.\n\nThis won’t work:\n\n\t\nlet title, width, height;\n\n// error in this line\n{title, width, height} = {title: \"Menu\", width: 200, height: 100};\n\nThe problem is that JavaScript treats {...} in the main code flow (not inside another expression) as a code block. Such code blocks can be used to group statements, like this:\n\n\t\n{\n  // a code block\n  let message = \"Hello\";\n  // ...\n  alert( message );\n}\n\nSo here JavaScript assumes that we have a code block, that’s why there’s an error. We want destructuring instead.\n\nTo show JavaScript that it’s not a code block, we can wrap the expression in parentheses (...):\n\n\t\nlet title, width, height;\n\n// okay now\n({title, width, height} = {title: \"Menu\", width: 200, height: 100});\n\nalert( title ); // Menu\nNested destructuring\n\nIf an object or an array contain other nested objects and arrays, we can use more complex left-side patterns to extract deeper portions.\n\nIn the code below options has another object in the property size and an array in the property items. The pattern on the left side of the assignment has the same structure to extract values from them:\n\n\t\nlet options = {\n  size: {\n    width: 100,\n    height: 200\n  },\n  items: [\"Cake\", \"Donut\"],\n  extra: true\n};\n\n// destructuring assignment split in multiple lines for clarity\nlet {\n  size: { // put size here\n    width,\n    height\n  },\n  items: [item1, item2], // assign items here\n  title = \"Menu\" // not present in the object (default value is used)\n} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\nalert(item1);  // Cake\nalert(item2);  // Donut\n\nAll properties of options object except extra that is absent in the left part, are assigned to corresponding variables:\n\nFinally, we have width, height, item1, item2 and title from the default value.\n\nNote that there are no variables for size and items, as we take their content instead.\n\nSmart function parameters\n\nThere are times when a function has many parameters, most of which are optional. That’s especially true for user interfaces. Imagine a function that creates a menu. It may have a width, a height, a title, items list and so on.\n\nHere’s a bad way to write such function:\n\nfunction showMenu(title = \"Untitled\", width = 200, height = 100, items = []) {\n  // ...\n}\n\nIn real-life, the problem is how to remember the order of arguments. Usually IDEs try to help us, especially if the code is well-documented, but still… Another problem is how to call a function when most parameters are ok by default.\n\nLike this?\n\n// undefined where default values are fine\nshowMenu(\"My Menu\", undefined, undefined, [\"Item1\", \"Item2\"])\n\nThat’s ugly. And becomes unreadable when we deal with more parameters.\n\nDestructuring comes to the rescue!\n\nWe can pass parameters as an object, and the function immediately destructurizes them into variables:\n\n\t\n// we pass object to function\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\n// ...and it immediately expands it to variables\nfunction showMenu({title = \"Untitled\", width = 200, height = 100, items = []}) {\n  // title, items – taken from options,\n  // width, height – defaults used\n  alert( `${title} ${width} ${height}` ); // My Menu 200 100\n  alert( items ); // Item1, Item2\n}\n\nshowMenu(options);\n\nWe can also use more complex destructuring with nested objects and colon mappings:\n\n\t\nlet options = {\n  title: \"My menu\",\n  items: [\"Item1\", \"Item2\"]\n};\n\nfunction showMenu({\n  title = \"Untitled\",\n  width: w = 100,  // width goes to w\n  height: h = 200, // height goes to h\n  items: [item1, item2] // items first element goes to item1, second to item2\n}) {\n  alert( `${title} ${w} ${h}` ); // My Menu 100 200\n  alert( item1 ); // Item1\n  alert( item2 ); // Item2\n}\n\nshowMenu(options);\n\nThe full syntax is the same as for a destructuring assignment:\n\nfunction({\n  incomingProperty: varName = defaultValue\n  ...\n})\n\nThen, for an object of parameters, there will be a variable varName for property incomingProperty, with defaultValue by default.\n\nPlease note that such destructuring assumes that showMenu() does have an argument. If we want all values by default, then we should specify an empty object:\n\nshowMenu({}); // ok, all values are default\n\nshowMenu(); // this would give an error\n\nWe can fix this by making {} the default value for the whole object of parameters:\n\n\t\nfunction showMenu({ title = \"Menu\", width = 100, height = 200 } = {}) {\n  alert( `${title} ${width} ${height}` );\n}\n\nshowMenu(); // Menu 100 200\n\nIn the code above, the whole arguments object is {} by default, so there’s always something to destructurize.\n\nSummary\n\nDestructuring assignment allows for instantly mapping an object or array onto many variables.\n\nThe full object syntax:\n\nlet {prop : varName = default, ...rest} = object\n\nThis means that property prop should go into the variable varName and, if no such property exists, then the default value should be used.\n\nObject properties that have no mapping are copied to the rest object.\n\nThe full array syntax:\n\nlet [item1 = default, item2, ...rest] = array\n\nThe first item goes to item1; the second goes into item2, all the rest makes the array rest.\n\nIt’s possible to extract data from nested arrays/objects, for that the left side must have the same structure as the right one.\n\nTasks\nDestructuring assignment\nimportance: 5\n\nWe have an object:\n\nlet user = {\n  name: \"John\",\n  years: 30\n};\n\nWrite the destructuring assignment that reads:\n\nname property into the variable name.\nyears property into the variable age.\nisAdmin property into the variable isAdmin (false, if no such property)\n\nHere’s an example of the values after your assignment:\n\nlet user = { name: \"John\", years: 30 };\n\n// your code to the left side:\n// ... = user\n\nalert( name ); // John\nalert( age ); // 30\nalert( isAdmin ); // false\nsolution\nThe maximal salary\nimportance: 5\n\nThere is a salaries object:\n\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nCreate the function topSalary(salaries) that returns the name of the top-paid person.\n\nIf salaries is empty, it should return null.\nIf there are multiple top-paid persons, return any of them.\n\nP.S. Use Object.entries and destructuring to iterate over key/value pairs.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Advanced working with functions",
    "url": "https://javascript.info/advanced-functions",
    "html": "Recursion and stack\nRest parameters and spread syntax\nVariable scope, closure\nThe old \"var\"\nGlobal object\nFunction object, NFE\nThe \"new Function\" syntax\nScheduling: setTimeout and setInterval\nDecorators and forwarding, call/apply\nFunction binding\nArrow functions revisited"
  },
  {
    "title": "Object.keys, values, entries",
    "url": "https://javascript.info/keys-values-entries",
    "html": "Let’s step away from the individual data structures and talk about the iterations over them.\n\nIn the previous chapter we saw methods map.keys(), map.values(), map.entries().\n\nThese methods are generic, there is a common agreement to use them for data structures. If we ever create a data structure of our own, we should implement them too.\n\nThey are supported for:\n\nMap\nSet\nArray\n\nPlain objects also support similar methods, but the syntax is a bit different.\n\nObject.keys, values, entries\n\nFor plain objects, the following methods are available:\n\nObject.keys(obj) – returns an array of keys.\nObject.values(obj) – returns an array of values.\nObject.entries(obj) – returns an array of [key, value] pairs.\n\nPlease note the distinctions (compared to map for example):\n\n\tMap\tObject\nCall syntax\tmap.keys()\tObject.keys(obj), but not obj.keys()\nReturns\titerable\t“real” Array\n\nThe first difference is that we have to call Object.keys(obj), and not obj.keys().\n\nWhy so? The main reason is flexibility. Remember, objects are a base of all complex structures in JavaScript. So we may have an object of our own like data that implements its own data.values() method. And we still can call Object.values(data) on it.\n\nThe second difference is that Object.* methods return “real” array objects, not just an iterable. That’s mainly for historical reasons.\n\nFor instance:\n\nlet user = {\n  name: \"John\",\n  age: 30\n};\nObject.keys(user) = [\"name\", \"age\"]\nObject.values(user) = [\"John\", 30]\nObject.entries(user) = [ [\"name\",\"John\"], [\"age\",30] ]\n\nHere’s an example of using Object.values to loop over property values:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\n// loop over values\nfor (let value of Object.values(user)) {\n  alert(value); // John, then 30\n}\nObject.keys/values/entries ignore symbolic properties\n\nJust like a for..in loop, these methods ignore properties that use Symbol(...) as keys.\n\nUsually that’s convenient. But if we want symbolic keys too, then there’s a separate method Object.getOwnPropertySymbols that returns an array of only symbolic keys. Also, there exist a method Reflect.ownKeys(obj) that returns all keys.\n\nTransforming objects\n\nObjects lack many methods that exist for arrays, e.g. map, filter and others.\n\nIf we’d like to apply them, then we can use Object.entries followed by Object.fromEntries:\n\nUse Object.entries(obj) to get an array of key/value pairs from obj.\nUse array methods on that array, e.g. map, to transform these key/value pairs.\nUse Object.fromEntries(array) on the resulting array to turn it back into an object.\n\nFor example, we have an object with prices, and would like to double them:\n\n\t\nlet prices = {\n  banana: 1,\n  orange: 2,\n  meat: 4,\n};\n\nlet doublePrices = Object.fromEntries(\n  // convert prices to array, map each key/value pair into another pair\n  // and then fromEntries gives back the object\n  Object.entries(prices).map(entry => [entry[0], entry[1] * 2])\n);\n\nalert(doublePrices.meat); // 8\n\nIt may look difficult at first sight, but becomes easy to understand after you use it once or twice. We can make powerful chains of transforms this way.\n\nTasks\nSum the properties\nimportance: 5\n\nThere is a salaries object with arbitrary number of salaries.\n\nWrite the function sumSalaries(salaries) that returns the sum of all salaries using Object.values and the for..of loop.\n\nIf salaries is empty, then the result must be 0.\n\nFor instance:\n\nlet salaries = {\n  \"John\": 100,\n  \"Pete\": 300,\n  \"Mary\": 250\n};\n\nalert( sumSalaries(salaries) ); // 650\n\nOpen a sandbox with tests.\n\nsolution\nCount properties\nimportance: 5\n\nWrite a function count(obj) that returns the number of properties in the object:\n\nlet user = {\n  name: 'John',\n  age: 30\n};\n\nalert( count(user) ); // 2\n\nTry to make the code as short as possible.\n\nP.S. Ignore symbolic properties, count only “regular” ones.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "WeakMap and WeakSet",
    "url": "https://javascript.info/weakmap-weakset",
    "html": "As we know from the chapter Garbage collection, JavaScript engine keeps a value in memory while it is “reachable” and can potentially be used.\n\nFor instance:\n\nlet john = { name: \"John\" };\n\n// the object can be accessed, john is the reference to it\n\n// overwrite the reference\njohn = null;\n\n// the object will be removed from memory\n\nUsually, properties of an object or elements of an array or another data structure are considered reachable and kept in memory while that data structure is in memory.\n\nFor instance, if we put an object into an array, then while the array is alive, the object will be alive as well, even if there are no other references to it.\n\nLike this:\n\nlet john = { name: \"John\" };\n\nlet array = [ john ];\n\njohn = null; // overwrite the reference\n\n// the object previously referenced by john is stored inside the array\n// therefore it won't be garbage-collected\n// we can get it as array[0]\n\nSimilar to that, if we use an object as the key in a regular Map, then while the Map exists, that object exists as well. It occupies memory and may not be garbage collected.\n\nFor instance:\n\nlet john = { name: \"John\" };\n\nlet map = new Map();\nmap.set(john, \"...\");\n\njohn = null; // overwrite the reference\n\n// john is stored inside the map,\n// we can get it by using map.keys()\n\nWeakMap is fundamentally different in this aspect. It doesn’t prevent garbage-collection of key objects.\n\nLet’s see what it means on examples.\n\nWeakMap\n\nThe first difference between Map and WeakMap is that keys must be objects, not primitive values:\n\n\t\nlet weakMap = new WeakMap();\n\nlet obj = {};\n\nweakMap.set(obj, \"ok\"); // works fine (object key)\n\n// can't use a string as the key\nweakMap.set(\"test\", \"Whoops\"); // Error, because \"test\" is not an object\n\nNow, if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.\n\nlet john = { name: \"John\" };\n\nlet weakMap = new WeakMap();\nweakMap.set(john, \"...\");\n\njohn = null; // overwrite the reference\n\n// john is removed from memory!\n\nCompare it with the regular Map example above. Now if john only exists as the key of WeakMap – it will be automatically deleted from the map (and memory).\n\nWeakMap does not support iteration and methods keys(), values(), entries(), so there’s no way to get all keys or values from it.\n\nWeakMap has only the following methods:\n\nweakMap.set(key, value)\nweakMap.get(key)\nweakMap.delete(key)\nweakMap.has(key)\n\nWhy such a limitation? That’s for technical reasons. If an object has lost all other references (like john in the code above), then it is to be garbage-collected automatically. But technically it’s not exactly specified when the cleanup happens.\n\nThe JavaScript engine decides that. It may choose to perform the memory cleanup immediately or to wait and do the cleaning later when more deletions happen. So, technically, the current element count of a WeakMap is not known. The engine may have cleaned it up or not, or did it partially. For that reason, methods that access all keys/values are not supported.\n\nNow, where do we need such a data structure?\n\nUse case: additional data\n\nThe main area of application for WeakMap is an additional data storage.\n\nIf we’re working with an object that “belongs” to another code, maybe even a third-party library, and would like to store some data associated with it, that should only exist while the object is alive – then WeakMap is exactly what’s needed.\n\nWe put the data to a WeakMap, using the object as the key, and when the object is garbage collected, that data will automatically disappear as well.\n\nweakMap.set(john, \"secret documents\");\n// if john dies, secret documents will be destroyed automatically\n\nLet’s look at an example.\n\nFor instance, we have code that keeps a visit count for users. The information is stored in a map: a user object is the key and the visit count is the value. When a user leaves (its object gets garbage collected), we don’t want to store their visit count anymore.\n\nHere’s an example of a counting function with Map:\n\n// 📁 visitsCount.js\nlet visitsCountMap = new Map(); // map: user => visits count\n\n// increase the visits count\nfunction countUser(user) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n\nAnd here’s another part of the code, maybe another file using it:\n\n// 📁 main.js\nlet john = { name: \"John\" };\n\ncountUser(john); // count his visits\n\n// later john leaves us\njohn = null;\n\nNow, john object should be garbage collected, but remains in memory, as it’s a key in visitsCountMap.\n\nWe need to clean visitsCountMap when we remove users, otherwise it will grow in memory indefinitely. Such cleaning can become a tedious task in complex architectures.\n\nWe can avoid it by switching to WeakMap instead:\n\n// 📁 visitsCount.js\nlet visitsCountMap = new WeakMap(); // weakmap: user => visits count\n\n// increase the visits count\nfunction countUser(user) {\n  let count = visitsCountMap.get(user) || 0;\n  visitsCountMap.set(user, count + 1);\n}\n\nNow we don’t have to clean visitsCountMap. After john object becomes unreachable, by all means except as a key of WeakMap, it gets removed from memory, along with the information by that key from WeakMap.\n\nUse case: caching\n\nAnother common example is caching. We can store (“cache”) results from a function, so that future calls on the same object can reuse it.\n\nTo achieve that, we can use Map (not optimal scenario):\n\n\t\n// 📁 cache.js\nlet cache = new Map();\n\n// calculate and remember the result\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculations of the result for */ obj;\n\n    cache.set(obj, result);\n    return result;\n  }\n\n  return cache.get(obj);\n}\n\n// Now we use process() in another file:\n\n// 📁 main.js\nlet obj = {/* let's say we have an object */};\n\nlet result1 = process(obj); // calculated\n\n// ...later, from another place of the code...\nlet result2 = process(obj); // remembered result taken from cache\n\n// ...later, when the object is not needed any more:\nobj = null;\n\nalert(cache.size); // 1 (Ouch! The object is still in cache, taking memory!)\n\nFor multiple calls of process(obj) with the same object, it only calculates the result the first time, and then just takes it from cache. The downside is that we need to clean cache when the object is not needed any more.\n\nIf we replace Map with WeakMap, then this problem disappears. The cached result will be removed from memory automatically after the object gets garbage collected.\n\n\t\n// 📁 cache.js\nlet cache = new WeakMap();\n\n// calculate and remember the result\nfunction process(obj) {\n  if (!cache.has(obj)) {\n    let result = /* calculate the result for */ obj;\n\n    cache.set(obj, result);\n    return result;\n  }\n\n  return cache.get(obj);\n}\n\n// 📁 main.js\nlet obj = {/* some object */};\n\nlet result1 = process(obj);\nlet result2 = process(obj);\n\n// ...later, when the object is not needed any more:\nobj = null;\n\n// Can't get cache.size, as it's a WeakMap,\n// but it's 0 or soon be 0\n// When obj gets garbage collected, cached data will be removed as well\nWeakSet\n\nWeakSet behaves similarly:\n\nIt is analogous to Set, but we may only add objects to WeakSet (not primitives).\nAn object exists in the set while it is reachable from somewhere else.\nLike Set, it supports add, has and delete, but not size, keys() and no iterations.\n\nBeing “weak”, it also serves as additional storage. But not for arbitrary data, rather for “yes/no” facts. A membership in WeakSet may mean something about the object.\n\nFor instance, we can add users to WeakSet to keep track of those who visited our site:\n\n\t\nlet visitedSet = new WeakSet();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\nvisitedSet.add(john); // John visited us\nvisitedSet.add(pete); // Then Pete\nvisitedSet.add(john); // John again\n\n// visitedSet has 2 users now\n\n// check if John visited?\nalert(visitedSet.has(john)); // true\n\n// check if Mary visited?\nalert(visitedSet.has(mary)); // false\n\njohn = null;\n\n// visitedSet will be cleaned automatically\n\nThe most notable limitation of WeakMap and WeakSet is the absence of iterations, and the inability to get all current content. That may appear inconvenient, but does not prevent WeakMap/WeakSet from doing their main job – be an “additional” storage of data for objects which are stored/managed at another place.\n\nSummary\n\nWeakMap is Map-like collection that allows only objects as keys and removes them together with associated value once they become inaccessible by other means.\n\nWeakSet is Set-like collection that stores only objects and removes them once they become inaccessible by other means.\n\nTheir main advantages are that they have weak reference to objects, so they can easily be removed by garbage collector.\n\nThat comes at the cost of not having support for clear, size, keys, values…\n\nWeakMap and WeakSet are used as “secondary” data structures in addition to the “primary” object storage. Once the object is removed from the primary storage, if it is only found as the key of WeakMap or in a WeakSet, it will be cleaned up automatically.\n\nTasks\nStore \"unread\" flags\nimportance: 5\n\nThere’s an array of messages:\n\nlet messages = [\n  {text: \"Hello\", from: \"John\"},\n  {text: \"How goes?\", from: \"John\"},\n  {text: \"See you soon\", from: \"Alice\"}\n];\n\nYour code can access it, but the messages are managed by someone else’s code. New messages are added, old ones are removed regularly by that code, and you don’t know the exact moments when it happens.\n\nNow, which data structure could you use to store information about whether the message “has been read”? The structure must be well-suited to give the answer “was it read?” for the given message object.\n\nP.S. When a message is removed from messages, it should disappear from your structure as well.\n\nP.P.S. We shouldn’t modify message objects, add our properties to them. As they are managed by someone else’s code, that may lead to bad consequences.\n\nsolution\nStore read dates\nimportance: 5\n\nThere’s an array of messages as in the previous task. The situation is similar.\n\nlet messages = [\n  {text: \"Hello\", from: \"John\"},\n  {text: \"How goes?\", from: \"John\"},\n  {text: \"See you soon\", from: \"Alice\"}\n];\n\nThe question now is: which data structure you’d suggest to store the information: “when the message was read?”.\n\nIn the previous task we only needed to store the “yes/no” fact. Now we need to store the date, and it should only remain in memory until the message is garbage collected.\n\nP.S. Dates can be stored as objects of built-in Date class, that we’ll cover later.\n\nsolution"
  },
  {
    "title": "Map and Set",
    "url": "https://javascript.info/map-set",
    "html": "Till now, we’ve learned about the following complex data structures:\n\nObjects are used for storing keyed collections.\nArrays are used for storing ordered collections.\n\nBut that’s not enough for real life. That’s why Map and Set also exist.\n\nMap\n\nMap is a collection of keyed data items, just like an Object. But the main difference is that Map allows keys of any type.\n\nMethods and properties are:\n\nnew Map() – creates the map.\nmap.set(key, value) – stores the value by the key.\nmap.get(key) – returns the value by the key, undefined if key doesn’t exist in map.\nmap.has(key) – returns true if the key exists, false otherwise.\nmap.delete(key) – removes the element (the key/value pair) by the key.\nmap.clear() – removes everything from the map.\nmap.size – returns the current element count.\n\nFor instance:\n\n\t\nlet map = new Map();\n\nmap.set('1', 'str1');   // a string key\nmap.set(1, 'num1');     // a numeric key\nmap.set(true, 'bool1'); // a boolean key\n\n// remember the regular Object? it would convert keys to string\n// Map keeps the type, so these two are different:\nalert( map.get(1)   ); // 'num1'\nalert( map.get('1') ); // 'str1'\n\nalert( map.size ); // 3\n\nAs we can see, unlike objects, keys are not converted to strings. Any type of key is possible.\n\nmap[key] isn’t the right way to use a Map\n\nAlthough map[key] also works, e.g. we can set map[key] = 2, this is treating map as a plain JavaScript object, so it implies all corresponding limitations (only string/symbol keys and so on).\n\nSo we should use map methods: set, get and so on.\n\nMap can also use objects as keys.\n\nFor instance:\n\n\t\nlet john = { name: \"John\" };\n\n// for every user, let's store their visits count\nlet visitsCountMap = new Map();\n\n// john is the key for the map\nvisitsCountMap.set(john, 123);\n\nalert( visitsCountMap.get(john) ); // 123\n\nUsing objects as keys is one of the most notable and important Map features. The same does not count for Object. String as a key in Object is fine, but we can’t use another Object as a key in Object.\n\nLet’s try:\n\n\t\nlet john = { name: \"John\" };\nlet ben = { name: \"Ben\" };\n\nlet visitsCountObj = {}; // try to use an object\n\nvisitsCountObj[ben] = 234; // try to use ben object as the key\nvisitsCountObj[john] = 123; // try to use john object as the key, ben object will get replaced\n\n// That's what got written!\nalert( visitsCountObj[\"[object Object]\"] ); // 123\n\nAs visitsCountObj is an object, it converts all Object keys, such as john and ben above, to same string \"[object Object]\". Definitely not what we want.\n\nHow Map compares keys\n\nTo test keys for equivalence, Map uses the algorithm SameValueZero. It is roughly the same as strict equality ===, but the difference is that NaN is considered equal to NaN. So NaN can be used as the key as well.\n\nThis algorithm can’t be changed or customized.\n\nChaining\n\nEvery map.set call returns the map itself, so we can “chain” the calls:\n\nmap.set('1', 'str1')\n  .set(1, 'num1')\n  .set(true, 'bool1');\nIteration over Map\n\nFor looping over a map, there are 3 methods:\n\nmap.keys() – returns an iterable for keys,\nmap.values() – returns an iterable for values,\nmap.entries() – returns an iterable for entries [key, value], it’s used by default in for..of.\n\nFor instance:\n\n\t\nlet recipeMap = new Map([\n  ['cucumber', 500],\n  ['tomatoes', 350],\n  ['onion',    50]\n]);\n\n// iterate over keys (vegetables)\nfor (let vegetable of recipeMap.keys()) {\n  alert(vegetable); // cucumber, tomatoes, onion\n}\n\n// iterate over values (amounts)\nfor (let amount of recipeMap.values()) {\n  alert(amount); // 500, 350, 50\n}\n\n// iterate over [key, value] entries\nfor (let entry of recipeMap) { // the same as of recipeMap.entries()\n  alert(entry); // cucumber,500 (and so on)\n}\nThe insertion order is used\n\nThe iteration goes in the same order as the values were inserted. Map preserves this order, unlike a regular Object.\n\nBesides that, Map has a built-in forEach method, similar to Array:\n\n// runs the function for each (key, value) pair\nrecipeMap.forEach( (value, key, map) => {\n  alert(`${key}: ${value}`); // cucumber: 500 etc\n});\nObject.entries: Map from Object\n\nWhen a Map is created, we can pass an array (or another iterable) with key/value pairs for initialization, like this:\n\n\t\n// array of [key, value] pairs\nlet map = new Map([\n  ['1',  'str1'],\n  [1,    'num1'],\n  [true, 'bool1']\n]);\n\nalert( map.get('1') ); // str1\n\nIf we have a plain object, and we’d like to create a Map from it, then we can use built-in method Object.entries(obj) that returns an array of key/value pairs for an object exactly in that format.\n\nSo we can create a map from an object like this:\n\n\t\nlet obj = {\n  name: \"John\",\n  age: 30\n};\n\nlet map = new Map(Object.entries(obj));\n\nalert( map.get('name') ); // John\n\nHere, Object.entries returns the array of key/value pairs: [ [\"name\",\"John\"], [\"age\", 30] ]. That’s what Map needs.\n\nObject.fromEntries: Object from Map\n\nWe’ve just seen how to create Map from a plain object with Object.entries(obj).\n\nThere’s Object.fromEntries method that does the reverse: given an array of [key, value] pairs, it creates an object from them:\n\n\t\nlet prices = Object.fromEntries([\n  ['banana', 1],\n  ['orange', 2],\n  ['meat', 4]\n]);\n\n// now prices = { banana: 1, orange: 2, meat: 4 }\n\nalert(prices.orange); // 2\n\nWe can use Object.fromEntries to get a plain object from Map.\n\nE.g. we store the data in a Map, but we need to pass it to a 3rd-party code that expects a plain object.\n\nHere we go:\n\n\t\nlet map = new Map();\nmap.set('banana', 1);\nmap.set('orange', 2);\nmap.set('meat', 4);\n\nlet obj = Object.fromEntries(map.entries()); // make a plain object (*)\n\n// done!\n// obj = { banana: 1, orange: 2, meat: 4 }\n\nalert(obj.orange); // 2\n\nA call to map.entries() returns an iterable of key/value pairs, exactly in the right format for Object.fromEntries.\n\nWe could also make line (*) shorter:\n\nlet obj = Object.fromEntries(map); // omit .entries()\n\nThat’s the same, because Object.fromEntries expects an iterable object as the argument. Not necessarily an array. And the standard iteration for map returns same key/value pairs as map.entries(). So we get a plain object with same key/values as the map.\n\nSet\n\nA Set is a special type collection – “set of values” (without keys), where each value may occur only once.\n\nIts main methods are:\n\nnew Set([iterable]) – creates the set, and if an iterable object is provided (usually an array), copies values from it into the set.\nset.add(value) – adds a value, returns the set itself.\nset.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.\nset.has(value) – returns true if the value exists in the set, otherwise false.\nset.clear() – removes everything from the set.\nset.size – is the elements count.\n\nThe main feature is that repeated calls of set.add(value) with the same value don’t do anything. That’s the reason why each value appears in a Set only once.\n\nFor example, we have visitors coming, and we’d like to remember everyone. But repeated visits should not lead to duplicates. A visitor must be “counted” only once.\n\nSet is just the right thing for that:\n\n\t\nlet set = new Set();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\n// visits, some users come multiple times\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\n// set keeps only unique values\nalert( set.size ); // 3\n\nfor (let user of set) {\n  alert(user.name); // John (then Pete and Mary)\n}\n\nThe alternative to Set could be an array of users, and the code to check for duplicates on every insertion using arr.find. But the performance would be much worse, because this method walks through the whole array checking every element. Set is much better optimized internally for uniqueness checks.\n\nIteration over Set\n\nWe can loop over a set either with for..of or using forEach:\n\n\t\nlet set = new Set([\"oranges\", \"apples\", \"bananas\"]);\n\nfor (let value of set) alert(value);\n\n// the same with forEach:\nset.forEach((value, valueAgain, set) => {\n  alert(value);\n});\n\nNote the funny thing. The callback function passed in forEach has 3 arguments: a value, then the same value valueAgain, and then the target object. Indeed, the same value appears in the arguments twice.\n\nThat’s for compatibility with Map where the callback passed forEach has three arguments. Looks a bit strange, for sure. But this may help to replace Map with Set in certain cases with ease, and vice versa.\n\nThe same methods Map has for iterators are also supported:\n\nset.keys() – returns an iterable object for values,\nset.values() – same as set.keys(), for compatibility with Map,\nset.entries() – returns an iterable object for entries [value, value], exists for compatibility with Map.\nSummary\n\nMap – is a collection of keyed values.\n\nMethods and properties:\n\nnew Map([iterable]) – creates the map, with optional iterable (e.g. array) of [key,value] pairs for initialization.\nmap.set(key, value) – stores the value by the key, returns the map itself.\nmap.get(key) – returns the value by the key, undefined if key doesn’t exist in map.\nmap.has(key) – returns true if the key exists, false otherwise.\nmap.delete(key) – removes the element by the key, returns true if key existed at the moment of the call, otherwise false.\nmap.clear() – removes everything from the map.\nmap.size – returns the current element count.\n\nThe differences from a regular Object:\n\nAny keys, objects can be keys.\nAdditional convenient methods, the size property.\n\nSet – is a collection of unique values.\n\nMethods and properties:\n\nnew Set([iterable]) – creates the set, with optional iterable (e.g. array) of values for initialization.\nset.add(value) – adds a value (does nothing if value exists), returns the set itself.\nset.delete(value) – removes the value, returns true if value existed at the moment of the call, otherwise false.\nset.has(value) – returns true if the value exists in the set, otherwise false.\nset.clear() – removes everything from the set.\nset.size – is the elements count.\n\nIteration over Map and Set is always in the insertion order, so we can’t say that these collections are unordered, but we can’t reorder elements or directly get an element by its number.\n\nTasks\nFilter unique array members\nimportance: 5\n\nLet arr be an array.\n\nCreate a function unique(arr) that should return an array with unique items of arr.\n\nFor instance:\n\nfunction unique(arr) {\n  /* your code */\n}\n\nlet values = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(values) ); // Hare, Krishna, :-O\n\nP.S. Here strings are used, but can be values of any type.\n\nP.P.S. Use Set to store unique values.\n\nOpen a sandbox with tests.\n\nsolution\nFilter anagrams\nimportance: 4\n\nAnagrams are words that have the same number of same letters, but in different order.\n\nFor instance:\n\nnap - pan\near - are - era\ncheaters - hectares - teachers\n\nWrite a function aclean(arr) that returns an array cleaned from anagrams.\n\nFor instance:\n\nlet arr = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n\nalert( aclean(arr) ); // \"nap,teachers,ear\" or \"PAN,cheaters,era\"\n\nFrom every anagram group should remain only one word, no matter which one.\n\nOpen a sandbox with tests.\n\nsolution\nIterable keys\nimportance: 5\n\nWe’d like to get an array of map.keys() in a variable and then apply array-specific methods to it, e.g. .push.\n\nBut that doesn’t work:\n\n\t\nlet map = new Map();\n\nmap.set(\"name\", \"John\");\n\nlet keys = map.keys();\n\n// Error: keys.push is not a function\nkeys.push(\"more\");\n\nWhy? How can we fix the code to make keys.push work?\n\nsolution"
  },
  {
    "title": "Iterables",
    "url": "https://javascript.info/iterable",
    "html": "Iterable objects are a generalization of arrays. That’s a concept that allows us to make any object useable in a for..of loop.\n\nOf course, Arrays are iterable. But there are many other built-in objects, that are iterable as well. For instance, strings are also iterable.\n\nIf an object isn’t technically an array, but represents a collection (list, set) of something, then for..of is a great syntax to loop over it, so let’s see how to make it work.\n\nSymbol.iterator\n\nWe can easily grasp the concept of iterables by making one of our own.\n\nFor instance, we have an object that is not an array, but looks suitable for for..of.\n\nLike a range object that represents an interval of numbers:\n\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// We want the for..of to work:\n// for(let num of range) ... num=1,2,3,4,5\n\nTo make the range object iterable (and thus let for..of work) we need to add a method to the object named Symbol.iterator (a special built-in symbol just for that).\n\nWhen for..of starts, it calls that method once (or errors if not found). The method must return an iterator – an object with the method next.\nOnward, for..of works only with that returned object.\nWhen for..of wants the next value, it calls next() on that object.\nThe result of next() must have the form {done: Boolean, value: any}, where done=true means that the loop is finished, otherwise value is the next value.\n\nHere’s the full implementation for range with remarks:\n\n\t\nlet range = {\n  from: 1,\n  to: 5\n};\n\n// 1. call to for..of initially calls this\nrange[Symbol.iterator] = function() {\n\n  // ...it returns the iterator object:\n  // 2. Onward, for..of works only with the iterator object below, asking it for next values\n  return {\n    current: this.from,\n    last: this.to,\n\n    // 3. next() is called on each iteration by the for..of loop\n    next() {\n      // 4. it should return the value as an object {done:.., value :...}\n      if (this.current <= this.last) {\n        return { done: false, value: this.current++ };\n      } else {\n        return { done: true };\n      }\n    }\n  };\n};\n\n// now it works!\nfor (let num of range) {\n  alert(num); // 1, then 2, 3, 4, 5\n}\n\nPlease note the core feature of iterables: separation of concerns.\n\nThe range itself does not have the next() method.\nInstead, another object, a so-called “iterator” is created by the call to range[Symbol.iterator](), and its next() generates values for the iteration.\n\nSo, the iterator object is separate from the object it iterates over.\n\nTechnically, we may merge them and use range itself as the iterator to make the code simpler.\n\nLike this:\n\n\t\nlet range = {\n  from: 1,\n  to: 5,\n\n  [Symbol.iterator]() {\n    this.current = this.from;\n    return this;\n  },\n\n  next() {\n    if (this.current <= this.to) {\n      return { done: false, value: this.current++ };\n    } else {\n      return { done: true };\n    }\n  }\n};\n\nfor (let num of range) {\n  alert(num); // 1, then 2, 3, 4, 5\n}\n\nNow range[Symbol.iterator]() returns the range object itself: it has the necessary next() method and remembers the current iteration progress in this.current. Shorter? Yes. And sometimes that’s fine too.\n\nThe downside is that now it’s impossible to have two for..of loops running over the object simultaneously: they’ll share the iteration state, because there’s only one iterator – the object itself. But two parallel for-ofs is a rare thing, even in async scenarios.\n\nInfinite iterators\n\nInfinite iterators are also possible. For instance, the range becomes infinite for range.to = Infinity. Or we can make an iterable object that generates an infinite sequence of pseudorandom numbers. Also can be useful.\n\nThere are no limitations on next, it can return more and more values, that’s normal.\n\nOf course, the for..of loop over such an iterable would be endless. But we can always stop it using break.\n\nString is iterable\n\nArrays and strings are most widely used built-in iterables.\n\nFor a string, for..of loops over its characters:\n\n\t\nfor (let char of \"test\") {\n  // triggers 4 times: once for each character\n  alert( char ); // t, then e, then s, then t\n}\n\nAnd it works correctly with surrogate pairs!\n\n\t\nlet str = '𝒳😂';\nfor (let char of str) {\n    alert( char ); // 𝒳, and then 😂\n}\nCalling an iterator explicitly\n\nFor deeper understanding, let’s see how to use an iterator explicitly.\n\nWe’ll iterate over a string in exactly the same way as for..of, but with direct calls. This code creates a string iterator and gets values from it “manually”:\n\n\t\nlet str = \"Hello\";\n\n// does the same as\n// for (let char of str) alert(char);\n\nlet iterator = str[Symbol.iterator]();\n\nwhile (true) {\n  let result = iterator.next();\n  if (result.done) break;\n  alert(result.value); // outputs characters one by one\n}\n\nThat is rarely needed, but gives us more control over the process than for..of. For instance, we can split the iteration process: iterate a bit, then stop, do something else, and then resume later.\n\nIterables and array-likes\n\nTwo official terms look similar, but are very different. Please make sure you understand them well to avoid the confusion.\n\nIterables are objects that implement the Symbol.iterator method, as described above.\nArray-likes are objects that have indexes and length, so they look like arrays.\n\nWhen we use JavaScript for practical tasks in a browser or any other environment, we may meet objects that are iterables or array-likes, or both.\n\nFor instance, strings are both iterable (for..of works on them) and array-like (they have numeric indexes and length).\n\nBut an iterable may be not array-like. And vice versa an array-like may be not iterable.\n\nFor example, the range in the example above is iterable, but not array-like, because it does not have indexed properties and length.\n\nAnd here’s the object that is array-like, but not iterable:\n\n\t\nlet arrayLike = { // has indexes and length => array-like\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\n// Error (no Symbol.iterator)\nfor (let item of arrayLike) {}\n\nBoth iterables and array-likes are usually not arrays, they don’t have push, pop etc. That’s rather inconvenient if we have such an object and want to work with it as with an array. E.g. we would like to work with range using array methods. How to achieve that?\n\nArray.from\n\nThere’s a universal method Array.from that takes an iterable or array-like value and makes a “real” Array from it. Then we can call array methods on it.\n\nFor instance:\n\n\t\nlet arrayLike = {\n  0: \"Hello\",\n  1: \"World\",\n  length: 2\n};\n\nlet arr = Array.from(arrayLike); // (*)\nalert(arr.pop()); // World (method works)\n\nArray.from at the line (*) takes the object, examines it for being an iterable or array-like, then makes a new array and copies all items to it.\n\nThe same happens for an iterable:\n\n\t\n// assuming that range is taken from the example above\nlet arr = Array.from(range);\nalert(arr); // 1,2,3,4,5 (array toString conversion works)\n\nThe full syntax for Array.from also allows us to provide an optional “mapping” function:\n\nArray.from(obj[, mapFn, thisArg])\n\nThe optional second argument mapFn can be a function that will be applied to each element before adding it to the array, and thisArg allows us to set this for it.\n\nFor instance:\n\n\t\n// assuming that range is taken from the example above\n\n// square each number\nlet arr = Array.from(range, num => num * num);\n\nalert(arr); // 1,4,9,16,25\n\nHere we use Array.from to turn a string into an array of characters:\n\n\t\nlet str = '𝒳😂';\n\n// splits str into array of characters\nlet chars = Array.from(str);\n\nalert(chars[0]); // 𝒳\nalert(chars[1]); // 😂\nalert(chars.length); // 2\n\nUnlike str.split, it relies on the iterable nature of the string and so, just like for..of, correctly works with surrogate pairs.\n\nTechnically here it does the same as:\n\n\t\nlet str = '𝒳😂';\n\nlet chars = []; // Array.from internally does the same loop\nfor (let char of str) {\n  chars.push(char);\n}\n\nalert(chars);\n\n…But it is shorter.\n\nWe can even build surrogate-aware slice on it:\n\n\t\nfunction slice(str, start, end) {\n  return Array.from(str).slice(start, end).join('');\n}\n\nlet str = '𝒳😂𩷶';\n\nalert( slice(str, 1, 3) ); // 😂𩷶\n\n// the native method does not support surrogate pairs\nalert( str.slice(1, 3) ); // garbage (two pieces from different surrogate pairs)\nSummary\n\nObjects that can be used in for..of are called iterable.\n\nTechnically, iterables must implement the method named Symbol.iterator.\nThe result of obj[Symbol.iterator]() is called an iterator. It handles further iteration process.\nAn iterator must have the method named next() that returns an object {done: Boolean, value: any}, here done:true denotes the end of the iteration process, otherwise the value is the next value.\nThe Symbol.iterator method is called automatically by for..of, but we also can do it directly.\nBuilt-in iterables like strings or arrays, also implement Symbol.iterator.\nString iterator knows about surrogate pairs.\n\nObjects that have indexed properties and length are called array-like. Such objects may also have other properties and methods, but lack the built-in methods of arrays.\n\nIf we look inside the specification – we’ll see that most built-in methods assume that they work with iterables or array-likes instead of “real” arrays, because that’s more abstract.\n\nArray.from(obj[, mapFn, thisArg]) makes a real Array from an iterable or array-like obj, and we can then use array methods on it. The optional arguments mapFn and thisArg allow us to apply a function to each item."
  },
  {
    "title": "Array methods",
    "url": "https://javascript.info/array-methods",
    "html": "Arrays provide a lot of methods. To make things easier, in this chapter they are split into groups.\n\nAdd/remove items\n\nWe already know methods that add and remove items from the beginning or the end:\n\narr.push(...items) – adds items to the end,\narr.pop() – extracts an item from the end,\narr.shift() – extracts an item from the beginning,\narr.unshift(...items) – adds items to the beginning.\n\nHere are a few others.\n\nsplice\n\nHow to delete an element from the array?\n\nThe arrays are objects, so we can try to use delete:\n\n\t\nlet arr = [\"I\", \"go\", \"home\"];\n\ndelete arr[1]; // remove \"go\"\n\nalert( arr[1] ); // undefined\n\n// now arr = [\"I\",  , \"home\"];\nalert( arr.length ); // 3\n\nThe element was removed, but the array still has 3 elements, we can see that arr.length == 3.\n\nThat’s natural, because delete obj.key removes a value by the key. It’s all it does. Fine for objects. But for arrays we usually want the rest of elements to shift and occupy the freed place. We expect to have a shorter array now.\n\nSo, special methods should be used.\n\nThe arr.splice method is a swiss army knife for arrays. It can do everything: insert, remove and replace elements.\n\nThe syntax is:\n\narr.splice(start[, deleteCount, elem1, ..., elemN])\n\nIt modifies arr starting from the index start: removes deleteCount elements and then inserts elem1, ..., elemN at their place. Returns the array of removed elements.\n\nThis method is easy to grasp by examples.\n\nLet’s start with the deletion:\n\n\t\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\narr.splice(1, 1); // from index 1 remove 1 element\n\nalert( arr ); // [\"I\", \"JavaScript\"]\n\nEasy, right? Starting from the index 1 it removed 1 element.\n\nIn the next example we remove 3 elements and replace them with the other two:\n\n\t\nlet arr = [\"I\", \"study\", \"JavaScript\", \"right\", \"now\"];\n\n// remove 3 first elements and replace them with another\narr.splice(0, 3, \"Let's\", \"dance\");\n\nalert( arr ) // now [\"Let's\", \"dance\", \"right\", \"now\"]\n\nHere we can see that splice returns the array of removed elements:\n\n\t\nlet arr = [\"I\", \"study\", \"JavaScript\", \"right\", \"now\"];\n\n// remove 2 first elements\nlet removed = arr.splice(0, 2);\n\nalert( removed ); // \"I\", \"study\" <-- array of removed elements\n\nThe splice method is also able to insert the elements without any removals. For that we need to set deleteCount to 0:\n\n\t\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\n// from index 2\n// delete 0\n// then insert \"complex\" and \"language\"\narr.splice(2, 0, \"complex\", \"language\");\n\nalert( arr ); // \"I\", \"study\", \"complex\", \"language\", \"JavaScript\"\nNegative indexes allowed\n\nHere and in other array methods, negative indexes are allowed. They specify the position from the end of the array, like here:\n\n\t\nlet arr = [1, 2, 5];\n\n// from index -1 (one step from the end)\n// delete 0 elements,\n// then insert 3 and 4\narr.splice(-1, 0, 3, 4);\n\nalert( arr ); // 1,2,3,4,5\nslice\n\nThe method arr.slice is much simpler than similar-looking arr.splice.\n\nThe syntax is:\n\narr.slice([start], [end])\n\nIt returns a new array copying to it all items from index start to end (not including end). Both start and end can be negative, in that case position from array end is assumed.\n\nIt’s similar to a string method str.slice, but instead of substrings it makes subarrays.\n\nFor instance:\n\n\t\nlet arr = [\"t\", \"e\", \"s\", \"t\"];\n\nalert( arr.slice(1, 3) ); // e,s (copy from 1 to 3)\n\nalert( arr.slice(-2) ); // s,t (copy from -2 till the end)\n\nWe can also call it without arguments: arr.slice() creates a copy of arr. That’s often used to obtain a copy for further transformations that should not affect the original array.\n\nconcat\n\nThe method arr.concat creates a new array that includes values from other arrays and additional items.\n\nThe syntax is:\n\narr.concat(arg1, arg2...)\n\nIt accepts any number of arguments – either arrays or values.\n\nThe result is a new array containing items from arr, then arg1, arg2 etc.\n\nIf an argument argN is an array, then all its elements are copied. Otherwise, the argument itself is copied.\n\nFor instance:\n\n\t\nlet arr = [1, 2];\n\n// create an array from: arr and [3,4]\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n\n// create an array from: arr and [3,4] and [5,6]\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n\n// create an array from: arr and [3,4], then add values 5 and 6\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n\nNormally, it only copies elements from arrays. Other objects, even if they look like arrays, are added as a whole:\n\n\t\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"something\",\n  length: 1\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,[object Object]\n\n…But if an array-like object has a special Symbol.isConcatSpreadable property, then it’s treated as an array by concat: its elements are added instead:\n\n\t\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"something\",\n  1: \"else\",\n  [Symbol.isConcatSpreadable]: true,\n  length: 2\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,something,else\nIterate: forEach\n\nThe arr.forEach method allows to run a function for every element of the array.\n\nThe syntax:\n\narr.forEach(function(item, index, array) {\n  // ... do something with item\n});\n\nFor instance, this shows each element of the array:\n\n\t\n// for each element call alert\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach(alert);\n\nAnd this code is more elaborate about their positions in the target array:\n\n\t\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach((item, index, array) => {\n  alert(`${item} is at index ${index} in ${array}`);\n});\n\nThe result of the function (if it returns any) is thrown away and ignored.\n\nSearching in array\n\nNow let’s cover methods that search in an array.\n\nindexOf/lastIndexOf and includes\n\nThe methods arr.indexOf and arr.includes have the similar syntax and do essentially the same as their string counterparts, but operate on items instead of characters:\n\narr.indexOf(item, from) – looks for item starting from index from, and returns the index where it was found, otherwise -1.\narr.includes(item, from) – looks for item starting from index from, returns true if found.\n\nUsually these methods are used with only one argument: the item to search. By default, the search is from the beginning.\n\nFor instance:\n\n\t\nlet arr = [1, 0, false];\n\nalert( arr.indexOf(0) ); // 1\nalert( arr.indexOf(false) ); // 2\nalert( arr.indexOf(null) ); // -1\n\nalert( arr.includes(1) ); // true\n\nPlease note that indexOf uses the strict equality === for comparison. So, if we look for false, it finds exactly false and not the zero.\n\nIf we want to check if item exists in the array, and don’t need the index, then arr.includes is preferred.\n\nThe method arr.lastIndexOf is the same as indexOf, but looks for from right to left.\n\n\t\nlet fruits = ['Apple', 'Orange', 'Apple']\n\nalert( fruits.indexOf('Apple') ); // 0 (first Apple)\nalert( fruits.lastIndexOf('Apple') ); // 2 (last Apple)\nThe includes method handles NaN correctly\n\nA minor, but noteworthy feature of includes is that it correctly handles NaN, unlike indexOf:\n\n\t\nconst arr = [NaN];\nalert( arr.indexOf(NaN) ); // -1 (wrong, should be 0)\nalert( arr.includes(NaN) );// true (correct)\n\nThat’s because includes was added to JavaScript much later and uses the more up to date comparison algorithm internally.\n\nfind and findIndex/findLastIndex\n\nImagine we have an array of objects. How do we find an object with the specific condition?\n\nHere the arr.find(fn) method comes in handy.\n\nThe syntax is:\n\nlet result = arr.find(function(item, index, array) {\n  // if true is returned, item is returned and iteration is stopped\n  // for falsy scenario returns undefined\n});\n\nThe function is called for elements of the array, one after another:\n\nitem is the element.\nindex is its index.\narray is the array itself.\n\nIf it returns true, the search is stopped, the item is returned. If nothing found, undefined is returned.\n\nFor example, we have an array of users, each with the fields id and name. Let’s find the one with id == 1:\n\n\t\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\nlet user = users.find(item => item.id == 1);\n\nalert(user.name); // John\n\nIn real life arrays of objects is a common thing, so the find method is very useful.\n\nNote that in the example we provide to find the function item => item.id == 1 with one argument. That’s typical, other arguments of this function are rarely used.\n\nThe arr.findIndex method has the same syntax, but returns the index where the element was found instead of the element itself. The value of -1 is returned if nothing is found.\n\nThe arr.findLastIndex method is like findIndex, but searches from right to left, similar to lastIndexOf.\n\nHere’s an example:\n\n\t\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"},\n  {id: 4, name: \"John\"}\n];\n\n// Find the index of the first John\nalert(users.findIndex(user => user.name == 'John')); // 0\n\n// Find the index of the last John\nalert(users.findLastIndex(user => user.name == 'John')); // 3\nfilter\n\nThe find method looks for a single (first) element that makes the function return true.\n\nIf there may be many, we can use arr.filter(fn).\n\nThe syntax is similar to find, but filter returns an array of all matching elements:\n\nlet results = arr.filter(function(item, index, array) {\n  // if true item is pushed to results and the iteration continues\n  // returns empty array if nothing found\n});\n\nFor instance:\n\n\t\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\n// returns array of the first two users\nlet someUsers = users.filter(item => item.id < 3);\n\nalert(someUsers.length); // 2\nTransform an array\n\nLet’s move on to methods that transform and reorder an array.\n\nmap\n\nThe arr.map method is one of the most useful and often used.\n\nIt calls the function for each element of the array and returns the array of results.\n\nThe syntax is:\n\nlet result = arr.map(function(item, index, array) {\n  // returns the new value instead of item\n});\n\nFor instance, here we transform each element into its length:\n\n\t\nlet lengths = [\"Bilbo\", \"Gandalf\", \"Nazgul\"].map(item => item.length);\nalert(lengths); // 5,7,6\nsort(fn)\n\nThe call to arr.sort() sorts the array in place, changing its element order.\n\nIt also returns the sorted array, but the returned value is usually ignored, as arr itself is modified.\n\nFor instance:\n\n\t\nlet arr = [ 1, 2, 15 ];\n\n// the method reorders the content of arr\narr.sort();\n\nalert( arr );  // 1, 15, 2\n\nDid you notice anything strange in the outcome?\n\nThe order became 1, 15, 2. Incorrect. But why?\n\nThe items are sorted as strings by default.\n\nLiterally, all elements are converted to strings for comparisons. For strings, lexicographic ordering is applied and indeed \"2\" > \"15\".\n\nTo use our own sorting order, we need to supply a function as the argument of arr.sort().\n\nThe function should compare two arbitrary values and return:\n\nfunction compare(a, b) {\n  if (a > b) return 1; // if the first value is greater than the second\n  if (a == b) return 0; // if values are equal\n  if (a < b) return -1; // if the first value is less than the second\n}\n\nFor instance, to sort as numbers:\n\n\t\nfunction compareNumeric(a, b) {\n  if (a > b) return 1;\n  if (a == b) return 0;\n  if (a < b) return -1;\n}\n\nlet arr = [ 1, 2, 15 ];\n\narr.sort(compareNumeric);\n\nalert(arr);  // 1, 2, 15\n\nNow it works as intended.\n\nLet’s step aside and think what’s happening. The arr can be array of anything, right? It may contain numbers or strings or objects or whatever. We have a set of some items. To sort it, we need an ordering function that knows how to compare its elements. The default is a string order.\n\nThe arr.sort(fn) method implements a generic sorting algorithm. We don’t need to care how it internally works (an optimized quicksort or Timsort most of the time). It will walk the array, compare its elements using the provided function and reorder them, all we need is to provide the fn which does the comparison.\n\nBy the way, if we ever want to know which elements are compared – nothing prevents from alerting them:\n\n\t\n[1, -2, 15, 2, 0, 8].sort(function(a, b) {\n  alert( a + \" <> \" + b );\n  return a - b;\n});\n\nThe algorithm may compare an element with multiple others in the process, but it tries to make as few comparisons as possible.\n\nA comparison function may return any number\n\nActually, a comparison function is only required to return a positive number to say “greater” and a negative number to say “less”.\n\nThat allows to write shorter functions:\n\n\t\nlet arr = [ 1, 2, 15 ];\n\narr.sort(function(a, b) { return a - b; });\n\nalert(arr);  // 1, 2, 15\nArrow functions for the best\n\nRemember arrow functions? We can use them here for neater sorting:\n\narr.sort( (a, b) => a - b );\n\nThis works exactly the same as the longer version above.\n\nUse localeCompare for strings\n\nRemember strings comparison algorithm? It compares letters by their codes by default.\n\nFor many alphabets, it’s better to use str.localeCompare method to correctly sort letters, such as Ö.\n\nFor example, let’s sort a few countries in German:\n\n\t\nlet countries = ['Österreich', 'Andorra', 'Vietnam'];\n\nalert( countries.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (wrong)\n\nalert( countries.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (correct!)\nreverse\n\nThe method arr.reverse reverses the order of elements in arr.\n\nFor instance:\n\n\t\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\n\nalert( arr ); // 5,4,3,2,1\n\nIt also returns the array arr after the reversal.\n\nsplit and join\n\nHere’s the situation from real life. We are writing a messaging app, and the person enters the comma-delimited list of receivers: John, Pete, Mary. But for us an array of names would be much more comfortable than a single string. How to get it?\n\nThe str.split(delim) method does exactly that. It splits the string into an array by the given delimiter delim.\n\nIn the example below, we split by a comma followed by space:\n\n\t\nlet names = 'Bilbo, Gandalf, Nazgul';\n\nlet arr = names.split(', ');\n\nfor (let name of arr) {\n  alert( `A message to ${name}.` ); // A message to Bilbo  (and other names)\n}\n\nThe split method has an optional second numeric argument – a limit on the array length. If it is provided, then the extra elements are ignored. In practice it is rarely used though:\n\n\t\nlet arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);\n\nalert(arr); // Bilbo, Gandalf\nSplit into letters\n\nThe call to split(s) with an empty s would split the string into an array of letters:\n\n\t\nlet str = \"test\";\n\nalert( str.split('') ); // t,e,s,t\n\nThe call arr.join(glue) does the reverse to split. It creates a string of arr items joined by glue between them.\n\nFor instance:\n\n\t\nlet arr = ['Bilbo', 'Gandalf', 'Nazgul'];\n\nlet str = arr.join(';'); // glue the array into a string using ;\n\nalert( str ); // Bilbo;Gandalf;Nazgul\nreduce/reduceRight\n\nWhen we need to iterate over an array – we can use forEach, for or for..of.\n\nWhen we need to iterate and return the data for each element – we can use map.\n\nThe methods arr.reduce and arr.reduceRight also belong to that breed, but are a little bit more intricate. They are used to calculate a single value based on the array.\n\nThe syntax is:\n\nlet value = arr.reduce(function(accumulator, item, index, array) {\n  // ...\n}, [initial]);\n\nThe function is applied to all array elements one after another and “carries on” its result to the next call.\n\nArguments:\n\naccumulator – is the result of the previous function call, equals initial the first time (if initial is provided).\nitem – is the current array item.\nindex – is its position.\narray – is the array.\n\nAs function is applied, the result of the previous function call is passed to the next one as the first argument.\n\nSo, the first argument is essentially the accumulator that stores the combined result of all previous executions. And at the end it becomes the result of reduce.\n\nSounds complicated?\n\nThe easiest way to grasp that is by example.\n\nHere we get a sum of an array in one line:\n\n\t\nlet arr = [1, 2, 3, 4, 5];\n\nlet result = arr.reduce((sum, current) => sum + current, 0);\n\nalert(result); // 15\n\nThe function passed to reduce uses only 2 arguments, that’s typically enough.\n\nLet’s see the details of what’s going on.\n\nOn the first run, sum is the initial value (the last argument of reduce), equals 0, and current is the first array element, equals 1. So the function result is 1.\nOn the second run, sum = 1, we add the second array element (2) to it and return.\nOn the 3rd run, sum = 3 and we add one more element to it, and so on…\n\nThe calculation flow:\n\nOr in the form of a table, where each row represents a function call on the next array element:\n\n\tsum\tcurrent\tresult\nthe first call\t0\t1\t1\nthe second call\t1\t2\t3\nthe third call\t3\t3\t6\nthe fourth call\t6\t4\t10\nthe fifth call\t10\t5\t15\n\nHere we can clearly see how the result of the previous call becomes the first argument of the next one.\n\nWe also can omit the initial value:\n\n\t\nlet arr = [1, 2, 3, 4, 5];\n\n// removed initial value from reduce (no 0)\nlet result = arr.reduce((sum, current) => sum + current);\n\nalert( result ); // 15\n\nThe result is the same. That’s because if there’s no initial, then reduce takes the first element of the array as the initial value and starts the iteration from the 2nd element.\n\nThe calculation table is the same as above, minus the first row.\n\nBut such use requires an extreme care. If the array is empty, then reduce call without initial value gives an error.\n\nHere’s an example:\n\n\t\nlet arr = [];\n\n// Error: Reduce of empty array with no initial value\n// if the initial value existed, reduce would return it for the empty arr.\narr.reduce((sum, current) => sum + current);\n\nSo it’s advised to always specify the initial value.\n\nThe method arr.reduceRight does the same, but goes from right to left.\n\nArray.isArray\n\nArrays do not form a separate language type. They are based on objects.\n\nSo typeof does not help to distinguish a plain object from an array:\n\n\t\nalert(typeof {}); // object\nalert(typeof []); // object (same)\n\n…But arrays are used so often that there’s a special method for that: Array.isArray(value). It returns true if the value is an array, and false otherwise.\n\n\t\nalert(Array.isArray({})); // false\n\nalert(Array.isArray([])); // true\nMost methods support “thisArg”\n\nAlmost all array methods that call functions – like find, filter, map, with a notable exception of sort, accept an optional additional parameter thisArg.\n\nThat parameter is not explained in the sections above, because it’s rarely used. But for completeness we have to cover it.\n\nHere’s the full syntax of these methods:\n\narr.find(func, thisArg);\narr.filter(func, thisArg);\narr.map(func, thisArg);\n// ...\n// thisArg is the optional last argument\n\nThe value of thisArg parameter becomes this for func.\n\nFor example, here we use a method of army object as a filter, and thisArg passes the context:\n\n\t\nlet army = {\n  minAge: 18,\n  maxAge: 27,\n  canJoin(user) {\n    return user.age >= this.minAge && user.age < this.maxAge;\n  }\n};\n\nlet users = [\n  {age: 16},\n  {age: 20},\n  {age: 23},\n  {age: 30}\n];\n\n// find users, for who army.canJoin returns true\nlet soldiers = users.filter(army.canJoin, army);\n\nalert(soldiers.length); // 2\nalert(soldiers[0].age); // 20\nalert(soldiers[1].age); // 23\n\nIf in the example above we used users.filter(army.canJoin), then army.canJoin would be called as a standalone function, with this=undefined, thus leading to an instant error.\n\nA call to users.filter(army.canJoin, army) can be replaced with users.filter(user => army.canJoin(user)), that does the same. The latter is used more often, as it’s a bit easier to understand for most people.\n\nSummary\n\nA cheat sheet of array methods:\n\nTo add/remove elements:\n\npush(...items) – adds items to the end,\npop() – extracts an item from the end,\nshift() – extracts an item from the beginning,\nunshift(...items) – adds items to the beginning.\nsplice(pos, deleteCount, ...items) – at index pos deletes deleteCount elements and inserts items.\nslice(start, end) – creates a new array, copies elements from index start till end (not inclusive) into it.\nconcat(...items) – returns a new array: copies all members of the current one and adds items to it. If any of items is an array, then its elements are taken.\n\nTo search among elements:\n\nindexOf/lastIndexOf(item, pos) – look for item starting from position pos, return the index or -1 if not found.\nincludes(value) – returns true if the array has value, otherwise false.\nfind/filter(func) – filter elements through the function, return first/all values that make it return true.\nfindIndex is like find, but returns the index instead of a value.\n\nTo iterate over elements:\n\nforEach(func) – calls func for every element, does not return anything.\n\nTo transform the array:\n\nmap(func) – creates a new array from results of calling func for every element.\nsort(func) – sorts the array in-place, then returns it.\nreverse() – reverses the array in-place, then returns it.\nsplit/join – convert a string to array and back.\nreduce/reduceRight(func, initial) – calculate a single value over the array by calling func for each element and passing an intermediate result between the calls.\n\nAdditionally:\n\nArray.isArray(value) checks value for being an array, if so returns true, otherwise false.\n\nPlease note that methods sort, reverse and splice modify the array itself.\n\nThese methods are the most used ones, they cover 99% of use cases. But there are few others:\n\narr.some(fn)/arr.every(fn) check the array.\n\nThe function fn is called on each element of the array similar to map. If any/all results are true, returns true, otherwise false.\n\nThese methods behave sort of like || and && operators: if fn returns a truthy value, arr.some() immediately returns true and stops iterating over the rest of items; if fn returns a falsy value, arr.every() immediately returns false and stops iterating over the rest of items as well.\n\nWe can use every to compare arrays:\n\n\t\nfunction arraysEqual(arr1, arr2) {\n  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\n\nalert( arraysEqual([1, 2], [1, 2])); // true\n\narr.fill(value, start, end) – fills the array with repeating value from index start to end.\n\narr.copyWithin(target, start, end) – copies its elements from position start till position end into itself, at position target (overwrites existing).\n\narr.flat(depth)/arr.flatMap(fn) create a new flat array from a multidimensional array.\n\nFor the full list, see the manual.\n\nFrom the first sight it may seem that there are so many methods, quite difficult to remember. But actually that’s much easier.\n\nLook through the cheat sheet just to be aware of them. Then solve the tasks of this chapter to practice, so that you have experience with array methods.\n\nAfterwards whenever you need to do something with an array, and you don’t know how – come here, look at the cheat sheet and find the right method. Examples will help you to write it correctly. Soon you’ll automatically remember the methods, without specific efforts from your side.\n\nTasks\nTranslate border-left-width to borderLeftWidth\nimportance: 5\n\nWrite the function camelize(str) that changes dash-separated words like “my-short-string” into camel-cased “myShortString”.\n\nThat is: removes all dashes, each word after dash becomes uppercased.\n\nExamples:\n\ncamelize(\"background-color\") == 'backgroundColor';\ncamelize(\"list-style-image\") == 'listStyleImage';\ncamelize(\"-webkit-transition\") == 'WebkitTransition';\n\nP.S. Hint: use split to split the string into an array, transform it and join back.\n\nOpen a sandbox with tests.\n\nsolution\nFilter range\nimportance: 4\n\nWrite a function filterRange(arr, a, b) that gets an array arr, looks for elements with values higher or equal to a and lower or equal to b and return a result as an array.\n\nThe function should not modify the array. It should return the new array.\n\nFor instance:\n\nlet arr = [5, 3, 8, 1];\n\nlet filtered = filterRange(arr, 1, 4);\n\nalert( filtered ); // 3,1 (matching values)\n\nalert( arr ); // 5,3,8,1 (not modified)\n\nOpen a sandbox with tests.\n\nsolution\nFilter range \"in place\"\nimportance: 4\n\nWrite a function filterRangeInPlace(arr, a, b) that gets an array arr and removes from it all values except those that are between a and b. The test is: a ≤ arr[i] ≤ b.\n\nThe function should only modify the array. It should not return anything.\n\nFor instance:\n\nlet arr = [5, 3, 8, 1];\n\nfilterRangeInPlace(arr, 1, 4); // removed the numbers except from 1 to 4\n\nalert( arr ); // [3, 1]\n\nOpen a sandbox with tests.\n\nsolution\nSort in decreasing order\nimportance: 4\nlet arr = [5, 2, 1, -10, 8];\n\n// ... your code to sort it in decreasing order\n\nalert( arr ); // 8, 5, 2, 1, -10\nsolution\nCopy and sort array\nimportance: 5\n\nWe have an array of strings arr. We’d like to have a sorted copy of it, but keep arr unmodified.\n\nCreate a function copySorted(arr) that returns such a copy.\n\nlet arr = [\"HTML\", \"JavaScript\", \"CSS\"];\n\nlet sorted = copySorted(arr);\n\nalert( sorted ); // CSS, HTML, JavaScript\nalert( arr ); // HTML, JavaScript, CSS (no changes)\nsolution\nCreate an extendable calculator\nimportance: 5\n\nCreate a constructor function Calculator that creates “extendable” calculator objects.\n\nThe task consists of two parts.\n\nFirst, implement the method calculate(str) that takes a string like \"1 + 2\" in the format “NUMBER operator NUMBER” (space-delimited) and returns the result. Should understand plus + and minus -.\n\nUsage example:\n\nlet calc = new Calculator;\n\nalert( calc.calculate(\"3 + 7\") ); // 10\n\nThen add the method addMethod(name, func) that teaches the calculator a new operation. It takes the operator name and the two-argument function func(a,b) that implements it.\n\nFor instance, let’s add the multiplication *, division / and power **:\n\nlet powerCalc = new Calculator;\npowerCalc.addMethod(\"*\", (a, b) => a * b);\npowerCalc.addMethod(\"/\", (a, b) => a / b);\npowerCalc.addMethod(\"**\", (a, b) => a ** b);\n\nlet result = powerCalc.calculate(\"2 ** 3\");\nalert( result ); // 8\nNo parentheses or complex expressions in this task.\nThe numbers and the operator are delimited with exactly one space.\nThere may be error handling if you’d like to add it.\n\nOpen a sandbox with tests.\n\nsolution\nMap to names\nimportance: 5\n\nYou have an array of user objects, each one has user.name. Write the code that converts it into an array of names.\n\nFor instance:\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet users = [ john, pete, mary ];\n\nlet names = /* ... your code */\n\nalert( names ); // John, Pete, Mary\nsolution\nMap to objects\nimportance: 5\n\nYou have an array of user objects, each one has name, surname and id.\n\nWrite the code to create another array from it, of objects with id and fullName, where fullName is generated from name and surname.\n\nFor instance:\n\nlet john = { name: \"John\", surname: \"Smith\", id: 1 };\nlet pete = { name: \"Pete\", surname: \"Hunt\", id: 2 };\nlet mary = { name: \"Mary\", surname: \"Key\", id: 3 };\n\nlet users = [ john, pete, mary ];\n\nlet usersMapped = /* ... your code ... */\n\n/*\nusersMapped = [\n  { fullName: \"John Smith\", id: 1 },\n  { fullName: \"Pete Hunt\", id: 2 },\n  { fullName: \"Mary Key\", id: 3 }\n]\n*/\n\nalert( usersMapped[0].id ) // 1\nalert( usersMapped[0].fullName ) // John Smith\n\nSo, actually you need to map one array of objects to another. Try using => here. There’s a small catch.\n\nsolution\nSort users by age\nimportance: 5\n\nWrite the function sortByAge(users) that gets an array of objects with the age property and sorts them by age.\n\nFor instance:\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 28 };\n\nlet arr = [ pete, john, mary ];\n\nsortByAge(arr);\n\n// now: [john, mary, pete]\nalert(arr[0].name); // John\nalert(arr[1].name); // Mary\nalert(arr[2].name); // Pete\nsolution\nShuffle an array\nimportance: 3\n\nWrite the function shuffle(array) that shuffles (randomly reorders) elements of the array.\n\nMultiple runs of shuffle may lead to different orders of elements. For instance:\n\nlet arr = [1, 2, 3];\n\nshuffle(arr);\n// arr = [3, 2, 1]\n\nshuffle(arr);\n// arr = [2, 1, 3]\n\nshuffle(arr);\n// arr = [3, 1, 2]\n// ...\n\nAll element orders should have an equal probability. For instance, [1,2,3] can be reordered as [1,2,3] or [1,3,2] or [3,1,2] etc, with equal probability of each case.\n\nsolution\nGet average age\nimportance: 4\n\nWrite the function getAverageAge(users) that gets an array of objects with property age and returns the average age.\n\nThe formula for the average is (age1 + age2 + ... + ageN) / N.\n\nFor instance:\n\nlet john = { name: \"John\", age: 25 };\nlet pete = { name: \"Pete\", age: 30 };\nlet mary = { name: \"Mary\", age: 29 };\n\nlet arr = [ john, pete, mary ];\n\nalert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28\nsolution\nFilter unique array members\nimportance: 4\n\nLet arr be an array.\n\nCreate a function unique(arr) that should return an array with unique items of arr.\n\nFor instance:\n\nfunction unique(arr) {\n  /* your code */\n}\n\nlet strings = [\"Hare\", \"Krishna\", \"Hare\", \"Krishna\",\n  \"Krishna\", \"Krishna\", \"Hare\", \"Hare\", \":-O\"\n];\n\nalert( unique(strings) ); // Hare, Krishna, :-O\n\nOpen a sandbox with tests.\n\nsolution\nCreate keyed object from array\nimportance: 4\n\nLet’s say we received an array of users in the form {id:..., name:..., age:... }.\n\nCreate a function groupById(arr) that creates an object from it, with id as the key, and array items as values.\n\nFor example:\n\nlet users = [\n  {id: 'john', name: \"John Smith\", age: 20},\n  {id: 'ann', name: \"Ann Smith\", age: 24},\n  {id: 'pete', name: \"Pete Peterson\", age: 31},\n];\n\nlet usersById = groupById(users);\n\n/*\n// after the call we should have:\n\nusersById = {\n  john: {id: 'john', name: \"John Smith\", age: 20},\n  ann: {id: 'ann', name: \"Ann Smith\", age: 24},\n  pete: {id: 'pete', name: \"Pete Peterson\", age: 31},\n}\n*/\n\nSuch function is really handy when working with server data.\n\nIn this task we assume that id is unique. There may be no two array items with the same id.\n\nPlease use array .reduce method in the solution.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Arrays",
    "url": "https://javascript.info/array",
    "html": "Objects allow you to store keyed collections of values. That’s fine.\n\nBut quite often we find that we need an ordered collection, where we have a 1st, a 2nd, a 3rd element and so on. For example, we need that to store a list of something: users, goods, HTML elements etc.\n\nIt is not convenient to use an object here, because it provides no methods to manage the order of elements. We can’t insert a new property “between” the existing ones. Objects are just not meant for such use.\n\nThere exists a special data structure named Array, to store ordered collections.\n\nDeclaration\n\nThere are two syntaxes for creating an empty array:\n\nlet arr = new Array();\nlet arr = [];\n\nAlmost all the time, the second syntax is used. We can supply initial elements in the brackets:\n\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nArray elements are numbered, starting with zero.\n\nWe can get an element by its number in square brackets:\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits[0] ); // Apple\nalert( fruits[1] ); // Orange\nalert( fruits[2] ); // Plum\n\nWe can replace an element:\n\nfruits[2] = 'Pear'; // now [\"Apple\", \"Orange\", \"Pear\"]\n\n…Or add a new one to the array:\n\nfruits[3] = 'Lemon'; // now [\"Apple\", \"Orange\", \"Pear\", \"Lemon\"]\n\nThe total count of the elements in the array is its length:\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits.length ); // 3\n\nWe can also use alert to show the whole array.\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits ); // Apple,Orange,Plum\n\nAn array can store elements of any type.\n\nFor instance:\n\n\t\n// mix of values\nlet arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];\n\n// get the object at index 1 and then show its name\nalert( arr[1].name ); // John\n\n// get the function at index 3 and run it\narr[3](); // hello\nTrailing comma\n\nAn array, just like an object, may end with a comma:\n\nlet fruits = [\n  \"Apple\",\n  \"Orange\",\n  \"Plum\",\n];\n\nThe “trailing comma” style makes it easier to insert/remove items, because all lines become alike.\n\nGet last elements with “at”\nA recent addition\nThis is a recent addition to the language. Old browsers may need polyfills.\n\nLet’s say we want the last element of the array.\n\nSome programming languages allow the use of negative indexes for the same purpose, like fruits[-1].\n\nAlthough, in JavaScript it won’t work. The result will be undefined, because the index in square brackets is treated literally.\n\nWe can explicitly calculate the last element index and then access it: fruits[fruits.length - 1].\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits[fruits.length-1] ); // Plum\n\nA bit cumbersome, isn’t it? We need to write the variable name twice.\n\nLuckily, there’s a shorter syntax: fruits.at(-1):\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// same as fruits[fruits.length-1]\nalert( fruits.at(-1) ); // Plum\n\nIn other words, arr.at(i):\n\nis exactly the same as arr[i], if i >= 0.\nfor negative values of i, it steps back from the end of the array.\nMethods pop/push, shift/unshift\n\nA queue is one of the most common uses of an array. In computer science, this means an ordered collection of elements which supports two operations:\n\npush appends an element to the end.\nshift get an element from the beginning, advancing the queue, so that the 2nd element becomes the 1st.\n\nArrays support both operations.\n\nIn practice we need it very often. For example, a queue of messages that need to be shown on-screen.\n\nThere’s another use case for arrays – the data structure named stack.\n\nIt supports two operations:\n\npush adds an element to the end.\npop takes an element from the end.\n\nSo new elements are added or taken always from the “end”.\n\nA stack is usually illustrated as a pack of cards: new cards are added to the top or taken from the top:\n\nFor stacks, the latest pushed item is received first, that’s also called LIFO (Last-In-First-Out) principle. For queues, we have FIFO (First-In-First-Out).\n\nArrays in JavaScript can work both as a queue and as a stack. They allow you to add/remove elements, both to/from the beginning or the end.\n\nIn computer science, the data structure that allows this, is called deque.\n\nMethods that work with the end of the array:\n\npop\n\nExtracts the last element of the array and returns it:\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Pear\"];\n\nalert( fruits.pop() ); // remove \"Pear\" and alert it\n\nalert( fruits ); // Apple, Orange\n\nBoth fruits.pop() and fruits.at(-1) return the last element of the array, but fruits.pop() also modifies the array by removing it.\n\npush\n\nAppend the element to the end of the array:\n\n\t\nlet fruits = [\"Apple\", \"Orange\"];\n\nfruits.push(\"Pear\");\n\nalert( fruits ); // Apple, Orange, Pear\n\nThe call fruits.push(...) is equal to fruits[fruits.length] = ....\n\nMethods that work with the beginning of the array:\n\nshift\n\nExtracts the first element of the array and returns it:\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Pear\"];\n\nalert( fruits.shift() ); // remove Apple and alert it\n\nalert( fruits ); // Orange, Pear\nunshift\n\nAdd the element to the beginning of the array:\n\n\t\nlet fruits = [\"Orange\", \"Pear\"];\n\nfruits.unshift('Apple');\n\nalert( fruits ); // Apple, Orange, Pear\n\nMethods push and unshift can add multiple elements at once:\n\n\t\nlet fruits = [\"Apple\"];\n\nfruits.push(\"Orange\", \"Peach\");\nfruits.unshift(\"Pineapple\", \"Lemon\");\n\n// [\"Pineapple\", \"Lemon\", \"Apple\", \"Orange\", \"Peach\"]\nalert( fruits );\nInternals\n\nAn array is a special kind of object. The square brackets used to access a property arr[0] actually come from the object syntax. That’s essentially the same as obj[key], where arr is the object, while numbers are used as keys.\n\nThey extend objects providing special methods to work with ordered collections of data and also the length property. But at the core it’s still an object.\n\nRemember, there are only eight basic data types in JavaScript (see the Data types chapter for more info). Array is an object and thus behaves like an object.\n\nFor instance, it is copied by reference:\n\n\t\nlet fruits = [\"Banana\"]\n\nlet arr = fruits; // copy by reference (two variables reference the same array)\n\nalert( arr === fruits ); // true\n\narr.push(\"Pear\"); // modify the array by reference\n\nalert( fruits ); // Banana, Pear - 2 items now\n\n…But what makes arrays really special is their internal representation. The engine tries to store its elements in the contiguous memory area, one after another, just as depicted on the illustrations in this chapter, and there are other optimizations as well, to make arrays work really fast.\n\nBut they all break if we quit working with an array as with an “ordered collection” and start working with it as if it were a regular object.\n\nFor instance, technically we can do this:\n\nlet fruits = []; // make an array\n\nfruits[99999] = 5; // assign a property with the index far greater than its length\n\nfruits.age = 25; // create a property with an arbitrary name\n\nThat’s possible, because arrays are objects at their base. We can add any properties to them.\n\nBut the engine will see that we’re working with the array as with a regular object. Array-specific optimizations are not suited for such cases and will be turned off, their benefits disappear.\n\nThe ways to misuse an array:\n\nAdd a non-numeric property like arr.test = 5.\nMake holes, like: add arr[0] and then arr[1000] (and nothing between them).\nFill the array in the reverse order, like arr[1000], arr[999] and so on.\n\nPlease think of arrays as special structures to work with the ordered data. They provide special methods for that. Arrays are carefully tuned inside JavaScript engines to work with contiguous ordered data, please use them this way. And if you need arbitrary keys, chances are high that you actually require a regular object {}.\n\nPerformance\n\nMethods push/pop run fast, while shift/unshift are slow.\n\nWhy is it faster to work with the end of an array than with its beginning? Let’s see what happens during the execution:\n\nfruits.shift(); // take 1 element from the start\n\nIt’s not enough to take and remove the element with the index 0. Other elements need to be renumbered as well.\n\nThe shift operation must do 3 things:\n\nRemove the element with the index 0.\nMove all elements to the left, renumber them from the index 1 to 0, from 2 to 1 and so on.\nUpdate the length property.\n\nThe more elements in the array, the more time to move them, more in-memory operations.\n\nThe similar thing happens with unshift: to add an element to the beginning of the array, we need first to move existing elements to the right, increasing their indexes.\n\nAnd what’s with push/pop? They do not need to move anything. To extract an element from the end, the pop method cleans the index and shortens length.\n\nThe actions for the pop operation:\n\nfruits.pop(); // take 1 element from the end\n\nThe pop method does not need to move anything, because other elements keep their indexes. That’s why it’s blazingly fast.\n\nThe similar thing with the push method.\n\nLoops\n\nOne of the oldest ways to cycle array items is the for loop over indexes:\n\n\t\nlet arr = [\"Apple\", \"Orange\", \"Pear\"];\n\nfor (let i = 0; i < arr.length; i++) {\n  alert( arr[i] );\n}\n\nBut for arrays there is another form of loop, for..of:\n\n\t\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// iterates over array elements\nfor (let fruit of fruits) {\n  alert( fruit );\n}\n\nThe for..of doesn’t give access to the number of the current element, just its value, but in most cases that’s enough. And it’s shorter.\n\nTechnically, because arrays are objects, it is also possible to use for..in:\n\n\t\nlet arr = [\"Apple\", \"Orange\", \"Pear\"];\n\nfor (let key in arr) {\n  alert( arr[key] ); // Apple, Orange, Pear\n}\n\nBut that’s actually a bad idea. There are potential problems with it:\n\nThe loop for..in iterates over all properties, not only the numeric ones.\n\nThere are so-called “array-like” objects in the browser and in other environments, that look like arrays. That is, they have length and indexes properties, but they may also have other non-numeric properties and methods, which we usually don’t need. The for..in loop will list them though. So if we need to work with array-like objects, then these “extra” properties can become a problem.\n\nThe for..in loop is optimized for generic objects, not arrays, and thus is 10-100 times slower. Of course, it’s still very fast. The speedup may only matter in bottlenecks. But still we should be aware of the difference.\n\nGenerally, we shouldn’t use for..in for arrays.\n\nA word about “length”\n\nThe length property automatically updates when we modify the array. To be precise, it is actually not the count of values in the array, but the greatest numeric index plus one.\n\nFor instance, a single element with a large index gives a big length:\n\n\t\nlet fruits = [];\nfruits[123] = \"Apple\";\n\nalert( fruits.length ); // 124\n\nNote that we usually don’t use arrays like that.\n\nAnother interesting thing about the length property is that it’s writable.\n\nIf we increase it manually, nothing interesting happens. But if we decrease it, the array is truncated. The process is irreversible, here’s the example:\n\n\t\nlet arr = [1, 2, 3, 4, 5];\n\narr.length = 2; // truncate to 2 elements\nalert( arr ); // [1, 2]\n\narr.length = 5; // return length back\nalert( arr[3] ); // undefined: the values do not return\n\nSo, the simplest way to clear the array is: arr.length = 0;.\n\nnew Array()\n\nThere is one more syntax to create an array:\n\nlet arr = new Array(\"Apple\", \"Pear\", \"etc\");\n\nIt’s rarely used, because square brackets [] are shorter. Also, there’s a tricky feature with it.\n\nIf new Array is called with a single argument which is a number, then it creates an array without items, but with the given length.\n\nLet’s see how one can shoot themselves in the foot:\n\n\t\nlet arr = new Array(2); // will it create an array of [2] ?\n\nalert( arr[0] ); // undefined! no elements.\n\nalert( arr.length ); // length 2\n\nTo avoid such surprises, we usually use square brackets, unless we really know what we’re doing.\n\nMultidimensional arrays\n\nArrays can have items that are also arrays. We can use it for multidimensional arrays, for example to store matrices:\n\n\t\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] ); // 5, the central element\ntoString\n\nArrays have their own implementation of toString method that returns a comma-separated list of elements.\n\nFor instance:\n\n\t\nlet arr = [1, 2, 3];\n\nalert( arr ); // 1,2,3\nalert( String(arr) === '1,2,3' ); // true\n\nAlso, let’s try this:\n\n\t\nalert( [] + 1 ); // \"1\"\nalert( [1] + 1 ); // \"11\"\nalert( [1,2] + 1 ); // \"1,21\"\n\nArrays do not have Symbol.toPrimitive, neither a viable valueOf, they implement only toString conversion, so here [] becomes an empty string, [1] becomes \"1\" and [1,2] becomes \"1,2\".\n\nWhen the binary plus \"+\" operator adds something to a string, it converts it to a string as well, so the next step looks like this:\n\n\t\nalert( \"\" + 1 ); // \"1\"\nalert( \"1\" + 1 ); // \"11\"\nalert( \"1,2\" + 1 ); // \"1,21\"\nDon’t compare arrays with ==\n\nArrays in JavaScript, unlike some other programming languages, shouldn’t be compared with operator ==.\n\nThis operator has no special treatment for arrays, it works with them as with any objects.\n\nLet’s recall the rules:\n\nTwo objects are equal == only if they’re references to the same object.\nIf one of the arguments of == is an object, and the other one is a primitive, then the object gets converted to primitive, as explained in the chapter Object to primitive conversion.\n…With an exception of null and undefined that equal == each other and nothing else.\n\nThe strict comparison === is even simpler, as it doesn’t convert types.\n\nSo, if we compare arrays with ==, they are never the same, unless we compare two variables that reference exactly the same array.\n\nFor example:\n\n\t\nalert( [] == [] ); // false\nalert( [0] == [0] ); // false\n\nThese arrays are technically different objects. So they aren’t equal. The == operator doesn’t do item-by-item comparison.\n\nComparison with primitives may give seemingly strange results as well:\n\n\t\nalert( 0 == [] ); // true\n\nalert('0' == [] ); // false\n\nHere, in both cases, we compare a primitive with an array object. So the array [] gets converted to primitive for the purpose of comparison and becomes an empty string ''.\n\nThen the comparison process goes on with the primitives, as described in the chapter Type Conversions:\n\n\t\n// after [] was converted to ''\nalert( 0 == '' ); // true, as '' becomes converted to number 0\n\nalert('0' == '' ); // false, no type conversion, different strings\n\nSo, how to compare arrays?\n\nThat’s simple: don’t use the == operator. Instead, compare them item-by-item in a loop or using iteration methods explained in the next chapter.\n\nSummary\n\nArray is a special kind of object, suited to storing and managing ordered data items.\n\nThe declaration:\n\n// square brackets (usual)\nlet arr = [item1, item2...];\n\n// new Array (exceptionally rare)\nlet arr = new Array(item1, item2...);\n\nThe call to new Array(number) creates an array with the given length, but without elements.\n\nThe length property is the array length or, to be precise, its last numeric index plus one. It is auto-adjusted by array methods.\nIf we shorten length manually, the array is truncated.\n\nGetting the elements:\n\nwe can get element by its index, like arr[0]\nalso we can use at(i) method that allows negative indexes. For negative values of i, it steps back from the end of the array. If i >= 0, it works same as arr[i].\n\nWe can use an array as a deque with the following operations:\n\npush(...items) adds items to the end.\npop() removes the element from the end and returns it.\nshift() removes the element from the beginning and returns it.\nunshift(...items) adds items to the beginning.\n\nTo loop over the elements of the array:\n\nfor (let i=0; i<arr.length; i++) – works fastest, old-browser-compatible.\nfor (let item of arr) – the modern syntax for items only,\nfor (let i in arr) – never use.\n\nTo compare arrays, don’t use the == operator (as well as >, < and others), as they have no special treatment for arrays. They handle them as any objects, and it’s not what we usually want.\n\nInstead you can use for..of loop to compare arrays item-by-item.\n\nWe will continue with arrays and study more methods to add, remove, extract elements and sort arrays in the next chapter Array methods.\n\nTasks\nIs array copied?\nimportance: 3\n\nWhat is this code going to show?\n\nlet fruits = [\"Apples\", \"Pear\", \"Orange\"];\n\n// push a new value into the \"copy\"\nlet shoppingCart = fruits;\nshoppingCart.push(\"Banana\");\n\n// what's in fruits?\nalert( fruits.length ); // ?\nsolution\nArray operations.\nimportance: 5\n\nLet’s try 5 array operations.\n\nCreate an array styles with items “Jazz” and “Blues”.\nAppend “Rock-n-Roll” to the end.\nReplace the value in the middle with “Classics”. Your code for finding the middle value should work for any arrays with odd length.\nStrip off the first value of the array and show it.\nPrepend Rap and Reggae to the array.\n\nThe array in the process:\n\nJazz, Blues\nJazz, Blues, Rock-n-Roll\nJazz, Classics, Rock-n-Roll\nClassics, Rock-n-Roll\nRap, Reggae, Classics, Rock-n-Roll\nsolution\nCalling in an array context\nimportance: 5\n\nWhat is the result? Why?\n\nlet arr = [\"a\", \"b\"];\n\narr.push(function() {\n  alert( this );\n});\n\narr[2](); // ?\nsolution\nSum input numbers\nimportance: 4\n\nWrite the function sumInput() that:\n\nAsks the user for values using prompt and stores the values in the array.\nFinishes asking when the user enters a non-numeric value, an empty string, or presses “Cancel”.\nCalculates and returns the sum of array items.\n\nP.S. A zero 0 is a valid number, please don’t stop the input on zero.\n\nRun the demo\n\nsolution\nA maximal subarray\nimportance: 2\n\nThe input is an array of numbers, e.g. arr = [1, -2, 3, 4, -9, 6].\n\nThe task is: find the contiguous subarray of arr with the maximal sum of items.\n\nWrite the function getMaxSubSum(arr) that will return that sum.\n\nFor instance:\n\ngetMaxSubSum([-1, 2, 3, -9]) == 5 (the sum of highlighted items)\ngetMaxSubSum([2, -1, 2, 3, -9]) == 6\ngetMaxSubSum([-1, 2, 3, -9, 11]) == 11\ngetMaxSubSum([-2, -1, 1, 2]) == 3\ngetMaxSubSum([100, -9, 2, -3, 5]) == 100\ngetMaxSubSum([1, 2, 3]) == 6 (take all)\n\nIf all items are negative, it means that we take none (the subarray is empty), so the sum is zero:\n\ngetMaxSubSum([-1, -2, -3]) = 0\n\nPlease try to think of a fast solution: O(n2) or even O(n) if you can.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Strings",
    "url": "https://javascript.info/string",
    "html": "In JavaScript, the textual data is stored as strings. There is no separate type for a single character.\n\nThe internal format for strings is always UTF-16, it is not tied to the page encoding.\n\nQuotes\n\nLet’s recall the kinds of quotes.\n\nStrings can be enclosed within either single quotes, double quotes or backticks:\n\nlet single = 'single-quoted';\nlet double = \"double-quoted\";\n\nlet backticks = `backticks`;\n\nSingle and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, by wrapping it in ${…}:\n\n\t\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.\n\nAnother advantage of using backticks is that they allow a string to span multiple lines:\n\n\t\nlet guestList = `Guests:\n * John\n * Pete\n * Mary\n`;\n\nalert(guestList); // a list of guests, multiple lines\n\nLooks natural, right? But single or double quotes do not work this way.\n\nIf we use them and try to use multiple lines, there’ll be an error:\n\n\t\nlet guestList = \"Guests: // Error: Unexpected token ILLEGAL\n  * John\";\n\nSingle and double quotes come from ancient times of language creation, when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.\n\nBackticks also allow us to specify a “template function” before the first backtick. The syntax is: func`string`. The function func is called automatically, receives the string and embedded expressions and can process them. This feature is called “tagged templates”, it’s rarely seen, but you can read about it in the MDN: Template literals.\n\nSpecial characters\n\nIt is still possible to create multiline strings with single and double quotes by using a so-called “newline character”, written as \\n, which denotes a line break:\n\n\t\nlet guestList = \"Guests:\\n * John\\n * Pete\\n * Mary\";\n\nalert(guestList); // a multiline list of guests, same as above\n\nAs a simpler example, these two lines are equal, just written differently:\n\n\t\nlet str1 = \"Hello\\nWorld\"; // two lines using a \"newline symbol\"\n\n// two lines using a normal newline and backticks\nlet str2 = `Hello\nWorld`;\n\nalert(str1 == str2); // true\n\nThere are other, less common special characters:\n\nCharacter\tDescription\n\\n\tNew line\n\\r\tIn Windows text files a combination of two characters \\r\\n represents a new break, while on non-Windows OS it’s just \\n. That’s for historical reasons, most Windows software also understands \\n.\n\\', \\\", \\`\tQuotes\n\\\\\tBackslash\n\\t\tTab\n\\b, \\f, \\v\tBackspace, Form Feed, Vertical Tab – mentioned for completeness, coming from old times, not used nowadays (you can forget them right now).\n\nAs you can see, all special characters start with a backslash character \\. It is also called an “escape character”.\n\nBecause it’s so special, if we need to show an actual backslash \\ within the string, we need to double it:\n\n\t\nalert( `The backslash: \\\\` ); // The backslash: \\\n\nSo-called “escaped” quotes \\', \\\", \\` are used to insert a quote into the same-quoted string.\n\nFor instance:\n\n\t\nalert( 'I\\'m the Walrus!' ); // I'm the Walrus!\n\nAs you can see, we have to prepend the inner quote by the backslash \\', because otherwise it would indicate the string end.\n\nOf course, only the quotes that are the same as the enclosing ones need to be escaped. So, as a more elegant solution, we could switch to double quotes or backticks instead:\n\n\t\nalert( \"I'm the Walrus!\" ); // I'm the Walrus!\n\nBesides these special characters, there’s also a special notation for Unicode codes \\u…, it’s rarely used and is covered in the optional chapter about Unicode.\n\nString length\n\nThe length property has the string length:\n\n\t\nalert( `My\\n`.length ); // 3\n\nNote that \\n is a single “special” character, so the length is indeed 3.\n\nlength is a property\n\nPeople with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn’t work.\n\nPlease note that str.length is a numeric property, not a function. There is no need to add parenthesis after it. Not .length(), but .length.\n\nAccessing characters\n\nTo get a character at position pos, use square brackets [pos] or call the method str.at(pos). The first character starts from the zero position:\n\n\t\nlet str = `Hello`;\n\n// the first character\nalert( str[0] ); // H\nalert( str.at(0) ); // H\n\n// the last character\nalert( str[str.length - 1] ); // o\nalert( str.at(-1) );\n\nAs you can see, the .at(pos) method has a benefit of allowing negative position. If pos is negative, then it’s counted from the end of the string.\n\nSo .at(-1) means the last character, and .at(-2) is the one before it, etc.\n\nThe square brackets always return undefined for negative indexes, for instance:\n\n\t\nlet str = `Hello`;\n\nalert( str[-2] ); // undefined\nalert( str.at(-2) ); // l\n\nWe can also iterate over characters using for..of:\n\n\t\nfor (let char of \"Hello\") {\n  alert(char); // H,e,l,l,o (char becomes \"H\", then \"e\", then \"l\" etc)\n}\nStrings are immutable\n\nStrings can’t be changed in JavaScript. It is impossible to change a character.\n\nLet’s try it to show that it doesn’t work:\n\n\t\nlet str = 'Hi';\n\nstr[0] = 'h'; // error\nalert( str[0] ); // doesn't work\n\nThe usual workaround is to create a whole new string and assign it to str instead of the old one.\n\nFor instance:\n\n\t\nlet str = 'Hi';\n\nstr = 'h' + str[1]; // replace the string\n\nalert( str ); // hi\n\nIn the following sections we’ll see more examples of this.\n\nChanging the case\n\nMethods toLowerCase() and toUpperCase() change the case:\n\n\t\nalert( 'Interface'.toUpperCase() ); // INTERFACE\nalert( 'Interface'.toLowerCase() ); // interface\n\nOr, if we want a single character lowercased:\n\n\t\nalert( 'Interface'[0].toLowerCase() ); // 'i'\nSearching for a substring\n\nThere are multiple ways to look for a substring within a string.\n\nstr.indexOf\n\nThe first method is str.indexOf(substr, pos).\n\nIt looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.\n\nFor instance:\n\n\t\nlet str = 'Widget with id';\n\nalert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning\nalert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive\n\nalert( str.indexOf(\"id\") ); // 1, \"id\" is found at the position 1 (..idget with id)\n\nThe optional second parameter allows us to start searching from a given position.\n\nFor instance, the first occurrence of \"id\" is at position 1. To look for the next occurrence, let’s start the search from position 2:\n\n\t\nlet str = 'Widget with id';\n\nalert( str.indexOf('id', 2) ) // 12\n\nIf we’re interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match:\n\n\t\nlet str = 'As sly as a fox, as strong as an ox';\n\nlet target = 'as'; // let's look for it\n\nlet pos = 0;\nwhile (true) {\n  let foundPos = str.indexOf(target, pos);\n  if (foundPos == -1) break;\n\n  alert( `Found at ${foundPos}` );\n  pos = foundPos + 1; // continue the search from the next position\n}\n\nThe same algorithm can be layed out shorter:\n\n\t\nlet str = \"As sly as a fox, as strong as an ox\";\nlet target = \"as\";\n\nlet pos = -1;\nwhile ((pos = str.indexOf(target, pos + 1)) != -1) {\n  alert( pos );\n}\nstr.lastIndexOf(substr, position)\n\nThere is also a similar method str.lastIndexOf(substr, position) that searches from the end of a string to its beginning.\n\nIt would list the occurrences in the reverse order.\n\nThere is a slight inconvenience with indexOf in the if test. We can’t put it in the if like this:\n\n\t\nlet str = \"Widget with id\";\n\nif (str.indexOf(\"Widget\")) {\n    alert(\"We found it\"); // doesn't work!\n}\n\nThe alert in the example above doesn’t show because str.indexOf(\"Widget\") returns 0 (meaning that it found the match at the starting position). Right, but if considers 0 to be false.\n\nSo, we should actually check for -1, like this:\n\n\t\nlet str = \"Widget with id\";\n\nif (str.indexOf(\"Widget\") != -1) {\n    alert(\"We found it\"); // works now!\n}\nincludes, startsWith, endsWith\n\nThe more modern method str.includes(substr, pos) returns true/false depending on whether str contains substr within.\n\nIt’s the right choice if we need to test for the match, but don’t need its position:\n\n\t\nalert( \"Widget with id\".includes(\"Widget\") ); // true\n\nalert( \"Hello\".includes(\"Bye\") ); // false\n\nThe optional second argument of str.includes is the position to start searching from:\n\n\t\nalert( \"Widget\".includes(\"id\") ); // true\nalert( \"Widget\".includes(\"id\", 3) ); // false, from position 3 there is no \"id\"\n\nThe methods str.startsWith and str.endsWith do exactly what they say:\n\n\t\nalert( \"Widget\".startsWith(\"Wid\") ); // true, \"Widget\" starts with \"Wid\"\nalert( \"Widget\".endsWith(\"get\") ); // true, \"Widget\" ends with \"get\"\nGetting a substring\n\nThere are 3 methods in JavaScript to get a substring: substring, substr and slice.\n\nstr.slice(start [, end])\n\nReturns the part of the string from start to (but not including) end.\n\nFor instance:\n\n\t\nlet str = \"stringify\";\nalert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)\nalert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0\n\nIf there is no second argument, then slice goes till the end of the string:\n\n\t\nlet str = \"stringify\";\nalert( str.slice(2) ); // 'ringify', from the 2nd position till the end\n\nNegative values for start/end are also possible. They mean the position is counted from the string end:\n\n\t\nlet str = \"stringify\";\n\n// start at the 4th position from the right, end at the 1st from the right\nalert( str.slice(-4, -1) ); // 'gif'\nstr.substring(start [, end])\n\nReturns the part of the string between start and end (not including end).\n\nThis is almost the same as slice, but it allows start to be greater than end (in this case it simply swaps start and end values).\n\nFor instance:\n\n\t\nlet str = \"stringify\";\n\n// these are same for substring\nalert( str.substring(2, 6) ); // \"ring\"\nalert( str.substring(6, 2) ); // \"ring\"\n\n// ...but not for slice:\nalert( str.slice(2, 6) ); // \"ring\" (the same)\nalert( str.slice(6, 2) ); // \"\" (an empty string)\n\nNegative arguments are (unlike slice) not supported, they are treated as 0.\n\nstr.substr(start [, length])\n\nReturns the part of the string from start, with the given length.\n\nIn contrast with the previous methods, this one allows us to specify the length instead of the ending position:\n\n\t\nlet str = \"stringify\";\nalert( str.substr(2, 4) ); // 'ring', from the 2nd position get 4 characters\n\nThe first argument may be negative, to count from the end:\n\n\t\nlet str = \"stringify\";\nalert( str.substr(-4, 2) ); // 'gi', from the 4th position get 2 characters\n\nThis method resides in the Annex B of the language specification. It means that only browser-hosted Javascript engines should support it, and it’s not recommended to use it. In practice, it’s supported everywhere.\n\nLet’s recap these methods to avoid any confusion:\n\nmethod\tselects…\tnegatives\nslice(start, end)\tfrom start to end (not including end)\tallows negatives\nsubstring(start, end)\tbetween start and end (not including end)\tnegative values mean 0\nsubstr(start, length)\tfrom start get length characters\tallows negative start\nWhich one to choose?\n\nAll of them can do the job. Formally, substr has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.\n\nOf the other two variants, slice is a little bit more flexible, it allows negative arguments and shorter to write.\n\nSo, for practical use it’s enough to remember only slice.\n\nComparing strings\n\nAs we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order.\n\nAlthough, there are some oddities.\n\nA lowercase letter is always greater than the uppercase:\n\n\t\nalert( 'a' > 'Z' ); // true\n\nLetters with diacritical marks are “out of order”:\n\n\t\nalert( 'Österreich' > 'Zealand' ); // true\n\nThis may lead to strange results if we sort these country names. Usually people would expect Zealand to come after Österreich in the list.\n\nTo understand what happens, we should be aware that strings in Javascript are encoded using UTF-16. That is: each character has a corresponding numeric code.\n\nThere are special methods that allow to get the character for the code and back:\n\nstr.codePointAt(pos)\n\nReturns a decimal number representing the code for the character at position pos:\n\n\t\n// different case letters have different codes\nalert( \"Z\".codePointAt(0) ); // 90\nalert( \"z\".codePointAt(0) ); // 122\nalert( \"z\".codePointAt(0).toString(16) ); // 7a (if we need a hexadecimal value)\nString.fromCodePoint(code)\n\nCreates a character by its numeric code\n\n\t\nalert( String.fromCodePoint(90) ); // Z\nalert( String.fromCodePoint(0x5a) ); // Z (we can also use a hex value as an argument)\n\nNow let’s see the characters with codes 65..220 (the latin alphabet and a little bit extra) by making a string of them:\n\n\t\nlet str = '';\n\nfor (let i = 65; i <= 220; i++) {\n  str += String.fromCodePoint(i);\n}\nalert( str );\n// Output:\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\n// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ\n\nSee? Capital characters go first, then a few special ones, then lowercase characters, and Ö near the end of the output.\n\nNow it becomes obvious why a > Z.\n\nThe characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).\n\nAll lowercase letters go after uppercase letters because their codes are greater.\nSome letters like Ö stand apart from the main alphabet. Here, its code is greater than anything from a to z.\nCorrect comparisons\n\nThe “right” algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages.\n\nSo, the browser needs to know the language to compare.\n\nLuckily, modern browsers support the internationalization standard ECMA-402.\n\nIt provides a special method to compare strings in different languages, following their rules.\n\nThe call str.localeCompare(str2) returns an integer indicating whether str is less, equal or greater than str2 according to the language rules:\n\nReturns a negative number if str is less than str2.\nReturns a positive number if str is greater than str2.\nReturns 0 if they are equivalent.\n\nFor instance:\n\n\t\nalert( 'Österreich'.localeCompare('Zealand') ); // -1\n\nThis method actually has two additional arguments specified in the documentation, which allows it to specify the language (by default taken from the environment, letter order depends on the language) and setup additional rules like case sensitivity or should \"a\" and \"á\" be treated as the same etc.\n\nSummary\nThere are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions ${…}.\nWe can use special characters, such as a line break \\n.\nTo get a character, use: [] or at method.\nTo get a substring, use: slice or substring.\nTo lowercase/uppercase a string, use: toLowerCase/toUpperCase.\nTo look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks.\nTo compare strings according to the language, use: localeCompare, otherwise they are compared by character codes.\n\nThere are several other helpful methods in strings:\n\nstr.trim() – removes (“trims”) spaces from the beginning and end of the string.\nstr.repeat(n) – repeats the string n times.\n…and more to be found in the manual.\n\nStrings also have methods for doing search/replace with regular expressions. But that’s big topic, so it’s explained in a separate tutorial section Regular expressions.\n\nAlso, as of now it’s important to know that strings are based on Unicode encoding, and hence there’re issues with comparisons. There’s more about Unicode in the chapter Unicode, String internals.\n\nTasks\nUppercase the first character\nimportance: 5\n\nWrite a function ucFirst(str) that returns the string str with the uppercased first character, for instance:\n\nucFirst(\"john\") == \"John\";\n\nOpen a sandbox with tests.\n\nsolution\nCheck for spam\nimportance: 5\n\nWrite a function checkSpam(str) that returns true if str contains ‘viagra’ or ‘XXX’, otherwise false.\n\nThe function must be case-insensitive:\n\ncheckSpam('buy ViAgRA now') == true\ncheckSpam('free xxxxx') == true\ncheckSpam(\"innocent rabbit\") == false\n\nOpen a sandbox with tests.\n\nsolution\nTruncate the text\nimportance: 5\n\nCreate a function truncate(str, maxlength) that checks the length of the str and, if it exceeds maxlength – replaces the end of str with the ellipsis character \"…\", to make its length equal to maxlength.\n\nThe result of the function should be the truncated (if needed) string.\n\nFor instance:\n\ntruncate(\"What I'd like to tell on this topic is:\", 20) = \"What I'd like to te…\"\n\ntruncate(\"Hi everyone!\", 20) = \"Hi everyone!\"\n\nOpen a sandbox with tests.\n\nsolution\nExtract the money\nimportance: 4\n\nWe have a cost in the form \"$120\". That is: the dollar sign goes first, and then the number.\n\nCreate a function extractCurrencyValue(str) that would extract the numeric value from such string and return it.\n\nThe example:\n\nalert( extractCurrencyValue('$120') === 120 ); // true\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Numbers",
    "url": "https://javascript.info/number",
    "html": "In modern JavaScript, there are two types of numbers:\n\nRegular numbers in JavaScript are stored in 64-bit format IEEE-754, also known as “double precision floating point numbers”. These are numbers that we’re using most of the time, and we’ll talk about them in this chapter.\n\nBigInt numbers represent integers of arbitrary length. They are sometimes needed because a regular integer number can’t safely exceed (253-1) or be less than -(253-1), as we mentioned earlier in the chapter Data types. As bigints are used in few special areas, we devote them a special chapter BigInt.\n\nSo here we’ll talk about regular numbers. Let’s expand our knowledge of them.\n\nMore ways to write a number\n\nImagine we need to write 1 billion. The obvious way is:\n\nlet billion = 1000000000;\n\nWe also can use underscore _ as the separator:\n\nlet billion = 1_000_000_000;\n\nHere the underscore _ plays the role of the “syntactic sugar”, it makes the number more readable. The JavaScript engine simply ignores _ between digits, so it’s exactly the same one billion as above.\n\nIn real life though, we try to avoid writing long sequences of zeroes. We’re too lazy for that. We’ll try to write something like \"1bn\" for a billion or \"7.3bn\" for 7 billion 300 million. The same is true for most large numbers.\n\nIn JavaScript, we can shorten a number by appending the letter \"e\" to it and specifying the zeroes count:\n\n\t\nlet billion = 1e9;  // 1 billion, literally: 1 and 9 zeroes\n\nalert( 7.3e9 );  // 7.3 billions (same as 7300000000 or 7_300_000_000)\n\nIn other words, e multiplies the number by 1 with the given zeroes count.\n\n1e3 === 1 * 1000; // e3 means *1000\n1.23e6 === 1.23 * 1000000; // e6 means *1000000\n\nNow let’s write something very small. Say, 1 microsecond (one millionth of a second):\n\nlet mсs = 0.000001;\n\nJust like before, using \"e\" can help. If we’d like to avoid writing the zeroes explicitly, we could write the same as:\n\nlet mcs = 1e-6; // five zeroes to the left from 1\n\nIf we count the zeroes in 0.000001, there are 6 of them. So naturally it’s 1e-6.\n\nIn other words, a negative number after \"e\" means a division by 1 with the given number of zeroes:\n\n// -3 divides by 1 with 3 zeroes\n1e-3 === 1 / 1000; // 0.001\n\n// -6 divides by 1 with 6 zeroes\n1.23e-6 === 1.23 / 1000000; // 0.00000123\n\n// an example with a bigger number\n1234e-2 === 1234 / 100; // 12.34, decimal point moves 2 times\nHex, binary and octal numbers\n\nHexadecimal numbers are widely used in JavaScript to represent colors, encode characters, and for many other things. So naturally, there exists a shorter way to write them: 0x and then the number.\n\nFor instance:\n\n\t\nalert( 0xff ); // 255\nalert( 0xFF ); // 255 (the same, case doesn't matter)\n\nBinary and octal numeral systems are rarely used, but also supported using the 0b and 0o prefixes:\n\n\t\nlet a = 0b11111111; // binary form of 255\nlet b = 0o377; // octal form of 255\n\nalert( a == b ); // true, the same number 255 at both sides\n\nThere are only 3 numeral systems with such support. For other numeral systems, we should use the function parseInt (which we will see later in this chapter).\n\ntoString(base)\n\nThe method num.toString(base) returns a string representation of num in the numeral system with the given base.\n\nFor example:\n\n\t\nlet num = 255;\n\nalert( num.toString(16) );  // ff\nalert( num.toString(2) );   // 11111111\n\nThe base can vary from 2 to 36. By default it’s 10.\n\nCommon use cases for this are:\n\nbase=16 is used for hex colors, character encodings etc, digits can be 0..9 or A..F.\n\nbase=2 is mostly for debugging bitwise operations, digits can be 0 or 1.\n\nbase=36 is the maximum, digits can be 0..9 or A..Z. The whole latin alphabet is used to represent a number. A funny, but useful case for 36 is when we need to turn a long numeric identifier into something shorter, for example to make a short url. Can simply represent it in the numeral system with base 36:\n\n\t\nalert( 123456..toString(36) ); // 2n9c\nTwo dots to call a method\n\nPlease note that two dots in 123456..toString(36) is not a typo. If we want to call a method directly on a number, like toString in the example above, then we need to place two dots .. after it.\n\nIf we placed a single dot: 123456.toString(36), then there would be an error, because JavaScript syntax implies the decimal part after the first dot. And if we place one more dot, then JavaScript knows that the decimal part is empty and now goes the method.\n\nAlso could write (123456).toString(36).\n\nRounding\n\nOne of the most used operations when working with numbers is rounding.\n\nThere are several built-in functions for rounding:\n\nMath.floor\nRounds down: 3.1 becomes 3, and -1.1 becomes -2.\nMath.ceil\nRounds up: 3.1 becomes 4, and -1.1 becomes -1.\nMath.round\nRounds to the nearest integer: 3.1 becomes 3, 3.6 becomes 4, the middle case: 3.5 rounds up to 4 too.\nMath.trunc (not supported by Internet Explorer)\nRemoves anything after the decimal point without rounding: 3.1 becomes 3, -1.1 becomes -1.\n\nHere’s the table to summarize the differences between them:\n\n\tMath.floor\tMath.ceil\tMath.round\tMath.trunc\n3.1\t3\t4\t3\t3\n3.6\t3\t4\t4\t3\n-1.1\t-2\t-1\t-1\t-1\n-1.6\t-2\t-1\t-2\t-1\n\nThese functions cover all of the possible ways to deal with the decimal part of a number. But what if we’d like to round the number to n-th digit after the decimal?\n\nFor instance, we have 1.2345 and want to round it to 2 digits, getting only 1.23.\n\nThere are two ways to do so:\n\nMultiply-and-divide.\n\nFor example, to round the number to the 2nd digit after the decimal, we can multiply the number by 100, call the rounding function and then divide it back.\n\n\t\nlet num = 1.23456;\n\nalert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23\n\nThe method toFixed(n) rounds the number to n digits after the point and returns a string representation of the result.\n\n\t\nlet num = 12.34;\nalert( num.toFixed(1) ); // \"12.3\"\n\nThis rounds up or down to the nearest value, similar to Math.round:\n\n\t\nlet num = 12.36;\nalert( num.toFixed(1) ); // \"12.4\"\n\nPlease note that the result of toFixed is a string. If the decimal part is shorter than required, zeroes are appended to the end:\n\n\t\nlet num = 12.34;\nalert( num.toFixed(5) ); // \"12.34000\", added zeroes to make exactly 5 digits\n\nWe can convert it to a number using the unary plus or a Number() call, e.g write +num.toFixed(5).\n\nImprecise calculations\n\nInternally, a number is represented in 64-bit format IEEE-754, so there are exactly 64 bits to store a number: 52 of them are used to store the digits, 11 of them store the position of the decimal point, and 1 bit is for the sign.\n\nIf a number is really huge, it may overflow the 64-bit storage and become a special numeric value Infinity:\n\n\t\nalert( 1e500 ); // Infinity\n\nWhat may be a little less obvious, but happens quite often, is the loss of precision.\n\nConsider this (falsy!) equality test:\n\n\t\nalert( 0.1 + 0.2 == 0.3 ); // false\n\nThat’s right, if we check whether the sum of 0.1 and 0.2 is 0.3, we get false.\n\nStrange! What is it then if not 0.3?\n\n\t\nalert( 0.1 + 0.2 ); // 0.30000000000000004\n\nOuch! Imagine you’re making an e-shopping site and the visitor puts $0.10 and $0.20 goods into their cart. The order total will be $0.30000000000000004. That would surprise anyone.\n\nBut why does this happen?\n\nA number is stored in memory in its binary form, a sequence of bits – ones and zeroes. But fractions like 0.1, 0.2 that look simple in the decimal numeric system are actually unending fractions in their binary form.\n\nWhat is 0.1? It is one divided by ten 1/10, one-tenth. In decimal numeral system such numbers are easily representable. Compare it to one-third: 1/3. It becomes an endless fraction 0.33333(3).\n\nSo, division by powers 10 is guaranteed to work well in the decimal system, but division by 3 is not. For the same reason, in the binary numeral system, the division by powers of 2 is guaranteed to work, but 1/10 becomes an endless binary fraction.\n\nThere’s just no way to store exactly 0.1 or exactly 0.2 using the binary system, just like there is no way to store one-third as a decimal fraction.\n\nThe numeric format IEEE-754 solves this by rounding to the nearest possible number. These rounding rules normally don’t allow us to see that “tiny precision loss”, but it exists.\n\nWe can see this in action:\n\n\t\nalert( 0.1.toFixed(20) ); // 0.10000000000000000555\n\nAnd when we sum two numbers, their “precision losses” add up.\n\nThat’s why 0.1 + 0.2 is not exactly 0.3.\n\nNot only JavaScript\n\nThe same issue exists in many other programming languages.\n\nPHP, Java, C, Perl, Ruby give exactly the same result, because they are based on the same numeric format.\n\nCan we work around the problem? Sure, the most reliable method is to round the result with the help of a method toFixed(n):\n\n\t\nlet sum = 0.1 + 0.2;\nalert( sum.toFixed(2) ); // \"0.30\"\n\nPlease note that toFixed always returns a string. It ensures that it has 2 digits after the decimal point. That’s actually convenient if we have an e-shopping and need to show $0.30. For other cases, we can use the unary plus to coerce it into a number:\n\n\t\nlet sum = 0.1 + 0.2;\nalert( +sum.toFixed(2) ); // 0.3\n\nWe also can temporarily multiply the numbers by 100 (or a bigger number) to turn them into integers, do the maths, and then divide back. Then, as we’re doing maths with integers, the error somewhat decreases, but we still get it on division:\n\n\t\nalert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3\nalert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001\n\nSo, multiply/divide approach reduces the error, but doesn’t remove it totally.\n\nSometimes we could try to evade fractions at all. Like if we’re dealing with a shop, then we can store prices in cents instead of dollars. But what if we apply a discount of 30%? In practice, totally evading fractions is rarely possible. Just round them to cut “tails” when needed.\n\nThe funny thing\n\nTry running this:\n\n\t\n// Hello! I'm a self-increasing number!\nalert( 9999999999999999 ); // shows 10000000000000000\n\nThis suffers from the same issue: a loss of precision. There are 64 bits for the number, 52 of them can be used to store digits, but that’s not enough. So the least significant digits disappear.\n\nJavaScript doesn’t trigger an error in such events. It does its best to fit the number into the desired format, but unfortunately, this format is not big enough.\n\nTwo zeroes\n\nAnother funny consequence of the internal representation of numbers is the existence of two zeroes: 0 and -0.\n\nThat’s because a sign is represented by a single bit, so it can be set or not set for any number including a zero.\n\nIn most cases the distinction is unnoticeable, because operators are suited to treat them as the same.\n\nTests: isFinite and isNaN\n\nRemember these two special numeric values?\n\nInfinity (and -Infinity) is a special numeric value that is greater (less) than anything.\nNaN represents an error.\n\nThey belong to the type number, but are not “normal” numbers, so there are special functions to check for them:\n\nisNaN(value) converts its argument to a number and then tests it for being NaN:\n\n\t\nalert( isNaN(NaN) ); // true\nalert( isNaN(\"str\") ); // true\n\nBut do we need this function? Can’t we just use the comparison === NaN? Unfortunately not. The value NaN is unique in that it does not equal anything, including itself:\n\n\t\nalert( NaN === NaN ); // false\n\nisFinite(value) converts its argument to a number and returns true if it’s a regular number, not NaN/Infinity/-Infinity:\n\n\t\nalert( isFinite(\"15\") ); // true\nalert( isFinite(\"str\") ); // false, because a special value: NaN\nalert( isFinite(Infinity) ); // false, because a special value: Infinity\n\nSometimes isFinite is used to validate whether a string value is a regular number:\n\n\t\nlet num = +prompt(\"Enter a number\", '');\n\n// will be true unless you enter Infinity, -Infinity or not a number\nalert( isFinite(num) );\n\nPlease note that an empty or a space-only string is treated as 0 in all numeric functions including isFinite.\n\nNumber.isNaN and Number.isFinite\n\nNumber.isNaN and Number.isFinite methods are the more “strict” versions of isNaN and isFinite functions. They do not autoconvert their argument into a number, but check if it belongs to the number type instead.\n\nNumber.isNaN(value) returns true if the argument belongs to the number type and it is NaN. In any other case it returns false.\n\n\t\nalert( Number.isNaN(NaN) ); // true\nalert( Number.isNaN(\"str\" / 2) ); // true\n\n// Note the difference:\nalert( Number.isNaN(\"str\") ); // false, because \"str\" belongs to the string type, not the number type\nalert( isNaN(\"str\") ); // true, because isNaN converts string \"str\" into a number and gets NaN as a result of this conversion\n\nNumber.isFinite(value) returns true if the argument belongs to the number type and it is not NaN/Infinity/-Infinity. In any other case it returns false.\n\n\t\nalert( Number.isFinite(123) ); // true\nalert( Number.isFinite(Infinity) ); // false\nalert( Number.isFinite(2 / 0) ); // false\n\n// Note the difference:\nalert( Number.isFinite(\"123\") ); // false, because \"123\" belongs to the string type, not the number type\nalert( isFinite(\"123\") ); // true, because isFinite converts string \"123\" into a number 123\n\nIn a way, Number.isNaN and Number.isFinite are simpler and more straightforward than isNaN and isFinite functions. In practice though, isNaN and isFinite are mostly used, as they’re shorter to write.\n\nComparison with Object.is\n\nThere is a special built-in method Object.is that compares values like ===, but is more reliable for two edge cases:\n\nIt works with NaN: Object.is(NaN, NaN) === true, that’s a good thing.\nValues 0 and -0 are different: Object.is(0, -0) === false, technically that’s correct, because internally the number has a sign bit that may be different even if all other bits are zeroes.\n\nIn all other cases, Object.is(a, b) is the same as a === b.\n\nWe mention Object.is here, because it’s often used in JavaScript specification. When an internal algorithm needs to compare two values for being exactly the same, it uses Object.is (internally called SameValue).\n\nparseInt and parseFloat\n\nNumeric conversion using a plus + or Number() is strict. If a value is not exactly a number, it fails:\n\n\t\nalert( +\"100px\" ); // NaN\n\nThe sole exception is spaces at the beginning or at the end of the string, as they are ignored.\n\nBut in real life we often have values in units, like \"100px\" or \"12pt\" in CSS. Also in many countries the currency symbol goes after the amount, so we have \"19€\" and would like to extract a numeric value out of that.\n\nThat’s what parseInt and parseFloat are for.\n\nThey “read” a number from a string until they can’t. In case of an error, the gathered number is returned. The function parseInt returns an integer, whilst parseFloat will return a floating-point number:\n\n\t\nalert( parseInt('100px') ); // 100\nalert( parseFloat('12.5em') ); // 12.5\n\nalert( parseInt('12.3') ); // 12, only the integer part is returned\nalert( parseFloat('12.3.4') ); // 12.3, the second point stops the reading\n\nThere are situations when parseInt/parseFloat will return NaN. It happens when no digits could be read:\n\n\t\nalert( parseInt('a123') ); // NaN, the first symbol stops the process\nThe second argument of parseInt(str, radix)\n\nThe parseInt() function has an optional second parameter. It specifies the base of the numeral system, so parseInt can also parse strings of hex numbers, binary numbers and so on:\n\n\t\nalert( parseInt('0xff', 16) ); // 255\nalert( parseInt('ff', 16) ); // 255, without 0x also works\n\nalert( parseInt('2n9c', 36) ); // 123456\nOther math functions\n\nJavaScript has a built-in Math object which contains a small library of mathematical functions and constants.\n\nA few examples:\n\nMath.random()\n\nReturns a random number from 0 to 1 (not including 1).\n\n\t\nalert( Math.random() ); // 0.1234567894322\nalert( Math.random() ); // 0.5435252343232\nalert( Math.random() ); // ... (any random numbers)\nMath.max(a, b, c...) and Math.min(a, b, c...)\n\nReturns the greatest and smallest from the arbitrary number of arguments.\n\n\t\nalert( Math.max(3, 5, -10, 0, 1) ); // 5\nalert( Math.min(1, 2) ); // 1\nMath.pow(n, power)\n\nReturns n raised to the given power.\n\n\t\nalert( Math.pow(2, 10) ); // 2 in power 10 = 1024\n\nThere are more functions and constants in Math object, including trigonometry, which you can find in the docs for the Math object.\n\nSummary\n\nTo write numbers with many zeroes:\n\nAppend \"e\" with the zeroes count to the number. Like: 123e6 is the same as 123 with 6 zeroes 123000000.\nA negative number after \"e\" causes the number to be divided by 1 with given zeroes. E.g. 123e-6 means 0.000123 (123 millionths).\n\nFor different numeral systems:\n\nCan write numbers directly in hex (0x), octal (0o) and binary (0b) systems.\nparseInt(str, base) parses the string str into an integer in numeral system with given base, 2 ≤ base ≤ 36.\nnum.toString(base) converts a number to a string in the numeral system with the given base.\n\nFor regular number tests:\n\nisNaN(value) converts its argument to a number and then tests it for being NaN\nNumber.isNaN(value) checks whether its argument belongs to the number type, and if so, tests it for being NaN\nisFinite(value) converts its argument to a number and then tests it for not being NaN/Infinity/-Infinity\nNumber.isFinite(value) checks whether its argument belongs to the number type, and if so, tests it for not being NaN/Infinity/-Infinity\n\nFor converting values like 12pt and 100px to a number:\n\nUse parseInt/parseFloat for the “soft” conversion, which reads a number from a string and then returns the value they could read before the error.\n\nFor fractions:\n\nRound using Math.floor, Math.ceil, Math.trunc, Math.round or num.toFixed(precision).\nMake sure to remember there’s a loss of precision when working with fractions.\n\nMore mathematical functions:\n\nSee the Math object when you need them. The library is very small, but can cover basic needs.\nTasks\nSum numbers from the visitor\nimportance: 5\n\nCreate a script that prompts the visitor to enter two numbers and then shows their sum.\n\nRun the demo\n\nP.S. There is a gotcha with types.\n\nsolution\nWhy 6.35.toFixed(1) == 6.3?\nimportance: 4\n\nAccording to the documentation Math.round and toFixed both round to the nearest number: 0..4 lead down while 5..9 lead up.\n\nFor instance:\n\n\t\nalert( 1.35.toFixed(1) ); // 1.4\n\nIn the similar example below, why is 6.35 rounded to 6.3, not 6.4?\n\n\t\nalert( 6.35.toFixed(1) ); // 6.3\n\nHow to round 6.35 the right way?\n\nsolution\nRepeat until the input is a number\nimportance: 5\n\nCreate a function readNumber which prompts for a number until the visitor enters a valid numeric value.\n\nThe resulting value must be returned as a number.\n\nThe visitor can also stop the process by entering an empty line or pressing “CANCEL”. In that case, the function should return null.\n\nRun the demo\n\nOpen a sandbox with tests.\n\nsolution\nAn occasional infinite loop\nimportance: 4\n\nThis loop is infinite. It never ends. Why?\n\nlet i = 0;\nwhile (i != 10) {\n  i += 0.2;\n}\nsolution\nA random number from min to max\nimportance: 2\n\nThe built-in function Math.random() creates a random value from 0 to 1 (not including 1).\n\nWrite the function random(min, max) to generate a random floating-point number from min to max (not including max).\n\nExamples of its work:\n\nalert( random(1, 5) ); // 1.2345623452\nalert( random(1, 5) ); // 3.7894332423\nalert( random(1, 5) ); // 4.3435234525\nsolution\nA random integer from min to max\nimportance: 2\n\nCreate a function randomInteger(min, max) that generates a random integer number from min to max including both min and max as possible values.\n\nAny number from the interval min..max must appear with the same probability.\n\nExamples of its work:\n\nalert( randomInteger(1, 5) ); // 1\nalert( randomInteger(1, 5) ); // 3\nalert( randomInteger(1, 5) ); // 5\n\nYou can use the solution of the previous task as the base.\n\nsolution"
  },
  {
    "title": "Methods of primitives",
    "url": "https://javascript.info/primitives-methods",
    "html": "JavaScript allows us to work with primitives (strings, numbers, etc.) as if they were objects. They also provide methods to call as such. We will study those soon, but first we’ll see how it works because, of course, primitives are not objects (and here we will make it even clearer).\n\nLet’s look at the key distinctions between primitives and objects.\n\nA primitive\n\nIs a value of a primitive type.\nThere are 7 primitive types: string, number, bigint, boolean, symbol, null and undefined.\n\nAn object\n\nIs capable of storing multiple values as properties.\nCan be created with {}, for instance: {name: \"John\", age: 30}. There are other kinds of objects in JavaScript: functions, for example, are objects.\n\nOne of the best things about objects is that we can store a function as one of its properties.\n\n\t\nlet john = {\n  name: \"John\",\n  sayHi: function() {\n    alert(\"Hi buddy!\");\n  }\n};\n\njohn.sayHi(); // Hi buddy!\n\nSo here we’ve made an object john with the method sayHi.\n\nMany built-in objects already exist, such as those that work with dates, errors, HTML elements, etc. They have different properties and methods.\n\nBut, these features come with a cost!\n\nObjects are “heavier” than primitives. They require additional resources to support the internal machinery.\n\nA primitive as an object\n\nHere’s the paradox faced by the creator of JavaScript:\n\nThere are many things one would want to do with a primitive, like a string or a number. It would be great to access them using methods.\nPrimitives must be as fast and lightweight as possible.\n\nThe solution looks a little bit awkward, but here it is:\n\nPrimitives are still primitive. A single value, as desired.\nThe language allows access to methods and properties of strings, numbers, booleans and symbols.\nIn order for that to work, a special “object wrapper” that provides the extra functionality is created, and then is destroyed.\n\nThe “object wrappers” are different for each primitive type and are called: String, Number, Boolean, Symbol and BigInt. Thus, they provide different sets of methods.\n\nFor instance, there exists a string method str.toUpperCase() that returns a capitalized str.\n\nHere’s how it works:\n\n\t\nlet str = \"Hello\";\n\nalert( str.toUpperCase() ); // HELLO\n\nSimple, right? Here’s what actually happens in str.toUpperCase():\n\nThe string str is a primitive. So in the moment of accessing its property, a special object is created that knows the value of the string, and has useful methods, like toUpperCase().\nThat method runs and returns a new string (shown by alert).\nThe special object is destroyed, leaving the primitive str alone.\n\nSo primitives can provide methods, but they still remain lightweight.\n\nThe JavaScript engine highly optimizes this process. It may even skip the creation of the extra object at all. But it must still adhere to the specification and behave as if it creates one.\n\nA number has methods of its own, for instance, toFixed(n) rounds the number to the given precision:\n\n\t\nlet n = 1.23456;\n\nalert( n.toFixed(2) ); // 1.23\n\nWe’ll see more specific methods in chapters Numbers and Strings.\n\nConstructors String/Number/Boolean are for internal use only\n\nSome languages like Java allow us to explicitly create “wrapper objects” for primitives using a syntax like new Number(1) or new Boolean(false).\n\nIn JavaScript, that’s also possible for historical reasons, but highly unrecommended. Things will go crazy in several places.\n\nFor instance:\n\n\t\nalert( typeof 0 ); // \"number\"\n\nalert( typeof new Number(0) ); // \"object\"!\n\nObjects are always truthy in if, so here the alert will show up:\n\n\t\nlet zero = new Number(0);\n\nif (zero) { // zero is true, because it's an object\n  alert( \"zero is truthy!?!\" );\n}\n\nOn the other hand, using the same functions String/Number/Boolean without new is totally fine and useful thing. They convert a value to the corresponding type: to a string, a number, or a boolean (primitive).\n\nFor example, this is entirely valid:\n\nlet num = Number(\"123\"); // convert a string to number\nnull/undefined have no methods\n\nThe special primitives null and undefined are exceptions. They have no corresponding “wrapper objects” and provide no methods. In a sense, they are “the most primitive”.\n\nAn attempt to access a property of such value would give the error:\n\n\t\nalert(null.test); // error\nSummary\nPrimitives except null and undefined provide many helpful methods. We will study those in the upcoming chapters.\nFormally, these methods work via temporary objects, but JavaScript engines are well tuned to optimize that internally, so they are not expensive to call.\nTasks\nCan I add a string property?\nimportance: 5\n\nConsider the following code:\n\nlet str = \"Hello\";\n\nstr.test = 5;\n\nalert(str.test);\n\nWhat do you think, will it work? What will be shown?\n\nsolution"
  },
  {
    "title": "Data types",
    "url": "https://javascript.info/data-types",
    "html": "More data structures and more in-depth study of the types.\n\nMethods of primitives\nNumbers\nStrings\nArrays\nArray methods\nIterables\nMap and Set\nWeakMap and WeakSet\nObject.keys, values, entries\nDestructuring assignment\nDate and time\nJSON methods, toJSON"
  },
  {
    "title": "Object to primitive conversion",
    "url": "https://javascript.info/object-toprimitive",
    "html": "What happens when objects are added obj1 + obj2, subtracted obj1 - obj2 or printed using alert(obj)?\n\nJavaScript doesn’t allow you to customize how operators work on objects. Unlike some other programming languages, such as Ruby or C++, we can’t implement a special object method to handle addition (or other operators).\n\nIn case of such operations, objects are auto-converted to primitives, and then the operation is carried out over these primitives and results in a primitive value.\n\nThat’s an important limitation: the result of obj1 + obj2 (or another math operation) can’t be another object!\n\nE.g. we can’t make objects representing vectors or matrices (or achievements or whatever), add them and expect a “summed” object as the result. Such architectural feats are automatically “off the board”.\n\nSo, because we can’t technically do much here, there’s no maths with objects in real projects. When it happens, with rare exceptions, it’s because of a coding mistake.\n\nIn this chapter we’ll cover how an object converts to primitive and how to customize it.\n\nWe have two purposes:\n\nIt will allow us to understand what’s going on in case of coding mistakes, when such an operation happened accidentally.\nThere are exceptions, where such operations are possible and look good. E.g. subtracting or comparing dates (Date objects). We’ll come across them later.\nConversion rules\n\nIn the chapter Type Conversions we’ve seen the rules for numeric, string and boolean conversions of primitives. But we left a gap for objects. Now, as we know about methods and symbols it becomes possible to fill it.\n\nThere’s no conversion to boolean. All objects are true in a boolean context, as simple as that. There exist only numeric and string conversions.\nThe numeric conversion happens when we subtract objects or apply mathematical functions. For instance, Date objects (to be covered in the chapter Date and time) can be subtracted, and the result of date1 - date2 is the time difference between two dates.\nAs for the string conversion – it usually happens when we output an object with alert(obj) and in similar contexts.\n\nWe can implement string and numeric conversion by ourselves, using special object methods.\n\nNow let’s get into technical details, because it’s the only way to cover the topic in-depth.\n\nHints\n\nHow does JavaScript decide which conversion to apply?\n\nThere are three variants of type conversion, that happen in various situations. They’re called “hints”, as described in the specification:\n\n\"string\"\n\nFor an object-to-string conversion, when we’re doing an operation on an object that expects a string, like alert:\n\n// output\nalert(obj);\n\n// using object as a property key\nanotherObj[obj] = 123;\n\"number\"\n\nFor an object-to-number conversion, like when we’re doing maths:\n\n// explicit conversion\nlet num = Number(obj);\n\n// maths (except binary plus)\nlet n = +obj; // unary plus\nlet delta = date1 - date2;\n\n// less/greater comparison\nlet greater = user1 > user2;\n\nMost built-in mathematical functions also include such conversion.\n\n\"default\"\n\nOccurs in rare cases when the operator is “not sure” what type to expect.\n\nFor instance, binary plus + can work both with strings (concatenates them) and numbers (adds them). So if a binary plus gets an object as an argument, it uses the \"default\" hint to convert it.\n\nAlso, if an object is compared using == with a string, number or a symbol, it’s also unclear which conversion should be done, so the \"default\" hint is used.\n\n// binary plus uses the \"default\" hint\nlet total = obj1 + obj2;\n\n// obj == number uses the \"default\" hint\nif (user == 1) { ... };\n\nThe greater and less comparison operators, such as < >, can work with both strings and numbers too. Still, they use the \"number\" hint, not \"default\". That’s for historical reasons.\n\nIn practice though, things are a bit simpler.\n\nAll built-in objects except for one case (Date object, we’ll learn it later) implement \"default\" conversion the same way as \"number\". And we probably should do the same.\n\nStill, it’s important to know about all 3 hints, soon we’ll see why.\n\nTo do the conversion, JavaScript tries to find and call three object methods:\n\nCall obj[Symbol.toPrimitive](hint) – the method with the symbolic key Symbol.toPrimitive (system symbol), if such method exists,\nOtherwise if hint is \"string\"\ntry calling obj.toString() or obj.valueOf(), whatever exists.\nOtherwise if hint is \"number\" or \"default\"\ntry calling obj.valueOf() or obj.toString(), whatever exists.\nSymbol.toPrimitive\n\nLet’s start from the first method. There’s a built-in symbol named Symbol.toPrimitive that should be used to name the conversion method, like this:\n\nobj[Symbol.toPrimitive] = function(hint) {\n  // here goes the code to convert this object to a primitive\n  // it must return a primitive value\n  // hint = one of \"string\", \"number\", \"default\"\n};\n\nIf the method Symbol.toPrimitive exists, it’s used for all hints, and no more methods are needed.\n\nFor instance, here user object implements it:\n\n\t\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  [Symbol.toPrimitive](hint) {\n    alert(`hint: ${hint}`);\n    return hint == \"string\" ? `{name: \"${this.name}\"}` : this.money;\n  }\n};\n\n// conversions demo:\nalert(user); // hint: string -> {name: \"John\"}\nalert(+user); // hint: number -> 1000\nalert(user + 500); // hint: default -> 1500\n\nAs we can see from the code, user becomes a self-descriptive string or a money amount, depending on the conversion. The single method user[Symbol.toPrimitive] handles all conversion cases.\n\ntoString/valueOf\n\nIf there’s no Symbol.toPrimitive then JavaScript tries to find methods toString and valueOf:\n\nFor the \"string\" hint: call toString method, and if it doesn’t exist or if it returns an object instead of a primitive value, then call valueOf (so toString has the priority for string conversions).\nFor other hints: call valueOf, and if it doesn’t exist or if it returns an object instead of a primitive value, then call toString (so valueOf has the priority for maths).\n\nMethods toString and valueOf come from ancient times. They are not symbols (symbols did not exist that long ago), but rather “regular” string-named methods. They provide an alternative “old-style” way to implement the conversion.\n\nThese methods must return a primitive value. If toString or valueOf returns an object, then it’s ignored (same as if there were no method).\n\nBy default, a plain object has following toString and valueOf methods:\n\nThe toString method returns a string \"[object Object]\".\nThe valueOf method returns the object itself.\n\nHere’s the demo:\n\n\t\nlet user = {name: \"John\"};\n\nalert(user); // [object Object]\nalert(user.valueOf() === user); // true\n\nSo if we try to use an object as a string, like in an alert or so, then by default we see [object Object].\n\nThe default valueOf is mentioned here only for the sake of completeness, to avoid any confusion. As you can see, it returns the object itself, and so is ignored. Don’t ask me why, that’s for historical reasons. So we can assume it doesn’t exist.\n\nLet’s implement these methods to customize the conversion.\n\nFor instance, here user does the same as above using a combination of toString and valueOf instead of Symbol.toPrimitive:\n\n\t\nlet user = {\n  name: \"John\",\n  money: 1000,\n\n  // for hint=\"string\"\n  toString() {\n    return `{name: \"${this.name}\"}`;\n  },\n\n  // for hint=\"number\" or \"default\"\n  valueOf() {\n    return this.money;\n  }\n\n};\n\nalert(user); // toString -> {name: \"John\"}\nalert(+user); // valueOf -> 1000\nalert(user + 500); // valueOf -> 1500\n\nAs we can see, the behavior is the same as the previous example with Symbol.toPrimitive.\n\nOften we want a single “catch-all” place to handle all primitive conversions. In this case, we can implement toString only, like this:\n\n\t\nlet user = {\n  name: \"John\",\n\n  toString() {\n    return this.name;\n  }\n};\n\nalert(user); // toString -> John\nalert(user + 500); // toString -> John500\n\nIn the absence of Symbol.toPrimitive and valueOf, toString will handle all primitive conversions.\n\nA conversion can return any primitive type\n\nThe important thing to know about all primitive-conversion methods is that they do not necessarily return the “hinted” primitive.\n\nThere is no control whether toString returns exactly a string, or whether Symbol.toPrimitive method returns a number for the hint \"number\".\n\nThe only mandatory thing: these methods must return a primitive, not an object.\n\nHistorical notes\n\nFor historical reasons, if toString or valueOf returns an object, there’s no error, but such value is ignored (like if the method didn’t exist). That’s because in ancient times there was no good “error” concept in JavaScript.\n\nIn contrast, Symbol.toPrimitive is stricter, it must return a primitive, otherwise there will be an error.\n\nFurther conversions\n\nAs we know already, many operators and functions perform type conversions, e.g. multiplication * converts operands to numbers.\n\nIf we pass an object as an argument, then there are two stages of calculations:\n\nThe object is converted to a primitive (using the rules described above).\nIf necessary for further calculations, the resulting primitive is also converted.\n\nFor instance:\n\n\t\nlet obj = {\n  // toString handles all conversions in the absence of other methods\n  toString() {\n    return \"2\";\n  }\n};\n\nalert(obj * 2); // 4, object converted to primitive \"2\", then multiplication made it a number\nThe multiplication obj * 2 first converts the object to primitive (that’s a string \"2\").\nThen \"2\" * 2 becomes 2 * 2 (the string is converted to number).\n\nBinary plus will concatenate strings in the same situation, as it gladly accepts a string:\n\n\t\nlet obj = {\n  toString() {\n    return \"2\";\n  }\n};\n\nalert(obj + 2); // 22 (\"2\" + 2), conversion to primitive returned a string => concatenation\nSummary\n\nThe object-to-primitive conversion is called automatically by many built-in functions and operators that expect a primitive as a value.\n\nThere are 3 types (hints) of it:\n\n\"string\" (for alert and other operations that need a string)\n\"number\" (for maths)\n\"default\" (few operators, usually objects implement it the same way as \"number\")\n\nThe specification describes explicitly which operator uses which hint.\n\nThe conversion algorithm is:\n\nCall obj[Symbol.toPrimitive](hint) if the method exists,\nOtherwise if hint is \"string\"\ntry calling obj.toString() or obj.valueOf(), whatever exists.\nOtherwise if hint is \"number\" or \"default\"\ntry calling obj.valueOf() or obj.toString(), whatever exists.\n\nAll these methods must return a primitive to work (if defined).\n\nIn practice, it’s often enough to implement only obj.toString() as a “catch-all” method for string conversions that should return a “human-readable” representation of an object, for logging or debugging purposes."
  },
  {
    "title": "Symbol type",
    "url": "https://javascript.info/symbol",
    "html": "By specification, only two primitive types may serve as object property keys:\n\nstring type, or\nsymbol type.\n\nOtherwise, if one uses another type, such as number, it’s autoconverted to string. So that obj[1] is the same as obj[\"1\"], and obj[true] is the same as obj[\"true\"].\n\nUntil now we’ve been using only strings.\n\nNow let’s explore symbols, see what they can do for us.\n\nSymbols\n\nA “symbol” represents a unique identifier.\n\nA value of this type can be created using Symbol():\n\nlet id = Symbol();\n\nUpon creation, we can give symbols a description (also called a symbol name), mostly useful for debugging purposes:\n\n// id is a symbol with the description \"id\"\nlet id = Symbol(\"id\");\n\nSymbols are guaranteed to be unique. Even if we create many symbols with exactly the same description, they are different values. The description is just a label that doesn’t affect anything.\n\nFor instance, here are two symbols with the same description – they are not equal:\n\n\t\nlet id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\nalert(id1 == id2); // false\n\nIf you are familiar with Ruby or another language that also has some sort of “symbols” – please don’t be misguided. JavaScript symbols are different.\n\nSo, to summarize, a symbol is a “primitive unique value” with an optional description. Let’s see where we can use them.\n\nSymbols don’t auto-convert to a string\n\nMost values in JavaScript support implicit conversion to a string. For instance, we can alert almost any value, and it will work. Symbols are special. They don’t auto-convert.\n\nFor instance, this alert will show an error:\n\n\t\nlet id = Symbol(\"id\");\nalert(id); // TypeError: Cannot convert a Symbol value to a string\n\nThat’s a “language guard” against messing up, because strings and symbols are fundamentally different and should not accidentally convert one into another.\n\nIf we really want to show a symbol, we need to explicitly call .toString() on it, like here:\n\n\t\nlet id = Symbol(\"id\");\nalert(id.toString()); // Symbol(id), now it works\n\nOr get symbol.description property to show the description only:\n\n\t\nlet id = Symbol(\"id\");\nalert(id.description); // id\n“Hidden” properties\n\nSymbols allow us to create “hidden” properties of an object, that no other part of code can accidentally access or overwrite.\n\nFor instance, if we’re working with user objects, that belong to a third-party code. We’d like to add identifiers to them.\n\nLet’s use a symbol key for it:\n\n\t\nlet user = { // belongs to another code\n  name: \"John\"\n};\n\nlet id = Symbol(\"id\");\n\nuser[id] = 1;\n\nalert( user[id] ); // we can access the data using the symbol as the key\n\nWhat’s the benefit of using Symbol(\"id\") over a string \"id\"?\n\nAs user objects belong to another codebase, it’s unsafe to add fields to them, since we might affect pre-defined behavior in that other codebase. However, symbols cannot be accessed accidentally. The third-party code won’t be aware of newly defined symbols, so it’s safe to add symbols to the user objects.\n\nAlso, imagine that another script wants to have its own identifier inside user, for its own purposes.\n\nThen that script can create its own Symbol(\"id\"), like this:\n\n// ...\nlet id = Symbol(\"id\");\n\nuser[id] = \"Their id value\";\n\nThere will be no conflict between our and their identifiers, because symbols are always different, even if they have the same name.\n\n…But if we used a string \"id\" instead of a symbol for the same purpose, then there would be a conflict:\n\nlet user = { name: \"John\" };\n\n// Our script uses \"id\" property\nuser.id = \"Our id value\";\n\n// ...Another script also wants \"id\" for its purposes...\n\nuser.id = \"Their id value\"\n// Boom! overwritten by another script!\nSymbols in an object literal\n\nIf we want to use a symbol in an object literal {...}, we need square brackets around it.\n\nLike this:\n\nlet id = Symbol(\"id\");\n\nlet user = {\n  name: \"John\",\n  [id]: 123 // not \"id\": 123\n};\n\nThat’s because we need the value from the variable id as the key, not the string “id”.\n\nSymbols are skipped by for…in\n\nSymbolic properties do not participate in for..in loop.\n\nFor instance:\n\n\t\nlet id = Symbol(\"id\");\nlet user = {\n  name: \"John\",\n  age: 30,\n  [id]: 123\n};\n\nfor (let key in user) alert(key); // name, age (no symbols)\n\n// the direct access by the symbol works\nalert( \"Direct: \" + user[id] ); // Direct: 123\n\nObject.keys(user) also ignores them. That’s a part of the general “hiding symbolic properties” principle. If another script or a library loops over our object, it won’t unexpectedly access a symbolic property.\n\nIn contrast, Object.assign copies both string and symbol properties:\n\n\t\nlet id = Symbol(\"id\");\nlet user = {\n  [id]: 123\n};\n\nlet clone = Object.assign({}, user);\n\nalert( clone[id] ); // 123\n\nThere’s no paradox here. That’s by design. The idea is that when we clone an object or merge objects, we usually want all properties to be copied (including symbols like id).\n\nGlobal symbols\n\nAs we’ve seen, usually all symbols are different, even if they have the same name. But sometimes we want same-named symbols to be same entities. For instance, different parts of our application want to access symbol \"id\" meaning exactly the same property.\n\nTo achieve that, there exists a global symbol registry. We can create symbols in it and access them later, and it guarantees that repeated accesses by the same name return exactly the same symbol.\n\nIn order to read (create if absent) a symbol from the registry, use Symbol.for(key).\n\nThat call checks the global registry, and if there’s a symbol described as key, then returns it, otherwise creates a new symbol Symbol(key) and stores it in the registry by the given key.\n\nFor instance:\n\n\t\n// read from the global registry\nlet id = Symbol.for(\"id\"); // if the symbol did not exist, it is created\n\n// read it again (maybe from another part of the code)\nlet idAgain = Symbol.for(\"id\");\n\n// the same symbol\nalert( id === idAgain ); // true\n\nSymbols inside the registry are called global symbols. If we want an application-wide symbol, accessible everywhere in the code – that’s what they are for.\n\nThat sounds like Ruby\n\nIn some programming languages, like Ruby, there’s a single symbol per name.\n\nIn JavaScript, as we can see, that’s true for global symbols.\n\nSymbol.keyFor\n\nWe have seen that for global symbols, Symbol.for(key) returns a symbol by name. To do the opposite – return a name by global symbol – we can use: Symbol.keyFor(sym):\n\nFor instance:\n\n\t\n// get symbol by name\nlet sym = Symbol.for(\"name\");\nlet sym2 = Symbol.for(\"id\");\n\n// get name by symbol\nalert( Symbol.keyFor(sym) ); // name\nalert( Symbol.keyFor(sym2) ); // id\n\nThe Symbol.keyFor internally uses the global symbol registry to look up the key for the symbol. So it doesn’t work for non-global symbols. If the symbol is not global, it won’t be able to find it and returns undefined.\n\nThat said, all symbols have the description property.\n\nFor instance:\n\n\t\nlet globalSymbol = Symbol.for(\"name\");\nlet localSymbol = Symbol(\"name\");\n\nalert( Symbol.keyFor(globalSymbol) ); // name, global symbol\nalert( Symbol.keyFor(localSymbol) ); // undefined, not global\n\nalert( localSymbol.description ); // name\nSystem symbols\n\nThere exist many “system” symbols that JavaScript uses internally, and we can use them to fine-tune various aspects of our objects.\n\nThey are listed in the specification in the Well-known symbols table:\n\nSymbol.hasInstance\nSymbol.isConcatSpreadable\nSymbol.iterator\nSymbol.toPrimitive\n…and so on.\n\nFor instance, Symbol.toPrimitive allows us to describe object to primitive conversion. We’ll see its use very soon.\n\nOther symbols will also become familiar when we study the corresponding language features.\n\nSummary\n\nSymbol is a primitive type for unique identifiers.\n\nSymbols are created with Symbol() call with an optional description (name).\n\nSymbols are always different values, even if they have the same name. If we want same-named symbols to be equal, then we should use the global registry: Symbol.for(key) returns (creates if needed) a global symbol with key as the name. Multiple calls of Symbol.for with the same key return exactly the same symbol.\n\nSymbols have two main use cases:\n\n“Hidden” object properties.\n\nIf we want to add a property into an object that “belongs” to another script or a library, we can create a symbol and use it as a property key. A symbolic property does not appear in for..in, so it won’t be accidentally processed together with other properties. Also it won’t be accessed directly, because another script does not have our symbol. So the property will be protected from accidental use or overwrite.\n\nSo we can “covertly” hide something into objects that we need, but others should not see, using symbolic properties.\n\nThere are many system symbols used by JavaScript which are accessible as Symbol.*. We can use them to alter some built-in behaviors. For instance, later in the tutorial we’ll use Symbol.iterator for iterables, Symbol.toPrimitive to setup object-to-primitive conversion and so on.\n\nTechnically, symbols are not 100% hidden. There is a built-in method Object.getOwnPropertySymbols(obj) that allows us to get all symbols. Also there is a method named Reflect.ownKeys(obj) that returns all keys of an object including symbolic ones. But most libraries, built-in functions and syntax constructs don’t use these methods."
  },
  {
    "title": "Optional chaining '?.'",
    "url": "https://javascript.info/optional-chaining",
    "html": "A recent addition\nThis is a recent addition to the language. Old browsers may need polyfills.\n\nThe optional chaining ?. is a safe way to access nested object properties, even if an intermediate property doesn’t exist.\n\nThe “non-existing property” problem\n\nIf you’ve just started to read the tutorial and learn JavaScript, maybe the problem hasn’t touched you yet, but it’s quite common.\n\nAs an example, let’s say we have user objects that hold the information about our users.\n\nMost of our users have addresses in user.address property, with the street user.address.street, but some did not provide them.\n\nIn such case, when we attempt to get user.address.street, and the user happens to be without an address, we get an error:\n\n\t\nlet user = {}; // a user without \"address\" property\n\nalert(user.address.street); // Error!\n\nThat’s the expected result. JavaScript works like this. As user.address is undefined, an attempt to get user.address.street fails with an error.\n\nIn many practical cases we’d prefer to get undefined instead of an error here (meaning “no street”).\n\n…and another example. In Web development, we can get an object that corresponds to a web page element using a special method call, such as document.querySelector('.elem'), and it returns null when there’s no such element.\n\n\t\n// document.querySelector('.elem') is null if there's no element\nlet html = document.querySelector('.elem').innerHTML; // error if it's null\n\nOnce again, if the element doesn’t exist, we’ll get an error accessing .innerHTML property of null. And in some cases, when the absence of the element is normal, we’d like to avoid the error and just accept html = null as the result.\n\nHow can we do this?\n\nThe obvious solution would be to check the value using if or the conditional operator ?, before accessing its property, like this:\n\nlet user = {};\n\nalert(user.address ? user.address.street : undefined);\n\nIt works, there’s no error… But it’s quite inelegant. As you can see, the \"user.address\" appears twice in the code.\n\nHere’s how the same would look for document.querySelector:\n\n\t\nlet html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;\n\nWe can see that the element search document.querySelector('.elem') is actually called twice here. Not good.\n\nFor more deeply nested properties, it becomes even uglier, as more repetitions are required.\n\nE.g. let’s get user.address.street.name in a similar fashion.\n\nlet user = {}; // user has no address\n\nalert(user.address ? user.address.street ? user.address.street.name : null : null);\n\nThat’s just awful, one may even have problems understanding such code.\n\nThere’s a little better way to write it, using the && operator:\n\n\t\nlet user = {}; // user has no address\n\nalert( user.address && user.address.street && user.address.street.name ); // undefined (no error)\n\nAND’ing the whole path to the property ensures that all components exist (if not, the evaluation stops), but also isn’t ideal.\n\nAs you can see, property names are still duplicated in the code. E.g. in the code above, user.address appears three times.\n\nThat’s why the optional chaining ?. was added to the language. To solve this problem once and for all!\n\nOptional chaining\n\nThe optional chaining ?. stops the evaluation if the value before ?. is undefined or null and returns undefined.\n\nFurther in this article, for brevity, we’ll be saying that something “exists” if it’s not null and not undefined.\n\nIn other words, value?.prop:\n\nworks as value.prop, if value exists,\notherwise (when value is undefined/null) it returns undefined.\n\nHere’s the safe way to access user.address.street using ?.:\n\n\t\nlet user = {}; // user has no address\n\nalert( user?.address?.street ); // undefined (no error)\n\nThe code is short and clean, there’s no duplication at all.\n\nHere’s an example with document.querySelector:\n\n\t\nlet html = document.querySelector('.elem')?.innerHTML; // will be undefined, if there's no element\n\nReading the address with user?.address works even if user object doesn’t exist:\n\n\t\nlet user = null;\n\nalert( user?.address ); // undefined\nalert( user?.address.street ); // undefined\n\nPlease note: the ?. syntax makes optional the value before it, but not any further.\n\nE.g. in user?.address.street.name the ?. allows user to safely be null/undefined (and returns undefined in that case), but that’s only for user. Further properties are accessed in a regular way. If we want some of them to be optional, then we’ll need to replace more . with ?..\n\nDon’t overuse the optional chaining\n\nWe should use ?. only where it’s ok that something doesn’t exist.\n\nFor example, if according to our code logic user object must exist, but address is optional, then we should write user.address?.street, but not user?.address?.street.\n\nThen, if user happens to be undefined, we’ll see a programming error about it and fix it. Otherwise, if we overuse ?., coding errors can be silenced where not appropriate, and become more difficult to debug.\n\nThe variable before ?. must be declared\n\nIf there’s no variable user at all, then user?.anything triggers an error:\n\n\t\n// ReferenceError: user is not defined\nuser?.address;\n\nThe variable must be declared (e.g. let/const/var user or as a function parameter). The optional chaining works only for declared variables.\n\nShort-circuiting\n\nAs it was said before, the ?. immediately stops (“short-circuits”) the evaluation if the left part doesn’t exist.\n\nSo, if there are any further function calls or operations to the right of ?., they won’t be made.\n\nFor instance:\n\n\t\nlet user = null;\nlet x = 0;\n\nuser?.sayHi(x++); // no \"user\", so the execution doesn't reach sayHi call and x++\n\nalert(x); // 0, value not incremented\nOther variants: ?.(), ?.[]\n\nThe optional chaining ?. is not an operator, but a special syntax construct, that also works with functions and square brackets.\n\nFor example, ?.() is used to call a function that may not exist.\n\nIn the code below, some of our users have admin method, and some don’t:\n\n\t\nlet userAdmin = {\n  admin() {\n    alert(\"I am admin\");\n  }\n};\n\nlet userGuest = {};\n\nuserAdmin.admin?.(); // I am admin\n\nuserGuest.admin?.(); // nothing happens (no such method)\n\nHere, in both lines we first use the dot (userAdmin.admin) to get admin property, because we assume that the user object exists, so it’s safe read from it.\n\nThen ?.() checks the left part: if the admin function exists, then it runs (that’s so for userAdmin). Otherwise (for userGuest) the evaluation stops without errors.\n\nThe ?.[] syntax also works, if we’d like to use brackets [] to access properties instead of dot .. Similar to previous cases, it allows to safely read a property from an object that may not exist.\n\n\t\nlet key = \"firstName\";\n\nlet user1 = {\n  firstName: \"John\"\n};\n\nlet user2 = null;\n\nalert( user1?.[key] ); // John\nalert( user2?.[key] ); // undefined\n\nAlso we can use ?. with delete:\n\n\t\ndelete user?.name; // delete user.name if user exists\nWe can use ?. for safe reading and deleting, but not writing\n\nThe optional chaining ?. has no use on the left side of an assignment.\n\nFor example:\n\n\t\nlet user = null;\n\nuser?.name = \"John\"; // Error, doesn't work\n// because it evaluates to: undefined = \"John\"\nSummary\n\nThe optional chaining ?. syntax has three forms:\n\nobj?.prop – returns obj.prop if obj exists, otherwise undefined.\nobj?.[prop] – returns obj[prop] if obj exists, otherwise undefined.\nobj.method?.() – calls obj.method() if obj.method exists, otherwise returns undefined.\n\nAs we can see, all of them are straightforward and simple to use. The ?. checks the left part for null/undefined and allows the evaluation to proceed if it’s not so.\n\nA chain of ?. allows to safely access nested properties.\n\nStill, we should apply ?. carefully, only where it’s acceptable, according to our code logic, that the left part doesn’t exist. So that it won’t hide programming errors from us, if they occur."
  },
  {
    "title": "Constructor, operator \"new\"",
    "url": "https://javascript.info/constructor-new",
    "html": "The regular {...} syntax allows us to create one object. But often we need to create many similar objects, like multiple users or menu items and so on.\n\nThat can be done using constructor functions and the \"new\" operator.\n\nConstructor function\n\nConstructor functions technically are regular functions. There are two conventions though:\n\nThey are named with capital letter first.\nThey should be executed only with \"new\" operator.\n\nFor instance:\n\n\t\nfunction User(name) {\n  this.name = name;\n  this.isAdmin = false;\n}\n\nlet user = new User(\"Jack\");\n\nalert(user.name); // Jack\nalert(user.isAdmin); // false\n\nWhen a function is executed with new, it does the following steps:\n\nA new empty object is created and assigned to this.\nThe function body executes. Usually it modifies this, adds new properties to it.\nThe value of this is returned.\n\nIn other words, new User(...) does something like:\n\nfunction User(name) {\n  // this = {};  (implicitly)\n\n  // add properties to this\n  this.name = name;\n  this.isAdmin = false;\n\n  // return this;  (implicitly)\n}\n\nSo let user = new User(\"Jack\") gives the same result as:\n\nlet user = {\n  name: \"Jack\",\n  isAdmin: false\n};\n\nNow if we want to create other users, we can call new User(\"Ann\"), new User(\"Alice\") and so on. Much shorter than using literals every time, and also easy to read.\n\nThat’s the main purpose of constructors – to implement reusable object creation code.\n\nLet’s note once again – technically, any function (except arrow functions, as they don’t have this) can be used as a constructor. It can be run with new, and it will execute the algorithm above. The “capital letter first” is a common agreement, to make it clear that a function is to be run with new.\n\nnew function() { … }\n\nIf we have many lines of code all about creation of a single complex object, we can wrap them in an immediately called constructor function, like this:\n\n// create a function and immediately call it with new\nlet user = new function() {\n  this.name = \"John\";\n  this.isAdmin = false;\n\n  // ...other code for user creation\n  // maybe complex logic and statements\n  // local variables etc\n};\n\nThis constructor can’t be called again, because it is not saved anywhere, just created and called. So this trick aims to encapsulate the code that constructs the single object, without future reuse.\n\nConstructor mode test: new.target\nAdvanced stuff\n\nThe syntax from this section is rarely used, skip it unless you want to know everything.\n\nInside a function, we can check whether it was called with new or without it, using a special new.target property.\n\nIt is undefined for regular calls and equals the function if called with new:\n\n\t\nfunction User() {\n  alert(new.target);\n}\n\n// without \"new\":\nUser(); // undefined\n\n// with \"new\":\nnew User(); // function User { ... }\n\nThat can be used inside the function to know whether it was called with new, “in constructor mode”, or without it, “in regular mode”.\n\nWe can also make both new and regular calls to do the same, like this:\n\n\t\nfunction User(name) {\n  if (!new.target) { // if you run me without new\n    return new User(name); // ...I will add new for you\n  }\n\n  this.name = name;\n}\n\nlet john = User(\"John\"); // redirects call to new User\nalert(john.name); // John\n\nThis approach is sometimes used in libraries to make the syntax more flexible. So that people may call the function with or without new, and it still works.\n\nProbably not a good thing to use everywhere though, because omitting new makes it a bit less obvious what’s going on. With new we all know that the new object is being created.\n\nReturn from constructors\n\nUsually, constructors do not have a return statement. Their task is to write all necessary stuff into this, and it automatically becomes the result.\n\nBut if there is a return statement, then the rule is simple:\n\nIf return is called with an object, then the object is returned instead of this.\nIf return is called with a primitive, it’s ignored.\n\nIn other words, return with an object returns that object, in all other cases this is returned.\n\nFor instance, here return overrides this by returning an object:\n\n\t\nfunction BigUser() {\n\n  this.name = \"John\";\n\n  return { name: \"Godzilla\" };  // <-- returns this object\n}\n\nalert( new BigUser().name );  // Godzilla, got that object\n\nAnd here’s an example with an empty return (or we could place a primitive after it, doesn’t matter):\n\n\t\nfunction SmallUser() {\n\n  this.name = \"John\";\n\n  return; // <-- returns this\n}\n\nalert( new SmallUser().name );  // John\n\nUsually constructors don’t have a return statement. Here we mention the special behavior with returning objects mainly for the sake of completeness.\n\nOmitting parentheses\n\nBy the way, we can omit parentheses after new:\n\nlet user = new User; // <-- no parentheses\n// same as\nlet user = new User();\n\nOmitting parentheses here is not considered a “good style”, but the syntax is permitted by specification.\n\nMethods in constructor\n\nUsing constructor functions to create objects gives a great deal of flexibility. The constructor function may have parameters that define how to construct the object, and what to put in it.\n\nOf course, we can add to this not only properties, but methods as well.\n\nFor instance, new User(name) below creates an object with the given name and the method sayHi:\n\n\t\nfunction User(name) {\n  this.name = name;\n\n  this.sayHi = function() {\n    alert( \"My name is: \" + this.name );\n  };\n}\n\nlet john = new User(\"John\");\n\njohn.sayHi(); // My name is: John\n\n/*\njohn = {\n   name: \"John\",\n   sayHi: function() { ... }\n}\n*/\n\nTo create complex objects, there’s a more advanced syntax, classes, that we’ll cover later.\n\nSummary\nConstructor functions or, briefly, constructors, are regular functions, but there’s a common agreement to name them with capital letter first.\nConstructor functions should only be called using new. Such a call implies a creation of empty this at the start and returning the populated one at the end.\n\nWe can use constructor functions to make multiple similar objects.\n\nJavaScript provides constructor functions for many built-in language objects: like Date for dates, Set for sets and others that we plan to study.\n\nObjects, we’ll be back!\n\nIn this chapter we only cover the basics about objects and constructors. They are essential for learning more about data types and functions in the next chapters.\n\nAfter we learn that, we return to objects and cover them in-depth in the chapters Prototypes, inheritance and Classes.\n\nTasks\nTwo functions – one object\nimportance: 2\n\nIs it possible to create functions A and B so that new A() == new B()?\n\nfunction A() { ... }\nfunction B() { ... }\n\nlet a = new A();\nlet b = new B();\n\nalert( a == b ); // true\n\nIf it is, then provide an example of their code.\n\nsolution\nCreate new Calculator\nimportance: 5\n\nCreate a constructor function Calculator that creates objects with 3 methods:\n\nread() prompts for two values and saves them as object properties with names a and b respectively.\nsum() returns the sum of these properties.\nmul() returns the multiplication product of these properties.\n\nFor instance:\n\nlet calculator = new Calculator();\ncalculator.read();\n\nalert( \"Sum=\" + calculator.sum() );\nalert( \"Mul=\" + calculator.mul() );\n\nRun the demo\n\nOpen a sandbox with tests.\n\nsolution\nCreate new Accumulator\nimportance: 5\n\nCreate a constructor function Accumulator(startingValue).\n\nObject that it creates should:\n\nStore the “current value” in the property value. The starting value is set to the argument of the constructor startingValue.\nThe read() method should use prompt to read a new number and add it to value.\n\nIn other words, the value property is the sum of all user-entered values with the initial value startingValue.\n\nHere’s the demo of the code:\n\nlet accumulator = new Accumulator(1); // initial value 1\n\naccumulator.read(); // adds the user-entered value\naccumulator.read(); // adds the user-entered value\n\nalert(accumulator.value); // shows the sum of these values\n\nRun the demo\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Object methods, \"this\"",
    "url": "https://javascript.info/object-methods",
    "html": "Objects are usually created to represent entities of the real world, like users, orders and so on:\n\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nAnd, in the real world, a user can act: select something from the shopping cart, login, logout etc.\n\nActions are represented in JavaScript by functions in properties.\n\nMethod examples\n\nFor a start, let’s teach the user to say hello:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nuser.sayHi = function() {\n  alert(\"Hello!\");\n};\n\nuser.sayHi(); // Hello!\n\nHere we’ve just used a Function Expression to create a function and assign it to the property user.sayHi of the object.\n\nThen we can call it as user.sayHi(). The user can now speak!\n\nA function that is a property of an object is called its method.\n\nSo, here we’ve got a method sayHi of the object user.\n\nOf course, we could use a pre-declared function as a method, like this:\n\n\t\nlet user = {\n  // ...\n};\n\n// first, declare\nfunction sayHi() {\n  alert(\"Hello!\");\n}\n\n// then add as a method\nuser.sayHi = sayHi;\n\nuser.sayHi(); // Hello!\nObject-oriented programming\n\nWhen we write our code using objects to represent entities, that’s called object-oriented programming, in short: “OOP”.\n\nOOP is a big thing, an interesting science of its own. How to choose the right entities? How to organize the interaction between them? That’s architecture, and there are great books on that topic, like “Design Patterns: Elements of Reusable Object-Oriented Software” by E. Gamma, R. Helm, R. Johnson, J. Vissides or “Object-Oriented Analysis and Design with Applications” by G. Booch, and more.\n\nMethod shorthand\n\nThere exists a shorter syntax for methods in an object literal:\n\n// these objects do the same\n\nuser = {\n  sayHi: function() {\n    alert(\"Hello\");\n  }\n};\n\n// method shorthand looks better, right?\nuser = {\n  sayHi() { // same as \"sayHi: function(){...}\"\n    alert(\"Hello\");\n  }\n};\n\nAs demonstrated, we can omit \"function\" and just write sayHi().\n\nTo tell the truth, the notations are not fully identical. There are subtle differences related to object inheritance (to be covered later), but for now they do not matter. In almost all cases, the shorter syntax is preferred.\n\n“this” in methods\n\nIt’s common that an object method needs to access the information stored in the object to do its job.\n\nFor instance, the code inside user.sayHi() may need the name of the user.\n\nTo access the object, a method can use the this keyword.\n\nThe value of this is the object “before dot”, the one used to call the method.\n\nFor instance:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n    // \"this\" is the \"current object\"\n    alert(this.name);\n  }\n\n};\n\nuser.sayHi(); // John\n\nHere during the execution of user.sayHi(), the value of this will be user.\n\nTechnically, it’s also possible to access the object without this, by referencing it via the outer variable:\n\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n    alert(user.name); // \"user\" instead of \"this\"\n  }\n\n};\n\n…But such code is unreliable. If we decide to copy user to another variable, e.g. admin = user and overwrite user with something else, then it will access the wrong object.\n\nThat’s demonstrated below:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30,\n\n  sayHi() {\n    alert( user.name ); // leads to an error\n  }\n\n};\n\n\nlet admin = user;\nuser = null; // overwrite to make things obvious\n\nadmin.sayHi(); // TypeError: Cannot read property 'name' of null\n\nIf we used this.name instead of user.name inside the alert, then the code would work.\n\n“this” is not bound\n\nIn JavaScript, keyword this behaves unlike most other programming languages. It can be used in any function, even if it’s not a method of an object.\n\nThere’s no syntax error in the following example:\n\nfunction sayHi() {\n  alert( this.name );\n}\n\nThe value of this is evaluated during the run-time, depending on the context.\n\nFor instance, here the same function is assigned to two different objects and has different “this” in the calls:\n\n\t\nlet user = { name: \"John\" };\nlet admin = { name: \"Admin\" };\n\nfunction sayHi() {\n  alert( this.name );\n}\n\n// use the same function in two objects\nuser.f = sayHi;\nadmin.f = sayHi;\n\n// these calls have different this\n// \"this\" inside the function is the object \"before the dot\"\nuser.f(); // John  (this == user)\nadmin.f(); // Admin  (this == admin)\n\nadmin['f'](); // Admin (dot or square brackets access the method – doesn't matter)\n\nThe rule is simple: if obj.f() is called, then this is obj during the call of f. So it’s either user or admin in the example above.\n\nCalling without an object: this == undefined\n\nWe can even call the function without an object at all:\n\n\t\nfunction sayHi() {\n  alert(this);\n}\n\nsayHi(); // undefined\n\nIn this case this is undefined in strict mode. If we try to access this.name, there will be an error.\n\nIn non-strict mode the value of this in such case will be the global object (window in a browser, we’ll get to it later in the chapter Global object). This is a historical behavior that \"use strict\" fixes.\n\nUsually such call is a programming error. If there’s this inside a function, it expects to be called in an object context.\n\nThe consequences of unbound this\n\nIf you come from another programming language, then you are probably used to the idea of a \"bound this\", where methods defined in an object always have this referencing that object.\n\nIn JavaScript this is “free”, its value is evaluated at call-time and does not depend on where the method was declared, but rather on what object is “before the dot”.\n\nThe concept of run-time evaluated this has both pluses and minuses. On the one hand, a function can be reused for different objects. On the other hand, the greater flexibility creates more possibilities for mistakes.\n\nHere our position is not to judge whether this language design decision is good or bad. We’ll understand how to work with it, how to get benefits and avoid problems.\n\nArrow functions have no “this”\n\nArrow functions are special: they don’t have their “own” this. If we reference this from such a function, it’s taken from the outer “normal” function.\n\nFor instance, here arrow() uses this from the outer user.sayHi() method:\n\n\t\nlet user = {\n  firstName: \"Ilya\",\n  sayHi() {\n    let arrow = () => alert(this.firstName);\n    arrow();\n  }\n};\n\nuser.sayHi(); // Ilya\n\nThat’s a special feature of arrow functions, it’s useful when we actually do not want to have a separate this, but rather to take it from the outer context. Later in the chapter Arrow functions revisited we’ll go more deeply into arrow functions.\n\nSummary\nFunctions that are stored in object properties are called “methods”.\nMethods allow objects to “act” like object.doSomething().\nMethods can reference the object as this.\n\nThe value of this is defined at run-time.\n\nWhen a function is declared, it may use this, but that this has no value until the function is called.\nA function can be copied between objects.\nWhen a function is called in the “method” syntax: object.method(), the value of this during the call is object.\n\nPlease note that arrow functions are special: they have no this. When this is accessed inside an arrow function, it is taken from outside.\n\nTasks\nUsing \"this\" in object literal\nimportance: 5\n\nHere the function makeUser returns an object.\n\nWhat is the result of accessing its ref? Why?\n\nfunction makeUser() {\n  return {\n    name: \"John\",\n    ref: this\n  };\n}\n\nlet user = makeUser();\n\nalert( user.ref.name ); // What's the result?\nsolution\nCreate a calculator\nimportance: 5\n\nCreate an object calculator with three methods:\n\nread() prompts for two values and saves them as object properties with names a and b respectively.\nsum() returns the sum of saved values.\nmul() multiplies saved values and returns the result.\nlet calculator = {\n  // ... your code ...\n};\n\ncalculator.read();\nalert( calculator.sum() );\nalert( calculator.mul() );\n\nRun the demo\n\nOpen a sandbox with tests.\n\nsolution\nChaining\nimportance: 2\n\nThere’s a ladder object that allows to go up and down:\n\nlet ladder = {\n  step: 0,\n  up() {\n    this.step++;\n  },\n  down() {\n    this.step--;\n  },\n  showStep: function() { // shows the current step\n    alert( this.step );\n  }\n};\n\nNow, if we need to make several calls in sequence, can do it like this:\n\nladder.up();\nladder.up();\nladder.down();\nladder.showStep(); // 1\nladder.down();\nladder.showStep(); // 0\n\nModify the code of up, down and showStep to make the calls chainable, like this:\n\nladder.up().up().down().showStep().down().showStep(); // shows 1 then 0\n\nSuch approach is widely used across JavaScript libraries.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Garbage collection",
    "url": "https://javascript.info/garbage-collection",
    "html": "Memory management in JavaScript is performed automatically and invisibly to us. We create primitives, objects, functions… All that takes memory.\n\nWhat happens when something is not needed any more? How does the JavaScript engine discover it and clean it up?\n\nReachability\n\nThe main concept of memory management in JavaScript is reachability.\n\nSimply put, “reachable” values are those that are accessible or usable somehow. They are guaranteed to be stored in memory.\n\nThere’s a base set of inherently reachable values, that cannot be deleted for obvious reasons.\n\nFor instance:\n\nThe currently executing function, its local variables and parameters.\nOther functions on the current chain of nested calls, their local variables and parameters.\nGlobal variables.\n(there are some other, internal ones as well)\n\nThese values are called roots.\n\nAny other value is considered reachable if it’s reachable from a root by a reference or by a chain of references.\n\nFor instance, if there’s an object in a global variable, and that object has a property referencing another object, that object is considered reachable. And those that it references are also reachable. Detailed examples to follow.\n\nThere’s a background process in the JavaScript engine that is called garbage collector. It monitors all objects and removes those that have become unreachable.\n\nA simple example\n\nHere’s the simplest example:\n\n// user has a reference to the object\nlet user = {\n  name: \"John\"\n};\n\nHere the arrow depicts an object reference. The global variable \"user\" references the object {name: \"John\"} (we’ll call it John for brevity). The \"name\" property of John stores a primitive, so it’s painted inside the object.\n\nIf the value of user is overwritten, the reference is lost:\n\nuser = null;\n\nNow John becomes unreachable. There’s no way to access it, no references to it. Garbage collector will junk the data and free the memory.\n\nTwo references\n\nNow let’s imagine we copied the reference from user to admin:\n\n// user has a reference to the object\nlet user = {\n  name: \"John\"\n};\n\nlet admin = user;\n\nNow if we do the same:\n\nuser = null;\n\n…Then the object is still reachable via admin global variable, so it must stay in memory. If we overwrite admin too, then it can be removed.\n\nInterlinked objects\n\nNow a more complex example. The family:\n\nfunction marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nlet family = marry({\n  name: \"John\"\n}, {\n  name: \"Ann\"\n});\n\nFunction marry “marries” two objects by giving them references to each other and returns a new object that contains them both.\n\nThe resulting memory structure:\n\nAs of now, all objects are reachable.\n\nNow let’s remove two references:\n\ndelete family.father;\ndelete family.mother.husband;\n\nIt’s not enough to delete only one of these two references, because all objects would still be reachable.\n\nBut if we delete both, then we can see that John has no incoming reference any more:\n\nOutgoing references do not matter. Only incoming ones can make an object reachable. So, John is now unreachable and will be removed from the memory with all its data that also became unaccessible.\n\nAfter garbage collection:\n\nUnreachable island\n\nIt is possible that the whole island of interlinked objects becomes unreachable and is removed from the memory.\n\nThe source object is the same as above. Then:\n\nfamily = null;\n\nThe in-memory picture becomes:\n\nThis example demonstrates how important the concept of reachability is.\n\nIt’s obvious that John and Ann are still linked, both have incoming references. But that’s not enough.\n\nThe former \"family\" object has been unlinked from the root, there’s no reference to it any more, so the whole island becomes unreachable and will be removed.\n\nInternal algorithms\n\nThe basic garbage collection algorithm is called “mark-and-sweep”.\n\nThe following “garbage collection” steps are regularly performed:\n\nThe garbage collector takes roots and “marks” (remembers) them.\nThen it visits and “marks” all references from them.\nThen it visits marked objects and marks their references. All visited objects are remembered, so as not to visit the same object twice in the future.\n…And so on until every reachable (from the roots) references are visited.\nAll objects except marked ones are removed.\n\nFor instance, let our object structure look like this:\n\nWe can clearly see an “unreachable island” to the right side. Now let’s see how “mark-and-sweep” garbage collector deals with it.\n\nThe first step marks the roots:\n\nThen we follow their references and mark referenced objects:\n\n…And continue to follow further references, while possible:\n\nNow the objects that could not be visited in the process are considered unreachable and will be removed:\n\nWe can also imagine the process as spilling a huge bucket of paint from the roots, that flows through all references and marks all reachable objects. The unmarked ones are then removed.\n\nThat’s the concept of how garbage collection works. JavaScript engines apply many optimizations to make it run faster and not introduce any delays into the code execution.\n\nSome of the optimizations:\n\nGenerational collection – objects are split into two sets: “new ones” and “old ones”. In typical code, many objects have a short life span: they appear, do their job and die fast, so it makes sense to track new objects and clear the memory from them if that’s the case. Those that survive for long enough, become “old” and are examined less often.\nIncremental collection – if there are many objects, and we try to walk and mark the whole object set at once, it may take some time and introduce visible delays in the execution. So the engine splits the whole set of existing objects into multiple parts. And then clear these parts one after another. There are many small garbage collections instead of a total one. That requires some extra bookkeeping between them to track changes, but we get many tiny delays instead of a big one.\nIdle-time collection – the garbage collector tries to run only while the CPU is idle, to reduce the possible effect on the execution.\n\nThere exist other optimizations and flavours of garbage collection algorithms. As much as I’d like to describe them here, I have to hold off, because different engines implement different tweaks and techniques. And, what’s even more important, things change as engines develop, so studying deeper “in advance”, without a real need is probably not worth that. Unless, of course, it is a matter of pure interest, then there will be some links for you below.\n\nSummary\n\nThe main things to know:\n\nGarbage collection is performed automatically. We cannot force or prevent it.\nObjects are retained in memory while they are reachable.\nBeing referenced is not the same as being reachable (from a root): a pack of interlinked objects can become unreachable as a whole, as we’ve seen in the example above.\n\nModern engines implement advanced algorithms of garbage collection.\n\nA general book “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. Jones et al) covers some of them.\n\nIf you are familiar with low-level programming, more detailed information about V8’s garbage collector is in the article A tour of V8: Garbage Collection.\n\nThe V8 blog also publishes articles about changes in memory management from time to time. Naturally, to learn more about garbage collection, you’d better prepare by learning about V8 internals in general and read the blog of Vyacheslav Egorov who worked as one of the V8 engineers. I’m saying: “V8”, because it is best covered by articles on the internet. For other engines, many approaches are similar, but garbage collection differs in many aspects.\n\nIn-depth knowledge of engines is good when you need low-level optimizations. It would be wise to plan that as the next step after you’re familiar with the language."
  },
  {
    "title": "Automated testing with Mocha",
    "url": "https://javascript.info/testing-mocha",
    "html": "Automated testing will be used in further tasks, and it’s also widely used in real projects.\n\nWhy do we need tests?\n\nWhen we write a function, we can usually imagine what it should do: which parameters give which results.\n\nDuring development, we can check the function by running it and comparing the outcome with the expected one. For instance, we can do it in the console.\n\nIf something is wrong – then we fix the code, run again, check the result – and so on till it works.\n\nBut such manual “re-runs” are imperfect.\n\nWhen testing a code by manual re-runs, it’s easy to miss something.\n\nFor instance, we’re creating a function f. Wrote some code, testing: f(1) works, but f(2) doesn’t work. We fix the code and now f(2) works. Looks complete? But we forgot to re-test f(1). That may lead to an error.\n\nThat’s very typical. When we develop something, we keep a lot of possible use cases in mind. But it’s hard to expect a programmer to check all of them manually after every change. So it becomes easy to fix one thing and break another one.\n\nAutomated testing means that tests are written separately, in addition to the code. They run our functions in various ways and compare results with the expected.\n\nBehavior Driven Development (BDD)\n\nLet’s start with a technique named Behavior Driven Development or, in short, BDD.\n\nBDD is three things in one: tests AND documentation AND examples.\n\nTo understand BDD, we’ll examine a practical case of development.\n\nDevelopment of “pow”: the spec\n\nLet’s say we want to make a function pow(x, n) that raises x to an integer power n. We assume that n≥0.\n\nThat task is just an example: there’s the ** operator in JavaScript that can do that, but here we concentrate on the development flow that can be applied to more complex tasks as well.\n\nBefore creating the code of pow, we can imagine what the function should do and describe it.\n\nSuch description is called a specification or, in short, a spec, and contains descriptions of use cases together with tests for them, like this:\n\ndescribe(\"pow\", function() {\n\n  it(\"raises to n-th power\", function() {\n    assert.equal(pow(2, 3), 8);\n  });\n\n});\n\nA spec has three main building blocks that you can see above:\n\ndescribe(\"title\", function() { ... })\n\nWhat functionality we’re describing? In our case we’re describing the function pow. Used to group “workers” – the it blocks.\n\nit(\"use case description\", function() { ... })\n\nIn the title of it we in a human-readable way describe the particular use case, and the second argument is a function that tests it.\n\nassert.equal(value1, value2)\n\nThe code inside it block, if the implementation is correct, should execute without errors.\n\nFunctions assert.* are used to check whether pow works as expected. Right here we’re using one of them – assert.equal, it compares arguments and yields an error if they are not equal. Here it checks that the result of pow(2, 3) equals 8. There are other types of comparisons and checks, that we’ll add later.\n\nThe specification can be executed, and it will run the test specified in it block. We’ll see that later.\n\nThe development flow\n\nThe flow of development usually looks like this:\n\nAn initial spec is written, with tests for the most basic functionality.\nAn initial implementation is created.\nTo check whether it works, we run the testing framework Mocha (more details soon) that runs the spec. While the functionality is not complete, errors are displayed. We make corrections until everything works.\nNow we have a working initial implementation with tests.\nWe add more use cases to the spec, probably not yet supported by the implementations. Tests start to fail.\nGo to 3, update the implementation till tests give no errors.\nRepeat steps 3-6 till the functionality is ready.\n\nSo, the development is iterative. We write the spec, implement it, make sure tests pass, then write more tests, make sure they work etc. At the end we have both a working implementation and tests for it.\n\nLet’s see this development flow in our practical case.\n\nThe first step is already complete: we have an initial spec for pow. Now, before making the implementation, let’s use a few JavaScript libraries to run the tests, just to see that they are working (they will all fail).\n\nThe spec in action\n\nHere in the tutorial we’ll be using the following JavaScript libraries for tests:\n\nMocha – the core framework: it provides common testing functions including describe and it and the main function that runs tests.\nChai – the library with many assertions. It allows to use a lot of different assertions, for now we need only assert.equal.\nSinon – a library to spy over functions, emulate built-in functions and more, we’ll need it much later.\n\nThese libraries are suitable for both in-browser and server-side testing. Here we’ll consider the browser variant.\n\nThe full HTML page with these frameworks and pow spec:\n\n<!DOCTYPE html>\n<html>\n<head>\n  <!-- add mocha css, to show results -->\n  <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css\">\n  <!-- add mocha framework code -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js\"></script>\n  <script>\n    mocha.setup('bdd'); // minimal setup\n  </script>\n  <!-- add chai -->\n  <script src=\"https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js\"></script>\n  <script>\n    // chai has a lot of stuff, let's make assert global\n    let assert = chai.assert;\n  </script>\n</head>\n\n<body>\n\n  <script>\n    function pow(x, n) {\n      /* function code is to be written, empty now */\n    }\n  </script>\n\n  <!-- the script with tests (describe, it...) -->\n  <script src=\"test.js\"></script>\n\n  <!-- the element with id=\"mocha\" will contain test results -->\n  <div id=\"mocha\"></div>\n\n  <!-- run tests! -->\n  <script>\n    mocha.run();\n  </script>\n</body>\n\n</html>\n\nThe page can be divided into five parts:\n\nThe <head> – add third-party libraries and styles for tests.\nThe <script> with the function to test, in our case – with the code for pow.\nThe tests – in our case an external script test.js that has describe(\"pow\", ...) from above.\nThe HTML element <div id=\"mocha\"> will be used by Mocha to output results.\nThe tests are started by the command mocha.run().\n\nThe result:\n\nAs of now, the test fails, there’s an error. That’s logical: we have an empty function code in pow, so pow(2,3) returns undefined instead of 8.\n\nFor the future, let’s note that there are more high-level test-runners, like karma and others, that make it easy to autorun many different tests.\n\nInitial implementation\n\nLet’s make a simple implementation of pow, for tests to pass:\n\nfunction pow(x, n) {\n  return 8; // :) we cheat!\n}\n\nWow, now it works!\n\nImproving the spec\n\nWhat we’ve done is definitely a cheat. The function does not work: an attempt to calculate pow(3,4) would give an incorrect result, but tests pass.\n\n…But the situation is quite typical, it happens in practice. Tests pass, but the function works wrong. Our spec is imperfect. We need to add more use cases to it.\n\nLet’s add one more test to check that pow(3, 4) = 81.\n\nWe can select one of two ways to organize the test here:\n\nThe first variant – add one more assert into the same it:\n\ndescribe(\"pow\", function() {\n\n  it(\"raises to n-th power\", function() {\n    assert.equal(pow(2, 3), 8);\n    assert.equal(pow(3, 4), 81);\n  });\n\n});\n\nThe second – make two tests:\n\ndescribe(\"pow\", function() {\n\n  it(\"2 raised to power 3 is 8\", function() {\n    assert.equal(pow(2, 3), 8);\n  });\n\n  it(\"3 raised to power 4 is 81\", function() {\n    assert.equal(pow(3, 4), 81);\n  });\n\n});\n\nThe principal difference is that when assert triggers an error, the it block immediately terminates. So, in the first variant if the first assert fails, then we’ll never see the result of the second assert.\n\nMaking tests separate is useful to get more information about what’s going on, so the second variant is better.\n\nAnd besides that, there’s one more rule that’s good to follow.\n\nOne test checks one thing.\n\nIf we look at the test and see two independent checks in it, it’s better to split it into two simpler ones.\n\nSo let’s continue with the second variant.\n\nThe result:\n\nAs we could expect, the second test failed. Sure, our function always returns 8, while the assert expects 81.\n\nImproving the implementation\n\nLet’s write something more real for tests to pass:\n\nfunction pow(x, n) {\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nTo be sure that the function works well, let’s test it for more values. Instead of writing it blocks manually, we can generate them in for:\n\ndescribe(\"pow\", function() {\n\n  function makeTest(x) {\n    let expected = x * x * x;\n    it(`${x} in the power 3 is ${expected}`, function() {\n      assert.equal(pow(x, 3), expected);\n    });\n  }\n\n  for (let x = 1; x <= 5; x++) {\n    makeTest(x);\n  }\n\n});\n\nThe result:\n\nNested describe\n\nWe’re going to add even more tests. But before that let’s note that the helper function makeTest and for should be grouped together. We won’t need makeTest in other tests, it’s needed only in for: their common task is to check how pow raises into the given power.\n\nGrouping is done with a nested describe:\n\ndescribe(\"pow\", function() {\n\n  describe(\"raises x to power 3\", function() {\n\n    function makeTest(x) {\n      let expected = x * x * x;\n      it(`${x} in the power 3 is ${expected}`, function() {\n        assert.equal(pow(x, 3), expected);\n      });\n    }\n\n    for (let x = 1; x <= 5; x++) {\n      makeTest(x);\n    }\n\n  });\n\n  // ... more tests to follow here, both describe and it can be added\n});\n\nThe nested describe defines a new “subgroup” of tests. In the output we can see the titled indentation:\n\nIn the future we can add more it and describe on the top level with helper functions of their own, they won’t see makeTest.\n\nbefore/after and beforeEach/afterEach\n\nWe can setup before/after functions that execute before/after running tests, and also beforeEach/afterEach functions that execute before/after every it.\n\nFor instance:\n\ndescribe(\"test\", function() {\n\n  before(() => alert(\"Testing started – before all tests\"));\n  after(() => alert(\"Testing finished – after all tests\"));\n\n  beforeEach(() => alert(\"Before a test – enter a test\"));\n  afterEach(() => alert(\"After a test – exit a test\"));\n\n  it('test 1', () => alert(1));\n  it('test 2', () => alert(2));\n\n});\n\nThe running sequence will be:\n\nTesting started – before all tests (before)\nBefore a test – enter a test (beforeEach)\n1\nAfter a test – exit a test   (afterEach)\nBefore a test – enter a test (beforeEach)\n2\nAfter a test – exit a test   (afterEach)\nTesting finished – after all tests (after)\nOpen the example in the sandbox.\n\nUsually, beforeEach/afterEach and before/after are used to perform initialization, zero out counters or do something else between the tests (or test groups).\n\nExtending the spec\n\nThe basic functionality of pow is complete. The first iteration of the development is done. When we’re done celebrating and drinking champagne – let’s go on and improve it.\n\nAs it was said, the function pow(x, n) is meant to work with positive integer values n.\n\nTo indicate a mathematical error, JavaScript functions usually return NaN. Let’s do the same for invalid values of n.\n\nLet’s first add the behavior to the spec(!):\n\ndescribe(\"pow\", function() {\n\n  // ...\n\n  it(\"for negative n the result is NaN\", function() {\n    assert.isNaN(pow(2, -1));\n  });\n\n  it(\"for non-integer n the result is NaN\", function() {\n    assert.isNaN(pow(2, 1.5));\n  });\n\n});\n\nThe result with new tests:\n\nThe newly added tests fail, because our implementation does not support them. That’s how BDD is done: first we write failing tests, and then make an implementation for them.\n\nOther assertions\n\nPlease note the assertion assert.isNaN: it checks for NaN.\n\nThere are other assertions in Chai as well, for instance:\n\nassert.equal(value1, value2) – checks the equality value1 == value2.\nassert.strictEqual(value1, value2) – checks the strict equality value1 === value2.\nassert.notEqual, assert.notStrictEqual – inverse checks to the ones above.\nassert.isTrue(value) – checks that value === true\nassert.isFalse(value) – checks that value === false\n…the full list is in the docs\n\nSo we should add a couple of lines to pow:\n\nfunction pow(x, n) {\n  if (n < 0) return NaN;\n  if (Math.round(n) != n) return NaN;\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nNow it works, all tests pass:\n\nOpen the full final example in the sandbox.\nSummary\n\nIn BDD, the spec goes first, followed by implementation. At the end we have both the spec and the code.\n\nThe spec can be used in three ways:\n\nAs Tests – they guarantee that the code works correctly.\nAs Docs – the titles of describe and it tell what the function does.\nAs Examples – the tests are actually working examples showing how a function can be used.\n\nWith the spec, we can safely improve, change, even rewrite the function from scratch and make sure it still works right.\n\nThat’s especially important in large projects when a function is used in many places. When we change such a function, there’s just no way to manually check if every place that uses it still works right.\n\nWithout tests, people have two ways:\n\nTo perform the change, no matter what. And then our users meet bugs, as we probably fail to check something manually.\nOr, if the punishment for errors is harsh, as there are no tests, people become afraid to modify such functions, and then the code becomes outdated, no one wants to get into it. Not good for development.\n\nAutomatic testing helps to avoid these problems!\n\nIf the project is covered with tests, there’s just no such problem. After any changes, we can run tests and see a lot of checks made in a matter of seconds.\n\nBesides, a well-tested code has better architecture.\n\nNaturally, that’s because auto-tested code is easier to modify and improve. But there’s also another reason.\n\nTo write tests, the code should be organized in such a way that every function has a clearly described task, well-defined input and output. That means a good architecture from the beginning.\n\nIn real life that’s sometimes not that easy. Sometimes it’s difficult to write a spec before the actual code, because it’s not yet clear how it should behave. But in general writing tests makes development faster and more stable.\n\nLater in the tutorial you will meet many tasks with tests baked-in. So you’ll see more practical examples.\n\nWriting tests requires good JavaScript knowledge. But we’re just starting to learn it. So, to settle down everything, as of now you’re not required to write tests, but you should already be able to read them even if they are a little bit more complex than in this chapter.\n\nTasks\nWhat's wrong in the test?\nimportance: 5\n\nWhat’s wrong in the test of pow below?\n\nit(\"Raises x to the power n\", function() {\n  let x = 5;\n\n  let result = x;\n  assert.equal(pow(x, 1), result);\n\n  result *= x;\n  assert.equal(pow(x, 2), result);\n\n  result *= x;\n  assert.equal(pow(x, 3), result);\n});\n\nP.S. Syntactically the test is correct and passes.\n\nsolution"
  },
  {
    "title": "Object references and copying",
    "url": "https://javascript.info/object-copy",
    "html": "One of the fundamental differences of objects versus primitives is that objects are stored and copied “by reference”, whereas primitive values: strings, numbers, booleans, etc – are always copied “as a whole value”.\n\nThat’s easy to understand if we look a bit under the hood of what happens when we copy a value.\n\nLet’s start with a primitive, such as a string.\n\nHere we put a copy of message into phrase:\n\nlet message = \"Hello!\";\nlet phrase = message;\n\nAs a result we have two independent variables, each one storing the string \"Hello!\".\n\nQuite an obvious result, right?\n\nObjects are not like that.\n\nA variable assigned to an object stores not the object itself, but its “address in memory” – in other words “a reference” to it.\n\nLet’s look at an example of such a variable:\n\nlet user = {\n  name: \"John\"\n};\n\nAnd here’s how it’s actually stored in memory:\n\nThe object is stored somewhere in memory (at the right of the picture), while the user variable (at the left) has a “reference” to it.\n\nWe may think of an object variable, such as user, like a sheet of paper with the address of the object on it.\n\nWhen we perform actions with the object, e.g. take a property user.name, the JavaScript engine looks at what’s at that address and performs the operation on the actual object.\n\nNow here’s why it’s important.\n\nWhen an object variable is copied, the reference is copied, but the object itself is not duplicated.\n\nFor instance:\n\nlet user = { name: \"John\" };\n\nlet admin = user; // copy the reference\n\nNow we have two variables, each storing a reference to the same object:\n\nAs you can see, there’s still one object, but now with two variables that reference it.\n\nWe can use either variable to access the object and modify its contents:\n\n\t\nlet user = { name: 'John' };\n\nlet admin = user;\n\nadmin.name = 'Pete'; // changed by the \"admin\" reference\n\nalert(user.name); // 'Pete', changes are seen from the \"user\" reference\n\nIt’s as if we had a cabinet with two keys and used one of them (admin) to get into it and make changes. Then, if we later use another key (user), we are still opening the same cabinet and can access the changed contents.\n\nComparison by reference\n\nTwo objects are equal only if they are the same object.\n\nFor instance, here a and b reference the same object, thus they are equal:\n\n\t\nlet a = {};\nlet b = a; // copy the reference\n\nalert( a == b ); // true, both variables reference the same object\nalert( a === b ); // true\n\nAnd here two independent objects are not equal, even though they look alike (both are empty):\n\n\t\nlet a = {};\nlet b = {}; // two independent objects\n\nalert( a == b ); // false\n\nFor comparisons like obj1 > obj2 or for a comparison against a primitive obj == 5, objects are converted to primitives. We’ll study how object conversions work very soon, but to tell the truth, such comparisons are needed very rarely – usually they appear as a result of a programming mistake.\n\nConst objects can be modified\n\nAn important side effect of storing objects as references is that an object declared as const can be modified.\n\nFor instance:\n\n\t\nconst user = {\n  name: \"John\"\n};\n\nuser.name = \"Pete\"; // (*)\n\nalert(user.name); // Pete\n\nIt might seem that the line (*) would cause an error, but it does not. The value of user is constant, it must always reference the same object, but properties of that object are free to change.\n\nIn other words, the const user gives an error only if we try to set user=... as a whole.\n\nThat said, if we really need to make constant object properties, it’s also possible, but using totally different methods. We’ll mention that in the chapter Property flags and descriptors.\n\nCloning and merging, Object.assign\n\nSo, copying an object variable creates one more reference to the same object.\n\nBut what if we need to duplicate an object?\n\nWe can create a new object and replicate the structure of the existing one, by iterating over its properties and copying them on the primitive level.\n\nLike this:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet clone = {}; // the new empty object\n\n// let's copy all user properties into it\nfor (let key in user) {\n  clone[key] = user[key];\n}\n\n// now clone is a fully independent object with the same content\nclone.name = \"Pete\"; // changed the data in it\n\nalert( user.name ); // still John in the original object\n\nWe can also use the method Object.assign.\n\nThe syntax is:\n\nObject.assign(dest, ...sources)\nThe first argument dest is a target object.\nFurther arguments is a list of source objects.\n\nIt copies the properties of all source objects into the target dest, and then returns it as the result.\n\nFor example, we have user object, let’s add a couple of permissions to it:\n\n\t\nlet user = { name: \"John\" };\n\nlet permissions1 = { canView: true };\nlet permissions2 = { canEdit: true };\n\n// copies all properties from permissions1 and permissions2 into user\nObject.assign(user, permissions1, permissions2);\n\n// now user = { name: \"John\", canView: true, canEdit: true }\nalert(user.name); // John\nalert(user.canView); // true\nalert(user.canEdit); // true\n\nIf the copied property name already exists, it gets overwritten:\n\n\t\nlet user = { name: \"John\" };\n\nObject.assign(user, { name: \"Pete\" });\n\nalert(user.name); // now user = { name: \"Pete\" }\n\nWe also can use Object.assign to perform a simple object cloning:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet clone = Object.assign({}, user);\n\nalert(clone.name); // John\nalert(clone.age); // 30\n\nHere it copies all properties of user into the empty object and returns it.\n\nThere are also other methods of cloning an object, e.g. using the spread syntax clone = {...user}, covered later in the tutorial.\n\nNested cloning\n\nUntil now we assumed that all properties of user are primitive. But properties can be references to other objects.\n\nLike this:\n\n\t\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nalert( user.sizes.height ); // 182\n\nNow it’s not enough to copy clone.sizes = user.sizes, because user.sizes is an object, and will be copied by reference, so clone and user will share the same sizes:\n\n\t\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nlet clone = Object.assign({}, user);\n\nalert( user.sizes === clone.sizes ); // true, same object\n\n// user and clone share sizes\nuser.sizes.width = 60;    // change a property from one place\nalert(clone.sizes.width); // 60, get the result from the other one\n\nTo fix that and make user and clone truly separate objects, we should use a cloning loop that examines each value of user[key] and, if it’s an object, then replicate its structure as well. That is called a “deep cloning” or “structured cloning”. There’s structuredClone method that implements deep cloning.\n\nstructuredClone\n\nThe call structuredClone(object) clones the object with all nested properties.\n\nHere’s how we can use it in our example:\n\n\t\nlet user = {\n  name: \"John\",\n  sizes: {\n    height: 182,\n    width: 50\n  }\n};\n\nlet clone = structuredClone(user);\n\nalert( user.sizes === clone.sizes ); // false, different objects\n\n// user and clone are totally unrelated now\nuser.sizes.width = 60;    // change a property from one place\nalert(clone.sizes.width); // 50, not related\n\nThe structuredClone method can clone most data types, such as objects, arrays, primitive values.\n\nIt also supports circular references, when an object property references the object itself (directly or via a chain or references).\n\nFor instance:\n\n\t\nlet user = {};\n// let's create a circular reference:\n// user.me references the user itself\nuser.me = user;\n\nlet clone = structuredClone(user);\nalert(clone.me === clone); // true\n\nAs you can see, clone.me references the clone, not the user! So the circular reference was cloned correctly as well.\n\nAlthough, there are cases when structuredClone fails.\n\nFor instance, when an object has a function property:\n\n\t\n// error\nstructuredClone({\n  f: function() {}\n});\n\nFunction properties aren’t supported.\n\nTo handle such complex cases we may need to use a combination of cloning methods, write custom code or, to not reinvent the wheel, take an existing implementation, for instance _.cloneDeep(obj) from the JavaScript library lodash.\n\nSummary\n\nObjects are assigned and copied by reference. In other words, a variable stores not the “object value”, but a “reference” (address in memory) for the value. So copying such a variable or passing it as a function argument copies that reference, not the object itself.\n\nAll operations via copied references (like adding/removing properties) are performed on the same single object.\n\nTo make a “real copy” (a clone) we can use Object.assign for the so-called “shallow copy” (nested objects are copied by reference) or a “deep cloning” function structuredClone or use a custom cloning implementation, such as _.cloneDeep(obj)."
  },
  {
    "title": "Objects",
    "url": "https://javascript.info/object",
    "html": "As we know from the chapter Data types, there are eight data types in JavaScript. Seven of them are called “primitive”, because their values contain only a single thing (be it a string or a number or whatever).\n\nIn contrast, objects are used to store keyed collections of various data and more complex entities. In JavaScript, objects penetrate almost every aspect of the language. So we must understand them first before going in-depth anywhere else.\n\nAn object can be created with figure brackets {…} with an optional list of properties. A property is a “key: value” pair, where key is a string (also called a “property name”), and value can be anything.\n\nWe can imagine an object as a cabinet with signed files. Every piece of data is stored in its file by the key. It’s easy to find a file by its name or add/remove a file.\n\nAn empty object (“empty cabinet”) can be created using one of two syntaxes:\n\nlet user = new Object(); // \"object constructor\" syntax\nlet user = {};  // \"object literal\" syntax\n\nUsually, the figure brackets {...} are used. That declaration is called an object literal.\n\nLiterals and properties\n\nWe can immediately put some properties into {...} as “key: value” pairs:\n\nlet user = {     // an object\n  name: \"John\",  // by key \"name\" store value \"John\"\n  age: 30        // by key \"age\" store value 30\n};\n\nA property has a key (also known as “name” or “identifier”) before the colon \":\" and a value to the right of it.\n\nIn the user object, there are two properties:\n\nThe first property has the name \"name\" and the value \"John\".\nThe second one has the name \"age\" and the value 30.\n\nThe resulting user object can be imagined as a cabinet with two signed files labeled “name” and “age”.\n\nWe can add, remove and read files from it at any time.\n\nProperty values are accessible using the dot notation:\n\n// get property values of the object:\nalert( user.name ); // John\nalert( user.age ); // 30\n\nThe value can be of any type. Let’s add a boolean one:\n\nuser.isAdmin = true;\n\nTo remove a property, we can use the delete operator:\n\ndelete user.age;\n\nWe can also use multiword property names, but then they must be quoted:\n\nlet user = {\n  name: \"John\",\n  age: 30,\n  \"likes birds\": true  // multiword property name must be quoted\n};\n\nThe last property in the list may end with a comma:\n\nlet user = {\n  name: \"John\",\n  age: 30,\n}\n\nThat is called a “trailing” or “hanging” comma. Makes it easier to add/remove/move around properties, because all lines become alike.\n\nSquare brackets\n\nFor multiword properties, the dot access doesn’t work:\n\n\t\n// this would give a syntax error\nuser.likes birds = true\n\nJavaScript doesn’t understand that. It thinks that we address user.likes, and then gives a syntax error when comes across unexpected birds.\n\nThe dot requires the key to be a valid variable identifier. That implies: contains no spaces, doesn’t start with a digit and doesn’t include special characters ($ and _ are allowed).\n\nThere’s an alternative “square bracket notation” that works with any string:\n\n\t\nlet user = {};\n\n// set\nuser[\"likes birds\"] = true;\n\n// get\nalert(user[\"likes birds\"]); // true\n\n// delete\ndelete user[\"likes birds\"];\n\nNow everything is fine. Please note that the string inside the brackets is properly quoted (any type of quotes will do).\n\nSquare brackets also provide a way to obtain the property name as the result of any expression – as opposed to a literal string – like from a variable as follows:\n\nlet key = \"likes birds\";\n\n// same as user[\"likes birds\"] = true;\nuser[key] = true;\n\nHere, the variable key may be calculated at run-time or depend on the user input. And then we use it to access the property. That gives us a great deal of flexibility.\n\nFor instance:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet key = prompt(\"What do you want to know about the user?\", \"name\");\n\n// access by variable\nalert( user[key] ); // John (if enter \"name\")\n\nThe dot notation cannot be used in a similar way:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet key = \"name\";\nalert( user.key ) // undefined\nComputed properties\n\nWe can use square brackets in an object literal, when creating an object. That’s called computed properties.\n\nFor instance:\n\n\t\nlet fruit = prompt(\"Which fruit to buy?\", \"apple\");\n\nlet bag = {\n  [fruit]: 5, // the name of the property is taken from the variable fruit\n};\n\nalert( bag.apple ); // 5 if fruit=\"apple\"\n\nThe meaning of a computed property is simple: [fruit] means that the property name should be taken from fruit.\n\nSo, if a visitor enters \"apple\", bag will become {apple: 5}.\n\nEssentially, that works the same as:\n\n\t\nlet fruit = prompt(\"Which fruit to buy?\", \"apple\");\nlet bag = {};\n\n// take property name from the fruit variable\nbag[fruit] = 5;\n\n…But looks nicer.\n\nWe can use more complex expressions inside square brackets:\n\nlet fruit = 'apple';\nlet bag = {\n  [fruit + 'Computers']: 5 // bag.appleComputers = 5\n};\n\nSquare brackets are much more powerful than dot notation. They allow any property names and variables. But they are also more cumbersome to write.\n\nSo most of the time, when property names are known and simple, the dot is used. And if we need something more complex, then we switch to square brackets.\n\nProperty value shorthand\n\nIn real code, we often use existing variables as values for property names.\n\nFor instance:\n\n\t\nfunction makeUser(name, age) {\n  return {\n    name: name,\n    age: age,\n    // ...other properties\n  };\n}\n\nlet user = makeUser(\"John\", 30);\nalert(user.name); // John\n\nIn the example above, properties have the same names as variables. The use-case of making a property from a variable is so common, that there’s a special property value shorthand to make it shorter.\n\nInstead of name:name we can just write name, like this:\n\nfunction makeUser(name, age) {\n  return {\n    name, // same as name: name\n    age,  // same as age: age\n    // ...\n  };\n}\n\nWe can use both normal properties and shorthands in the same object:\n\nlet user = {\n  name,  // same as name:name\n  age: 30\n};\nProperty names limitations\n\nAs we already know, a variable cannot have a name equal to one of the language-reserved words like “for”, “let”, “return” etc.\n\nBut for an object property, there’s no such restriction:\n\n\t\n// these properties are all right\nlet obj = {\n  for: 1,\n  let: 2,\n  return: 3\n};\n\nalert( obj.for + obj.let + obj.return );  // 6\n\nIn short, there are no limitations on property names. They can be any strings or symbols (a special type for identifiers, to be covered later).\n\nOther types are automatically converted to strings.\n\nFor instance, a number 0 becomes a string \"0\" when used as a property key:\n\n\t\nlet obj = {\n  0: \"test\" // same as \"0\": \"test\"\n};\n\n// both alerts access the same property (the number 0 is converted to string \"0\")\nalert( obj[\"0\"] ); // test\nalert( obj[0] ); // test (same property)\n\nThere’s a minor gotcha with a special property named __proto__. We can’t set it to a non-object value:\n\n\t\nlet obj = {};\nobj.__proto__ = 5; // assign a number\nalert(obj.__proto__); // [object Object] - the value is an object, didn't work as intended\n\nAs we see from the code, the assignment to a primitive 5 is ignored.\n\nWe’ll cover the special nature of __proto__ in subsequent chapters, and suggest the ways to fix such behavior.\n\nProperty existence test, “in” operator\n\nA notable feature of objects in JavaScript, compared to many other languages, is that it’s possible to access any property. There will be no error if the property doesn’t exist!\n\nReading a non-existing property just returns undefined. So we can easily test whether the property exists:\n\n\t\nlet user = {};\n\nalert( user.noSuchProperty === undefined ); // true means \"no such property\"\n\nThere’s also a special operator \"in\" for that.\n\nThe syntax is:\n\n\"key\" in object\n\nFor instance:\n\n\t\nlet user = { name: \"John\", age: 30 };\n\nalert( \"age\" in user ); // true, user.age exists\nalert( \"blabla\" in user ); // false, user.blabla doesn't exist\n\nPlease note that on the left side of in there must be a property name. That’s usually a quoted string.\n\nIf we omit quotes, that means a variable should contain the actual name to be tested. For instance:\n\n\t\nlet user = { age: 30 };\n\nlet key = \"age\";\nalert( key in user ); // true, property \"age\" exists\n\nWhy does the in operator exist? Isn’t it enough to compare against undefined?\n\nWell, most of the time the comparison with undefined works fine. But there’s a special case when it fails, but \"in\" works correctly.\n\nIt’s when an object property exists, but stores undefined:\n\n\t\nlet obj = {\n  test: undefined\n};\n\nalert( obj.test ); // it's undefined, so - no such property?\n\nalert( \"test\" in obj ); // true, the property does exist!\n\nIn the code above, the property obj.test technically exists. So the in operator works right.\n\nSituations like this happen very rarely, because undefined should not be explicitly assigned. We mostly use null for “unknown” or “empty” values. So the in operator is an exotic guest in the code.\n\nThe \"for..in\" loop\n\nTo walk over all keys of an object, there exists a special form of the loop: for..in. This is a completely different thing from the for(;;) construct that we studied before.\n\nThe syntax:\n\nfor (key in object) {\n  // executes the body for each key among object properties\n}\n\nFor instance, let’s output all properties of user:\n\n\t\nlet user = {\n  name: \"John\",\n  age: 30,\n  isAdmin: true\n};\n\nfor (let key in user) {\n  // keys\n  alert( key );  // name, age, isAdmin\n  // values for the keys\n  alert( user[key] ); // John, 30, true\n}\n\nNote that all “for” constructs allow us to declare the looping variable inside the loop, like let key here.\n\nAlso, we could use another variable name here instead of key. For instance, \"for (let prop in obj)\" is also widely used.\n\nOrdered like an object\n\nAre objects ordered? In other words, if we loop over an object, do we get all properties in the same order they were added? Can we rely on this?\n\nThe short answer is: “ordered in a special fashion”: integer properties are sorted, others appear in creation order. The details follow.\n\nAs an example, let’s consider an object with the phone codes:\n\n\t\nlet codes = {\n  \"49\": \"Germany\",\n  \"41\": \"Switzerland\",\n  \"44\": \"Great Britain\",\n  // ..,\n  \"1\": \"USA\"\n};\n\nfor (let code in codes) {\n  alert(code); // 1, 41, 44, 49\n}\n\nThe object may be used to suggest a list of options to the user. If we’re making a site mainly for a German audience then we probably want 49 to be the first.\n\nBut if we run the code, we see a totally different picture:\n\nUSA (1) goes first\nthen Switzerland (41) and so on.\n\nThe phone codes go in the ascending sorted order, because they are integers. So we see 1, 41, 44, 49.\n\nInteger properties? What’s that?\n\nThe “integer property” term here means a string that can be converted to-and-from an integer without a change.\n\nSo, \"49\" is an integer property name, because when it’s transformed to an integer number and back, it’s still the same. But \"+49\" and \"1.2\" are not:\n\n\t\n// Number(...) explicitly converts to a number\n// Math.trunc is a built-in function that removes the decimal part\nalert( String(Math.trunc(Number(\"49\"))) ); // \"49\", same, integer property\nalert( String(Math.trunc(Number(\"+49\"))) ); // \"49\", not same \"+49\" ⇒ not integer property\nalert( String(Math.trunc(Number(\"1.2\"))) ); // \"1\", not same \"1.2\" ⇒ not integer property\n\n…On the other hand, if the keys are non-integer, then they are listed in the creation order, for instance:\n\n\t\nlet user = {\n  name: \"John\",\n  surname: \"Smith\"\n};\nuser.age = 25; // add one more\n\n// non-integer properties are listed in the creation order\nfor (let prop in user) {\n  alert( prop ); // name, surname, age\n}\n\nSo, to fix the issue with the phone codes, we can “cheat” by making the codes non-integer. Adding a plus \"+\" sign before each code is enough.\n\nLike this:\n\n\t\nlet codes = {\n  \"+49\": \"Germany\",\n  \"+41\": \"Switzerland\",\n  \"+44\": \"Great Britain\",\n  // ..,\n  \"+1\": \"USA\"\n};\n\nfor (let code in codes) {\n  alert( +code ); // 49, 41, 44, 1\n}\n\nNow it works as intended.\n\nSummary\n\nObjects are associative arrays with several special features.\n\nThey store properties (key-value pairs), where:\n\nProperty keys must be strings or symbols (usually strings).\nValues can be of any type.\n\nTo access a property, we can use:\n\nThe dot notation: obj.property.\nSquare brackets notation obj[\"property\"]. Square brackets allow taking the key from a variable, like obj[varWithKey].\n\nAdditional operators:\n\nTo delete a property: delete obj.prop.\nTo check if a property with the given key exists: \"key\" in obj.\nTo iterate over an object: for (let key in obj) loop.\n\nWhat we’ve studied in this chapter is called a “plain object”, or just Object.\n\nThere are many other kinds of objects in JavaScript:\n\nArray to store ordered data collections,\nDate to store the information about the date and time,\nError to store the information about an error.\n…And so on.\n\nThey have their special features that we’ll study later. Sometimes people say something like “Array type” or “Date type”, but formally they are not types of their own, but belong to a single “object” data type. And they extend it in various ways.\n\nObjects in JavaScript are very powerful. Here we’ve just scratched the surface of a topic that is really huge. We’ll be closely working with objects and learning more about them in further parts of the tutorial.\n\nTasks\nHello, object\nimportance: 5\n\nWrite the code, one line for each action:\n\nCreate an empty object user.\nAdd the property name with the value John.\nAdd the property surname with the value Smith.\nChange the value of the name to Pete.\nRemove the property name from the object.\nsolution\nCheck for emptiness\nimportance: 5\n\nWrite the function isEmpty(obj) which returns true if the object has no properties, false otherwise.\n\nShould work like that:\n\nlet schedule = {};\n\nalert( isEmpty(schedule) ); // true\n\nschedule[\"8:30\"] = \"get up\";\n\nalert( isEmpty(schedule) ); // false\n\nOpen a sandbox with tests.\n\nsolution\nSum object properties\nimportance: 5\n\nWe have an object storing salaries of our team:\n\nlet salaries = {\n  John: 100,\n  Ann: 160,\n  Pete: 130\n}\n\nWrite the code to sum all salaries and store in the variable sum. Should be 390 in the example above.\n\nIf salaries is empty, then the result must be 0.\n\nsolution\nMultiply numeric property values by 2\nimportance: 3\n\nCreate a function multiplyNumeric(obj) that multiplies all numeric property values of obj by 2.\n\nFor instance:\n\n// before the call\nlet menu = {\n  width: 200,\n  height: 300,\n  title: \"My menu\"\n};\n\nmultiplyNumeric(menu);\n\n// after the call\nmenu = {\n  width: 400,\n  height: 600,\n  title: \"My menu\"\n};\n\nPlease note that multiplyNumeric does not need to return anything. It should modify the object in-place.\n\nP.S. Use typeof to check for a number here.\n\nOpen a sandbox with tests.\n\nsolution"
  },
  {
    "title": "Objects: the basics",
    "url": "https://javascript.info/object-basics",
    "html": "Objects\nObject references and copying\nGarbage collection\nObject methods, \"this\"\nConstructor, operator \"new\"\nOptional chaining '?.'\nSymbol type\nObject to primitive conversion"
  },
  {
    "title": "Polyfills and transpilers",
    "url": "https://javascript.info/polyfills",
    "html": "The JavaScript language steadily evolves. New proposals to the language appear regularly, they are analyzed and, if considered worthy, are appended to the list at https://tc39.github.io/ecma262/ and then progress to the specification.\n\nTeams behind JavaScript engines have their own ideas about what to implement first. They may decide to implement proposals that are in draft and postpone things that are already in the spec, because they are less interesting or just harder to do.\n\nSo it’s quite common for an engine to implement only part of the standard.\n\nA good page to see the current state of support for language features is https://kangax.github.io/compat-table/es6/ (it’s big, we have a lot to study yet).\n\nAs programmers, we’d like to use most recent features. The more good stuff – the better!\n\nOn the other hand, how to make our modern code work on older engines that don’t understand recent features yet?\n\nThere are two tools for that:\n\nTranspilers.\nPolyfills.\n\nHere, in this chapter, our purpose is to get the gist of how they work, and their place in web development.\n\nTranspilers\n\nA transpiler is a special piece of software that translates source code to another source code. It can parse (“read and understand”) modern code and rewrite it using older syntax constructs, so that it’ll also work in outdated engines.\n\nE.g. JavaScript before year 2020 didn’t have the “nullish coalescing operator” ??. So, if a visitor uses an outdated browser, it may fail to understand the code like height = height ?? 100.\n\nA transpiler would analyze our code and rewrite height ?? 100 into (height !== undefined && height !== null) ? height : 100.\n\n// before running the transpiler\nheight = height ?? 100;\n\n// after running the transpiler\nheight = (height !== undefined && height !== null) ? height : 100;\n\nNow the rewritten code is suitable for older JavaScript engines.\n\nUsually, a developer runs the transpiler on their own computer, and then deploys the transpiled code to the server.\n\nSpeaking of names, Babel is one of the most prominent transpilers out there.\n\nModern project build systems, such as webpack, provide a means to run a transpiler automatically on every code change, so it’s very easy to integrate into the development process.\n\nPolyfills\n\nNew language features may include not only syntax constructs and operators, but also built-in functions.\n\nFor example, Math.trunc(n) is a function that “cuts off” the decimal part of a number, e.g Math.trunc(1.23) returns 1.\n\nIn some (very outdated) JavaScript engines, there’s no Math.trunc, so such code will fail.\n\nAs we’re talking about new functions, not syntax changes, there’s no need to transpile anything here. We just need to declare the missing function.\n\nA script that updates/adds new functions is called “polyfill”. It “fills in” the gap and adds missing implementations.\n\nFor this particular case, the polyfill for Math.trunc is a script that implements it, like this:\n\nif (!Math.trunc) { // if no such function\n  // implement it\n  Math.trunc = function(number) {\n    // Math.ceil and Math.floor exist even in ancient JavaScript engines\n    // they are covered later in the tutorial\n    return number < 0 ? Math.ceil(number) : Math.floor(number);\n  };\n}\n\nJavaScript is a highly dynamic language. Scripts may add/modify any function, even built-in ones.\n\nTwo interesting polyfill libraries are:\n\ncore js that supports a lot, allows to include only needed features.\npolyfill.io service that provides a script with polyfills, depending on the features and user’s browser.\nSummary\n\nIn this chapter we’d like to motivate you to study modern and even “bleeding-edge” language features, even if they aren’t yet well-supported by JavaScript engines.\n\nJust don’t forget to use a transpiler (if using modern syntax or operators) and polyfills (to add functions that may be missing). They’ll ensure that the code works.\n\nFor example, later when you’re familiar with JavaScript, you can setup a code build system based on webpack with the babel-loader plugin.\n\nGood resources that show the current state of support for various features:\n\nhttps://kangax.github.io/compat-table/es6/ – for pure JavaScript.\nhttps://caniuse.com/ – for browser-related functions.\n\nP.S. Google Chrome is usually the most up-to-date with language features, try it if a tutorial demo fails. Most tutorial demos work with any modern browser though."
  },
  {
    "title": "Ninja code",
    "url": "https://javascript.info/ninja-code",
    "html": "Learning without thought is labor lost; thought without learning is perilous.\n\nConfucius (Analects)\n\nProgrammer ninjas of the past used these tricks to sharpen the mind of code maintainers.\n\nCode review gurus look for them in test tasks.\n\nNovice developers sometimes use them even better than programmer ninjas.\n\nRead them carefully and find out who you are – a ninja, a novice, or maybe a code reviewer?\n\nIrony detected\n\nMany try to follow ninja paths. Few succeed.\n\nBrevity is the soul of wit\n\nMake the code as short as possible. Show how smart you are.\n\nLet subtle language features guide you.\n\nFor instance, take a look at this ternary operator '?':\n\n// taken from a well-known javascript library\ni = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n\nCool, right? If you write like that, a developer who comes across this line and tries to understand what is the value of i is going to have a merry time. Then come to you, seeking for an answer.\n\nTell them that shorter is always better. Initiate them into the paths of ninja.\n\nOne-letter variables\n\nThe Dao hides in wordlessness. Only the Dao is well begun and well completed.\n\nLaozi (Tao Te Ching)\n\nAnother way to code shorter is to use single-letter variable names everywhere. Like a, b or c.\n\nA short variable disappears in the code like a real ninja in the forest. No one will be able to find it using “search” of the editor. And even if someone does, they won’t be able to “decipher” what the name a or b means.\n\n…But there’s an exception. A real ninja will never use i as the counter in a \"for\" loop. Anywhere, but not here. Look around, there are many more exotic letters. For instance, x or y.\n\nAn exotic variable as a loop counter is especially cool if the loop body takes 1-2 pages (make it longer if you can). Then if someone looks deep inside the loop, they won’t be able to quickly figure out that the variable named x is the loop counter.\n\nUse abbreviations\n\nIf the team rules forbid the use of one-letter and vague names – shorten them, make abbreviations.\n\nLike this:\n\nlist → lst.\nuserAgent → ua.\nbrowser → brsr.\n…etc\n\nOnly the one with truly good intuition will be able to understand such names. Try to shorten everything. Only a worthy person should be able to uphold the development of your code.\n\nSoar high. Be abstract.\n\nThe great square is cornerless\nThe great vessel is last complete,\nThe great note is rarified sound,\nThe great image has no form.\n\nLaozi (Tao Te Ching)\n\nWhile choosing a name try to use the most abstract word. Like obj, data, value, item, elem and so on.\n\nThe ideal name for a variable is data. Use it everywhere you can. Indeed, every variable holds data, right?\n\n…But what to do if data is already taken? Try value, it’s also universal. After all, a variable eventually gets a value.\n\nName a variable by its type: str, num…\n\nGive them a try. A young initiate may wonder – are such names really useful for a ninja? Indeed, they are!\n\nSure, the variable name still means something. It says what’s inside the variable: a string, a number or something else. But when an outsider tries to understand the code, they’ll be surprised to see that there’s actually no information at all! And will ultimately fail to alter your well-thought code.\n\nThe value type is easy to find out by debugging. But what’s the meaning of the variable? Which string/number does it store?\n\nThere’s just no way to figure out without a good meditation!\n\n…But what if there are no more such names? Just add a number: data1, item2, elem5…\n\nAttention test\n\nOnly a truly attentive programmer should be able to understand your code. But how to check that?\n\nOne of the ways – use similar variable names, like date and data.\n\nMix them where you can.\n\nA quick read of such code becomes impossible. And when there’s a typo… Ummm… We’re stuck for long, time to drink tea.\n\nSmart synonyms\n\nThe Tao that can be told is not the eternal Tao. The name that can be named is not the eternal name.\n\nLaozi (Tao Te Ching)\n\nUsing similar names for same things makes life more interesting and shows your creativity to the public.\n\nFor instance, consider function prefixes. If a function shows a message on the screen – start it with display…, like displayMessage. And then if another function shows on the screen something else, like a user name, start it with show… (like showName).\n\nInsinuate that there’s a subtle difference between such functions, while there is none.\n\nMake a pact with fellow ninjas of the team: if John starts “showing” functions with display... in his code, then Peter could use render.., and Ann – paint.... Note how much more interesting and diverse the code became.\n\n…And now the hat trick!\n\nFor two functions with important differences – use the same prefix!\n\nFor instance, the function printPage(page) will use a printer. And the function printText(text) will put the text on-screen. Let an unfamiliar reader think well over similarly named function printMessage: “Where does it put the message? To a printer or on the screen?”. To make it really shine, printMessage(message) should output it in the new window!\n\nReuse names\n\nOnce the whole is divided, the parts\nneed names.\nThere are already enough names.\nOne must know when to stop.\n\nLaozi (Tao Te Ching)\n\nAdd a new variable only when absolutely necessary.\n\nInstead, reuse existing names. Just write new values into them.\n\nIn a function try to use only variables passed as parameters.\n\nThat would make it really hard to identify what’s exactly in the variable now. And also where it comes from. The purpose is to develop the intuition and memory of a person reading the code. A person with weak intuition would have to analyze the code line-by-line and track the changes through every code branch.\n\nAn advanced variant of the approach is to covertly (!) replace the value with something alike in the middle of a loop or a function.\n\nFor instance:\n\nfunction ninjaFunction(elem) {\n  // 20 lines of code working with elem\n\n  elem = clone(elem);\n\n  // 20 more lines, now working with the clone of the elem!\n}\n\nA fellow programmer who wants to work with elem in the second half of the function will be surprised… Only during the debugging, after examining the code they will find out that they’re working with a clone!\n\nSeen in code regularly. Deadly effective even against an experienced ninja.\n\nUnderscores for fun\n\nPut underscores _ and __ before variable names. Like _name or __value. It would be great if only you knew their meaning. Or, better, add them just for fun, without particular meaning at all. Or different meanings in different places.\n\nYou kill two rabbits with one shot. First, the code becomes longer and less readable, and the second, a fellow developer may spend a long time trying to figure out what the underscores mean.\n\nA smart ninja puts underscores at one spot of code and evades them at other places. That makes the code even more fragile and increases the probability of future errors.\n\nShow your love\n\nLet everyone see how magnificent your entities are! Names like superElement, megaFrame and niceItem will definitely enlighten a reader.\n\nIndeed, from one hand, something is written: super.., mega.., nice.. But from the other hand – that brings no details. A reader may decide to look for a hidden meaning and meditate for an hour or two of their paid working time.\n\nOverlap outer variables\n\nWhen in the light, can’t see anything in the darkness.\nWhen in the darkness, can see everything in the light.\n\nGuan Yin Zi\n\nUse same names for variables inside and outside a function. As simple. No efforts to invent new names.\n\nlet user = authenticateUser();\n\nfunction render() {\n  let user = anotherValue();\n  ...\n  ...many lines...\n  ...\n  ... // <-- a programmer wants to work with user here and...\n  ...\n}\n\nA programmer who jumps inside the render will probably fail to notice that there’s a local user shadowing the outer one.\n\nThen they’ll try to work with user assuming that it’s the external variable, the result of authenticateUser()… The trap is sprung! Hello, debugger…\n\nSide-effects everywhere!\n\nThere are functions that look like they don’t change anything. Like isReady(), checkPermission(), findTags()… They are assumed to carry out calculations, find and return the data, without changing anything outside of them. In other words, without “side-effects”.\n\nA really beautiful trick is to add a “useful” action to them, besides the main task.\n\nAn expression of dazed surprise on the face of your colleague when they see a function named is.., check.. or find... changing something – will definitely broaden your boundaries of reason.\n\nAnother way to surprise is to return a non-standard result.\n\nShow your original thinking! Let the call of checkPermission return not true/false, but a complex object with the results of the check.\n\nThose developers who try to write if (checkPermission(..)), will wonder why it doesn’t work. Tell them: “Read the docs!”. And give this article.\n\nPowerful functions!\n\nThe great Tao flows everywhere,\nboth to the left and to the right.\n\nLaozi (Tao Te Ching)\n\nDon’t limit the function by what’s written in its name. Be broader.\n\nFor instance, a function validateEmail(email) could (besides checking the email for correctness) show an error message and ask to re-enter the email.\n\nAdditional actions should not be obvious from the function name. A true ninja coder will make them not obvious from the code as well.\n\nJoining several actions into one protects your code from reuse.\n\nImagine, another developer wants only to check the email, and not output any message. Your function validateEmail(email) that does both will not suit them. So they won’t break your meditation by asking anything about it.\n\nSummary\n\nAll “pieces of advice” above are from the real code… Sometimes, written by experienced developers. Maybe even more experienced than you are ;)\n\nFollow some of them, and your code will become full of surprises.\nFollow many of them, and your code will become truly yours, no one would want to change it.\nFollow all, and your code will become a valuable lesson for young developers looking for enlightenment."
  },
  {
    "title": "Comments",
    "url": "https://javascript.info/comments",
    "html": "As we know from the chapter Code structure, comments can be single-line: starting with // and multiline: /* ... */.\n\nWe normally use them to describe how and why the code works.\n\nAt first sight, commenting might be obvious, but novices in programming often use them wrongly.\n\nBad comments\n\nNovices tend to use comments to explain “what is going on in the code”. Like this:\n\n// This code will do this thing (...) and that thing (...)\n// ...and who knows what else...\nvery;\ncomplex;\ncode;\n\nBut in good code, the amount of such “explanatory” comments should be minimal. Seriously, the code should be easy to understand without them.\n\nThere’s a great rule about that: “if the code is so unclear that it requires a comment, then maybe it should be rewritten instead”.\n\nRecipe: factor out functions\n\nSometimes it’s beneficial to replace a code piece with a function, like here:\n\nfunction showPrimes(n) {\n  nextPrime:\n  for (let i = 2; i < n; i++) {\n\n    // check if i is a prime number\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert(i);\n  }\n}\n\nThe better variant, with a factored out function isPrime:\n\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    if (!isPrime(i)) continue;\n\n    alert(i);\n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if (n % i == 0) return false;\n  }\n\n  return true;\n}\n\nNow we can understand the code easily. The function itself becomes the comment. Such code is called self-descriptive.\n\nRecipe: create functions\n\nAnd if we have a long “code sheet” like this:\n\n// here we add whiskey\nfor(let i = 0; i < 10; i++) {\n  let drop = getWhiskey();\n  smell(drop);\n  add(drop, glass);\n}\n\n// here we add juice\nfor(let t = 0; t < 3; t++) {\n  let tomato = getTomato();\n  examine(tomato);\n  let juice = press(tomato);\n  add(juice, glass);\n}\n\n// ...\n\nThen it might be a better variant to refactor it into functions like:\n\naddWhiskey(glass);\naddJuice(glass);\n\nfunction addWhiskey(container) {\n  for(let i = 0; i < 10; i++) {\n    let drop = getWhiskey();\n    //...\n  }\n}\n\nfunction addJuice(container) {\n  for(let t = 0; t < 3; t++) {\n    let tomato = getTomato();\n    //...\n  }\n}\n\nOnce again, functions themselves tell what’s going on. There’s nothing to comment. And also the code structure is better when split. It’s clear what every function does, what it takes and what it returns.\n\nIn reality, we can’t totally avoid “explanatory” comments. There are complex algorithms. And there are smart “tweaks” for purposes of optimization. But generally we should try to keep the code simple and self-descriptive.\n\nGood comments\n\nSo, explanatory comments are usually bad. Which comments are good?\n\nDescribe the architecture\nProvide a high-level overview of components, how they interact, what’s the control flow in various situations… In short – the bird’s eye view of the code. There’s a special language UML to build high-level architecture diagrams explaining the code. Definitely worth studying.\nDocument function parameters and usage\nThere’s a special syntax JSDoc to document a function: usage, parameters, returned value.\n\nFor instance:\n\n/**\n * Returns x raised to the n-th power.\n *\n * @param {number} x The number to raise.\n * @param {number} n The power, must be a natural number.\n * @return {number} x raised to the n-th power.\n */\nfunction pow(x, n) {\n  ...\n}\n\nSuch comments allow us to understand the purpose of the function and use it the right way without looking in its code.\n\nBy the way, many editors like WebStorm can understand them as well and use them to provide autocomplete and some automatic code-checking.\n\nAlso, there are tools like JSDoc 3 that can generate HTML-documentation from the comments. You can read more information about JSDoc at https://jsdoc.app.\n\nWhy is the task solved this way?\n\nWhat’s written is important. But what’s not written may be even more important to understand what’s going on. Why is the task solved exactly this way? The code gives no answer.\n\nIf there are many ways to solve the task, why this one? Especially when it’s not the most obvious one.\n\nWithout such comments the following situation is possible:\n\nYou (or your colleague) open the code written some time ago, and see that it’s “suboptimal”.\nYou think: “How stupid I was then, and how much smarter I’m now”, and rewrite using the “more obvious and correct” variant.\n…The urge to rewrite was good. But in the process you see that the “more obvious” solution is actually lacking. You even dimly remember why, because you already tried it long ago. You revert to the correct variant, but the time was wasted.\n\nComments that explain the solution are very important. They help to continue development the right way.\n\nAny subtle features of the code? Where they are used?\n\nIf the code has anything subtle and counter-intuitive, it’s definitely worth commenting.\n\nSummary\n\nAn important sign of a good developer is comments: their presence and even their absence.\n\nGood comments allow us to maintain the code well, come back to it after a delay and use it more effectively.\n\nComment this:\n\nOverall architecture, high-level view.\nFunction usage.\nImportant solutions, especially when not immediately obvious.\n\nAvoid comments:\n\nThat tell “how code works” and “what it does”.\nPut them in only if it’s impossible to make the code so simple and self-descriptive that it doesn’t require them.\n\nComments are also used for auto-documenting tools like JSDoc3: they read them and generate HTML-docs (or docs in another format)."
  },
  {
    "title": "Coding Style",
    "url": "https://javascript.info/coding-style",
    "html": "Our code must be as clean and easy to read as possible.\n\nThat is actually the art of programming – to take a complex task and code it in a way that is both correct and human-readable. A good code style greatly assists in that.\n\nSyntax\n\nHere is a cheat sheet with some suggested rules (see below for more details):\n\nNow let’s discuss the rules and reasons for them in detail.\n\nThere are no “you must” rules\n\nNothing is set in stone here. These are style preferences, not religious dogmas.\n\nCurly Braces\n\nIn most JavaScript projects curly braces are written in “Egyptian” style with the opening brace on the same line as the corresponding keyword – not on a new line. There should also be a space before the opening bracket, like this:\n\nif (condition) {\n  // do this\n  // ...and that\n  // ...and that\n}\n\nA single-line construct, such as if (condition) doSomething(), is an important edge case. Should we use braces at all?\n\nHere are the annotated variants so you can judge their readability for yourself:\n\n😠 Beginners sometimes do that. Bad! Curly braces are not needed:\nif (n < 0) {alert(`Power ${n} is not supported`);}\n😠 Split to a separate line without braces. Never do that, easy to make an error when adding new lines:\nif (n < 0)\n  alert(`Power ${n} is not supported`);\n😏 One line without braces – acceptable, if it’s short:\nif (n < 0) alert(`Power ${n} is not supported`);\n😃 The best variant:\nif (n < 0) {\n  alert(`Power ${n} is not supported`);\n}\n\nFor a very brief code, one line is allowed, e.g. if (cond) return null. But a code block (the last variant) is usually more readable.\n\nLine Length\n\nNo one likes to read a long horizontal line of code. It’s best practice to split them.\n\nFor example:\n\n// backtick quotes ` allow to split the string into multiple lines\nlet str = `\n  ECMA International's TC39 is a group of JavaScript developers,\n  implementers, academics, and more, collaborating with the community\n  to maintain and evolve the definition of JavaScript.\n`;\n\nAnd, for if statements:\n\nif (\n  id === 123 &&\n  moonPhase === 'Waning Gibbous' &&\n  zodiacSign === 'Libra'\n) {\n  letTheSorceryBegin();\n}\n\nThe maximum line length should be agreed upon at the team-level. It’s usually 80 or 120 characters.\n\nIndents\n\nThere are two types of indents:\n\nHorizontal indents: 2 or 4 spaces.\n\nA horizontal indentation is made using either 2 or 4 spaces or the horizontal tab symbol (key Tab). Which one to choose is an old holy war. Spaces are more common nowadays.\n\nOne advantage of spaces over tabs is that spaces allow more flexible configurations of indents than the tab symbol.\n\nFor instance, we can align the parameters with the opening bracket, like this:\n\nshow(parameters,\n     aligned, // 5 spaces padding at the left\n     one,\n     after,\n     another\n  ) {\n  // ...\n}\n\nVertical indents: empty lines for splitting code into logical blocks.\n\nEven a single function can often be divided into logical blocks. In the example below, the initialization of variables, the main loop and returning the result are split vertically:\n\nfunction pow(x, n) {\n  let result = 1;\n  //              <--\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n  //              <--\n  return result;\n}\n\nInsert an extra newline where it helps to make the code more readable. There should not be more than nine lines of code without a vertical indentation.\n\nSemicolons\n\nA semicolon should be present after each statement, even if it could possibly be skipped.\n\nThere are languages where a semicolon is truly optional and it is rarely used. In JavaScript, though, there are cases where a line break is not interpreted as a semicolon, leaving the code vulnerable to errors. See more about that in the chapter Code structure.\n\nIf you’re an experienced JavaScript programmer, you may choose a no-semicolon code style like StandardJS. Otherwise, it’s best to use semicolons to avoid possible pitfalls. The majority of developers put semicolons.\n\nNesting Levels\n\nTry to avoid nesting code too many levels deep.\n\nFor example, in the loop, it’s sometimes a good idea to use the continue directive to avoid extra nesting.\n\nFor example, instead of adding a nested if conditional like this:\n\nfor (let i = 0; i < 10; i++) {\n  if (cond) {\n    ... // <- one more nesting level\n  }\n}\n\nWe can write:\n\nfor (let i = 0; i < 10; i++) {\n  if (!cond) continue;\n  ...  // <- no extra nesting level\n}\n\nA similar thing can be done with if/else and return.\n\nFor example, two constructs below are identical.\n\nOption 1:\n\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n  } else {\n    let result = 1;\n\n    for (let i = 0; i < n; i++) {\n      result *= x;\n    }\n\n    return result;\n  }\n}\n\nOption 2:\n\nfunction pow(x, n) {\n  if (n < 0) {\n    alert(\"Negative 'n' not supported\");\n    return;\n  }\n\n  let result = 1;\n\n  for (let i = 0; i < n; i++) {\n    result *= x;\n  }\n\n  return result;\n}\n\nThe second one is more readable because the “special case” of n < 0 is handled early on. Once the check is done we can move on to the “main” code flow without the need for additional nesting.\n\nFunction Placement\n\nIf you are writing several “helper” functions and the code that uses them, there are three ways to organize the functions.\n\nDeclare the functions above the code that uses them:\n\n// function declarations\nfunction createElement() {\n  ...\n}\n\nfunction setHandler(elem) {\n  ...\n}\n\nfunction walkAround() {\n  ...\n}\n\n// the code which uses them\nlet elem = createElement();\nsetHandler(elem);\nwalkAround();\n\nCode first, then functions\n\n// the code which uses the functions\nlet elem = createElement();\nsetHandler(elem);\nwalkAround();\n\n// --- helper functions ---\nfunction createElement() {\n  ...\n}\n\nfunction setHandler(elem) {\n  ...\n}\n\nfunction walkAround() {\n  ...\n}\n\nMixed: a function is declared where it’s first used.\n\nMost of time, the second variant is preferred.\n\nThat’s because when reading code, we first want to know what it does. If the code goes first, then it becomes clear from the start. Then, maybe we won’t need to read the functions at all, especially if their names are descriptive of what they actually do.\n\nStyle Guides\n\nA style guide contains general rules about “how to write” code, e.g. which quotes to use, how many spaces to indent, the maximal line length, etc. A lot of minor things.\n\nWhen all members of a team use the same style guide, the code looks uniform, regardless of which team member wrote it.\n\nOf course, a team can always write their own style guide, but usually there’s no need to. There are many existing guides to choose from.\n\nSome popular choices:\n\nGoogle JavaScript Style Guide\nAirbnb JavaScript Style Guide\nIdiomatic.JS\nStandardJS\n(plus many more)\n\nIf you’re a novice developer, start with the cheat sheet at the beginning of this chapter. Then you can browse other style guides to pick up more ideas and decide which one you like best.\n\nAutomated Linters\n\nLinters are tools that can automatically check the style of your code and make improving suggestions.\n\nThe great thing about them is that style-checking can also find some bugs, like typos in variable or function names. Because of this feature, using a linter is recommended even if you don’t want to stick to one particular “code style”.\n\nHere are some well-known linting tools:\n\nJSLint – one of the first linters.\nJSHint – more settings than JSLint.\nESLint – probably the newest one.\n\nAll of them can do the job. The author uses ESLint.\n\nMost linters are integrated with many popular editors: just enable the plugin in the editor and configure the style.\n\nFor instance, for ESLint you should do the following:\n\nInstall Node.js.\nInstall ESLint with the command npm install -g eslint (npm is a JavaScript package installer).\nCreate a config file named .eslintrc in the root of your JavaScript project (in the folder that contains all your files).\nInstall/enable the plugin for your editor that integrates with ESLint. The majority of editors have one.\n\nHere’s an example of an .eslintrc file:\n\n{\n  \"extends\": \"eslint:recommended\",\n  \"env\": {\n    \"browser\": true,\n    \"node\": true,\n    \"es6\": true\n  },\n  \"rules\": {\n    \"no-console\": 0,\n    \"indent\": 2\n  }\n}\n\nHere the directive \"extends\" denotes that the configuration is based on the “eslint:recommended” set of settings. After that, we specify our own.\n\nIt is also possible to download style rule sets from the web and extend them instead. See https://eslint.org/docs/user-guide/getting-started for more details about installation.\n\nAlso certain IDEs have built-in linting, which is convenient but not as customizable as ESLint.\n\nSummary\n\nAll syntax rules described in this chapter (and in the style guides referenced) aim to increase the readability of your code. All of them are debatable.\n\nWhen we think about writing “better” code, the questions we should ask ourselves are: “What makes the code more readable and easier to understand?” and “What can help us avoid errors?” These are the main things to keep in mind when choosing and debating code styles.\n\nReading popular style guides will allow you to keep up to date with the latest ideas about code style trends and best practices.\n\nTasks\nBad style\nimportance: 4\n\nWhat’s wrong with the code style below?\n\nfunction pow(x,n)\n{\n  let result=1;\n  for(let i=0;i<n;i++) {result*=x;}\n  return result;\n}\n\nlet x=prompt(\"x?\",''), n=prompt(\"n?\",'')\nif (n<=0)\n{\n  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);\n}\nelse\n{\n  alert(pow(x,n))\n}\n\nFix it.\n\nsolution"
  },
  {
    "title": "Debugging in the browser",
    "url": "https://javascript.info/debugging-chrome",
    "html": "Before writing more complex code, let’s talk about debugging.\n\nDebugging is the process of finding and fixing errors within a script. All modern browsers and most other environments support debugging tools – a special UI in developer tools that makes debugging much easier. It also allows to trace the code step by step to see what exactly is going on.\n\nWe’ll be using Chrome here, because it has enough features, most other browsers have a similar process.\n\nThe “Sources” panel\n\nYour Chrome version may look a little bit different, but it still should be obvious what’s there.\n\nOpen the example page in Chrome.\nTurn on developer tools with F12 (Mac: Cmd+Opt+I).\nSelect the Sources panel.\n\nHere’s what you should see if you are doing it for the first time:\n\nThe toggler button  opens the tab with files.\n\nLet’s click it and select hello.js in the tree view. Here’s what should show up:\n\nThe Sources panel has 3 parts:\n\nThe File Navigator pane lists HTML, JavaScript, CSS and other files, including images that are attached to the page. Chrome extensions may appear here too.\nThe Code Editor pane shows the source code.\nThe JavaScript Debugging pane is for debugging, we’ll explore it soon.\n\nNow you could click the same toggler  again to hide the resources list and give the code some space.\n\nConsole\n\nIf we press Esc, then a console opens below. We can type commands there and press Enter to execute.\n\nAfter a statement is executed, its result is shown below.\n\nFor example, here 1+2 results in 3, while the function call hello(\"debugger\") returns nothing, so the result is undefined:\n\nBreakpoints\n\nLet’s examine what’s going on within the code of the example page. In hello.js, click at line number 4. Yes, right on the 4 digit, not on the code.\n\nCongratulations! You’ve set a breakpoint. Please also click on the number for line 8.\n\nIt should look like this (blue is where you should click):\n\nA breakpoint is a point of code where the debugger will automatically pause the JavaScript execution.\n\nWhile the code is paused, we can examine current variables, execute commands in the console etc. In other words, we can debug it.\n\nWe can always find a list of breakpoints in the right panel. That’s useful when we have many breakpoints in various files. It allows us to:\n\nQuickly jump to the breakpoint in the code (by clicking on it in the right panel).\nTemporarily disable the breakpoint by unchecking it.\nRemove the breakpoint by right-clicking and selecting Remove.\n…And so on.\nConditional breakpoints\n\nRight click on the line number allows to create a conditional breakpoint. It only triggers when the given expression, that you should provide when you create it, is truthy.\n\nThat’s handy when we need to stop only for a certain variable value or for certain function parameters.\n\nThe command “debugger”\n\nWe can also pause the code by using the debugger command in it, like this:\n\nfunction hello(name) {\n  let phrase = `Hello, ${name}!`;\n\n  debugger;  // <-- the debugger stops here\n\n  say(phrase);\n}\n\nSuch command works only when the development tools are open, otherwise the browser ignores it.\n\nPause and look around\n\nIn our example, hello() is called during the page load, so the easiest way to activate the debugger (after we’ve set the breakpoints) is to reload the page. So let’s press F5 (Windows, Linux) or Cmd+R (Mac).\n\nAs the breakpoint is set, the execution pauses at the 4th line:\n\nPlease open the informational dropdowns to the right (labeled with arrows). They allow you to examine the current code state:\n\nWatch – shows current values for any expressions.\n\nYou can click the plus + and input an expression. The debugger will show its value, automatically recalculating it in the process of execution.\n\nCall Stack – shows the nested calls chain.\n\nAt the current moment the debugger is inside hello() call, called by a script in index.html (no function there, so it’s called “anonymous”).\n\nIf you click on a stack item (e.g. “anonymous”), the debugger jumps to the corresponding code, and all its variables can be examined as well.\n\nScope – current variables.\n\nLocal shows local function variables. You can also see their values highlighted right over the source.\n\nGlobal has global variables (out of any functions).\n\nThere’s also this keyword there that we didn’t study yet, but we’ll do that soon.\n\nTracing the execution\n\nNow it’s time to trace the script.\n\nThere are buttons for it at the top of the right panel. Let’s engage them.\n\n – “Resume”: continue the execution, hotkey F8.\n\nResumes the execution. If there are no additional breakpoints, then the execution just continues and the debugger loses control.\n\nHere’s what we can see after a click on it:\n\nThe execution has resumed, reached another breakpoint inside say() and paused there. Take a look at the “Call Stack” at the right. It has increased by one more call. We’re inside say() now.\n\n – “Step”: run the next command, hotkey F9.\n\nRun the next statement. If we click it now, alert will be shown.\n\nClicking this again and again will step through all script statements one by one.\n\n – “Step over”: run the next command, but don’t go into a function, hotkey F10.\n\nSimilar to the previous “Step” command, but behaves differently if the next statement is a function call (not a built-in, like alert, but a function of our own).\n\nIf we compare them, the “Step” command goes into a nested function call and pauses the execution at its first line, while “Step over” executes the nested function call invisibly to us, skipping the function internals.\n\nThe execution is then paused immediately after that function call.\n\nThat’s good if we’re not interested to see what happens inside the function call.\n\n – “Step into”, hotkey F11.\n\nThat’s similar to “Step”, but behaves differently in case of asynchronous function calls. If you’re only starting to learn JavaScript, then you can ignore the difference, as we don’t have asynchronous calls yet.\n\nFor the future, just note that “Step” command ignores async actions, such as setTimeout (scheduled function call), that execute later. The “Step into” goes into their code, waiting for them if necessary. See DevTools manual for more details.\n\n – “Step out”: continue the execution till the end of the current function, hotkey Shift+F11.\n\nContinue the execution and stop it at the very last line of the current function. That’s handy when we accidentally entered a nested call using , but it does not interest us, and we want to continue to its end as soon as possible.\n\n – enable/disable all breakpoints.\n\nThat button does not move the execution. Just a mass on/off for breakpoints.\n\n – enable/disable automatic pause in case of an error.\n\nWhen enabled, if the developer tools is open, an error during the script execution automatically pauses it. Then we can analyze variables in the debugger to see what went wrong. So if our script dies with an error, we can open debugger, enable this option and reload the page to see where it dies and what’s the context at that moment.\n\nContinue to here\n\nRight click on a line of code opens the context menu with a great option called “Continue to here”.\n\nThat’s handy when we want to move multiple steps forward to the line, but we’re too lazy to set a breakpoint.\n\nLogging\n\nTo output something to console from our code, there’s console.log function.\n\nFor instance, this outputs values from 0 to 4 to console:\n\n\t\n// open console to see\nfor (let i = 0; i < 5; i++) {\n  console.log(\"value,\", i);\n}\n\nRegular users don’t see that output, it is in the console. To see it, either open the Console panel of developer tools or press Esc while in another panel: that opens the console at the bottom.\n\nIf we have enough logging in our code, then we can see what’s going on from the records, without the debugger.\n\nSummary\n\nAs we can see, there are three main ways to pause a script:\n\nA breakpoint.\nThe debugger statements.\nAn error (if dev tools are open and the button  is “on”).\n\nWhen paused, we can debug: examine variables and trace the code to see where the execution goes wrong.\n\nThere are many more options in developer tools than covered here. The full manual is at https://developers.google.com/web/tools/chrome-devtools.\n\nThe information from this chapter is enough to begin debugging, but later, especially if you do a lot of browser stuff, please go there and look through more advanced capabilities of developer tools.\n\nOh, and also you can click at various places of dev tools and just see what’s showing up. That’s probably the fastest route to learn dev tools. Don’t forget about the right click and context menus!"
  },
  {
    "title": "JavaScript specials",
    "url": "https://javascript.info/javascript-specials",
    "html": "This chapter briefly recaps the features of JavaScript that we’ve learned by now, paying special attention to subtle moments.\n\nCode structure\n\nStatements are delimited with a semicolon:\n\n\t\nalert('Hello'); alert('World');\n\nUsually, a line-break is also treated as a delimiter, so that would also work:\n\n\t\nalert('Hello')\nalert('World')\n\nThat’s called “automatic semicolon insertion”. Sometimes it doesn’t work, for instance:\n\n\t\nalert(\"There will be an error after this message\")\n\n[1, 2].forEach(alert)\n\nMost codestyle guides agree that we should put a semicolon after each statement.\n\nSemicolons are not required after code blocks {...} and syntax constructs with them like loops:\n\nfunction f() {\n  // no semicolon needed after function declaration\n}\n\nfor(;;) {\n  // no semicolon needed after the loop\n}\n\n…But even if we can put an “extra” semicolon somewhere, that’s not an error. It will be ignored.\n\nMore in: Code structure.\n\nStrict mode\n\nTo fully enable all features of modern JavaScript, we should start scripts with \"use strict\".\n\n'use strict';\n\n...\n\nThe directive must be at the top of a script or at the beginning of a function body.\n\nWithout \"use strict\", everything still works, but some features behave in the old-fashioned, “compatible” way. We’d generally prefer the modern behavior.\n\nSome modern features of the language (like classes that we’ll study in the future) enable strict mode implicitly.\n\nMore in: The modern mode, \"use strict\".\n\nVariables\n\nCan be declared using:\n\nlet\nconst (constant, can’t be changed)\nvar (old-style, will see later)\n\nA variable name can include:\n\nLetters and digits, but the first character may not be a digit.\nCharacters $ and _ are normal, on par with letters.\nNon-Latin alphabets and hieroglyphs are also allowed, but commonly not used.\n\nVariables are dynamically typed. They can store any value:\n\nlet x = 5;\nx = \"John\";\n\nThere are 8 data types:\n\nnumber for both floating-point and integer numbers,\nbigint for integer numbers of arbitrary length,\nstring for strings,\nboolean for logical values: true/false,\nnull – a type with a single value null, meaning “empty” or “does not exist”,\nundefined – a type with a single value undefined, meaning “not assigned”,\nobject and symbol – for complex data structures and unique identifiers, we haven’t learnt them yet.\n\nThe typeof operator returns the type for a value, with two exceptions:\n\ntypeof null == \"object\" // error in the language\ntypeof function(){} == \"function\" // functions are treated specially\n\nMore in: Variables and Data types.\n\nInteraction\n\nWe’re using a browser as a working environment, so basic UI functions will be:\n\nprompt(question, [default])\nAsk a question, and return either what the visitor entered or null if they clicked “cancel”.\nconfirm(question)\nAsk a question and suggest to choose between Ok and Cancel. The choice is returned as true/false.\nalert(message)\nOutput a message.\n\nAll these functions are modal, they pause the code execution and prevent the visitor from interacting with the page until they answer.\n\nFor instance:\n\n\t\nlet userName = prompt(\"Your name?\", \"Alice\");\nlet isTeaWanted = confirm(\"Do you want some tea?\");\n\nalert( \"Visitor: \" + userName ); // Alice\nalert( \"Tea wanted: \" + isTeaWanted ); // true\n\nMore in: Interaction: alert, prompt, confirm.\n\nOperators\n\nJavaScript supports the following operators:\n\nArithmetical\n\nRegular: * + - /, also % for the remainder and ** for power of a number.\n\nThe binary plus + concatenates strings. And if any of the operands is a string, the other one is converted to string too:\n\n\t\nalert( '1' + 2 ); // '12', string\nalert( 1 + '2' ); // '12', string\nAssignments\n\nThere is a simple assignment: a = b and combined ones like a *= 2.\n\nBitwise\n\nBitwise operators work with 32-bit integers at the lowest, bit-level: see the docs when they are needed.\n\nConditional\n\nThe only operator with three parameters: cond ? resultA : resultB. If cond is truthy, returns resultA, otherwise resultB.\n\nLogical operators\n\nLogical AND && and OR || perform short-circuit evaluation and then return the value where it stopped (not necessary true/false). Logical NOT ! converts the operand to boolean type and returns the inverse value.\n\nNullish coalescing operator\n\nThe ?? operator provides a way to choose a defined value from a list of variables. The result of a ?? b is a unless it’s null/undefined, then b.\n\nComparisons\n\nEquality check == for values of different types converts them to a number (except null and undefined that equal each other and nothing else), so these are equal:\n\n\t\nalert( 0 == false ); // true\nalert( 0 == '' ); // true\n\nOther comparisons convert to a number as well.\n\nThe strict equality operator === doesn’t do the conversion: different types always mean different values for it.\n\nValues null and undefined are special: they equal == each other and don’t equal anything else.\n\nGreater/less comparisons compare strings character-by-character, other types are converted to a number.\n\nOther operators\n\nThere are few others, like a comma operator.\n\nMore in: Basic operators, maths, Comparisons, Logical operators, Nullish coalescing operator '??'.\n\nLoops\n\nWe covered 3 types of loops:\n\n// 1\nwhile (condition) {\n  ...\n}\n\n// 2\ndo {\n  ...\n} while (condition);\n\n// 3\nfor(let i = 0; i < 10; i++) {\n  ...\n}\n\nThe variable declared in for(let...) loop is visible only inside the loop. But we can also omit let and reuse an existing variable.\n\nDirectives break/continue allow to exit the whole loop/current iteration. Use labels to break nested loops.\n\nDetails in: Loops: while and for.\n\nLater we’ll study more types of loops to deal with objects.\n\nThe “switch” construct\n\nThe “switch” construct can replace multiple if checks. It uses === (strict equality) for comparisons.\n\nFor instance:\n\n\t\nlet age = prompt('Your age?', 18);\n\nswitch (age) {\n  case 18:\n    alert(\"Won't work\"); // the result of prompt is a string, not a number\n    break;\n\n  case \"18\":\n    alert(\"This works!\");\n    break;\n\n  default:\n    alert(\"Any value not equal to one above\");\n}\n\nDetails in: The \"switch\" statement.\n\nFunctions\n\nWe covered three ways to create a function in JavaScript:\n\nFunction Declaration: the function in the main code flow\n\nfunction sum(a, b) {\n  let result = a + b;\n\n  return result;\n}\n\nFunction Expression: the function in the context of an expression\n\nlet sum = function(a, b) {\n  let result = a + b;\n\n  return result;\n};\n\nArrow functions:\n\n// expression on the right side\nlet sum = (a, b) => a + b;\n\n// or multi-line syntax with { ... }, need return here:\nlet sum = (a, b) => {\n  // ...\n  return a + b;\n}\n\n// without arguments\nlet sayHi = () => alert(\"Hello\");\n\n// with a single argument\nlet double = n => n * 2;\nFunctions may have local variables: those declared inside its body or its parameter list. Such variables are only visible inside the function.\nParameters can have default values: function sum(a = 1, b = 2) {...}.\nFunctions always return something. If there’s no return statement, then the result is undefined.\n\nDetails: see Functions, Arrow functions, the basics.\n\nMore to come\n\nThat was a brief list of JavaScript features. As of now we’ve studied only basics. Further in the tutorial you’ll find more specials and advanced features of JavaScript."
  },
  {
    "title": "Code quality",
    "url": "https://javascript.info/code-quality",
    "html": "This chapter explains coding practices that we’ll use further in the development.\n\nDebugging in the browser\nCoding Style\nComments\nNinja code\nAutomated testing with Mocha\nPolyfills and transpilers"
  },
  {
    "title": "Arrow functions, the basics",
    "url": "https://javascript.info/arrow-functions-basics",
    "html": "There’s another very simple and concise syntax for creating functions, that’s often better than Function Expressions.\n\nIt’s called “arrow functions”, because it looks like this:\n\nlet func = (arg1, arg2, ..., argN) => expression;\n\nThis creates a function func that accepts arguments arg1..argN, then evaluates the expression on the right side with their use and returns its result.\n\nIn other words, it’s the shorter version of:\n\nlet func = function(arg1, arg2, ..., argN) {\n  return expression;\n};\n\nLet’s see a concrete example:\n\n\t\nlet sum = (a, b) => a + b;\n\n/* This arrow function is a shorter form of:\n\nlet sum = function(a, b) {\n  return a + b;\n};\n*/\n\nalert( sum(1, 2) ); // 3\n\nAs you can see, (a, b) => a + b means a function that accepts two arguments named a and b. Upon the execution, it evaluates the expression a + b and returns the result.\n\nIf we have only one argument, then parentheses around parameters can be omitted, making that even shorter.\n\nFor example:\n\n\t\nlet double = n => n * 2;\n// roughly the same as: let double = function(n) { return n * 2 }\n\nalert( double(3) ); // 6\n\nIf there are no arguments, parentheses are empty, but they must be present:\n\n\t\nlet sayHi = () => alert(\"Hello!\");\n\nsayHi();\n\nArrow functions can be used in the same way as Function Expressions.\n\nFor instance, to dynamically create a function:\n\n\t\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome = (age < 18) ?\n  () => alert('Hello!') :\n  () => alert(\"Greetings!\");\n\nwelcome();\n\nArrow functions may appear unfamiliar and not very readable at first, but that quickly changes as the eyes get used to the structure.\n\nThey are very convenient for simple one-line actions, when we’re just too lazy to write many words.\n\nMultiline arrow functions\n\nThe arrow functions that we’ve seen so far were very simple. They took arguments from the left of =>, evaluated and returned the right-side expression with them.\n\nSometimes we need a more complex function, with multiple expressions and statements. In that case, we can enclose them in curly braces. The major difference is that curly braces require a return within them to return a value (just like a regular function does).\n\nLike this:\n\n\t\nlet sum = (a, b) => {  // the curly brace opens a multiline function\n  let result = a + b;\n  return result; // if we use curly braces, then we need an explicit \"return\"\n};\n\nalert( sum(1, 2) ); // 3\nMore to come\n\nHere we praised arrow functions for brevity. But that’s not all!\n\nArrow functions have other interesting features.\n\nTo study them in-depth, we first need to get to know some other aspects of JavaScript, so we’ll return to arrow functions later in the chapter Arrow functions revisited.\n\nFor now, we can already use arrow functions for one-line actions and callbacks.\n\nSummary\n\nArrow functions are handy for simple actions, especially for one-liners. They come in two flavors:\n\nWithout curly braces: (...args) => expression – the right side is an expression: the function evaluates it and returns the result. Parentheses can be omitted, if there’s only a single argument, e.g. n => n*2.\nWith curly braces: (...args) => { body } – brackets allow us to write multiple statements inside the function, but we need an explicit return to return something.\nTasks\nRewrite with arrow functions\n\nReplace Function Expressions with arrow functions in the code below:\n\n\t\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes();\n  else no();\n}\n\nask(\n  \"Do you agree?\",\n  function() { alert(\"You agreed.\"); },\n  function() { alert(\"You canceled the execution.\"); }\n);\nsolution"
  },
  {
    "title": "Function expressions",
    "url": "https://javascript.info/function-expressions",
    "html": "In JavaScript, a function is not a “magical language structure”, but a special kind of value.\n\nThe syntax that we used before is called a Function Declaration:\n\nfunction sayHi() {\n  alert( \"Hello\" );\n}\n\nThere is another syntax for creating a function that is called a Function Expression.\n\nIt allows us to create a new function in the middle of any expression.\n\nFor example:\n\nlet sayHi = function() {\n  alert( \"Hello\" );\n};\n\nHere we can see a variable sayHi getting a value, the new function, created as function() { alert(\"Hello\"); }.\n\nAs the function creation happens in the context of the assignment expression (to the right side of =), this is a Function Expression.\n\nPlease note, there’s no name after the function keyword. Omitting a name is allowed for Function Expressions.\n\nHere we immediately assign it to the variable, so the meaning of these code samples is the same: \"create a function and put it into the variable sayHi\".\n\nIn more advanced situations, that we’ll come across later, a function may be created and immediately called or scheduled for a later execution, not stored anywhere, thus remaining anonymous.\n\nFunction is a value\n\nLet’s reiterate: no matter how the function is created, a function is a value. Both examples above store a function in the sayHi variable.\n\nWe can even print out that value using alert:\n\n\t\nfunction sayHi() {\n  alert( \"Hello\" );\n}\n\nalert( sayHi ); // shows the function code\n\nPlease note that the last line does not run the function, because there are no parentheses after sayHi. There are programming languages where any mention of a function name causes its execution, but JavaScript is not like that.\n\nIn JavaScript, a function is a value, so we can deal with it as a value. The code above shows its string representation, which is the source code.\n\nSurely, a function is a special value, in the sense that we can call it like sayHi().\n\nBut it’s still a value. So we can work with it like with other kinds of values.\n\nWe can copy a function to another variable:\n\n\t\nfunction sayHi() {   // (1) create\n  alert( \"Hello\" );\n}\n\nlet func = sayHi;    // (2) copy\n\nfunc(); // Hello     // (3) run the copy (it works)!\nsayHi(); // Hello    //     this still works too (why wouldn't it)\n\nHere’s what happens above in detail:\n\nThe Function Declaration (1) creates the function and puts it into the variable named sayHi.\nLine (2) copies it into the variable func. Please note again: there are no parentheses after sayHi. If there were, then func = sayHi() would write the result of the call sayHi() into func, not the function sayHi itself.\nNow the function can be called as both sayHi() and func().\n\nWe could also have used a Function Expression to declare sayHi, in the first line:\n\nlet sayHi = function() { // (1) create\n  alert( \"Hello\" );\n};\n\nlet func = sayHi;\n// ...\n\nEverything would work the same.\n\nWhy is there a semicolon at the end?\n\nYou might wonder, why do Function Expressions have a semicolon ; at the end, but Function Declarations do not:\n\nfunction sayHi() {\n  // ...\n}\n\nlet sayHi = function() {\n  // ...\n};\n\nThe answer is simple: a Function Expression is created here as function(…) {…} inside the assignment statement: let sayHi = …;. The semicolon ; is recommended at the end of the statement, it’s not a part of the function syntax.\n\nThe semicolon would be there for a simpler assignment, such as let sayHi = 5;, and it’s also there for a function assignment.\n\nCallback functions\n\nLet’s look at more examples of passing functions as values and using function expressions.\n\nWe’ll write a function ask(question, yes, no) with three parameters:\n\nquestion\nText of the question\nyes\nFunction to run if the answer is “Yes”\nno\nFunction to run if the answer is “No”\n\nThe function should ask the question and, depending on the user’s answer, call yes() or no():\n\n\t\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nfunction showOk() {\n  alert( \"You agreed.\" );\n}\n\nfunction showCancel() {\n  alert( \"You canceled the execution.\" );\n}\n\n// usage: functions showOk, showCancel are passed as arguments to ask\nask(\"Do you agree?\", showOk, showCancel);\n\nIn practice, such functions are quite useful. The major difference between a real-life ask and the example above is that real-life functions use more complex ways to interact with the user than a simple confirm. In the browser, such functions usually draw a nice-looking question window. But that’s another story.\n\nThe arguments showOk and showCancel of ask are called callback functions or just callbacks.\n\nThe idea is that we pass a function and expect it to be “called back” later if necessary. In our case, showOk becomes the callback for “yes” answer, and showCancel for “no” answer.\n\nWe can use Function Expressions to write an equivalent, shorter function:\n\n\t\nfunction ask(question, yes, no) {\n  if (confirm(question)) yes()\n  else no();\n}\n\nask(\n  \"Do you agree?\",\n  function() { alert(\"You agreed.\"); },\n  function() { alert(\"You canceled the execution.\"); }\n);\n\nHere, functions are declared right inside the ask(...) call. They have no name, and so are called anonymous. Such functions are not accessible outside of ask (because they are not assigned to variables), but that’s just what we want here.\n\nSuch code appears in our scripts very naturally, it’s in the spirit of JavaScript.\n\nA function is a value representing an “action”\n\nRegular values like strings or numbers represent the data.\n\nA function can be perceived as an action.\n\nWe can pass it between variables and run when we want.\n\nFunction Expression vs Function Declaration\n\nLet’s formulate the key differences between Function Declarations and Expressions.\n\nFirst, the syntax: how to differentiate between them in the code.\n\nFunction Declaration: a function, declared as a separate statement, in the main code flow:\n\n// Function Declaration\nfunction sum(a, b) {\n  return a + b;\n}\n\nFunction Expression: a function, created inside an expression or inside another syntax construct. Here, the function is created on the right side of the “assignment expression” =:\n\n// Function Expression\nlet sum = function(a, b) {\n  return a + b;\n};\n\nThe more subtle difference is when a function is created by the JavaScript engine.\n\nA Function Expression is created when the execution reaches it and is usable only from that moment.\n\nOnce the execution flow passes to the right side of the assignment let sum = function… – here we go, the function is created and can be used (assigned, called, etc. ) from now on.\n\nFunction Declarations are different.\n\nA Function Declaration can be called earlier than it is defined.\n\nFor example, a global Function Declaration is visible in the whole script, no matter where it is.\n\nThat’s due to internal algorithms. When JavaScript prepares to run the script, it first looks for global Function Declarations in it and creates the functions. We can think of it as an “initialization stage”.\n\nAnd after all Function Declarations are processed, the code is executed. So it has access to these functions.\n\nFor example, this works:\n\n\t\nsayHi(\"John\"); // Hello, John\n\nfunction sayHi(name) {\n  alert( `Hello, ${name}` );\n}\n\nThe Function Declaration sayHi is created when JavaScript is preparing to start the script and is visible everywhere in it.\n\n…If it were a Function Expression, then it wouldn’t work:\n\n\t\nsayHi(\"John\"); // error!\n\nlet sayHi = function(name) {  // (*) no magic any more\n  alert( `Hello, ${name}` );\n};\n\nFunction Expressions are created when the execution reaches them. That would happen only in the line (*). Too late.\n\nAnother special feature of Function Declarations is their block scope.\n\nIn strict mode, when a Function Declaration is within a code block, it’s visible everywhere inside that block. But not outside of it.\n\nFor instance, let’s imagine that we need to declare a function welcome() depending on the age variable that we get during runtime. And then we plan to use it some time later.\n\nIf we use Function Declaration, it won’t work as intended:\n\n\t\nlet age = prompt(\"What is your age?\", 18);\n\n// conditionally declare a function\nif (age < 18) {\n\n  function welcome() {\n    alert(\"Hello!\");\n  }\n\n} else {\n\n  function welcome() {\n    alert(\"Greetings!\");\n  }\n\n}\n\n// ...use it later\nwelcome(); // Error: welcome is not defined\n\nThat’s because a Function Declaration is only visible inside the code block in which it resides.\n\nHere’s another example:\n\n\t\nlet age = 16; // take 16 as an example\n\nif (age < 18) {\n  welcome();               // \\   (runs)\n                           //  |\n  function welcome() {     //  |\n    alert(\"Hello!\");       //  |  Function Declaration is available\n  }                        //  |  everywhere in the block where it's declared\n                           //  |\n  welcome();               // /   (runs)\n\n} else {\n\n  function welcome() {\n    alert(\"Greetings!\");\n  }\n}\n\n// Here we're out of curly braces,\n// so we can not see Function Declarations made inside of them.\n\nwelcome(); // Error: welcome is not defined\n\nWhat can we do to make welcome visible outside of if?\n\nThe correct approach would be to use a Function Expression and assign welcome to the variable that is declared outside of if and has the proper visibility.\n\nThis code works as intended:\n\n\t\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome;\n\nif (age < 18) {\n\n  welcome = function() {\n    alert(\"Hello!\");\n  };\n\n} else {\n\n  welcome = function() {\n    alert(\"Greetings!\");\n  };\n\n}\n\nwelcome(); // ok now\n\nOr we could simplify it even further using a question mark operator ?:\n\n\t\nlet age = prompt(\"What is your age?\", 18);\n\nlet welcome = (age < 18) ?\n  function() { alert(\"Hello!\"); } :\n  function() { alert(\"Greetings!\"); };\n\nwelcome(); // ok now\nWhen to choose Function Declaration versus Function Expression?\n\nAs a rule of thumb, when we need to declare a function, the first thing to consider is Function Declaration syntax. It gives more freedom in how to organize our code, because we can call such functions before they are declared.\n\nThat’s also better for readability, as it’s easier to look up function f(…) {…} in the code than let f = function(…) {…};. Function Declarations are more “eye-catching”.\n\n…But if a Function Declaration does not suit us for some reason, or we need a conditional declaration (we’ve just seen an example), then Function Expression should be used.\n\nSummary\nFunctions are values. They can be assigned, copied or declared in any place of the code.\nIf the function is declared as a separate statement in the main code flow, that’s called a “Function Declaration”.\nIf the function is created as a part of an expression, it’s called a “Function Expression”.\nFunction Declarations are processed before the code block is executed. They are visible everywhere in the block.\nFunction Expressions are created when the execution flow reaches them.\n\nIn most cases when we need to declare a function, a Function Declaration is preferable, because it is visible prior to the declaration itself. That gives us more flexibility in code organization, and is usually more readable.\n\nSo we should use a Function Expression only when a Function Declaration is not fit for the task. We’ve seen a couple of examples of that in this chapter, and will see more in the future."
  },
  {
    "title": "Functions",
    "url": "https://javascript.info/function-basics",
    "html": "Quite often we need to perform a similar action in many places of the script.\n\nFor example, we need to show a nice-looking message when a visitor logs in, logs out and maybe somewhere else.\n\nFunctions are the main “building blocks” of the program. They allow the code to be called many times without repetition.\n\nWe’ve already seen examples of built-in functions, like alert(message), prompt(message, default) and confirm(question). But we can create functions of our own as well.\n\nFunction Declaration\n\nTo create a function we can use a function declaration.\n\nIt looks like this:\n\nfunction showMessage() {\n  alert( 'Hello everyone!' );\n}\n\nThe function keyword goes first, then goes the name of the function, then a list of parameters between the parentheses (comma-separated, empty in the example above, we’ll see examples later) and finally the code of the function, also named “the function body”, between curly braces.\n\nfunction name(parameter1, parameter2, ... parameterN) {\n // body\n}\n\nOur new function can be called by its name: showMessage().\n\nFor instance:\n\n\t\nfunction showMessage() {\n  alert( 'Hello everyone!' );\n}\n\nshowMessage();\nshowMessage();\n\nThe call showMessage() executes the code of the function. Here we will see the message two times.\n\nThis example clearly demonstrates one of the main purposes of functions: to avoid code duplication.\n\nIf we ever need to change the message or the way it is shown, it’s enough to modify the code in one place: the function which outputs it.\n\nLocal variables\n\nA variable declared inside a function is only visible inside that function.\n\nFor example:\n\n\t\nfunction showMessage() {\n  let message = \"Hello, I'm JavaScript!\"; // local variable\n\n  alert( message );\n}\n\nshowMessage(); // Hello, I'm JavaScript!\n\nalert( message ); // <-- Error! The variable is local to the function\nOuter variables\n\nA function can access an outer variable as well, for example:\n\n\t\nlet userName = 'John';\n\nfunction showMessage() {\n  let message = 'Hello, ' + userName;\n  alert(message);\n}\n\nshowMessage(); // Hello, John\n\nThe function has full access to the outer variable. It can modify it as well.\n\nFor instance:\n\n\t\nlet userName = 'John';\n\nfunction showMessage() {\n  userName = \"Bob\"; // (1) changed the outer variable\n\n  let message = 'Hello, ' + userName;\n  alert(message);\n}\n\nalert( userName ); // John before the function call\n\nshowMessage();\n\nalert( userName ); // Bob, the value was modified by the function\n\nThe outer variable is only used if there’s no local one.\n\nIf a same-named variable is declared inside the function then it shadows the outer one. For instance, in the code below the function uses the local userName. The outer one is ignored:\n\n\t\nlet userName = 'John';\n\nfunction showMessage() {\n  let userName = \"Bob\"; // declare a local variable\n\n  let message = 'Hello, ' + userName; // Bob\n  alert(message);\n}\n\n// the function will create and use its own userName\nshowMessage();\n\nalert( userName ); // John, unchanged, the function did not access the outer variable\nGlobal variables\n\nVariables declared outside of any function, such as the outer userName in the code above, are called global.\n\nGlobal variables are visible from any function (unless shadowed by locals).\n\nIt’s a good practice to minimize the use of global variables. Modern code has few or no globals. Most variables reside in their functions. Sometimes though, they can be useful to store project-level data.\n\nParameters\n\nWe can pass arbitrary data to functions using parameters.\n\nIn the example below, the function has two parameters: from and text.\n\n\t\nfunction showMessage(from, text) { // parameters: from, text\n  alert(from + ': ' + text);\n}\n\nshowMessage('Ann', 'Hello!'); // Ann: Hello! (*)\nshowMessage('Ann', \"What's up?\"); // Ann: What's up? (**)\n\nWhen the function is called in lines (*) and (**), the given values are copied to local variables from and text. Then the function uses them.\n\nHere’s one more example: we have a variable from and pass it to the function. Please note: the function changes from, but the change is not seen outside, because a function always gets a copy of the value:\n\n\t\nfunction showMessage(from, text) {\n\n  from = '*' + from + '*'; // make \"from\" look nicer\n\n  alert( from + ': ' + text );\n}\n\nlet from = \"Ann\";\n\nshowMessage(from, \"Hello\"); // *Ann*: Hello\n\n// the value of \"from\" is the same, the function modified a local copy\nalert( from ); // Ann\n\nWhen a value is passed as a function parameter, it’s also called an argument.\n\nIn other words, to put these terms straight:\n\nA parameter is the variable listed inside the parentheses in the function declaration (it’s a declaration time term).\nAn argument is the value that is passed to the function when it is called (it’s a call time term).\n\nWe declare functions listing their parameters, then call them passing arguments.\n\nIn the example above, one might say: \"the function showMessage is declared with two parameters, then called with two arguments: from and \"Hello\"\".\n\nDefault values\n\nIf a function is called, but an argument is not provided, then the corresponding value becomes undefined.\n\nFor instance, the aforementioned function showMessage(from, text) can be called with a single argument:\n\nshowMessage(\"Ann\");\n\nThat’s not an error. Such a call would output \"*Ann*: undefined\". As the value for text isn’t passed, it becomes undefined.\n\nWe can specify the so-called “default” (to use if omitted) value for a parameter in the function declaration, using =:\n\n\t\nfunction showMessage(from, text = \"no text given\") {\n  alert( from + \": \" + text );\n}\n\nshowMessage(\"Ann\"); // Ann: no text given\n\nNow if the text parameter is not passed, it will get the value \"no text given\".\n\nThe default value also jumps in if the parameter exists, but strictly equals undefined, like this:\n\nshowMessage(\"Ann\", undefined); // Ann: no text given\n\nHere \"no text given\" is a string, but it can be a more complex expression, which is only evaluated and assigned if the parameter is missing. So, this is also possible:\n\n\t\nfunction showMessage(from, text = anotherFunction()) {\n  // anotherFunction() only executed if no text given\n  // its result becomes the value of text\n}\nEvaluation of default parameters\n\nIn JavaScript, a default parameter is evaluated every time the function is called without the respective parameter.\n\nIn the example above, anotherFunction() isn’t called at all, if the text parameter is provided.\n\nOn the other hand, it’s independently called every time when text is missing.\n\nDefault parameters in old JavaScript code\n\nSeveral years ago, JavaScript didn’t support the syntax for default parameters. So people used other ways to specify them.\n\nNowadays, we can come across them in old scripts.\n\nFor example, an explicit check for undefined:\n\nfunction showMessage(from, text) {\n  if (text === undefined) {\n    text = 'no text given';\n  }\n\n  alert( from + \": \" + text );\n}\n\n…Or using the || operator:\n\nfunction showMessage(from, text) {\n  // If the value of text is falsy, assign the default value\n  // this assumes that text == \"\" is the same as no text at all\n  text = text || 'no text given';\n  ...\n}\nAlternative default parameters\n\nSometimes it makes sense to assign default values for parameters at a later stage after the function declaration.\n\nWe can check if the parameter is passed during the function execution, by comparing it with undefined:\n\n\t\nfunction showMessage(text) {\n  // ...\n\n  if (text === undefined) { // if the parameter is missing\n    text = 'empty message';\n  }\n\n  alert(text);\n}\n\nshowMessage(); // empty message\n\n…Or we could use the || operator:\n\nfunction showMessage(text) {\n  // if text is undefined or otherwise falsy, set it to 'empty'\n  text = text || 'empty';\n  ...\n}\n\nModern JavaScript engines support the nullish coalescing operator ??, it’s better when most falsy values, such as 0, should be considered “normal”:\n\n\t\nfunction showCount(count) {\n  // if count is undefined or null, show \"unknown\"\n  alert(count ?? \"unknown\");\n}\n\nshowCount(0); // 0\nshowCount(null); // unknown\nshowCount(); // unknown\nReturning a value\n\nA function can return a value back into the calling code as the result.\n\nThe simplest example would be a function that sums two values:\n\n\t\nfunction sum(a, b) {\n  return a + b;\n}\n\nlet result = sum(1, 2);\nalert( result ); // 3\n\nThe directive return can be in any place of the function. When the execution reaches it, the function stops, and the value is returned to the calling code (assigned to result above).\n\nThere may be many occurrences of return in a single function. For instance:\n\n\t\nfunction checkAge(age) {\n  if (age >= 18) {\n    return true;\n  } else {\n    return confirm('Do you have permission from your parents?');\n  }\n}\n\nlet age = prompt('How old are you?', 18);\n\nif ( checkAge(age) ) {\n  alert( 'Access granted' );\n} else {\n  alert( 'Access denied' );\n}\n\nIt is possible to use return without a value. That causes the function to exit immediately.\n\nFor example:\n\nfunction showMovie(age) {\n  if ( !checkAge(age) ) {\n    return;\n  }\n\n  alert( \"Showing you the movie\" ); // (*)\n  // ...\n}\n\nIn the code above, if checkAge(age) returns false, then showMovie won’t proceed to the alert.\n\nA function with an empty return or without it returns undefined\n\nIf a function does not return a value, it is the same as if it returns undefined:\n\n\t\nfunction doNothing() { /* empty */ }\n\nalert( doNothing() === undefined ); // true\n\nAn empty return is also the same as return undefined:\n\n\t\nfunction doNothing() {\n  return;\n}\n\nalert( doNothing() === undefined ); // true\nNever add a newline between return and the value\n\nFor a long expression in return, it might be tempting to put it on a separate line, like this:\n\nreturn\n (some + long + expression + or + whatever * f(a) + f(b))\n\nThat doesn’t work, because JavaScript assumes a semicolon after return. That’ll work the same as:\n\nreturn;\n (some + long + expression + or + whatever * f(a) + f(b))\n\nSo, it effectively becomes an empty return.\n\nIf we want the returned expression to wrap across multiple lines, we should start it at the same line as return. Or at least put the opening parentheses there as follows:\n\nreturn (\n  some + long + expression\n  + or +\n  whatever * f(a) + f(b)\n  )\n\nAnd it will work just as we expect it to.\n\nNaming a function\n\nFunctions are actions. So their name is usually a verb. It should be brief, as accurate as possible and describe what the function does, so that someone reading the code gets an indication of what the function does.\n\nIt is a widespread practice to start a function with a verbal prefix which vaguely describes the action. There must be an agreement within the team on the meaning of the prefixes.\n\nFor instance, functions that start with \"show\" usually show something.\n\nFunction starting with…\n\n\"get…\" – return a value,\n\"calc…\" – calculate something,\n\"create…\" – create something,\n\"check…\" – check something and return a boolean, etc.\n\nExamples of such names:\n\nshowMessage(..)     // shows a message\ngetAge(..)          // returns the age (gets it somehow)\ncalcSum(..)         // calculates a sum and returns the result\ncreateForm(..)      // creates a form (and usually returns it)\ncheckPermission(..) // checks a permission, returns true/false\n\nWith prefixes in place, a glance at a function name gives an understanding what kind of work it does and what kind of value it returns.\n\nOne function – one action\n\nA function should do exactly what is suggested by its name, no more.\n\nTwo independent actions usually deserve two functions, even if they are usually called together (in that case we can make a 3rd function that calls those two).\n\nA few examples of breaking this rule:\n\ngetAge – would be bad if it shows an alert with the age (should only get).\ncreateForm – would be bad if it modifies the document, adding a form to it (should only create it and return).\ncheckPermission – would be bad if it displays the access granted/denied message (should only perform the check and return the result).\n\nThese examples assume common meanings of prefixes. You and your team are free to agree on other meanings, but usually they’re not much different. In any case, you should have a firm understanding of what a prefix means, what a prefixed function can and cannot do. All same-prefixed functions should obey the rules. And the team should share the knowledge.\n\nUltrashort function names\n\nFunctions that are used very often sometimes have ultrashort names.\n\nFor example, the jQuery framework defines a function with $. The Lodash library has its core function named _.\n\nThese are exceptions. Generally function names should be concise and descriptive.\n\nFunctions == Comments\n\nFunctions should be short and do exactly one thing. If that thing is big, maybe it’s worth it to split the function into a few smaller functions. Sometimes following this rule may not be that easy, but it’s definitely a good thing.\n\nA separate function is not only easier to test and debug – its very existence is a great comment!\n\nFor instance, compare the two functions showPrimes(n) below. Each one outputs prime numbers up to n.\n\nThe first variant uses a label:\n\nfunction showPrimes(n) {\n  nextPrime: for (let i = 2; i < n; i++) {\n\n    for (let j = 2; j < i; j++) {\n      if (i % j == 0) continue nextPrime;\n    }\n\n    alert( i ); // a prime\n  }\n}\n\nThe second variant uses an additional function isPrime(n) to test for primality:\n\nfunction showPrimes(n) {\n\n  for (let i = 2; i < n; i++) {\n    if (!isPrime(i)) continue;\n\n    alert(i);  // a prime\n  }\n}\n\nfunction isPrime(n) {\n  for (let i = 2; i < n; i++) {\n    if ( n % i == 0) return false;\n  }\n  return true;\n}\n\nThe second variant is easier to understand, isn’t it? Instead of the code piece we see a name of the action (isPrime). Sometimes people refer to such code as self-describing.\n\nSo, functions can be created even if we don’t intend to reuse them. They structure the code and make it readable.\n\nSummary\n\nA function declaration looks like this:\n\nfunction name(parameters, delimited, by, comma) {\n  /* code */\n}\nValues passed to a function as parameters are copied to its local variables.\nA function may access outer variables. But it works only from inside out. The code outside of the function doesn’t see its local variables.\nA function can return a value. If it doesn’t, then its result is undefined.\n\nTo make the code clean and easy to understand, it’s recommended to use mainly local variables and parameters in the function, not outer variables.\n\nIt is always easier to understand a function which gets parameters, works with them and returns a result than a function which gets no parameters, but modifies outer variables as a side effect.\n\nFunction naming:\n\nA name should clearly describe what the function does. When we see a function call in the code, a good name instantly gives us an understanding what it does and returns.\nA function is an action, so function names are usually verbal.\nThere exist many well-known function prefixes like create…, show…, get…, check… and so on. Use them to hint what a function does.\n\nFunctions are the main building blocks of scripts. Now we’ve covered the basics, so we actually can start creating and using them. But that’s only the beginning of the path. We are going to return to them many times, going more deeply into their advanced features.\n\nTasks\nIs \"else\" required?\nimportance: 4\n\nThe following function returns true if the parameter age is greater than 18.\n\nOtherwise it asks for a confirmation and returns its result:\n\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  } else {\n    // ...\n    return confirm('Did parents allow you?');\n  }\n}\n\nWill the function work differently if else is removed?\n\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  }\n  // ...\n  return confirm('Did parents allow you?');\n}\n\nIs there any difference in the behavior of these two variants?\n\nsolution\nRewrite the function using '?' or '||'\nimportance: 4\n\nThe following function returns true if the parameter age is greater than 18.\n\nOtherwise it asks for a confirmation and returns its result.\n\nfunction checkAge(age) {\n  if (age > 18) {\n    return true;\n  } else {\n    return confirm('Did parents allow you?');\n  }\n}\n\nRewrite it, to perform the same, but without if, in a single line.\n\nMake two variants of checkAge:\n\nUsing a question mark operator ?\nUsing OR ||\nsolution\nFunction min(a, b)\nimportance: 1\n\nWrite a function min(a,b) which returns the least of two numbers a and b.\n\nFor instance:\n\nmin(2, 5) == 2\nmin(3, -1) == -1\nmin(1, 1) == 1\nsolution\nFunction pow(x,n)\nimportance: 4\n\nWrite a function pow(x,n) that returns x in power n. Or, in other words, multiplies x by itself n times and returns the result.\n\npow(3, 2) = 3 * 3 = 9\npow(3, 3) = 3 * 3 * 3 = 27\npow(1, 100) = 1 * 1 * ...* 1 = 1\n\nCreate a web-page that prompts for x and n, and then shows the result of pow(x,n).\n\nRun the demo\n\nP.S. In this task the function should support only natural values of n: integers up from 1.\n\nsolution"
  },
  {
    "title": "The \"switch\" statement",
    "url": "https://javascript.info/switch",
    "html": "A switch statement can replace multiple if checks.\n\nIt gives a more descriptive way to compare a value with multiple variants.\n\nThe syntax\n\nThe switch has one or more case blocks and an optional default.\n\nIt looks like this:\n\nswitch(x) {\n  case 'value1':  // if (x === 'value1')\n    ...\n    [break]\n\n  case 'value2':  // if (x === 'value2')\n    ...\n    [break]\n\n  default:\n    ...\n    [break]\n}\nThe value of x is checked for a strict equality to the value from the first case (that is, value1) then to the second (value2) and so on.\nIf the equality is found, switch starts to execute the code starting from the corresponding case, until the nearest break (or until the end of switch).\nIf no case is matched then the default code is executed (if it exists).\nAn example\n\nAn example of switch (the executed code is highlighted):\n\n\t\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Too small' );\n    break;\n  case 4:\n    alert( 'Exactly!' );\n    break;\n  case 5:\n    alert( 'Too big' );\n    break;\n  default:\n    alert( \"I don't know such values\" );\n}\n\nHere the switch starts to compare a from the first case variant that is 3. The match fails.\n\nThen 4. That’s a match, so the execution starts from case 4 until the nearest break.\n\nIf there is no break then the execution continues with the next case without any checks.\n\nAn example without break:\n\n\t\nlet a = 2 + 2;\n\nswitch (a) {\n  case 3:\n    alert( 'Too small' );\n  case 4:\n    alert( 'Exactly!' );\n  case 5:\n    alert( 'Too big' );\n  default:\n    alert( \"I don't know such values\" );\n}\n\nIn the example above we’ll see sequential execution of three alerts:\n\nalert( 'Exactly!' );\nalert( 'Too big' );\nalert( \"I don't know such values\" );\nAny expression can be a switch/case argument\n\nBoth switch and case allow arbitrary expressions.\n\nFor example:\n\n\t\nlet a = \"1\";\nlet b = 0;\n\nswitch (+a) {\n  case b + 1:\n    alert(\"this runs, because +a is 1, exactly equals b+1\");\n    break;\n\n  default:\n    alert(\"this doesn't run\");\n}\n\nHere +a gives 1, that’s compared with b + 1 in case, and the corresponding code is executed.\n\nGrouping of “case”\n\nSeveral variants of case which share the same code can be grouped.\n\nFor example, if we want the same code to run for case 3 and case 5:\n\n\t\nlet a = 3;\n\nswitch (a) {\n  case 4:\n    alert('Right!');\n    break;\n\n  case 3: // (*) grouped two cases\n  case 5:\n    alert('Wrong!');\n    alert(\"Why don't you take a math class?\");\n    break;\n\n  default:\n    alert('The result is strange. Really.');\n}\n\nNow both 3 and 5 show the same message.\n\nThe ability to “group” cases is a side effect of how switch/case works without break. Here the execution of case 3 starts from the line (*) and goes through case 5, because there’s no break.\n\nType matters\n\nLet’s emphasize that the equality check is always strict. The values must be of the same type to match.\n\nFor example, let’s consider the code:\n\n\t\nlet arg = prompt(\"Enter a value?\");\nswitch (arg) {\n  case '0':\n  case '1':\n    alert( 'One or zero' );\n    break;\n\n  case '2':\n    alert( 'Two' );\n    break;\n\n  case 3:\n    alert( 'Never executes!' );\n    break;\n  default:\n    alert( 'An unknown value' );\n}\nFor 0, 1, the first alert runs.\nFor 2 the second alert runs.\nBut for 3, the result of the prompt is a string \"3\", which is not strictly equal === to the number 3. So we’ve got a dead code in case 3! The default variant will execute.\nTasks\nRewrite the \"switch\" into an \"if\"\nimportance: 5\n\nWrite the code using if..else which would correspond to the following switch:\n\nswitch (browser) {\n  case 'Edge':\n    alert( \"You've got the Edge!\" );\n    break;\n\n  case 'Chrome':\n  case 'Firefox':\n  case 'Safari':\n  case 'Opera':\n    alert( 'Okay we support these browsers too' );\n    break;\n\n  default:\n    alert( 'We hope that this page looks ok!' );\n}\nsolution\nRewrite \"if\" into \"switch\"\nimportance: 4\n\nRewrite the code below using a single switch statement:\n\n\t\nlet a = +prompt('a?', '');\n\nif (a == 0) {\n  alert( 0 );\n}\nif (a == 1) {\n  alert( 1 );\n}\n\nif (a == 2 || a == 3) {\n  alert( '2,3' );\n}\nsolution"
  },
  {
    "title": "Loops: while and for",
    "url": "https://javascript.info/while-for",
    "html": "We often need to repeat actions.\n\nFor example, outputting goods from a list one after another or just running the same code for each number from 1 to 10.\n\nLoops are a way to repeat the same code multiple times.\n\nThe for…of and for…in loops\n\nA small announcement for advanced readers.\n\nThis article covers only basic loops: while, do..while and for(..;..;..).\n\nIf you came to this article searching for other types of loops, here are the pointers:\n\nSee for…in to loop over object properties.\nSee for…of and iterables for looping over arrays and iterable objects.\n\nOtherwise, please read on.\n\nThe “while” loop\n\nThe while loop has the following syntax:\n\nwhile (condition) {\n  // code\n  // so-called \"loop body\"\n}\n\nWhile the condition is truthy, the code from the loop body is executed.\n\nFor instance, the loop below outputs i while i < 3:\n\n\t\nlet i = 0;\nwhile (i < 3) { // shows 0, then 1, then 2\n  alert( i );\n  i++;\n}\n\nA single execution of the loop body is called an iteration. The loop in the example above makes three iterations.\n\nIf i++ was missing from the example above, the loop would repeat (in theory) forever. In practice, the browser provides ways to stop such loops, and in server-side JavaScript, we can kill the process.\n\nAny expression or variable can be a loop condition, not just comparisons: the condition is evaluated and converted to a boolean by while.\n\nFor instance, a shorter way to write while (i != 0) is while (i):\n\n\t\nlet i = 3;\nwhile (i) { // when i becomes 0, the condition becomes falsy, and the loop stops\n  alert( i );\n  i--;\n}\nCurly braces are not required for a single-line body\n\nIf the loop body has a single statement, we can omit the curly braces {…}:\n\n\t\nlet i = 3;\nwhile (i) alert(i--);\nThe “do…while” loop\n\nThe condition check can be moved below the loop body using the do..while syntax:\n\ndo {\n  // loop body\n} while (condition);\n\nThe loop will first execute the body, then check the condition, and, while it’s truthy, execute it again and again.\n\nFor example:\n\n\t\nlet i = 0;\ndo {\n  alert( i );\n  i++;\n} while (i < 3);\n\nThis form of syntax should only be used when you want the body of the loop to execute at least once regardless of the condition being truthy. Usually, the other form is preferred: while(…) {…}.\n\nThe “for” loop\n\nThe for loop is more complex, but it’s also the most commonly used loop.\n\nIt looks like this:\n\nfor (begin; condition; step) {\n  // ... loop body ...\n}\n\nLet’s learn the meaning of these parts by example. The loop below runs alert(i) for i from 0 up to (but not including) 3:\n\n\t\nfor (let i = 0; i < 3; i++) { // shows 0, then 1, then 2\n  alert(i);\n}\n\nLet’s examine the for statement part-by-part:\n\npart\t\t\nbegin\tlet i = 0\tExecutes once upon entering the loop.\ncondition\ti < 3\tChecked before every loop iteration. If false, the loop stops.\nbody\talert(i)\tRuns again and again while the condition is truthy.\nstep\ti++\tExecutes after the body on each iteration.\n\nThe general loop algorithm works like this:\n\nRun begin\n→ (if condition → run body and run step)\n→ (if condition → run body and run step)\n→ (if condition → run body and run step)\n→ ...\n\nThat is, begin executes once, and then it iterates: after each condition test, body and step are executed.\n\nIf you are new to loops, it could help to go back to the example and reproduce how it runs step-by-step on a piece of paper.\n\nHere’s exactly what happens in our case:\n\n// for (let i = 0; i < 3; i++) alert(i)\n\n// run begin\nlet i = 0\n// if condition → run body and run step\nif (i < 3) { alert(i); i++ }\n// if condition → run body and run step\nif (i < 3) { alert(i); i++ }\n// if condition → run body and run step\nif (i < 3) { alert(i); i++ }\n// ...finish, because now i == 3\nInline variable declaration\n\nHere, the “counter” variable i is declared right in the loop. This is called an “inline” variable declaration. Such variables are visible only inside the loop.\n\n\t\nfor (let i = 0; i < 3; i++) {\n  alert(i); // 0, 1, 2\n}\nalert(i); // error, no such variable\n\nInstead of defining a variable, we could use an existing one:\n\n\t\nlet i = 0;\n\nfor (i = 0; i < 3; i++) { // use an existing variable\n  alert(i); // 0, 1, 2\n}\n\nalert(i); // 3, visible, because declared outside of the loop\nSkipping parts\n\nAny part of for can be skipped.\n\nFor example, we can omit begin if we don’t need to do anything at the loop start.\n\nLike here:\n\n\t\nlet i = 0; // we have i already declared and assigned\n\nfor (; i < 3; i++) { // no need for \"begin\"\n  alert( i ); // 0, 1, 2\n}\n\nWe can also remove the step part:\n\n\t\nlet i = 0;\n\nfor (; i < 3;) {\n  alert( i++ );\n}\n\nThis makes the loop identical to while (i < 3).\n\nWe can actually remove everything, creating an infinite loop:\n\nfor (;;) {\n  // repeats without limits\n}\n\nPlease note that the two for semicolons ; must be present. Otherwise, there would be a syntax error.\n\nBreaking the loop\n\nNormally, a loop exits when its condition becomes falsy.\n\nBut we can force the exit at any time using the special break directive.\n\nFor example, the loop below asks the user for a series of numbers, “breaking” when no number is entered:\n\n\t\nlet sum = 0;\n\nwhile (true) {\n\n  let value = +prompt(\"Enter a number\", '');\n\n  if (!value) break; // (*)\n\n  sum += value;\n\n}\nalert( 'Sum: ' + sum );\n\nThe break directive is activated at the line (*) if the user enters an empty line or cancels the input. It stops the loop immediately, passing control to the first line after the loop. Namely, alert.\n\nThe combination “infinite loop + break as needed” is great for situations when a loop’s condition must be checked not in the beginning or end of the loop, but in the middle or even in several places of its body.\n\nContinue to the next iteration\n\nThe continue directive is a “lighter version” of break. It doesn’t stop the whole loop. Instead, it stops the current iteration and forces the loop to start a new one (if the condition allows).\n\nWe can use it if we’re done with the current iteration and would like to move on to the next one.\n\nThe loop below uses continue to output only odd values:\n\n\t\nfor (let i = 0; i < 10; i++) {\n\n  // if true, skip the remaining part of the body\n  if (i % 2 == 0) continue;\n\n  alert(i); // 1, then 3, 5, 7, 9\n}\n\nFor even values of i, the continue directive stops executing the body and passes control to the next iteration of for (with the next number). So the alert is only called for odd values.\n\nThe continue directive helps decrease nesting\n\nA loop that shows odd values could look like this:\n\n\t\nfor (let i = 0; i < 10; i++) {\n\n  if (i % 2) {\n    alert( i );\n  }\n\n}\n\nFrom a technical point of view, this is identical to the example above. Surely, we can just wrap the code in an if block instead of using continue.\n\nBut as a side effect, this created one more level of nesting (the alert call inside the curly braces). If the code inside of if is longer than a few lines, that may decrease the overall readability.\n\nNo break/continue to the right side of ‘?’\n\nPlease note that syntax constructs that are not expressions cannot be used with the ternary operator ?. In particular, directives such as break/continue aren’t allowed there.\n\nFor example, if we take this code:\n\nif (i > 5) {\n  alert(i);\n} else {\n  continue;\n}\n\n…and rewrite it using a question mark:\n\n(i > 5) ? alert(i) : continue; // continue isn't allowed here\n\n…it stops working: there’s a syntax error.\n\nThis is just another reason not to use the question mark operator ? instead of if.\n\nLabels for break/continue\n\nSometimes we need to break out from multiple nested loops at once.\n\nFor example, in the code below we loop over i and j, prompting for the coordinates (i, j) from (0,0) to (2,2):\n\n\t\nfor (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '');\n\n    // what if we want to exit from here to Done (below)?\n  }\n}\n\nalert('Done!');\n\nWe need a way to stop the process if the user cancels the input.\n\nThe ordinary break after input would only break the inner loop. That’s not sufficient – labels, come to the rescue!\n\nA label is an identifier with a colon before a loop:\n\nlabelName: for (...) {\n  ...\n}\n\nThe break <labelName> statement in the loop below breaks out to the label:\n\n\t\nouter: for (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '');\n\n    // if an empty string or canceled, then break out of both loops\n    if (!input) break outer; // (*)\n\n    // do something with the value...\n  }\n}\n\nalert('Done!');\n\nIn the code above, break outer looks upwards for the label named outer and breaks out of that loop.\n\nSo the control goes straight from (*) to alert('Done!').\n\nWe can also move the label onto a separate line:\n\nouter:\nfor (let i = 0; i < 3; i++) { ... }\n\nThe continue directive can also be used with a label. In this case, code execution jumps to the next iteration of the labeled loop.\n\nLabels do not allow to “jump” anywhere\n\nLabels do not allow us to jump into an arbitrary place in the code.\n\nFor example, it is impossible to do this:\n\nbreak label; // jump to the label below (doesn't work)\n\nlabel: for (...)\n\nA break directive must be inside a code block. Technically, any labelled code block will do, e.g.:\n\nlabel: {\n  // ...\n  break label; // works\n  // ...\n}\n\n…Although, 99.9% of the time break is used inside loops, as we’ve seen in the examples above.\n\nA continue is only possible from inside a loop.\n\nSummary\n\nWe covered 3 types of loops:\n\nwhile – The condition is checked before each iteration.\ndo..while – The condition is checked after each iteration.\nfor (;;) – The condition is checked before each iteration, additional settings available.\n\nTo make an “infinite” loop, usually the while(true) construct is used. Such a loop, just like any other, can be stopped with the break directive.\n\nIf we don’t want to do anything in the current iteration and would like to forward to the next one, we can use the continue directive.\n\nbreak/continue support labels before the loop. A label is the only way for break/continue to escape a nested loop to go to an outer one.\n\nTasks\nLast loop value\nimportance: 3\n\nWhat is the last value alerted by this code? Why?\n\nlet i = 3;\n\nwhile (i) {\n  alert( i-- );\n}\nsolution\nWhich values does the while loop show?\nimportance: 4\n\nFor every loop iteration, write down which value it outputs and then compare it with the solution.\n\nBoth loops alert the same values, or not?\n\nThe prefix form ++i:\n\nlet i = 0;\nwhile (++i < 5) alert( i );\n\nThe postfix form i++\n\nlet i = 0;\nwhile (i++ < 5) alert( i );\nsolution\nWhich values get shown by the \"for\" loop?\nimportance: 4\n\nFor each loop write down which values it is going to show. Then compare with the answer.\n\nBoth loops alert same values or not?\n\nThe postfix form:\n\nfor (let i = 0; i < 5; i++) alert( i );\n\nThe prefix form:\n\nfor (let i = 0; i < 5; ++i) alert( i );\nsolution\nOutput even numbers in the loop\nimportance: 5\n\nUse the for loop to output even numbers from 2 to 10.\n\nRun the demo\n\nsolution\nReplace \"for\" with \"while\"\nimportance: 5\n\nRewrite the code changing the for loop to while without altering its behavior (the output should stay same).\n\n\t\nfor (let i = 0; i < 3; i++) {\n  alert( `number ${i}!` );\n}\nsolution\nRepeat until the input is correct\nimportance: 5\n\nWrite a loop which prompts for a number greater than 100. If the visitor enters another number – ask them to input again.\n\nThe loop must ask for a number until either the visitor enters a number greater than 100 or cancels the input/enters an empty line.\n\nHere we can assume that the visitor only inputs numbers. There’s no need to implement a special handling for a non-numeric input in this task.\n\nRun the demo\n\nsolution\nOutput prime numbers\nimportance: 3\n\nAn integer number greater than 1 is called a prime if it cannot be divided without a remainder by anything except 1 and itself.\n\nIn other words, n > 1 is a prime if it can’t be evenly divided by anything except 1 and n.\n\nFor example, 5 is a prime, because it cannot be divided without a remainder by 2, 3 and 4.\n\nWrite the code which outputs prime numbers in the interval from 2 to n.\n\nFor n = 10 the result will be 2,3,5,7.\n\nP.S. The code should work for any n, not be hard-tuned for any fixed value.\n\nsolution"
  },
  {
    "title": "Nullish coalescing operator '??'",
    "url": "https://javascript.info/nullish-coalescing-operator",
    "html": "A recent addition\nThis is a recent addition to the language. Old browsers may need polyfills.\n\nThe nullish coalescing operator is written as two question marks ??.\n\nAs it treats null and undefined similarly, we’ll use a special term here, in this article. For brevity, we’ll say that a value is “defined” when it’s neither null nor undefined.\n\nThe result of a ?? b is:\n\nif a is defined, then a,\nif a isn’t defined, then b.\n\nIn other words, ?? returns the first argument if it’s not null/undefined. Otherwise, the second one.\n\nThe nullish coalescing operator isn’t anything completely new. It’s just a nice syntax to get the first “defined” value of the two.\n\nWe can rewrite result = a ?? b using the operators that we already know, like this:\n\nresult = (a !== null && a !== undefined) ? a : b;\n\nNow it should be absolutely clear what ?? does. Let’s see where it helps.\n\nThe common use case for ?? is to provide a default value.\n\nFor example, here we show user if its value isn’t null/undefined, otherwise Anonymous:\n\n\t\nlet user;\n\nalert(user ?? \"Anonymous\"); // Anonymous (user is undefined)\n\nHere’s the example with user assigned to a name:\n\n\t\nlet user = \"John\";\n\nalert(user ?? \"Anonymous\"); // John (user is not null/undefined)\n\nWe can also use a sequence of ?? to select the first value from a list that isn’t null/undefined.\n\nLet’s say we have a user’s data in variables firstName, lastName or nickName. All of them may be not defined, if the user decided not to fill in the corresponding values.\n\nWe’d like to display the user name using one of these variables, or show “Anonymous” if all of them are null/undefined.\n\nLet’s use the ?? operator for that:\n\n\t\nlet firstName = null;\nlet lastName = null;\nlet nickName = \"Supercoder\";\n\n// shows the first defined value:\nalert(firstName ?? lastName ?? nickName ?? \"Anonymous\"); // Supercoder\nComparison with ||\n\nThe OR || operator can be used in the same way as ??, as it was described in the previous chapter.\n\nFor example, in the code above we could replace ?? with || and still get the same result:\n\n\t\nlet firstName = null;\nlet lastName = null;\nlet nickName = \"Supercoder\";\n\n// shows the first truthy value:\nalert(firstName || lastName || nickName || \"Anonymous\"); // Supercoder\n\nHistorically, the OR || operator was there first. It’s been there since the beginning of JavaScript, so developers were using it for such purposes for a long time.\n\nOn the other hand, the nullish coalescing operator ?? was added to JavaScript only recently, and the reason for that was that people weren’t quite happy with ||.\n\nThe important difference between them is that:\n\n|| returns the first truthy value.\n?? returns the first defined value.\n\nIn other words, || doesn’t distinguish between false, 0, an empty string \"\" and null/undefined. They are all the same – falsy values. If any of these is the first argument of ||, then we’ll get the second argument as the result.\n\nIn practice though, we may want to use default value only when the variable is null/undefined. That is, when the value is really unknown/not set.\n\nFor example, consider this:\n\n\t\nlet height = 0;\n\nalert(height || 100); // 100\nalert(height ?? 100); // 0\nThe height || 100 checks height for being a falsy value, and it’s 0, falsy indeed.\nso the result of || is the second argument, 100.\nThe height ?? 100 checks height for being null/undefined, and it’s not,\nso the result is height “as is”, that is 0.\n\nIn practice, the zero height is often a valid value, that shouldn’t be replaced with the default. So ?? does just the right thing.\n\nPrecedence\n\nThe precedence of the ?? operator is the same as ||. They both equal 3 in the MDN table.\n\nThat means that, just like ||, the nullish coalescing operator ?? is evaluated before = and ?, but after most other operations, such as +, *.\n\nSo we may need to add parentheses in expressions like this:\n\n\t\nlet height = null;\nlet width = null;\n\n// important: use parentheses\nlet area = (height ?? 100) * (width ?? 50);\n\nalert(area); // 5000\n\nOtherwise, if we omit parentheses, then as * has the higher precedence than ??, it would execute first, leading to incorrect results.\n\n// without parentheses\nlet area = height ?? 100 * width ?? 50;\n\n// ...works this way (not what we want):\nlet area = height ?? (100 * width) ?? 50;\nUsing ?? with && or ||\n\nDue to safety reasons, JavaScript forbids using ?? together with && and || operators, unless the precedence is explicitly specified with parentheses.\n\nThe code below triggers a syntax error:\n\n\t\nlet x = 1 && 2 ?? 3; // Syntax error\n\nThe limitation is surely debatable, it was added to the language specification with the purpose to avoid programming mistakes, when people start to switch from || to ??.\n\nUse explicit parentheses to work around it:\n\n\t\nlet x = (1 && 2) ?? 3; // Works\n\nalert(x); // 2\nSummary\n\nThe nullish coalescing operator ?? provides a short way to choose the first “defined” value from a list.\n\nIt’s used to assign default values to variables:\n\n// set height=100, if height is null or undefined\nheight = height ?? 100;\n\nThe operator ?? has a very low precedence, only a bit higher than ? and =, so consider adding parentheses when using it in an expression.\n\nIt’s forbidden to use it with || or && without explicit parentheses."
  },
  {
    "title": "Logical operators",
    "url": "https://javascript.info/logical-operators",
    "html": "There are four logical operators in JavaScript: || (OR), && (AND), ! (NOT), ?? (Nullish Coalescing). Here we cover the first three, the ?? operator is in the next article.\n\nAlthough they are called “logical”, they can be applied to values of any type, not only boolean. Their result can also be of any type.\n\nLet’s see the details.\n\n|| (OR)\n\nThe “OR” operator is represented with two vertical line symbols:\n\nresult = a || b;\n\nIn classical programming, the logical OR is meant to manipulate boolean values only. If any of its arguments are true, it returns true, otherwise it returns false.\n\nIn JavaScript, the operator is a little bit trickier and more powerful. But first, let’s see what happens with boolean values.\n\nThere are four possible logical combinations:\n\n\t\nalert( true || true );   // true\nalert( false || true );  // true\nalert( true || false );  // true\nalert( false || false ); // false\n\nAs we can see, the result is always true except for the case when both operands are false.\n\nIf an operand is not a boolean, it’s converted to a boolean for the evaluation.\n\nFor instance, the number 1 is treated as true, the number 0 as false:\n\n\t\nif (1 || 0) { // works just like if( true || false )\n  alert( 'truthy!' );\n}\n\nMost of the time, OR || is used in an if statement to test if any of the given conditions is true.\n\nFor example:\n\n\t\nlet hour = 9;\n\nif (hour < 10 || hour > 18) {\n  alert( 'The office is closed.' );\n}\n\nWe can pass more conditions:\n\n\t\nlet hour = 12;\nlet isWeekend = true;\n\nif (hour < 10 || hour > 18 || isWeekend) {\n  alert( 'The office is closed.' ); // it is the weekend\n}\nOR \"||\" finds the first truthy value\n\nThe logic described above is somewhat classical. Now, let’s bring in the “extra” features of JavaScript.\n\nThe extended algorithm works as follows.\n\nGiven multiple OR’ed values:\n\nresult = value1 || value2 || value3;\n\nThe OR || operator does the following:\n\nEvaluates operands from left to right.\nFor each operand, converts it to boolean. If the result is true, stops and returns the original value of that operand.\nIf all operands have been evaluated (i.e. all were false), returns the last operand.\n\nA value is returned in its original form, without the conversion.\n\nIn other words, a chain of OR || returns the first truthy value or the last one if no truthy value is found.\n\nFor instance:\n\n\t\nalert( 1 || 0 ); // 1 (1 is truthy)\n\nalert( null || 1 ); // 1 (1 is the first truthy value)\nalert( null || 0 || 1 ); // 1 (the first truthy value)\n\nalert( undefined || null || 0 ); // 0 (all falsy, returns the last value)\n\nThis leads to some interesting usage compared to a “pure, classical, boolean-only OR”.\n\nGetting the first truthy value from a list of variables or expressions.\n\nFor instance, we have firstName, lastName and nickName variables, all optional (i.e. can be undefined or have falsy values).\n\nLet’s use OR || to choose the one that has the data and show it (or \"Anonymous\" if nothing set):\n\n\t\nlet firstName = \"\";\nlet lastName = \"\";\nlet nickName = \"SuperCoder\";\n\nalert( firstName || lastName || nickName || \"Anonymous\"); // SuperCoder\n\nIf all variables were falsy, \"Anonymous\" would show up.\n\nShort-circuit evaluation.\n\nAnother feature of OR || operator is the so-called “short-circuit” evaluation.\n\nIt means that || processes its arguments until the first truthy value is reached, and then the value is returned immediately, without even touching the other argument.\n\nThe importance of this feature becomes obvious if an operand isn’t just a value, but an expression with a side effect, such as a variable assignment or a function call.\n\nIn the example below, only the second message is printed:\n\n\t\ntrue || alert(\"not printed\");\nfalse || alert(\"printed\");\n\nIn the first line, the OR || operator stops the evaluation immediately upon seeing true, so the alert isn’t run.\n\nSometimes, people use this feature to execute commands only if the condition on the left part is falsy.\n\n&& (AND)\n\nThe AND operator is represented with two ampersands &&:\n\nresult = a && b;\n\nIn classical programming, AND returns true if both operands are truthy and false otherwise:\n\n\t\nalert( true && true );   // true\nalert( false && true );  // false\nalert( true && false );  // false\nalert( false && false ); // false\n\nAn example with if:\n\n\t\nlet hour = 12;\nlet minute = 30;\n\nif (hour == 12 && minute == 30) {\n  alert( 'The time is 12:30' );\n}\n\nJust as with OR, any value is allowed as an operand of AND:\n\n\t\nif (1 && 0) { // evaluated as true && false\n  alert( \"won't work, because the result is falsy\" );\n}\nAND “&&” finds the first falsy value\n\nGiven multiple AND’ed values:\n\nresult = value1 && value2 && value3;\n\nThe AND && operator does the following:\n\nEvaluates operands from left to right.\nFor each operand, converts it to a boolean. If the result is false, stops and returns the original value of that operand.\nIf all operands have been evaluated (i.e. all were truthy), returns the last operand.\n\nIn other words, AND returns the first falsy value or the last value if none were found.\n\nThe rules above are similar to OR. The difference is that AND returns the first falsy value while OR returns the first truthy one.\n\nExamples:\n\n\t\n// if the first operand is truthy,\n// AND returns the second operand:\nalert( 1 && 0 ); // 0\nalert( 1 && 5 ); // 5\n\n// if the first operand is falsy,\n// AND returns it. The second operand is ignored\nalert( null && 5 ); // null\nalert( 0 && \"no matter what\" ); // 0\n\nWe can also pass several values in a row. See how the first falsy one is returned:\n\n\t\nalert( 1 && 2 && null && 3 ); // null\n\nWhen all values are truthy, the last value is returned:\n\n\t\nalert( 1 && 2 && 3 ); // 3, the last one\nPrecedence of AND && is higher than OR ||\n\nThe precedence of AND && operator is higher than OR ||.\n\nSo the code a && b || c && d is essentially the same as if the && expressions were in parentheses: (a && b) || (c && d).\n\nDon’t replace if with || or &&\n\nSometimes, people use the AND && operator as a \"shorter way to write if\".\n\nFor instance:\n\n\t\nlet x = 1;\n\n(x > 0) && alert( 'Greater than zero!' );\n\nThe action in the right part of && would execute only if the evaluation reaches it. That is, only if (x > 0) is true.\n\nSo we basically have an analogue for:\n\n\t\nlet x = 1;\n\nif (x > 0) alert( 'Greater than zero!' );\n\nAlthough, the variant with && appears shorter, if is more obvious and tends to be a little bit more readable. So we recommend using every construct for its purpose: use if if we want if and use && if we want AND.\n\n! (NOT)\n\nThe boolean NOT operator is represented with an exclamation sign !.\n\nThe syntax is pretty simple:\n\nresult = !value;\n\nThe operator accepts a single argument and does the following:\n\nConverts the operand to boolean type: true/false.\nReturns the inverse value.\n\nFor instance:\n\n\t\nalert( !true ); // false\nalert( !0 ); // true\n\nA double NOT !! is sometimes used for converting a value to boolean type:\n\n\t\nalert( !!\"non-empty string\" ); // true\nalert( !!null ); // false\n\nThat is, the first NOT converts the value to boolean and returns the inverse, and the second NOT inverses it again. In the end, we have a plain value-to-boolean conversion.\n\nThere’s a little more verbose way to do the same thing – a built-in Boolean function:\n\n\t\nalert( Boolean(\"non-empty string\") ); // true\nalert( Boolean(null) ); // false\n\nThe precedence of NOT ! is the highest of all logical operators, so it always executes first, before && or ||.\n\nTasks\nWhat's the result of OR?\nimportance: 5\n\nWhat is the code below going to output?\n\nalert( null || 2 || undefined );\nsolution\nWhat's the result of OR'ed alerts?\nimportance: 3\n\nWhat will the code below output?\n\nalert( alert(1) || 2 || alert(3) );\nsolution\nWhat is the result of AND?\nimportance: 5\n\nWhat is this code going to show?\n\nalert( 1 && null && 2 );\nsolution\nWhat is the result of AND'ed alerts?\nimportance: 3\n\nWhat will this code show?\n\nalert( alert(1) && alert(2) );\nsolution\nThe result of OR AND OR\nimportance: 5\n\nWhat will the result be?\n\nalert( null || 2 && 3 || 4 );\nsolution\nCheck the range between\nimportance: 3\n\nWrite an if condition to check that age is between 14 and 90 inclusively.\n\n“Inclusively” means that age can reach the edges 14 or 90.\n\nsolution\nCheck the range outside\nimportance: 3\n\nWrite an if condition to check that age is NOT between 14 and 90 inclusively.\n\nCreate two variants: the first one using NOT !, the second one – without it.\n\nsolution\nA question about \"if\"\nimportance: 5\n\nWhich of these alerts are going to execute?\n\nWhat will the results of the expressions be inside if(...)?\n\nif (-1 || 0) alert( 'first' );\nif (-1 && 0) alert( 'second' );\nif (null || -1 && 1) alert( 'third' );\nsolution\nCheck the login\nimportance: 3\n\nWrite the code which asks for a login with prompt.\n\nIf the visitor enters \"Admin\", then prompt for a password, if the input is an empty line or Esc – show “Canceled”, if it’s another string – then show “I don’t know you”.\n\nThe password is checked as follows:\n\nIf it equals “TheMaster”, then show “Welcome!”,\nAnother string – show “Wrong password”,\nFor an empty string or cancelled input, show “Canceled”\n\nThe schema:\n\nPlease use nested if blocks. Mind the overall readability of the code.\n\nHint: passing an empty input to a prompt returns an empty string ''. Pressing ESC during a prompt returns null.\n\nRun the demo\n\nsolution"
  },
  {
    "title": "Conditional branching: if, '?'",
    "url": "https://javascript.info/ifelse",
    "html": "Sometimes, we need to perform different actions based on different conditions.\n\nTo do that, we can use the if statement and the conditional operator ?, that’s also called a “question mark” operator.\n\nThe “if” statement\n\nThe if(...) statement evaluates a condition in parentheses and, if the result is true, executes a block of code.\n\nFor example:\n\n\t\nlet year = prompt('In which year was ECMAScript-2015 specification published?', '');\n\nif (year == 2015) alert( 'You are right!' );\n\nIn the example above, the condition is a simple equality check (year == 2015), but it can be much more complex.\n\nIf we want to execute more than one statement, we have to wrap our code block inside curly braces:\n\nif (year == 2015) {\n  alert( \"That's correct!\" );\n  alert( \"You're so smart!\" );\n}\n\nWe recommend wrapping your code block with curly braces {} every time you use an if statement, even if there is only one statement to execute. Doing so improves readability.\n\nBoolean conversion\n\nThe if (…) statement evaluates the expression in its parentheses and converts the result to a boolean.\n\nLet’s recall the conversion rules from the chapter Type Conversions:\n\nA number 0, an empty string \"\", null, undefined, and NaN all become false. Because of that they are called “falsy” values.\nOther values become true, so they are called “truthy”.\n\nSo, the code under this condition would never execute:\n\nif (0) { // 0 is falsy\n  ...\n}\n\n…and inside this condition – it always will:\n\nif (1) { // 1 is truthy\n  ...\n}\n\nWe can also pass a pre-evaluated boolean value to if, like this:\n\nlet cond = (year == 2015); // equality evaluates to true or false\n\nif (cond) {\n  ...\n}\nThe “else” clause\n\nThe if statement may contain an optional else block. It executes when the condition is falsy.\n\nFor example:\n\n\t\nlet year = prompt('In which year was the ECMAScript-2015 specification published?', '');\n\nif (year == 2015) {\n  alert( 'You guessed it right!' );\n} else {\n  alert( 'How can you be so wrong?' ); // any value except 2015\n}\nSeveral conditions: “else if”\n\nSometimes, we’d like to test several variants of a condition. The else if clause lets us do that.\n\nFor example:\n\n\t\nlet year = prompt('In which year was the ECMAScript-2015 specification published?', '');\n\nif (year < 2015) {\n  alert( 'Too early...' );\n} else if (year > 2015) {\n  alert( 'Too late' );\n} else {\n  alert( 'Exactly!' );\n}\n\nIn the code above, JavaScript first checks year < 2015. If that is falsy, it goes to the next condition year > 2015. If that is also falsy, it shows the last alert.\n\nThere can be more else if blocks. The final else is optional.\n\nConditional operator ‘?’\n\nSometimes, we need to assign a variable depending on a condition.\n\nFor instance:\n\n\t\nlet accessAllowed;\nlet age = prompt('How old are you?', '');\n\nif (age > 18) {\n  accessAllowed = true;\n} else {\n  accessAllowed = false;\n}\n\nalert(accessAllowed);\n\nThe so-called “conditional” or “question mark” operator lets us do that in a shorter and simpler way.\n\nThe operator is represented by a question mark ?. Sometimes it’s called “ternary”, because the operator has three operands. It is actually the one and only operator in JavaScript which has that many.\n\nThe syntax is:\n\nlet result = condition ? value1 : value2;\n\nThe condition is evaluated: if it’s truthy then value1 is returned, otherwise – value2.\n\nFor example:\n\nlet accessAllowed = (age > 18) ? true : false;\n\nTechnically, we can omit the parentheses around age > 18. The question mark operator has a low precedence, so it executes after the comparison >.\n\nThis example will do the same thing as the previous one:\n\n// the comparison operator \"age > 18\" executes first anyway\n// (no need to wrap it into parentheses)\nlet accessAllowed = age > 18 ? true : false;\n\nBut parentheses make the code more readable, so we recommend using them.\n\nPlease note:\n\nIn the example above, you can avoid using the question mark operator because the comparison itself returns true/false:\n\n// the same\nlet accessAllowed = age > 18;\nMultiple ‘?’\n\nA sequence of question mark operators ? can return a value that depends on more than one condition.\n\nFor instance:\n\n\t\nlet age = prompt('age?', 18);\n\nlet message = (age < 3) ? 'Hi, baby!' :\n  (age < 18) ? 'Hello!' :\n  (age < 100) ? 'Greetings!' :\n  'What an unusual age!';\n\nalert( message );\n\nIt may be difficult at first to grasp what’s going on. But after a closer look, we can see that it’s just an ordinary sequence of tests:\n\nThe first question mark checks whether age < 3.\nIf true – it returns 'Hi, baby!'. Otherwise, it continues to the expression after the colon “:”, checking age < 18.\nIf that’s true – it returns 'Hello!'. Otherwise, it continues to the expression after the next colon “:”, checking age < 100.\nIf that’s true – it returns 'Greetings!'. Otherwise, it continues to the expression after the last colon “:”, returning 'What an unusual age!'.\n\nHere’s how this looks using if..else:\n\nif (age < 3) {\n  message = 'Hi, baby!';\n} else if (age < 18) {\n  message = 'Hello!';\n} else if (age < 100) {\n  message = 'Greetings!';\n} else {\n  message = 'What an unusual age!';\n}\nNon-traditional use of ‘?’\n\nSometimes the question mark ? is used as a replacement for if:\n\n\t\nlet company = prompt('Which company created JavaScript?', '');\n\n(company == 'Netscape') ?\n   alert('Right!') : alert('Wrong.');\n\nDepending on the condition company == 'Netscape', either the first or the second expression after the ? gets executed and shows an alert.\n\nWe don’t assign a result to a variable here. Instead, we execute different code depending on the condition.\n\nIt’s not recommended to use the question mark operator in this way.\n\nThe notation is shorter than the equivalent if statement, which appeals to some programmers. But it is less readable.\n\nHere is the same code using if for comparison:\n\n\t\nlet company = prompt('Which company created JavaScript?', '');\n\nif (company == 'Netscape') {\n  alert('Right!');\n} else {\n  alert('Wrong.');\n}\n\nOur eyes scan the code vertically. Code blocks which span several lines are easier to understand than a long, horizontal instruction set.\n\nThe purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code.\n\nTasks\nif (a string with zero)\nimportance: 5\n\nWill alert be shown?\n\nif (\"0\") {\n  alert( 'Hello' );\n}\nsolution\nThe name of JavaScript\nimportance: 2\n\nUsing the if..else construct, write the code which asks: ‘What is the “official” name of JavaScript?’\n\nIf the visitor enters “ECMAScript”, then output “Right!”, otherwise – output: “You don’t know? ECMAScript!”\n\nDemo in new window\n\nsolution\nShow the sign\nimportance: 2\n\nUsing if..else, write the code which gets a number via prompt and then shows in alert:\n\n1, if the value is greater than zero,\n-1, if less than zero,\n0, if equals zero.\n\nIn this task we assume that the input is always a number.\n\nDemo in new window\n\nsolution\nRewrite 'if' into '?'\nimportance: 5\n\nRewrite this if using the conditional operator '?':\n\nlet result;\n\nif (a + b < 4) {\n  result = 'Below';\n} else {\n  result = 'Over';\n}\nsolution\nRewrite 'if..else' into '?'\nimportance: 5\n\nRewrite if..else using multiple ternary operators '?'.\n\nFor readability, it’s recommended to split the code into multiple lines.\n\nlet message;\n\nif (login == 'Employee') {\n  message = 'Hello';\n} else if (login == 'Director') {\n  message = 'Greetings';\n} else if (login == '') {\n  message = 'No login';\n} else {\n  message = '';\n}\nsolution"
  },
  {
    "title": "Comparisons",
    "url": "https://javascript.info/comparison",
    "html": "We know many comparison operators from maths.\n\nIn JavaScript they are written like this:\n\nGreater/less than: a > b, a < b.\nGreater/less than or equals: a >= b, a <= b.\nEquals: a == b, please note the double equality sign == means the equality test, while a single one a = b means an assignment.\nNot equals: In maths the notation is ≠, but in JavaScript it’s written as a != b.\n\nIn this article we’ll learn more about different types of comparisons, how JavaScript makes them, including important peculiarities.\n\nAt the end you’ll find a good recipe to avoid “JavaScript quirks”-related issues.\n\nBoolean is the result\n\nAll comparison operators return a boolean value:\n\ntrue – means “yes”, “correct” or “the truth”.\nfalse – means “no”, “wrong” or “not the truth”.\n\nFor example:\n\n\t\nalert( 2 > 1 );  // true (correct)\nalert( 2 == 1 ); // false (wrong)\nalert( 2 != 1 ); // true (correct)\n\nA comparison result can be assigned to a variable, just like any value:\n\n\t\nlet result = 5 > 4; // assign the result of the comparison\nalert( result ); // true\nString comparison\n\nTo see whether a string is greater than another, JavaScript uses the so-called “dictionary” or “lexicographical” order.\n\nIn other words, strings are compared letter-by-letter.\n\nFor example:\n\n\t\nalert( 'Z' > 'A' ); // true\nalert( 'Glow' > 'Glee' ); // true\nalert( 'Bee' > 'Be' ); // true\n\nThe algorithm to compare two strings is simple:\n\nCompare the first character of both strings.\nIf the first character from the first string is greater (or less) than the other string’s, then the first string is greater (or less) than the second. We’re done.\nOtherwise, if both strings’ first characters are the same, compare the second characters the same way.\nRepeat until the end of either string.\nIf both strings end at the same length, then they are equal. Otherwise, the longer string is greater.\n\nIn the first example above, the comparison 'Z' > 'A' gets to a result at the first step.\n\nThe second comparison 'Glow' and 'Glee' needs more steps as strings are compared character-by-character:\n\nG is the same as G.\nl is the same as l.\no is greater than e. Stop here. The first string is greater.\nNot a real dictionary, but Unicode order\n\nThe comparison algorithm given above is roughly equivalent to the one used in dictionaries or phone books, but it’s not exactly the same.\n\nFor instance, case matters. A capital letter \"A\" is not equal to the lowercase \"a\". Which one is greater? The lowercase \"a\". Why? Because the lowercase character has a greater index in the internal encoding table JavaScript uses (Unicode). We’ll get back to specific details and consequences of this in the chapter Strings.\n\nComparison of different types\n\nWhen comparing values of different types, JavaScript converts the values to numbers.\n\nFor example:\n\n\t\nalert( '2' > 1 ); // true, string '2' becomes a number 2\nalert( '01' == 1 ); // true, string '01' becomes a number 1\n\nFor boolean values, true becomes 1 and false becomes 0.\n\nFor example:\n\n\t\nalert( true == 1 ); // true\nalert( false == 0 ); // true\nA funny consequence\n\nIt is possible that at the same time:\n\nTwo values are equal.\nOne of them is true as a boolean and the other one is false as a boolean.\n\nFor example:\n\n\t\nlet a = 0;\nalert( Boolean(a) ); // false\n\nlet b = \"0\";\nalert( Boolean(b) ); // true\n\nalert(a == b); // true!\n\nFrom JavaScript’s standpoint, this result is quite normal. An equality check converts values using the numeric conversion (hence \"0\" becomes 0), while the explicit Boolean conversion uses another set of rules.\n\nStrict equality\n\nA regular equality check == has a problem. It cannot differentiate 0 from false:\n\n\t\nalert( 0 == false ); // true\n\nThe same thing happens with an empty string:\n\n\t\nalert( '' == false ); // true\n\nThis happens because operands of different types are converted to numbers by the equality operator ==. An empty string, just like false, becomes a zero.\n\nWhat to do if we’d like to differentiate 0 from false?\n\nA strict equality operator === checks the equality without type conversion.\n\nIn other words, if a and b are of different types, then a === b immediately returns false without an attempt to convert them.\n\nLet’s try it:\n\n\t\nalert( 0 === false ); // false, because the types are different\n\nThere is also a “strict non-equality” operator !== analogous to !=.\n\nThe strict equality operator is a bit longer to write, but makes it obvious what’s going on and leaves less room for errors.\n\nComparison with null and undefined\n\nThere’s a non-intuitive behavior when null or undefined are compared to other values.\n\nFor a strict equality check ===\n\nThese values are different, because each of them is a different type.\n\n\t\nalert( null === undefined ); // false\nFor a non-strict check ==\n\nThere’s a special rule. These two are a “sweet couple”: they equal each other (in the sense of ==), but not any other value.\n\n\t\nalert( null == undefined ); // true\nFor maths and other comparisons < > <= >=\n\nnull/undefined are converted to numbers: null becomes 0, while undefined becomes NaN.\n\nNow let’s see some funny things that happen when we apply these rules. And, what’s more important, how to not fall into a trap with them.\n\nStrange result: null vs 0\n\nLet’s compare null with a zero:\n\n\t\nalert( null > 0 );  // (1) false\nalert( null == 0 ); // (2) false\nalert( null >= 0 ); // (3) true\n\nMathematically, that’s strange. The last result states that \"null is greater than or equal to zero\", so in one of the comparisons above it must be true, but they are both false.\n\nThe reason is that an equality check == and comparisons > < >= <= work differently. Comparisons convert null to a number, treating it as 0. That’s why (3) null >= 0 is true and (1) null > 0 is false.\n\nOn the other hand, the equality check == for undefined and null is defined such that, without any conversions, they equal each other and don’t equal anything else. That’s why (2) null == 0 is false.\n\nAn incomparable undefined\n\nThe value undefined shouldn’t be compared to other values:\n\n\t\nalert( undefined > 0 ); // false (1)\nalert( undefined < 0 ); // false (2)\nalert( undefined == 0 ); // false (3)\n\nWhy does it dislike zero so much? Always false!\n\nWe get these results because:\n\nComparisons (1) and (2) return false because undefined gets converted to NaN and NaN is a special numeric value which returns false for all comparisons.\nThe equality check (3) returns false because undefined only equals null, undefined, and no other value.\nAvoid problems\n\nWhy did we go over these examples? Should we remember these peculiarities all the time? Well, not really. Actually, these tricky things will gradually become familiar over time, but there’s a solid way to avoid problems with them:\n\nTreat any comparison with undefined/null except the strict equality === with exceptional care.\nDon’t use comparisons >= > < <= with a variable which may be null/undefined, unless you’re really sure of what you’re doing. If a variable can have these values, check for them separately.\nSummary\nComparison operators return a boolean value.\nStrings are compared letter-by-letter in the “dictionary” order.\nWhen values of different types are compared, they get converted to numbers (with the exclusion of a strict equality check).\nThe values null and undefined equal == each other and do not equal any other value.\nBe careful when using comparisons like > or < with variables that can occasionally be null/undefined. Checking for null/undefined separately is a good idea.\nTasks\nComparisons\nimportance: 5\n\nWhat will be the result for these expressions?\n\n5 > 4\n\"apple\" > \"pineapple\"\n\"2\" > \"12\"\nundefined == null\nundefined === null\nnull == \"\\n0\\n\"\nnull === +\"\\n0\\n\"\nsolution"
  },
  {
    "title": "Basic operators, maths",
    "url": "https://javascript.info/operators",
    "html": "We know many operators from school. They are things like addition +, multiplication *, subtraction -, and so on.\n\nIn this chapter, we’ll start with simple operators, then concentrate on JavaScript-specific aspects, not covered by school arithmetic.\n\nTerms: “unary”, “binary”, “operand”\n\nBefore we move on, let’s grasp some common terminology.\n\nAn operand – is what operators are applied to. For instance, in the multiplication of 5 * 2 there are two operands: the left operand is 5 and the right operand is 2. Sometimes, people call these “arguments” instead of “operands”.\n\nAn operator is unary if it has a single operand. For example, the unary negation - reverses the sign of a number:\n\n\t\nlet x = 1;\n\nx = -x;\nalert( x ); // -1, unary negation was applied\n\nAn operator is binary if it has two operands. The same minus exists in binary form as well:\n\n\t\nlet x = 1, y = 3;\nalert( y - x ); // 2, binary minus subtracts values\n\nFormally, in the examples above we have two different operators that share the same symbol: the negation operator, a unary operator that reverses the sign, and the subtraction operator, a binary operator that subtracts one number from another.\n\nMaths\n\nThe following math operations are supported:\n\nAddition +,\nSubtraction -,\nMultiplication *,\nDivision /,\nRemainder %,\nExponentiation **.\n\nThe first four are straightforward, while % and ** need a few words about them.\n\nRemainder %\n\nThe remainder operator %, despite its appearance, is not related to percents.\n\nThe result of a % b is the remainder of the integer division of a by b.\n\nFor instance:\n\n\t\nalert( 5 % 2 ); // 1, the remainder of 5 divided by 2\nalert( 8 % 3 ); // 2, the remainder of 8 divided by 3\nalert( 8 % 4 ); // 0, the remainder of 8 divided by 4\nExponentiation **\n\nThe exponentiation operator a ** b raises a to the power of b.\n\nIn school maths, we write that as ab.\n\nFor instance:\n\n\t\nalert( 2 ** 2 ); // 2² = 4\nalert( 2 ** 3 ); // 2³ = 8\nalert( 2 ** 4 ); // 2⁴ = 16\n\nJust like in maths, the exponentiation operator is defined for non-integer numbers as well.\n\nFor example, a square root is an exponentiation by ½:\n\n\t\nalert( 4 ** (1/2) ); // 2 (power of 1/2 is the same as a square root)\nalert( 8 ** (1/3) ); // 2 (power of 1/3 is the same as a cubic root)\nString concatenation with binary +\n\nLet’s meet the features of JavaScript operators that are beyond school arithmetics.\n\nUsually, the plus operator + sums numbers.\n\nBut, if the binary + is applied to strings, it merges (concatenates) them:\n\nlet s = \"my\" + \"string\";\nalert(s); // mystring\n\nNote that if any of the operands is a string, then the other one is converted to a string too.\n\nFor example:\n\n\t\nalert( '1' + 2 ); // \"12\"\nalert( 2 + '1' ); // \"21\"\n\nSee, it doesn’t matter whether the first operand is a string or the second one.\n\nHere’s a more complex example:\n\n\t\nalert(2 + 2 + '1' ); // \"41\" and not \"221\"\n\nHere, operators work one after another. The first + sums two numbers, so it returns 4, then the next + adds the string 1 to it, so it’s like 4 + '1' = '41'.\n\n\t\nalert('1' + 2 + 2); // \"122\" and not \"14\"\n\nHere, the first operand is a string, the compiler treats the other two operands as strings too. The 2 gets concatenated to '1', so it’s like '1' + 2 = \"12\" and \"12\" + 2 = \"122\".\n\nThe binary + is the only operator that supports strings in such a way. Other arithmetic operators work only with numbers and always convert their operands to numbers.\n\nHere’s the demo for subtraction and division:\n\n\t\nalert( 6 - '2' ); // 4, converts '2' to a number\nalert( '6' / '2' ); // 3, converts both operands to numbers\nNumeric conversion, unary +\n\nThe plus + exists in two forms: the binary form that we used above and the unary form.\n\nThe unary plus or, in other words, the plus operator + applied to a single value, doesn’t do anything to numbers. But if the operand is not a number, the unary plus converts it into a number.\n\nFor example:\n\n\t\n// No effect on numbers\nlet x = 1;\nalert( +x ); // 1\n\nlet y = -2;\nalert( +y ); // -2\n\n// Converts non-numbers\nalert( +true ); // 1\nalert( +\"\" );   // 0\n\nIt actually does the same thing as Number(...), but is shorter.\n\nThe need to convert strings to numbers arises very often. For example, if we are getting values from HTML form fields, they are usually strings. What if we want to sum them?\n\nThe binary plus would add them as strings:\n\n\t\nlet apples = \"2\";\nlet oranges = \"3\";\n\nalert( apples + oranges ); // \"23\", the binary plus concatenates strings\n\nIf we want to treat them as numbers, we need to convert and then sum them:\n\n\t\nlet apples = \"2\";\nlet oranges = \"3\";\n\n// both values converted to numbers before the binary plus\nalert( +apples + +oranges ); // 5\n\n// the longer variant\n// alert( Number(apples) + Number(oranges) ); // 5\n\nFrom a mathematician’s standpoint, the abundance of pluses may seem strange. But from a programmer’s standpoint, there’s nothing special: unary pluses are applied first, they convert strings to numbers, and then the binary plus sums them up.\n\nWhy are unary pluses applied to values before the binary ones? As we’re going to see, that’s because of their higher precedence.\n\nOperator precedence\n\nIf an expression has more than one operator, the execution order is defined by their precedence, or, in other words, the default priority order of operators.\n\nFrom school, we all know that the multiplication in the expression 1 + 2 * 2 should be calculated before the addition. That’s exactly the precedence thing. The multiplication is said to have a higher precedence than the addition.\n\nParentheses override any precedence, so if we’re not satisfied with the default order, we can use them to change it. For example, write (1 + 2) * 2.\n\nThere are many operators in JavaScript. Every operator has a corresponding precedence number. The one with the larger number executes first. If the precedence is the same, the execution order is from left to right.\n\nHere’s an extract from the precedence table (you don’t need to remember this, but note that unary operators are higher than corresponding binary ones):\n\nPrecedence\tName\tSign\n…\t…\t…\n14\tunary plus\t+\n14\tunary negation\t-\n13\texponentiation\t**\n12\tmultiplication\t*\n12\tdivision\t/\n11\taddition\t+\n11\tsubtraction\t-\n…\t…\t…\n2\tassignment\t=\n…\t…\t…\n\nAs we can see, the “unary plus” has a priority of 14 which is higher than the 11 of “addition” (binary plus). That’s why, in the expression \"+apples + +oranges\", unary pluses work before the addition.\n\nAssignment\n\nLet’s note that an assignment = is also an operator. It is listed in the precedence table with the very low priority of 2.\n\nThat’s why, when we assign a variable, like x = 2 * 2 + 1, the calculations are done first and then the = is evaluated, storing the result in x.\n\nlet x = 2 * 2 + 1;\n\nalert( x ); // 5\nAssignment = returns a value\n\nThe fact of = being an operator, not a “magical” language construct has an interesting implication.\n\nAll operators in JavaScript return a value. That’s obvious for + and -, but also true for =.\n\nThe call x = value writes the value into x and then returns it.\n\nHere’s a demo that uses an assignment as part of a more complex expression:\n\n\t\nlet a = 1;\nlet b = 2;\n\nlet c = 3 - (a = b + 1);\n\nalert( a ); // 3\nalert( c ); // 0\n\nIn the example above, the result of expression (a = b + 1) is the value which was assigned to a (that is 3). It is then used for further evaluations.\n\nFunny code, isn’t it? We should understand how it works, because sometimes we see it in JavaScript libraries.\n\nAlthough, please don’t write the code like that. Such tricks definitely don’t make code clearer or readable.\n\nChaining assignments\n\nAnother interesting feature is the ability to chain assignments:\n\n\t\nlet a, b, c;\n\na = b = c = 2 + 2;\n\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n\nChained assignments evaluate from right to left. First, the rightmost expression 2 + 2 is evaluated and then assigned to the variables on the left: c, b and a. At the end, all the variables share a single value.\n\nOnce again, for the purposes of readability it’s better to split such code into few lines:\n\nc = 2 + 2;\nb = c;\na = c;\n\nThat’s easier to read, especially when eye-scanning the code fast.\n\nModify-in-place\n\nWe often need to apply an operator to a variable and store the new result in that same variable.\n\nFor example:\n\nlet n = 2;\nn = n + 5;\nn = n * 2;\n\nThis notation can be shortened using the operators += and *=:\n\n\t\nlet n = 2;\nn += 5; // now n = 7 (same as n = n + 5)\nn *= 2; // now n = 14 (same as n = n * 2)\n\nalert( n ); // 14\n\nShort “modify-and-assign” operators exist for all arithmetical and bitwise operators: /=, -=, etc.\n\nSuch operators have the same precedence as a normal assignment, so they run after most other calculations:\n\n\t\nlet n = 2;\n\nn *= 3 + 5; // right part evaluated first, same as n *= 8\n\nalert( n ); // 16\nIncrement/decrement\n\nIncreasing or decreasing a number by one is among the most common numerical operations.\n\nSo, there are special operators for it:\n\nIncrement ++ increases a variable by 1:\n\n\t\nlet counter = 2;\ncounter++;        // works the same as counter = counter + 1, but is shorter\nalert( counter ); // 3\n\nDecrement -- decreases a variable by 1:\n\n\t\nlet counter = 2;\ncounter--;        // works the same as counter = counter - 1, but is shorter\nalert( counter ); // 1\nImportant:\n\nIncrement/decrement can only be applied to variables. Trying to use it on a value like 5++ will give an error.\n\nThe operators ++ and -- can be placed either before or after a variable.\n\nWhen the operator goes after the variable, it is in “postfix form”: counter++.\nThe “prefix form” is when the operator goes before the variable: ++counter.\n\nBoth of these statements do the same thing: increase counter by 1.\n\nIs there any difference? Yes, but we can only see it if we use the returned value of ++/--.\n\nLet’s clarify. As we know, all operators return a value. Increment/decrement is no exception. The prefix form returns the new value while the postfix form returns the old value (prior to increment/decrement).\n\nTo see the difference, here’s an example:\n\n\t\nlet counter = 1;\nlet a = ++counter; // (*)\n\nalert(a); // 2\n\nIn the line (*), the prefix form ++counter increments counter and returns the new value, 2. So, the alert shows 2.\n\nNow, let’s use the postfix form:\n\n\t\nlet counter = 1;\nlet a = counter++; // (*) changed ++counter to counter++\n\nalert(a); // 1\n\nIn the line (*), the postfix form counter++ also increments counter but returns the old value (prior to increment). So, the alert shows 1.\n\nTo summarize:\n\nIf the result of increment/decrement is not used, there is no difference in which form to use:\n\n\t\nlet counter = 0;\ncounter++;\n++counter;\nalert( counter ); // 2, the lines above did the same\n\nIf we’d like to increase a value and immediately use the result of the operator, we need the prefix form:\n\n\t\nlet counter = 0;\nalert( ++counter ); // 1\n\nIf we’d like to increment a value but use its previous value, we need the postfix form:\n\n\t\nlet counter = 0;\nalert( counter++ ); // 0\nIncrement/decrement among other operators\n\nThe operators ++/-- can be used inside expressions as well. Their precedence is higher than most other arithmetical operations.\n\nFor instance:\n\n\t\nlet counter = 1;\nalert( 2 * ++counter ); // 4\n\nCompare with:\n\n\t\nlet counter = 1;\nalert( 2 * counter++ ); // 2, because counter++ returns the \"old\" value\n\nThough technically okay, such notation usually makes code less readable. One line does multiple things – not good.\n\nWhile reading code, a fast “vertical” eye-scan can easily miss something like counter++ and it won’t be obvious that the variable increased.\n\nWe advise a style of “one line – one action”:\n\n\t\nlet counter = 1;\nalert( 2 * counter );\ncounter++;\nBitwise operators\n\nBitwise operators treat arguments as 32-bit integer numbers and work on the level of their binary representation.\n\nThese operators are not JavaScript-specific. They are supported in most programming languages.\n\nThe list of operators:\n\nAND ( & )\nOR ( | )\nXOR ( ^ )\nNOT ( ~ )\nLEFT SHIFT ( << )\nRIGHT SHIFT ( >> )\nZERO-FILL RIGHT SHIFT ( >>> )\n\nThese operators are used very rarely, when we need to fiddle with numbers on the very lowest (bitwise) level. We won’t need these operators any time soon, as web development has little use of them, but in some special areas, such as cryptography, they are useful. You can read the Bitwise Operators chapter on MDN when a need arises.\n\nComma\n\nThe comma operator , is one of the rarest and most unusual operators. Sometimes, it’s used to write shorter code, so we need to know it in order to understand what’s going on.\n\nThe comma operator allows us to evaluate several expressions, dividing them with a comma ,. Each of them is evaluated but only the result of the last one is returned.\n\nFor example:\n\n\t\nlet a = (1 + 2, 3 + 4);\n\nalert( a ); // 7 (the result of 3 + 4)\n\nHere, the first expression 1 + 2 is evaluated and its result is thrown away. Then, 3 + 4 is evaluated and returned as the result.\n\nComma has a very low precedence\n\nPlease note that the comma operator has very low precedence, lower than =, so parentheses are important in the example above.\n\nWithout them: a = 1 + 2, 3 + 4 evaluates + first, summing the numbers into a = 3, 7, then the assignment operator = assigns a = 3, and the rest is ignored. It’s like (a = 1 + 2), 3 + 4.\n\nWhy do we need an operator that throws away everything except the last expression?\n\nSometimes, people use it in more complex constructs to put several actions in one line.\n\nFor example:\n\n// three operations in one line\nfor (a = 1, b = 3, c = a * b; a < 10; a++) {\n ...\n}\n\nSuch tricks are used in many JavaScript frameworks. That’s why we’re mentioning them. But usually they don’t improve code readability so we should think well before using them.\n\nTasks\nThe postfix and prefix forms\nimportance: 5\n\nWhat are the final values of all variables a, b, c and d after the code below?\n\nlet a = 1, b = 1;\n\nlet c = ++a; // ?\nlet d = b++; // ?\nsolution\nAssignment result\nimportance: 3\n\nWhat are the values of a and x after the code below?\n\nlet a = 2;\n\nlet x = 1 + (a *= 2);\nsolution\nType conversions\nimportance: 5\n\nWhat are results of these expressions?\n\n\"\" + 1 + 0\n\"\" - 1 + 0\ntrue + false\n6 / \"3\"\n\"2\" * \"3\"\n4 + 5 + \"px\"\n\"$\" + 4 + 5\n\"4\" - 2\n\"4px\" - 2\n\"  -9  \" + 5\n\"  -9  \" - 5\nnull + 1\nundefined + 1\n\" \\t \\n\" - 2\n\nThink well, write down and then compare with the answer.\n\nsolution\nFix the addition\nimportance: 5\n\nHere’s a code that asks the user for two numbers and shows their sum.\n\nIt works incorrectly. The output in the example below is 12 (for default prompt values).\n\nWhy? Fix it. The result should be 3.\n\n\t\nlet a = prompt(\"First number?\", 1);\nlet b = prompt(\"Second number?\", 2);\n\nalert(a + b); // 12\nsolution"
  },
  {
    "title": "Type Conversions",
    "url": "https://javascript.info/type-conversions",
    "html": "Most of the time, operators and functions automatically convert the values given to them to the right type.\n\nFor example, alert automatically converts any value to a string to show it. Mathematical operations convert values to numbers.\n\nThere are also cases when we need to explicitly convert a value to the expected type.\n\nNot talking about objects yet\n\nIn this chapter, we won’t cover objects. For now, we’ll just be talking about primitives.\n\nLater, after we learn about objects, in the chapter Object to primitive conversion we’ll see how objects fit in.\n\nString Conversion\n\nString conversion happens when we need the string form of a value.\n\nFor example, alert(value) does it to show the value.\n\nWe can also call the String(value) function to convert a value to a string:\n\n\t\nlet value = true;\nalert(typeof value); // boolean\n\nvalue = String(value); // now value is a string \"true\"\nalert(typeof value); // string\n\nString conversion is mostly obvious. A false becomes \"false\", null becomes \"null\", etc.\n\nNumeric Conversion\n\nNumeric conversion in mathematical functions and expressions happens automatically.\n\nFor example, when division / is applied to non-numbers:\n\n\t\nalert( \"6\" / \"2\" ); // 3, strings are converted to numbers\n\nWe can use the Number(value) function to explicitly convert a value to a number:\n\n\t\nlet str = \"123\";\nalert(typeof str); // string\n\nlet num = Number(str); // becomes a number 123\n\nalert(typeof num); // number\n\nExplicit conversion is usually required when we read a value from a string-based source like a text form but expect a number to be entered.\n\nIf the string is not a valid number, the result of such a conversion is NaN. For instance:\n\n\t\nlet age = Number(\"an arbitrary string instead of a number\");\n\nalert(age); // NaN, conversion failed\n\nNumeric conversion rules:\n\nValue\tBecomes…\nundefined\tNaN\nnull\t0\ntrue and false\t1 and 0\nstring\tWhitespaces (includes spaces, tabs \\t, newlines \\n etc.) from the start and end are removed. If the remaining string is empty, the result is 0. Otherwise, the number is “read” from the string. An error gives NaN.\n\nExamples:\n\n\t\nalert( Number(\"   123   \") ); // 123\nalert( Number(\"123z\") );      // NaN (error reading a number at \"z\")\nalert( Number(true) );        // 1\nalert( Number(false) );       // 0\n\nPlease note that null and undefined behave differently here: null becomes zero while undefined becomes NaN.\n\nMost mathematical operators also perform such conversion, we’ll see that in the next chapter.\n\nBoolean Conversion\n\nBoolean conversion is the simplest one.\n\nIt happens in logical operations (later we’ll meet condition tests and other similar things) but can also be performed explicitly with a call to Boolean(value).\n\nThe conversion rule:\n\nValues that are intuitively “empty”, like 0, an empty string, null, undefined, and NaN, become false.\nOther values become true.\n\nFor instance:\n\n\t\nalert( Boolean(1) ); // true\nalert( Boolean(0) ); // false\n\nalert( Boolean(\"hello\") ); // true\nalert( Boolean(\"\") ); // false\nPlease note: the string with zero \"0\" is true\n\nSome languages (namely PHP) treat \"0\" as false. But in JavaScript, a non-empty string is always true.\n\n\t\nalert( Boolean(\"0\") ); // true\nalert( Boolean(\" \") ); // spaces, also true (any non-empty string is true)\nSummary\n\nThe three most widely used type conversions are to string, to number, and to boolean.\n\nString Conversion – Occurs when we output something. Can be performed with String(value). The conversion to string is usually obvious for primitive values.\n\nNumeric Conversion – Occurs in math operations. Can be performed with Number(value).\n\nThe conversion follows the rules:\n\nValue\tBecomes…\nundefined\tNaN\nnull\t0\ntrue / false\t1 / 0\nstring\tThe string is read “as is”, whitespaces (includes spaces, tabs \\t, newlines \\n etc.) from both sides are ignored. An empty string becomes 0. An error gives NaN.\n\nBoolean Conversion – Occurs in logical operations. Can be performed with Boolean(value).\n\nFollows the rules:\n\nValue\tBecomes…\n0, null, undefined, NaN, \"\"\tfalse\nany other value\ttrue\n\nMost of these rules are easy to understand and memorize. The notable exceptions where people usually make mistakes are:\n\nundefined is NaN as a number, not 0.\n\"0\" and space-only strings like \" \" are true as a boolean.\n\nObjects aren’t covered here. We’ll return to them later in the chapter Object to primitive conversion that is devoted exclusively to objects after we learn more basic things about JavaScript."
  },
  {
    "title": "Interaction: alert, prompt, confirm",
    "url": "https://javascript.info/alert-prompt-confirm",
    "html": "As we’ll be using the browser as our demo environment, let’s see a couple of functions to interact with the user: alert, prompt and confirm.\n\nalert\n\nThis one we’ve seen already. It shows a message and waits for the user to press “OK”.\n\nFor example:\n\n\t\nalert(\"Hello\");\n\nThe mini-window with the message is called a modal window. The word “modal” means that the visitor can’t interact with the rest of the page, press other buttons, etc, until they have dealt with the window. In this case – until they press “OK”.\n\nprompt\n\nThe function prompt accepts two arguments:\n\nresult = prompt(title, [default]);\n\nIt shows a modal window with a text message, an input field for the visitor, and the buttons OK/Cancel.\n\ntitle\nThe text to show the visitor.\ndefault\nAn optional second parameter, the initial value for the input field.\nThe square brackets in syntax [...]\n\nThe square brackets around default in the syntax above denote that the parameter is optional, not required.\n\nThe visitor can type something in the prompt input field and press OK. Then we get that text in the result. Or they can cancel the input by pressing Cancel or hitting the Esc key, then we get null as the result.\n\nThe call to prompt returns the text from the input field or null if the input was canceled.\n\nFor instance:\n\n\t\nlet age = prompt('How old are you?', 100);\n\nalert(`You are ${age} years old!`); // You are 100 years old!\nIn IE: always supply a default\n\nThe second parameter is optional, but if we don’t supply it, Internet Explorer will insert the text \"undefined\" into the prompt.\n\nRun this code in Internet Explorer to see:\n\n\t\nlet test = prompt(\"Test\");\n\nSo, for prompts to look good in IE, we recommend always providing the second argument:\n\n\t\nlet test = prompt(\"Test\", ''); // <-- for IE\nconfirm\n\nThe syntax:\n\nresult = confirm(question);\n\nThe function confirm shows a modal window with a question and two buttons: OK and Cancel.\n\nThe result is true if OK is pressed and false otherwise.\n\nFor example:\n\n\t\nlet isBoss = confirm(\"Are you the boss?\");\n\nalert( isBoss ); // true if OK is pressed\nSummary\n\nWe covered 3 browser-specific functions to interact with visitors:\n\nalert\nshows a message.\nprompt\nshows a message asking the user to input text. It returns the text or, if Cancel button or Esc is clicked, null.\nconfirm\nshows a message and waits for the user to press “OK” or “Cancel”. It returns true for OK and false for Cancel/Esc.\n\nAll these methods are modal: they pause script execution and don’t allow the visitor to interact with the rest of the page until the window has been dismissed.\n\nThere are two limitations shared by all the methods above:\n\nThe exact location of the modal window is determined by the browser. Usually, it’s in the center.\nThe exact look of the window also depends on the browser. We can’t modify it.\n\nThat is the price for simplicity. There are other ways to show nicer windows and richer interaction with the visitor, but if “bells and whistles” do not matter much, these methods work just fine.\n\nTasks\nA simple page\nimportance: 4\n\nCreate a web-page that asks for a name and outputs it.\n\nRun the demo\n\nsolution"
  },
  {
    "title": "Data types",
    "url": "https://javascript.info/types",
    "html": "A value in JavaScript is always of a certain type. For example, a string or a number.\n\nThere are eight basic data types in JavaScript. Here, we’ll cover them in general and in the next chapters we’ll talk about each of them in detail.\n\nWe can put any type in a variable. For example, a variable can at one moment be a string and then store a number:\n\n// no error\nlet message = \"hello\";\nmessage = 123456;\n\nProgramming languages that allow such things, such as JavaScript, are called “dynamically typed”, meaning that there exist data types, but variables are not bound to any of them.\n\nNumber\nlet n = 123;\nn = 12.345;\n\nThe number type represents both integer and floating point numbers.\n\nThere are many operations for numbers, e.g. multiplication *, division /, addition +, subtraction -, and so on.\n\nBesides regular numbers, there are so-called “special numeric values” which also belong to this data type: Infinity, -Infinity and NaN.\n\nInfinity represents the mathematical Infinity ∞. It is a special value that’s greater than any number.\n\nWe can get it as a result of division by zero:\n\n\t\nalert( 1 / 0 ); // Infinity\n\nOr just reference it directly:\n\n\t\nalert( Infinity ); // Infinity\n\nNaN represents a computational error. It is a result of an incorrect or an undefined mathematical operation, for instance:\n\n\t\nalert( \"not a number\" / 2 ); // NaN, such division is erroneous\n\nNaN is sticky. Any further mathematical operation on NaN returns NaN:\n\n\t\nalert( NaN + 1 ); // NaN\nalert( 3 * NaN ); // NaN\nalert( \"not a number\" / 2 - 1 ); // NaN\n\nSo, if there’s a NaN somewhere in a mathematical expression, it propagates to the whole result (there’s only one exception to that: NaN ** 0 is 1).\n\nMathematical operations are safe\n\nDoing maths is “safe” in JavaScript. We can do anything: divide by zero, treat non-numeric strings as numbers, etc.\n\nThe script will never stop with a fatal error (“die”). At worst, we’ll get NaN as the result.\n\nSpecial numeric values formally belong to the “number” type. Of course they are not numbers in the common sense of this word.\n\nWe’ll see more about working with numbers in the chapter Numbers.\n\nBigInt\n\nIn JavaScript, the “number” type cannot safely represent integer values larger than (253-1) (that’s 9007199254740991), or less than -(253-1) for negatives.\n\nTo be really precise, the “number” type can store larger integers (up to 1.7976931348623157 * 10308), but outside of the safe integer range ±(253-1) there’ll be a precision error, because not all digits fit into the fixed 64-bit storage. So an “approximate” value may be stored.\n\nFor example, these two numbers (right above the safe range) are the same:\n\nconsole.log(9007199254740991 + 1); // 9007199254740992\nconsole.log(9007199254740991 + 2); // 9007199254740992\n\nSo to say, all odd integers greater than (253-1) can’t be stored at all in the “number” type.\n\nFor most purposes ±(253-1) range is quite enough, but sometimes we need the entire range of really big integers, e.g. for cryptography or microsecond-precision timestamps.\n\nBigInt type was recently added to the language to represent integers of arbitrary length.\n\nA BigInt value is created by appending n to the end of an integer:\n\n// the \"n\" at the end means it's a BigInt\nconst bigInt = 1234567890123456789012345678901234567890n;\n\nAs BigInt numbers are rarely needed, we don’t cover them here, but devoted them a separate chapter BigInt. Read it when you need such big numbers.\n\nCompatibility issues\n\nRight now, BigInt is supported in Firefox/Chrome/Edge/Safari, but not in IE.\n\nYou can check MDN BigInt compatibility table to know which versions of a browser are supported.\n\nString\n\nA string in JavaScript must be surrounded by quotes.\n\nlet str = \"Hello\";\nlet str2 = 'Single quotes are ok too';\nlet phrase = `can embed another ${str}`;\n\nIn JavaScript, there are 3 types of quotes.\n\nDouble quotes: \"Hello\".\nSingle quotes: 'Hello'.\nBackticks: `Hello`.\n\nDouble and single quotes are “simple” quotes. There’s practically no difference between them in JavaScript.\n\nBackticks are “extended functionality” quotes. They allow us to embed variables and expressions into a string by wrapping them in ${…}, for example:\n\n\t\nlet name = \"John\";\n\n// embed a variable\nalert( `Hello, ${name}!` ); // Hello, John!\n\n// embed an expression\nalert( `the result is ${1 + 2}` ); // the result is 3\n\nThe expression inside ${…} is evaluated and the result becomes a part of the string. We can put anything in there: a variable like name or an arithmetical expression like 1 + 2 or something more complex.\n\nPlease note that this can only be done in backticks. Other quotes don’t have this embedding functionality!\n\n\t\nalert( \"the result is ${1 + 2}\" ); // the result is ${1 + 2} (double quotes do nothing)\n\nWe’ll cover strings more thoroughly in the chapter Strings.\n\nThere is no character type.\n\nIn some languages, there is a special “character” type for a single character. For example, in the C language and in Java it is called “char”.\n\nIn JavaScript, there is no such type. There’s only one type: string. A string may consist of zero characters (be empty), one character or many of them.\n\nBoolean (logical type)\n\nThe boolean type has only two values: true and false.\n\nThis type is commonly used to store yes/no values: true means “yes, correct”, and false means “no, incorrect”.\n\nFor instance:\n\nlet nameFieldChecked = true; // yes, name field is checked\nlet ageFieldChecked = false; // no, age field is not checked\n\nBoolean values also come as a result of comparisons:\n\n\t\nlet isGreater = 4 > 1;\n\nalert( isGreater ); // true (the comparison result is \"yes\")\n\nWe’ll cover booleans more deeply in the chapter Logical operators.\n\nThe “null” value\n\nThe special null value does not belong to any of the types described above.\n\nIt forms a separate type of its own which contains only the null value:\n\nlet age = null;\n\nIn JavaScript, null is not a “reference to a non-existing object” or a “null pointer” like in some other languages.\n\nIt’s just a special value which represents “nothing”, “empty” or “value unknown”.\n\nThe code above states that age is unknown.\n\nThe “undefined” value\n\nThe special value undefined also stands apart. It makes a type of its own, just like null.\n\nThe meaning of undefined is “value is not assigned”.\n\nIf a variable is declared, but not assigned, then its value is undefined:\n\n\t\nlet age;\n\nalert(age); // shows \"undefined\"\n\nTechnically, it is possible to explicitly assign undefined to a variable:\n\n\t\nlet age = 100;\n\n// change the value to undefined\nage = undefined;\n\nalert(age); // \"undefined\"\n\n…But we don’t recommend doing that. Normally, one uses null to assign an “empty” or “unknown” value to a variable, while undefined is reserved as a default initial value for unassigned things.\n\nObjects and Symbols\n\nThe object type is special.\n\nAll other types are called “primitive” because their values can contain only a single thing (be it a string or a number or whatever). In contrast, objects are used to store collections of data and more complex entities.\n\nBeing that important, objects deserve a special treatment. We’ll deal with them later in the chapter Objects, after we learn more about primitives.\n\nThe symbol type is used to create unique identifiers for objects. We have to mention it here for the sake of completeness, but also postpone the details till we know objects.\n\nThe typeof operator\n\nThe typeof operator returns the type of the operand. It’s useful when we want to process values of different types differently or just want to do a quick check.\n\nA call to typeof x returns a string with the type name:\n\ntypeof undefined // \"undefined\"\n\ntypeof 0 // \"number\"\n\ntypeof 10n // \"bigint\"\n\ntypeof true // \"boolean\"\n\ntypeof \"foo\" // \"string\"\n\ntypeof Symbol(\"id\") // \"symbol\"\n\ntypeof Math // \"object\"  (1)\n\ntypeof null // \"object\"  (2)\n\ntypeof alert // \"function\"  (3)\n\nThe last three lines may need additional explanation:\n\nMath is a built-in object that provides mathematical operations. We will learn it in the chapter Numbers. Here, it serves just as an example of an object.\nThe result of typeof null is \"object\". That’s an officially recognized error in typeof, coming from very early days of JavaScript and kept for compatibility. Definitely, null is not an object. It is a special value with a separate type of its own. The behavior of typeof is wrong here.\nThe result of typeof alert is \"function\", because alert is a function. We’ll study functions in the next chapters where we’ll also see that there’s no special “function” type in JavaScript. Functions belong to the object type. But typeof treats them differently, returning \"function\". That also comes from the early days of JavaScript. Technically, such behavior isn’t correct, but can be convenient in practice.\nThe typeof(x) syntax\n\nYou may also come across another syntax: typeof(x). It’s the same as typeof x.\n\nTo put it clear: typeof is an operator, not a function. The parentheses here aren’t a part of typeof. It’s the kind of parentheses used for mathematical grouping.\n\nUsually, such parentheses contain a mathematical expression, such as (2 + 2), but here they contain only one argument (x). Syntactically, they allow to avoid a space between the typeof operator and its argument, and some people like it.\n\nSome people prefer typeof(x), although the typeof x syntax is much more common.\n\nSummary\n\nThere are 8 basic data types in JavaScript.\n\nSeven primitive data types:\nnumber for numbers of any kind: integer or floating-point, integers are limited by ±(253-1).\nbigint for integer numbers of arbitrary length.\nstring for strings. A string may have zero or more characters, there’s no separate single-character type.\nboolean for true/false.\nnull for unknown values – a standalone type that has a single value null.\nundefined for unassigned values – a standalone type that has a single value undefined.\nsymbol for unique identifiers.\nAnd one non-primitive data type:\nobject for more complex data structures.\n\nThe typeof operator allows us to see which type is stored in a variable.\n\nUsually used as typeof x, but typeof(x) is also possible.\nReturns a string with the name of the type, like \"string\".\nFor null returns \"object\" – this is an error in the language, it’s not actually an object.\n\nIn the next chapters, we’ll concentrate on primitive values and once we’re familiar with them, we’ll move on to objects.\n\nTasks\nString quotes\nimportance: 5\n\nWhat is the output of the script?\n\nlet name = \"Ilya\";\n\nalert( `hello ${1}` ); // ?\n\nalert( `hello ${\"name\"}` ); // ?\n\nalert( `hello ${name}` ); // ?\nsolution"
  },
  {
    "title": "Variables",
    "url": "https://javascript.info/variables",
    "html": "Most of the time, a JavaScript application needs to work with information. Here are two examples:\n\nAn online shop – the information might include goods being sold and a shopping cart.\nA chat application – the information might include users, messages, and much more.\n\nVariables are used to store this information.\n\nA variable\n\nA variable is a “named storage” for data. We can use variables to store goodies, visitors, and other data.\n\nTo create a variable in JavaScript, use the let keyword.\n\nThe statement below creates (in other words: declares) a variable with the name “message”:\n\nlet message;\n\nNow, we can put some data into it by using the assignment operator =:\n\nlet message;\n\nmessage = 'Hello'; // store the string 'Hello' in the variable named message\n\nThe string is now saved into the memory area associated with the variable. We can access it using the variable name:\n\n\t\nlet message;\nmessage = 'Hello!';\n\nalert(message); // shows the variable content\n\nTo be concise, we can combine the variable declaration and assignment into a single line:\n\n\t\nlet message = 'Hello!'; // define the variable and assign the value\n\nalert(message); // Hello!\n\nWe can also declare multiple variables in one line:\n\nlet user = 'John', age = 25, message = 'Hello';\n\nThat might seem shorter, but we don’t recommend it. For the sake of better readability, please use a single line per variable.\n\nThe multiline variant is a bit longer, but easier to read:\n\nlet user = 'John';\nlet age = 25;\nlet message = 'Hello';\n\nSome people also define multiple variables in this multiline style:\n\nlet user = 'John',\n  age = 25,\n  message = 'Hello';\n\n…Or even in the “comma-first” style:\n\nlet user = 'John'\n  , age = 25\n  , message = 'Hello';\n\nTechnically, all these variants do the same thing. So, it’s a matter of personal taste and aesthetics.\n\nvar instead of let\n\nIn older scripts, you may also find another keyword: var instead of let:\n\nvar message = 'Hello';\n\nThe var keyword is almost the same as let. It also declares a variable, but in a slightly different, “old-school” way.\n\nThere are subtle differences between let and var, but they do not matter for us yet. We’ll cover them in detail in the chapter The old \"var\".\n\nA real-life analogy\n\nWe can easily grasp the concept of a “variable” if we imagine it as a “box” for data, with a uniquely-named sticker on it.\n\nFor instance, the variable message can be imagined as a box labeled \"message\" with the value \"Hello!\" in it:\n\nWe can put any value in the box.\n\nWe can also change it as many times as we want:\n\n\t\nlet message;\n\nmessage = 'Hello!';\n\nmessage = 'World!'; // value changed\n\nalert(message);\n\nWhen the value is changed, the old data is removed from the variable:\n\nWe can also declare two variables and copy data from one into the other.\n\n\t\nlet hello = 'Hello world!';\n\nlet message;\n\n// copy 'Hello world' from hello into message\nmessage = hello;\n\n// now two variables hold the same data\nalert(hello); // Hello world!\nalert(message); // Hello world!\nDeclaring twice triggers an error\n\nA variable should be declared only once.\n\nA repeated declaration of the same variable is an error:\n\n\t\nlet message = \"This\";\n\n// repeated 'let' leads to an error\nlet message = \"That\"; // SyntaxError: 'message' has already been declared\n\nSo, we should declare a variable once and then refer to it without let.\n\nFunctional languages\n\nIt’s interesting to note that there exist so-called pure functional programming languages, such as Haskell, that forbid changing variable values.\n\nIn such languages, once the value is stored “in the box”, it’s there forever. If we need to store something else, the language forces us to create a new box (declare a new variable). We can’t reuse the old one.\n\nThough it may seem a little odd at first sight, these languages are quite capable of serious development. More than that, there are areas like parallel computations where this limitation confers certain benefits.\n\nVariable naming\n\nThere are two limitations on variable names in JavaScript:\n\nThe name must contain only letters, digits, or the symbols $ and _.\nThe first character must not be a digit.\n\nExamples of valid names:\n\nlet userName;\nlet test123;\n\nWhen the name contains multiple words, camelCase is commonly used. That is: words go one after another, each word except first starting with a capital letter: myVeryLongName.\n\nWhat’s interesting – the dollar sign '$' and the underscore '_' can also be used in names. They are regular symbols, just like letters, without any special meaning.\n\nThese names are valid:\n\n\t\nlet $ = 1; // declared a variable with the name \"$\"\nlet _ = 2; // and now a variable with the name \"_\"\n\nalert($ + _); // 3\n\nExamples of incorrect variable names:\n\nlet 1a; // cannot start with a digit\n\nlet my-name; // hyphens '-' aren't allowed in the name\nCase matters\n\nVariables named apple and APPLE are two different variables.\n\nNon-Latin letters are allowed, but not recommended\n\nIt is possible to use any language, including cyrillic letters, Chinese logograms and so on, like this:\n\nlet имя = '...';\nlet 我 = '...';\n\nTechnically, there is no error here. Such names are allowed, but there is an international convention to use English in variable names. Even if we’re writing a small script, it may have a long life ahead. People from other countries may need to read it some time.\n\nReserved names\n\nThere is a list of reserved words, which cannot be used as variable names because they are used by the language itself.\n\nFor example: let, class, return, and function are reserved.\n\nThe code below gives a syntax error:\n\n\t\nlet let = 5; // can't name a variable \"let\", error!\nlet return = 5; // also can't name it \"return\", error!\nAn assignment without use strict\n\nNormally, we need to define a variable before using it. But in the old times, it was technically possible to create a variable by a mere assignment of the value without using let. This still works now if we don’t put use strict in our scripts to maintain compatibility with old scripts.\n\n\t\n// note: no \"use strict\" in this example\n\nnum = 5; // the variable \"num\" is created if it didn't exist\n\nalert(num); // 5\n\nThis is a bad practice and would cause an error in strict mode:\n\n\"use strict\";\n\nnum = 5; // error: num is not defined\nConstants\n\nTo declare a constant (unchanging) variable, use const instead of let:\n\nconst myBirthday = '18.04.1982';\n\nVariables declared using const are called “constants”. They cannot be reassigned. An attempt to do so would cause an error:\n\n\t\nconst myBirthday = '18.04.1982';\n\nmyBirthday = '01.01.2001'; // error, can't reassign the constant!\n\nWhen a programmer is sure that a variable will never change, they can declare it with const to guarantee and clearly communicate that fact to everyone.\n\nUppercase constants\n\nThere is a widespread practice to use constants as aliases for difficult-to-remember values that are known prior to execution.\n\nSuch constants are named using capital letters and underscores.\n\nFor instance, let’s make constants for colors in so-called “web” (hexadecimal) format:\n\n\t\nconst COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n\n// ...when we need to pick a color\nlet color = COLOR_ORANGE;\nalert(color); // #FF7F00\n\nBenefits:\n\nCOLOR_ORANGE is much easier to remember than \"#FF7F00\".\nIt is much easier to mistype \"#FF7F00\" than COLOR_ORANGE.\nWhen reading the code, COLOR_ORANGE is much more meaningful than #FF7F00.\n\nWhen should we use capitals for a constant and when should we name it normally? Let’s make that clear.\n\nBeing a “constant” just means that a variable’s value never changes. But there are constants that are known prior to execution (like a hexadecimal value for red) and there are constants that are calculated in run-time, during the execution, but do not change after their initial assignment.\n\nFor instance:\n\nconst pageLoadTime = /* time taken by a webpage to load */;\n\nThe value of pageLoadTime is not known prior to the page load, so it’s named normally. But it’s still a constant because it doesn’t change after assignment.\n\nIn other words, capital-named constants are only used as aliases for “hard-coded” values.\n\nName things right\n\nTalking about variables, there’s one more extremely important thing.\n\nA variable name should have a clean, obvious meaning, describing the data that it stores.\n\nVariable naming is one of the most important and complex skills in programming. A quick glance at variable names can reveal which code was written by a beginner versus an experienced developer.\n\nIn a real project, most of the time is spent modifying and extending an existing code base rather than writing something completely separate from scratch. When we return to some code after doing something else for a while, it’s much easier to find information that is well-labeled. Or, in other words, when the variables have good names.\n\nPlease spend time thinking about the right name for a variable before declaring it. Doing so will repay you handsomely.\n\nSome good-to-follow rules are:\n\nUse human-readable names like userName or shoppingCart.\nStay away from abbreviations or short names like a, b, c, unless you really know what you’re doing.\nMake names maximally descriptive and concise. Examples of bad names are data and value. Such names say nothing. It’s only okay to use them if the context of the code makes it exceptionally obvious which data or value the variable is referencing.\nAgree on terms within your team and in your own mind. If a site visitor is called a “user” then we should name related variables currentUser or newUser instead of currentVisitor or newManInTown.\n\nSounds simple? Indeed it is, but creating descriptive and concise variable names in practice is not. Go for it.\n\nReuse or create?\n\nAnd the last note. There are some lazy programmers who, instead of declaring new variables, tend to reuse existing ones.\n\nAs a result, their variables are like boxes into which people throw different things without changing their stickers. What’s inside the box now? Who knows? We need to come closer and check.\n\nSuch programmers save a little bit on variable declaration but lose ten times more on debugging.\n\nAn extra variable is good, not evil.\n\nModern JavaScript minifiers and browsers optimize code well enough, so it won’t create performance issues. Using different variables for different values can even help the engine optimize your code.\n\nSummary\n\nWe can declare variables to store data by using the var, let, or const keywords.\n\nlet – is a modern variable declaration.\nvar – is an old-school variable declaration. Normally we don’t use it at all, but we’ll cover subtle differences from let in the chapter The old \"var\", just in case you need them.\nconst – is like let, but the value of the variable can’t be changed.\n\nVariables should be named in a way that allows us to easily understand what’s inside them.\n\nTasks\nWorking with variables\nimportance: 2\nDeclare two variables: admin and name.\nAssign the value \"John\" to name.\nCopy the value from name to admin.\nShow the value of admin using alert (must output “John”).\nsolution\nGiving the right name\nimportance: 3\nCreate a variable with the name of our planet. How would you name such a variable?\nCreate a variable to store the name of a current visitor to a website. How would you name that variable?\nsolution\nUppercase const?\nimportance: 4\n\nExamine the following code:\n\nconst birthday = '18.04.1982';\n\nconst age = someCode(birthday);\n\nHere we have a constant birthday for the date, and also the age constant.\n\nThe age is calculated from birthday using someCode(), which means a function call that we didn’t explain yet (we will soon!), but the details don’t matter here, the point is that age is calculated somehow based on the birthday.\n\nWould it be right to use upper case for birthday? For age? Or even for both?\n\nconst BIRTHDAY = '18.04.1982'; // make birthday uppercase?\n\nconst AGE = someCode(BIRTHDAY); // make age uppercase?\nsolution"
  },
  {
    "title": "The modern mode, \"use strict\"",
    "url": "https://javascript.info/strict-mode",
    "html": "For a long time, JavaScript evolved without compatibility issues. New features were added to the language while old functionality didn’t change.\n\nThat had the benefit of never breaking existing code. But the downside was that any mistake or an imperfect decision made by JavaScript’s creators got stuck in the language forever.\n\nThis was the case until 2009 when ECMAScript 5 (ES5) appeared. It added new features to the language and modified some of the existing ones. To keep the old code working, most such modifications are off by default. You need to explicitly enable them with a special directive: \"use strict\".\n\n“use strict”\n\nThe directive looks like a string: \"use strict\" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.\n\nFor example:\n\n\"use strict\";\n\n// this code works the modern way\n...\n\nQuite soon we’re going to learn functions (a way to group commands), so let’s note in advance that \"use strict\" can be put at the beginning of a function. Doing that enables strict mode in that function only. But usually people use it for the whole script.\n\nEnsure that “use strict” is at the top\n\nPlease make sure that \"use strict\" is at the top of your scripts, otherwise strict mode may not be enabled.\n\nStrict mode isn’t enabled here:\n\nalert(\"some code\");\n// \"use strict\" below is ignored--it must be at the top\n\n\"use strict\";\n\n// strict mode is not activated\n\nOnly comments may appear above \"use strict\".\n\nThere’s no way to cancel use strict\n\nThere is no directive like \"no use strict\" that reverts the engine to old behavior.\n\nOnce we enter strict mode, there’s no going back.\n\nBrowser console\n\nWhen you use a developer console to run code, please note that it doesn’t use strict by default.\n\nSometimes, when use strict makes a difference, you’ll get incorrect results.\n\nSo, how to actually use strict in the console?\n\nFirst, you can try to press Shift+Enter to input multiple lines, and put use strict on top, like this:\n\n'use strict'; <Shift+Enter for a newline>\n//  ...your code\n<Enter to run>\n\nIt works in most browsers, namely Firefox and Chrome.\n\nIf it doesn’t, e.g. in an old browser, there’s an ugly, but reliable way to ensure use strict. Put it inside this kind of wrapper:\n\n(function() {\n  'use strict';\n\n  // ...your code here...\n})()\nShould we “use strict”?\n\nThe question may sound obvious, but it’s not so.\n\nOne could recommend to start scripts with \"use strict\"… But you know what’s cool?\n\nModern JavaScript supports “classes” and “modules” – advanced language structures (we’ll surely get to them), that enable use strict automatically. So we don’t need to add the \"use strict\" directive, if we use them.\n\nSo, for now \"use strict\"; is a welcome guest at the top of your scripts. Later, when your code is all in classes and modules, you may omit it.\n\nAs of now, we’ve got to know about use strict in general.\n\nIn the next chapters, as we learn language features, we’ll see the differences between the strict and old modes. Luckily, there aren’t many and they actually make our lives better.\n\nAll examples in this tutorial assume strict mode unless (very rarely) specified otherwise."
  },
  {
    "title": "Code structure",
    "url": "https://javascript.info/structure",
    "html": "The first thing we’ll study is the building blocks of code.\n\nStatements\n\nStatements are syntax constructs and commands that perform actions.\n\nWe’ve already seen a statement, alert('Hello, world!'), which shows the message “Hello, world!”.\n\nWe can have as many statements in our code as we want. Statements can be separated with a semicolon.\n\nFor example, here we split “Hello World” into two alerts:\n\n\t\nalert('Hello'); alert('World');\n\nUsually, statements are written on separate lines to make the code more readable:\n\n\t\nalert('Hello');\nalert('World');\nSemicolons\n\nA semicolon may be omitted in most cases when a line break exists.\n\nThis would also work:\n\n\t\nalert('Hello')\nalert('World')\n\nHere, JavaScript interprets the line break as an “implicit” semicolon. This is called an automatic semicolon insertion.\n\nIn most cases, a newline implies a semicolon. But “in most cases” does not mean “always”!\n\nThere are cases when a newline does not mean a semicolon. For example:\n\n\t\nalert(3 +\n1\n+ 2);\n\nThe code outputs 6 because JavaScript does not insert semicolons here. It is intuitively obvious that if the line ends with a plus \"+\", then it is an “incomplete expression”, so a semicolon there would be incorrect. And in this case, that works as intended.\n\nBut there are situations where JavaScript “fails” to assume a semicolon where it is really needed.\n\nErrors which occur in such cases are quite hard to find and fix.\n\nAn example of an error\n\nIf you’re curious to see a concrete example of such an error, check this code out:\n\n\t\nalert(\"Hello\");\n\n[1, 2].forEach(alert);\n\nNo need to think about the meaning of the brackets [] and forEach yet. We’ll study them later. For now, just remember the result of running the code: it shows Hello, then 1, then 2.\n\nNow let’s remove the semicolon after the alert:\n\n\t\nalert(\"Hello\")\n\n[1, 2].forEach(alert);\n\nThe difference compared to the code above is only one character: the semicolon at the end of the first line is gone.\n\nIf we run this code, only the first Hello shows (and there’s an error, you may need to open the console to see it). There are no numbers any more.\n\nThat’s because JavaScript does not assume a semicolon before square brackets [...]. So, the code in the last example is treated as a single statement.\n\nHere’s how the engine sees it:\n\n\t\nalert(\"Hello\")[1, 2].forEach(alert);\n\nLooks weird, right? Such merging in this case is just wrong. We need to put a semicolon after alert for the code to work correctly.\n\nThis can happen in other situations also.\n\nWe recommend putting semicolons between statements even if they are separated by newlines. This rule is widely adopted by the community. Let’s note once again – it is possible to leave out semicolons most of the time. But it’s safer – especially for a beginner – to use them.\n\nComments\n\nAs time goes on, programs become more and more complex. It becomes necessary to add comments which describe what the code does and why.\n\nComments can be put into any place of a script. They don’t affect its execution because the engine simply ignores them.\n\nOne-line comments start with two forward slash characters //.\n\nThe rest of the line is a comment. It may occupy a full line of its own or follow a statement.\n\nLike here:\n\n\t\n// This comment occupies a line of its own\nalert('Hello');\n\nalert('World'); // This comment follows the statement\n\nMultiline comments start with a forward slash and an asterisk /* and end with an asterisk and a forward slash */.\n\nLike this:\n\n\t\n/* An example with two messages.\nThis is a multiline comment.\n*/\nalert('Hello');\nalert('World');\n\nThe content of comments is ignored, so if we put code inside /* … */, it won’t execute.\n\nSometimes it can be handy to temporarily disable a part of code:\n\n\t\n/* Commenting out the code\nalert('Hello');\n*/\nalert('World');\nUse hotkeys!\n\nIn most editors, a line of code can be commented out by pressing the Ctrl+/ hotkey for a single-line comment and something like Ctrl+Shift+/ – for multiline comments (select a piece of code and press the hotkey). For Mac, try Cmd instead of Ctrl and Option instead of Shift.\n\nNested comments are not supported!\n\nThere may not be /*...*/ inside another /*...*/.\n\nSuch code will die with an error:\n\n\t\n/*\n  /* nested comment ?!? */\n*/\nalert( 'World' );\n\nPlease, don’t hesitate to comment your code.\n\nComments increase the overall code footprint, but that’s not a problem at all. There are many tools which minify code before publishing to a production server. They remove comments, so they don’t appear in the working scripts. Therefore, comments do not have negative effects on production at all.\n\nLater in the tutorial there will be a chapter Code quality that also explains how to write better comments."
  },
  {
    "title": "About the project",
    "url": "https://javascript.info/about",
    "html": "About the project\n\nThe Modern JavaScript Tutorial was created in 2007 by Ilya Kantor, and regularly updated since then. New chapters were added, outdated ones - removed, to stay fresh. The PDF version is about 1300 pages, starting from the beginning, and then to advanced topics.\n\nIt's a book, not a video, as for many people reading is faster. Also, books are easier to update, keep modern :).\n\nThe content of this tutorial is open source and everyone is welcome to contribute.\n\nContacts\nTechlead LLC\nYerevan, Armenia\nadmin@javascript.info\nBug or typo? Great idea?\n\nPlease create an issue on our github.\n\nWe want to make this open-source project available for people all around the world.\n\nHelp to translate the content of this tutorial to your language!\n\nThe team\nIlya Kantor\nAuthor, trainer, JS-developer\nAlexey Maximov\nSystem Administrator\nArtem Beztsinniy\nDesigner\nSergey Zelenov\nJS-developer, teacher\nStepan Suvorov\nAngular trainer\nTutorial maintainers\nIlya Kantor\n\nThe tutorial repository is at https://github.com/javascript-tutorial/en.javascript.info.\n\nContributors\n\nThe list below includes all contributors-authors of 10+ lines of the tutorial. The full list of contributors is available at github.\n\nIt's very easy to become listed. Just write an article or propose fixes in the tutorial repository. And get everyone's thanks.\n\nContributor\tLines\tPercent\nIlya Kantor\t60648\t90.75%\nOleksandr Tkachenko\t1183\t1.77%\nimidom\t474\t0.71%\nAlexander\t234\t0.35%\nparoche\t210\t0.31%\nBrent Guffens\t201\t0.30%\nShow all ▾"
  },
  {
    "title": "Developer console",
    "url": "https://javascript.info/devtools",
    "html": "Code is prone to errors. You will quite likely make errors… Oh, what am I talking about? You are absolutely going to make errors, at least if you’re a human, not a robot.\n\nBut in the browser, users don’t see errors by default. So, if something goes wrong in the script, we won’t see what’s broken and can’t fix it.\n\nTo see errors and get a lot of other useful information about scripts, “developer tools” have been embedded in browsers.\n\nMost developers lean towards Chrome or Firefox for development because those browsers have the best developer tools. Other browsers also provide developer tools, sometimes with special features, but are usually playing “catch-up” to Chrome or Firefox. So most developers have a “favorite” browser and switch to others if a problem is browser-specific.\n\nDeveloper tools are potent; they have many features. To start, we’ll learn how to open them, look at errors, and run JavaScript commands.\n\nGoogle Chrome\n\nOpen the page bug.html.\n\nThere’s an error in the JavaScript code on it. It’s hidden from a regular visitor’s eyes, so let’s open developer tools to see it.\n\nPress F12 or, if you’re on Mac, then Cmd+Opt+J.\n\nThe developer tools will open on the Console tab by default.\n\nIt looks somewhat like this:\n\nThe exact look of developer tools depends on your version of Chrome. It changes from time to time but should be similar.\n\nHere we can see the red-colored error message. In this case, the script contains an unknown “lalala” command.\nOn the right, there is a clickable link to the source bug.html:12 with the line number where the error has occurred.\n\nBelow the error message, there is a blue > symbol. It marks a “command line” where we can type JavaScript commands. Press Enter to run them.\n\nNow we can see errors, and that’s enough for a start. We’ll come back to developer tools later and cover debugging more in-depth in the chapter Debugging in the browser.\n\nMulti-line input\n\nUsually, when we put a line of code into the console, and then press Enter, it executes.\n\nTo insert multiple lines, press Shift+Enter. This way one can enter long fragments of JavaScript code.\n\nFirefox, Edge, and others\n\nMost other browsers use F12 to open developer tools.\n\nThe look & feel of them is quite similar. Once you know how to use one of these tools (you can start with Chrome), you can easily switch to another.\n\nSafari\n\nSafari (Mac browser, not supported by Windows/Linux) is a little bit special here. We need to enable the “Develop menu” first.\n\nOpen Preferences and go to the “Advanced” pane. There’s a checkbox at the bottom:\n\nNow Cmd+Opt+C can toggle the console. Also, note that the new top menu item named “Develop” has appeared. It has many commands and options.\n\nSummary\nDeveloper tools allow us to see errors, run commands, examine variables, and much more.\nThey can be opened with F12 for most browsers on Windows. Chrome for Mac needs Cmd+Opt+J, Safari: Cmd+Opt+C (need to enable first).\n\nNow we have the environment ready. In the next section, we’ll get down to JavaScript."
  },
  {
    "title": "Hello, world!",
    "url": "https://javascript.info/hello-world",
    "html": "This part of the tutorial is about core JavaScript, the language itself.\n\nBut we need a working environment to run our scripts and, since this book is online, the browser is a good choice. We’ll keep the amount of browser-specific commands (like alert) to a minimum so that you don’t spend time on them if you plan to concentrate on another environment (like Node.js). We’ll focus on JavaScript in the browser in the next part of the tutorial.\n\nSo first, let’s see how we attach a script to a webpage. For server-side environments (like Node.js), you can execute the script with a command like \"node my.js\".\n\nThe “script” tag\n\nJavaScript programs can be inserted almost anywhere into an HTML document using the <script> tag.\n\nFor instance:\n\n\t\n<!DOCTYPE HTML>\n<html>\n\n<body>\n\n  <p>Before the script...</p>\n\n  <script>\n    alert( 'Hello, world!' );\n  </script>\n\n  <p>...After the script.</p>\n\n</body>\n\n</html>\n\nYou can run the example by clicking the “Play” button in the right-top corner of the box above.\n\nThe <script> tag contains JavaScript code which is automatically executed when the browser processes the tag.\n\nModern markup\n\nThe <script> tag has a few attributes that are rarely used nowadays but can still be found in old code:\n\nThe type attribute: <script type=…>\n\nThe old HTML standard, HTML4, required a script to have a type. Usually it was type=\"text/javascript\". It’s not required anymore. Also, the modern HTML standard totally changed the meaning of this attribute. Now, it can be used for JavaScript modules. But that’s an advanced topic, we’ll talk about modules in another part of the tutorial.\n\nThe language attribute: <script language=…>\n\nThis attribute was meant to show the language of the script. This attribute no longer makes sense because JavaScript is the default language. There is no need to use it.\n\nComments before and after scripts.\n\nIn really ancient books and guides, you may find comments inside <script> tags, like this:\n\n<script type=\"text/javascript\"><!--\n    ...\n//--></script>\n\nThis trick isn’t used in modern JavaScript. These comments hide JavaScript code from old browsers that didn’t know how to process the <script> tag. Since browsers released in the last 15 years don’t have this issue, this kind of comment can help you identify really old code.\n\nExternal scripts\n\nIf we have a lot of JavaScript code, we can put it into a separate file.\n\nScript files are attached to HTML with the src attribute:\n\n<script src=\"/path/to/script.js\"></script>\n\nHere, /path/to/script.js is an absolute path to the script from the site root. One can also provide a relative path from the current page. For instance, src=\"script.js\", just like src=\"./script.js\", would mean a file \"script.js\" in the current folder.\n\nWe can give a full URL as well. For instance:\n\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js\"></script>\n\nTo attach several scripts, use multiple tags:\n\n<script src=\"/js/script1.js\"></script>\n<script src=\"/js/script2.js\"></script>\n…\nPlease note:\n\nAs a rule, only the simplest scripts are put into HTML. More complex ones reside in separate files.\n\nThe benefit of a separate file is that the browser will download it and store it in its cache.\n\nOther pages that reference the same script will take it from the cache instead of downloading it, so the file is actually downloaded only once.\n\nThat reduces traffic and makes pages faster.\n\nIf src is set, the script content is ignored.\n\nA single <script> tag can’t have both the src attribute and code inside.\n\nThis won’t work:\n\n<script src=\"file.js\">\n  alert(1); // the content is ignored, because src is set\n</script>\n\nWe must choose either an external <script src=\"…\"> or a regular <script> with code.\n\nThe example above can be split into two scripts to work:\n\n<script src=\"file.js\"></script>\n<script>\n  alert(1);\n</script>\nSummary\nWe can use a <script> tag to add JavaScript code to a page.\nThe type and language attributes are not required.\nA script in an external file can be inserted with <script src=\"path/to/script.js\"></script>.\n\nThere is much more to learn about browser scripts and their interaction with the webpage. But let’s keep in mind that this part of the tutorial is devoted to the JavaScript language, so we shouldn’t distract ourselves with browser-specific implementations of it. We’ll be using the browser as a way to run JavaScript, which is very convenient for online reading, but only one of many.\n\nTasks\nShow an alert\nimportance: 5\n\nCreate a page that shows a message “I’m JavaScript!”.\n\nDo it in a sandbox, or on your hard drive, doesn’t matter, just ensure that it works.\n\nDemo in new window\n\nsolution\nShow an alert with an external script\nimportance: 5\n\nTake the solution of the previous task Show an alert. Modify it by extracting the script content into an external file alert.js, residing in the same folder.\n\nOpen the page, ensure that the alert works.\n\nsolution"
  },
  {
    "title": "JavaScript Fundamentals",
    "url": "https://javascript.info/first-steps",
    "html": "Let’s learn the fundamentals of script building.\n\nHello, world!\nCode structure\nThe modern mode, \"use strict\"\nVariables\nData types\nInteraction: alert, prompt, confirm\nType Conversions\nBasic operators, maths\nComparisons\nConditional branching: if, '?'\nLogical operators\nNullish coalescing operator '??'\nLoops: while and for\nThe \"switch\" statement\nFunctions\nFunction expressions\nArrow functions, the basics\nJavaScript specials"
  },
  {
    "title": "Code editors",
    "url": "https://javascript.info/code-editors",
    "html": "A code editor is the place where programmers spend most of their time.\n\nThere are two main types of code editors: IDEs and lightweight editors. Many people use one tool of each type.\n\nIDE\n\nThe term IDE (Integrated Development Environment) refers to a powerful editor with many features that usually operates on a “whole project.” As the name suggests, it’s not just an editor, but a full-scale “development environment.”\n\nAn IDE loads the project (which can be many files), allows navigation between files, provides autocompletion based on the whole project (not just the open file), and integrates with a version management system (like git), a testing environment, and other “project-level” stuff.\n\nIf you haven’t selected an IDE yet, consider the following options:\n\nVisual Studio Code (cross-platform, free).\nWebStorm (cross-platform, paid).\n\nFor Windows, there’s also “Visual Studio”, not to be confused with “Visual Studio Code”. “Visual Studio” is a paid and mighty Windows-only editor, well-suited for the .NET platform. It’s also good at JavaScript. There’s also a free version Visual Studio Community.\n\nMany IDEs are paid, but have a trial period. Their cost is usually negligible compared to a qualified developer’s salary, so just choose the best one for you.\n\nLightweight editors\n\n“Lightweight editors” are not as powerful as IDEs, but they’re fast, elegant and simple.\n\nThey are mainly used to open and edit a file instantly.\n\nThe main difference between a “lightweight editor” and an “IDE” is that an IDE works on a project-level, so it loads much more data on start, analyzes the project structure if needed and so on. A lightweight editor is much faster if we need only one file.\n\nIn practice, lightweight editors may have a lot of plugins including directory-level syntax analyzers and autocompleters, so there’s no strict border between a lightweight editor and an IDE.\n\nThere are many options, for instance:\n\nSublime Text (cross-platform, shareware).\nNotepad++ (Windows, free).\nVim and Emacs are also cool if you know how to use them.\nLet’s not argue\n\nThe editors in the lists above are those that either I or my friends whom I consider good developers have been using for a long time and are happy with.\n\nThere are other great editors in our big world. Please choose the one you like the most.\n\nThe choice of an editor, like any other tool, is individual and depends on your projects, habits, and personal preferences.\n\nThe author’s personal opinion:\n\nI’d use Visual Studio Code if I develop mostly frontend.\nOtherwise, if it’s mostly another language/platform and partially frontend, then consider other editors, such as XCode (Mac), Visual Studio (Windows) or Jetbrains family (Webstorm, PHPStorm, RubyMine etc, depending on the language)."
  },
  {
    "title": "An Introduction to JavaScript",
    "url": "https://javascript.info/intro",
    "html": "Let’s see what’s so special about JavaScript, what we can achieve with it, and what other technologies play well with it.\n\nWhat is JavaScript?\n\nJavaScript was initially created to “make web pages alive”.\n\nThe programs in this language are called scripts. They can be written right in a web page’s HTML and run automatically as the page loads.\n\nScripts are provided and executed as plain text. They don’t need special preparation or compilation to run.\n\nIn this aspect, JavaScript is very different from another language called Java.\n\nWhy is it called JavaScript?\n\nWhen JavaScript was created, it initially had another name: “LiveScript”. But Java was very popular at that time, so it was decided that positioning a new language as a “younger brother” of Java would help.\n\nBut as it evolved, JavaScript became a fully independent language with its own specification called ECMAScript, and now it has no relation to Java at all.\n\nToday, JavaScript can execute not only in the browser, but also on the server, or actually on any device that has a special program called the JavaScript engine.\n\nThe browser has an embedded engine sometimes called a “JavaScript virtual machine”.\n\nDifferent engines have different “codenames”. For example:\n\nV8 – in Chrome, Opera and Edge.\nSpiderMonkey – in Firefox.\n…There are other codenames like “Chakra” for IE, “JavaScriptCore”, “Nitro” and “SquirrelFish” for Safari, etc.\n\nThe terms above are good to remember because they are used in developer articles on the internet. We’ll use them too. For instance, if “a feature X is supported by V8”, then it probably works in Chrome, Opera and Edge.\n\nHow do engines work?\n\nEngines are complicated. But the basics are easy.\n\nThe engine (embedded if it’s a browser) reads (“parses”) the script.\nThen it converts (“compiles”) the script to machine code.\nAnd then the machine code runs, pretty fast.\n\nThe engine applies optimizations at each step of the process. It even watches the compiled script as it runs, analyzes the data that flows through it, and further optimizes the machine code based on that knowledge.\n\nWhat can in-browser JavaScript do?\n\nModern JavaScript is a “safe” programming language. It does not provide low-level access to memory or the CPU, because it was initially created for browsers which do not require it.\n\nJavaScript’s capabilities greatly depend on the environment it’s running in. For instance, Node.js supports functions that allow JavaScript to read/write arbitrary files, perform network requests, etc.\n\nIn-browser JavaScript can do everything related to webpage manipulation, interaction with the user, and the webserver.\n\nFor instance, in-browser JavaScript is able to:\n\nAdd new HTML to the page, change the existing content, modify styles.\nReact to user actions, run on mouse clicks, pointer movements, key presses.\nSend requests over the network to remote servers, download and upload files (so-called AJAX and COMET technologies).\nGet and set cookies, ask questions to the visitor, show messages.\nRemember the data on the client-side (“local storage”).\nWhat CAN’T in-browser JavaScript do?\n\nJavaScript’s abilities in the browser are limited to protect the user’s safety. The aim is to prevent an evil webpage from accessing private information or harming the user’s data.\n\nExamples of such restrictions include:\n\nJavaScript on a webpage may not read/write arbitrary files on the hard disk, copy them or execute programs. It has no direct access to OS functions.\n\nModern browsers allow it to work with files, but the access is limited and only provided if the user does certain actions, like “dropping” a file into a browser window or selecting it via an <input> tag.\n\nThere are ways to interact with the camera/microphone and other devices, but they require a user’s explicit permission. So a JavaScript-enabled page may not sneakily enable a web-camera, observe the surroundings and send the information to the NSA.\n\nDifferent tabs/windows generally do not know about each other. Sometimes they do, for example when one window uses JavaScript to open the other one. But even in this case, JavaScript from one page may not access the other page if they come from different sites (from a different domain, protocol or port).\n\nThis is called the “Same Origin Policy”. To work around that, both pages must agree for data exchange and must contain special JavaScript code that handles it. We’ll cover that in the tutorial.\n\nThis limitation is, again, for the user’s safety. A page from http://anysite.com which a user has opened must not be able to access another browser tab with the URL http://gmail.com, for example, and steal information from there.\n\nJavaScript can easily communicate over the net to the server where the current page came from. But its ability to receive data from other sites/domains is crippled. Though possible, it requires explicit agreement (expressed in HTTP headers) from the remote side. Once again, that’s a safety limitation.\n\nSuch limitations do not exist if JavaScript is used outside of the browser, for example on a server. Modern browsers also allow plugins/extensions which may ask for extended permissions.\n\nWhat makes JavaScript unique?\n\nThere are at least three great things about JavaScript:\n\nFull integration with HTML/CSS.\nSimple things are done simply.\nSupported by all major browsers and enabled by default.\n\nJavaScript is the only browser technology that combines these three things.\n\nThat’s what makes JavaScript unique. That’s why it’s the most widespread tool for creating browser interfaces.\n\nThat said, JavaScript can be used to create servers, mobile applications, etc.\n\nLanguages “over” JavaScript\n\nThe syntax of JavaScript does not suit everyone’s needs. Different people want different features.\n\nThat’s to be expected, because projects and requirements are different for everyone.\n\nSo, recently a plethora of new languages appeared, which are transpiled (converted) to JavaScript before they run in the browser.\n\nModern tools make the transpilation very fast and transparent, actually allowing developers to code in another language and auto-converting it “under the hood”.\n\nExamples of such languages:\n\nCoffeeScript is “syntactic sugar” for JavaScript. It introduces shorter syntax, allowing us to write clearer and more precise code. Usually, Ruby devs like it.\nTypeScript is concentrated on adding “strict data typing” to simplify the development and support of complex systems. It is developed by Microsoft.\nFlow also adds data typing, but in a different way. Developed by Facebook.\nDart is a standalone language that has its own engine that runs in non-browser environments (like mobile apps), but also can be transpiled to JavaScript. Developed by Google.\nBrython is a Python transpiler to JavaScript that enables the writing of applications in pure Python without JavaScript.\nKotlin is a modern, concise and safe programming language that can target the browser or Node.\n\nThere are more. Of course, even if we use one of these transpiled languages, we should also know JavaScript to really understand what we’re doing.\n\nSummary\nJavaScript was initially created as a browser-only language, but it is now used in many other environments as well.\nToday, JavaScript has a unique position as the most widely-adopted browser language, fully integrated with HTML/CSS.\nThere are many languages that get “transpiled” to JavaScript and provide certain features. It is recommended to take a look at them, at least briefly, after mastering JavaScript."
  },
  {
    "title": "Manuals and specifications",
    "url": "https://javascript.info/manuals-specifications",
    "html": "This book is a tutorial. It aims to help you gradually learn the language. But once you’re familiar with the basics, you’ll need other resources.\n\nSpecification\n\nThe ECMA-262 specification contains the most in-depth, detailed and formalized information about JavaScript. It defines the language.\n\nBut being that formalized, it’s difficult to understand at first. So if you need the most trustworthy source of information about the language details, the specification is the right place. But it’s not for everyday use.\n\nA new specification version is released every year. Between these releases, the latest specification draft is at https://tc39.es/ecma262/.\n\nTo read about new bleeding-edge features, including those that are “almost standard” (so-called “stage 3”), see proposals at https://github.com/tc39/proposals.\n\nAlso, if you’re developing for the browser, then there are other specifications covered in the second part of the tutorial.\n\nManuals\n\nMDN (Mozilla) JavaScript Reference is the main manual with examples and other information. It’s great to get in-depth information about individual language functions, methods etc.\n\nYou can find it at https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference.\n\nAlthough, it’s often best to use an internet search instead. Just use “MDN [term]” in the query, e.g. https://google.com/search?q=MDN+parseInt to search for the parseInt function.\n\nCompatibility tables\n\nJavaScript is a developing language, new features get added regularly.\n\nTo see their support among browser-based and other engines, see:\n\nhttps://caniuse.com – per-feature tables of support, e.g. to see which engines support modern cryptography functions: https://caniuse.com/#feat=cryptography.\nhttps://kangax.github.io/compat-table – a table with language features and engines that support those or don’t support.\n\nAll these resources are useful in real-life development, as they contain valuable information about language details, their support, etc.\n\nPlease remember them (or this page) for the cases when you need in-depth information about a particular feature."
  },
  {
    "title": "An introduction",
    "url": "https://javascript.info/getting-started",
    "html": "About the JavaScript language and the environment to develop with it.\n\nAn Introduction to JavaScript\nManuals and specifications\nCode editors\nDeveloper console"
  },
  {
    "title": "Privacy Policy",
    "url": "https://javascript.info/privacy",
    "html": "We value your privacy.\n\nWe never sell your data to third party. We only use it for intended purposes. And we only send you newsletters if you willingly subscribe.\n\nThis Privacy Policy (the “Policy”) discloses the privacy practices of Techlead LLC, the legal entity behind the site, and other people of the team (referred to collectively as “we”, “us”, “our”).\n\nThe Policy governs how we use and protect personal information that we collect when you visit our website, use our services, or otherwise engage with us.\n\nINFORMATION WE COLLECT\n\nWe collect personal information in the following ways:\n\nINFORMATION THAT YOU PROVIDE TO US DIRECTLY\n\nWe gather information that you provide to us when you:\n\npurchase products or services from us\nsubscribe to our newsletters and mailing lists\nfill in forms, conduct searches, post content on the website, respond to surveys, or use any other features of our websites\nmake an inquiry, provide feedback, submit correspondence, or make a complaint over the phone, by email, on our websites or by post\nregister for, and update an online account with us (including if you access through Facebook, LinkedIn, Twitter, Google, or another provider)\nenter into a contract with us\nsign up for alerts or notifications on our websites, submit a job application, a CV, cover letter, or social media profile to a job vacancy, attend an interview, assessment, or meeting\n‘follow’, ‘like’, post to, or interact with, our social media accounts, including Facebook, LinkedIn, Twitter, Pinterest, Instagram, Google+, SnapChat and Slack.\n\nThe information you provide to us may include (depending on the circumstances):\n\nIdentity and contact data: title, names, addresses, email addresses, phone numbers or your signature.\nAccount profile data: a username/display name, password, user preferences, picture if you upload it, additional details that you enter and, if you sign up through a social media account, certain information about that account.\nLimited payment details if you make a payment at our website. We use a secure third-party service, e.g. Stripe or Paypal for payments, so we do not get your credit card number, but we may have information like the last four digits, your name or the country of issue.\n\nIf you apply for employment:\n\nEmployment and background data, your academic and work history, qualifications, skills, projects and research that you are involved in, references, proof of your entitlement to work in the relevant country, your national security number, your passport or other identity document details, your current level of remuneration (including benefits), and any other such similar information that you may provide to us.\nVisual and audio information about yourself: e.g. a photo or video footage, or sound recording.\nAny other information that you choose to share with us: for example, any information that you provide via correspondence, when you fill out our survey(s), that you share via our website or social media accounts linked to our website, or any information that you choose to provide in person at events, meetings, or over the phone.\nINFORMATION WE COLLECT THROUGH SERVER TECHNOLOGY\n\nWe may store IP addresses in our server logs to ensure network security, the ability of our system to resist unlawful or malicious actions, such as ‘denial of service’ attacks.\n\nWe can also store additional technical details about your visits for diagnostic purposes, to fix errors in our service if they occur.\n\nINFORMATION WE COLLECT THROUGH ONLINE TECHNOLOGY\n\nTechnologies such as cookies, beacons, tags, local storage, and scripts are used by us and our affiliates, and other companies, such as third party technology service providers and web analytics providers. These technologies make it easier for you to navigate our website and to help us manage the content on our website and are used to analyze trends, administer the sites, track users’ movements around the site (including which site you clicked from to arrive at our site), and gather demographic information about our user base.\n\nCookies are small files that a site or its service provider transfers to your computer’s hard drive through your Web browser (if you don’t disable it) that enables the site’s or service provider’s systems to recognize your browser and capture and remember certain information. They are used to help us understand your preferences based on previous or current site activity, which enables us to provide you with improved services.\n\nCookies also help us compile aggregate data about site traffic and site interaction so that we can offer better site experiences and tools in the future.\n\nFor instance, we use Google Analytics and Yandex Metrika to collect statistics about our site.\n\nSPECIAL CATEGORIES OF DATA\n\nSpecial categories of particularly sensitive personal information require higher levels of protection.\n\nWe do not collect such information when you visit our website or purchase or subscribe for a newsletter or ask for services, as we need further justification for that.\n\nThese so-called “special categories of data” include details about your race or ethnicity, religious or philosophical beliefs, sex life, sexual orientation, political opinions, trade union membership, information about your health and genetic and biometric data,criminal convictions and offenses.\n\nThe reasons for collecting, storing and using this type of personal information:\n\nyou apply to work for us, where it is necessary to carry out our legal obligations or exercise rights in connection with employment\nwhere it is necessary for reasons of substantial public interest\nwhere it is necessary in relation to legal claims\nwhere it is necessary to protect your interests (or someone else’s interests) and you are not capable of giving your consent\nwhere you have already made the information public\n\nIn limited circumstances, we may request your written consent to allow us to use certain particularly sensitive data. If we do so, we will provide you with full details of the information that we would like and the reason we need it, so that you can carefully consider whether you wish to consent.\n\nUSING PERSONAL INFORMATION\nHOW WE USE INFORMATION WE COLLECT\n\nWe use your information for the following purposes:\n\nTo provide access to our website in a manner convenient and optimal and with personalized content relevant to you (on the basis of our legitimate interest to ensure our website is presented in an effective and optimal manner).\nTo register and maintain your website account (on the basis of our terms of service).\nTo store your personal settings.\nTo process and fulfill your orders for products and services (on the basis of performing our contract with you).\nTo process and facilitate transactions and payments, and recover money owed to us (on the basis of performing our contract with you, and on the basis of our legitimate interest to recover debts due).\nTo monitor your account and use of services to ensure compliance with our end-user agreements and prevent and identify unlawful content use and violations (on the basis of our legitimate interests to operate a safe and lawful business, or where we have a legal obligation to do so).\nTo enable you to communicate with other website users and clients (on the basis of your consent where we have requested it, or on the basis of performing our contract with you).\nTo manage our relationship with you, which will include notifying you about changes to our terms of service or privacy policy, and asking you to leave a review or take a survey (on the basis of performing our contract with you, to comply with our legal obligations, and our legitimate interest in keeping our records updated and study how our website and services are used).\nTo conduct business with you or your employer, including to contact you and manage and facilitate our business relationship with you and your employer (on the basis of performing our contract with you, and our legitimate interest in running our business).\nTo provide customer service and support, like dealing with inquiries or complaints about the website, which may include sharing your information with our website developer, IT support provider, and payment services provider as necessary (on the basis of performing our contract with you, our legitimate interest in providing the correct products and services to our website users, and to comply with our legal obligations).\nTo enable you to take part in prize drawings, competitions, and surveys (on the basis of performing our contract with you, and our legitimate interest in studying how our website and services are used, to develop them, and to grow our business).\nTo work with you and undertake projects with you, including to process any proposals that you submit to us (on the basis of our contract with you, and our legitimate interest in running our business).\nFor recruitment, including to process any job applications you submit to us, whether directly or via an agent or recruiter including sharing your information with our third party recruitment agencies (on the basis of our legitimate interest to recruit new employees or contractors).\nTo carry out marketing and let you know about our news, events, new website features products or services that we believe may interest you, including sharing your information with our marketing services providers (either on the basis of your consent where we have requested it, or our legitimate interests to provide you with marketing communications where we may lawfully do so).\nTo deliver relevant website content and advertisements to you and measure or understand the effectiveness of the advertising we serve to you (on the basis of our legitimate interests in studying how our website/services are used, to develop them, to grow our business and to inform our marketing strategy).\nTo interact with users on social media platforms (on the basis of our legitimate interest in promoting our brand and communicating with interested individuals).\nTo conduct data analytics to improve our website, products/services, marketing, customer relationships and experiences (on the basis of our legitimate interests in defining types of customers for our website and services, to keep our website updated and relevant, to develop our business, to provide the right kinds of products and services to our customers, and to inform our business and marketing strategy).\nTo make suggestions and recommendations by sharing your information with selected third parties such as sponsors and partners, so they can contact you about things that may interest you (either on the basis of your consent where we have requested it, or on the basis of our legitimate interest to share details of conference attendees with our co-presenters and sponsors).\nTo carry out marketing research and user testing to assess the levels of satisfaction of existing and proposed products and services (on the basis of our legitimate interest in carrying out research, providing the right kinds of products and services to our customers).\nTo protect, investigate, and deter against fraudulent, unauthorized, or illegal activity (on the basis of our legitimate interests to operate a safe and lawful business, or where we have a legal obligation to do so).\nTo enable us to comply with our policies and procedures and enforce our legal rights, and to protect the rights, property or safety of our employees and share your information with our technical and legal advisors (on the basis of our legitimate interests to operate a safe and lawful business, or where we have a legal obligation to do so).\n\nWe will use your information for the purposes listed above either on the basis of:\n\nyour consent (where we request it)\nperformance of your contract with us and the provision of our services to you\nwhere we need to comply with a legal or regulatory obligation\nour legitimate interests or those of a third party (see section below for more information).\nLEGITIMATE INTERESTS\n\nAs outlined above, in certain circumstances we may use your personal information to pursue legitimate interests of our own or those of third parties.\n\nWhere we refer to our “legitimate interests”, we mean our legitimate business interests in conducting and managing our business and our relationship with you, including the legitimate interests we have specified in section above.\n\nWhere we use your information for our legitimate interests, we make sure that we take into account any potential impact that such use may have on you.\n\nOur legitimate interests don’t automatically override yours and we won’t use your information if we believe your interests should override ours unless we have other grounds to do so (such as your consent or a legal obligation).\n\nIf you have any concerns about our processing please refer to details of “Your Rights” section below.\n\nHOW WE SHARE AND DISCLOSE PERSONAL INFORMATION\n\nWe consider your personal information to be a vital part of our relationship with you and do not sell your personal information to third parties. There are, however, certain circumstances in which we may share your personal information with certain third parties, as follows:\n\nOur service providers who are acting as processors and who assist us with our administrative or business functions, or in the provision of any of our products/services to you, for instance Paymentwall that accepts credit card payments, or Amazon services that processes email sending. These providers’ privacy policy is described in respective agreements.\nOther website users and clients who use our websites and/or applications to communicate or otherwise interact with you.\nOur partners who are involved in providing services to you.\nRegulators and governmental bodies, authorities and regulators acting as processors or joint controllers who require reporting of processing activities in certain circumstances.\nMarketing parties which are any selected third party that you consent to our sharing your information with for marketing purposes.\nAny prospective buyer of our business or assets, only in the event that we wish to sell any part of our business or assets.\nOther third parties including legal, professional or other advisors, regulatory authorities, courts, law enforcement agencies and government agencies) where necessary to enable us to enforce our legal rights, or to protect the rights, property or safety of our employees or where such disclosure may be permitted or required by law.\nHOW WE LOOK AFTER YOUR PERSONAL INFORMATION AND HOW LONG WE KEEP IT\nSECURITY\n\nWe use administrative, technical, and physical safeguards to protect the security, confidentiality, and integrity of personal data against loss, misuse and unauthorized access, disclosure, alteration, and destruction.\n\nWe also operate a policy of “privacy by design” by looking for opportunities to minimize the amount of personal information we hold about you.\n\nThe safeguards we use include:\n\nensuring the physical security of our offices, warehouses, or other sites\nensuring the physical and digital security of our equipment and devices by using appropriate password protection and encryption\nusing standard security protocols and mechanisms (such as secure socket layer (SSL) encryption) to transmit sensitive data such as credit card details\nlimiting access to your personal information to those who need to use it in the course of their work\n\nIf you have any questions about the security of your personal information, please contact us using the methods outlined in the “Contact Us” section below.\n\nRETENTION\n\nWe will keep your information for as long as is necessary to provide you with the services that you have requested from us or for as long as we reasonably require to retain the information for our lawful business purposes, such as for the purposes of exercising our legal rights or where we are permitted to do.\n\nHELP KEEP YOUR INFORMATION SAFE\n\nYou can also play a part in keeping your information safe by:\n\nchoosing a strong account password, changing it regularly, and using different passwords for different online accounts\nkeeping your login and password details confidential\nlogging out of the website and closing the browser each time you have finished using it, especially when using a shared computer\ninforming us if know or suspect that your account has been compromised, or if someone has accessed your account without your permission\nkeeping your devices protected by using the latest version of your operating system and maintaining any necessary anti-virus software\nbeing vigilant to any fraudulent emails that may appear to be from us\nINTERNATIONAL TRANSFERS OF YOUR INFORMATION\n\nOur servers are located in Germany, also we use Amazon services located in the United States of America.\n\nOur partners and contractors involved in servicing you (e.g. support agents, course teachers) may be located in other European and Asian countries.\n\nIf you reside in the European Union, please be advised that your personal data will be processed outside of the European Economic Area (EEA).\n\nWe will take all steps necessary to ensure that your information is adequately protected and processed in accordance with this Privacy Policy.\n\nYOUR RIGHTS: ACCESS AND ACCURACY, UPDATING, CORRECTING, OR DELETING INFORMATION\n\nYou have certain rights in respect of the information that we hold about you, including:\n\nthe right to be informed of the ways in which we use your information, as we seek to do in this Privacy Policy\nthe right to ask us not to process your personal data for marketing purposes\nthe right to request access to the information that we hold about you\nthe right to request that we correct or rectify any information that we hold about you which is out of date or incorrect\nthe right to withdraw your consent for our use of your information in reliance of your consent (refer to sections above to see when we are relying on your consent), which you can do by contacting us using any of the details at the top of this Privacy Policy\nthe right to object to our using your information on the basis of our legitimate interests (refer to sections above to see when we are relying on our legitimate interests) (or those of a third party)) and there is something about your particular situation which makes you want to object to processing on this ground\nthe right to receive a copy of any information we hold about you (or request that we transfer this to another service provider) in a structured, commonly-used, machine readable format, in certain circumstances\nin certain circumstances, the right to ask us to limit or cease processing or erase information we hold about you\nHOW TO EXERCISE YOUR RIGHTS\n\nYou may exercise your rights above by contacting us using the methods outlined in the “Contact Us” section below and we will comply with your requests unless we have a lawful reason not to do so.\n\nYou can opt-out of receiving newsletters or other communications that you previously subscribed by following the opt-out instructions included in each newsletter or communication or by contacting us using the methods outlined in the “Contact Us” section below.\n\nPlease note that your objection to processing (or withdrawal of any previously given consent) could mean that we are unable to provide you with our services. Even after you have chosen to withdraw your consent we may continue to process your personal information when required or permitted by law, in particular in connection with exercising and defending our legal rights, or meeting our legal and regulatory obligations.\n\nWHAT WE NEED FROM YOU TO PROCESS YOUR REQUESTS\n\nWe may need to request specific information from you to help us confirm your identity and to enable you to exercise the rights set out above. This is a security measure to ensure that personal data is not disclosed to any person who has no right to receive it. We may also contact you to ask you for further information in relation to your request to speed up our response.\n\nYou will not have to pay a fee to exercise the rights set out above.\nHowever, we may charge a reasonable fee if your request is clearly unfounded, repetitive or excessive.\nAlternatively, we may refuse to comply with your request in these circumstances.\nWe will try to respond to all legitimate requests within one month.\nOccasionally it may take us longer than a month if your request is particularly complex or you have made a number of requests. In this case, we will notify you and keep you updated.\nCHILDREN’S PRIVACY\n\nOur website is not intended for children. We do not knowingly collect or maintain the personal information of children under the age of 13, and in some jurisdictions under the age of 16. If you are under the age of 13, please do not access our website at any time or in any manner. If we learn that we have collected personal information of children under the age of 13 or 16 (as applicable), we will take appropriate steps to delete that data.\n\nSHARING DATA WITH THIRD PARTIES\n\nYou might provide personal information directly to third parties as a consequence of your interactions with our website and other services offered by us.\n\nFor example, our website may contain content and links to other third-party websites, plug-ins, and applications that are operated by third parties that may also operate cookies.\n\nClicking on those links or enabling those connections may allow third parties to collect or share data about you. We don’t control these third party websites or cookies, we are not responsible for their privacy statements, and this Privacy Policy does not apply to them.\n\nPlease check the terms and conditions and privacy policy of the relevant third party website to find out how they collect and use your information.\n\nPlease be responsible with personal information of others when using our website and the services available on it. We are not responsible for your misuse of personal information, or for the direct relationship between you and others that takes place outside of the website or our services.\n\nFOR CALIFORNIA RESIDENTS: YOUR PRIVACY RIGHTS AND DO NOT TRACK DISCLOSURE\n\nThe Policy is to share your personal information only if you have given us your consent, for instance, by your agreeing to this Privacy Policy through your use of our sites. After obtaining such consent, Safari may in accordance with this Privacy Policy from time to time provide its business partners with contact details for direct marketing purposes of relevant services, products, and programs. If you no longer wish your information to be shared, please let us know, and we will prevent disclosure of your information to such business partners free of charge, or if you have further inquiries regarding our information sharing practices, please let us know using the methods outlined in the “Contact Us” section below.\n\nCalifornia law requires us to let you know how we respond to web browser Do Not Track (DNT) signals. DNT is a way for users to inform websites and services that they do not want certain information about their webpage visits collected over time and across websites or online services. We do not respond to or honor DNT signals or similar mechanisms transmitted by web browsers at this time.\n\nCHANGES TO THIS PRIVACY POLICY\n\nPlease note that this Policy may change from time to time. We will not reduce your rights under this Policy without your consent.\n\nIf we make any material changes we will notify you by email or by means of a notice on this website prior to the change becoming effective.\n\nCONTACT US\n\nThe legal entity behind the site is Techlead LLC.\n\nAddress: Armenia, Yerevan, 0051 Nairi Zaryan 22a.\nReg. number: 264.110.1232255.\nTax id: 08220384.\n\nEmail: help@javascript.info."
  },
  {
    "title": "Terms of Usage",
    "url": "https://javascript.info/terms",
    "html": "Welcome to JavaScript.info!\n\nBy accessing this website we assume you accept these terms and conditions in full. Do not continue to use javascript.info if you do not accept all of the terms and conditions stated on this page.\n\nIn short, we do not require anything unusual. Respect yourself and others, respect the license when you republish something. That’s what we do as well.\n\nThe following terminology applies to these Terms and Conditions, Privacy Statement and Disclaimer Notice and any or all Agreements: “Client”, “You” and “Your” refers to you, the person accessing this website and accepting the Company’s terms and conditions. “The Company”, “Ourselves”, “We”, “Our” and “Us”, refers to Techlead LLC, the legal entity behind the site. “Party”, “Parties”, or “Us”, refers to both the Client and ourselves, or either the Client or ourselves. Any use of the above terminology or other words in the singular, plural, capitalisation and/or he/she or they, are taken as interchangeable and therefore as referring to same.\n\nUnless otherwise stated, we and/or and/or our licensors own the intellectual property rights for all material on javascript.info. All intellectual property rights are reserved. You may view and/or print pages from https://javascript.info for your own personal use subject to restrictions set in these terms and conditions.\n\nUnless otherwise stated, you must not:\n\nRepublish material from https://javascript.info,\nSell, rent or sub-license material from https://javascript.info,\nReproduce, duplicate or copy material from https://javascript.info,\nRedistribute content from javascript.info (unless content is specifically made for redistribution).\n\nThe Modern JavaScript Tutorial text is a notable exception. It is licensed as CC-BY-NC-SA (see https://github.com/javascript-tutorial/en. javascript.info/blob/master/LICENSE.md) for details, So it is possible to republish it while obeying the terms of the license. Note that if you republish it on your site, you need to put a link to the original version and don’t put ads (non-commercially).\n\nCertain parts of this website offer the opportunity for users to post and exchange opinions, information, material and data (‘Comments’) in areas of the website, and also publish the information about themselves (‘Profile’). Together we refer to them as User Content. We do not screen, edit, publish or review User Content prior to their appearance on the website and User Content do not reflect Our views or opinions. User Content reflect the view and opinion of the person who posts such view or opinion. To the extent permitted by applicable laws We shall not be responsible or liable for the User Content or for any loss cost, liability, damages or expenses caused and or suffered as a result of any use of and/or posting of and/or appearance of the User Content on this website. We reserve the right to monitor all User Content and to remove any User Content which it considers in its absolute discretion to be inappropriate, offensive or otherwise in breach of these Terms and Conditions.\n\nYou warrant and represent that:\n\nYou are entitled to post User Content on our website and have all necessary licenses and consents to do so;\nThe User Content do not infringe any intellectual property right, including without limitation copyright, patent or trademark, or other proprietary right of any third party;\nThe User Content do not contain any defamatory, libelous, offensive, indecent or otherwise unlawful material or material which is an invasion of privacy\nThe User Content will not be used to solicit or promote business or custom or present commercial activities or unlawful activity.\n\nYou hereby grant Us a non-exclusive royalty-free license to use, reproduce, edit and authorize others to use, reproduce and edit any of your Comments in any and all forms, formats or media.\n\nTo the maximum extent permitted by applicable law, we exclude all representations, warranties and conditions relating to our website and the use of this website (including, without limitation, any warranties implied by law in respect of satisfactory quality, fitness for purpose and/or the use of reasonable care and skill).\n\nNothing in this disclaimer will:\n\nlimit or exclude our or your liability for death or personal injury resulting from negligence;\nlimit or exclude our or your liability for fraud or fraudulent misrepresentation;\nlimit any of our or your liabilities in any way that is not permitted under applicable law; or\nexclude any of our or your liabilities that may not be excluded under applicable law.\n\nThe limitations and exclusions of liability set out in this Section and elsewhere in this disclaimer: (a) are subject to the preceding paragraph; and (b) govern all liabilities arising under the disclaimer or in relation to the subject matter of this disclaimer, including liabilities arising in contract, in tort (including negligence) and for breach of statutory duty. To the extent that the website and the information and services on the website are provided free of charge, we will not be liable for any loss or damage of any nature.\n\nThis sites makes use of Disqus for comments. It has a separate user authentication system, independent from ours. Occasionally we may include or offer other third-party products or services with clear indication that they belong to a third-party. Third-party sites have separate and independent privacy policies, therefore we have no responsibility or liability for the content and activities of these linked sites. Nonetheless, we seek to protect the integrity of our site and welcome any feedback about these sites.\n\nEbook Terms and Conditions\neBook titles purchased cannot be returned, printed, refunded, or exchanged.\nIf you experience technical difficulty in downloading or accessing a title, please contact us at help@javascript.info for assistance.\nYou are permitted to download the eBook but this licence is personal to you, non-exclusive and non-transferrable.\nYou may reproduce and store portions of the eBook content for your personal use.\nFull-scale reproduction of the contents of the eBook is expressly prohibited.\nYou may not use the eBook on more than one computer system concurrently, make or distribute unauthorised copies of the eBook, or use, copy, modify, or transfer the eBook, in whole or in part, unless you receive our express permission.\nIf you transfer possession of the eBook to a third party, the licence is automatically terminated.\nYou are granted the right to download the eBook\nyou may print pages of the eBook for your personal use and reference in connection with your work.\nYou may create and save bookmarks, highlights and notes as provided by the functionality of the program.\nYou agree to protect the eBook from unauthorised use, reproduction, or distribution.\nYou further agree not to translate, decompile, or disassemble the eBook except to the extent permitted under applicable law.\nMulti-use configurations or network distribution of the eBook is expressly prohibited.\n\nAdditionally, the contents of the eBook is published under CC-BY-NC-SA license, see https://creativecommons.org/licenses/by-nc-sa/3.0/legalcode.\n\nIn short, you may distribute, adapt and reuse it under following conditions:\n\nAttribution: write about the source (this site), add a link to our website.\nNoncommercial use only.\nYour works based on this code must use the same license.\nDisclaimer\n\nThe ebook is provided “as is”, without warranty of any kind, expressed or implied including without limitations, accuracy, omissions, completeness or implied warranties or suitability or fitness for a particular purpose or other incidental damages arising out of the use or the inability to use the ebook. You acknowledge that the use of this service is entirely at your own risk. You acknowledge that you have read these Terms of Usage, and agree to be bound by these terms and conditions.\n\nThe legal entity behind the site is Techlead LLC.\n\nAddress: Armenia, Yerevan, 0051 Nairi Zaryan 22a.\nReg. number: 264.110.1232255.\nTax id: 08220384.\n\nTo contact, please mail to help@javascript.info."
  },
  {
    "title": "Fetch: Cross-Origin Requests",
    "url": "https://javascript.info/fetch-crossorigin",
    "html": "If we send a fetch request to another web-site, it will probably fail.\n\nFor instance, let’s try fetching http://example.com:\n\n\t\ntry {\n  await fetch('http://example.com');\n} catch(err) {\n  alert(err); // Failed to fetch\n}\n\nFetch fails, as expected.\n\nThe core concept here is origin – a domain/port/protocol triplet.\n\nCross-origin requests – those sent to another domain (even a subdomain) or protocol or port – require special headers from the remote side.\n\nThat policy is called “CORS”: Cross-Origin Resource Sharing.\n\nWhy is CORS needed? A brief history\n\nCORS exists to protect the internet from evil hackers.\n\nSeriously. Let’s make a very brief historical digression.\n\nFor many years a script from one site could not access the content of another site.\n\nThat simple, yet powerful rule was a foundation of the internet security. E.g. an evil script from website hacker.com could not access the user’s mailbox at website gmail.com. People felt safe.\n\nJavaScript also did not have any special methods to perform network requests at that time. It was a toy language to decorate a web page.\n\nBut web developers demanded more power. A variety of tricks were invented to work around the limitation and make requests to other websites.\n\nUsing forms\n\nOne way to communicate with another server was to submit a <form> there. People submitted it into <iframe>, just to stay on the current page, like this:\n\n<!-- form target -->\n<iframe name=\"iframe\"></iframe>\n\n<!-- a form could be dynamically generated and submitted by JavaScript -->\n<form target=\"iframe\" method=\"POST\" action=\"http://another.com/…\">\n  ...\n</form>\n\nSo, it was possible to make a GET/POST request to another site, even without networking methods, as forms can send data anywhere. But as it’s forbidden to access the content of an <iframe> from another site, it wasn’t possible to read the response.\n\nTo be precise, there were actually tricks for that, they required special scripts at both the iframe and the page. So the communication with the iframe was technically possible. Right now there’s no point to go into details, let these dinosaurs rest in peace.\n\nUsing scripts\n\nAnother trick was to use a script tag. A script could have any src, with any domain, like <script src=\"http://another.com/…\">. It’s possible to execute a script from any website.\n\nIf a website, e.g. another.com intended to expose data for this kind of access, then a so-called “JSONP (JSON with padding)” protocol was used.\n\nHere’s how it worked.\n\nLet’s say we, at our site, need to get the data from http://another.com, such as the weather:\n\nFirst, in advance, we declare a global function to accept the data, e.g. gotWeather.\n\n// 1. Declare the function to process the weather data\nfunction gotWeather({ temperature, humidity }) {\n  alert(`temperature: ${temperature}, humidity: ${humidity}`);\n}\n\nThen we make a <script> tag with src=\"http://another.com/weather.json?callback=gotWeather\", using the name of our function as the callback URL-parameter.\n\nlet script = document.createElement('script');\nscript.src = `http://another.com/weather.json?callback=gotWeather`;\ndocument.body.append(script);\n\nThe remote server another.com dynamically generates a script that calls gotWeather(...) with the data it wants us to receive.\n\n// The expected answer from the server looks like this:\ngotWeather({\n  temperature: 25,\n  humidity: 78\n});\n\nWhen the remote script loads and executes, gotWeather runs, and, as it’s our function, we have the data.\n\nThat works, and doesn’t violate security, because both sides agreed to pass the data this way. And, when both sides agree, it’s definitely not a hack. There are still services that provide such access, as it works even for very old browsers.\n\nAfter a while, networking methods appeared in browser JavaScript.\n\nAt first, cross-origin requests were forbidden. But as a result of long discussions, cross-origin requests were allowed, but with any new capabilities requiring an explicit allowance by the server, expressed in special headers.\n\nSafe requests\n\nThere are two types of cross-origin requests:\n\nSafe requests.\nAll the others.\n\nSafe Requests are simpler to make, so let’s start with them.\n\nA request is safe if it satisfies two conditions:\n\nSafe method: GET, POST or HEAD\nSafe headers – the only allowed custom headers are:\nAccept,\nAccept-Language,\nContent-Language,\nContent-Type with the value application/x-www-form-urlencoded, multipart/form-data or text/plain.\n\nAny other request is considered “unsafe”. For instance, a request with PUT method or with an API-Key HTTP-header does not fit the limitations.\n\nThe essential difference is that a safe request can be made with a <form> or a <script>, without any special methods.\n\nSo, even a very old server should be ready to accept a safe request.\n\nContrary to that, requests with non-standard headers or e.g. method DELETE can’t be created this way. For a long time JavaScript was unable to do such requests. So an old server may assume that such requests come from a privileged source, “because a webpage is unable to send them”.\n\nWhen we try to make a unsafe request, the browser sends a special “preflight” request that asks the server – does it agree to accept such cross-origin requests, or not?\n\nAnd, unless the server explicitly confirms that with headers, an unsafe request is not sent.\n\nNow we’ll go into details.\n\nCORS for safe requests\n\nIf a request is cross-origin, the browser always adds the Origin header to it.\n\nFor instance, if we request https://anywhere.com/request from https://javascript.info/page, the headers will look like:\n\nGET /request\nHost: anywhere.com\nOrigin: https://javascript.info\n...\n\nAs you can see, the Origin header contains exactly the origin (domain/protocol/port), without a path.\n\nThe server can inspect the Origin and, if it agrees to accept such a request, add a special header Access-Control-Allow-Origin to the response. That header should contain the allowed origin (in our case https://javascript.info), or a star *. Then the response is successful, otherwise it’s an error.\n\nThe browser plays the role of a trusted mediator here:\n\nIt ensures that the correct Origin is sent with a cross-origin request.\nIt checks for permitting Access-Control-Allow-Origin in the response, if it exists, then JavaScript is allowed to access the response, otherwise it fails with an error.\n\nHere’s an example of a permissive server response:\n\n200 OK\nContent-Type:text/html; charset=UTF-8\nAccess-Control-Allow-Origin: https://javascript.info\nResponse headers\n\nFor cross-origin request, by default JavaScript may only access so-called “safe” response headers:\n\nCache-Control\nContent-Language\nContent-Length\nContent-Type\nExpires\nLast-Modified\nPragma\n\nAccessing any other response header causes an error.\n\nTo grant JavaScript access to any other response header, the server must send the Access-Control-Expose-Headers header. It contains a comma-separated list of unsafe header names that should be made accessible.\n\nFor example:\n\n200 OK\nContent-Type:text/html; charset=UTF-8\nContent-Length: 12345\nContent-Encoding: gzip\nAPI-Key: 2c9de507f2c54aa1\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Expose-Headers: Content-Encoding,API-Key\n\nWith such an Access-Control-Expose-Headers header, the script is allowed to read the Content-Encoding and API-Key headers of the response.\n\n“Unsafe” requests\n\nWe can use any HTTP-method: not just GET/POST, but also PATCH, DELETE and others.\n\nSome time ago no one could even imagine that a webpage could make such requests. So there may still exist webservices that treat a non-standard method as a signal: “That’s not a browser”. They can take it into account when checking access rights.\n\nSo, to avoid misunderstandings, any “unsafe” request – that couldn’t be done in the old times, the browser does not make such requests right away. First, it sends a preliminary, so-called “preflight” request, to ask for permission.\n\nA preflight request uses the method OPTIONS, no body and three headers:\n\nAccess-Control-Request-Method header has the method of the unsafe request.\nAccess-Control-Request-Headers header provides a comma-separated list of its unsafe HTTP-headers.\nOrigin header tells from where the request came. (such as https://javascript.info)\n\nIf the server agrees to serve the requests, then it should respond with empty body, status 200 and headers:\n\nAccess-Control-Allow-Origin must be either * or the requesting origin, such as https://javascript.info, to allow it.\nAccess-Control-Allow-Methods must have the allowed method.\nAccess-Control-Allow-Headers must have a list of allowed headers.\nAdditionally, the header Access-Control-Max-Age may specify a number of seconds to cache the permissions. So the browser won’t have to send a preflight for subsequent requests that satisfy given permissions.\n\nLet’s see how it works step-by-step on the example of a cross-origin PATCH request (this method is often used to update data):\n\nlet response = await fetch('https://site.com/service.json', {\n  method: 'PATCH',\n  headers: {\n    'Content-Type': 'application/json',\n    'API-Key': 'secret'\n  }\n});\n\nThere are three reasons why the request is unsafe (one is enough):\n\nMethod PATCH\nContent-Type is not one of: application/x-www-form-urlencoded, multipart/form-data, text/plain.\n“Unsafe” API-Key header.\nStep 1 (preflight request)\n\nPrior to sending such a request, the browser, on its own, sends a preflight request that looks like this:\n\nOPTIONS /service.json\nHost: site.com\nOrigin: https://javascript.info\nAccess-Control-Request-Method: PATCH\nAccess-Control-Request-Headers: Content-Type,API-Key\nMethod: OPTIONS.\nThe path – exactly the same as the main request: /service.json.\nCross-origin special headers:\nOrigin – the source origin.\nAccess-Control-Request-Method – requested method.\nAccess-Control-Request-Headers – a comma-separated list of “unsafe” headers.\nStep 2 (preflight response)\n\nThe server should respond with status 200 and the headers:\n\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Allow-Methods: PATCH\nAccess-Control-Allow-Headers: Content-Type,API-Key.\n\nThat allows future communication, otherwise an error is triggered.\n\nIf the server expects other methods and headers in the future, it makes sense to allow them in advance by adding them to the list.\n\nFor example, this response also allows PUT, DELETE and additional headers:\n\n200 OK\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Allow-Methods: PUT,PATCH,DELETE\nAccess-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control\nAccess-Control-Max-Age: 86400\n\nNow the browser can see that PATCH is in Access-Control-Allow-Methods and Content-Type,API-Key are in the list Access-Control-Allow-Headers, so it sends out the main request.\n\nIf there’s the header Access-Control-Max-Age with a number of seconds, then the preflight permissions are cached for the given time. The response above will be cached for 86400 seconds (one day). Within this timeframe, subsequent requests will not cause a preflight. Assuming that they fit the cached allowances, they will be sent directly.\n\nStep 3 (actual request)\n\nWhen the preflight is successful, the browser now makes the main request. The process here is the same as for safe requests.\n\nThe main request has the Origin header (because it’s cross-origin):\n\nPATCH /service.json\nHost: site.com\nContent-Type: application/json\nAPI-Key: secret\nOrigin: https://javascript.info\nStep 4 (actual response)\n\nThe server should not forget to add Access-Control-Allow-Origin to the main response. A successful preflight does not relieve from that:\n\nAccess-Control-Allow-Origin: https://javascript.info\n\nThen JavaScript is able to read the main server response.\n\nPlease note:\n\nPreflight request occurs “behind the scenes”, it’s invisible to JavaScript.\n\nJavaScript only gets the response to the main request or an error if there’s no server permission.\n\nCredentials\n\nA cross-origin request initiated by JavaScript code by default does not bring any credentials (cookies or HTTP authentication).\n\nThat’s uncommon for HTTP-requests. Usually, a request to http://site.com is accompanied by all cookies from that domain. Cross-origin requests made by JavaScript methods on the other hand are an exception.\n\nFor example, fetch('http://another.com') does not send any cookies, even those (!) that belong to another.com domain.\n\nWhy?\n\nThat’s because a request with credentials is much more powerful than without them. If allowed, it grants JavaScript the full power to act on behalf of the user and access sensitive information using their credentials.\n\nDoes the server really trust the script that much? Then it must explicitly allow requests with credentials with an additional header.\n\nTo send credentials in fetch, we need to add the option credentials: \"include\", like this:\n\nfetch('http://another.com', {\n  credentials: \"include\"\n});\n\nNow fetch sends cookies originating from another.com with request to that site.\n\nIf the server agrees to accept the request with credentials, it should add a header Access-Control-Allow-Credentials: true to the response, in addition to Access-Control-Allow-Origin.\n\nFor example:\n\n200 OK\nAccess-Control-Allow-Origin: https://javascript.info\nAccess-Control-Allow-Credentials: true\n\nPlease note: Access-Control-Allow-Origin is prohibited from using a star * for requests with credentials. Like shown above, it must provide the exact origin there. That’s an additional safety measure, to ensure that the server really knows who it trusts to make such requests.\n\nSummary\n\nFrom the browser point of view, there are two kinds of cross-origin requests: “safe” and all the others.\n\n“Safe” requests must satisfy the following conditions:\n\nMethod: GET, POST or HEAD.\nHeaders – we can set only:\nAccept\nAccept-Language\nContent-Language\nContent-Type to the value application/x-www-form-urlencoded, multipart/form-data or text/plain.\n\nThe essential difference is that safe requests were doable since ancient times using <form> or <script> tags, while unsafe were impossible for browsers for a long time.\n\nSo, the practical difference is that safe requests are sent right away, with the Origin header, while for the other ones the browser makes a preliminary “preflight” request, asking for permission.\n\nFor safe requests:\n\n→ The browser sends the Origin header with the origin.\n← For requests without credentials (not sent by default), the server should set:\nAccess-Control-Allow-Origin to * or same value as Origin\n← For requests with credentials, the server should set:\nAccess-Control-Allow-Origin to same value as Origin\nAccess-Control-Allow-Credentials to true\n\nAdditionally, to grant JavaScript access to any response headers except Cache-Control, Content-Language, Content-Type, Expires, Last-Modified or Pragma, the server should list the allowed ones in Access-Control-Expose-Headers header.\n\nFor unsafe requests, a preliminary “preflight” request is issued before the requested one:\n\n→ The browser sends an OPTIONS request to the same URL, with the headers:\nAccess-Control-Request-Method has requested method.\nAccess-Control-Request-Headers lists unsafe requested headers.\n← The server should respond with status 200 and the headers:\nAccess-Control-Allow-Methods with a list of allowed methods,\nAccess-Control-Allow-Headers with a list of allowed headers,\nAccess-Control-Max-Age with a number of seconds to cache the permissions.\nThen the actual request is sent, and the previous “safe” scheme is applied.\nTasks\nWhy do we need Origin?\nimportance: 5\n\nAs you probably know, there’s HTTP-header Referer, that usually contains an url of the page which initiated a network request.\n\nFor instance, when fetching http://google.com from http://javascript.info/some/url, the headers look like this:\n\nAccept: */*\nAccept-Charset: utf-8\nAccept-Encoding: gzip,deflate,sdch\nConnection: keep-alive\nHost: google.com\nOrigin: http://javascript.info\nReferer: http://javascript.info/some/url\n\nAs you can see, both Referer and Origin are present.\n\nThe questions:\n\nWhy Origin is needed, if Referer has even more information?\nIs it possible that there’s no Referer or Origin, or is it incorrect?\nsolution"
  },
  {
    "title": "Export and Import",
    "url": "https://javascript.info/import-export",
    "html": "Export and import directives have several syntax variants.\n\nIn the previous article we saw a simple use, now let’s explore more examples.\n\nExport before declarations\n\nWe can label any declaration as exported by placing export before it, be it a variable, function or a class.\n\nFor instance, here all exports are valid:\n\n// export an array\nexport let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\n// export a constant\nexport const MODULES_BECAME_STANDARD_YEAR = 2015;\n\n// export a class\nexport class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\nNo semicolons after export class/function\n\nPlease note that export before a class or a function does not make it a function expression. It’s still a function declaration, albeit exported.\n\nMost JavaScript style guides don’t recommend semicolons after function and class declarations.\n\nThat’s why there’s no need for a semicolon at the end of export class and export function:\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}  // no ; at the end\nExport apart from declarations\n\nAlso, we can put export separately.\n\nHere we first declare, and then export:\n\n// 📁 say.js\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nfunction sayBye(user) {\n  alert(`Bye, ${user}!`);\n}\n\nexport {sayHi, sayBye}; // a list of exported variables\n\n…Or, technically we could put export above functions as well.\n\nImport *\n\nUsually, we put a list of what to import in curly braces import {...}, like this:\n\n// 📁 main.js\nimport {sayHi, sayBye} from './say.js';\n\nsayHi('John'); // Hello, John!\nsayBye('John'); // Bye, John!\n\nBut if there’s a lot to import, we can import everything as an object using import * as <obj>, for instance:\n\n// 📁 main.js\nimport * as say from './say.js';\n\nsay.sayHi('John');\nsay.sayBye('John');\n\nAt first sight, “import everything” seems such a cool thing, short to write, why should we ever explicitly list what we need to import?\n\nWell, there are few reasons.\n\nExplicitly listing what to import gives shorter names: sayHi() instead of say.sayHi().\nExplicit list of imports gives better overview of the code structure: what is used and where. It makes code support and refactoring easier.\nDon’t be afraid to import too much\n\nModern build tools, such as webpack and others, bundle modules together and optimize them to speedup loading. They also removed unused imports.\n\nFor instance, if you import * as library from a huge code library, and then use only few methods, then unused ones will not be included into the optimzed bundle.\n\nImport “as”\n\nWe can also use as to import under different names.\n\nFor instance, let’s import sayHi into the local variable hi for brevity, and import sayBye as bye:\n\n// 📁 main.js\nimport {sayHi as hi, sayBye as bye} from './say.js';\n\nhi('John'); // Hello, John!\nbye('John'); // Bye, John!\nExport “as”\n\nThe similar syntax exists for export.\n\nLet’s export functions as hi and bye:\n\n// 📁 say.js\n...\nexport {sayHi as hi, sayBye as bye};\n\nNow hi and bye are official names for outsiders, to be used in imports:\n\n// 📁 main.js\nimport * as say from './say.js';\n\nsay.hi('John'); // Hello, John!\nsay.bye('John'); // Bye, John!\nExport default\n\nIn practice, there are mainly two kinds of modules.\n\nModules that contain a library, pack of functions, like say.js above.\nModules that declare a single entity, e.g. a module user.js exports only class User.\n\nMostly, the second approach is preferred, so that every “thing” resides in its own module.\n\nNaturally, that requires a lot of files, as everything wants its own module, but that’s not a problem at all. Actually, code navigation becomes easier if files are well-named and structured into folders.\n\nModules provide a special export default (“the default export”) syntax to make the “one thing per module” way look better.\n\nPut export default before the entity to export:\n\n// 📁 user.js\nexport default class User { // just add \"default\"\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nThere may be only one export default per file.\n\n…And then import it without curly braces:\n\n// 📁 main.js\nimport User from './user.js'; // not {User}, just User\n\nnew User('John');\n\nImports without curly braces look nicer. A common mistake when starting to use modules is to forget curly braces at all. So, remember, import needs curly braces for named exports and doesn’t need them for the default one.\n\nNamed export\tDefault export\nexport class User {...}\texport default class User {...}\nimport {User} from ...\timport User from ...\n\nTechnically, we may have both default and named exports in a single module, but in practice people usually don’t mix them. A module has either named exports or the default one.\n\nAs there may be at most one default export per file, the exported entity may have no name.\n\nFor instance, these are all perfectly valid default exports:\n\nexport default class { // no class name\n  constructor() { ... }\n}\nexport default function(user) { // no function name\n  alert(`Hello, ${user}!`);\n}\n// export a single value, without making a variable\nexport default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n\nNot giving a name is fine, because there is only one export default per file, so import without curly braces knows what to import.\n\nWithout default, such an export would give an error:\n\nexport class { // Error! (non-default export needs a name)\n  constructor() {}\n}\nThe “default” name\n\nIn some situations the default keyword is used to reference the default export.\n\nFor example, to export a function separately from its definition:\n\nfunction sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n// same as if we added \"export default\" before the function\nexport {sayHi as default};\n\nOr, another situation, let’s say a module user.js exports one main “default” thing, and a few named ones (rarely the case, but it happens):\n\n// 📁 user.js\nexport default class User {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\nHere’s how to import the default export along with a named one:\n\n// 📁 main.js\nimport {default as User, sayHi} from './user.js';\n\nnew User('John');\n\nAnd, finally, if importing everything * as an object, then the default property is exactly the default export:\n\n// 📁 main.js\nimport * as user from './user.js';\n\nlet User = user.default; // the default export\nnew User('John');\nA word against default exports\n\nNamed exports are explicit. They exactly name what they import, so we have that information from them; that’s a good thing.\n\nNamed exports force us to use exactly the right name to import:\n\nimport {User} from './user.js';\n// import {MyUser} won't work, the name must be {User}\n\n…While for a default export, we always choose the name when importing:\n\nimport User from './user.js'; // works\nimport MyUser from './user.js'; // works too\n// could be import Anything... and it'll still work\n\nSo team members may use different names to import the same thing, and that’s not good.\n\nUsually, to avoid that and keep the code consistent, there’s a rule that imported variables should correspond to file names, e.g:\n\nimport User from './user.js';\nimport LoginForm from './loginForm.js';\nimport func from '/path/to/func.js';\n...\n\nStill, some teams consider it a serious drawback of default exports. So they prefer to always use named exports. Even if only a single thing is exported, it’s still exported under a name, without default.\n\nThat also makes re-export (see below) a little bit easier.\n\nRe-export\n\n“Re-export” syntax export ... from ... allows to import things and immediately export them (possibly under another name), like this:\n\nexport {sayHi} from './say.js'; // re-export sayHi\n\nexport {default as User} from './user.js'; // re-export default\n\nWhy would that be needed? Let’s see a practical use case.\n\nImagine, we’re writing a “package”: a folder with a lot of modules, with some of the functionality exported outside (tools like NPM allow us to publish and distribute such packages, but we don’t have to use them), and many modules are just “helpers”, for internal use in other package modules.\n\nThe file structure could be like this:\n\nauth/\n    index.js\n    user.js\n    helpers.js\n    tests/\n        login.js\n    providers/\n        github.js\n        facebook.js\n        ...\n\nWe’d like to expose the package functionality via a single entry point.\n\nIn other words, a person who would like to use our package, should import only from the “main file” auth/index.js.\n\nLike this:\n\nimport {login, logout} from 'auth/index.js'\n\nThe “main file”, auth/index.js exports all the functionality that we’d like to provide in our package.\n\nThe idea is that outsiders, other programmers who use our package, should not meddle with its internal structure, search for files inside our package folder. We export only what’s necessary in auth/index.js and keep the rest hidden from prying eyes.\n\nAs the actual exported functionality is scattered among the package, we can import it into auth/index.js and export from it:\n\n// 📁 auth/index.js\n\n// import login/logout and immediately export them\nimport {login, logout} from './helpers.js';\nexport {login, logout};\n\n// import default as User and export it\nimport User from './user.js';\nexport {User};\n...\n\nNow users of our package can import {login} from \"auth/index.js\".\n\nThe syntax export ... from ... is just a shorter notation for such import-export:\n\n// 📁 auth/index.js\n// re-export login/logout\nexport {login, logout} from './helpers.js';\n\n// re-export the default export as User\nexport {default as User} from './user.js';\n...\n\nThe notable difference of export ... from compared to import/export is that re-exported modules aren’t available in the current file. So inside the above example of auth/index.js we can’t use re-exported login/logout functions.\n\nRe-exporting the default export\n\nThe default export needs separate handling when re-exporting.\n\nLet’s say we have user.js with the export default class User and would like to re-export it:\n\n// 📁 user.js\nexport default class User {\n  // ...\n}\n\nWe can come across two problems with it:\n\nexport User from './user.js' won’t work. That would lead to a syntax error.\n\nTo re-export the default export, we have to write export {default as User}, as in the example above.\n\nexport * from './user.js' re-exports only named exports, but ignores the default one.\n\nIf we’d like to re-export both named and default exports, then two statements are needed:\n\nexport * from './user.js'; // to re-export named exports\nexport {default} from './user.js'; // to re-export the default export\n\nSuch oddities of re-exporting a default export are one of the reasons why some developers don’t like default exports and prefer named ones.\n\nSummary\n\nHere are all types of export that we covered in this and previous articles.\n\nYou can check yourself by reading them and recalling what they mean:\n\nBefore declaration of a class/function/…:\nexport [default] class/function/variable ...\nStandalone export:\nexport {x [as y], ...}.\nRe-export:\nexport {x [as y], ...} from \"module\"\nexport * from \"module\" (doesn’t re-export default).\nexport {default [as y]} from \"module\" (re-export default).\n\nImport:\n\nImporting named exports:\nimport {x [as y], ...} from \"module\"\nImporting the default export:\nimport x from \"module\"\nimport {default as x} from \"module\"\nImport all:\nimport * as obj from \"module\"\nImport the module (its code runs), but do not assign any of its exports to variables:\nimport \"module\"\n\nWe can put import/export statements at the top or at the bottom of a script, that doesn’t matter.\n\nSo, technically this code is fine:\n\nsayHi();\n\n// ...\n\nimport {sayHi} from './say.js'; // import at the end of the file\n\nIn practice imports are usually at the start of the file, but that’s only for more convenience.\n\nPlease note that import/export statements don’t work if inside {...}.\n\nA conditional import, like this, won’t work:\n\nif (something) {\n  import {sayHi} from \"./say.js\"; // Error: import must be at top level\n}\n\n…But what if we really need to import something conditionally? Or at the right time? Like, load a module upon request, when it’s really needed?\n\nWe’ll see dynamic imports in the next article."
  },
  {
    "title": "Scripts: async, defer",
    "url": "https://javascript.info/script-async-defer",
    "html": "In modern websites, scripts are often “heavier” than HTML: their download size is larger, and processing time is also longer.\n\nWhen the browser loads HTML and comes across a <script>...</script> tag, it can’t continue building the DOM. It must execute the script right now. The same happens for external scripts <script src=\"...\"></script>: the browser must wait for the script to download, execute the downloaded script, and only then can it process the rest of the page.\n\nThat leads to two important issues:\n\nScripts can’t see DOM elements below them, so they can’t add handlers etc.\nIf there’s a bulky script at the top of the page, it “blocks the page”. Users can’t see the page content till it downloads and runs:\n\t\n<p>...content before script...</p>\n\n<script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- This isn't visible until the script loads -->\n<p>...content after script...</p>\n\nThere are some workarounds to that. For instance, we can put a script at the bottom of the page. Then it can see elements above it, and it doesn’t block the page content from showing:\n\n<body>\n  ...all content is above the script...\n\n  <script src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n</body>\n\nBut this solution is far from perfect. For example, the browser notices the script (and can start downloading it) only after it downloaded the full HTML document. For long HTML documents, that may be a noticeable delay.\n\nSuch things are invisible for people using very fast connections, but many people in the world still have slow internet speeds and use a far-from-perfect mobile internet connection.\n\nLuckily, there are two <script> attributes that solve the problem for us: defer and async.\n\ndefer\n\nThe defer attribute tells the browser not to wait for the script. Instead, the browser will continue to process the HTML, build DOM. The script loads “in the background”, and then runs when the DOM is fully built.\n\nHere’s the same example as above, but with defer:\n\n\t\n<p>...content before script...</p>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<!-- visible immediately -->\n<p>...content after script...</p>\n\nIn other words:\n\nScripts with defer never block the page.\nScripts with defer always execute when the DOM is ready (but before DOMContentLoaded event).\n\nThe following example demonstrates the second part:\n\n\t\n<p>...content before scripts...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"DOM ready after defer!\"));\n</script>\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js?speed=1\"></script>\n\n<p>...content after scripts...</p>\nThe page content shows up immediately.\nDOMContentLoaded event handler waits for the deferred script. It only triggers when the script is downloaded and executed.\n\nDeferred scripts keep their relative order, just like regular scripts.\n\nLet’s say, we have two deferred scripts: the long.js and then small.js:\n\n<script defer src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script defer src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n\nBrowsers scan the page for scripts and download them in parallel, to improve performance. So in the example above both scripts download in parallel. The small.js probably finishes first.\n\n…But the defer attribute, besides telling the browser “not to block”, ensures that the relative order is kept. So even though small.js loads first, it still waits and runs after long.js executes.\n\nThat may be important for cases when we need to load a JavaScript library and then a script that depends on it.\n\nThe defer attribute is only for external scripts\n\nThe defer attribute is ignored if the <script> tag has no src.\n\nasync\n\nThe async attribute is somewhat like defer. It also makes the script non-blocking. But it has important differences in the behavior.\n\nThe async attribute means that a script is completely independent:\n\nThe browser doesn’t block on async scripts (like defer).\nOther scripts don’t wait for async scripts, and async scripts don’t wait for them.\nDOMContentLoaded and async scripts don’t wait for each other:\nDOMContentLoaded may happen both before an async script (if an async script finishes loading after the page is complete)\n…or after an async script (if an async script is short or was in HTTP-cache)\n\nIn other words, async scripts load in the background and run when ready. The DOM and other scripts don’t wait for them, and they don’t wait for anything. A fully independent script that runs when loaded. As simple, as it can get, right?\n\nHere’s an example similar to what we’ve seen with defer: two scripts long.js and small.js, but now with async instead of defer.\n\nThey don’t wait for each other. Whatever loads first (probably small.js) – runs first:\n\n\t\n<p>...content before scripts...</p>\n\n<script>\n  document.addEventListener('DOMContentLoaded', () => alert(\"DOM ready!\"));\n</script>\n\n<script async src=\"https://javascript.info/article/script-async-defer/long.js\"></script>\n<script async src=\"https://javascript.info/article/script-async-defer/small.js\"></script>\n\n<p>...content after scripts...</p>\nThe page content shows up immediately: async doesn’t block it.\nDOMContentLoaded may happen both before and after async, no guarantees here.\nA smaller script small.js goes second, but probably loads before long.js, so small.js runs first. Although, it might be that long.js loads first, if cached, then it runs first. In other words, async scripts run in the “load-first” order.\n\nAsync scripts are great when we integrate an independent third-party script into the page: counters, ads and so on, as they don’t depend on our scripts, and our scripts shouldn’t wait for them:\n\n<!-- Google Analytics is usually added like this -->\n<script async src=\"https://google-analytics.com/analytics.js\"></script>\nThe async attribute is only for external scripts\n\nJust like defer, the async attribute is ignored if the <script> tag has no src.\n\nDynamic scripts\n\nThere’s one more important way of adding a script to the page.\n\nWe can create a script and append it to the document dynamically using JavaScript:\n\n\t\nlet script = document.createElement('script');\nscript.src = \"/article/script-async-defer/long.js\";\ndocument.body.append(script); // (*)\n\nThe script starts loading as soon as it’s appended to the document (*).\n\nDynamic scripts behave as “async” by default.\n\nThat is:\n\nThey don’t wait for anything, nothing waits for them.\nThe script that loads first – runs first (“load-first” order).\n\nThis can be changed if we explicitly set script.async=false. Then scripts will be executed in the document order, just like defer.\n\nIn this example, loadScript(src) function adds a script and also sets async to false.\n\nSo long.js always runs first (as it’s added first):\n\n\t\nfunction loadScript(src) {\n  let script = document.createElement('script');\n  script.src = src;\n  script.async = false;\n  document.body.append(script);\n}\n\n// long.js runs first because of async=false\nloadScript(\"/article/script-async-defer/long.js\");\nloadScript(\"/article/script-async-defer/small.js\");\n\nWithout script.async=false, scripts would execute in default, load-first order (the small.js probably first).\n\nAgain, as with the defer, the order matters if we’d like to load a library and then another script that depends on it.\n\nSummary\n\nBoth async and defer have one common thing: downloading of such scripts doesn’t block page rendering. So the user can read page content and get acquainted with the page immediately.\n\nBut there are also essential differences between them:\n\n\tOrder\tDOMContentLoaded\nasync\tLoad-first order. Their document order doesn’t matter – which loads first runs first\tIrrelevant. May load and execute while the document has not yet been fully downloaded. That happens if scripts are small or cached, and the document is long enough.\ndefer\tDocument order (as they go in the document).\tExecute after the document is loaded and parsed (they wait if needed), right before DOMContentLoaded.\n\nIn practice, defer is used for scripts that need the whole DOM and/or their relative execution order is important.\n\nAnd async is used for independent scripts, like counters or ads. And their relative execution order does not matter.\n\nPage without scripts should be usable\n\nPlease note: if you’re using defer or async, then user will see the page before the script loads.\n\nIn such case, some graphical components are probably not initialized yet.\n\nDon’t forget to put “loading” indication and disable buttons that aren’t functional yet. Let the user clearly see what he can do on the page, and what’s still getting ready."
  },
  {
    "title": "Modules",
    "url": "https://javascript.info/modules",
    "html": "Modules, introduction\nExport and Import\nDynamic imports"
  },
  {
    "title": "The JavaScript language",
    "url": "https://javascript.info/js",
    "html": "Here we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.\n\nWe concentrate on the language itself here, with the minimum of environment-specific notes.\n\nAn introduction\nJavaScript Fundamentals\nCode quality\nObjects: the basics\nData types\nAdvanced working with functions\nObject properties configuration\nPrototypes, inheritance\nClasses\nError handling\nPromises, async/await\nGenerators, advanced iteration\nModules\nMiscellaneous"
  },
  {
    "title": "",
    "url": "https://javascript.info/ebook",
    "html": "Buy EPUB/PDF for offline reading\n\nPDF/EPUB book is an offline version of the tutorial. Buying this book, you support the project and become able to read the tutorial as e-book.\n\nYou get the whole content as of now, plus 1 year of free updates.\n\ndownload sample\nWhich parts of the tutorial you want?\nPart I. The JavaScript Language\n710+ pages, PDF + EPUB\n€9\nPart II. Browser: Document, Events, Interfaces\n300+ pages, PDF + EPUB\n€9\nPart III. Various topics: Network, Regexps, etc.\n330+ pages, PDF + EPUB\n€9\nParts I && II together\n2xPDF + 2xEPUB (1000+ pages)\n€12\nFull Tutorial (all 3 parts)\n3xEPUB + 3xPDF (1300+ pages)\n€18\nSpecify your email\nThe download link will be sent to this address after payment.\nIn case of any difficulty please contact orders@javascript.info.\nProceed with payment"
  },
  {
    "title": "The Modern JavaScript Tutorial",
    "url": "https://javascript.info/",
    "html": "PART 1\nThe JavaScript language\nPART 2\nBrowser: Document, Events, Interfaces\nPART 3\nAdditional articles\nThe JavaScript language\n\nHere we learn JavaScript, starting from scratch and go on to advanced concepts like OOP.\n\nWe concentrate on the language itself here, with the minimum of environment-specific notes.\n\nAn introduction\nAn Introduction to JavaScript\nManuals and specifications\nCode editors\nDeveloper console\nJavaScript Fundamentals\nHello, world!\nCode structure\nThe modern mode, \"use strict\"\nVariables\nData types\nInteraction: alert, prompt, confirm\nType Conversions\nBasic operators, maths\nComparisons\nConditional branching: if, '?'\nLogical operators\nNullish coalescing operator '??'\nLoops: while and for\nThe \"switch\" statement\nFunctions\nFunction expressions\nArrow functions, the basics\nJavaScript specials\nCode quality\nDebugging in the browser\nCoding Style\nComments\nNinja code\nAutomated testing with Mocha\nPolyfills and transpilers\nObjects: the basics\nObjects\nObject references and copying\nGarbage collection\nObject methods, \"this\"\nConstructor, operator \"new\"\nOptional chaining '?.'\nSymbol type\nObject to primitive conversion\nData types\nMethods of primitives\nNumbers\nStrings\nArrays\nArray methods\nIterables\nMap and Set\nWeakMap and WeakSet\nObject.keys, values, entries\nDestructuring assignment\nDate and time\nJSON methods, toJSON\nAdvanced working with functions\nRecursion and stack\nRest parameters and spread syntax\nVariable scope, closure\nThe old \"var\"\nGlobal object\nFunction object, NFE\nThe \"new Function\" syntax\nScheduling: setTimeout and setInterval\nDecorators and forwarding, call/apply\nFunction binding\nArrow functions revisited\nObject properties configuration\nProperty flags and descriptors\nProperty getters and setters\nPrototypes, inheritance\nPrototypal inheritance\nF.prototype\nNative prototypes\nPrototype methods, objects without __proto__\nClasses\nClass basic syntax\nClass inheritance\nStatic properties and methods\nPrivate and protected properties and methods\nExtending built-in classes\nClass checking: \"instanceof\"\nMixins\nError handling\nError handling, \"try...catch\"\nCustom errors, extending Error\nPromises, async/await\nIntroduction: callbacks\nPromise\nPromises chaining\nError handling with promises\nPromise API\nPromisification\nMicrotasks\nAsync/await\nGenerators, advanced iteration\nGenerators\nAsync iteration and generators\nModules\nModules, introduction\nExport and Import\nDynamic imports\nMiscellaneous\nProxy and Reflect\nEval: run a code string\nCurrying\nReference Type\nBigInt\nUnicode, String internals\nWeakRef and FinalizationRegistry\nBrowser: Document, Events, Interfaces\n\nLearning how to manage the browser page: add elements, manipulate their size and position, dynamically create interfaces and interact with the visitor.\n\nDocument\nBrowser environment, specs\nDOM tree\nWalking the DOM\nSearching: getElement*, querySelector*\nNode properties: type, tag and contents\nAttributes and properties\nModifying the document\nStyles and classes\nElement size and scrolling\nWindow sizes and scrolling\nCoordinates\nIntroduction to Events\nIntroduction to browser events\nBubbling and capturing\nEvent delegation\nBrowser default actions\nDispatching custom events\nUI Events\nMouse events\nMoving the mouse: mouseover/out, mouseenter/leave\nDrag'n'Drop with mouse events\nPointer events\nKeyboard: keydown and keyup\nScrolling\nForms, controls\nForm properties and methods\nFocusing: focus/blur\nEvents: change, input, cut, copy, paste\nForms: event and method submit\nDocument and resource loading\nPage: DOMContentLoaded, load, beforeunload, unload\nScripts: async, defer\nResource loading: onload and onerror\nMiscellaneous\nMutation observer\nSelection and Range\nEvent loop: microtasks and macrotasks\nAdditional articles\nList of extra topics that assume you've covered the first two parts of tutorial. There is no clear hierarchy here, you can read articles in the order you want.\nFrames and windows\nPopups and window methods\nCross-window communication\nThe clickjacking attack\nBinary data, files\nArrayBuffer, binary arrays\nTextDecoder and TextEncoder\nBlob\nFile and FileReader\nNetwork requests\nFetch\nFormData\nFetch: Download progress\nFetch: Abort\nFetch: Cross-Origin Requests\nFetch API\nURL objects\nXMLHttpRequest\nResumable file upload\nLong polling\nWebSocket\nServer Sent Events\nStoring data in the browser\nCookies, document.cookie\nLocalStorage, sessionStorage\nIndexedDB\nAnimation\nBezier curve\nCSS-animations\nJavaScript animations\nWeb components\nFrom the orbital height\nCustom elements\nShadow DOM\nTemplate element\nShadow DOM slots, composition\nShadow DOM styling\nShadow DOM and events\nRegular expressions\nPatterns and flags\nCharacter classes\nUnicode: flag \"u\" and class \\p{...}\nAnchors: string start ^ and end $\nMultiline mode of anchors ^ $, flag \"m\"\nWord boundary: \\b\nEscaping, special characters\nSets and ranges [...]\nQuantifiers +, *, ? and {n}\nGreedy and lazy quantifiers\nCapturing groups\nBackreferences in pattern: \\N and \\k<name>\nAlternation (OR) |\nLookahead and lookbehind\nCatastrophic backtracking\nSticky flag \"y\", searching at position\nMethods of RegExp and String"
  },
  {
    "title": "Translation of the Modern JavaScript Tutorial",
    "url": "https://javascript.info/translate",
    "html": "There are following translations (in the alphabetical order):\n\nLanguage\tTranslated (%)\tLast Commit\tPublished\nAlbanian\t\n11%\t23 Jun 2023\t\nArabic\t\n57%\t28 May 2023\thttps://ar.javascript.info\nArmenian\t\n12%\t11 Jul 2022\t\nAzerbaijani\t\n17%\t18 Feb 2023\t\nBengali\t\n34%\t15 Oct 2023\t\nBosnian\t\n17%\t15 Dec 2021\t\nBulgarian\t\n24%\t2 Oct 2023\t\nBurmese\t\n4%\t20 Aug 2023\t\nCatalan\t\n32%\t15 Dec 2021\t\nCentral Khmer\t\n30%\t15 Dec 2021\t\nChinese\t\n92%\t14 Oct 2023\thttps://zh.javascript.info\nChinese Traditional\t\n33%\t15 Dec 2021\t\nCroatian\t\n1%\t22 Aug 2022\t\nCzech\t\n14%\t14 Aug 2023\t\nDanish\t\n3%\t14 Aug 2023\t\nDutch\t\n13%\t15 Dec 2021\t\nFinnish\t\n5%\t19 Apr 2022\t\nFrench\t\n83%\t16 Nov 2023\thttps://fr.javascript.info\nGeorgian\t\n5%\t15 Dec 2021\t\nGerman\t\n9%\t25 Nov 2023\t\nGreek\t\n13%\t14 Aug 2023\t\nHebrew\t\n11%\t15 Dec 2021\t\nHindi\t\n9%\t15 Dec 2021\t\nHungarian\t\n6%\t15 Dec 2021\t\nIndonesian\t\n64%\t25 Sep 2023\thttps://id.javascript.info\nItalian\t\n87%\t5 Nov 2023\thttps://it.javascript.info\nJapanese\t\n90%\t30 Sep 2023\thttps://ja.javascript.info\nKazakh\t\n3%\t29 Apr 2023\t\nKorean\t\n74%\t25 Nov 2023\thttps://ko.javascript.info\nKyrgyz\t\n9%\t18 May 2023\t\nLithuanian\t\n16%\t21 Aug 2022\t\nMalay\t\n1%\t12 Nov 2022\t\nMalayalam\t\n5%\t14 Feb 2022\t\nMontenegrin\t\n25%\t15 Dec 2021\t\nNorvegian\t\n32%\t15 Dec 2021\t\nPersian (Farsi)\t\n65%\t14 Nov 2023\thttps://fa.javascript.info\nPolish\t\n25%\t22 Oct 2022\t\nPortuguese\t\n10%\t18 Sep 2023\t\nPunjabi\t\n17%\t15 Dec 2021\t\nRomanian\t\n26%\t6 Sep 2023\t\nRussian\t\n91%\t24 Nov 2023\thttps://learn.javascript.ru\nSerbian\t\n5%\t15 Dec 2021\t\nSinhala\t\n11%\t15 Dec 2021\t\nSlovak\t\n11%\t15 Dec 2021\t\nSlovenian\t\n5%\t15 Dec 2021\t\nSpanish\t\n91%\t19 Nov 2023\thttps://es.javascript.info\nTamil\t\n6%\t15 Dec 2021\t\nTelugu\t\n3%\t12 Feb 2022\t\nThai\t\n17%\t12 Jun 2023\t\nTurkish\t\n63%\t12 Oct 2023\thttps://tr.javascript.info\nTurkmen\t\n11%\t15 Dec 2021\t\nUkrainian\t\n89%\t30 Oct 2023\thttps://uk.javascript.info\nUrdu\t\n4%\t20 Feb 2023\t\nUyghur\t\n1%\t10 Apr 2023\t\nUzbek\t\n51%\t15 Dec 2021\t\nVietnamese\t\n15%\t24 Jul 2023\t\n\nHelp us to translate: click the language name link above, it leads to the repo. Then read the instruction. That's simple, join in!\n\nHelp to translate\n\nTo participate in a translation, simply choose the language in the list above.\n\nThen you’ll get to the language page and see instructions. Maybe even in that language, if the readme is translated :)\n\nBecoming a maintainer\n\nAnyone can contribute to a translation. But maintainers are the ones who also watch over its quality.\n\nMaintainers have the power to review and merge pull requests of others.\n\nPlease file an issue, if:\n\nYou’re already a maintainer of a translation, and would like to add another one.\nYou’re interested in becoming a maintainer for a translation, and other maintainers agree to add you.\nAn existing translation is stalled, previous maintainers don’t respond, and you want to take it over.\nStarting a new translation\n\nYour language is not in the list?\n\nIf you’d like to create a new translation, file an issue with the following information:\n\nLanguage code\nList of maintainers (one or more): github nick and email\n\nAs a maintainer, you should know JavaScript well enough to translate and review pull requests of others.\n\nWe will:\n\nCreate a new repository for you at javascript-tutorial/{lang-code}.javascript.info.\nAdd/invite all maintainers to the team translate-{lang-code} in the javascript-tutorial organization.\nCreate an special issue in the new repository to track your translation progress.\n\nYou’ll get an email invite to join (unless you’re a member already). Please accept this invite, so you can get admin access to your repository!\n\nYou’ll find more translation tips in Readme when the repository is created.\n\nHappy translating!\n\nPublishing\n\nWhen the translation is at least half-finished, please create an issue with a request to publish. Your name and contributions will show up at the About page."
  },
  {
    "title": "Modules, introduction",
    "url": "https://javascript.info/modules-intro",
    "html": "As our application grows bigger, we want to split it into multiple files, so called “modules”. A module may contain a class or a library of functions for a specific purpose.\n\nFor a long time, JavaScript existed without a language-level module syntax. That wasn’t a problem, because initially scripts were small and simple, so there was no need.\n\nBut eventually scripts became more and more complex, so the community invented a variety of ways to organize code into modules, special libraries to load modules on demand.\n\nTo name some (for historical reasons):\n\nAMD – one of the most ancient module systems, initially implemented by the library require.js.\nCommonJS – the module system created for Node.js server.\nUMD – one more module system, suggested as a universal one, compatible with AMD and CommonJS.\n\nNow these all slowly became a part of history, but we still can find them in old scripts.\n\nThe language-level module system appeared in the standard in 2015, gradually evolved since then, and is now supported by all major browsers and in Node.js. So we’ll study the modern JavaScript modules from now on.\n\nWhat is a module?\n\nA module is just a file. One script is one module. As simple as that.\n\nModules can load each other and use special directives export and import to interchange functionality, call functions of one module from another one:\n\nexport keyword labels variables and functions that should be accessible from outside the current module.\nimport allows the import of functionality from other modules.\n\nFor instance, if we have a file sayHi.js exporting a function:\n\n// 📁 sayHi.js\nexport function sayHi(user) {\n  alert(`Hello, ${user}!`);\n}\n\n…Then another file may import and use it:\n\n// 📁 main.js\nimport {sayHi} from './sayHi.js';\n\nalert(sayHi); // function...\nsayHi('John'); // Hello, John!\n\nThe import directive loads the module by path ./sayHi.js relative to the current file, and assigns exported function sayHi to the corresponding variable.\n\nLet’s run the example in-browser.\n\nAs modules support special keywords and features, we must tell the browser that a script should be treated as a module, by using the attribute <script type=\"module\">.\n\nLike this:\n\nResultsay.jsindex.html\n\t\n<!doctype html>\n<script type=\"module\">\n  import {sayHi} from './say.js';\n\n  document.body.innerHTML = sayHi('John');\n</script>\n\nThe browser automatically fetches and evaluates the imported module (and its imports if needed), and then runs the script.\n\nModules work only via HTTP(s), not locally\n\nIf you try to open a web-page locally, via file:// protocol, you’ll find that import/export directives don’t work. Use a local web-server, such as static-server or use the “live server” capability of your editor, such as VS Code Live Server Extension to test modules.\n\nCore module features\n\nWhat’s different in modules, compared to “regular” scripts?\n\nThere are core features, valid both for browser and server-side JavaScript.\n\nAlways “use strict”\n\nModules always work in strict mode. E.g. assigning to an undeclared variable will give an error.\n\n\t\n<script type=\"module\">\n  a = 5; // error\n</script>\nModule-level scope\n\nEach module has its own top-level scope. In other words, top-level variables and functions from a module are not seen in other scripts.\n\nIn the example below, two scripts are imported, and hello.js tries to use user variable declared in user.js. It fails, because it’s a separate module (you’ll see the error in the console):\n\nResulthello.jsuser.jsindex.html\n\t\n<!doctype html>\n<script type=\"module\" src=\"user.js\"></script>\n<script type=\"module\" src=\"hello.js\"></script>\n\nModules should export what they want to be accessible from outside and import what they need.\n\nuser.js should export the user variable.\nhello.js should import it from user.js module.\n\nIn other words, with modules we use import/export instead of relying on global variables.\n\nThis is the correct variant:\n\nResulthello.jsuser.jsindex.html\n\t\nimport {user} from './user.js';\n\ndocument.body.innerHTML = user; // John\n\nIn the browser, if we talk about HTML pages, independent top-level scope also exists for each <script type=\"module\">.\n\nHere are two scripts on the same page, both type=\"module\". They don’t see each other’s top-level variables:\n\n\t\n<script type=\"module\">\n  // The variable is only visible in this module script\n  let user = \"John\";\n</script>\n\n<script type=\"module\">\n  alert(user); // Error: user is not defined\n</script>\nPlease note:\n\nIn the browser, we can make a variable window-level global by explicitly assigning it to a window property, e.g. window.user = \"John\".\n\nThen all scripts will see it, both with type=\"module\" and without it.\n\nThat said, making such global variables is frowned upon. Please try to avoid them.\n\nA module code is evaluated only the first time when imported\n\nIf the same module is imported into multiple other modules, its code is executed only once, upon the first import. Then its exports are given to all further importers.\n\nThe one-time evaluation has important consequences, that we should be aware of.\n\nLet’s see a couple of examples.\n\nFirst, if executing a module code brings side-effects, like showing a message, then importing it multiple times will trigger it only once – the first time:\n\n// 📁 alert.js\nalert(\"Module is evaluated!\");\n// Import the same module from different files\n\n// 📁 1.js\nimport `./alert.js`; // Module is evaluated!\n\n// 📁 2.js\nimport `./alert.js`; // (shows nothing)\n\nThe second import shows nothing, because the module has already been evaluated.\n\nThere’s a rule: top-level module code should be used for initialization, creation of module-specific internal data structures. If we need to make something callable multiple times – we should export it as a function, like we did with sayHi above.\n\nNow, let’s consider a deeper example.\n\nLet’s say, a module exports an object:\n\n// 📁 admin.js\nexport let admin = {\n  name: \"John\"\n};\n\nIf this module is imported from multiple files, the module is only evaluated the first time, admin object is created, and then passed to all further importers.\n\nAll importers get exactly the one and only admin object:\n\n// 📁 1.js\nimport {admin} from './admin.js';\nadmin.name = \"Pete\";\n\n// 📁 2.js\nimport {admin} from './admin.js';\nalert(admin.name); // Pete\n\n// Both 1.js and 2.js reference the same admin object\n// Changes made in 1.js are visible in 2.js\n\nAs you can see, when 1.js changes the name property in the imported admin, then 2.js can see the new admin.name.\n\nThat’s exactly because the module is executed only once. Exports are generated, and then they are shared between importers, so if something changes the admin object, other importers will see that.\n\nSuch behavior is actually very convenient, because it allows us to configure modules.\n\nIn other words, a module can provide a generic functionality that needs a setup. E.g. authentication needs credentials. Then it can export a configuration object expecting the outer code to assign to it.\n\nHere’s the classical pattern:\n\nA module exports some means of configuration, e.g. a configuration object.\nOn the first import we initialize it, write to its properties. The top-level application script may do that.\nFurther imports use the module.\n\nFor instance, the admin.js module may provide certain functionality (e.g. authentication), but expect the credentials to come into the config object from outside:\n\n// 📁 admin.js\nexport let config = { };\n\nexport function sayHi() {\n  alert(`Ready to serve, ${config.user}!`);\n}\n\nHere, admin.js exports the config object (initially empty, but may have default properties too).\n\nThen in init.js, the first script of our app, we import config from it and set config.user:\n\n// 📁 init.js\nimport {config} from './admin.js';\nconfig.user = \"Pete\";\n\n…Now the module admin.js is configured.\n\nFurther importers can call it, and it correctly shows the current user:\n\n// 📁 another.js\nimport {sayHi} from './admin.js';\n\nsayHi(); // Ready to serve, Pete!\nimport.meta\n\nThe object import.meta contains the information about the current module.\n\nIts content depends on the environment. In the browser, it contains the URL of the script, or a current webpage URL if inside HTML:\n\n\t\n<script type=\"module\">\n  alert(import.meta.url); // script URL\n  // for an inline script - the URL of the current HTML-page\n</script>\nIn a module, “this” is undefined\n\nThat’s kind of a minor feature, but for completeness we should mention it.\n\nIn a module, top-level this is undefined.\n\nCompare it to non-module scripts, where this is a global object:\n\n\t\n<script>\n  alert(this); // window\n</script>\n\n<script type=\"module\">\n  alert(this); // undefined\n</script>\nBrowser-specific features\n\nThere are also several browser-specific differences of scripts with type=\"module\" compared to regular ones.\n\nYou may want to skip this section for now if you’re reading for the first time, or if you don’t use JavaScript in a browser.\n\nModule scripts are deferred\n\nModule scripts are always deferred, same effect as defer attribute (described in the chapter Scripts: async, defer), for both external and inline scripts.\n\nIn other words:\n\ndownloading external module scripts <script type=\"module\" src=\"...\"> doesn’t block HTML processing, they load in parallel with other resources.\nmodule scripts wait until the HTML document is fully ready (even if they are tiny and load faster than HTML), and then run.\nrelative order of scripts is maintained: scripts that go first in the document, execute first.\n\nAs a side effect, module scripts always “see” the fully loaded HTML-page, including HTML elements below them.\n\nFor instance:\n\n\t\n<script type=\"module\">\n  alert(typeof button); // object: the script can 'see' the button below\n  // as modules are deferred, the script runs after the whole page is loaded\n</script>\n\nCompare to regular script below:\n\n<script>\n  alert(typeof button); // button is undefined, the script can't see elements below\n  // regular scripts run immediately, before the rest of the page is processed\n</script>\n\n<button id=\"button\">Button</button>\n\nPlease note: the second script actually runs before the first! So we’ll see undefined first, and then object.\n\nThat’s because modules are deferred, so we wait for the document to be processed. The regular script runs immediately, so we see its output first.\n\nWhen using modules, we should be aware that the HTML page shows up as it loads, and JavaScript modules run after that, so the user may see the page before the JavaScript application is ready. Some functionality may not work yet. We should put “loading indicators”, or otherwise ensure that the visitor won’t be confused by that.\n\nAsync works on inline scripts\n\nFor non-module scripts, the async attribute only works on external scripts. Async scripts run immediately when ready, independently of other scripts or the HTML document.\n\nFor module scripts, it works on inline scripts as well.\n\nFor example, the inline script below has async, so it doesn’t wait for anything.\n\nIt performs the import (fetches ./analytics.js) and runs when ready, even if the HTML document is not finished yet, or if other scripts are still pending.\n\nThat’s good for functionality that doesn’t depend on anything, like counters, ads, document-level event listeners.\n\n<!-- all dependencies are fetched (analytics.js), and the script runs -->\n<!-- doesn't wait for the document or other <script> tags -->\n<script async type=\"module\">\n  import {counter} from './analytics.js';\n\n  counter.count();\n</script>\nExternal scripts\n\nExternal scripts that have type=\"module\" are different in two aspects:\n\nExternal scripts with the same src run only once:\n\n<!-- the script my.js is fetched and executed only once -->\n<script type=\"module\" src=\"my.js\"></script>\n<script type=\"module\" src=\"my.js\"></script>\n\nExternal scripts that are fetched from another origin (e.g. another site) require CORS headers, as described in the chapter Fetch: Cross-Origin Requests. In other words, if a module script is fetched from another origin, the remote server must supply a header Access-Control-Allow-Origin allowing the fetch.\n\n<!-- another-site.com must supply Access-Control-Allow-Origin -->\n<!-- otherwise, the script won't execute -->\n<script type=\"module\" src=\"http://another-site.com/their.js\"></script>\n\nThat ensures better security by default.\n\nNo “bare” modules allowed\n\nIn the browser, import must get either a relative or absolute URL. Modules without any path are called “bare” modules. Such modules are not allowed in import.\n\nFor instance, this import is invalid:\n\nimport {sayHi} from 'sayHi'; // Error, \"bare\" module\n// the module must have a path, e.g. './sayHi.js' or wherever the module is\n\nCertain environments, like Node.js or bundle tools allow bare modules, without any path, as they have their own ways for finding modules and hooks to fine-tune them. But browsers do not support bare modules yet.\n\nCompatibility, “nomodule”\n\nOld browsers do not understand type=\"module\". Scripts of an unknown type are just ignored. For them, it’s possible to provide a fallback using the nomodule attribute:\n\n\t\n<script type=\"module\">\n  alert(\"Runs in modern browsers\");\n</script>\n\n<script nomodule>\n  alert(\"Modern browsers know both type=module and nomodule, so skip this\")\n  alert(\"Old browsers ignore script with unknown type=module, but execute this.\");\n</script>\nBuild tools\n\nIn real-life, browser modules are rarely used in their “raw” form. Usually, we bundle them together with a special tool such as Webpack and deploy to the production server.\n\nOne of the benefits of using bundlers – they give more control over how modules are resolved, allowing bare modules and much more, like CSS/HTML modules.\n\nBuild tools do the following:\n\nTake a “main” module, the one intended to be put in <script type=\"module\"> in HTML.\nAnalyze its dependencies: imports and then imports of imports etc.\nBuild a single file with all modules (or multiple files, that’s tunable), replacing native import calls with bundler functions, so that it works. “Special” module types like HTML/CSS modules are also supported.\nIn the process, other transformations and optimizations may be applied:\nUnreachable code removed.\nUnused exports removed (“tree-shaking”).\nDevelopment-specific statements like console and debugger removed.\nModern, bleeding-edge JavaScript syntax may be transformed to older one with similar functionality using Babel.\nThe resulting file is minified (spaces removed, variables replaced with shorter names, etc).\n\nIf we use bundle tools, then as scripts are bundled together into a single file (or few files), import/export statements inside those scripts are replaced by special bundler functions. So the resulting “bundled” script does not contain any import/export, it doesn’t require type=\"module\", and we can put it into a regular script:\n\n<!-- Assuming we got bundle.js from a tool like Webpack -->\n<script src=\"bundle.js\"></script>\n\nThat said, native modules are also usable. So we won’t be using Webpack here: you can configure it later.\n\nSummary\n\nTo summarize, the core concepts are:\n\nA module is a file. To make import/export work, browsers need <script type=\"module\">. Modules have several differences:\nDeferred by default.\nAsync works on inline scripts.\nTo load external scripts from another origin (domain/protocol/port), CORS headers are needed.\nDuplicate external scripts are ignored.\nModules have their own, local top-level scope and interchange functionality via import/export.\nModules always use strict.\nModule code is executed only once. Exports are created once and shared between importers.\n\nWhen we use modules, each module implements the functionality and exports it. Then we use import to directly import it where it’s needed. The browser loads and evaluates the scripts automatically.\n\nIn production, people often use bundlers such as Webpack to bundle modules together for performance and other reasons.\n\nIn the next chapter we’ll see more examples of modules, and how things can be exported/imported."
  }
]