[
  {
    "title": "Unsupported transform in content config. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unsupported-config-transform-error/",
    "html": "Unsupported transform in content config.\n\nUnsupportedConfigTransformError: transform() functions in your content config must return valid JSON, or data types compatible with the devalue library (including Dates, Maps, and Sets).\nFull error: PARSE_ERROR\n\nWhat went wrong?\nSection titled What went wrong?\n\ntransform() functions in your content config must return valid JSON, or data types compatible with the devalue library (including Dates, Maps, and Sets).\n\nSee Also:\n\ndevalue library"
  },
  {
    "title": "Collection contains entries of a different type. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/content-collection-type-mismatch-error/",
    "html": "Collection contains entries of a different type.\n\nCOLLECTION_NAME contains entries of type ACTUAL_TYPE, but is configured as a EXPECTED_TYPE collection.\n\nWhat went wrong?\nSection titled What went wrong?\n\nContent collections must contain entries of the type configured. Collections are type: 'content' by default. Try adding type: 'data' to your collection config for data collections.\n\nSee Also:\n\nDefining content collections"
  },
  {
    "title": "Data collection entry failed to parse. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/data-collection-entry-parse-error/",
    "html": "Data collection entry failed to parse.\n\nCOLLECTION_ENTRY_NAME failed to parse.\n\nWhat went wrong?\nSection titled What went wrong?\n\nCollection entries of type: 'data' must return an object with valid JSON (for .json entries) or YAML (for .yaml entries)."
  },
  {
    "title": "Duplicate content entry slug. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/duplicate-content-entry-slug-error/",
    "html": "Duplicate content entry slug.\n\nCOLLECTION_NAME contains multiple entries with the same slug: SLUG. Slugs must be unique.\n\nWhat went wrong?\nSection titled What went wrong?\n\nContent collection entries must have unique slugs. Duplicates are often caused by the slug frontmatter property."
  },
  {
    "title": "Content and data cannot be in same collection. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/mixed-content-data-collection-error/",
    "html": "Content and data cannot be in same collection.\n\nCOLLECTION_NAME contains a mix of content and data entries. All entries must be of the same type.\n\nWhat went wrong?\nSection titled What went wrong?\n\nA content collection cannot contain a mix of content and data entries. You must store entries in separate collections by type.\n\nSee Also:\n\nDefining content collections"
  },
  {
    "title": "Content Schema should not contain slug. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/content-schema-contains-slug-error/",
    "html": "Content Schema should not contain slug.\n\nContentSchemaContainsSlugError: A content collection schema should not contain slug since it is reserved for slug generation. Remove this from your COLLECTION_NAME collection schema.\n\nWhat went wrong?\nSection titled What went wrong?\n\nA content collection schema should not contain the slug field. This is reserved by Astro for generating entry slugs. Remove slug from your schema. You can still use custom slugs in your frontmatter.\n\nSee Also:\n\nThe reserved entry slug field"
  },
  {
    "title": "Collection does not exist üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/errors/collection-does-not-exist-error/",
    "html": "Collection does not exist\n\n DEPRECATED\n\nCollections that do not exist no longer result in an error. A warning is given instead.\n\nA collection queried via getCollection() does not exist.\n\nWhat went wrong?\nSection titled What went wrong?\n\nWhen querying a collection, ensure a collection directory with the requested name exists under src/content/."
  },
  {
    "title": "Invalid content entry slug. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-content-entry-slug-error/",
    "html": "Invalid content entry slug.\n\nCOLLECTION_NAME ‚Üí ENTRY_ID has an invalid slug. slug must be a string.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAn entry in src/content/ has an invalid slug. This field is reserved for generating entry slugs, and must be a string when present.\n\nSee Also:\n\nThe reserved entry slug field"
  },
  {
    "title": "Content entry frontmatter does not match schema. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-content-entry-frontmatter-error/",
    "html": "Content entry frontmatter does not match schema.\n\nExample error message:\nblog ‚Üí post.md frontmatter does not match collection schema.\n‚Äútitle‚Äù is required.\n‚Äúdate‚Äù must be a valid date.\n\nWhat went wrong?\nSection titled What went wrong?\n\nA Markdown or MDX entry in src/content/ does not match its collection schema. Make sure that all required fields are present, and that all fields are of the correct type. You can check against the collection schema in your src/content/config.* file. See the Content collections documentation for more information."
  },
  {
    "title": "Unknown Content Collection Error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unknown-content-collection-error/",
    "html": "Unknown Content Collection Error.\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an unknown error loading your content collections. This can be caused by certain errors inside your src/content/config.ts file or some internal errors.\n\nIf you can reliably cause this error to happen, we‚Äôd appreciate if you could open an issue"
  },
  {
    "title": "Failed to generate content types. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/generate-content-types-error/",
    "html": "Failed to generate content types.\n\nGenerateContentTypesError: astro sync command failed to generate content collection types: ERROR_MESSAGE\n\nWhat went wrong?\nSection titled What went wrong?\n\nastro sync command failed to generate content collection types.\n\nSee Also:\n\nContent collections documentation"
  },
  {
    "title": "Specified configuration file not found. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/config-not-found/",
    "html": "Specified configuration file not found.\n\nConfigNotFound: Unable to resolve --config \"CONFIG_FILE\". Does the file exist?\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe specified configuration file using --config could not be found. Make sure that it exists or that the path is correct\n\nSee Also:\n\n--config"
  },
  {
    "title": "Unknown CLI Error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unknown-clierror/",
    "html": "Unknown CLI Error.\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an unknown error while starting one of its CLI commands. The error message should contain more information.\n\nIf you can reliably cause this error to happen, we‚Äôd appreciate if you could open an issue"
  },
  {
    "title": "Legacy configuration detected. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/config-legacy-key/",
    "html": "Legacy configuration detected.\n\nConfigLegacyKey: Legacy configuration detected: LEGACY_CONFIG_KEY.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro detected a legacy configuration option in your configuration file.\n\nSee Also:\n\nConfiguration reference"
  },
  {
    "title": "Unknown configuration error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unknown-config-error/",
    "html": "Unknown configuration error.\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an unknown error loading your Astro configuration file. This is often caused by a syntax error in your config and the message should offer more information.\n\nIf you can reliably cause this error to happen, we‚Äôd appreciate if you could open an issue\n\nSee Also:\n\nConfiguration Reference"
  },
  {
    "title": "Invalid frontmatter injection. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-frontmatter-injection-error/",
    "html": "Invalid frontmatter injection.\n\nInvalidFrontmatterInjectionError: A remark or rehype plugin attempted to inject invalid frontmatter. Ensure ‚Äúastro.frontmatter‚Äù is set to a valid JSON object that is not null or undefined.\n\nWhat went wrong?\nSection titled What went wrong?\n\nA remark or rehype plugin attempted to inject invalid frontmatter. This occurs when ‚Äúastro.frontmatter‚Äù is set to null, undefined, or an invalid JSON object.\n\nSee Also:\n\nModifying frontmatter programmatically"
  },
  {
    "title": "MDX integration missing. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/mdx-integration-missing-error/",
    "html": "MDX integration missing.\n\nMdxIntegrationMissingError: Unable to render FILE. Ensure that the @astrojs/mdx integration is installed.\n\nWhat went wrong?\nSection titled What went wrong?\n\nUnable to find the official @astrojs/mdx integration. This error is raised when using MDX files without an MDX integration installed.\n\nSee Also:\n\nMDX installation and usage"
  },
  {
    "title": "Failed to parse Markdown frontmatter. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/markdown-frontmatter-parse-error/",
    "html": "Failed to parse Markdown frontmatter.\n\nExample error messages:\ncan not read an implicit mapping pair; a colon is missed\nunexpected end of the stream within a double quoted scalar\ncan not read a block mapping entry; a multiline key may not be an implicit key\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an error while parsing the frontmatter of your Markdown file. This is often caused by a mistake in the syntax, such as a missing colon or a missing end quote."
  },
  {
    "title": "Unknown Markdown Error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unknown-markdown-error/",
    "html": "Unknown Markdown Error.\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an unknown error while parsing your Markdown. Oftentimes, this is caused by a syntax error and the error message should contain more information."
  },
  {
    "title": "Unknown CSS Error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unknown-csserror/",
    "html": "Unknown CSS Error.\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an unknown error while parsing your CSS. Oftentimes, this is caused by a syntax error and the error message should contain more information.\n\nSee Also:\n\nStyles and CSS"
  },
  {
    "title": "CSS Syntax Error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/csssyntax-error/",
    "html": "CSS Syntax Error.\n\nExample error messages:\nCSSSyntaxError: Missed semicolon\nCSSSyntaxError: Unclosed string\n\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an error while parsing your CSS, due to a syntax error. This is often caused by a missing semicolon."
  },
  {
    "title": "Astro couldn't find the correct page to render üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/errors/failed-to-find-page-map-ssr/",
    "html": "Astro couldn't find the correct page to render\n\nFailedToFindPageMapSSR: Astro couldn‚Äôt find the correct page to render, probably because it wasn‚Äôt correctly mapped for SSR usage. This is an internal error. Please file an issue.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro couldn‚Äôt find the correct page to render, probably because it wasn‚Äôt correctly mapped for SSR usage. This is an internal error."
  },
  {
    "title": "Invalid glob pattern. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-glob/",
    "html": "Invalid glob pattern.\n\nInvalidGlob: Invalid glob pattern: GLOB_PATTERN. Glob patterns must start with ‚Äô./‚Äô, ‚Äò../‚Äô or ‚Äô/‚Äò.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an invalid glob pattern. This is often caused by the glob pattern not being a valid file path.\n\nSee Also:\n\nGlob Patterns"
  },
  {
    "title": "Unknown Vite Error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unknown-vite-error/",
    "html": "Unknown Vite Error.\nWhat went wrong?\nSection titled What went wrong?\n\nVite encountered an unknown error while rendering your project. We unfortunately do not know what happened (or we would tell you!)\n\nIf you can reliably cause this error to happen, we‚Äôd appreciate if you could open an issue\n\nSee Also:\n\nVite troubleshooting guide"
  },
  {
    "title": "Could not import file. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/failed-to-load-module-ssr/",
    "html": "Could not import file.\n\nFailedToLoadModuleSSR: Could not import IMPORT_NAME.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro could not import the requested file. Oftentimes, this is caused by the import path being wrong (either because the file does not exist, or there is a typo in the path)\n\nThis message can also appear when a type is imported without specifying that it is a type import.\n\nSee Also:\n\nType Imports"
  },
  {
    "title": "Could not find Sharp. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/missing-sharp/",
    "html": "Could not find Sharp.\n\nMissingSharp: Could not find Sharp. Please install Sharp (sharp) manually into your project or migrate to another image service.\n\nWhat went wrong?\nSection titled What went wrong?\n\nSharp is the default image service used for astro:assets. When using a strict package manager like pnpm, Sharp must be installed manually into your project in order to use image processing.\n\nIf you are not using astro:assets for image processing, and do not wish to install Sharp, you can configure the following passthrough image service that does no processing:\n\nimport { defineConfig, passthroughImageService } from \"astro/config\";\nexport default defineConfig({\n image: {\n   service: passthroughImageService(),\n },\n});\n\nSee Also:\n\nDefault Image Service\nImage Component\nImage Services API"
  },
  {
    "title": "Invalid dynamic route. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-dynamic-route/",
    "html": "Invalid dynamic route.\n\nInvalidDynamicRoute: The INVALID_PARAM param for route ROUTE is invalid. Received RECEIVED.\n\nWhat went wrong?\nSection titled What went wrong?\n\nA dynamic route param is invalid. This is often caused by an undefined parameter or a missing rest parameter.\n\nSee Also:\n\nDynamic routes"
  },
  {
    "title": "A redirect must be given a location with the Location header. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/redirect-with-no-location/",
    "html": "A redirect must be given a location with the Location header.\nWhat went wrong?\nSection titled What went wrong?\n\nA redirect must be given a location with the Location header.\n\nSee Also:\n\nAstro.redirect"
  },
  {
    "title": "Astro.glob() used outside of an Astro file. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/astro-glob-used-outside/",
    "html": "Astro.glob() used outside of an Astro file.\n\nAstroGlobUsedOutside: Astro.glob(GLOB_STR) can only be used in .astro files. import.meta.glob(GLOB_STR) can be used instead to achieve a similar result.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro.glob() can only be used in .astro files. You can use import.meta.glob() instead to acheive the same result.\n\nSee Also:\n\nAstro.glob"
  },
  {
    "title": "Astro.glob() did not match any files. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/astro-glob-no-match/",
    "html": "Astro.glob() did not match any files.\n\nAstroGlobNoMatch: Astro.glob(GLOB_STR) did not return any matching files. Check the pattern for typos.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro.glob() did not return any matching files. There might be a typo in the glob pattern.\n\nSee Also:\n\nAstro.glob"
  },
  {
    "title": "Local images must be imported. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/local-image-used-wrongly/",
    "html": "Local images must be imported.\n\nLocalImageUsedWrongly: Image‚Äôs and getImage‚Äôs src parameter must be an imported image or an URL, it cannot be a string filepath. Received IMAGE_FILE_PATH.\n\nWhat went wrong?\nSection titled What went wrong?\n\nWhen using the default image services, Image‚Äôs and getImage‚Äôs src parameter must be either an imported image or an URL, it cannot be a string of a filepath.\n\nFor local images from content collections, you can use the image() schema helper to resolve the images.\n\n---\nimport { Image } from \"astro:assets\";\nimport myImage from \"../my_image.png\";\n---\n\n\n<!-- GOOD: `src` is the full imported image. -->\n<Image src={myImage} alt=\"Cool image\" />\n\n\n<!-- GOOD: `src` is a URL. -->\n<Image src=\"https://example.com/my_image.png\" alt=\"Cool image\" />\n\n\n<!-- BAD: `src` is an image's `src` path instead of the full image object. -->\n<Image src={myImage.src} alt=\"Cool image\" />\n\n\n<!-- BAD: `src` is a string filepath. -->\n<Image src=\"../my_image.png\" alt=\"Cool image\" />\n\nSee Also:\n\nImages"
  },
  {
    "title": "The middleware didn't return a response or call next. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/middleware-no-data-or-next-called/",
    "html": "The middleware didn't return a response or call next.\n\nMiddlewareNoDataOrNextCalled: The middleware needs to either return a Response object or call the next function.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThrown when the middleware does not return any data or call the next function.\n\nFor example:\n\nimport {defineMiddleware} from \"astro:middleware\";\nexport const onRequest = defineMiddleware((context, _) => {\n  // doesn't return anything or call `next`\n  context.locals.someData = false;\n});"
  },
  {
    "title": "Value assigned to locals is not accepted. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/locals-not-an-object/",
    "html": "Value assigned to locals is not accepted.\n\nLocalsNotAnObject: locals can only be assigned to an object. Other values like numbers, strings, etc. are not accepted.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThrown in development mode when locals is overwritten with something that is not an object\n\nFor example:\n\nimport {defineMiddleware} from \"astro:middleware\";\nexport const onRequest = defineMiddleware((context, next) => {\n  context.locals = 1541;\n  return next();\n});"
  },
  {
    "title": "The middleware returned something that is not a Response object. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/middleware-not-aresponse/",
    "html": "The middleware returned something that is not a Response object.\n\nMiddlewareNotAResponse: Any data returned from middleware must be a valid Response object.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThrown in development mode when middleware returns something that is not a Response object.\n\nFor example:\n\nimport {defineMiddleware} from \"astro:middleware\";\nexport const onRequest = defineMiddleware(() => {\n  return \"string\"\n});"
  },
  {
    "title": "Image not found. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/markdown-image-not-found/",
    "html": "Image not found.\n\n DEPRECATED\n\nThis error is no longer Markdown specific and as such, as been replaced by ImageNotFound\n\nCould not find requested image IMAGE_PATH at FULL_IMAGE_PATH.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro could not find an image you included in your Markdown content. Usually, this is simply caused by a typo in the path.\n\nImages in Markdown are relative to the current file. To refer to an image that is located in the same folder as the .md file, the path should start with ./\n\nSee Also:\n\nImages"
  },
  {
    "title": "Unable to set response. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/response-sent-error/",
    "html": "Unable to set response.\n\nResponseSentError: The response has already been sent to the browser and cannot be altered.\n\nWhat went wrong?\nSection titled What went wrong?\n\nMaking changes to the response, such as setting headers, cookies, and the status code cannot be done outside of page components."
  },
  {
    "title": "Could not process image metadata. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/no-image-metadata/",
    "html": "Could not process image metadata.\n\nCould not process image metadata for IMAGE_PATH.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro could not process the metadata of an image you imported. This is often caused by a corrupted or malformed image and re-exporting the image from your image editor may fix this issue.\n\nSee Also:\n\nImages"
  },
  {
    "title": "Expected src to be an image. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/expected-image/",
    "html": "Expected src to be an image.\n\nExpectedImage: Expected src property for getImage or <Image /> to be either an ESM imported image or a string with the path of a remote image. Received SRC (type: TYPEOF_OPTIONS).\n\nFull serialized options received: FULL_OPTIONS.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAn image‚Äôs src property is not valid. The Image component requires the src attribute to be either an image that has been ESM imported or a string. This is also true for the first parameter of getImage().\n\n---\nimport { Image } from \"astro:assets\";\nimport myImage from \"../assets/my_image.png\";\n---\n\n\n<Image src={myImage} alt=\"...\" />\n<Image src=\"https://example.com/logo.png\" width={300} height={300} alt=\"...\" />\n\nIn most cases, this error happens when the value passed to src is undefined.\n\nSee Also:\n\nImages"
  },
  {
    "title": "Image not found. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/image-not-found/",
    "html": "Image not found.\n\nImageNotFound: Could not find requested image IMAGE_PATH. Does it exist?\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro could not find an image you imported. Often, this is simply caused by a typo in the path.\n\nImages in Markdown are relative to the current file. To refer to an image that is located in the same folder as the .md file, the path should start with ./\n\nSee Also:\n\nImages"
  },
  {
    "title": "Cannot set both densities and widths üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/errors/incompatible-descriptor-options/",
    "html": "Cannot set both densities and widths\n\nIncompatibleDescriptorOptions: Only one of densities or widths can be specified. In most cases, you‚Äôll probably want to use only widths if you require specific widths.\n\nWhat went wrong?\nSection titled What went wrong?\n\nOnly one of densities or widths can be specified. Those attributes are used to construct a srcset attribute, which cannot have both x and w descriptors.\n\nSee Also:\n\nImages"
  },
  {
    "title": "Expected image options. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/expected-image-options/",
    "html": "Expected image options.\n\nExpectedImageOptions: Expected getImage() parameter to be an object. Received OPTIONS.\n\nWhat went wrong?\nSection titled What went wrong?\n\ngetImage()‚Äôs first parameter should be an object with the different properties to apply to your image.\n\nimport { getImage } from \"astro:assets\";\nimport myImage from \"../assets/my_image.png\";\n\n\nconst optimizedImage = await getImage({src: myImage, width: 300, height: 300});\n\nIn most cases, this error happens because parameters were passed directly instead of inside an object.\n\nSee Also:\n\nImages"
  },
  {
    "title": "Prerendered dynamic endpoint has path collision. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/prerender-dynamic-endpoint-path-collide/",
    "html": "Prerendered dynamic endpoint has path collision.\n\nPrerenderDynamicEndpointPathCollide: Could not render PATHNAME with an undefined param as the generated path will collide during prerendering. Prevent passing undefined as params for the endpoint‚Äôs getStaticPaths() function, or add an additional extension to the endpoint‚Äôs filename.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe endpoint is prerendered with an undefined param so the generated path will collide with another route.\n\nIf you cannot prevent passing undefined, then an additional extension can be added to the endpoint file name to generate the file with a different name. For example, renaming pages/api/[slug].ts to pages/api/[slug].json.ts.\n\nSee Also:\n\ngetStaticPaths()\nparams"
  },
  {
    "title": "Unsupported image conversion üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/errors/unsupported-image-conversion/",
    "html": "Unsupported image conversion\n\nUnsupportedImageConversion: Converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images is not currently supported.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro does not currently supporting converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images.\n\nSee Also:\n\nImages"
  },
  {
    "title": "Unsupported image format üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/errors/unsupported-image-format/",
    "html": "Unsupported image format\n\nUnsupportedImageFormat: Received unsupported format FORMAT from IMAGE_PATH. Currently only SUPPORTED_FORMATS.JOIN(‚Äô, ‚Äô) are supported by our image services.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe built-in image services do not currently support optimizing all image formats.\n\nFor unsupported formats such as GIFs, you may be able to use an img tag directly:\n\n---\nimport rocket from '../assets/images/rocket.gif';\n---\n\n\n<img src={rocket.src} width={rocket.width} height={rocket.height} alt=\"A rocketship in space.\" />"
  },
  {
    "title": "Error while loading image service. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-image-service/",
    "html": "Error while loading image service.\n\nInvalidImageService: There was an error loading the configured image service. Please see the stack trace for more information.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThere was an error while loading the configured image service. This can be caused by various factors, such as your image service not properly exporting a compatible object in its default export, or an incorrect path.\n\nIf you believe that your service is properly configured and this error is wrong, please open an issue.\n\nSee Also:\n\nImage Service API"
  },
  {
    "title": "Missing image dimensions üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/errors/missing-image-dimension/",
    "html": "Missing image dimensions\n\nMissing width and height attributes for IMAGE_URL. When using remote images, both dimensions are always required in order to avoid cumulative layout shift (CLS).\n\nWhat went wrong?\nSection titled What went wrong?\n\nFor remote images, width and height cannot be inferred from the original file. As such, in order to avoid CLS, those two properties are always required.\n\nIf your image is inside your src folder, you probably meant to import it instead. See the Imports guide for more information.\n\nSee Also:\n\nImages\nImage component#width-and-height-required"
  },
  {
    "title": "Missing alt property. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/image-missing-alt/",
    "html": "Missing alt property.\n\nImageMissingAlt: The alt property is required.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe alt property allows you to provide descriptive alt text to users of screen readers and other assistive technologies. In order to ensure your images are accessible, the Image component requires that an alt be specified.\n\nIf the image is merely decorative (i.e. doesn‚Äôt contribute to the understanding of the page), set alt=\"\" so that screen readers know to ignore the image.\n\nSee Also:\n\nImages\nImage component\n¬†Image component#alt"
  },
  {
    "title": "Page number param not found. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/page-number-param-not-found/",
    "html": "Page number param not found.\n\nPageNumberParamNotFound: [paginate()] page number param PARAM_NAME not found in your filepath.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe page number parameter was not found in your filepath.\n\nSee Also:\n\nPagination"
  },
  {
    "title": "Invalid component arguments. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-component-args/",
    "html": "Invalid component arguments.\n\nExample error messages:\nInvalidComponentArgs: Invalid arguments passed to <MyAstroComponent> component.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro components cannot be rendered manually via a function call, such as Component() or {items.map(Component)}. Prefer the component syntax <Component /> or {items.map(item => <Component {...item} />)}."
  },
  {
    "title": "Invalid prerender export. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-prerender-export/",
    "html": "Invalid prerender export.\n\nExample error messages:\nInvalidPrerenderExport: A prerender export has been detected, but its value cannot be statically analyzed.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe prerender feature only supports a subset of valid JavaScript ‚Äî be sure to use exactly export const prerender = true so that our compiler can detect this directive at build time. Variables, let, and var declarations are not supported."
  },
  {
    "title": "No import found for component. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/no-matching-import/",
    "html": "No import found for component.\n\nNoMatchingImport: Could not render COMPONENT_NAME. No matching import has been found for COMPONENT_NAME.\n\nWhat went wrong?\nSection titled What went wrong?\n\nNo import statement was found for one of the components. If there is an import statement, make sure you are using the same identifier in both the imports and the component usage."
  },
  {
    "title": "Invalid slot name. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/reserved-slot-name/",
    "html": "Invalid slot name.\n\nReservedSlotName: Unable to create a slot named SLOT_NAME. SLOT_NAME is a reserved slot name. Please update the name of this slot.\n\nWhat went wrong?\nSection titled What went wrong?\n\nCertain words cannot be used for slot names due to being already used internally.\n\nSee Also:\n\nNamed slots"
  },
  {
    "title": "Cannot use Server-side Rendering without an adapter. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/no-adapter-installed/",
    "html": "Cannot use Server‚Å†-‚Å†side Rendering without an adapter.\n\nNoAdapterInstalled: Cannot use output: 'server' or output: 'hybrid' without an adapter. Please install and configure the appropriate server adapter for your final deployment.\n\nWhat went wrong?\nSection titled What went wrong?\n\nTo use server-side rendering, an adapter needs to be installed so Astro knows how to generate the proper output for your targeted deployment platform.\n\nSee Also:\n\nServer-side Rendering"
  },
  {
    "title": "Invalid value for getStaticPaths route parameter. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/get-static-paths-invalid-route-param/",
    "html": "Invalid value for getStaticPaths route parameter.\n\nGetStaticPathsInvalidRouteParam: Invalid getStaticPaths route parameter for KEY. Expected undefined, a string or a number, received VALUE_TYPE (VALUE)\n\nWhat went wrong?\nSection titled What went wrong?\n\nSince params are encoded into the URL, only certain types are supported as values.\n\n/route/[id].astro\n---\nexport async function getStaticPaths() {\n  return [\n    { params: { id: '1' } } // Works\n    { params: { id: 2 } } // Works\n    { params: { id: false } } // Does not work\n  ];\n}\n---\n\nIn routes using rest parameters, undefined can be used to represent a path with no parameters passed in the URL:\n\n/route/[...id].astro\n---\nexport async function getStaticPaths() {\n  return [\n    { params: { id: 1 } } // /route/1\n    { params: { id: 2 } } // /route/2\n    { params: { id: undefined } } // /route/\n  ];\n}\n---\n\nSee Also:\n\ngetStaticPaths()\nparams"
  },
  {
    "title": "Missing params property on getStaticPaths route. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/get-static-paths-expected-params/",
    "html": "Missing params property on getStaticPaths route.\n\nGetStaticPathsExpectedParams: Missing or empty required params property on getStaticPaths route.\n\nWhat went wrong?\nSection titled What went wrong?\n\nEvery route specified by getStaticPaths require a params property specifying the path parameters needed to match the route.\n\nFor instance, the following code:\n\npages/blog/[id].astro\n---\nexport async function getStaticPaths() {\n  return [\n    { params: { id: '1' } }\n  ];\n}\n---\n\nWill create the following route: site.com/blog/1.\n\nSee Also:\n\ngetStaticPaths()\nparams"
  },
  {
    "title": "getStaticPaths() function required for dynamic routes. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/get-static-paths-required/",
    "html": "getStaticPaths() function required for dynamic routes.\n\nGetStaticPathsRequired: getStaticPaths() function is required for dynamic routes. Make sure that you export a getStaticPaths function from your dynamic route.\n\nWhat went wrong?\nSection titled What went wrong?\n\nIn Static Mode, all routes must be determined at build time. As such, dynamic routes must export a getStaticPaths function returning the different paths to generate.\n\nSee Also:\n\nDynamic Routes\ngetStaticPaths()\nServer-side Rendering"
  },
  {
    "title": "getStaticPaths RSS helper is not available anymore. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/get-static-paths-removed-rsshelper/",
    "html": "getStaticPaths RSS helper is not available anymore.\n\nGetStaticPathsRemovedRSSHelper: The RSS helper has been removed from getStaticPaths. Try the new @astrojs/rss package instead.\n\nWhat went wrong?\nSection titled What went wrong?\n\ngetStaticPaths no longer expose an helper for generating a RSS feed. We recommend migrating to the @astrojs/rssintegration instead.\n\nSee Also:\n\nRSS Guide"
  },
  {
    "title": "Invalid value returned by getStaticPaths. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-get-static-paths-return/",
    "html": "Invalid value returned by getStaticPaths.\n\nInvalidGetStaticPathsReturn: Invalid type returned by getStaticPaths. Expected an array, got RETURN_TYPE\n\nWhat went wrong?\nSection titled What went wrong?\n\ngetStaticPaths‚Äôs return value must be an array of objects.\n\npages/blog/[id].astro\nexport async function getStaticPaths() {\n  return [ // <-- Array\n    { params: { slug: \"blog\" } },\n    { params: { slug: \"about\" } }\n  ];\n}\n\nSee Also:\n\ngetStaticPaths()\nparams"
  },
  {
    "title": "Invalid value returned by a getStaticPaths path. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/invalid-get-static-path-param/",
    "html": "Invalid value returned by a getStaticPaths path.\n\nInvalidGetStaticPathParam: Invalid params given to getStaticPaths path. Expected an object, got PARAM_TYPE\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe params property in getStaticPaths‚Äôs return value (an array of objects) should also be an object.\n\npages/blog/[id].astro\n---\nexport async function getStaticPaths() {\n  return [\n    { params: { slug: \"blog\" } },\n    { params: { slug: \"about\" } }\n  ];\n}\n---\n\nSee Also:\n\ngetStaticPaths()\nparams"
  },
  {
    "title": "Missing hint on client:only directive. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/no-client-only-hint/",
    "html": "Missing hint on client:only directive.\n\nNoClientOnlyHint: Unable to render COMPONENT_NAME. When using the client:only hydration strategy, Astro needs a hint to use the correct renderer.\n\nWhat went wrong?\nSection titled What went wrong?\n\nclient:only components are not run on the server, as such Astro does not know (and cannot guess) which renderer to use and require a hint. Like such:\n\n  <SomeReactComponent client:only=\"react\" />\n\nSee Also:\n\nclient:only"
  },
  {
    "title": "No client entrypoint specified in renderer. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/no-client-entrypoint/",
    "html": "No client entrypoint specified in renderer.\n\nNoClientEntrypoint: COMPONENT_NAME component has a client:CLIENT_DIRECTIVE directive, but no client entrypoint was provided by RENDERER_NAME.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro tried to hydrate a component on the client, but the renderer used does not provide a client entrypoint to use to hydrate.\n\nSee Also:\n\naddRenderer option\nHydrating framework components"
  },
  {
    "title": "Missing value for client:media directive. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/missing-media-query-directive/",
    "html": "Missing value for client:media directive.\n\nMissingMediaQueryDirective: Media query not provided for client:media directive. A media query similar to client:media=\"(max-width: 600px)\" must be provided\n\nWhat went wrong?\nSection titled What went wrong?\n\nA media query parameter is required when using the client:media directive.\n\n<Counter client:media=\"(max-width: 640px)\" />\n\nSee Also:\n\nclient:media"
  },
  {
    "title": "Invalid type returned by Astro page. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/only-response-can-be-returned/",
    "html": "Invalid type returned by Astro page.\n\nRoute returned a RETURNED_VALUE. Only a Response can be returned from Astro files.\n\nWhat went wrong?\nSection titled What went wrong?\n\nOnly instances of Response can be returned inside Astro files.\n\npages/login.astro\n---\nreturn new Response(null, {\n status: 404,\n statusText: 'Not found'\n});\n\n\n// Alternatively, for redirects, Astro.redirect also returns an instance of Response\nreturn Astro.redirect('/login');\n---\n\nSee Also:\n\nResponse"
  },
  {
    "title": "No matching renderer found. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/no-matching-renderer/",
    "html": "No matching renderer found.\n\nUnable to render COMPONENT_NAME. There are RENDERER_COUNT renderer(s) configured in your astro.config.mjs file, but none were able to server-side render COMPONENT_NAME.\n\nWhat went wrong?\nSection titled What went wrong?\n\nNone of the installed integrations were able to render the component you imported. Make sure to install the appropriate integration for the type of component you are trying to include in your page.\n\nFor JSX / TSX files, @astrojs/react, @astrojs/preact or @astrojs/solid-js can be used. For Vue and Svelte files, the @astrojs/vue and @astrojs/svelte integrations can be used respectively\n\nSee Also:\n\nFrameworks components\nUI Frameworks"
  },
  {
    "title": "No static path found for requested path. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/no-matching-static-path-found/",
    "html": "No static path found for requested path.\n\nNoMatchingStaticPathFound: A getStaticPaths() route pattern was matched, but no matching static path was found for requested path PATH_NAME.\n\nWhat went wrong?\nSection titled What went wrong?\n\nA dynamic route was matched, but no corresponding path was found for the requested parameters. This is often caused by a typo in either the generated or the requested path.\n\nSee Also:\n\ngetStaticPaths()"
  },
  {
    "title": "Astro.clientAddress is not available in static mode. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/static-client-address-not-available/",
    "html": "Astro.clientAddress is not available in static mode.\n\nStaticClientAddressNotAvailable: Astro.clientAddress is only available when using output: 'server' or output: 'hybrid'. Update your Astro config if you need SSR features.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe Astro.clientAddress property is only available when Server-side rendering is enabled.\n\nTo get the user‚Äôs IP address in static mode, different APIs such as Ipify can be used in a Client-side script or it may be possible to get the user‚Äôs IP using a serverless function hosted on your hosting provider.\n\nSee Also:\n\nEnabling SSR in Your Project\nAstro.clientAddress"
  },
  {
    "title": "Astro.clientAddress is not available in current adapter. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/client-address-not-available/",
    "html": "Astro.clientAddress is not available in current adapter.\n\nClientAddressNotAvailable: Astro.clientAddress is not available in the ADAPTER_NAME adapter. File an issue with the adapter to add support.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe adapter you‚Äôre using unfortunately does not support Astro.clientAddress.\n\nSee Also:\n\nOfficial integrations\nAstro.clientAddress"
  },
  {
    "title": "Astro.redirect is not available in static mode. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/static-redirect-not-available/",
    "html": "Astro.redirect is not available in static mode.\n\n DEPRECATED\n\nDeprecated since version 2.6.\n\nStaticRedirectNotAvailable: Redirects are only available when using output: 'server' or output: 'hybrid'. Update your Astro config if you need SSR features.\n\nWhat went wrong?\nSection titled What went wrong?\n\nThe Astro.redirect function is only available when Server-side rendering is enabled.\n\nTo redirect on a static website, the meta refresh attribute can be used. Certain hosts also provide config-based redirects (ex: Netlify redirects).\n\nSee Also:\n\nEnabling SSR in Your Project\nAstro.redirect"
  },
  {
    "title": "Unknown compiler error. ‚Ä¢ Astro",
    "url": "https://docs.astro.build/en/reference/errors/unknown-compiler-error/",
    "html": "Unknown compiler error.\n\nUnknown compiler error.\n\nWhat went wrong?\nSection titled What went wrong?\n\nAstro encountered an unknown error while compiling your files. In most cases, this is not your fault, but an issue in our compiler.\n\nIf there isn‚Äôt one already, please create an issue.\n\nSee Also:\n\nwithastro/compiler issues list"
  },
  {
    "title": "Add Last Modified Time üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/modified-time/",
    "html": "Add Last Modified Time\n\nLearn how to build a remark plugin that adds the last modified time to the frontmatter of your Markdown and MDX files. Use this property to display the modified time in your pages.\n\nRecipe\nSection titled Recipe\n\nInstall Helper Packages\n\nInstall Day.js to modify and format times:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install dayjs\n\nCreate a Remark Plugin\n\nThis plugin uses execSync to run a Git command that returns the timestamp of the latest commit in ISO 8601 format. The timestamp is then added to the frontmatter of the file.\n\nremark-modified-time.mjs\nimport { execSync } from \"child_process\";\n\n\nexport function remarkModifiedTime() {\n  return function (tree, file) {\n    const filepath = file.history[0];\n    const result = execSync(`git log -1 --pretty=\"format:%cI\" ${filepath}`);\n    file.data.astro.frontmatter.lastModified = result.toString();\n  };\n}\nUsing the file system instead of Git\n\nAdd the plugin to your config\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport { remarkModifiedTime } from './remark-modified-time.mjs';\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [remarkModifiedTime],\n  },\n});\n\nNow all Markdown documents will have a lastModified property in their frontmatter.\n\nDisplay Last Modified Time\n\nIf your content is stored in a content collection, access the remarkPluginFrontmatter from the entry.render() function. Then render lastModified in your template wherever you would like it to appear.\n\nsrc/pages/posts/[slug].astro\n---\nimport { CollectionEntry, getCollection } from 'astro:content';\nimport dayjs from \"dayjs\";\nimport utc from \"dayjs/plugin/utc\";\n\n\ndayjs.extend(utc);\n\n\nexport async function getStaticPaths() {\n  const blog = await getCollection('blog');\n  return blog.map(entry => ({\n    params: { slug: entry.slug },\n    props: { entry },\n  }));\n}\n\n\nconst { entry } = Astro.props;\nconst { Content, remarkPluginFrontmatter } = await entry.render();\n\n\nconst lastModified = dayjs(remarkPluginFrontmatter.lastModified)\n  .utc()\n  .format(\"HH:mm:ss DD MMMM YYYY UTC\");\n---\n\n\n<html>\n  <head>...</head>\n  <body>\n    ...\n    <p>Last Modified: {lastModified}</p>\n    ...\n  </body>\n</html>\n\nIf you‚Äôre using a Markdown layout, use the lastModified frontmatter property from Astro.props in your layout template.\n\nsrc/layouts/BlogLayout.astro\n---\nimport dayjs from \"dayjs\";\nimport utc from \"dayjs/plugin/utc\";\n\n\ndayjs.extend(utc);\n\n\nconst lastModified = dayjs()\n  .utc(Astro.props.frontmatter.lastModified)\n  .format(\"HH:mm:ss DD MMMM YYYY UTC\");\n---\n\n\n<html>\n  <head>...</head>\n  <body>\n    <p>{lastModified}</p>\n    <slot />\n  </body>\n</html>\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Style Rendered Markdown with Tailwind Typography üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/tailwind-rendered-markdown/",
    "html": "Style Rendered Markdown with Tailwind Typography\n\nYou can use Tailwind‚Äôs Typography plugin to style rendered Markdown from sources such as Astro‚Äôs content collections.\n\nThis recipe will teach you how to create a reusable Astro component to style your Markdown content using Tailwind‚Äôs utility classes.\n\nPrerequisites\nSection titled Prerequisites\n\nAn Astro project that:\n\nhas Astro‚Äôs Tailwind integration installed.\nuses Astro‚Äôs content collections.\nSetting Up @tailwindcss/typography\nSection titled Setting Up @tailwindcss/typography\n\nFirst, install @tailwindcss/typography using your preferred package manager.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install -D @tailwindcss/typography\n\nThen, add the package as a plugin in your Tailwind configuration file.\n\ntailwind.config.js\n/** @type {import('tailwindcss').Config} */\n\n\nexport default {\n  theme: {\n    // ...\n  },\n  plugins: [\n   require('@tailwindcss/typography'),\n    // ...\n  ],\n}\nRecipe\nSection titled Recipe\n\nCreate a <Prose /> component to provide a wrapping <div> with a <slot /> for your rendered Markdown. Add the style class prose alongside any desired Tailwind element modifiers in the parent element.\n\nsrc/components/Prose.astro\n---\n---\n<div\n  class=\"prose dark:prose-invert\n  prose-h1:font-bold prose-h1:text-xl\n  prose-a:text-blue-600 prose-p:text-justify prose-img:rounded-xl\n  prose-headings:underline\">\n  <slot />\n</div>\n\n TIP\n\nThe @tailwindcss/typography plugin uses element modifiers to style child components of a container with the prose class.\n\nThese modifiers follow the following general syntax:\n\nprose-[element]:class-to-apply\n\nFor example, prose-h1:font-bold gives all <h1> tags the font-bold Tailwind class.\n\nQuery your collection entry on the page you want to render your Markdown. Pass the <Content /> component from await entry.render() to <Prose /> as a child to wrap your Markdown content in Tailwind styles.\n\nsrc/pages/index.astro\n---\nimport Prose from \"../components/Prose.astro\";\nimport Layout from \"../layouts/Layout.astro\";\nimport { getEntry } from 'astro:content';\n\n\nconst entry = await getEntry('collection', 'entry');\nconst { Content } = await entry.render();\n---\n<Layout>\n  <Prose>\n    <Content />\n  </Prose>\n</Layout>\nResources\nSection titled Resources\nTailwind Typography Documentation\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Add i18n features üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/i18n/",
    "html": "Add i18n features\n\nAstro doesn‚Äôt have built-in internationalization (i18n) support, but you can build your own i18n solution. In this recipe, you‚Äôll learn how to use content collections and dynamic routing to serve content for different languages.\n\nThis example serves each language at its own subpath, e.g. example.com/en/blog for English and example.com/fr/blog for French.\n\nIf you prefer the default language to not be visible in the URL unlike other languages, there are instructions to hide the default language below.\n\nRecipe\nSection titled Recipe\nSet up pages for each language\nSection titled Set up pages for each language\n\nCreate a directory for each language you want to support. For example, en/ and fr/ if you are supporting English and French:\n\nDirectory\nsrc/\nDirectory\npages/\nDirectory\nen/\nabout.astro\nindex.astro\nDirectory\nfr/\nabout.astro\nindex.astro\nindex.astro\n\nSet up src/pages/index.astro to redirect to your default language.\n\nStatic\nSSR\nsrc/pages/index.astro\n---\n---\n<meta http-equiv=\"refresh\" content=\"0;url=/en/\" />\n\nThis approach uses a meta refresh and will work however you deploy your site. Some static hosts also let you configure server redirects with a custom configuration file. See your deploy platform‚Äôs documentation for more details.\n\nUse collections for translated content\nSection titled Use collections for translated content\n\nCreate a folder in src/content/ for each type of content you want to include and add subdirectories for each supported language. For example, to support English and French blog posts:\n\nDirectory\nsrc/\nDirectory\ncontent/\nDirectory\nblog/\nDirectory\nen/\nBlog posts in English\npost-1.md\npost-2.md\nDirectory\nfr/\nBlog posts in French\npost-1.md\npost-2.md\n\nCreate a src/content/config.ts file and export a collection for each type of content.\n\nsrc/content/config.ts\nimport { defineCollection, z } from 'astro:content';\n\n\nconst blogCollection = defineCollection({\n  schema: z.object({\n    title: z.string(),\n    author: z.string(),\n    date: z.date()\n  })\n});\n\n\nexport const collections = {\n  'blog': blogCollection\n};\n\nüìö Read more about Content Collections.\n\nUse dynamic routes to fetch and render content based on a lang and a slug parameter.\n\nStatic\nSSR\n\nIn static rendering mode, use getStaticPaths to map each content entry to a page:\n\nsrc/pages/[lang]/blog/[...slug].astro\n---\nimport { getCollection } from 'astro:content'\n\n\nexport async function getStaticPaths() {\n  const pages = await getCollection('blog')\n\n\n  const paths = pages.map(page => {\n    const [lang, ...slug] = page.slug.split('/');\n    return { params: { lang, slug: slug.join('/') || undefined }, props: page }\n  })\n\n\n  return paths;\n}\n\n\nconst { lang, slug } = Astro.params;\nconst page = Astro.props;\nconst formattedDate = page.data.date.toLocaleString(lang);\n\n\nconst { Content } = await page.render();\n---\n<h1>{page.data.title}</h1>\n<p>by {page.data.author} ‚Ä¢ {formattedDate}</p>\n<Content/>\n\nüìö Read more about dynamic routing.\n\n DATE FORMATTING\n\nThe example above uses the built-in toLocaleString() date-formatting method to create a human-readable string from the frontmatter date. This ensures the date and time are formatted to match the user‚Äôs language.\n\nTranslate UI strings\nSection titled Translate UI strings\n\nCreate dictionaries of terms to translate the labels for UI elements around your site. This allows your visitors to experience your site fully in their language.\n\nCreate a src/i18n/ui.ts file to store your translation strings:\n\nsrc/i18n/ui.ts\nexport const languages = {\n  en: 'English',\n  fr: 'Fran√ßais',\n};\n\n\nexport const defaultLang = 'en';\n\n\nexport const ui = {\n  en: {\n    'nav.home': 'Home',\n    'nav.about': 'About',\n    'nav.twitter': 'Twitter',\n  },\n  fr: {\n    'nav.home': 'Accueil',\n    'nav.about': '√Ä propos',\n  },\n} as const;\n\nCreate two helper functions: one to detect the page language based on the current URL, and one to get translations strings for different parts of the UI in src/i18n/utils.ts:\n\nsrc/i18n/utils.ts\nimport { ui, defaultLang } from './ui';\n\n\nexport function getLangFromUrl(url: URL) {\n  const [, lang] = url.pathname.split('/');\n  if (lang in ui) return lang as keyof typeof ui;\n  return defaultLang;\n}\n\n\nexport function useTranslations(lang: keyof typeof ui) {\n  return function t(key: keyof typeof ui[typeof defaultLang]) {\n    return ui[lang][key] || ui[defaultLang][key];\n  }\n}\n\n DID YOU NOTICE?\n\nIn step 1, the nav.twitter string was not translated to French. You may not want every term translated, such as proper names or common industry terms. The useTranslations helper will return the default language‚Äôs value if a key is not translated. In this example, French users will also see ‚ÄúTwitter‚Äù in the nav bar.\n\nImport the helpers where needed and use them to choose the UI string that corresponds to the current language. For example, a nav component might look like:\n\nsrc/components/Nav.astro\n---\nimport { getLangFromUrl, useTranslations } from '../i18n/utils';\n\n\nconst lang = getLangFromUrl(Astro.url);\nconst t = useTranslations(lang);\n---\n<ul>\n    <li>\n        <a href={`/${lang}/home/`}>\n          {t('nav.home')}\n        </a>\n    </li>\n    <li>\n        <a href={`/${lang}/about/`}>\n          {t('nav.about')}\n        </a>\n    </li>\n    <li>\n        <a href=\"https://twitter.com/astrodotbuild\">\n          {t('nav.twitter')}\n        </a>\n    </li>\n</ul>\n\nEach page must have a lang attribute on the <html> element that matches the language on the page. In this example, a reusable layout extracts the language from the current route:\n\nsrc/layouts/Base.astro\n---\nimport { getLangFromUrl } from '../i18n/utils';\n\n\nconst lang = getLangFromUrl(Astro.url);\n---\n<html lang={lang}>\n    <head>\n        <meta charset=\"utf-8\" />\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n        <meta name=\"viewport\" content=\"width=device-width\" />\n        <title>Astro</title>\n    </head>\n    <body>\n        <slot />\n    </body>\n</html>\n\nYou can then use this base layout to ensure that pages use the correct lang attribute automatically.\n\nsrc/pages/en/about.astro\n---\nimport Base from \"../../layouts/Base.astro\"\n---\n<Base>\n    <h1>About me</h1>\n    ...\n</Base>\nLet users switch between languages\nSection titled Let users switch between languages\n\nCreate links to the different languages you support so users can choose the language they want to read your site in.\n\nCreate a component to show a link for each language:\n\nsrc/components/LanguagePicker.astro\n---\nimport { languages } from '../i18n/ui';\n---\n<ul>\n  {Object.entries(languages).map(([lang, label]) => (\n    <li>\n      <a href={`/${lang}/`}>{label}</a>\n    </li>\n  ))}\n</ul>\n\nAdd <LanguagePicker /> to your site so it is shown on every page. The example below adds it to the site footer in a base layout:\n\nsrc/layouts/Base.astro\n---\nimport LanguagePicker from '../components/LanguagePicker.astro';\nimport { getLangFromUrl } from '../i18n/utils';\n\n\nconst lang = getLangFromUrl(Astro.url);\n---\n<html lang={lang}>\n    <head>\n        <meta charset=\"utf-8\" />\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n        <meta name=\"viewport\" content=\"width=device-width\" />\n        <title>Astro</title>\n    </head>\n    <body>\n        <slot />\n        <footer>\n          <LanguagePicker />\n        </footer>\n    </body>\n</html>\nHide default language in the URL\nSection titled Hide default language in the URL\n\nCreate a directory for each language except the default language. For example, store your default language pages directly in pages/, and your translated pages in fr/:\n\nDirectory\nsrc/\nDirectory\npages/\nabout.astro\nindex.astro\nDirectory\nfr/\nabout.astro\nindex.astro\n\nAdd another line to the src/i18n/ui.ts file to toggle the feature:\n\nsrc/i18n/ui.ts\nexport const showDefaultLang = false;\n\nAdd a helper function to src/i18n/utils.ts, to translate paths based on the current language:\n\nsrc/i18n/utils.ts\n import { ui, defaultLang, showDefaultLang } from './ui';\n\n\n export function useTranslatedPath(lang: keyof typeof ui) {\n   return function translatePath(path: string, l: string = lang) {\n     return !showDefaultLang && l === defaultLang ? path : `/${l}${path}`\n   }\n }\n\nImport the helper where needed. For example, a nav component might look like:\n\nsrc/components/Nav.astro\n---\nimport { getLangFromUrl, useTranslations, useTranslatedPath } from '../i18n/utils';\n\n\nconst lang = getLangFromUrl(Astro.url);\nconst t = useTranslations(lang);\nconst translatePath = useTranslatedPath(lang);\n---\n<ul>\n    <li>\n        <a href={translatePath('/home/')}>\n          {t('nav.home')}\n        </a>\n    </li>\n    <li>\n        <a href={translatePath('/about/')}>\n          {t('nav.about')}\n        </a>\n    </li>\n    <li>\n        <a href=\"https://twitter.com/astrodotbuild\">\n          {t('nav.twitter')}\n        </a>\n    </li>\n</ul>\n\nThe helper function can also be used to translate paths for a specific language. For example, when users switch between languages:\n\nsrc/components/LanguagePicker.astro\n---\nimport { languages } from '../i18n/ui';\n---\n\n\n<ul>\n  {Object.entries(languages).map(([lang, label]) => (\n    <li>\n      <a href={translatePath('/', lang)}>{label}</a>\n    </li>\n  ))}\n</ul>\nTranslate Routes\nSection titled Translate Routes\n\nTranslate the routes of your pages for each language.\n\nAdd route mappings to src/i18n/ui.ts:\n\nsrc/i18n/ui.ts\nexport const routes = {\n  de: {\n    'services': 'leistungen',\n  },\n  fr: {\n    'services': 'prestations-de-service',\n  },\n  }\n\nUpdate the useTranslatedPath helper function in src/i18n/utils.ts to add router translation logic.\n\nsrc/i18n/utils.ts\nimport { ui, defaultLang, showDefaultLang, routes } from './ui';\n\n\nexport function useTranslatedPath(lang: keyof typeof ui) {\n  return function translatePath(path: string, l: string = lang) {\n    const pathName = path.replaceAll('/', '')\n    const hasTranslation = defaultLang !== l && routes[l] !== undefined && routes[l][pathName] !== undefined\n    const translatedPath = hasTranslation ? '/' + routes[l][pathName] : path\n\n\n    return !showDefaultLang && l === defaultLang ? translatedPath : `/${l}${translatedPath}`\n  }\n}\n\nCreate a helper function to get the route, if it exists based on the current URL, in src/i18n/utils.ts:\n\nsrc/i18n/utils.ts\nimport { ui, defaultLang, showDefaultLang, routes } from './ui';\n\n\nexport function getRouteFromUrl(url: URL): string | undefined {\n  const pathname = new URL(url).pathname\n  const parts = pathname?.split('/')\n  const path = parts.pop() || parts.pop()\n\n\n  if (path === undefined) {\n    return undefined\n  }\n\n\n  const currentLang = getLangFromUrl(url);\n\n\n  if (defaultLang === currentLang) {\n    const route = Object.values(routes)[0];\n    return route[path] !== undefined ? route[path] : undefined\n  }\n\n\n  const getKeyByValue = (obj: Record<string, string>, value: string): string | undefined  => {\n      return Object.keys(obj).find((key) => obj[key] === value)\n  }\n\n\n  const reversedKey = getKeyByValue(routes[currentLang], path)\n\n\n  if (reversedKey !== undefined) {\n    return reversedKey\n  }\n\n\n  return undefined\n}\n\nThe helper function can be used to get a translated route. For example, when no translated route is defined, the user will be redirected to the home page:\n\nsrc/components/LanguagePicker.astro\n  ---\n  import { languages } from '../i18n/ui';\n  const route = getRouteFromUrl(Astro.url);\n  ---\n\n\n  <ul>\n    {Object.entries(languages).map(([lang, label]) => (\n      <li>\n        <a href={translatePath(`/${route ? route : ''}`, lang)}>{label}</a>\n      </li>\n    ))}\n  </ul>\nResources\nSection titled Resources\nChoosing a Language Tag\nRight-to-left Styling 101\nCommunity libraries\nSection titled Community libraries\nastro-i18next ‚Äî An Astro integration for i18next including some utility components.\nastro-i18n ‚Äî A TypeScript-first internationalization library for Astro.\nastro-i18n-aut ‚Äî An Astro integration for i18n that supports the defaultLocale without page generation. The integration is adapter agnostic and UI framework agnostic.\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Share State Between Astro Components üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/sharing-state/",
    "html": "Share State Between Astro Components\n\n TIP\n\nUsing framework components? See how to share state between Islands!\n\nWhen building an Astro website, you may need to share state across components. Astro recommends the use of Nano Stores for shared client storage.\n\nRecipe\nSection titled Recipe\nInstall Nano Stores:\nnpm\npnpm\nYarn\nTerminal window\nnpm install nanostores\nCreate a store. In this example, the store tracks whether a dialog is open or not:\nsrc/store.js\nimport { atom } from 'nanostores';\n\n\nexport const isOpen = atom(false);\nImport and use the store in a <script> tag in the components that will share state.\n\nThe following Button and Dialog components each use the shared isOpen state to control whether a particular <div> is hidden or displayed:\n\nsrc/components/Button.astro\n<button id=\"openDialog\">Open</button>\n\n\n<script>\n  import { isOpen } from '../store.js';\n\n\n  // Set the store to true when the button is clicked\n  function openDialog() {\n    isOpen.set(true);\n  }\n\n\n  // Add an event listener to the button\n  document.getElementById('openDialog').addEventListener('click', openDialog);\n</script>\nsrc/components/Dialog.astro\n<div id=\"dialog\" style=\"display: hidden\">Hello world!</div>\n\n\n<script>\n  import { isOpen } from '../store.js';\n\n\n  // Listen to changes in the store, and show/hide the dialog accordingly\n  isOpen.subscribe(open => {\n    if (open) {\n      document.getElementById('dialog').style.display = 'block';\n    } else {\n      document.getElementById('dialog').style.display = 'none';\n    }\n  })\n\n\n  document.getElementById('openDialog').addEventListener('click', openDialog);\n</script>\nResources\nSection titled Resources\nNano Stores on NPM\nNano Stores documentation for Vanilla JS\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Add icons to external links üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/external-links/",
    "html": "Add icons to external links\n\nUsing a rehype plugin, you can identify and modify links in your Markdown files that point to external sites. This example adds icons to the end of each external link, so that visitors will know they are leaving your site.\n\nPrerequisites\nSection titled Prerequisites\nAn Astro project using Markdown for content pages.\nRecipe\nSection titled Recipe\n\nInstall the rehype-external-links plugin.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install rehype-external-links\n\nImport the plugin into your astro.config.mjs file.\n\nPass rehypeExternalLinks to the rehypePlugins array, along with an options object that includes a content property. Set this property‚Äôs type to text if you want to add plain text to the end of the link. To add HTML to the end of the link instead, set the property type to raw.\n\n...\nimport rehypeExternalLinks from 'rehype-external-links';\n\n\nexport default defineConfig({\n  // ...\n  markdown: {\n    rehypePlugins: [\n      [\n        rehypeExternalLinks,\n        {\n          content: { type: 'text', value: ' üîó' }\n        }\n      ],\n    ]\n  },\n});\n\n NOTE\n\nThe value of the content property is not represented in the accessibility tree. As such, it‚Äôs best to make clear that the link is external in the surrounding content, rather than relying on the icon alone.\n\nResources\nSection titled Resources\nrehype-external-links\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Dynamically Import Images üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/dynamically-importing-images/",
    "html": "Dynamically Import Images\n\nLocal images must be imported into .astro files in order to display them. There will be times where you will want or need to dynamically import the image paths of your images instead of explicitly importing each individual image.\n\nIn this recipe, you will learn how to dynamically import your images using Vite‚Äôs import.meta.glob function. You will build a card component that displays the name, age, and photo of a person.\n\nRecipe\nSection titled Recipe\nCreate a new assets folder under the src directory and add your images inside that new folder.\nDirectory\nsrc/\nDirectory\nassets/\navatar-1.jpg\navatar-2.png\navatar-3.jpeg\n\n NOTE\n\nassets is a popular folder name convention for placing images but you are free to name the folder whatever you like.\n\nCreate a new Astro component for your card and import the <Image /> component.\n\nsrc/components/MyCustomCardComponent.astro\n---\n import { Image } from 'astro:assets';\n---\n\nSpecify the props that your component will receive in order to display the necessary information on each card. You can optionally define their types, if you are using TypeScript in your project.\n\nsrc/components/MyCustomCardComponent.astro\n---\n import { Image } from 'astro:assets';\n\n\n interface Props {\n    imagePath: string;\n    altText: string;\n    name: string;\n    age: number;\n }\n\n\n const { imagePath, altText, name, age } = Astro.props;\n---\n\nCreate a new images variable and use the import.meta.glob function which returns an object of all of the image paths inside the assets folder.\n\nsrc/components/MyCustomCardComponent.astro\n---\n import { Image } from 'astro:assets';\n\n\n interface Props {\n    imagePath: string;\n    altText: string;\n    name: string;\n    age: number;\n }\n\n\n const { imagePath, altText, name, age } = Astro.props;\n const images = import.meta.glob('/src/assets/*.{jpeg,jpg,png,gif}')\n---\n\nUse the props to create the markup for your card component.\n\nsrc/components/MyCustomCardComponent.astro\n---\n import { Image } from 'astro:assets';\n\n\n interface Props {\n    imagePath: string;\n    altText: string;\n    name: string;\n    age: number;\n }\n\n\n const { imagePath, altText, name, age } = Astro.props;\n // Type: Record<string, () => Promise<{default: ImageMetadata}>>\n const images = import.meta.glob('/src/assets/*.{jpeg,jpg,png,gif}')\n---\n<div class=\"card\">\n    <h2>{name}</h2>\n    <p>Age: {age}</p>\n    <Image src={} alt={altText} />\n</div>\n\nInside the src attribute, pass in the images object and use bracket notation for the image path. Then make sure to invoke the glob function.\n\nsrc/components/MyCustomCardComponent.astro\n---\n import { Image } from 'astro:assets';\n\n\n interface Props {\n    imagePath: string;\n    altText: string;\n    name: string;\n    age: number;\n }\n\n\n const { imagePath, altText, name, age } = Astro.props;\n const images = import.meta.glob('/src/assets/*.{jpeg,jpg,png,gif}')\n---\n<div class=\"card\">\n    <h2>{name}</h2>\n    <p>Age: {age}</p>\n    <Image src={images[imagePath]()} alt={altText} />\n</div>\n\n NOTE\n\nimages is an object that contains all of the image paths inside the assets folder.\n\nconst images = {\n  './assets/avatar-1.jpg': () => import('./assets/avatar-1.jpg'),\n  './assets/avatar-2.png': () => import('./assets/avatar-2.png'),\n  './assets/avatar-3.jpeg': () => import('./assets/avatar-3.jpeg')\n}\n\nThe imagePath prop is a string that contains the path to the image that you want to display. The import.meta.glob() is doing the work of finding the image path that matches the imagePath prop and handling the import for you.\n\nImport and use the card component inside an Astro page, passing in the values for the props.\n\nsrc/pages/index.astro\n---\nimport MyCustomCardComponent from '../components/MyCustomCardComponent.astro';\n---\n<MyCustomCardComponent\n    imagePath=\"/src/assets/avatar-1.jpg\"\n    altText=\"A headshot of Priya against a brick wall background.\"\n    name=\"Priya\"\n    age={25}\n/>\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Verify a Captcha üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/captcha/",
    "html": "Verify a Captcha\n\nServer endpoints can be used as REST API endpoints to run functions such as authentications, database access, and verifications without exposing sensitive data to the client.\n\nIn this recipe, an API route is used to verify Google reCAPTCHA v3 without exposing the secret to clients.\n\nPrerequisites\nSection titled Prerequisites\nA project with SSR (output: 'server') enabled\nRecipe\nSection titled Recipe\n\nCreate a POST endpoint that accepts recaptcha data, then verifies it with reCAPTCHA‚Äôs API. Here, you can safely define secret values or read environment variables.\n\nsrc/pages/recaptcha.js\nexport async function POST({ request }) {\n  const data = await request.json();\n\n\n  const recaptchaURL = 'https://www.google.com/recaptcha/api/siteverify';\n  const requestBody = {\n    secret: \"YOUR_SITE_SECRET_KEY\",   // This can be an environment variable\n    response: data.recaptcha          // The token passed in from the client\n  };\n\n\n  const response = await fetch(recaptchaURL, {\n    method: \"POST\",\n    body: JSON.stringify(requestBody)\n  });\n\n\n  const responseData = await response.json();\n\n\n  return new Response(JSON.stringify(responseData), { status: 200 });\n}\n\nAccess your endpoint using fetch from a client script:\n\nsrc/pages/index.astro\n<html>\n  <head>\n    <script src=\"https://www.google.com/recaptcha/api.js\"></script>\n  </head>\n\n\n  <body>\n    <button class=\"g-recaptcha\"\n      data-sitekey=\"PUBLIC_SITE_KEY\"\n      data-callback=\"onSubmit\"\n      data-action=\"submit\"> Click me to verify the captcha challenge! </button>\n\n\n    <script is:inline>\n      function onSubmit(token) {\n        fetch(\"/recaptcha\", {\n          method: \"POST\",\n          body: JSON.stringify({ recaptcha: token })\n        })\n        .then((response) => response.json())\n        .then((gResponse) => {\n          if (gResponse.success) {\n            // Captcha verification was a success\n          } else {\n            // Captcha verification failed\n          }\n        })\n      }\n    </script>\n  </body>\n</html>\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Build your Astro Site with Docker üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/docker/",
    "html": "Build your Astro Site with Docker\n\nDocker is a tool to build, deploy, and run applications using containers.\n\nDocker images and containers can be deployed to many different platforms, like AWS, Azure, and Google Cloud. This recipe won‚Äôt cover how to deploy your site to a specific platform but will show you how to set up Docker for your project.\n\nPrerequisites\nSection titled Prerequisites\nDocker installed on your local machine. You can find installation instructions for your operating system here.\nA Dockerfile in your project. You can learn more about Dockerfiles here and use the Dockerfiles in the following section as a starting point.\nCreating a Dockerfile\nSection titled Creating a Dockerfile\n\nCreate a file called Dockerfile in your project‚Äôs root directory. This file contains the instructions to build your site, which will differ depending on your needs. This guide can‚Äôt show all possible options but will give you starting points for SSR and static mode.\n\nIf you‚Äôre using another package manager than npm, you‚Äôll need to adjust the commands accordingly.\n\nSSR\nSection titled SSR\n\nThis Dockerfile will build your site and serve it using Node.js on port 4321 and therefore requires the Node adapter installed in your Astro project.\n\nDockerfile\nFROM node:lts AS runtime\nWORKDIR /app\n\n\nCOPY . .\n\n\nRUN npm install\nRUN npm run build\n\n\nENV HOST=0.0.0.0\nENV PORT=4321\nEXPOSE 4321\nCMD node ./dist/server/entry.mjs\n\n KEEP THIS IN MIND\n\nThese are just examples of Dockerfiles. You can customize them to your needs. For example, you could use another image, like node:lts-alpine:\n\nDockerfile\nFROM node:lts as runtime\nFROM node:lts-alpine as runtime\nAdding a .dockerignore\nSection titled Adding a .dockerignore\n\nAdding a .dockerignore file to your project is best practice. This file describes which files or folders should be ignored in the Docker COPY or ADD commands, very similar to how .gitignore works. This speeds up the build process and reduces the size of the final image.\n\n.dockerignore\n.DS_Store\nnode_modules\ndist\n\nThis file should go in the same directory as the Dockerfile itself. Read the .dockerignore documentation for extra info\n\nStatic\nSection titled Static\nApache (httpd)\nSection titled Apache (httpd)\n\nThe following Dockerfile will build your site and serve it using Apache htppd on port 80 with the default configuration.\n\nDockerfile\nFROM node:lts AS build\nWORKDIR /app\nCOPY . .\nRUN npm i\nRUN npm run build\n\n\nFROM httpd:2.4 AS runtime\nCOPY --from=build /app/dist /usr/local/apache2/htdocs/\nEXPOSE 80\n\n RECOMMENDATION\n\nUse this approach for simple websites that don‚Äôt need any special configuration. For more complex websites, it is recommended to use a custom configuration, either in Apache or NGINX.\n\nNGINX\nSection titled NGINX\nDockerfile\nFROM node:lts AS build\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\n\nFROM nginx:alpine AS runtime\nCOPY ./nginx/nginx.conf /etc/nginx/nginx.conf\nCOPY --from=build /app/dist /usr/share/nginx/html\nEXPOSE 8080\n\nIn order to build the Dockerfile above, you‚Äôll also need to create a configuration file for NGINX. Create a folder called nginx in your project‚Äôs root directory and create a file called nginx.conf inside.\n\nnginx.conf\nworker_processes  1;\n\n\nevents {\n  worker_connections  1024;\n}\n\n\nhttp {\n  server {\n    listen 8080;\n    server_name   _;\n\n\n    root   /usr/share/nginx/html;\n    index  index.html index.htm;\n    include /etc/nginx/mime.types;\n\n\n    gzip on;\n    gzip_min_length 1000;\n    gzip_proxied expired no-cache no-store private auth;\n    gzip_types text/plain text/css application/json application/javascript application/x-javascript text/xml application/xml application/xml+rss text/javascript;\n\n\n    error_page 404 /404.html;\n    location = /404.html {\n            root /usr/share/nginx/html;\n            internal;\n    }\n\n\n    location / {\n            try_files $uri $uri/index.html =404;\n    }\n  }\n}\nMulti-stage build (using SSR)\nSection titled Multi-stage build (using SSR)\n\nHere‚Äôs an example of a more advanced Dockerfile that, thanks to Docker‚Äôs multi-stage builds, optimizes the build process for your site by not reinstalling the npm dependencies when only the source code changes. This can reduce the build time even by minutes, depending on the size of your dependencies.\n\nDockerfile\nFROM node:lts AS base\nWORKDIR /app\n\n\n# By copying only the package.json and package-lock.json here, we ensure that the following `-deps` steps are independent of the source code.\n# Therefore, the `-deps` steps will be skipped if only the source code changes.\nCOPY package.json package-lock.json ./\n\n\nFROM base AS prod-deps\nRUN npm install --production\n\n\nFROM base AS build-deps\nRUN npm install --production=false\n\n\nFROM build-deps AS build\nCOPY . .\nRUN npm run build\n\n\nFROM base AS runtime\nCOPY --from=prod-deps /app/node_modules ./node_modules\nCOPY --from=build /app/dist ./dist\n\n\nENV HOST=0.0.0.0\nENV PORT=4321\nEXPOSE 4321\nCMD node ./dist/server/entry.mjs\nRecipe\nSection titled Recipe\nBuild your container by running the following command in your project‚Äôs root directory. Use any name for <your-astro-image-name>:\nTerminal window\ndocker build -t <your-astro-image-name> .\n\nThis will output an image, which you can run locally or deploy to a platform of your choice.\n\nTo run your image as a local container, use the following command.\n\nReplace <local-port> with an open port on your machine. Replace <container-port> with the port exposed by your Docker container (4321, 80, or 8080 in the above examples.)\n\nTerminal window\ndocker run -p <local-port>:<container-port> <your-astro-image-name>\n\nYou should be able to access your site at http://localhost:<local-port>.\n\nNow that your website is successfully built and packaged in a container, you can deploy it to a cloud provider. See the Google Cloud deployment guide for one example, and the Deploy your app page in the Docker docs.\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Use Bun with Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/bun/",
    "html": "Use Bun with Astro\n\nBun is an all-in-one JavaScript runtime & toolkit. See Bun‚Äôs documentation for more information.\n\n CAUTION\n\nBun recently made their first stable release. However, using Bun with Astro may reveal rough edges. Some integrations may not work as expected. Consult Bun‚Äôs official documentation for working with Astro for details.\n\nIf you have any problems using Bun, please open an Issue on GitHub with Bun directly.\n\nPrerequisites\nSection titled Prerequisites\nBun installed locally on your machine. See the installation instructions in Bun‚Äôs official documentation.\nCreate a new Astro project with Bun\nSection titled Create a new Astro project with Bun\n\nCreate a new Astro project with Bun using the following create-astro command:\n\nTerminal window\nbunx create-astro@latest my-astro-project-using-bun\n\n TIP\n\nYou may also create a new Astro project from any existing Astro GitHub repository using the --template flag:\n\nTerminal window\nbunx create-astro@latest my-astro-project-using-bun --template eliancodes/brutal\nInstall dependencies\nSection titled Install dependencies\n\nIf you‚Äôre starting a new project using bunx create-astro, the CLI will automatically use Bun to install dependencies and you can skip this step.\n\nOtherwise, you‚Äôll need to install your dependencies with Bun:\n\nTerminal window\nbun install\nAdd Types\nSection titled Add Types\n\nBun publishes the bun-types package, containing the runtime types for Bun.\n\nInstall bun-types using the following command:\n\nTerminal window\nbun add -d bun-types\n\nAdd the package to your types in tsconfig.json\n\ntsconfig.json\n  \"compilerOptions\": {\n    \"types\": [\"bun-types\"]\n  }\nUsing Astro integrations\nSection titled Using Astro integrations\n\nYou can also use any of the official Astro integrations with the astro add command:\n\nTerminal window\nbunx astro add react\nRun Astro with Bun\nSection titled Run Astro with Bun\n\n NOTE\n\nUse the --bun CLI flag before every astro command to use Bun‚Äôs own runtime in place of Node.\n\nRun the development server\nSection titled Run the development server\n\nTo run the development server using Bun as the runtime, use the following command:\n\nTerminal window\nbunx --bun astro dev\nBuilding your site with Bun\nSection titled Building your site with Bun\n\nTo build your site using Bun as the runtime, use the following command:\n\nTerminal window\nbunx --bun astro build\n\nAstro will output your site to the dist/ directory. Then, you can serve your site using the preview command:\n\nTerminal window\nbunx --bun astro preview\nAdd SSR with Bun using @astrojs/node\nSection titled Add SSR with Bun using @astrojs/node\n\nBun features Node.js API compatibility. Using the @astrojs/node adapter you can add server-side rendering to your Astro project using Bun‚Äôs runtime as a replacement for Node.\n\nRun the following command to add the Node.js adapter to your Astro project:\n\nTerminal window\nbunx astro add node\n\nBuild your site again, using the same build command as above:\n\nTerminal window\nbunx --bun astro build\n\nFinally, use the following command to run your built site.\n\nTerminal window\nbun ./dist/server/entry.mjs\nOfficial Resources\nSection titled Official Resources\nBuild an app with Astro and Bun\nCommunity Resources\nSection titled Community Resources\n\nUsing Bun with Astro? Add your blog post or video to this page!\n\nBuilding a Cloudflare Pages site with Bun - blog post\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Call endpoints from the server üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/call-endpoints/",
    "html": "Call endpoints from the server\n\nEndpoints can be used to serve many kinds of data. This recipe calls a server endpoint from a page‚Äôs component script to display a greeting, without requiring an additional fetch request.\n\nPrerequisites\nSection titled Prerequisites\nA project with SSR (output: ‚Äòserver‚Äô) enabled\nRecipe\nSection titled Recipe\n\nCreate an endpoint in a new file src/pages/api/hello.ts that returns some data:\n\nsrc/pages/api/hello.ts\nimport type { APIRoute } from 'astro'\n\n\nexport const GET: APIRoute = () => {\n  return new Response(\n    JSON.stringify({\n      greeting: 'Hello',\n    }),\n  )\n}\n\nOn any Astro page, import the GET() method from the endpoint. Call it with the Astro global to provide the request context, and use the response on the page:\n\nsrc/pages/index.astro\n---\nimport { GET } from './api/hello.ts'\n\n\nlet response = await GET(Astro)\nconst data = await response.json()\n---\n\n\n<h1>{data.greeting} world!</h1>\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Build HTML Forms in Astro Pages üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/build-forms/",
    "html": "Build HTML Forms in Astro Pages\n\nIn SSR mode, Astro pages can both display and handle forms. In this recipe, you‚Äôll use a standard HTML form to submit data to the server. Your frontmatter script will handle the data on the server, sending no JavaScript to the client.\n\nPrerequisites\nSection titled Prerequisites\nA project with SSR (output: 'server') enabled\nRecipe\nSection titled Recipe\n\nCreate or identify a .astro page which will contain your form and your handling code. For example, you could add a registration page:\n\nsrc/pages/register.astro\n---\n---\n<h1>Register</h1>\n\nAdd a <form> tag with some inputs to the page. Each input should have a name attribute that describes the value of that input.\n\nBe sure to include a <button> or <input type=\"submit\"> element to submit the form.\n\nsrc/pages/register.astro\n---\n---\n<h1>Register</h1>\n<form>\n  <label>\n    Username:\n    <input type=\"text\" name=\"username\" />\n  </label>\n  <label>\n    Email:\n    <input type=\"email\" name=\"email\" />\n  </label>\n  <label>\n    Password:\n    <input type=\"password\" name=\"password\" />\n  </label>\n  <button>Submit</button>\n</form>\n\nUse validation attributes to provide basic client-side validation that works even if JavaScript is disabled.\n\nIn this example,\n\nrequired prevents form submission until the field is filled.\nminlength sets a minimum required length for the input text.\ntype=\"email\" also introduces validation that will only accept a valid email format.\nsrc/pages/register.astro\n---\n---\n<h1>Register</h1>\n<form>\n  <label>\n    Username:\n    <input type=\"text\" name=\"username\" required />\n  </label>\n  <label>\n    Email:\n    <input type=\"email\" name=\"email\" required />\n  </label>\n  <label>\n    Password:\n    <input type=\"password\" name=\"password\" required minlength=\"6\" />\n  </label>\n  <button>Submit</button>\n</form>\n\n TIP\n\nYou can add custom validation logic that refers to multiple fields using a <script> tag and the Constraint Validation API.\n\nTo write complex validation logic more easily, you can build your form using a frontend framework and choose a form library like React Hook Form or Felte.\n\nThe form submission will cause the browser to request the page again. Change the form‚Äôs data transfer method to POST to send the form data as part of the Request body, rather than as URL parameters.\n\nsrc/pages/register.astro\n---\n---\n<h1>Register</h1>\n<form method=\"POST\">\n  <label>\n    Username:\n    <input type=\"text\" name=\"username\" required />\n  </label>\n  <label>\n    Email:\n    <input type=\"email\" name=\"email\" required />\n  </label>\n  <label>\n    Password:\n    <input type=\"password\" name=\"password\" required minlength=\"6\" />\n  </label>\n  <button>Submit</button>\n</form>\n\nCheck for the POST method in the frontmatter and access the form data using Astro.request.formData(). Wrap this in a try ... catch block to handle cases when the POST request wasn‚Äôt sent by a form and the formData is invalid.\n\nsrc/pages/register.astro\n---\nif (Astro.request.method === \"POST\") {\n  try {\n    const data = await Astro.request.formData();\n    const name = data.get(\"username\");\n    const email = data.get(\"email\");\n    const password = data.get(\"password\");\n    // Do something with the data\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error(error.message);\n    }\n  }\n}\n---\n<h1>Register</h1>\n<form method=\"POST\">\n  <label>\n    Username:\n    <input type=\"text\" name=\"username\" required />\n  </label>\n  <label>\n    Email:\n    <input type=\"email\" name=\"email\" required />\n  </label>\n  <label>\n    Password:\n    <input type=\"password\" name=\"password\" required minlength=\"6\" />\n  </label>\n  <button>Submit</button>\n</form>\n\nValidate the form data on the server. This should include the same validation done on the client to prevent malicious submissions to your endpoint and to support the rare legacy browser that doesn‚Äôt have form validation.\n\nIt can also include validation that can‚Äôt be done on the client. For example, this example checks if the email is already in the database.\n\nError messages can be sent back to the client by storing them in an errors object and accessing it in the template.\n\nsrc/pages/register.astro\n---\nimport { isRegistered, registerUser } from \"../../data/users\"\nimport { isValidEmail } from \"../../utils/isValidEmail\";\n\n\nconst errors = { username: \"\", email: \"\", password: \"\" };\nif (Astro.request.method === \"POST\") {\n  try {\n    const data = await Astro.request.formData();\n    const name = data.get(\"username\");\n    const email = data.get(\"email\");\n    const password = data.get(\"password\");\n    if (typeof name !== \"string\" || name.length < 1) {\n      errors.username += \"Please enter a username. \";\n    }\n    if (typeof email !== \"string\" || !isValidEmail(email)) {\n      errors.email += \"Email is not valid. \";\n    } else if (await isRegistered(email)) {\n      errors.email += \"Email is already registered. \";\n    }\n    if (typeof password !== \"string\" || password.length < 6) {\n      errors.password += \"Password must be at least 6 characters. \";\n    }\n    const hasErrors = Object.values(errors).some(msg => msg)\n    if (!hasErrors) {\n      await registerUser({name, email, password});\n      return Astro.redirect(\"/login\");\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      console.error(error.message);\n    }\n  }\n}\n---\n<h1>Register</h1>\n<form method=\"POST\">\n  <label>\n    Username:\n    <input type=\"text\" name=\"username\" />\n  </label>\n  {errors.username && <p>{errors.username}</p>}\n  <label>\n    Email:\n    <input type=\"email\" name=\"email\" required />\n  </label>\n  {errors.email && <p>{errors.email}</p>}\n  <label>\n    Password:\n    <input type=\"password\" name=\"password\" required minlength=\"6\" />\n  </label>\n  {errors.password && <p>{errors.password}</p>}\n  <button>Register</button>\n</form>\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Build a custom image component üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/build-custom-img-component/",
    "html": "Build a custom image component\n\nAstro provides two built-in components that you can use to display and optimize your images. The <Picture> component allows you to display responsive images and work with different formats and sizes. The <Image> component will optimize your images and allow you to pass in different formats and quality properties.\n\nWhen you need options that the <Picture> and <Image> components do not currently support, you can use the getImage() function to create a custom component.\n\nIn this recipe, you will use the getImage() function to create your own custom image component that displays different source images based on media queries.\n\nRecipe\nSection titled Recipe\n\nCreate a new Astro component and import the getImage() function\n\nsrc/components/MyCustomImageComponent.astro\n---\n import { getImage } from \"astro:assets\";\n---\n\nCreate a new component for your custom image. MyCustomComponent.astro will receive three props from Astro.props. The mobileImgUrl and desktopImgUrl props are used for creating your image at different viewport sizes. The alt prop is used for the image‚Äôs alt text. These props will be passed wherever you render your custom image components. Add the following imports and define the props that you will use in your component. You can also use TypeScript to type the props.\n\nsrc/components/MyCustomImageComponent.astro\n---\nimport type { ImageMetadata } from \"astro\";\nimport { getImage } from \"astro:assets\";\n\n\ninterface Props {\n    mobileImgUrl: string | ImageMetadata;\n    desktopImgUrl: string | ImageMetadata;\n    alt: string;\n}\n\n\nconst { mobileImgUrl, desktopImgUrl, alt } = Astro.props;\n---\n\nDefine each of your responsive images by calling the getImage() function with your desired properties.\n\nsrc/components/MyCustomImageComponent.astro\n---\nimport type { ImageMetadata } from \"astro\";\nimport { getImage } from \"astro:assets\";\n\n\ninterface Props {\n    mobileImgUrl: string | ImageMetadata;\n    desktopImgUrl: string | ImageMetadata;\n    alt: string;\n}\n\n\nconst { mobileImgUrl, desktopImgUrl, alt } = Astro.props;\n\n\nconst mobileImg = await getImage({\n    src: mobileImgUrl,\n    format: \"webp\",\n    width: 200,\n    height: 200,\n});\n\n\nconst desktopImg = await getImage({\n    src: desktopImgUrl,\n    format: \"webp\",\n    width: 800,\n    height: 200,\n});\n---\n\nCreate a <picture> element that generates a srcset with your different images based on your desired media queries.\n\nsrc/components/MyCustomImageComponent.astro\n---\nimport type { ImageMetadata } from \"astro\";\nimport { getImage } from \"astro:assets\";\n\n\ninterface Props {\n    mobileImgUrl: string | ImageMetadata;\n    desktopImgUrl: string | ImageMetadata;\n    alt: string;\n}\n\n\nconst { mobileImgUrl, desktopImgUrl, alt } = Astro.props;\n\n\nconst mobileImg = await getImage({\n    src: mobileImgUrl,\n    format: \"webp\",\n    width: 200,\n    height: 200,\n});\n\n\nconst desktopImg = await getImage({\n    src: desktopImgUrl,\n    format: \"webp\",\n    width: 800,\n    height: 200,\n});\n---\n\n\n<picture>\n    <source media=\"(max-width: 799px)\" srcset={mobileImg.src} />\n    <source media=\"(min-width: 800px)\" srcset={desktopImg.src} />\n    <img src={desktopImg.src} alt={alt} />\n</picture>\n\nImport and use <MyCustomImageComponent /> in any .astro file. Be sure to pass the necessary props for generating two different images at the different viewport sizes:\n\nsrc/pages/index.astro\n---\nimport MyCustomImageComponent from \"../components/MyCustomImageComponent.astro\";\nimport mobileImage from \"../images/mobile-profile-image.jpg\";\nimport desktopImage from \"../images/desktop-profile-image.jpg\";\n---\n\n\n<MyCustomImageComponent\n    mobileImgUrl={mobileImage}\n    desktopImgUrl={desktopImage}\n    alt=\"user profile picture\"\n/>\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Build Forms With API Routes üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/build-forms-api/",
    "html": "Build Forms With API Routes\n\nAn HTML form causes the browser to refresh the page or navigate to a new one. To send form data to an API endpoint instead, you must intercept the form submission using JavaScript.\n\nThis recipe shows you how to send form data to an API endpoint and handle that data.\n\nPrerequisites\nSection titled Prerequisites\nA project with SSR (output: 'server') enabled\nA UI Framework integration installed\nRecipe\nSection titled Recipe\n\nCreate a form component using your UI framework. Each input should have a name attribute that describes the value of that input.\n\nBe sure to include a <button> or <input type=\"submit\"> element to submit the form.\n\nPreact\nReact\nSolid\nSvelte\nVue\nsrc/components/FeedbackForm.tsx\nexport default function Form() {\n  return (\n    <form>\n      <label>\n        Name\n        <input type=\"text\" id=\"name\" name=\"name\" required />\n      </label>\n      <label>\n        Email\n        <input type=\"email\" id=\"email\" name=\"email\" required />\n      </label>\n      <label>\n        Message\n        <textarea id=\"message\" name=\"message\" required />\n      </label>\n      <button>Send</button>\n    </form>\n  );\n}\n\nCreate the POST API endpoint that will receive the form data. Use request.formData() to process it. Be sure to validate the form values before you use them.\n\nThis example sends a JSON object with a message back to the client.\n\nsrc/pages/api/feedback.ts\nimport type { APIRoute } from \"astro\";\n\n\nexport const POST: APIRoute = async ({ request }) => {\n  const data = await request.formData();\n  const name = data.get(\"name\");\n  const email = data.get(\"email\");\n  const message = data.get(\"message\");\n  // Validate the data - you'll probably want to do more than this\n  if (!name || !email || !message) {\n    return new Response(\n      JSON.stringify({\n        message: \"Missing required fields\",\n      }),\n      { status: 400 }\n    );\n  }\n  // Do something with the data, then return a success response\n  return new Response(\n    JSON.stringify({\n      message: \"Success!\"\n    }),\n    { status: 200 }\n  );\n};\n\nCreate a function that accepts a submit event, then pass it as a submit event handler to your form. In the function, call preventDefault on the event to override the browser‚Äôs default submission process.\n\nThen, create a FormData object and send it to your endpoint using fetch.\n\nPreact\nReact\nSolid\nSvelte\nVue\nsrc/components/FeedbackForm.tsx\nimport { useState } from \"preact/hooks\";\n\n\nexport default function Form() {\n  const [responseMessage, setResponseMessage] = useState(\"\");\n\n\n  async function submit(e: SubmitEvent) {\n    e.preventDefault();\n    const formData = new FormData(e.target as HTMLFormElement);\n    const response = await fetch(\"/api/feedback\", {\n      method: \"POST\",\n      body: formData,\n    });\n    const data = await response.json();\n    if (data.message) {\n      setResponseMessage(data.message);\n    }\n  }\n\n\n  return (\n    <form onSubmit={submit}>\n      <label>\n        Name\n        <input type=\"text\" id=\"name\" name=\"name\" required />\n      </label>\n      <label>\n        Email\n        <input type=\"email\" id=\"email\" name=\"email\" required />\n      </label>\n      <label>\n        Message\n        <textarea id=\"message\" name=\"message\" required />\n      </label>\n      <button>Send</button>\n      {responseMessage && <p>{responseMessage}</p>}\n    </form>\n  );\n}\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Installing a Vite or Rollup plugin üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/add-yaml-support/",
    "html": "Installing a Vite or Rollup plugin\n\nAstro builds on top of Vite, and supports both Vite and Rollup plugins. This recipe uses a Rollup plugin to add the ability to import a YAML (.yml) file in Astro.\n\nRecipe\nSection titled Recipe\nInstall @rollup/plugin-yaml:\nnpm\npnpm\nYarn\nTerminal window\nnpm install @rollup/plugin-yaml --save-dev\n\nImport the plugin in your astro.config.mjs and add it to the Vite plugins array:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport yaml from '@rollup/plugin-yaml';\n\n\nexport default defineConfig({\n  vite: {\n    plugins: [yaml()]\n  }\n});\n\nFinally, you can import YAML data using an import statement:\n\nimport yml from './data.yml';\n\n NOTE\n\nWhile you can now import YAML data in your Astro project, your editor will not provide types for the imported data. To add types, create or find an existing *.d.ts file in the src directory of your project and add the following:\n\nsrc/files.d.ts\n// Specify the file extension you want to import\ndeclare module \"*.yml\" {\n  const value: any; // Add type definitions here if desired\n  export default value;\n}\n\nThis will allow your editor to provide type hints for your YAML data.\n\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Add an RSS feed üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/rss/",
    "html": "Add an RSS feed\n\nAstro supports fast, automatic RSS feed generation for blogs and other content websites. RSS feeds provide an easy way for users to subscribe to your content.\n\nSetting up @astrojs/rss\nSection titled Setting up @astrojs/rss\n\nThe package @astrojs/rss provides helpers for generating RSS feeds using API endpoints. This unlocks both static builds and on-demand generation when using an SSR adapter.\n\nInstall @astrojs/rss using your preferred package manager:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @astrojs/rss\n\n TIP\n\nEnsure you‚Äôve configured a site in your project‚Äôs astro.config. This will be used to generate links to your RSS articles.\n\nCreate a file in src/pages/ with a name of your choice and the extension .xml.js to be used as the output URL for your feed. Some common RSS feed URL names are feed.xml or rss.xml.\n\nThe example file below src/pages/rss.xml.js will create an RSS feed at site/rss.xml.\n\nImport the rss() helper from the @astrojs/rss package into your .xml.js file and export a function that returns it using the following parameters:\n\nsrc/pages/rss.xml.js\nimport rss from '@astrojs/rss';\n\n\nexport function GET(context) {\n  return rss({\n    // `<title>` field in output xml\n    title: 'Buzz‚Äôs Blog',\n    // `<description>` field in output xml\n    description: 'A humble Astronaut‚Äôs guide to the stars',\n    // Pull in your project \"site\" from the endpoint context\n    // https://docs.astro.build/en/reference/api-reference/#contextsite\n    site: context.site,\n    // Array of `<item>`s in output xml\n    // See \"Generating items\" section for examples using content collections and glob imports\n    items: [],\n    // (optional) inject custom xml\n    customData: `<language>en-us</language>`,\n  });\n}\nGenerating items\nSection titled Generating items\n\nThe items field accepts a list of RSS feed objects, each with a required link, title, and pubDate. Three optional values may also be included description (a short excerpt), content (the full content of your post), and a customData field for including any extra data, such as other frontmatter properties from your blog posts.\n\nYou can generate this array from a content collection schema or by using glob imports for blog posts located within src/pages/.\n\nUsing content collections\nSection titled Using content collections\n\nTo create an RSS feed of pages managed in content collections, use the getCollection() function to retrieve the list of your items.\n\nsrc/pages/rss.xml.js\nimport rss from '@astrojs/rss';\nimport { getCollection } from 'astro:content';\n\n\nexport async function GET(context) {\n  const blog = await getCollection('blog');\n  return rss({\n    title: 'Buzz‚Äôs Blog',\n    description: 'A humble Astronaut‚Äôs guide to the stars',\n    site: context.site,\n    items: blog.map((post) => ({\n      title: post.data.title,\n      pubDate: post.data.pubDate,\n      description: post.data.description,\n      customData: post.data.customData,\n      // Compute RSS link from post `slug`\n      // This example assumes all posts are rendered as `/blog/[slug]` routes\n      link: `/blog/${post.slug}/`,\n    })),\n  });\n}\n\nOptional: replace your existing blog collection schema to enforce the expected RSS properties.\n\nTo ensure that every blog entry produces a valid RSS feed item, you can optionally import and apply rssSchema instead of defining each individual property of your schema.\n\nsrc/content/config.ts\nimport { defineCollection } from 'astro:content';\nimport { rssSchema } from '@astrojs/rss';\n\n\nconst blog = defineCollection({\n  schema: rssSchema,\n});\n\n\nexport const collections = { blog };\nUsing glob imports\nSection titled Using glob imports\nAdded in: @astrojs/rss@2.1.0\n\nTo create an RSS feed from documents in src/pages/, use the pagesGlobToRssItems() helper. This accepts an import.meta.glob result and outputs an array of valid RSS feed items (see more about writing glob patterns for specifying which pages to include).\n\n CAUTION\n\nThis function assumes, but does not verify, that all necessary feed properties are present in each document‚Äôs frontmatter. If you encounter errors, verify each page frontmatter manually.\n\nsrc/pages/rss.xml.js\nimport rss, { pagesGlobToRssItems } from '@astrojs/rss';\n\n\nexport async function GET(context) {\n  return rss({\n    title: 'Buzz‚Äôs Blog',\n    description: 'A humble Astronaut‚Äôs guide to the stars',\n    site: context.site,\n    items: await pagesGlobToRssItems(\n      import.meta.glob('./blog/*.{md,mdx}'),\n    ),\n  });\n}\n\n USING AN OLDER VERSION?\n\nIn versions of @astrojs/rss before v2.1.0, pass your glob result straight to items without the pagesGlobToRssItems() wrapper:\n\nitems: import.meta.glob('./blog/*.{md,mdx}'),\nIncluding full post content\nSection titled Including full post content\nAdded in: astro@1.6.14\n\nThe content key contains the full content of the post as HTML. This allows you to make your entire post content available to RSS feed readers.\n\n TIP\n\nA package like sanitize-html will make sure that your content is properly sanitized, escaped, and encoded.\n\nWhen using content collections, render the post body using a standard Markdown parser like markdown-it and sanitize the result:\n\nsrc/pages/rss.xml.js\nimport rss from '@astrojs/rss';\nimport { getCollection } from 'astro:content';\nimport sanitizeHtml from 'sanitize-html';\nimport MarkdownIt from 'markdown-it';\nconst parser = new MarkdownIt();\n\n\nexport async function GET(context) {\n  const blog = await getCollection('blog');\n  return rss({\n    title: 'Buzz‚Äôs Blog',\n    description: 'A humble Astronaut‚Äôs guide to the stars',\n    site: context.site,\n    items: blog.map((post) => ({\n      link: `/blog/${post.slug}/`,\n      // Note: this will not process components or JSX expressions in MDX files.\n      content: sanitizeHtml(parser.render(post.body)),\n      ...post.data,\n    })),\n  });\n}\n\nWhen using glob imports with Markdown, you may use the compiledContent() helper to retrieve the rendered HTML for sanitization. Note: this feature is not supported for MDX files.\n\nsrc/pages/rss.xml.js\nimport rss from '@astrojs/rss';\nimport sanitizeHtml from 'sanitize-html';\n\n\nexport function GET(context) {\n  const postImportResult = import.meta.glob('../posts/**/*.md', { eager: true });\n  const posts = Object.values(postImportResult);\n  return rss({\n    title: 'Buzz‚Äôs Blog',\n    description: 'A humble Astronaut‚Äôs guide to the stars',\n    site: context.site,\n    items: posts.map((post) => ({\n      link: post.url,\n      content: sanitizeHtml(post.compiledContent()),\n      ...post.frontmatter,\n    })),\n  });\n}\nAdding a stylesheet\nSection titled Adding a stylesheet\n\nStyle your RSS feed for a more pleasant user experience when viewing the file in your browser.\n\nUse the rss function‚Äôs stylesheet option to specify an absolute path to your stylesheet.\n\n...\nrss({\n  // ex. use your stylesheet from \"public/rss/styles.xsl\"\n  stylesheet: '/rss/styles.xsl',\n});\n\n TIP\n\nIf you‚Äôd prefer not to create your own stylesheet, you may use a premade stylesheet such as the Pretty Feed v3 default stylesheet. Download the stylesheet from GitHub and save into your project‚Äôs public/ directory.\n\nNext Steps\nSection titled Next Steps\n\nAfter visiting your feed in the browser at your-domain.com/rss.xml and confirming that you can see data for each of your posts, you can now promote your feed on your website. Adding the standard RSS icon to your site lets your readers know that they can subscribe to your posts in their own feed reader.\n\nResources\nSection titled Resources\nRSS Feeds\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Deploy your Astro Site to Space üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/space/",
    "html": "Deploy your Astro Site to Space\n\nDeta Space is a personal computer that lives in the cloud ‚Äî a ‚Äòpersonal cloud‚Äô. You can build and run apps for yourself in your own ‚ÄúSpace‚Äù. You can publish the apps you‚Äôve built, and they‚Äôll run for people all around the world.\n\nThis guide includes step-by-step instructions for building sites in Space. Both static and server-side rendered (with the @astrojs/node adapter) Astro sites are supported.\n\nPrerequisite\nSection titled Prerequisite\n\nTo push an Astro site to Space, make sure you first:\n\nCreate a Space account.\nInstall the Space CLI and log in.\n\nCreate a Space project inside the directory of your Astro project. Run the CLI and follow the instructions on the screen.\n\nTerminal window\nspace new\n\n NOTE\n\nThe Space CLI will try to auto-detect the configuration for your app. Accept the suggested configuration and then follow the instructions below, depending on the type of Astro app you want to deploy.\n\nProject Configuration\nSection titled Project Configuration\nStatic site\nSection titled Static site\n\nMake the following changes to the Spacefile file at the root of your project generated by the Space CLI.\n\nChange the engine to static.\nAdd Astro‚Äôs build command to the list of commands.\nServe the dist directory generated by Astro.\nSpacefile\n# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0\nv: 0\nmicros:\n  - name: static-astro-in-space\n    src: .\n    engine: static\n    commands:\n      - npm run build\n    serve: dist\nServer-side rendered site\nSection titled Server-side rendered site\n\nMake the following changes to the Spacefile file at the root of your project generated by the Space CLI:\n\nConfigure the nodejs16 engine.\nAdd the build command.\nInclude the dist directory generated by Astro.\nRun the node command.\nSpacefile\n# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0\nv: 0\nmicros:\n  - name: ssr-astro-in-space\n    src: .\n    engine: nodejs16\n    commands:\n      - npm run build\n    include:\n      - dist\n    run: \"node ./dist/server/entry.mjs\"\nHow to deploy\nSection titled How to deploy\n\nDeploy your project with the following command:\n\nTerminal window\nspace push\n\nThis will run the build process and create a new Space app instance where you can access your Astro app.\n\nBy default Space apps are private and are only accessible to you.\n\nIf you want to make your app available to others you can use Public Routes to make parts of your app public. Or, you can create a release to let others install your app into their own personal cloud.\n\nNext steps\nSection titled Next steps\nAdd more compute to your Space project\nStore data for your Space project\nLaunch your Space app\nExamples\nSection titled Examples\nAstro in Space ‚Äì GitHub\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Kinsta Application Hosting üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/kinsta/",
    "html": "Deploy your Astro Site to Kinsta Application Hosting\n\nYou can use Kinsta Application Hosting to host an Astro site on their cloud hosting.\n\nConfiguring your Astro project\nSection titled Configuring your Astro project\nStatic hosting\nSection titled Static hosting\n\n LOOKING FOR AN EXAMPLE?\n\nCheck out the official Kinsta Application Hosting Starter project for Astro!\n\nTo host your project on Kinsta Application Hosting, you need to:\n\nInclude a name field in your package.json. (This can be anything, and will not affect your deployment.)\nInclude a build script in your package.json. (Your Astro project should already include this.)\nInstall the serve package and set the start script to serve dist/.\n\nHere are the necessary lines in your package.json file:\n\npackage.json\n{\n  \"name\": \"anything\", // This is required, but the value does not matter.\n  \"scripts\": {\n    \"dev\": \"astro dev\",\n    \"start\": \"serve dist/\",\n    \"build\": \"astro build\",\n    \"preview\": \"astro preview\",\n    \"astro\": \"astro\"\n  },\n  \"dependencies\": {\n    \"astro\": \"^2.2.0\",\n    \"serve\": \"^14.0.1\"\n  },\n}\nSSR\nSection titled SSR\n\n LOOKING FOR AN EXAMPLE?\n\nCheck out the official Kinsta Application Hosting Starter project for Astro SSR!\n\nTo host your project on Kinsta Application Hosting, you need to:\n\nInclude a name field in your package.json. (This can be anything, and will not affect your deployment.)\nInclude a build script in your package.json. (Your Astro project should already include this.)\nInstall the @astrojs/node package and set the start script to node ./dist/server/entry.mjs.\nSet the astro.config.mjs to use @astrojs/node and to use host: true.\n\nHere are the necessary lines in your package.json file:\n\npackage.json\n{\n  \"name\": \"anything\", // This is required, but the value does not matter.\n  \"scripts\": {\n    \"dev\": \"astro dev\",\n    \"start\": \"node ./dist/server/entry.mjs\",\n    \"build\": \"astro build\",\n    \"preview\": \"astro preview\",\n    \"astro\": \"astro\"\n  },\n  \"dependencies\": {\n    \"astro\": \"^2.2.0\",\n    \"@astrojs/node\": \"^5.1.1\"\n  },\n}\n\nHere are the necessary lines in your astro.config.mjs file:\n\nastro.config.mjs\n  import { defineConfig } from 'astro/config';\n  import node from \"@astrojs/node\";\n\n\n  export default defineConfig({\n    output: 'server',\n    adapter: node({\n      mode: \"standalone\"\n    }),\n    server: {\n      host: true\n    }\n  });\nHow to deploy\nSection titled How to deploy\n\nOnce your project‚Äôs GitHub repository is connected, you can trigger manual deploys to Kinsta Application Hosting in the MyKinsta Admin Panel. You can also set up automatic deployments in your admin panel.\n\nConfiguring a new Kinsta application\nSection titled Configuring a new Kinsta application\nGo to the My Kinsta admin panel.\nGo to the Applications tab.\nConnect your GitHub repository.\nPress the Add service > Application button.\nFollow the wizard steps.\nYour application is deployed.\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Render üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/render/",
    "html": "Deploy your Astro Site to Render\n\nYou can deploy your Astro project to Render, a service to build websites with free TLS certificates, a global CDN, DDoS protection, private networks, and auto deploys from Git.\n\nHow to deploy\nSection titled How to deploy\nCreate a render.com account and sign in\nClick the New + button from your dashboard and select Static Site\nConnect your GitHub or GitLab repository or alternatively enter the public URL of a public repository\nGive your website a name, select the branch and specify the build command and publish directory\nbuild command: npm run build\npublish directory: dist\nEnvironment variables (advanced): By default, Render uses Node.js 14.17.0, but Astro requires a higher version. Add an environment variable with a Variable key of NODE_VERSION and a Value of 18.14.1 or higher to tell Render to use a compatible Node.js version. Alternatively, add a .node-version or .nvmrc file to your project to specify a Node.js version.\nClick the Create Static Site button\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site with Cleavr üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/cleavr/",
    "html": "Deploy your Astro Site with Cleavr\n\nYou can deploy your Astro project to your own Virtual Private Server (VPS) using Cleavr, a server and app deployment management tool.\n\n TIP\n\nCheck out the Astro guide in Cleavr‚Äôs docs!\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need:\n\nA Cleavr account\nA server on your VPS provider using Cleavr\nAdd your site\nSection titled Add your site\n\nIn Cleavr, navigate to the server you want to add your Astro project to.\n\nSelect Add Site and fill in the details for your application, such as domain name.\n\nFor App Type, select ‚ÄòNodeJS Static‚Äô or ‚ÄòNodeJS SSR‚Äô according to how you are setting up your Astro app.\n\nFor Static apps, set Artifact Folder to dist.\n\nFor SSR apps:\n\nSet Entry Point to entry.mjs.\nSet Artifact Folder to dist/server.\n\nSelect Add to add the site to your server.\n\nSetup and deploy\nSection titled Setup and deploy\n\nOnce your new site is added, click Setup and deploy.\n\nSelect the VC Profile, Repo, and Branch for your Astro Project.\n\nMake any additional configurations necessary for your project.\n\nClick on the Deployments tab and then click on Deploy.\n\nCongratulations, you‚Äôve just deployed your Astro app!\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Surge üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/surge/",
    "html": "Deploy your Astro Site to Surge\n\nYou can deploy your Astro project to Surge, a single-command web publishing platform designed for front-end developers.\n\nHow to deploy\nSection titled How to deploy\n\nInstall the Surge CLI globally from the Terminal, if you haven‚Äôt already.\n\nTerminal window\nnpm install -g surge\n\nBuild your Astro site from your project‚Äôs root directory.\n\nTerminal window\nnpm run build\n\nDeploy to Surge using the CLI.\n\nTerminal window\nsurge dist\n\nYou can use a custom domain when deploying by running surge dist yourdomain.com.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Edgio üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/edgio/",
    "html": "Deploy your Astro Site to Edgio\n\nYou can deploy your Astro project to Edgio, an edge and CDN platform to deploy, protect and accelerate websites and APIs.\n\n TIP\n\nCheck out the Astro guide in Edgio‚Äôs docs!\n\nHow to deploy\nSection titled How to deploy\n\nInstall the Edgio CLI globally from the Terminal, if you haven‚Äôt already.\n\nTerminal window\nnpm install -g @edgio/cli\n\nAdd Edgio to your Astro site\n\nTerminal window\nedgio init\n\n(Optional) Enable Server Side Rendering\n\nAfter you‚Äôve set up @astrojs/node with Astro, specify the server file path in edgio.config.js as below:\n\nedgio.config.js\nimport { join } from 'path'\n\n\nmodule.exports = {\n  astro: {\n    // The path of the standalone server that runs Astro SSR.\n    // The dependencies for this file are automatically bundled.\n    appPath: join(process.cwd(), 'dist', 'server', 'entry.mjs'),\n  },\n};\n\nDeploy to Edgio\n\nTerminal window\nedgio deploy\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site with Buddy üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/buddy/",
    "html": "Deploy your Astro Site with Buddy\n\nYou can deploy your Astro project using Buddy, a CI/CD solution that can build your site and push it to many different deploy targets including FTP servers and cloud hosting providers.\n\n NOTE\n\nBuddy itself will not host your site. Instead, it helps you manage the build process and deliver the result to a deploy platform of your choice.\n\nHow to deploy\nSection titled How to deploy\n\nCreate a Buddy account.\n\nCreate a new project and connect it with a git repository (GitHub, GitLab, BitBucket, any private Git Repository or you can use Buddy Git Hosting).\n\nAdd a new pipeline.\n\nIn the newly created pipeline add a Node.js action.\n\nIn this action add:\n\nTerminal window\nnpm install\nnpm run build\n\nAdd a deployment action ‚Äî there are many to choose from, you can browse them in Buddy‚Äôs actions catalog. Although their settings can differ, remember to set the Source path to dist.\n\nPress the Run button.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Microsoft Azure üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/microsoft-azure/",
    "html": "Deploy your Astro Site to Microsoft Azure\n\nAzure is a cloud platform from Microsoft. You can deploy your Astro site with Microsoft Azure‚Äôs Static Web Apps service.\n\nThis guide takes you through deploying your Astro site stored in GitHub using Visual Studio Code. Please see Microsoft guides for using an Azure Pipelines Task for other setups.\n\nPrerequisites\nSection titled Prerequisites\n\nTo follow this guide, you will need:\n\nAn Azure account and a subscription key. You can create a free Azure account here.\nYour app code pushed to GitHub.\nThe SWA Extension in Visual Studio Code.\nHow to deploy\nSection titled How to deploy\n\nOpen your project in VS Code.\n\nOpen the Static Web Apps extension, sign in to Azure, and click the + button to create a new Static Web App. You will be prompted to designate which subscription key to use.\n\nFollow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually /) and built file location (use /dist). Astro is not listed in the built-in templates in Azure so you will need to select custom. The wizard will run and will create a GitHub Action in the .github folder of your repo. (This folder will be automatically created if it does not already exist.)\n\nThe GitHub Action will deploy your app (you can see its progress in your repo‚Äôs Actions tab on GitHub). When successfully completed, you can view your app at the address shown in the SWA Extension‚Äôs progress window by clicking the Browse Website button (this will appear after the GitHub Action has run).\n\nKnown Issues\nSection titled Known Issues\n\nThe GitHub action yaml that is created for you assumes the use of node 14. This means the Astro build fails. To resolve this update your projects package.json file with this snippet.\n\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  },\nOfficial Resources\nSection titled Official Resources\nMicrosoft Azure Static Web Apps documentation\nCommunity Resources\nSection titled Community Resources\nDeploying an Astro Website to Azure Static Web Apps\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Heroku üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/heroku/",
    "html": "Deploy your Astro Site to Heroku\n\nHeroku is a platform-as-a-service for building, running, and managing modern apps in the cloud. You can deploy an Astro site to Heroku using this guide.\n\nHow to deploy\nSection titled How to deploy\n\nInstall the Heroku CLI.\n\nCreate a Heroku account by signing up.\n\nRun heroku login and fill in your Heroku credentials:\n\nTerminal window\n$ heroku login\n\nCreate a file called static.json in the root of your project with the below content:\n\nstatic.json:\n\n{\n  \"root\": \"./dist\"\n}\n\nThis is the configuration of your site; read more at heroku-buildpack-static.\n\nSet up your Heroku git remote:\n\nTerminal window\n# version change\n$ git init\n$ git add .\n$ git commit -m \"My site ready for deployment.\"\n\n\n# creates a new app with a specified name\n$ heroku apps:create example\n\n\n# set buildpack for static sites\n$ heroku buildpacks:set https://github.com/heroku/heroku-buildpack-static.git\n\nDeploy your site:\n\nTerminal window\n# publish site\n$ git push heroku master\n\n\n# opens a browser to view the Dashboard version of Heroku CI\n$ heroku open\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Google Cloud üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/google-cloud/",
    "html": "Deploy your Astro Site to Google Cloud\n\nGoogle Cloud is a full-featured web app hosting platform that can be used to deploy an Astro site.\n\nHow to deploy\nSection titled How to deploy\nCloud Storage (static only)\nSection titled Cloud Storage (static only)\n\nCreate a new GCP project, or select one you already have.\n\nCreate a new bucket under Cloud Storage.\n\nGive it a name and the other required settings.\n\nUpload your dist folder into it or upload using Cloud Build.\n\nEnable public access by adding a new permission to allUsers called Storage Object Viewer.\n\nEdit the website configuration and add √¨ndex.html as the entrypoint and 404.html as the error page.\n\nCloud Run (SSR and static)\nSection titled Cloud Run (SSR and static)\n\nCloud Run is a serverless platform that allows you to run a container without having to manage any infrastructure. It can be used to deploy both static and SSR sites.\n\nPrepare the Service\nSection titled Prepare the Service\n\nCreate a new GCP project, or select one you already have.\n\nMake sure the Cloud Run API is enabled.\n\nCreate a new service.\n\nCreate Dockerfile & Build the Container\nSection titled Create Dockerfile &amp; Build the Container\n\nBefore you can deploy your Astro site to Cloud Run, you need to create a Dockerfile that will be used to build the container. Find more information about how to use Docker with Astro in our recipe section.\n\nOnce the Dockerfile is created, build it into an image and push it to Google Cloud. There are a few ways to accomplish this:\n\nBuild locally using Docker:\n\nUse the docker build command to build the image, docker tag to give it a tag, then docker push to push it to a registry. In the case of Google Cloud, Google Cloud Registry is the easiest option, but you can also use Docker Hub.\n\nTerminal window\n# build your container\ndocker build .\n\n\ndocker tag SOURCE_IMAGE HOSTNAME/PROJECT-ID/TARGET-IMAGE:TAG\n\n\n# Push your image to a registry\ndocker push HOSTNAME/PROJECT-ID/IMAGE:TAG\n\nChange the following values in the commands above to match your project:\n\nSOURCE_IMAGE: the local image name or image ID.\nHOSTNAME: the registry host (gcr.io, eu.gcr.io, asia.gcr.io, us.gcr.io).\nPROJECT: your Google Cloud project ID.\nTARGET-IMAGE: the name for the image when it‚Äôs stored in the registry.\nTAG is the version associated with the image.\n\nRead more in the Google Cloud docs.\n\nUsing another tool:\n\nYou can use a CI/CD tool that supports Docker, like GitHub Actions.\n\nBuild using Cloud Build:\n\nInstead of building the Dockerfile locally, you can instruct Google Cloud to build the image remotely. See the Google Cloud Build documentation here.\n\nDeploying the container\nSection titled Deploying the container\n\nDeployment can be handled manually in your terminal using gcloud or automatically using Cloud Build or any other CI/CD system.\n\n NEED PUBLIC ACCESS?\n\nDon‚Äôt forget to add the permission Cloud Run Invoker to the allUsers group in the Cloud Run permissions settings!\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Google‚Äôs Firebase Hosting üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/google-firebase/",
    "html": "Deploy your Astro Site to Google‚Äôs Firebase Hosting\n\nFirebase Hosting is a service provided by Google‚Äôs Firebase app development platform, which can be used to deploy an Astro site.\n\nSee our separate guide for adding Firebase backend services such as databases, authentication, and storage.\n\nHow to deploy\nSection titled How to deploy\n\nMake sure you have firebase-tools installed.\n\nCreate firebase.json and .firebaserc at the root of your project with the following content:\n\nfirebase.json:\n\n{\n  \"hosting\": {\n    \"public\": \"dist\",\n    \"ignore\": []\n  }\n}\n\n.firebaserc:\n\n{\n  \"projects\": {\n    \"default\": \"<YOUR_FIREBASE_ID>\"\n  }\n}\n\nAfter running npm run build, deploy using the command firebase deploy.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to AWS with Flightcontrol üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/flightcontrol/",
    "html": "Deploy your Astro Site to AWS with Flightcontrol\n\nYou can deploy an Astro site using Flightcontrol, which provides fully-automated deployments to your AWS account.\n\nSupports both static and SSR Astro sites.\n\nHow to Deploy\nSection titled How to Deploy\nCreate a Flightcontrol account at app.flightcontrol.dev/signup\nGo to app.flightcontrol.dev/projects/new/1\nConnect your GitHub account and select your repo\nSelect your desired ‚ÄúConfig Type‚Äù:\nGUI (all config managed through flightcontrol dashboard) where you will select the Astro Static or Astro SSR preset\nflightcontrol.json (‚Äúinfrastructure as code‚Äù option where all config is in your repo) where you will select an Astro example config, then add it to your codebase as flightcontrol.json\nAdjust any configuration as needed\nClick ‚ÄúCreate Project‚Äù and complete any required steps (like linking your AWS account).\nSSR Setup\nSection titled SSR Setup\n\nTo deploy with SSR support, make sure you first set up the @astro/node adapter. Then, follow the steps above, choosing the appropriate configurations for Astro SSR.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to AWS with SST üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/sst/",
    "html": "Deploy your Astro Site to AWS with SST\n\nYou can deploy an Astro site using SST, an open-source framework for deploying fully serverless applications to AWS with SSG and SSR support.\n\nYou can also use any additional SST constructs like Cron Jobs, Buckets, Queues, etc while maintaining type-safety.\n\nQuickstart\nSection titled Quickstart\nCreate an astro project\nRun npx create-sst\nIt should detect that you are using Astro and ask you to confirm.\nOnce you‚Äôre ready for deployment you can run npx sst deploy --stage=production\n\nYou can also watch a video walkthrough of this process that will guide you through the steps.\n\nSST constructs\nSection titled SST constructs\n\nTo use any additional SST constructs, add them to sst.config.ts.\n\nsst.config.ts\napp.stack(function Site(ctx) {\n  const bucket = new Bucket(ctx.stack, \"public\");\n  const site = new AstroSite(ctx.stack, \"site\", {\n    bind: [bucket],\n  });\n\n\n  ctx.stack.addOutputs({\n    url: site.url,\n  });\n});\n\nAnd then access them in your .astro file.\n\n---\nimport { Bucket } from \"sst/node/bucket\"\nconsole.log(Bucket.public.bucketName)\n---\n\nConsult the SST docs on Resource Binding to learn more\n\nIf you have any questions, you can ask in the SST Discord.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to AWS üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/aws/",
    "html": "Deploy your Astro Site to AWS\n\nAWS is a full-featured web app hosting platform that can be used to deploy an Astro site.\n\nDeploying your project to AWS requires using the AWS console. (Most of these actions can also be done using the AWS CLI). This guide will walk you through the steps to deploy your site to AWS starting with the most basic method. Then, it will demonstrate adding additional services to improve cost efficiency and performance.\n\nAWS Amplify\nSection titled AWS Amplify\n\nAWS Amplify is a set of purpose-built tools and features that lets frontend web and mobile developers quickly and easily build full-stack applications on AWS.\n\nCreate a new Amplify Hosting project.\n\nConnect your repository to Amplify.\n\nModify your build output directory baseDirectory to /dist.\n\nversion: 1\nfrontend:\n  phases:\n    preBuild:\n      # Not using npm? Change `npm ci` to `yarn install` or `pnpm i`\n      commands:\n        - npm ci\n    build:\n      commands:\n        - npm run build\n  artifacts:\n    baseDirectory: /dist\n    files:\n      - '**/*'\n  cache:\n    paths:\n      - node_modules/**/*\n\nUsing pnpm will require slightly different settings in order to cache the pnpm store directory instead of node_modules. Below is the recommended build config:\n\nversion: 1\nfrontend:\n  phases:\n    preBuild:\n      commands:\n        - npm i -g pnpm\n        - pnpm config set store-dir .pnpm-store\n        - pnpm i\n    build:\n      commands:\n        - pnpm run build\n  artifacts:\n    baseDirectory: /dist\n    files:\n      - '**/*'\n  cache:\n    paths:\n      - .pnpm-store/**/*\n\nAmplify will automatically deploy your website and update it when you push a commit to your repository.\n\nS3 static website hosting\nSection titled S3 static website hosting\n\nS3 is the starting point of any application. It is where your project files and other assets are stored. S3 charges for file storage and number of requests. You can find more information about S3 in the AWS documentation.\n\nCreate an S3 bucket with your project‚Äôs name.\n\n TIP\n\nThe bucket name should be globally unique. We recommend a combination of your project name and the domain name of your site.\n\nDisable ‚ÄúBlock all public access‚Äù. By default, AWS sets all buckets to be private. To make it public, you need to uncheck the ‚ÄúBlock public access‚Äù checkbox in the bucket‚Äôs properties.\n\nUpload your built files located in dist to S3. You can do this manually in the console or use the AWS CLI. If you use the AWS CLI, you can use the following command after authenticating with your AWS credentials:\n\naws s3 cp dist/ s3://<BUCKET_NAME>/ --recursive\n\nUpdate your bucket policy to allow public access. You can find this setting in the bucket‚Äôs Permissions > Bucket policy.\n\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Sid\": \"PublicReadGetObject\",\n      \"Effect\": \"Allow\",\n      \"Principal\": \"*\",\n      \"Action\": \"s3:GetObject\",\n      \"Resource\": \"arn:aws:s3:::<BUCKET_NAME>/*\"\n    }\n  ]\n}\n\n CAUTION\n\nDo not forget to replace <BUCKET_NAME> with the name of your bucket.\n\nEnable website hosting for your bucket. You can find this setting in the bucket‚Äôs Settings > Static website hosting. Set your index document to index.html and your error document to 404.html. Finally, you can find your new website URL in the bucket‚Äôs Settings > Static website hosting.\n\n NOTE\n\nIf you are deploying a single-page application (SPA), set your error document to index.html.\n\nS3 with CloudFront\nSection titled S3 with CloudFront\n\nCloudFront is a web service that provides content delivery network (CDN) capabilities. It is used to cache content of a web server and distribute it to end users. CloudFront charges for the amount of data transferred. Adding CloudFront to your S3 bucket is more cost-effective and provides a faster delivery.\n\nWe will use CloudFront to wrap our S3 bucket to serve our project‚Äôs files using Amazon global CDN network. This will reduce the cost of serving your project‚Äôs files and will increase the performance of your site.\n\nS3 setup\nSection titled S3 setup\n\nCreate an S3 bucket with your project‚Äôs name.\n\n TIP\n\nThe bucket name should be globally unique. We recommend a combination of your project name and the domain name of your site.\n\nUpload your built files located in dist to S3. You can do this manually in the console or use the AWS CLI. If you use the AWS CLI, you can use the following command after authenticating with your AWS credentials:\n\naws s3 cp dist/ s3://<BUCKET_NAME>/ --recursive\n\nUpdate your bucket policy to allow CloudFront Access. You can find this setting in the bucket‚Äôs Permissions > Bucket policy.\n\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [{\n    \"Effect\": \"Allow\",\n    \"Principal\": {\n      \"AWS\": \"arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity <CLOUDFRONT_OAI_ID>\"\n    },\n    \"Action\": \"s3:GetObject\",\n    \"Resource\": \"arn:aws:s3:::astro-aws/*\"\n  }]\n}\n\n CAUTION\n\nDo not forget to replace <CLOUDFRONT_OAI_ID> with the name of your CloudFront Origin Access Identity ID. You can find the CloudFront Origin Access Identity ID in CloudFront > Origin access identities after setting up CloudFront.\n\nCloudFront setup\nSection titled CloudFront setup\nCreate a CloudFront distribution with the following values:\nOrigin domain: Your S3 bucket\nS3 bucket access: ‚ÄúYes use OAI (bucket can restrict access to only CloudFront)‚Äù\nOrigin access identity: Create a new origin access identity\nViewer - Bucket policy: ‚ÄúNo, I will update the bucket policy‚Äù\nViewer protocol policy: ‚ÄúRedirect to HTTPS‚Äù\nDefault root object: index.html\n\nThis configuration will block access to your S3 bucket from the public internet and serve your site using the global CDN network. You can find your CloudFront distribution URL in the bucket‚Äôs Distributions > Domain name.\n\nCloudFront Functions setup\nSection titled CloudFront Functions setup\n\nUnfortunately, CloudFront does not support multi-page sub-folder/index routing by default. To configure it, we will use CloudFront Functions to point the request to the desired object in S3.\n\nCreate a new CloudFront function with the following code snippet. You can find CloudFront functions in CloudFront > Functions.\n\nfunction handler(event) {\n  var request = event.request;\n  var uri = request.uri;\n\n\n  // Check whether the URI is missing a file name.\n  if (uri.endsWith('/')) {\n    request.uri += 'index.html';\n  }\n  // Check whether the URI is missing a file extension.\n  else if (!uri.includes('.')) {\n    request.uri += '/index.html';\n  }\n\n\n  return request;\n}\n\nAttach your function to the CloudFront distribution. You can find this option in your CloudFront distribution‚Äôs Settings > Behaviors > Edit > Function associations.\n\nViewer request - Function type: CloudFront Function.\nViewer request - Function ARN: Select the function you created in the previous step.\nCloudFront Error Pages setup\nSection titled CloudFront Error Pages setup\n\nBy default, S3 returns a 404 error when the file is not found, and 403 when the file is private. This causes visitors to see an ugly XML error page in both cases.\n\nTo fix this, add custom error responses in your CloudFront distribution‚Äôs Settings > Error pages.\n\nCreate a custom error response for 404 errors with the following values:\n\nHTTP error code: 404: Not Found\nCustomize error response: Yes\nResponse page path: /index.html\nHTTP response code: 200: OK\n\nCreate a custom error response for 403 errors with the following values:\n\nHTTP error code: 403: Forbidden\nCustomize error response: Yes\nResponse page path: /index.html\nHTTP response code: 200: OK\n\n TIP\n\nFor the best user experience, you can create a custom 404 page in your project and set the Response page path to /404.html.\n\nContinuous deployment with GitHub Actions\nSection titled Continuous deployment with GitHub Actions\n\nThere are many ways to set up continuous deployment for AWS. One possibility for code hosted on GitHub is to use GitHub Actions to deploy your website every time you push a commit.\n\nCreate a new policy in your AWS account using IAM with the following permissions. This policy will allow you to upload built files to your S3 bucket and invalidate the CloudFront distribution files when you push a commit.\n\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n      {\n          \"Sid\": \"VisualEditor0\",\n          \"Effect\": \"Allow\",\n          \"Action\": [\n              \"s3:PutObject\",\n              \"s3:ListBucket\",\n              \"s3:DeleteObject\",\n              \"cloudfront:CreateInvalidation\"\n          ],\n          \"Resource\": [\n              \"<DISTRIBUTION_ARN>\",\n              \"arn:aws:s3:::<BUCKET_NAME>/*\",\n              \"arn:aws:s3:::<BUCKET_NAME>\"\n          ]\n      }\n  ]\n}\n\n CAUTION\n\nDo not forget to replace <DISTRIBUTION_ARN> and <BUCKET_NAME>. You can find the ARN in CloudFront > Distributions > Details.\n\nCreate a new IAM user and attach the policy to the user. This will provide your AWS_SECRET_ACCESS_KEY and AWS_ACCESS_KEY_ID.\n\nAdd this sample workflow to your repository at .github/workflows/deploy.yml and push it to GitHub. You will need to add AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, BUCKET_ID, and DISTRIBUTION_ID as ‚Äúsecrets‚Äù to your repository on GitHub under Settings > Secrets > Actions. Click New repository secret to add each one.\n\nname: Deploy Website\n\n\non:\n  push:\n    branches:\n      - main\n\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n      - name: Configure AWS Credentials\n        uses: aws-actions/configure-aws-credentials@v1\n        with:\n          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n          aws-region: us-east-1\n      - name: Install modules\n        run: npm ci\n      - name: Build application\n        run: npm run build\n      - name: Deploy to S3\n        run: aws s3 sync --delete ./dist/ s3://${{ secrets.BUCKET_ID }}\n      - name: Create CloudFront invalidation\n        run: aws cloudfront create-invalidation --distribution-id ${{ secrets.DISTRIBUTION_ID }} --paths \"/*\"\n\n NOTE\n\nYour BUCKET_ID is the name of your S3 bucket. Your DISTRIBUTION_ID is your CloudFront distribution ID. You can find your CloudFront distribution ID in CloudFront > Distributions > ID\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Cloudflare Pages üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/cloudflare/",
    "html": "Deploy your Astro Site to Cloudflare Pages\n\nYou can deploy your Astro project on Cloudflare Pages, a platform for frontend developers to collaborate and deploy static (JAMstack) and SSR websites.\n\nThis guide includes:\n\nHow to deploy through the Cloudflare Pages Dashboard\nHow to deploy using Wrangler, the Cloudflare CLI\nHow to deploy an SSR site using @astrojs/cloudflare\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need:\n\nA Cloudflare account. If you don‚Äôt already have one, you can create a free Cloudflare account during the process.\nYour app code pushed to a GitHub or a GitLab repository.\nHow to deploy a site with Git\nSection titled How to deploy a site with Git\n\nSet up a new project on Cloudflare Pages.\n\nPush your code to your git repository (GitHub, GitLab).\n\nLog in to the Cloudflare dashboard and select your account in Account Home > Pages.\n\nSelect Create a new Project and the Connect Git option.\n\nSelect the git project you want to deploy and click Begin setup\n\nUse the following build settings:\n\nFramework preset: Astro\nBuild command: npm run build\nBuild output directory: dist\n\nClick the Save and Deploy button.\n\nHow to deploy a site using Wrangler\nSection titled How to deploy a site using Wrangler\nInstall Wrangler CLI.\nAuthenticate Wrangler with your Cloudflare account using wrangler login.\nRun your build command.\nDeploy using npx wrangler pages deploy dist.\nTerminal window\n# Install Wrangler CLI\nnpm install -g wrangler\n# Login to Cloudflare account from CLI\nwrangler login\n# Run your build command\nnpm run build\n# Create new deployment\nnpx wrangler pages deploy dist\n\nAfter your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.\n\nEnabling Preview locally with Wrangler\nSection titled Enabling Preview locally with Wrangler\n\nFor the preview to work, you must install wrangler\n\nTerminal window\npnpm add wrangler --save-dev\n\nIt‚Äôs then possible to update the preview script to run wrangler instead of Astro‚Äôs built-in preview command:\n\npackage.json\n\"preview\": \"wrangler pages dev ./dist\"\nHow to deploy an SSR site\nSection titled How to deploy an SSR site\n\nYou can build an Astro SSR site for deployment to Cloudflare Pages using the @astrojs/cloudflare adapter.\n\nFollow the steps below to set up the adapter. You can then deploy using either of the approaches documented above.\n\nQuick install\nSection titled Quick install\n\nAdd the Cloudflare adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\nnpx astro add cloudflare\nManual install\nSection titled Manual install\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nAdd the @astrojs/cloudflare adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/cloudflare\n\nAdd the following to your astro.config.mjs file:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport cloudflare from '@astrojs/cloudflare';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: cloudflare()\n});\nModes\nSection titled Modes\n\nThere are currently two modes supported when using Pages Functions with the @astrojs/cloudflare adapter.\n\nAdvanced mode: This mode is used when you want to run your function in advanced mode which picks up the _worker.js in dist, or a directory mode where pages will compile the worker out of a functions folder in the project root.\n\nIf no mode is set, the default is \"advanced\".\n\ndirectory mode: This mode is used when you want to run your function in directory mode, which means the adapter will compile the client side part of your app the same way, but it will move the worker script into a functions folder in the project root. The adaptor will only ever place a [[path]].js in that folder, allowing you to add additional plugins and pages middleware which can be checked into version control.\n\nastro.config.mjs\nexport default defineConfig({\n  adapter: cloudflare({ mode: \"directory\" }),\n});\nUsing Pages Functions\nSection titled Using Pages Functions\n\nPages Functions enable you to run server-side code to enable dynamic functionality without running a dedicated server.\n\nTo get started, create a /functions directory at the root of your project. Writing your Functions files in this directory automatically generates a Worker with custom functionality at the predesignated routes. To learn more about writing Functions, see the Pages Functions documentation.\n\nüìö Read more about SSR in Astro.\n\nTroubleshooting\nSection titled Troubleshooting\n\nIf you‚Äôre encountering errors, double-check the version of node you‚Äôre using locally (node -v) matches the version you‚Äôre specifying in the environment variable.\n\nCloudflare requires Node v16.13, which is a more recent version than Astro‚Äôs out-of-the-box minimum, so double check you‚Äôre using at least v16.13.\n\nClient-side hydration may fail as a result of Cloudflare‚Äôs Auto Minify setting. If you see Hydration completed but contains mismatches in the console, make sure to disable Auto Minify under Cloudflare settings.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Deno üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/deno/",
    "html": "Deploy your Astro Site to Deno\n\nYou can deploy a server-side rendered Astro site to Deno Deploy, a distributed system that runs JavaScript, TypeScript, and WebAssembly at the edge, worldwide.\n\nThis guide includes instructions for deploying to Deno Deploy through GitHub Actions or Deno Deploy‚Äôs CLI.\n\nRequirements\nSection titled Requirements\n\nThis guide assumes you already have Deno installed.\n\nProject Configuration\nSection titled Project Configuration\n\nYour Astro project can be deployed to Deno Deploy as a server-side rendered site (SSR). Deno Deploy does not support static sites.\n\nAdapter for SSR\nSection titled Adapter for SSR\n\nTo enable SSR in your Astro project and deploy on Deno Deploy:\n\nAdd the Deno adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\nnpx astro add deno\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nInstall the @astrojs/deno adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\n  npm install @astrojs/deno\n\nUpdate your astro.config.mjs project configuration file with the changes below.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport deno from '@astrojs/deno';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: deno(),\n});\n\nNext, Update your preview script in package.json with the change below.\n\npackage.json\n{\n  // ...\n  \"scripts\": {\n    \"dev\": \"astro dev\",\n    \"start\": \"astro dev\",\n    \"build\": \"astro build\",\n    \"preview\": \"astro preview\"\n    \"preview\": \"deno run --allow-net --allow-read --allow-env ./dist/server/entry.mjs\"\n  }\n}\n\nYou can now use this command to preview your production Astro site locally with Deno.\n\nTerminal window\nnpm run preview\nHow to deploy\nSection titled How to deploy\n\nYou can deploy to Deno Deploy through GitHub Actions or using Deno Deploy‚Äôs CLI (command line interface).\n\nGitHub Actions Deployment\nSection titled GitHub Actions Deployment\n\nIf your project is stored on GitHub, the Deno Deploy website will guide you through setting up GitHub Actions to deploy your Astro site.\n\nPush your code to a public or private GitHub repository.\n\nSign in on Deno Deploy with your GitHub account, and click on New Project.\n\nSelect your repository, the branch you want to deploy from, and select GitHub Action mode. (Your Astro site requires a build step, and cannot use Automatic mode.)\n\nIn your Astro project, create a new file at .github/workflows/deploy.yml and paste in the YAML below. This is similar to the YAML given by Deno Deploy, with the additional steps needed for your Astro site.\n\nname: Deploy\non: [push]\n\n\njobs:\n  deploy:\n    name: Deploy\n    runs-on: ubuntu-latest\n    permissions:\n      id-token: write # Needed for auth with Deno Deploy\n      contents: read # Needed to clone the repository\n\n\n    steps:\n      - name: Clone repository\n        uses: actions/checkout@v3\n\n\n      # Not using npm? Change `npm ci` to `yarn install` or `pnpm i`\n      - name: Install dependencies\n        run: npm ci\n\n\n      # Not using npm? Change `npm run build` to `yarn build` or `pnpm run build`\n      - name: Build Astro\n        run: npm run build\n\n\n      - name: Upload to Deno Deploy\n        uses: denoland/deployctl@v1\n        with:\n          project: my-deno-project # TODO: replace with Deno Deploy project name\n          entrypoint: server/entry.mjs\n          root: dist\n\nAfter committing this YAML file, and pushing to GitHub on your configured deploy branch, the deploy should begin automatically!\n\nYou can track the progress using the ‚ÄúActions‚Äù tab on your GitHub repository page, or on Deno Deploy.\n\nCLI Deployment\nSection titled CLI Deployment\n\nInstall the Deno Deploy CLI.\n\nTerminal window\ndeno install --allow-read --allow-write --allow-env --allow-net --allow-run --no-check -r -f https://deno.land/x/deploy/deployctl.ts\n\nRun your Astro build step.\n\nTerminal window\nnpm run build\n\nRun deployctl to deploy!\n\nIn the command below, replace <ACCESS-TOKEN> with your Personal Access Token and <MY-DENO-PROJECT> with your Deno Deploy project name.\n\nTerminal window\nDENO_DEPLOY_TOKEN=<ACCESS-TOKEN> deployctl deploy --project=<MY-DENO-PROJECT> --no-static --include=./dist ./dist/server/entry.mjs\n\nYou can track all your deploys on Deno Deploy.\n\n(Optional) To simplify the build and deploy into one command, add a deploy-deno script in package.json.\n\npackage.json\n{\n  // ...\n  \"scripts\": {\n    \"dev\": \"astro dev\",\n    \"start\": \"astro dev\",\n    \"build\": \"astro build\",\n    \"preview\": \"deno run --allow-net --allow-read --allow-env ./dist/server/entry.mjs\",\n    \"deno-deploy\": \"npm run build && deployctl deploy --project=<MY-DENO-PROJECT> --no-static --include=./dist ./dist/server/entry.mjs\"\n  }\n}\n\nThen you can use this command to build and deploy your Astro site in one step.\n\nTerminal window\nDENO_DEPLOY_TOKEN=<ACCESS-TOKEN> npm run deno-deploy\n\nüìö Read more about SSR in Astro.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to GitLab Pages üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/gitlab/",
    "html": "Deploy your Astro Site to GitLab Pages\n\nYou can use GitLab Pages to host an Astro site for your GitLab projects, groups, or user account.\n\n LOOKING FOR AN EXAMPLE?\n\nCheck out the official GitLab Pages Astro example project!\n\nHow to deploy\nSection titled How to deploy\n\nSet the correct site in astro.config.mjs.\n\nRename the public/ directory to static.\n\nSet outDir:public in astro.config.mjs. This setting instructs Astro to put the static build output in a folder called public, which is the folder required by GitLab Pages for exposed files.\n\nIf you were using the public/ directory as a source of static files in your Astro project, rename it and use that new folder name in astro.config.mjs for the value of publicDir.\n\nFor example, here are the correct astro.config.mjs settings when the public/ directory is renamed to static/:\n\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  site: 'https://<user>.gitlab.io',\n  base: '/<project-name>'\n  outDir: 'public',\n  publicDir: 'static',\n});\n\nCreate a file called .gitlab-ci.yml in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:\n\npages:\n  # The Docker image that will be used to build your app\n  image: node:lts\n\n\n  before_script:\n    - npm ci\n\n\n  script:\n    # Specify the steps involved to build your app here\n    - npm run build\n\n\n  artifacts:\n    paths:\n      # The folder that contains the built files to be published.\n      # This must be called \"public\".\n      - public\n\n\n  only:\n    # Trigger a new build and deploy only when there is a push to the\n    # branch(es) below\n    - main\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to GitHub Pages üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/github/",
    "html": "Deploy your Astro Site to GitHub Pages\n\nYou can use GitHub Pages to host an Astro website directly from a repository on GitHub.com.\n\nHow to deploy\nSection titled How to deploy\n\nYou can deploy an Astro site to GitHub Pages by using GitHub Actions to automatically build and deploy your site. To do this, your source code must be hosted on GitHub.\n\nAstro maintains the official withastro/action to deploy your project with very little configuration. Follow the instructions below to deploy your Astro site to GitHub pages, and see the package README if you need more information.\n\nSet the site and, if needed, base options in astro.config.mjs.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  site: 'https://astronaut.github.io',\n  base: '/my-repo',\n})\nsite should be https://<YOUR_USERNAME>.github.io or https://my-custom-domain.com\nbase should be your repository‚Äôs name starting with a forward slash, for example /my-repo. This is so that Astro understands your website‚Äôs root is /my-repo, rather than the default /.\n\n NOTE\n\nDon‚Äôt set a base parameter if:\n\nYour page is served from the root folder.\nYour repository is located at https://github.com/<USERNAME>/<USERNAME>.github.io.\nYou‚Äôre using a custom domain.\n\n CAUTION\n\nIf you did not previously have a value for base set, and are only configuring this value so that you can deploy to GitHub, you must update your internal page links to now include your base.\n\n<a href=\"/my-repo/about\">About</a>\n\nCreate a new file in your project at .github/workflows/deploy.yml and paste in the YAML below.\n\ndeploy.yml\nname: Deploy to GitHub Pages\n\n\non:\n  # Trigger the workflow every time you push to the `main` branch\n  # Using a different branch name? Replace `main` with your branch‚Äôs name\n  push:\n    branches: [ main ]\n  # Allows you to run this workflow manually from the Actions tab on GitHub.\n  workflow_dispatch:\n\n\n# Allow this job to clone the repo and create a page deployment\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout your repository using git\n        uses: actions/checkout@v3\n      - name: Install, build, and upload your site\n        uses: withastro/action@v1\n        # with:\n          # path: . # The root location of your Astro project inside the repository. (optional)\n          # node-version: 18 # The specific version of Node that should be used to build your site. Defaults to 18. (optional)\n          # package-manager: pnpm@latest # The Node package manager that should be used to install dependencies and build your site. Automatically detected based on your lockfile. (optional)\n\n\n  deploy:\n    needs: build\n    runs-on: ubuntu-latest\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    steps:\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v1\n\n NOTE\n\nThe astro action takes a few optional inputs. These can be provided by uncommenting the with: line and the input you want to use.\n\n CAUTION\n\nThe official Astro action scans for a lockfile to detect your preferred package manager (npm, yarn, pnpm, or bun). You should commit your package manager‚Äôs automatically generated package-lock.json, yarn.lock, pnpm-lock.yaml, or bun.lockb file to your repository.\n\nOn GitHub, go to your repository‚Äôs Settings tab and find the Pages section of the settings.\n\nChoose GitHub Actions as the Source of your site.\n\nCommit the new workflow file and push it to GitHub.\n\nYour site should now be published! When you push changes to your Astro project‚Äôs repository, the GitHub Action will automatically deploy them for you.\n\n SET UP A CUSTOM DOMAIN\n\nYou can optionally set up a custom domain by adding the following ./public/CNAME file to your project:\n\npublic/CNAME\nsub.mydomain.com\n\nThis will deploy your site at your custom domain instead of user.github.io. Don‚Äôt forget to also configure DNS for your domain provider.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Tigris & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/backend/tigris/",
    "html": "Tigris & Astro\n\nTigris is an open source alternative to MongoDB and DynamoDB. It is a serverless NoSQL database and search platform with their own official Astro integration.\n\nOfficial Resources\nSection titled Official Resources\nCreating database-driven Astro sites with the Tigris Astro integration\nTigris Astro Integration\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this backend service with Astro? More backend service guides\nFirebase\nSupabase\nXata\nAppwrite\nTigris"
  },
  {
    "title": "Deploy your Astro Site to Vercel üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/vercel/",
    "html": "Deploy your Astro Site to Vercel\n\nYou can use Vercel to deploy an Astro site to their global edge network with zero configuration.\n\nThis guide includes instructions for deploying to Vercel through the website UI or Vercel‚Äôs CLI.\n\nProject Configuration\nSection titled Project Configuration\n\nYour Astro project can be deployed to Vercel as a static site, or as a server-side rendered site (SSR).\n\nStatic Site\nSection titled Static Site\n\nYour Astro project is a static site by default. You don‚Äôt need any extra configuration to deploy a static Astro site to Vercel.\n\nAdapter for SSR\nSection titled Adapter for SSR\n\nTo enable SSR in your Astro project and deploy on Vercel:\n\nAdd the Vercel adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\nnpx astro add vercel\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nInstall the @astrojs/vercel adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\n  npm install @astrojs/vercel\n\nAdd two new lines to your astro.config.mjs project configuration file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel(),\n});\nHow to deploy\nSection titled How to deploy\n\nYou can deploy to Vercel through the website UI or using Vercel‚Äôs CLI (command line interface). The process is the same for both static and SSR Astro sites.\n\nWebsite UI Deployment\nSection titled Website UI Deployment\nPush your code to your online Git repository (GitHub, GitLab, BitBucket).\nImport your project into Vercel.\nVercel will automatically detect Astro and configure the right settings.\nYour application is deployed! (e.g. astro.vercel.app)\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate Preview Deployments, and all changes made to the Production Branch (commonly ‚Äúmain‚Äù) will result in a Production Deployment.\n\nüìö Learn more about Vercel‚Äôs Git Integration.\n\nCLI Deployment\nSection titled CLI Deployment\n\nInstall the Vercel CLI and run vercel to deploy.\n\nTerminal window\nnpm install -g vercel\nvercel\n\nVercel will automatically detect Astro and configure the right settings.\n\nWhen asked Want to override the settings? [y/N], choose N.\n\nYour application is deployed! (e.g. astro.vercel.app)\n\nProject config with vercel.json\nSection titled Project config with vercel.json\n\nYou can use vercel.json to override the default behavior of Vercel and to configure additional settings. For example, you may wish to attach headers to HTTP responses from your Deployments.\n\nüìö Learn more about Vercel‚Äôs project configuration.\n\nUpgrading to Astro 2.0\nSection titled Upgrading to Astro 2.0\n\nAstro v2.0 drops support for Node 14, so make sure your project is using Node 18.14.1 or later. You can define the Node.js version used during the Build Step and Serverless Functions from the General page under Project Settings.\n\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Deploy your Astro Site to Netlify üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/netlify/",
    "html": "Deploy your Astro Site to Netlify\n\nNetlify offers hosting and serverless backend services for web applications and static websites. Any Astro site can be hosted on Netlify!\n\nThis guide includes instructions for deploying to Netlify through the website UI or Netlify‚Äôs CLI.\n\nProject Configuration\nSection titled Project Configuration\n\nYour Astro project can be deployed to Netlify in three different ways: as a static site, a server-rendered site, or an edge-rendered site.\n\nStatic Site\nSection titled Static Site\n\nYour Astro project is a static site by default. You don‚Äôt need any extra configuration to deploy a static Astro site to Netlify.\n\nAdapter for SSR\nSection titled Adapter for SSR\n\nTo enable SSR in your Astro project and deploy on Netlify, including using Netlify‚Äôs edge functions:\n\nAdd the Netlify adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\nnpx astro add netlify\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nInstall the @astrojs/netlify adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\n  npm install @astrojs/netlify\n\nAdd two new lines to your astro.config.mjs project configuration file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/functions';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: netlify(),\n});\n\nYou can also deploy your project using Netlify‚Äôs Edge Functions by adding edgeMiddleware: true to the Netlify adatper‚Äôs configuration:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/functions';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: netlify({\n    edgeMiddleware: true\n  }),\n});\nHow to deploy\nSection titled How to deploy\n\nYou can deploy to Netlify through the website UI or using Netlify‚Äôs CLI (command line interface). The process is the same for both static and SSR Astro sites.\n\nWebsite UI Deployment\nSection titled Website UI Deployment\n\nIf your project is stored in GitHub, GitLab, BitBucket, or Azure DevOps, you can use the Netlify website UI to deploy your Astro site.\n\nClick Add a new site in your Netlify dashboard\n\nChoose Import an existing project\n\nWhen you import your Astro repository from your Git provider, Netlify should automatically detect and pre-fill the correct configuration settings for you.\n\nMake sure that the following settings are entered, then press the Deploy button:\n\nBuild Command: astro build or npm run build\nPublish directory: dist\n\nAfter deploying, you will be redirected to the site overview page. There, you can edit the details of your site.\n\nAny future changes to your source repository will trigger preview and production deploys based on your deployment configuration.\n\nnetlify.toml file\nSection titled netlify.toml file\n\nYou can optionally create a new netlify.toml file at the top level of your project repository to configure your build command and publish directory, as well as other project settings including environment variables and redirects. Netlify will read this file and automatically configure your deployment.\n\nTo configure the default settings, create a netlify.toml file with the following contents:\n\n[build]\n  command = \"npm run build\"\n  publish = \"dist\"\n\nüìö More info at ‚ÄúDeploying an existing Astro Git repository‚Äù on Netlify‚Äôs blog\n\nCLI Deployment\nSection titled CLI Deployment\n\nYou can also create a new site on Netlify and link up your Git repository by installing and using the Netlify CLI.\n\nInstall Netlify‚Äôs CLI globally\n\nTerminal window\nnpm install --global netlify-cli\n\nRun netlify login and follow the instructions to log in and authorize Netlify\n\nRun netlify init and follow the instructions\n\nConfirm your build command (astro build)\n\nThe CLI will automatically detect the build settings (astro build) and deploy directory (dist), and will offer to automatically generate a netlify.toml file with those settings.\n\nBuild and deploy by pushing to Git\n\nThe CLI will add a deploy key to the repository, which means your site will be automatically rebuilt on Netlify every time you git push.\n\nüìö More details from Netlify on Deploy an Astro site using the Netlify CLI\n\nSet a Node.js Version\nSection titled Set a Node.js Version\n\nIf you are using a legacy build image (Xenial) on Netlify, make sure that your Node.js version is set. Astro requires v18.14.1 or higher.\n\nYou can specify your Node.js version in Netlify using:\n\na .nvmrc file in your base directory.\na NODE_VERSION environment variable in your site‚Äôs settings using the Netlify project dashboard.\nUsing Netlify Functions\nSection titled Using Netlify Functions\n\nNo special configuration is required to use Netlify Functions with Astro. Add a netlify/functions directory to your project root and follow the Netlify Functions documentation to get started!\n\nExamples\nSection titled Examples\nHow to deploy an Astro site ‚Äî Netlify Blog\nDeploy An Astro site with Forms, Serverless Functions, and Redirects ‚Äî Netlify Blog\nDeployment Walkthrough Video ‚Äî Netlify YouTube channel\nMore Deployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nVercel\nDeno Deploy\nGitHub Pages\nGitLab Pages\nCloudflare Pages\nAWS\nAWS via Flightcontrol\nAWS via SST\nGoogle Cloud\nFirebase Hosting\nHeroku\nMicrosoft Azure\nBuddy\nEdgio\nRender\nSurge\nCleavr\nKinsta\nDeta Space"
  },
  {
    "title": "Xata & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/backend/xata/",
    "html": "Xata & Astro\n\nXata is a Serverless Data Platform that combines the features of a relational database, a search engine, and an analytics engine by exposing a single consistent REST API.\n\nAdding a database with Xata\nSection titled Adding a database with Xata\nPrerequisites\nSection titled Prerequisites\nA Xata account with a created database. (You can use the sample database from the Web UI.)\nAn Access Token (XATA_TOKEN_API).\nYour Database URL.\n\nAfter you update and initialize the Xata CLI, you will have your API token in your .env file and database URL defined.\n\nBy the end of the setup, you should have:\n\n.env\nXATA_API_KEY=hash_key\n\n\n# Xata branch that will be used\n# if there's not a xata branch with\n# the same name as your git branch\nXATA_BRANCH=main\n\nAnd the databaseURL defined:\n\n.xatarc\n{\n  \"databaseUrl\": \"https://your-database-url\"\n}\nEnvironment configuration\nSection titled Environment configuration\n\nTo have IntelliSense and type safety for your environment variables, edit or create the file env.d.ts in your src/ directory:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly XATA_API_KEY: string;\n  readonly XATA_BRANCH?: string;\n}\n\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n\n TIP\n\nRead more about environment variables and .env files in Astro.\n\nUsing the codegeneration from the Xata CLI and choosing the TypeScript option, generated an instance of the SDK for you, with types tailored to your database schema. Additionally, @xata.io/client was added to your package.json.\n\nYour Xata environment variables and database url were automatically pulled by the SDK instance, so there‚Äôs no more setup work needed.\n\nNow, your project should have the following structure:\n\nDirectory\nsrc/\nxata.ts\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\n.xatarc\nCreate your queries\nSection titled Create your queries\n\nTo query your posts, import and use XataClient class in a .astro file. The example below queries the first 50 posts from Xata‚Äôs Sample Blog Database.\n\nsrc/pages/blog/index.astro\n---\nimport { XataClient } from '../../xata';\n\n\nconst xata = new XataClient({\n  apiKey: import.meta.env.XATA_API_KEY,\n  branch: import.meta.env.XATA_BRANCH\n});\n\n\nconst { records } = await xata.db.Posts.getPaginated({\n  pagination: {\n    size: 50\n  }\n})\n---\n\n\n<ul>\n  {records.map((post) => (\n    <li>{post.title}</li>\n  ))}\n</ul>\n\nIt‚Äôs important to note the SDK needs to be regenerated everytime your schema changes. So, avoid making changes to the generated files the Xata CLI creates because once schema updates, your changes will be overwritten.\n\nOfficial Resources\nSection titled Official Resources\nXata Astro Starter\nXata Docs: Quick Start Guide\nMore backend service guides\nFirebase\nSupabase\nXata\nAppwrite\nTigris"
  },
  {
    "title": "Appwrite & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/backend/appwriteio/",
    "html": "Appwrite & Astro\n\nAppwrite is a self-hosted backend-as-a-service platform that provides authentication and account management, user preferences, database and storage persistence, cloud functions, localization, image manipulation, and other server-side utilities.\n\nOfficial Resources\nSection titled Official Resources\nAppwrite Demos for Astro\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this backend service with Astro? More backend service guides\nFirebase\nSupabase\nXata\nAppwrite\nTigris"
  },
  {
    "title": "Supabase & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/backend/supabase/",
    "html": "Supabase & Astro\n\nSupabase is an open source Firebase alternative. It provides a Postgres database, authentication, edge functions, realtime subscriptions, and storage.\n\nInitializing Supabase in Astro\nSection titled Initializing Supabase in Astro\nPrerequisites\nSection titled Prerequisites\nA Supabase project. If you don‚Äôt have one, you can sign up for free at supabase.com and create a new project.\nAn Astro project with server-side rendering (SSR) enabled.\nSupabase credentials for your project. You can find these in the Settings > API tab of your Supabase project.\nSUPABASE_URL: The URL of your Supabase project.\nSUPABASE_ANON_KEY: The anonymous key for your Supabase project.\nAdding Supabase credentials\nSection titled Adding Supabase credentials\n\nTo add your Supabase credentials to your Astro project, add the following to your .env file:\n\n.env\nSUPABASE_URL=YOUR_SUPABASE_URL\nSUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY\n\nNow, these environment variables are available in your project.\n\nIf you would like to have IntelliSense for your environment variables, edit or create the env.d.ts in your src/ directory and add the following:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly SUPABASE_URL: string\n  readonly SUPABASE_ANON_KEY: string\n}\n\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n\n TIP\n\nRead more about environment variables and .env files in Astro.\n\nYour project should now include these files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nInstalling dependencies\nSection titled Installing dependencies\n\nTo connect to Supabase, you will need to install @supabase/supabase-js in your project.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @supabase/supabase-js\n\nNext, create a folder named lib in your src/ directory. This is where you will add your Supabase client.\n\nIn supabase.ts, add the following to initialize your Supabase client:\n\nsrc/lib/supabase.ts\nimport { createClient } from \"@supabase/supabase-js\";\n\n\nexport const supabase = createClient(\n  import.meta.env.SUPABASE_URL,\n  import.meta.env.SUPABASE_ANON_KEY,\n);\n\nNow, your project should include these files:\n\nDirectory\nsrc/\nDirectory\nlib/\nsupabase.ts\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nAdding authentication with Supabase\nSection titled Adding authentication with Supabase\n\nSupabase provides authentication out of the box. It supports email/password authentication and OAuth authentication with many providers including GitHub, Google, and several others.\n\nPrerequisites\nSection titled Prerequisites\nAn Astro project initialized with Supabase.\nA Supabase project with email/password authentication enabled. You can enable this in the Authentication > Providers tab of your Supabase project.\nCreating auth server endpoints\nSection titled Creating auth server endpoints\n\nTo add authentication to your project, you will need to create a few server endpoints. These endpoints will be used to register, sign in, and sign out users.\n\nPOST /api/auth/register: to register a new user.\nPOST /api/auth/signin: to sign in a user.\nGET /api/auth/signout: to sign out a user.\n\nCreate these endpoints in the src/pages/api/auth directory of your project. Your project should now include these new files:\n\nDirectory\nsrc/\nDirectory\nlib/\nsupabase.ts\nDirectory\npages/\nDirectory\napi/\nDirectory\nauth/\nsignin.ts\nsignout.ts\nregister.ts\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\n\nregister.ts creates a new user in Supabase. It accepts a POST request with the an email and password. It then uses the Supabase SDK to create a new user.\n\nsrc/pages/api/auth/register.ts\nimport type { APIRoute } from \"astro\";\nimport { supabase } from \"../../../lib/supabase\";\n\n\nexport const POST: APIRoute = async ({ request, redirect }) => {\n  const formData = await request.formData();\n  const email = formData.get(\"email\")?.toString();\n  const password = formData.get(\"password\")?.toString();\n\n\n  if (!email || !password) {\n    return new Response(\"Email and password are required\", { status: 400 });\n  }\n\n\n  const { error } = await supabase.auth.signUp({\n    email,\n    password,\n  });\n\n\n  if (error) {\n    return new Response(error.message, { status: 500 });\n  }\n\n\n  return redirect(\"/signin\");\n};\n\nsignin.ts signs in a user. It accepts a POST request with the an email and password. It then uses the Supabase SDK to sign in the user.\n\nsrc/pages/api/auth/signin.ts\nimport type { APIRoute } from \"astro\";\nimport { supabase } from \"../../../lib/supabase\";\n\n\nexport const POST: APIRoute = async ({ request, cookies, redirect }) => {\n  const formData = await request.formData();\n  const email = formData.get(\"email\")?.toString();\n  const password = formData.get(\"password\")?.toString();\n\n\n  if (!email || !password) {\n    return new Response(\"Email and password are required\", { status: 400 });\n  }\n\n\n  const { data, error } = await supabase.auth.signInWithPassword({\n    email,\n    password,\n  });\n\n\n  if (error) {\n    return new Response(error.message, { status: 500 });\n  }\n\n\n  const { access_token, refresh_token } = data.session;\n  cookies.set(\"sb-access-token\", access_token, {\n    path: \"/\",\n  });\n  cookies.set(\"sb-refresh-token\", refresh_token, {\n    path: \"/\",\n  });\n  return redirect(\"/dashboard\");\n};\n\nsignout.ts signs out a user. It accepts a GET request and removes the user‚Äôs access and refresh tokens.\n\nsrc/pages/api/auth/signout.ts\nimport type { APIRoute } from \"astro\";\n\n\nexport const GET: APIRoute = async ({ cookies, redirect }) => {\n  cookies.delete(\"sb-access-token\", { path: \"/\" });\n  cookies.delete(\"sb-refresh-token\", { path: \"/\" });\n  return redirect(\"/signin\");\n};\nCreating auth pages\nSection titled Creating auth pages\n\nNow that you have created your server endpoints, create the pages that will use them.\n\nsrc/pages/register: contains a form to register a new user.\nsrc/pages/signin: contains a form to sign in a user.\nsrc/pages/dashboard: contains a page that is only accessible to authenticated users.\n\nCreate these pages in the src/pages directory. Your project should now include these new files:\n\nDirectory\nsrc/\nDirectory\nlib/\nsupabase.ts\nDirectory\npages/\nDirectory\napi/\nDirectory\nauth/\nsignin.ts\nsignout.ts\nregister.ts\nregister.astro\nsignin.astro\ndashboard.astro\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\n\nregister.astro contains a form to register a new user. It accepts an email and password and sends a POST request to /api/auth/register.\n\nsrc/pages/register.astro\n---\nimport Layout from \"../layouts/Layout.astro\";\n---\n\n\n<Layout title=\"Register\">\n  <h1>Register</h1>\n  <p>Already have an account? <a href=\"/signin\">Sign in</a></p>\n  <form action=\"/api/auth/register\" method=\"post\">\n    <label for=\"email\" for=\"email\">Email</label>\n    <input type=\"email\" name=\"email\" id=\"email\" />\n    <label for=\"password\">Password</label>\n    <input type=\"password\" name=\"password\" id=\"password\" />\n    <button type=\"submit\">Login</button>\n  </form>\n</Layout>\n\nsignin.astro contains a form to sign in a user. It accepts an email and password and sends a POST request to /api/auth/signin. It also checks for the presence of the access and refresh tokens. If they are present, it redirects to the dashboard.\n\nsrc/pages/signin.astro\n---\nimport Layout from \"../layouts/Layout.astro\";\n\n\nconst { cookies, redirect } = Astro;\n\n\nconst accessToken = cookies.get(\"sb-access-token\");\nconst refreshToken = cookies.get(\"sb-refresh-token\");\n\n\nif (accessToken && refreshToken) {\n  return redirect(\"/dashboard\");\n}\n---\n\n\n<Layout title=\"Sign in\">\n  <h1>Sign in</h1>\n  <p>New here? <a href=\"/register\">Create an account</a></p>\n  <form action=\"/api/auth/signin\" method=\"post\">\n    <label for=\"email\" for=\"email\">Email</label>\n    <input type=\"email\" name=\"email\" id=\"email\" />\n    <label for=\"password\">Password</label>\n    <input type=\"password\" name=\"password\" id=\"password\" />\n    <button type=\"submit\">Login</button>\n  </form>\n</Layout>\n\ndashboard.astro contains a page that is only accessible to authenticated users. It checks for the presence of the access and refresh tokens. If they are not present, it redirects to the sign in page.\n\nsrc/pages/dashboard.astro\n---\nimport Layout from \"../layouts/Layout.astro\";\n\n\nconst { cookies, redirect } = Astro;\n\n\nconst accessToken = cookies.get(\"sb-access-token\");\nconst refreshToken = cookies.get(\"sb-refresh-token\");\n\n\nif (!accessToken || !refreshToken) {\n  return redirect(\"/signin\");\n}\n\n\nconst { data, error } = await supabase.auth.setSession({\n  refresh_token: refreshToken.value,\n  access_token: accessToken.value,\n});\n\n\nif (error) {\n  cookies.delete(\"sb-access-token\", {\n    path: \"/\",\n  });\n  cookies.delete(\"sb-refresh-token\", {\n    path: \"/\",\n  });\n\n\n  return redirect(\"/signin\");\n}\n\n\nconst email = data?.user?.email;\n---\n<Layout title=\"dashboard\">\n  <h1>Welcome {email}</h1>\n  <p>We are happy to see you here</p>\n  <form action=\"/api/auth/signout\">\n    <button type=\"submit\">Sign out</button>\n  </form>\n</Layout>\nAdding OAuth authentication\nSection titled Adding OAuth authentication\n\nTo add OAuth authentication to your project, you will need to edit your Supabase client to enable authentication flow with \"pkce\". You can read more about authentication flows in the Supabase documentation.\n\nsrc/lib/supabase.ts\nimport { createClient } from \"@supabase/supabase-js\";\n\n\nexport const supabase = createClient(\n  import.meta.env.SUPABASE_URL,\n  import.meta.env.SUPABASE_ANON_KEY,\n  {\n    auth: {\n      flowType: \"pkce\",\n    },\n  },\n);\n\nNext, in the Supabase dashboard, enable the OAuth provider you would like to use. You can find the list of supported providers in the Authentication > Providers tab of your Supabase project.\n\nThe following example uses GitHub as the OAuth provider. To connect your project to GitHub, follow the steps in the Supabase documentation.\n\nThen, create a new server endpoint to handle the OAuth callback at src/pages/api/auth/callback.ts. This endpoint will be used to exchange the OAuth code for an access and refresh token.\n\nsrc/pages/api/auth/callback.ts\nimport type { APIRoute } from \"astro\";\nimport { supabase } from \"../../../lib/supabase\";\n\n\nexport const GET: APIRoute = async ({ url, cookies, redirect }) => {\n  const authCode = url.searchParams.get(\"code\");\n\n\n  if (!authCode) {\n    return new Response(\"No code provided\", { status: 400 });\n  }\n\n\n  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);\n\n\n  if (error) {\n    return new Response(error.message, { status: 500 });\n  }\n\n\n  const { access_token, refresh_token } = data.session;\n\n\n  cookies.set(\"sb-access-token\", access_token, {\n    path: \"/\",\n  });\n  cookies.set(\"sb-refresh-token\", refresh_token, {\n    path: \"/\",\n  });\n\n\n  return redirect(\"/dashboard\");\n};\n\nNext, edit the sign in page to include a new button to sign in with the OAuth provider. This button should send a POST request to /api/auth/signin with the provider set to the name of the OAuth provider.\n\nsrc/pages/signin.astro\n---\nimport Layout from \"../layouts/Layout.astro\";\n\n\nconst { cookies, redirect } = Astro;\n\n\nconst accessToken = cookies.get(\"sb-access-token\");\nconst refreshToken = cookies.get(\"sb-refresh-token\");\n\n\nif (accessToken && refreshToken) {\n  return redirect(\"/dashboard\");\n}\n---\n\n\n<Layout title=\"Sign in\">\n  <h1>Sign in</h1>\n  <p>New here? <a href=\"/register\">Create an account</a></p>\n  <form action=\"/api/auth/signin\" method=\"post\">\n    <label for=\"email\" for=\"email\">Email</label>\n    <input type=\"email\" name=\"email\" id=\"email\" />\n    <label for=\"password\">Password</label>\n    <input type=\"password\" name=\"password\" id=\"password\" />\n    <button type=\"submit\">Login</button>\n    <button value=\"github\" name=\"provider\" type=\"submit\">Sign in with GitHub</button>\n  </form>\n</Layout>\n\nFinally, edit the sign in server endpoint to handle the OAuth provider. If the provider is present, it will redirect to the OAuth provider. Otherwise, it will sign in the user with the email and password.\n\nsrc/pages/api/auth/signin.ts\nimport type { APIRoute } from \"astro\";\nimport { supabase } from \"../../../lib/supabase\";\n\n\nexport const POST: APIRoute = async ({ request, cookies, redirect }) => {\n  const formData = await request.formData();\n  const email = formData.get(\"email\")?.toString();\n  const password = formData.get(\"password\")?.toString();\n  const provider = formData.get(\"provider\")?.toString();\n\n\n  const validProviders = [\"google\", \"github\", \"discord\"];\n\n\n  if (provider && validProviders.includes(provider)) {\n    const { data, error } = await supabase.auth.signInWithOAuth({\n      provider as Provider,\n      options: {\n        redirectTo: \"http://localhost:4321/api/auth/callback\"\n      },\n    });\n\n\n    if (error) {\n      return new Response(error.message, { status: 500 });\n    }\n\n\n    return redirect(data.url);\n  }\n\n\n  if (!email || !password) {\n    return new Response(\"Email and password are required\", { status: 400 });\n  }\n\n\n  const { data, error } = await supabase.auth.signInWithPassword({\n    email,\n    password,\n  });\n\n\n  if (error) {\n    return new Response(error.message, { status: 500 });\n  }\n\n\n  const { access_token, refresh_token } = data.session;\n  cookies.set(\"sb-access-token\", access_token, {\n    path: \"/\",\n  });\n  cookies.set(\"sb-refresh-token\", refresh_token, {\n    path: \"/\",\n  });\n  return redirect(\"/dashboard\");\n};\n\nAfter creating the OAuth callback endpoint and editing the sign in page and server endpoint, your project should have the following file structure:\n\nDirectory\nsrc/\nDirectory\nlib/\nsupabase.ts\nDirectory\npages/\nDirectory\napi/\nDirectory\nauth/\nsignin.ts\nsignout.ts\nregister.ts\ncallback.ts\nregister.astro\nsignin.astro\ndashboard.astro\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nCommunity Resources\nSection titled Community Resources\nGetting into the holiday spirit with Astro, React, and Supabase\nAstro and Supabase auth demo\nMore backend service guides\nFirebase\nSupabase\nXata\nAppwrite\nTigris"
  },
  {
    "title": "Firebase & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/backend/google-firebase/",
    "html": "Firebase & Astro\n\nFirebase is an app development platform that provides a NoSQL database, authentication, realtime subscriptions, functions, and storage.\n\nSee our separate guide for deploying to Firebase hosting.\n\nInitializing Firebase in Astro\nSection titled Initializing Firebase in Astro\nPrerequisites\nSection titled Prerequisites\nA Firebase project with a web app configured.\nAn Astro project with server-side rendering (SSR) enabled.\nFirebase credentials: You will need two sets of credentials to connect Astro to Firebase:\nWeb app credentials: These credentials will be used by the client side of your app. You can find them in the Firebase console under Project settings > General. Scroll down to the Your apps section and click on the Web app icon.\nProject credentials: These credentials will be used by the server side of your app. You can generate them in the Firebase console under Project settings > Service accounts > Firebase Admin SDK > Generate new private key.\nAdding Firebase credentials\nSection titled Adding Firebase credentials\n\nTo add your Firebase credentials to Astro, create an .env file in the root of your project with the following variables:\n\n.env\nFIREBASE_PRIVATE_KEY_ID=YOUR_PRIVATE_KEY_ID\nFIREBASE_PRIVATE_KEY=YOUR_PRIVATE_KEY\nFIREBASE_PROJECT_ID=YOUR_PROJECT_ID\nFIREBASE_CLIENT_EMAIL=YOUR_CLIENT_EMAIL\nFIREBASE_CLIENT_ID=YOUR_CLIENT_ID\nFIREBASE_AUTH_URI=YOUR_AUTH_URI\nFIREBASE_TOKEN_URI=YOUR_TOKEN_URI\nFIREBASE_AUTH_CERT_URL=YOUR_AUTH_CERT_URL\nFIREBASE_CLIENT_CERT_URL=YOUR_CLIENT_CERT_URL\n\nNow, these environment variables are available for use in your project.\n\nIf you would like to have IntelliSense for your Firebase environment variables, edit or create the file env.d.ts in your src/ directory and configure your types:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly FIREBASE_PRIVATE_KEY_ID: string;\n  readonly FIREBASE_PRIVATE_KEY: string;\n  readonly FIREBASE_PROJECT_ID: string;\n  readonly FIREBASE_CLIENT_EMAIL: string;\n  readonly FIREBASE_CLIENT_ID: string;\n  readonly FIREBASE_AUTH_URI: string;\n  readonly FIREBASE_TOKEN_URI: string;\n  readonly FIREBASE_AUTH_CERT_URL: string\n  readonly FIREBASE_CLIENT_CERT_URL: string;\n}\n\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\n\n TIP\n\nRead more about environment variables and .env files in Astro.\n\nYour project should now include these new files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nInstalling dependencies\nSection titled Installing dependencies\n\nTo connect Astro with Firebase, install the following packages using the single command below for your preferred package manager:\n\nfirebase - the Firebase SDK for the client side\nfirebase-admin - the Firebase Admin SDK for the server side\nnpm\npnpm\nYarn\nTerminal window\nnpm install firebase firebase-admin\n\nNext, create a folder named firebase in the src/ directory and add two new files to this folder: client.ts and server.ts.\n\nIn client.ts, add the following code to initialize Firebase in the client using your web app credentials and the firebase package:\n\nsrc/firebase/client.ts\nimport { initializeApp } from \"firebase/app\";\n\n\nconst firebaseConfig = {\n  apiKey: \"my-public-api-key\",\n  authDomain: \"my-auth-domain\",\n  projectId: \"my-project-id\",\n  storageBucket: \"my-storage-bucket\",\n  messagingSenderId: \"my-sender-id\",\n  appId: \"my-app-id\",\n};\n\n\nexport const app = initializeApp(firebaseConfig);\n\n NOTE\n\nRemember to replace the firebaseConfig object with your own web app credentials.\n\nIn server.ts, add the following code to initialize Firebase in the server using your project credentials and the firebase-admin package:\n\nsrc/firebase/server.ts\nimport type { ServiceAccount } from \"firebase-admin\";\nimport { initializeApp, cert, getApps } from \"firebase-admin/app\";\n\n\nconst activeApps = getApps();\nconst serviceAccount = {\n  type: \"service_account\",\n  project_id: import.meta.env.FIREBASE_PROJECT_ID,\n  private_key_id: import.meta.env.FIREBASE_PRIVATE_KEY_ID,\n  private_key: import.meta.env.FIREBASE_PRIVATE_KEY,\n  client_email: import.meta.env.FIREBASE_CLIENT_EMAIL,\n  client_id: import.meta.env.FIREBASE_CLIENT_ID,\n  auth_uri: import.meta.env.FIREBASE_AUTH_URI,\n  token_uri: import.meta.env.FIREBASE_TOKEN_URI,\n  auth_provider_x509_cert_url: import.meta.env.FIREBASE_AUTH_CERT_URL,\n  client_x509_cert_url: import.meta.env.FIREBASE_CLIENT_CERT_URL,\n};\n\n\nexport const app = activeApps.length === 0 ? initializeApp({\n  credential: cert(serviceAccount as ServiceAccount),\n}) : activeApps[0];\n\n NOTE\n\nRemember to replace the serviceAccount object with your own project credentials.\n\nFinally, your project should now include these new files:\n\nDirectory\nsrc\nenv.d.ts\nDirectory\nfirebase\nclient.ts\nserver.ts\n.env\nastro.config.mjs\npackage.json\nAdding authentication with Firebase\nSection titled Adding authentication with Firebase\nPrerequisites\nSection titled Prerequisites\nAn Astro project initialized with Firebase.\nA Firebase project with email/password authentication enabled in the Firebase console under Authentication > Sign-in method.\nCreating auth server endpoints\nSection titled Creating auth server endpoints\n\nFirebase authentication in Astro requires the following three Astro server endpoints:\n\nGET /api/auth/signin - to sign in a user\nGET /api/auth/signout - to sign out a user\nPOST /api/auth/register - to register a user\n\nCreate three endpoints related to authentication in a new directory src/pages/api/auth/: signin.ts, signout.ts and register.ts.\n\nsignin.ts contains the code to sign in a user using Firebase:\n\nsrc/pages/api/auth/signin.ts\nimport type { APIRoute } from \"astro\";\nimport { app } from \"../../../firebase/server\";\nimport { getAuth } from \"firebase-admin/auth\";\n\n\nexport const GET: APIRoute = async ({ request, cookies, redirect }) => {\n  const auth = getAuth(app);\n\n\n  /* Get token from request headers */\n  const idToken = request.headers.get(\"Authorization\")?.split(\"Bearer \")[1];\n  if (!idToken) {\n    return new Response(\n      \"No token found\",\n      { status: 401 }\n    );\n  }\n\n\n  /* Verify id token */\n  try {\n    await auth.verifyIdToken(idToken);\n  } catch (error) {\n    return new Response(\n      \"Invalid token\",\n      { status: 401 }\n    );\n  }\n\n\n  /* Create and set session cookie */\n  const fiveDays = 60 * 60 * 24 * 5 * 1000;\n  const sessionCookie = await auth.createSessionCookie(idToken, {\n    expiresIn: fiveDays,\n  });\n\n\n  cookies.set(\"session\", sessionCookie, {\n    path: \"/\",\n  });\n\n\n  return redirect(\"/dashboard\");\n};\n\n NOTE\n\nThis is a basic implementation of the signin endpoint. You can add more logic to this endpoint to suit your needs.\n\nsignout.ts contains the code to log out a user by deleting the session cookie:\n\nsrc/pages/api/auth/signout.ts\nimport type { APIRoute } from \"astro\";\n\n\nexport const GET: APIRoute = async ({ redirect, cookies }) => {\n  cookies.delete(\"session\", {\n    path: \"/\",\n  });\n  return redirect(\"/signin\");\n};\n\n NOTE\n\nThis is a basic implementation of the signout endpoint. You can add more logic to this endpoint to suit your needs.\n\nregister.ts contains the code to register a user using Firebase:\n\nsrc/pages/api/auth/register.ts\nimport type { APIRoute } from \"astro\";\nimport { getAuth } from \"firebase-admin/auth\";\nimport { app } from \"../../../firebase/server\";\n\n\nexport const POST: APIRoute = async ({ request, redirect }) => {\n  const auth = getAuth(app);\n\n\n  /* Get form data */\n  const formData = await request.formData();\n  const email = formData.get(\"email\")?.toString();\n  const password = formData.get(\"password\")?.toString();\n  const name = formData.get(\"name\")?.toString();\n\n\n  if (!email || !password || !name) {\n    return new Response(\n      \"Missing form data\",\n      { status: 400 }\n    );\n  }\n\n\n  /* Create user */\n  try {\n    await auth.createUser({\n      email,\n      password,\n      displayName: name,\n    });\n  } catch (error: any) {\n    return new Response(\n      \"Something went wrong\",\n      { status: 400 }\n    );\n  }\n  return redirect(\"/signin\");\n};\n\n NOTE\n\nThis is a basic implementation of the register endpoint. You can add more logic to this endpoint to suit your needs.\n\nAfter creating server endpoints for authentication, your project directory should now include these new files:\n\nDirectory\nsrc\nenv.d.ts\nDirectory\nfirebase\nclient.ts\nserver.ts\nDirectory\npages\nDirectory\napi\nDirectory\nauth\nsignin.ts\nsignout.ts\nregister.ts\n.env\nastro.config.mjs\npackage.json\nCreating pages\nSection titled Creating pages\n\nCreate the pages that will use the Firebase endpoints:\n\nsrc/pages/register - will contain a form to register a user\nsrc/pages/signin - will contain a form to sign in a user\nsrc/pages/dashboard - will contain a dashboard that can only be accessed by authenticated users\n\nThe example src/pages/register.astro below includes a form that will send a POST request to the /api/auth/register endpoint. This endpoint will create a new user using the data from the form and then will redirect the user to the /signin page.\n\nsrc/pages/register.astro\n---\nimport Layout from \"../layouts/Layout.astro\";\n---\n\n\n<Layout title=\"Register\">\n  <h1>Register</h1>\n  <p>Already have an account? <a href=\"/signin\">Sign in</a></p>\n  <form action=\"/api/auth/register\" method=\"post\">\n    <label for=\"name\">Name</label>\n    <input type=\"text\" name=\"name\" id=\"name\" />\n    <label for=\"email\" for=\"email\">Email</label>\n    <input type=\"email\" name=\"email\" id=\"email\" />\n    <label for=\"password\">Password</label>\n    <input type=\"password\" name=\"password\" id=\"password\" />\n    <button type=\"submit\">Login</button>\n  </form>\n</Layout>\n\nsrc/pages/signin.astro uses the Firebase server app to verify the user‚Äôs session cookie. If the user is authenticated, the page will redirect the user to the /dashboard page.\n\nThe example page below contains a form that will send a POST request to the /api/auth/signin endpoint with the ID token generated by the Firebase client app.\n\nThe endpoint will verify the ID token and create a new session cookie for the user. Then, the endpoint will redirect the user to the /dashboard page.\n\nsrc/pages/signin.astro\n---\nimport { app } from \"../firebase/server\";\nimport { getAuth } from \"firebase-admin/auth\";\nimport Layout from \"../layouts/Layout.astro\";\n\n\n/* Check if the user is authenticated */\nconst auth = getAuth(app);\nif (Astro.cookies.has(\"session\")) {\n  const sessionCookie = Astro.cookies.get(\"session\").value;\n  const decodedCookie = await auth.verifySessionCookie(sessionCookie);\n  if (decodedCookie) {\n    return Astro.redirect(\"/dashboard\");\n  }\n}\n---\n\n\n<Layout title=\"Sign in\">\n  <h1>Sign in</h1>\n  <p>New here? <a href=\"/register\">Create an account</a></p>\n  <form action=\"/api/auth/signin\" method=\"post\">\n    <label for=\"email\" for=\"email\">Email</label>\n    <input type=\"email\" name=\"email\" id=\"email\" />\n    <label for=\"password\">Password</label>\n    <input type=\"password\" name=\"password\" id=\"password\" />\n    <button type=\"submit\">Login</button>\n  </form>\n</Layout>\n<script>\n  import {\n    getAuth,\n    inMemoryPersistence,\n    signInWithEmailAndPassword,\n  } from \"firebase/auth\";\n  import { app } from \"../firebase/client\";\n\n\n  const auth = getAuth(app);\n  // This will prevent the browser from storing session data\n  auth.setPersistence(inMemoryPersistence);\n\n\n  const form = document.querySelector(\"form\") as HTMLFormElement;\n  form.addEventListener(\"submit\", async (e) => {\n    e.preventDefault();\n    const formData = new FormData(form);\n    const email = formData.get(\"email\")?.toString();\n    const password = formData.get(\"password\")?.toString();\n\n\n    if (!email || !password) {\n      return;\n    }\n    const userCredential = await signInWithEmailAndPassword(\n      auth,\n      email,\n      password\n    );\n    const idToken = await userCredential.user.getIdToken();\n    const response = await fetch(\"/api/auth/signin\", {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${idToken}`,\n      },\n    });\n\n\n    if (response.redirected) {\n      window.location.assign(response.url);\n    }\n  });\n</script>\n\nsrc/pages/dashboard.astro will verify the user‚Äôs session cookie using the Firebase server app. If the user is not authenticated, the page will redirect the user to the /signin page.\n\nThe example page below display the user‚Äôs name and a button to sign out. Clicking the button will send a GET request to the /api/auth/signout endpoint.\n\nThe endpoint will delete the user‚Äôs session cookie and redirect the user to the /signin page.\n\nsrc/pages/dashboard.astro\n---\nimport { app } from \"../firebase/server\";\nimport { getAuth } from \"firebase-admin/auth\";\nimport Layout from \"../layouts/Layout.astro\";\n\n\nconst auth = getAuth(app);\n\n\n/* Check current session */\nif (!Astro.cookies.has(\"session\")) {\n  return Astro.redirect(\"/signin\");\n}\nconst sessionCookie = Astro.cookies.get(\"session\").value;\nconst decodedCookie = await auth.verifySessionCookie(sessionCookie);\nconst user = await auth.getUser(decodedCookie.uid);\n\n\nif (!user) {\n  return Astro.redirect(\"/signin\");\n}\n---\n\n\n<Layout title=\"dashboard\">\n  <h1>Welcome {user.displayName}</h1>\n  <p>We are happy to see you here</p>\n  <form action=\"/api/auth/signout\">\n    <button type=\"submit\">Sign out</button>\n  </form>\n</Layout>\nAdding OAuth providers\nSection titled Adding OAuth providers\n\nTo add OAuth providers to your app, you need to enable them in the Firebase console.\n\nIn the Firebase console, go to the Authentication section and click on the Sign-in method tab. Then, click on the Add a new provider button and enable the providers you want to use.\n\nThe example below uses the Google provider.\n\nEdit the signin.astro page to add:\n\na button to sign in with Google underneath the existing form\nan event listener on the button to handle the sign in process in the existing <script>.\nsrc/pages/signin.astro\n---\nimport { app } from \"../firebase/server\";\nimport { getAuth } from \"firebase-admin/auth\";\nimport Layout from \"../layouts/Layout.astro\";\n\n\n/* Check if the user is authenticated */\nconst auth = getAuth(app);\nif (Astro.cookies.has(\"session\")) {\n  const sessionCookie = Astro.cookies.get(\"session\").value;\n  const decodedCookie = await auth.verifySessionCookie(sessionCookie);\n  if (decodedCookie) {\n    return Astro.redirect(\"/dashboard\");\n  }\n}\n---\n\n\n<Layout title=\"Sign in\">\n  <h1>Sign in</h1>\n  <p>New here? <a href=\"/register\">Create an account</a></p>\n  <form action=\"/api/auth/signin\" method=\"post\">\n    <label for=\"email\" for=\"email\">Email</label>\n    <input type=\"email\" name=\"email\" id=\"email\" />\n    <label for=\"password\">Password</label>\n    <input type=\"password\" name=\"password\" id=\"password\" />\n    <button type=\"submit\">Login</button>\n  </form>\n  <button id=\"google\">Sign in with Google</button>\n</Layout>\n<script>\n  import {\n    getAuth,\n    inMemoryPersistence,\n    signInWithEmailAndPassword,\n    GoogleAuthProvider,\n    signInWithPopup,\n  } from \"firebase/auth\";\n  import { app } from \"../firebase/client\";\n\n\n  const auth = getAuth(app);\n  auth.setPersistence(inMemoryPersistence);\n\n\n  const form = document.querySelector(\"form\") as HTMLFormElement;\n  form.addEventListener(\"submit\", async (e) => {\n    e.preventDefault();\n    const formData = new FormData(form);\n    const email = formData.get(\"email\")?.toString();\n    const password = formData.get(\"password\")?.toString();\n\n\n    if (!email || !password) {\n      return;\n    }\n    const userCredential = await signInWithEmailAndPassword(\n      auth,\n      email,\n      password\n    );\n    const idToken = await userCredential.user.getIdToken();\n    const response = await fetch(\"/api/auth/signin\", {\n      headers: {\n        Authorization: `Bearer ${idToken}`,\n      },\n    });\n\n\n    if (response.redirected) {\n      window.location.assign(response.url);\n    }\n  });\n\n\n  const googleSignin = document.querySelector(\"#google\") as HTMLButtonElement;\n  googleSignin.addEventListener(\"click\", async () => {\n    const provider = new GoogleAuthProvider();\n    const userCredential = await signInWithPopup(auth, provider);\n    const idToken = await userCredential.user.getIdToken();\n    const res = await fetch(\"/api/auth/signin\", {\n      headers: {\n        Authorization: `Bearer ${idToken}`,\n      },\n    });\n\n\n    if (res.redirected) {\n      window.location.assign(res.url);\n    }\n  });\n</script>\n\nWhen clicked, the Google sign in button will open a popup window to sign in with Google. Once the user signs in, it will send a POST request to the /api/auth/signin endpoint with the ID token generated by OAuth provider.\n\nThe endpoint will verify the ID token and create a new session cookie for the user. Then, the endpoint will redirect the user to the /dashboard page.\n\nConnecting to Firestore database\nSection titled Connecting to Firestore database\nPrerequisites\nSection titled Prerequisites\n\nAn Astro project initialized with Firebase as described in the Initializing Firebase in Astro section.\n\nA Firebase project with a Firestore database. You can follow the Firebase documentation to create a new project and set up a Firestore database.\n\nIn this recipe, the Firestore collection will be called friends and will contain documents with the following fields:\n\nid: autogenerated by Firestore\nname: a string field\nage: a number field\nisBestFriend: a boolean field\nCreating the server endpoints\nSection titled Creating the server endpoints\n\nCreate two new files in a new directory src/pages/api/friends/: index.ts and [id].ts. These will create two server endpoints to interact with the Firestore database in the following ways:\n\nPOST /api/friends: to create a new document in the friends collection.\nPOST /api/friends/:id: to update a document in the friends collection.\nDELETE /api/friends/:id: to delete a document in the friends collection.\n\nindex.ts will contain the code to create a new document in the friends collection:\n\nsrc/pages/api/friends/index.ts\nimport type { APIRoute } from \"astro\";\nimport { app } from \"../../../firebase/server\";\nimport { getFirestore } from \"firebase-admin/firestore\";\n\n\nexport const POST: APIRoute = async ({ request, redirect }) => {\n  const formData = await request.formData();\n  const name = formData.get(\"name\")?.toString();\n  const age = formData.get(\"age\")?.toString();\n  const isBestFriend = formData.get(\"isBestFriend\") === \"on\";\n\n\n  if (!name || !age) {\n    return new Response(\"Missing required fields\", {\n      status: 400,\n    });\n  }\n  try {\n    const db = getFirestore(app);\n    const friendsRef = db.collection(\"friends\");\n    await friendsRef.add({\n      name,\n      age: parseInt(age),\n      isBestFriend,\n    });\n  } catch (error) {\n    return new Response(\"Something went wrong\", {\n      status: 500,\n    });\n  }\n  return redirect(\"/dashboard\");\n};\n\n NOTE\n\nThis is a basic implementation of the friends endpoint. You can add more logic to this endpoint to suit your needs.\n\n[id].ts will contain the code to update and delete a document in the friends collection:\n\nsrc/pages/api/friends/[id].ts\nimport type { APIRoute } from \"astro\";\nimport { app } from \"../../../firebase/server\";\nimport { getFirestore } from \"firebase-admin/firestore\";\n\n\nconst db = getFirestore(app);\nconst friendsRef = db.collection(\"friends\");\n\n\nexport const POST: APIRoute = async ({ params, redirect, request }) => {\n  const formData = await request.formData();\n  const name = formData.get(\"name\")?.toString();\n  const age = formData.get(\"age\")?.toString();\n  const isBestFriend = formData.get(\"isBestFriend\") === \"on\";\n\n\n  if (!name || !age) {\n    return new Response(\"Missing required fields\", {\n      status: 400,\n    });\n  }\n\n\n  if (!params.id) {\n    return new Response(\"Cannot find friend\", {\n      status: 404,\n    });\n  }\n\n\n  try {\n    await friendsRef.doc(params.id).update({\n      name,\n      age: parseInt(age),\n      isBestFriend,\n    });\n  } catch (error) {\n    return new Response(\"Something went wrong\", {\n      status: 500,\n    });\n  }\n  return redirect(\"/dashboard\");\n};\n\n\nexport const DELETE: APIRoute = async ({ params, redirect }) => {\n  if (!params.id) {\n    return new Response(\"Cannot find friend\", {\n      status: 404,\n    });\n  }\n\n\n  try {\n    await friendsRef.doc(params.id).delete();\n  } catch (error) {\n    return new Response(\"Something went wrong\", {\n      status: 500,\n    });\n  }\n  return redirect(\"/dashboard\");\n};\n\n NOTE\n\nThis is a basic implementation of the friends/:id endpoint. You can add more logic to this endpoint to suit your needs.\n\nAfter creating server endpoints for Firestore, your project directory should now include these new files:\n\nDirectory\nsrc\nenv.d.ts\nDirectory\nfirebase\nclient.ts\nserver.ts\nDirectory\npages\nDirectory\napi\nDirectory\nfriends\nindex.ts\n[id].ts\n.env\nastro.config.mjs\npackage.json\nCreating pages\nSection titled Creating pages\n\nCreate the pages that will use the Firestore endpoints:\n\nsrc/pages/add.astro - will contain a form to add a new friend.\nsrc/pages/edit/[id].astro - will contain a form to edit a friend and a button to delete a friend.\nsrc/pages/friend/[id].astro - will contain the details of a friend.\nsrc/pages/dashboard.astro - will display a list of friends.\nAdd a new record\nSection titled Add a new record\n\nThe example src/pages/add.astro below includes a form that will send a POST request to the /api/friends endpoint. This endpoint will create a new friend using the data from the form and then will redirect the user to the /dashboard page.\n\nsrc/pages/add.astro\n---\nimport Layout from \"../layouts/Layout.astro\";\n---\n\n\n<Layout title=\"Add a new friend\">\n  <h1>Add a new friend</h1>\n  <form method=\"post\" action=\"/api/friends\">\n    <label for=\"name\">Name</label>\n    <input type=\"text\" id=\"name\" name=\"name\" />\n    <label for=\"age\">Age</label>\n    <input type=\"number\" id=\"age\" name=\"age\" />\n    <label for=\"isBestFriend\">Is best friend?</label>\n    <input type=\"checkbox\" id=\"isBestFriend\" name=\"isBestFriend\" />\n    <button type=\"submit\">Add friend</button>\n  </form>\n</Layout>\nEdit or Delete a record\nSection titled Edit or Delete a record\n\nsrc/pages/edit/[id].astro will contain a form to edit a friend data and a button to delete a friend. On submit, this page will send a POST request to the /api/friends/:id endpoint to update a friend data.\n\nIf the user clicks the delete button, this page will send a DELETE request to the /api/friends/:id endpoint to delete a friend.\n\nsrc/pages/edit/[id].astro\n---\nimport Layout from \"../../layouts/Layout.astro\";\nimport { app } from \"../../firebase/server\";\nimport { getFirestore } from \"firebase-admin/firestore\";\n\n\ninterface Friend {\n  name: string;\n  age: number;\n  isBestFriend: boolean;\n}\n\n\nconst { id } = Astro.params;\n\n\nif (!id) {\n  return Astro.redirect(\"/404\");\n}\n\n\nconst db = getFirestore(app);\nconst friendsRef = db.collection(\"friends\");\nconst friendSnapshot = await friendsRef.doc(id).get();\n\n\nif (!friendSnapshot.exists) {\n  return Astro.redirect(\"/404\");\n}\n\n\nconst friend = friendSnapshot.data() as Friend;\n---\n\n\n<Layout title=\"Edit {friend.name}\">\n  <h1>Edit {friend.name}</h1>\n  <p>Here you can edit or delete your friend's data.</p>\n  <form method=\"post\" action={`/api/friends/${id}`}>\n    <label for=\"name\">Name</label>\n    <input type=\"text\" id=\"name\" name=\"name\" value={friend.name} />\n    <label for=\"age\">Age</label>\n    <input type=\"number\" id=\"age\" name=\"age\" value={friend.age} />\n    <label for=\"isBestFriend\">Is best friend?</label>\n    <input\n      type=\"checkbox\"\n      id=\"isBestFriend\"\n      name=\"isBestFriend\"\n      checked={friend.isBestFriend}\n    />\n    <button type=\"submit\">Edit friend</button>\n  </form>\n  <button type=\"button\" id=\"delete-document\">Delete</button>\n</Layout>\n<script>\n  const deleteButton = document.getElementById(\n    \"delete-document\"\n  ) as HTMLButtonElement;\n  const url = document.querySelector(\"form\")?.getAttribute(\"action\") as string;\n  deleteButton.addEventListener(\"click\", async () => {\n    const response = await fetch(url, {\n      method: \"DELETE\",\n    });\n    if (response.redirected) {\n      window.location.assign(response.url);\n    }\n  });\n</script>\nDisplay an individual record\nSection titled Display an individual record\n\nsrc/pages/friend/[id].astro will display the details of a friend.\n\nsrc/pages/friend/[id].astro\n---\nimport Layout from \"../../layouts/Layout.astro\";\nimport { app } from \"../../firebase/server\";\nimport { getFirestore } from \"firebase-admin/firestore\";\n\n\ninterface Friend {\n  name: string;\n  age: number;\n  isBestFriend: boolean;\n}\n\n\nconst { id } = Astro.params;\n\n\nif (!id) {\n  return Astro.redirect(\"/404\");\n}\n\n\nconst db = getFirestore(app);\nconst friendsRef = db.collection(\"friends\");\nconst friendSnapshot = await friendsRef.doc(id).get();\n\n\nif (!friendSnapshot.exists) {\n  return Astro.redirect(\"/404\");\n}\n\n\nconst friend = friendSnapshot.data() as Friend;\n---\n\n\n<Layout title={friend.name}>\n  <h1>{friend.name}</h1>\n  <p>Age: {friend.age}</p>\n  <p>Is best friend: {friend.isBestFriend ? \"Yes\" : \"No\"}</p>\n</Layout>\nDisplay a list of records with an edit button\nSection titled Display a list of records with an edit button\n\nFinally, src/pages/dashboard.astro will display a list of friends. Each friend will have a link to their details page and an edit button that will redirect the user to the edit page.\n\nsrc/pages/dashboard.astro\n---\nimport { app } from \"../firebase/server\";\nimport { getFirestore } from \"firebase-admin/firestore\";\nimport Layout from \"../layouts/Layout.astro\";\n\n\ninterface Friend {\n  id: string;\n  name: string;\n  age: number;\n  isBestFriend: boolean;\n}\n\n\nconst db = getFirestore(app);\nconst friendsRef = db.collection(\"friends\");\nconst friendsSnapshot = await friendsRef.get();\nconst friends = friendsSnapshot.docs.map((doc) => ({\n  id: doc.id,\n  ...doc.data(),\n})) as Friend[];\n---\n\n\n<Layout title=\"My friends\">\n  <h1>Friends</h1>\n  <ul>\n    {\n      friends.map((friend) => (\n        <li>\n          <a href={`/friend/${friend.id}`}>{friend.name}</a>\n          <span>({friend.age})</span>\n          <strong>{friend.isBestFriend ? \"Bestie\" : \"Friend\"}</strong>\n          <a href={`/edit/${friend.id}`}>Edit</a>\n        </li>\n      ))\n    }\n  </ul>\n</Layout>\n\nAfter creating all the pages, you should have the following file structure:\n\nDirectory\nsrc\nenv.d.ts\nDirectory\nfirebase\nclient.ts\nserver.ts\nDirectory\npages\ndashboard.astro\nadd.astro\nDirectory\nedit\n[id].astro\nDirectory\nfriend\n[id].astro\nDirectory\napi\nDirectory\nfriends\nindex.ts\n[id].ts\n.env\nastro.config.mjs\npackage.json\nCommunity Resources\nSection titled Community Resources\nAstro and Firebase SSR app example\nMore backend service guides\nFirebase\nSupabase\nXata\nAppwrite\nTigris"
  },
  {
    "title": "Authoring Content üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/content/",
    "html": "Authoring Content\n\nAstro is a perfect choice for your content-focused site: blogs, marketing sites, portfolios, and more!\n\nAstro helps you author and present your content. You can write a blog post directly in Astro using Markdown/MDX, or fetch your content from a headless CMS. Astro lets you build a site around your content: you can add a layout to your pages, create an index of posts, and set up an RSS feed to allow readers to subscribe.\n\nWriting Content\nSection titled Writing Content\n\nIn Astro, you can author your content in a variety of ways:\n\nIn Markdown files (.md or alternative extensions), designed to make it easy to write rich text content.\nIn MDX (.mdx) files, which let you include components and dynamic expressions in your document.\nUsing a third-party content management system (CMS), then pulling that content into a .astro page.\nOther options (less commonly used for content-heavy pages) include .astro files and .html files.\nMarkdown Authoring\nSection titled Markdown Authoring\n\nMarkdown is a convenient syntax for writing rich text with basic formatting and common elements like headers, lists, and images. Astro has built-in support for Markdown files in your project.\n\nCreate and write a new .md file in your code editor or bring in an existing file written in your favorite Markdown editor. Some online Markdown editors like StackEdit and Dillinger will even allow you to edit and sync your work with your Astro repository stored on GitHub.\n\nüìö Learn more about writing Markdown content in Astro.\n\nMDX Authoring\nSection titled MDX Authoring\n\nIf you add the MDX integration to your project, you can also write content using .mdx files, which let you include JavaScript expressions and custom components within your Markdown. This includes both static Astro components and interactive framework components. Add UI elements such as a banner or an interactive carousel right in your text to turn your content into full-fledged web pages.\n\nWrite and edit .mdx files directly in your code editor, alongside your project files.\n\nüìö Learn more about using MDX with Astro.\n\nHeadless CMS Authoring\nSection titled Headless CMS Authoring\n\nWrite blog posts in your existing Content Management System (CMS) such as Storyblok, WordPress, or Contentful. Some CMSes, like Storyblok, provide an official Astro integration. Others expose a JavaScript SDK that Astro pages can use to fetch your remote content.\n\nManaging content pages\nSection titled Managing content pages\n\nMarkdown and MDX files that live in your src/pages directory will automatically generate pages on your site using Astro‚Äôs file-based routing, built at a URL corresponding to the post‚Äôs file path.\n\nYou can also choose to keep your Markdown and MDX files outside of the src/pages directory, and instead import their content into .astro pages.\n\nIf you‚Äôre writing your content in a CMS, you can fetch your posts and use dynamic routing to use one .astro file to generate a route for each post. In Astro‚Äôs default static mode, these routes are generated at build time. If you opt-in to SSR mode, you respond to a request at runtime and fetch the content on demand.\n\nShowcasing your content\nSection titled Showcasing your content\n\nTo build common features to organize and display your content, such as a blog archive or a page for each blog tag, Astro allows you to fetch filenames and metadata from your Markdown and MDX frontmatter and use these to generate page content and routes.\n\nRelated recipe:\nAdd an RSS feed\nCommunity Integrations\nSection titled Community Integrations\n\nIn addition to the official @astrojs/mdx integration, there are several third-party community integrations for working with content in your Astro project."
  },
  {
    "title": "Spinal & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/spinal/",
    "html": "Spinal & Astro\n\nSpinal is a commercial, SaaS-focused, Git-based CMS.\n\nGetting started\nSection titled Getting started\nCreate a Spinal account.\nConnect your GitHub account to Spinal.\nSelect your Astro repository when prompted.\n\nAll Markdown content from the selected folder will be imported into your Spinal account and is ready to be edited.\n\nOfficial Resources\nSection titled Official Resources\nDocumentation theme built for Astro with Tailwind CSS\nProduction Sites\nSection titled Production Sites\n\nThe following sites use Astro + Spinal in production:\n\nspinalcms.com (all blog articles, documentation, changelog, feature pages, etc.)\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Sanity & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/sanity/",
    "html": "Sanity & Astro\n\nSanity is a headless content management system that focuses on structured content.\n\nOfficial Resources\nSection titled Official Resources\nBuild your blog with Astro and Sanity\nCommunity Resources\nSection titled Community Resources\n\nUse the astro-sanity integration to add Sanity to your project.\n\nYou can get started with the Astro Sanity Minimal Starter.\n\nVideo: Create your own Blog with Astro and Sanity.io by Jaydan Urwin\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Prismic & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/prismic/",
    "html": "Prismic & Astro\n\nPrismic is a headless content management system.\n\nCommunity Resources\nSection titled Community Resources\nBuilding with Astro & Prismic - w/ Nate Moore (livestream) and the repo from the show.\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "KeystoneJS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/keystonejs/",
    "html": "KeystoneJS & Astro\n\nKeystoneJS is an open source, headless content-management system that allows you to describe the structure of your schema.\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Prepr CMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/preprcms/",
    "html": "Prepr CMS & Astro\n\nPrepr.io, is a headless CMS for building websites with segment targeting.\n\nOfficial Resources\nSection titled Official Resources\nCheck out the Prepr CMS Astro quickstart\nRead Connecting Prepr CMS to Astro\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Directus & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/directus/",
    "html": "Directus & Astro\n\nDirectus is a backend-as-a-service which can be used to host data and content for your Astro project.\n\nOfficial Resources\nSection titled Official Resources\nDirectus provides an example Astro blog template.\nCommunity Resources\nSection titled Community Resources\nAdd yours!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Payload CMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/payload/",
    "html": "Payload CMS & Astro\n\nPayloadCMS is a headless open-source content management system that can be used to provide content for your Astro project.\n\nIntegrating with Astro\nSection titled Integrating with Astro\nPrerequisites\nSection titled Prerequisites\nAn Astro project - If you don‚Äôt have an Astro project yet, our Installation guide will get you up and running in no time.\nA MongoDB database - PayloadCMS will ask you for a MongoDB connection string when creating a new project. You can set one up locally or use MongoDBAtlas to host a database on the web for free.\nA PayloadCMS REST API - Create a PayloadCMS project and connect it to your MongoDB database during the setup.\n\n CHOOSING A TEMPLATE\n\nDuring the PayloadCMS installation, you will be asked if you want to use a template.\n\nChoosing any of the available templates at this step (such as ‚Äòblog‚Äô) automatically generates additional collections for you to use. Otherwise, you will need to manually create your PayloadCMS collections.\n\nConfiguring Astro for your PayloadCMS collection\nSection titled Configuring Astro for your PayloadCMS collection\n\nYour Payload project template will contain a file called Posts.ts in src/collections/. If you did not choose a template during installation that created a content collection for you, you can create a new Payload CMS Collection by adding this configuration file manually. The example below shows this file for a collection called posts that requires title, content, and slug fields:\n\nsrc/collections/Posts.ts\nimport { CollectionConfig } from \"payload/types\";\n\n\nconst Posts: CollectionConfig = {\n  slug: \"posts\",\n  admin: {\n    useAsTitle: \"title\",\n  },\n  access: {\n    read: () => true,\n  },\n\n\n  fields: [\n    {\n      name: \"title\",\n      type: \"text\",\n      required: true,\n    },\n    {\n      name: \"content\",\n      type: \"text\",\n      required: true,\n    },\n    {\n      name: \"slug\",\n      type: \"text\",\n      required: true,\n    },\n  ],\n};\n\n\nexport default Posts;\n\nImport and add both Users (available in all PayloadCMS projects) and any other collections (e.g. Posts) to the available collections in the payload.config.ts file.\n\nsrc/payload.config.ts\nimport { buildConfig } from \"payload/config\";\nimport path from \"path\";\n\n\nimport Users from \"./collections/Users\";\nimport Posts from \"./collections/Posts\";\n\n\nexport default buildConfig({\n  serverURL: \"http://localhost:4321\",\n  admin: {\n    user: Users.slug,\n  },\n  collections: [Users, Posts],\n  typescript: {\n    outputFile: path.resolve(__dirname, \"payload-types.ts\"),\n  },\n  graphQL: {\n    schemaOutputFile: path.resolve(__dirname, \"generated-schema.graphql\"),\n  },\n});\n\nThis will make a new collection called ‚ÄúPosts‚Äù appear in your PayloadCMS Dashboard next to the ‚ÄúUsers‚Äù collection.\n\nEnter the ‚ÄúPosts‚Äù collection and create a new post. After saving it, you will notice the API URL appear in the bottom right corner.\n\nWith the dev server running, open http://localhost:4321/api/posts in your browser. You should see a JSON file containing the post you have created as an object.\n\n{\n  \"docs\":[\n      {\n        \"id\":\"64098b16483b0f06a7e20ed4\",\n        \"title\":\"Astro & PayloadCMS Title üöÄ\",\n        \"content\":\"Astro & PayloadCMS Content\",\n        \"slug\":\"astro-payloadcms-slug\",\n        \"createdAt\":\"2023-03-09T07:30:30.837Z\",\n        \"updatedAt\":\"2023-03-09T07:30:30.837Z\"\n      }\n  ],\n  \"totalDocs\":1,\n  \"limit\":10,\n  \"totalPages\":1,\n  \"page\":1,\n  \"pagingCounter\":1,\n  \"hasPrevPage\":false,\n  \"hasNextPage\":false,\n  \"prevPage\":null,\n  \"nextPage\":null\n}\n\n TIP\n\nBy default, both Astro and PayloadCMS will use port 4321. You might want to change the PayloadCMS port in the src/server.ts file. Don‚Äôt forget to update the serverURL in src/payload.config.ts as well.\n\nFetching Data\nSection titled Fetching Data\n\nFetch your PayloadCMS data through your site‚Äôs unique REST API URL and the route for your content. (By default, PayloadCMS will mount all routes through /api.) Then, you can render your data properties using Astro‚Äôs set:html=\"\" directive.\n\nTogether with your post, PayloadCMS will return some top-level metadata. The actual documents are nested within the docs array.\n\nFor example, to display a list of post titles and their content:\n\nsrc/pages/index.astro\n---\nimport HomeLayout from \"../layouts/HomeLayout.astro\";\n\n\nconst res = await fetch(\"http://localhost:5000/api/posts\") // http://localhost:4321/api/posts by default\nconst posts = await res.json()\n---\n\n\n<HomeLayout title='Astro Blog'>\n  {\n    posts.docs.map((post) => (\n        <h2 set:html={post.title} />\n        <p set:html={post.content} />\n    ))\n  }\n</HomeLayout>\nBuilding a blog with PayloadCMS and Astro\nSection titled Building a blog with PayloadCMS and Astro\n\nCreate a blog index page src/pages/index.astro to list each of your posts with a link to its own page.\n\nFetching via the API returns an array of objects (posts) that include, among others, the following properties:\n\ntitle\ncontent\nslug\nsrc/pages/index.astro\n---\nimport HomeLayout from \"../layouts/HomeLayout.astro\";\n\n\nconst res = await fetch(\"http://localhost:5000/api/posts\") // http://localhost:4321/api/posts by default\nconst posts = await res.json()\n---\n\n\n<HomeLayout title='Astro Blog'>\n  <h1>Astro + PayloadCMS üöÄ</h1>\n  <h2>Blog posts list:</h2>\n  <ul>\n    {\n      posts.docs.map((post) =>(\n        <li>\n          <a href={`posts/${post.slug}`} set:html={post.title} />\n        </li>\n      ))\n    }\n  </ul>\n</HomeLayout>\nUsing the PayloadCMS API to generate pages\nSection titled Using the PayloadCMS API to generate pages\n\nCreate a page src/pages/posts/[slug].astro to dynamically generate a page for each post.\n\nsrc/pages/posts/[slug].astro\n---\nimport PostLayout from \"../../layouts/PostLayout.astro\"\n\n\nconst {title, content} = Astro.props\n\n\n// The getStaticPaths() is required for static Astro sites.\n// If using SSR, you will not need this function.\nexport async function getStaticPaths() {\n    let data = await fetch(\"http://localhost:5000/api/posts\")\n    let posts = await data.json()\n\n\n    return posts.docs.map((post) => {\n        return {\n            params: {slug: post.slug},\n            props: {title: post.title, content: post.content},\n        };\n    });\n}\n---\n<PostLayout title={title}>\n    <article>\n        <h1 set:html={title} />\n        <p set:html={content} />\n    </article>\n</PostLayout>\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your site visit our deployment guide and follow the instructions for your preferred hosting provider.\n\nCommunity Resources\nSection titled Community Resources\nTry this Payload CMS & Astro Template.\nCheck out Astroad for easy development and VPS deployment with Docker.\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "microCMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/microcms/",
    "html": "microCMS & Astro\n\nmicroCMS is an API-based headless CMS that lets you define content using schemas, and manage it using the dashboard.\n\nOfficial Resources\nSection titled Official Resources\nCheck out the official microCMS document\nBlog: Build a blog with microCMS\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Decap CMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/decap-cms/",
    "html": "Decap CMS & Astro\n\nDecap CMS (formerly Netlify CMS) is an open-source, Git-based content management system.\n\nCommunity Resources\nSection titled Community Resources\n\nUse the astro-netlify-cms Astro integration to add Netlify CMS to your project.\n\nYou can get started with the Astro Blog Starter with Netlify CMS.\n\nBlog Post: Author your Astro site‚Äôs content with Git-based CMSs by Aftab Alam\n\nYoutube Tutorial: Create a Custom Blog with Astro & NetlifyCMS in MINUTES! by Kumail Pirzada\n\nProduction Sites\nSection titled Production Sites\n\nThe following sites use Astro + Decap CMS in production:\n\nyunielacosta.com by Yuniel Acosta ‚Äî source code on GitHub (Netlify CMS)\nportfolioris.nl by Joris Hulsbosch ‚Äì source code on GitHub\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Crystallize & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/crystallize/",
    "html": "Crystallize & Astro\n\nCrystallize is a headless content management system for eCommerce that exposes a GraphQL API.\n\nExample\nSection titled Example\nsrc/pages/index.astro\n---\n// Fetch your catalogue paths from Crystallize GraphQL API\n\n\nimport BaseLayout from '../../layouts/BaseLayout.astro';\nimport { createClient } from '@crystallize/js-api-client';\n\n\nconst apiClient = createClient({\n  tenantIdentifier: 'furniture'\n});\n\n\nconst query = `\n  query getCataloguePaths{\n    catalogue(language: \"en\", path: \"/shop\") {\n      name\n      children {\n        name\n        path\n      }\n    }\n  }\n`\nconst { data: { catalogue } } = await apiClient.catalogueApi(query)\n---\n<BaseLayout>\n  <h1>{catalogue.name}</h1>\n  <nav>\n    <ul>\n      {catalogue.children.map(child => (\n        <li><a href={child.path}>{child.name}</a></li>\n      ))}\n    </ul>\n  </nav>\n</BaseLayout>\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Headless WordPress & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/wordpress/",
    "html": "Headless WordPress & Astro\n\nWordPress is a content management system that includes its own frontend, but can also be used as a headless CMS to provide content to your Astro project.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nWordPress comes with a built-in WordPress REST API to connect your WordPress data to Astro. You can optionally install WPGraphQL on your site to use GraphQL.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nAn Astro project - If you don‚Äôt have an Astro project yet, our Installation guide will get you up and running in no time.\nA WordPress site - Your site‚Äôs REST API is [YOUR_SITE]/wp-json/wp/v2/ and is available by default with any WordPress site. It is also possible to set up WordPress on a local environment.\nSetting up Credentials\nSection titled Setting up Credentials\n\nYour WordPress REST API is available to external requests for data fetching without authentication by default. This does not allow users to modify your data or site settings and allows you to use your data in your Astro project without any credentials.\n\nYou may choose to require authentication if necessary.\n\nFetching Data\nSection titled Fetching Data\n\nFetch your WordPress data through your site‚Äôs unique REST API URL and the route for your content. (For a blog, this will commonly be posts.) Then, you can render your data properties using Astro‚Äôs set:html={} directive.\n\nFor example, to display a list of post titles and their content:\n\n---\nconst res = await fetch(\"https://[YOUR-SITE]/wp-json/wp/v2/posts\")\nconst posts = await res.json()\n---\n<h1>Astro + WordPress üöÄ</h1>\n{\n  posts.map((post) => (\n      <h2 set:html={post.title.rendered} />\n      <p set:html={post.content.rendered} />\n  ))\n}\n\nThe WordPress REST API includes global parameters such as _fields and embed.\n\nA large quantity of data is available to you via this API, so you may wish to only fetch certain fields. You can restrict your response by adding the _fields parameter to the API URL, for example: [YOUR-SITE]/wp/v2/posts?_fields=author,id,excerpt,title,link\n\nThe API can also return content related to your post, such as a link to the parent post, or to comments on the post. You can add the _embed parameter to the API URL (e.g. [YOUR-SITE]/wp/v2/posts?_embed) to indicate to the server that the response should include these embedded resources.\n\nBuilding a blog with WordPress and Astro\nSection titled Building a blog with WordPress and Astro\n\nThis example fetches data from the public WordPress API of https://norian.studio/dinosaurs/. This WordPress site stores information about individual dinosaurs under the dinos route, just as a blog would store individual blog posts under the posts route.\n\nThis example shows how to reproduce this site structure in Astro: an index page that lists dinosaurs with links to dynamically-generated individual dinosaur pages.\n\n NOTE\n\nTo use Custom Post Types (CPT) in your WordPress API (not just post and page), you will have to configure them in your WordPress dashboard or add REST API Support For Custom Content Types in WordPress.\n\nThis example fetches data from a WordPress site whose content types have already been configured and exposed to the REST API.\n\nDisplaying a list of WordPress posts\nSection titled Displaying a list of WordPress posts\n\nThe page src/pages/index.astro lists each dinosaur, with a description and link to its own page.\n\nDirectory\nsrc/\nDirectory\npages/\nindex.astro\nDirectory\ndinos/\n[slug].astro\nastro.config.mjs\npackage.json\n\nFetching via the API returns an object that includes the properties:\n\ntitle.rendered - Contains the HTML rendering of the title of the post.\ncontent.rendered - Contains the HTML rendering of the content of the post.\nslug - Contains the slug of the post. (This provides the link to the dynamically-generated individual dinosaur pages.)\n/src/pages/index.astro\n---\nimport Layout from \"../layouts/Layout.astro\"\n\n\nlet res = await fetch(\"https://norian.studio/wp-json/wp/v2/dinos\")\nlet posts = await res.json();\n---\n<Layout title=\"Dinos!\">\n  <section>\n    <h1>List of Dinosaurs</h1>\n    {\n      posts.map((post) => (\n        <article>\n          <h2>\n            <a href={`/dinos/${post.slug}/`} set:html={post.title.rendered} />\n          </h2>\n          <Fragment set:html={post.content.rendered} />\n        </article>\n      ))\n    }\n  </section>\n</Layout>\nUsing the WordPress API to generate pages\nSection titled Using the WordPress API to generate pages\n\nThe page src/pages/dinos/[slug].astro dynamically generates a page for each dinosaur.\n\n/src/pages/dinos/[slug].astro\n---\nimport Layout from '../../layouts/Layout.astro';\n\n\nconst { slug } = Astro.params;\n\n\nlet res = await fetch(`https://norian.studio/wp-json/wp/v2/dinos?slug=${slug}`)\nlet [post] = await res.json();\n\n\n// The getStaticPaths() is required for static Astro sites.\n// If using SSR, you will not need this function.\nexport async function getStaticPaths() {\n  let data = await fetch(\"https://norian.studio/wp-json/wp/v2/dinos\")\n  let posts = await data.json();\n\n\n  return posts.map((post) => ({\n    params: { slug: post.slug },\n    props: { post: post },\n  }));\n}\n---\n<Layout title={post.title.rendered}>\n  <article>\n    <h1 set:html={post.title.rendered} />\n    <Fragment set:html={post.content.rendered} />\n  </article>\n</Layout>\nReturning embedded resources\nSection titled Returning embedded resources\n\nThe _embed query parameter instructs the server to return related (embedded) resources.\n\nsrc/pages/dinos/[slug].astro\n---\nconst { slug } = Astro.params;\n\n\nlet res = await fetch(`https://norian.studio/wp-json/wp/v2/dinos?slug=${slug}&_embed`)\nlet [post] = await res.json();\n---\n\nThe _embedded['wp:featuredmedia']['0'].media_details.sizes.medium.source_url property is returned, and can be used to display the featured image on each dinosuar page. (Replace medium with your desired image size.)\n\n/src/pages/dinos/[slug].astro\n<Layout title={post.title.rendered}>\n  <article>\n    <img src={post._embedded['wp:featuredmedia']['0'].media_details.sizes.medium.source_url} />\n    <h1 set:html={post.title.rendered} />\n    <Fragment set:html={post.content.rendered} />\n  </article>\n</Layout>\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your site visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nCommunity Resources\nSection titled Community Resources\nBuilding An Astro Website With WordPress As A Headless CMS by Chris Bongers.\nBuilding with Astro x WordPress on Ben Holmes‚Äôs stream.\nBuilding a Headless WordPress Site with Astro by Jeff Everhart.\nAstro and WordPress as an API by Darko Bozhinovski.\nProduction Sites\nSection titled Production Sites\n\nThe following sites use Astro + WordPress in production:\n\nSoft Hard System by Rafid Muhymin Wafi ‚Äî source code on GitHub\nDinos! by Anindo Neel Dutta ‚Äî source code on GitHub\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Caisy & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/caisy/",
    "html": "Caisy & Astro\n\nCaisy is a headless CMS that exposes a GraphQL API to access content.\n\nUsing Caisy CMS with Astro\nSection titled Using Caisy CMS with Astro\n\nUse graphql-request and Caisy‚Äôs rich text renderer for Astro to fetch your CMS data and display your content on an Astro page:\n\nsrc/pages/blog/[...slug].astro\n---\nimport RichTextRenderer from '@caisy/rich-text-astro-renderer';\nimport { gql, GraphQLClient } from 'graphql-request';\n\n\nconst params = Astro.params;\n\n\nconst client = new GraphQLClient(\n  `https://cloud.caisy.io/api/v3/e/${import.meta.env.CAISY_PROJECT_ID}/graphql`,\n  {\n    headers: {\n      'x-caisy-apikey': import.meta.env.CAISY_API_KEY\n    }\n  }\n);\nconst gqlResponse = await client.request(\n  gql`\n    query allBlogArticle($slug: String) {\n      allBlogArticle(where: { slug: { eq: $slug } }) {\n        edges {\n          node {\n            text {\n              json\n            }\n            title\n            slug\n            id\n          }\n        }\n      }\n    }\n  `,\n  { slug: params.slug }\n);\n\n\nconst post = gqlResponse?.allBlogArticle?.edges?.[0]?.node;\n---\n<h1>{post.title}</h1>\n<RichTextRenderer node={post.text.json} />\nOfficial Resources\nSection titled Official Resources\nCheck out the Caisy + Astro example on GitHub or Stackblitz\nQuery your documents in draft mode and multiple locales.\nUse pagination to query large numbers of documents.\nUse filter in your queries and order the results\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "CloudCannon & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/cloudcannon/",
    "html": "CloudCannon & Astro\n\nCloudCannon is a Git-based content management system that provides a visual editor for your content.\n\nOfficial Resources\nSection titled Official Resources\nAstro Starter Guide\nBookshop & Astro Guide\nAstro Beginner Tutorial Series\nBlog: How CloudCannon‚Äôs live editing works with Astro and Bookshop\nBlog: Out-of-this-world support for all Astro users\nCommunity Resources\nSection titled Community Resources\nCloudCannon announces official support for Astro\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nKnow more about how to use this CMS with Astro? More CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Tina CMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/tina-cms/",
    "html": "Tina CMS & Astro\n\nTina CMS is a Git-backed headless content management system.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nTo get started, you‚Äôll need an existing Astro project.\n\nRun the following command to install Tina into your Astro project.\n\nnpm\npnpm\nYarn\nTerminal window\nnpx @tinacms/cli@latest init\nWhen prompted for a Cloud ID, press Enter to skip. You‚Äôll generate one later if you want to use Tina Cloud.\nWhen prompted ‚ÄúWhat framework are you using‚Äù, choose Other.\nWhen asked where public assets are stored, press Enter.\n\nAfter this has finished, you should now have a .tina folder in the root of your project and a generated hello-world.md file at content/posts.\n\nChange the dev script in package.json:\n\nnpm\npnpm\nYarn\npackage.json\n{\n    \"scripts\": {\n        \"dev\": \"astro dev\",\n        \"dev\": \"tinacms dev -c \\\"astro dev\\\"\"\n    }\n}\n\nTinaCMS is now set up in local mode. Test this by running the dev script, then navigating to /admin/index.html#/collections/post.\n\nEditing the ‚ÄúHello, World!‚Äù post will update the content/posts/hello-world.md file in your project directory.\n\nSet up your Tina collections by editing the schema.collections property in .tina/config.ts.\n\nFor example, you can add a required ‚Äúdate posted‚Äù frontmatter property to our posts:\n\n.tina/config.ts\nimport { defineConfig } from \"tinacms\";\n\n\n// Your hosting provider likely exposes this as an environment variable\nconst branch = process.env.HEAD || process.env.VERCEL_GIT_COMMIT_REF || \"main\";\n\n\nexport default defineConfig({\n  branch,\n  clientId: null, // Get this from tina.io\n  token: null, // Get this from tina.io\n  build: {\n    outputFolder: \"admin\",\n    publicFolder: \"public\",\n  },\n  media: {\n    tina: {\n      mediaRoot: \"images\",\n      publicFolder: \"public\",\n    },\n  },\n  schema: {\n    collections: [\n      {\n        name: \"posts\",\n        label: \"Posts\",\n        path: \"src/content/posts\",\n        format: 'mdx',\n        fields: [\n          {\n            type: \"string\",\n            name: \"title\",\n            label: \"Title\",\n            isTitle: true,\n            required: true,\n          },\n          {\n            type: \"datetime\",\n            name: \"posted\",\n            label: \"Date Posted\",\n            required: true,\n          },\n          {\n            type: \"rich-text\",\n            name: \"body\",\n            label: \"Body\",\n            isBody: true,\n          },\n        ],\n      },\n    ],\n  },\n});\n\nLearn more about Tina collections in the Tina docs.\n\nIn production, TinaCMS can commit changes directly to your GitHub repository. To set up TinaCMS for production, you can choose to use Tina Cloud or self-host the Tina Data Layer. You can read more about registering for Tina Cloud in the Tina Docs.\n\nOfficial Resources\nSection titled Official Resources\nTinaCMS Astro integration guide.\nCommunity Resources\nSection titled Community Resources\nAstro Tina Starter with visual editing by Jeff See + Dylan Awalt-Conley\nAstro Tina Starter with basic editing by Tom Bennet\nUsing Astro‚Äôs Image Optimization with Tina\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Headless Statamic & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/statamic/",
    "html": "Headless Statamic & Astro\n\nStatamic is a modern, flat-file CMS. It allows developers to easily create dynamic websites and applications while offering content editors an intuitive and user-friendly interface for managing content.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nStatamic comes with a built-in REST API and GraphQL API to connect your data to Astro.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nREST API and GraphQL API are only available in a pro version of Statamic. You can try the Pro version free on your local machine.\nAn Astro project - If you still need an Astro project, our Installation guide will get you up and running quickly.\nA Statamic site - If you need a Statamic website, this guide will help you get started. Remember to enable REST API or GraphQL API by adding STATAMIC_API_ENABLED=true or STATAMIC_GRAPHQL_ENABLED=true in the .env file and enable required resources in the API configuration file.\n\n CAUTION\n\nAll the examples assume that your website has a collection called posts, that has a blueprint called post, and this blueprint has a title field (fieldtype text) and content (fieldtype markdown).\n\nFetching Data\nSection titled Fetching Data\n\n CAUTION\n\nIf you are using Statamic and Astro on your local machine remember to use 127.0.0.1 instead of localhost when fetching the API.\n\nWhen requesting from the Astro server localhost doesn‚Äôt resolve correctly like it does in the browser, and any fetch to either API will fail.\n\nREST API\nSection titled REST API\n\nFetch your Statamic data from your site‚Äôs REST API URL. By default, it‚Äôs https://[YOUR-SITE]/api/. Then, you can render your data properties using Astro‚Äôs set:html={} directive.\n\nFor example, to display a list of titles and their content from a selected collection:\n\n---\nconst res = await fetch(\"https://[YOUR-SITE]/api/collections/posts/entries?sort=-date\")\nconst posts = await res.json()\n---\n<h1>Astro + Statamic üöÄ</h1>\n{\n  posts.map((post) => (\n      <h2 set:html={post.title} />\n      <p set:html={post.content} />\n  ))\n}\nGraphQL\nSection titled GraphQL\n\nFetch your Statamic data with your site‚Äôs GraphQL API URL. By default, it‚Äôs https://[YOUR-SITE]/graphql/. Then, you can render your data properties using Astro‚Äôs set:html={} directive.\n\nFor example, to display a list of titles and their content from a selected collection:\n\n---\nconst res = await fetch(\"https://[YOUR-SITE]/graphql/\",\n  {\n    method: 'POST',\n    headers: {'Content-Type':'application/json'},\n    body: JSON.stringify({\n      query: `\n        posts: entries(collection: \"posts\", sort: \"date desc\") {\n          data {\n            title\n            ... on Entry_Posts_Post {\n              content\n            }\n          }\n        }\n      `\n    }),\n  });\nconst entries = await res.json()\n---\n<h1>Astro + Statamic üöÄ</h1>\n{\n  entries.data.posts.data.map((post) => (\n      <h2 set:html={post.title} />\n      <p set:html={post.content} />\n  ))\n}\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your Astro site visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nCommunity Resources\nSection titled Community Resources\nHow to build a static site using Statamic as headless CMS\nImplementing Astro live previews in headless Statamic\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Strapi & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/strapi/",
    "html": "Strapi & Astro\n\nStrapi is an open-source, customizable, headless CMS.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nThis guide will build a wrapper function to connect Strapi with Astro.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nAn Astro project - If you don‚Äôt have an Astro project yet, our Installation guide will get you up and running in no time.\nA Strapi CMS server - You can set up a Strapi server on a local environment.\nAdding the Strapi URL in .env\nSection titled Adding the Strapi URL in .env\n\nTo add your Strapi URL to Astro, create a .env file in the root of your project (if one does not already exist) and add the following variable:\n\n.env\nSTRAPI_URL=\"http://127.0.0.1:1337\" // or use your IP address\n\nNow, you can use this environment variable in your Astro project.\n\nIf you would like to have IntelliSense for your environment variable, you can create a env.d.ts file in the src/ directory and configure ImportMetaEnv like this:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly STRAPI_URL: string;\n}\n\nYour root directory should now include the new file(s):\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nCreating the API wrapper\nSection titled Creating the API wrapper\n\nCreate a new file at lib/strapi.ts and add the following wrapper function to interact with the Strapi API:\n\nlib/strapi.ts\ninterface Props {\n  endpoint: string;\n  query?: Record<string, string>;\n  wrappedByKey?: string;\n  wrappedByList?: boolean;\n}\n\n\n/**\n * Fetches data from the Strapi API\n * @param endpoint - The endpoint to fetch from\n * @param query - The query parameters to add to the url\n * @param wrappedByKey - The key to unwrap the response from\n * @param wrappedByList - If the response is a list, unwrap it\n * @returns\n */\nexport default async function fetchApi<T>({\n  endpoint,\n  query,\n  wrappedByKey,\n  wrappedByList,\n}: Props): Promise<T> {\n  if (endpoint.startsWith('/')) {\n    endpoint = endpoint.slice(1);\n  }\n\n\n  const url = new URL(`${import.meta.env.STRAPI_URL}/api/${endpoint}`);\n\n\n  if (query) {\n    Object.entries(query).forEach(([key, value]) => {\n      url.searchParams.append(key, value);\n    });\n  }\n  const res = await fetch(url.toString());\n  let data = await res.json();\n\n\n  if (wrappedByKey) {\n    data = data[wrappedByKey];\n  }\n\n\n  if (wrappedByList) {\n    data = data[0];\n  }\n\n\n  return data as T;\n}\n\nThis function requires an object with the following properties:\n\nendpoint - The enpoint you are fetching.\nquery - The query parameters to add to the end of URL\nwrappedByKey - The data key in the object that wraps your Response.\nwrappedByList - A parameter to ‚Äúunwrap‚Äù the list returned by Strapi, and return only the first item.\nOptional: Creating the Article interface\nSection titled Optional: Creating the Article interface\n\nIf you are using TypeScript, create the following Article interface to correspond to the Strapi content types at src/interfaces/article.ts:\n\nsrc/interfaces/article.ts\nexport default interface Article {\n  id: number;\n  attributes: {\n    title: string;\n    description: string;\n    content: string;\n    slug: string;\n    createdAt: string;\n    updatedAt: string;\n    publishedAt: string;\n  };\n}\n\n NOTE\n\nYou can modify this interface, or create multiple interfaces, to correspond to your own project data.\n\nDirectory\nsrc/\nDirectory\ninterfaces/\narticle.ts\nDirectory\nlib/\nstrapi.ts\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nDisplaying a list of articles\nSection titled Displaying a list of articles\n\nUpdate your home page src/pages/index.astro to display a list of blog posts, each with a description and a link to its own page.\n\nImport the wrapper function and the interface. Add the following API call to fetch your articles and return a list:\n\nsrc/pages/index.astro\n---\nimport fetchApi from '../lib/strapi';\nimport type Article from '../interfaces/article';\n\n\nconst articles = await fetchApi<Article[]>({\n  endpoint: 'articles', // the content type to fetch\n  wrappedByKey: 'data', // the key to unwrap the response\n});\n---\n\nThe API call requests data from http://localhost:1337/api/articles and returns articles: an array of json objects representing your data:\n\n[\n  {\n    id: 1,\n    attributes: {\n      title: \"What's inside a Black Hole\",\n      description: 'Maybe the answer is in this article, or not...',\n      content: \"Well, we don't know yet...\",\n      slug: 'what-s-inside-a-black-hole',\n      createdAt: '2023-05-28T13:19:46.421Z',\n      updatedAt: '2023-05-28T13:19:46.421Z',\n      publishedAt: '2023-05-28T13:19:45.826Z'\n    }\n  },\n  // ...\n]\nUsing data from the articles array returned by the API, display your Strapi blog posts in a list. These posts will link to their own individual pages, which you will create in the next step.\nsrc/pages/index.astro\n---\nimport fetchApi from '../lib/strapi';\nimport type Article from '../interfaces/article';\n\n\nconst articles = await fetchApi<Article[]>({\n  endpoint: 'articles?populate=image',\n  wrappedByKey: 'data',\n});\n---\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>Strapi & Astro</title>\n  </head>\n\n\n  <body>\n    <main>\n      <ul>\n        {\n          articles.map((article) => (\n            <a href={`/blog/${article.attributes.slug}/`}>\n              {article.attributes.title}\n            </a>\n          ))\n        }\n      </ul>\n    </main>\n  </body>\n</html>\nGenerating article pages\nSection titled Generating article pages\n\nCreate the file src/pages/blog/[slug].astro to dynamically generate a page for each article.\n\nDirectory\nsrc/\nDirectory\ninterfaces/\narticle.ts\nDirectory\nlib/\nstrapi.ts\nDirectory\npages/\nindex.astro\nDirectory\nblog/\n[slug].astro\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nStatic site generation\nSection titled Static site generation\n\nIn Astro‚Äôs default static mode (SSG), use getStaticPaths() to fetch your list of articles from Strapi.\n\n---\nimport fetchApi from '../../lib/strapi';\nimport type Article from '../../interfaces/article';\n\n\nexport async function getStaticPaths() {\n  const articles = await fetchApi<Article[]>({\n    endpoint: 'articles',\n    wrappedByKey: 'data',\n  });\n\n\n  return articles.map((article) => ({\n    params: { slug: article.attributes.slug },\n    props: article,\n  }));\n}\ntype Props = Article;\n\n\nconst article = Astro.props;\n---\n\nCreate the template for each page using the properties of each post object.\n\n---\nimport fetchApi from '../../lib/strapi';\nimport type Article from '../../interfaces/article';\n\n\nexport async function getStaticPaths() {\n  const articles = await fetchApi<Article[]>({\n    endpoint: 'articles',\n    wrappedByKey: 'data',\n  });\n\n\n  return articles.map((article) => ({\n    params: { slug: article.attributes.slug },\n    props: article,\n  }));\n}\ntype Props = Article;\n\n\nconst article = Astro.props;\n---\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>{article.attributes.title}</title>\n  </head>\n\n\n  <body>\n    <main>\n      <img src={import.meta.env.STRAPI_URL + article.attributes.image.data.attributes.url} />\n\n\n      <h1>{article.attributes.title}</h1>\n\n\n      <!-- Render plain text -->\n      <p>{article.attributes.content}</p>\n      <!-- Render markdown -->\n      <MyMarkdownComponent>\n        {article.attributes.content}\n      </MyMarkdownComponent>\n      <!-- Render html -->\n      <Fragment set:html={article.attributes.content} />\n    </main>\n  </body>\n</html>\n\n TIP\n\nMake sure to choose the right rendering for your content. For markdown check out our markdown guide. If you are rendering html refer to this guide for safety.\n\nServer-side rendering\nSection titled Server-side rendering\n\nIf you‚Äôve opted into SSR mode with output: server or output: hybrid, generate your dynamic routes using the following code:\n\nCreate the src/pages/blog/[slug].astro file:\n\nsrc/pages/blog/[slug].astro\n---\nimport fetchApi from '../../../lib/strapi';\nimport type Article from '../../../interfaces/article';\n\n\nconst { slug } = Astro.params;\n\n\nlet article: Article;\n\n\ntry {\n  article = await fetchApi<Article>({\n    endpoint: 'articles',\n    wrappedByKey: 'data',\n    wrappedByList: true,\n    query: {\n      'filters[slug][$eq]': slug || '',\n    },\n  });\n} catch (error) {\n  return Astro.redirect('/404');\n}\n---\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>{article.attributes.title}</title>\n  </head>\n\n\n  <body>\n    <main>\n      <img src={import.meta.env.STRAPI_URL + article.attributes.image.data.attributes.url} />\n\n\n      <h1>{article.attributes.title}</h1>\n\n\n      <!-- Render plain text -->\n      <p>{article.attributes.content}</p>\n      <!-- Render markdown -->\n      <MyMarkdownComponent>\n        {article.attributes.content}\n      </MyMarkdownComponent>\n      <!-- Render html -->\n      <Fragment set:html={article.attributes.content} />\n    </main>\n  </body>\n</html>\n\nThis file will fetch and render the page data from Strapi that matches the dynamic slug parameter.\n\nSince you are using a redirect to /404, create a 404 page in src/pages:\n\nsrc/pages/404.astro\n<html lang=\"en\">\n  <head>\n    <title>Not found</title>\n  </head>\n  <body>\n    <p>Sorry, this page does not exist.</p>\n    <img src=\"https://http.cat/404\" />\n  </body>\n</html>\n\nIf the article is not found, the user will be redirected to this 404 page and be greeted by a lovely cat.\n\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your website, visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nRebuild on changes\nSection titled Rebuild on changes\n\nIf your project is using Astro‚Äôs default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Strapi.\n\nNetlify\nSection titled Netlify\n\nTo set up a webhook in Netlify:\n\nGo to your site dashboard and click on Build & deploy.\n\nUnder the Continuous Deployment tab, find the Build hooks section and click on Add build hook.\n\nProvide a name for your webhook and select the branch you want to trigger the build on. Click on Save and copy the generated URL.\n\nVercel\nSection titled Vercel\n\nTo set up a webhook in Vercel:\n\nGo to your project dashboard and click on Settings.\n\nUnder the Git tab, find the Deploy Hooks section.\n\nProvide a name for your webhook and the branch you want to trigger the build on. Click Add and copy the generated URL.\n\nAdding a webhook to Strapi\nSection titled Adding a webhook to Strapi\n\nFollow the Strapi webhooks guide to create a webhook in your Strapi admin panel.\n\nOfficial Resources\nSection titled Official Resources\nStrapi Blog Guide For React by Strapi\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Hygraph & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/hygraph/",
    "html": "Hygraph & Astro\n\nHygraph is a federated content management platform. It exposes a GraphQL endpoint for fetching content.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nIn this section, you‚Äôll create a Hygraph GraphQL endpoint to fetch with Astro.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nA Hygraph account and project. If you don‚Äôt have an account, you can sign up for free and create a new project.\n\nHygraph access permissions - In Project Settings > API Access, configure Public Content API permissions to allow read requests without authentication. If you haven‚Äôt set any permissions, you can click Yes, initialize defaults to add the required permissions to use the ‚ÄúHigh Performance Content API‚Äù.\n\nSetting up the endpoint\nSection titled Setting up the endpoint\n\nTo add your Hygraph endpoint to Astro, create a .env file in the root of your project with the following variable:\n\n.env\nHYGRAPH_ENDPOINT=YOUR_HIGH_PERFORMANCE_API\n\nNow, you should be able to use this environment variable in your project.\n\nIf you would like to have IntelliSense for your environment variables, you can create a env.d.ts file in the src/ directory and configure ImportMetaEnv like this:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly HYGRAPH_ENDPOINT: string;\n}\n\n NOTE\n\nRead more about using environment variables and .env files in Astro.\n\nYour root directory should now include these new files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nFetching data\nSection titled Fetching data\n\nFetch data from your Hygraph project by using the HYGRAPH_ENDPOINT.\n\nFor example, to fetch entries of a blogPosts content type that has a string field title, create a GraphQL query to fetch that content. Then, define the type of the content, and set it as the type of the response.\n\nsrc/pages/index.astro\n---\ninterface Post {\n  title: string;\n}\n\n\nconst query = {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: JSON.stringify({\n    query: `\n      {\n        blogPosts {\n          title\n        }\n      }`,\n  }),\n};\n\n\nconst response = await fetch(import.meta.env.HYGRAPH_ENDPOINT, query);\nconst json = await response.json();\nconst posts: Post[] = json.data.blogPosts;\n---\n\n\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>Astro</title>\n  </head>\n  <body>\n    <h1>Astro</h1>\n    {\n      posts.map((post) => (\n        <div>\n          <h2>{post.title}</h2>\n        </div>\n      ))\n    }\n  </body>\n</html>\nDeploy\nSection titled Deploy\nConfiguring Netlify Webhook\nSection titled Configuring Netlify Webhook\n\nTo set up a webhook in Netlify:\n\nDeploy your site to Netlify with this guide. Remember to add your HYGRAPH_ENDPOINT to the enviroment variables.\n\nThen Go to your Hygraph project dashboard and click on Apps.\n\nGo to the marketplace and search for Netlify and follow the instructions provided.\n\nIf all went good, now you can deploy your website with a click in the Hygraph interface.\n\nCommunity Resources\nSection titled Community Resources\nHygraph + Astro example with marked for markdown parsing\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Kontent.ai & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/kontent-ai/",
    "html": "Kontent.ai & Astro\n\nKontent.ai is a headless CMS that allows you to manage content in a structured and modular way, supported by AI capabilities.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nIn this section, you‚Äôll use the Kontent.ai TypeScript SDK to connect your Kontent.ai project to your Astro application.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you‚Äôll need the following:\n\nKontent.ai project - If you don‚Äôt have a Kontent.ai account yet, sign up for free and create a new project.\n\nDelivery API keys - You will need the Environment ID for published content and the Preview API key for fetching drafts (optional). Both keys are located in the Environment Settings -> API keys tab in Kontent.ai.\n\nSetting up credentials\nSection titled Setting up credentials\n\nTo add your Kontent.ai credentials to Astro, create a .env file in the root of your project with the following variables:\n\n.env\nKONTENT_ENVIRONMENT_ID=YOUR_ENVIRONMENT_ID\nKONTENT_PREVIEW_API_KEY=YOUR_PREVIEW_API_KEY\n\nNow, these environment variables can be used in your Astro project.\n\nIf you would like to get TypeScript IntelliSense for these environment variables, you can create a new env.d.ts file in the src/ directory and configure ImportMetaEnv like this:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly KONTENT_ENVIRONMENT_ID: string;\n  readonly KONTENT_PREVIEW_API_KEY: string;\n}\n\nYour root directory should now include these new files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nInstalling dependencies\nSection titled Installing dependencies\n\nTo connect Astro with your Kontent.ai project, install the Kontent.ai TypeScript SDK:\n\nnpm\npnpm\nYarn\nTerminal window\n  npm install @kontent-ai/delivery-sdk\n\nNext, create a new file called kontent.ts in the src/lib/ directory of your Astro project.\n\nsrc/lib/kontent.ts\nimport { createDeliveryClient } from \"@kontent-ai/delivery-sdk\";\n\n\nexport const deliveryClient = createDeliveryClient({\n    environmentId: import.meta.env.KONTENT_ENVIRONMENT_ID,\n    previewApiKey: import.meta.env.KONTENT_PREVIEW_API_KEY,\n});\n\n NOTE\n\nRead more on getting environment variables in Astro.\n\nThis implementation creates a new DeliveryClient object using credentials from the .env file.\n\n PREVIEWS\n\nThe previewApiKey is optional. When used, you can configure each query to the Delivery API endpoint to return the latest versions of content items regardless of their state in the workflow. Otherwise, only published items are returned.\n\nFinally, the root directory of your Astro project should now include these new files:\n\nDirectory\nsrc/\nDirectory\nlib/\nkontent.ts\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nFetching data\nSection titled Fetching data\n\nThe DeliveryClient is now available to all components. To fetch content, use the DeliveryClient and method chaining to define your desired items. This example shows a basic fetch of blog posts and renders their titles in a list:\n\nsrc/pages/index.astro\n---\nimport { deliveryClient } from \"../lib/kontent\";\n\n\nconst blogPosts = await deliveryClient\n    .items()\n    .type(\"blogPost\")\n    .toPromise()\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n        <ul>\n        {blogPosts.data.items.map(blogPost => (\n            <li>{blogPost.elements.title.value}</li>\n        ))}\n        </ul>\n    </body>\n</html>\n\nYou can find more querying options in the Kontent.ai documentation.\n\nMaking a blog with Astro and Kontent.ai\nSection titled Making a blog with Astro and Kontent.ai\n\nWith the setup above, you are now able to create a blog that uses Kontent.ai as the source of content.\n\nPrerequisites\nSection titled Prerequisites\n\nKontent.ai project - For this tutorial, using a blank project is recommended. If you already have some content types in your content model, you may use them, but you will need to modify the code snippets to match your content model.\n\nAstro project configured for content fetching from Kontent.ai - see above for more details on how to set up an Astro project with Kontent.ai\n\nSetting up content model\nSection titled Setting up content model\n\nIn Kontent.ai, navigate to Content model and create a new content type with the following fields and values:\n\nName: Blog Post\nElements:\nText field\nName: Title\nElement Required: yes\nRich text field\nName: Teaser\nElement Required: yes\nAllowed in this element: only check Text\nRich text field\nName: Content\nElement Required: yes\nDate & time field\nName: Date\nURL slug field\nName: URL slug\nElement Required: yes\nAuto-generate from: select ‚ÄúTitle‚Äù\n\nThen, click on Save Changes.\n\nCreating content\nSection titled Creating content\n\nNow, navigate to Content & assets tab and create a new content item of type Blog Post. Fill the fields using these values:\n\nContent item name: Astro\nTitle: Astro is amazing\nTeaser: Astro is an all-in-one framework for building fast websites faster.\nContent: You can use JavaScript to implement the website functionality, but no client bundle is necessary.\nDate & time: select today\nURL slug: astro-is-amazing\n\nWhen you‚Äôre finished, publish the blog post using the Publish button at the top.\n\nNote: Feel free to create as many blog posts as you like before moving to the next step.\n\nGenerating content model in TypeScript\nSection titled Generating content model in TypeScript\n\nNext, you‚Äôll generate TypeScript types out of your content model.\n\n NOTE\n\nThis step is optional but provides a much better developer experience and allows you to discover potential problems at build time rather than at runtime.\n\nFirst, install the Kontent.ai JS model generator, ts-node, and dotenv:\n\nnpm\npnpm\nYarn\nTerminal window\n  npm install @kontent-ai/model-generator ts-node dotenv\n\nThen, add the following script to package.json:\n\npackage.json\n{\n    ...\n    \"scripts\": {\n        ...\n        \"regenerate:models\": \"ts-node --esm ./generate-models.ts\"\n    },\n}\n\nBecause the types require structural information about your project that is not available in the public API, you also need to add a Content Management API key to the .env file. You can generate the key under Environment settings -> API keys -> Management API.\n\n.env\nKONTENT_ENVIRONMENT_ID=YOUR_ENVIRONMENT_ID\nKONTENT_PREVIEW_API_KEY=YOUR_PREVIEW_API_KEY\nKONTENT_MANAGEMENT_API_KEY=YOUR_MANAGEMENT_API_KEY\n\nFinally, add the script generate-models.ts that configures the model generator to generate the models:\n\ngenerate-models.ts\nimport { generateModelsAsync, textHelper } from '@kontent-ai/model-generator'\nimport { rmSync, mkdirSync } from 'fs'\n\n\nimport * as dotenv from 'dotenv'\ndotenv.config()\n\n\nconst runAsync = async () => {\n  rmSync('./src/models', { force: true, recursive: true })\n  mkdirSync('./src/models')\n\n\n  // change working directory to models\n  process.chdir('./src/models')\n\n\n  await generateModelsAsync({\n    sdkType: 'delivery',\n    apiKey: process.env.KONTENT_MANAGEMENT_API_KEY ?? '',\n    environmentId: process.env.KONTENT_ENVIRONMENT_ID ?? '',\n    addTimestamp: false,\n    isEnterpriseSubscription: false,\n  })\n}\n\n\n// Self-invocation async function\n;(async () => {\n  await runAsync()\n})().catch(err => {\n  console.error(err)\n  throw err\n})\n\nNow, execute it:\n\nnpm\npnpm\nYarn\nTerminal window\n  npm run regenerate:models\nDisplaying a list of blog posts\nSection titled Displaying a list of blog posts\n\nNow you‚Äôre ready to fetch some content. Go to the Astro page where you want to display a list of all blog posts, for example, the homepage index.astro in src/pages.\n\nFetch all blog posts in the frontmatter of the Astro page:\n\nsrc/pages/index.astro\n---\nimport { deliveryClient } from '../lib/kontent';\nimport type { BlogPost } from '../models';\nimport { contentTypes } from '../models/project/contentTypes';\n\n\nconst blogPosts = await deliveryClient\n    .items<BlogPost>\n    .type(contentTypes.blog_post.codename)\n    .toPromise()\n---\n\nIf you skipped the model generation, you can also use an untyped object and string literal to define the type:\n\nconst blogPosts = await deliveryClient\n    .items()\n    .type(\"blogPost\")\n    .toPromise()\n\nThe fetch call will return a response object which contains a list of all blog posts in data.items. In the HTML section of the Astro page, you can use the map() function to list the blog posts:\n\nsrc/pages/index.astro\n---\nimport { deliveryClient } from '../lib/kontent';\nimport type { BlogPost } from '../models';\nimport { contentTypes } from '../models/project/contentTypes';\n\n\nconst blogPosts = await deliveryClient\n    .items<BlogPost>\n    .type(contentTypes.blogPost.codename)\n    .toPromise()\n---\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width\" />\n        <title>Astro</title>\n    </head>\n    <body>\n        <h1>Blog posts</h1>\n        <ul>\n            {blogPosts.data.items.map(blogPost => (\n                <li>\n                    <a href={`/blog/${blogPost.elements.url_slug.value}/`} title={blogPost.elements.title.value}>\n                        {blogPost.elements.title.value}\n                    </a>\n                </li>\n            ))}\n        </ul>\n    </body>\n</html>\nGenerating individual blog posts\nSection titled Generating individual blog posts\n\nThe last step of the tutorial is to generate detailed blog post pages.\n\nStatic site generation\nSection titled Static site generation\n\nIn this section, you‚Äôll use the Static (SSG) Mode with Astro.\n\nFirst, create a file [slug].astro in /src/pages/blog/ which needs to export a function getStaticPaths that collects all data from the CMS:\n\nsrc/pages/blog/[slug].astro\n---\nimport { deliveryClient } from '../../lib/kontent';\nimport type { BlogPost } from '../../models';\nimport { contentTypes } from '../../models/project/contentTypes';\n\n\nexport async function getStaticPaths() {\n    const blogPosts = await deliveryClient\n        .items<BlogPost>()\n        .type(contentTypes.blog_post.codename)\n        .toPromise()\n---\n\nSo far, the function fetches all blog posts from Kontent.ai. The code snippet is exactly the same as what you used on the home page.\n\nNext, the function must export paths and data for each blog post. You named the file [slug].astro, so the param which represents the URL slug is called slug:\n\nsrc/pages/blog/[slug].astro\n---\nimport { deliveryClient } from '../../lib/kontent';\nimport type { BlogPost } from '../../models';\nimport { contentTypes } from '../../models/project/contentTypes';\n\n\nexport async function getStaticPaths() {\n    const blogPosts = await deliveryClient\n        .items<BlogPost>()\n        .type(contentTypes.blog_post.codename)\n        .toPromise()\n\n\n    return blogPosts.data.items.map(blogPost => ({\n        params: { slug: blogPost.elements.url_slug.value },\n        props: { blogPost }\n    }))\n}\n---\n\nThe last part is to provide the HTML template and display each blog post:\n\nsrc/pages/blog/[slug].astro\n---\nimport { deliveryClient } from '../../lib/kontent';\nimport type { BlogPost } from '../../models';\nimport { contentTypes } from '../../models/project/contentTypes';\n\n\nexport async function getStaticPaths() {\n    const blogPosts = await deliveryClient\n        .items<BlogPost>()\n        .type(contentTypes.blog_post.codename)\n        .toPromise()\n\n\n    return blogPosts.data.items.map(blogPost => ({\n        params: { slug: blogPost.elements.url_slug.value },\n        props: { blogPost }\n    }))\n}\n\n\nconst blogPost: BlogPost = Astro.props.blogPost\n---\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width\" />\n        <title>{blogPost.elements.title.value}</title>\n    </head>\n    <body>\n        <article>\n            <h1>{blogPost.elements.title.value}</h1>\n            <Fragment set:html={blogPost.elements.teaser.value} />\n            <Fragment set:html={blogPost.elements.content.value} />\n            <time>{new Date(blogPost.elements.date.value ?? \"\")}</time>\n    </body>\n</html>\n\nNavigate to your Astro preview (http://localhost:4321/blog/astro-is-amazing/ by default) to see the rendered blog post.\n\nServer-side rendering\nSection titled Server-side rendering\n\nIf you‚Äôve opted into SSR mode, you will use dynamic routes to fetch the page data from Kontent.ai.\n\nCreate a new file [slug].astro in /src/pages/blog/ and add the following code. The data fetching is very similar to previous use cases but adds an equalsFilter that lets us find the right blog post based on the used URL:\n\nsrc/pages/blog/[slug].astro\n---\nimport { deliveryClient } from '../../lib/kontent';\nimport type { BlogPost } from '../../models';\nimport { contentTypes } from '../../models/project/contentTypes';\n\n\nconst { slug } = Astro.params\nlet blogPost: BlogPost;\ntry {\n    const data = await deliveryClient\n        .items<BlogPost>()\n        .equalsFilter(contentTypes.blog_post.elements.url_slug.codename, slug ?? '')\n        .type(contentTypes.blog_post.codename)\n        .limitParameter(1)\n        .toPromise()\n    blogPost = data.data.items[0]\n} catch (error) {\n    return Astro.redirect('/404')\n}\n---\n\nIf you‚Äôre not using generated types, you can instead use string literals to define the content item type and the filtered element codename:\n\nconst data = await deliveryClient\n        .items()\n        .equalsFilter(\"url_slug\", slug ?? '')\n        .type(\"blog_post\")\n        .limitParameter(1)\n        .toPromise()\n\nLastly, add the HTML code to render the blog post. This part is the same as with static generation:\n\nsrc/pages/blog/[slug].astro\n---\nimport { deliveryClient } from '../../lib/kontent';\nimport type { BlogPost } from '../../models';\nimport { contentTypes } from '../../models/project/contentTypes';\n\n\nconst { slug } = Astro.params\nlet blogPost: BlogPost;\ntry {\n    const data = await deliveryClient\n        .items<BlogPost>()\n        .equalsFilter(contentTypes.blog_post.elements.url_slug.codename, slug ?? '')\n        .type(contentTypes.blog_post.codename)\n        .limitParameter(1)\n        .toPromise()\n    blogPost = data.data.items[0]\n} catch (error) {\n    return Astro.redirect('/404')\n}\n---\n<html lang=\"en\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width\" />\n        <title>{blogPost.elements.title.value}</title>\n    </head>\n    <body>\n        <article>\n            <h1>{blogPost.elements.title.value}</h1>\n            <Fragment set:html={blogPost.elements.teaser.value} />\n            <Fragment set:html={blogPost.elements.content.value} />\n            <time>{new Date(blogPost.elements.date.value ?? '')}</time>\n    </body>\n</html>\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your website, visit the deployment guides and follow the instructions for your preferred hosting provider.\n\nRebuild on Kontent.ai changes\nSection titled Rebuild on Kontent.ai changes\n\nIf your project is using Astro‚Äôs default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Kontent.ai events.\n\nNetlify\nSection titled Netlify\n\nTo set up a webhook in Netlify:\n\nGo to your site dashboard and click on Build & deploy.\nUnder the Continuous Deployment tab, find the Build hooks section and click on Add build hook.\nProvide a name for your webhook and select the branch you want to trigger the build on. Click on Save and copy the generated URL.\nVercel\nSection titled Vercel\n\nTo set up a webhook in Vercel:\n\nGo to your project dashboard and click on Settings.\nUnder the Git tab, find the Deploy Hooks section.\nProvide a name for your webhook and the branch you want to trigger the build on. Click Add and copy the generated URL.\n\nAdding a webhook to Kontent.ai\n\nIn the Kontent.ai app, go to Environment settings -> Webhooks. Click on Create new webhook and provide a name for your new webhook. Paste in the URL you copied from Netlify or Vercel and select which events should trigger the webhook. By default, for rebuilding your site when published content changes, you only need Publish and Unpublish events under Delivery API triggers. When you‚Äôre finished, click on Save.\n\nNow, whenever you publish a new blog post in Kontent.ai, a new build will be triggered and your blog will be updated.\n\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Keystatic & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/keystatic/",
    "html": "Keystatic & Astro\n\nKeystatic is an open source, headless content-management system that allows you to structure your content and sync it with GitHub.\n\n TIP\n\nIf you‚Äôre starting a new Astro + Keystatic project from scratch, you can use the Keystatic CLI to generate a new project in seconds:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create @keystatic@latest\n\nSelect the Astro template, and you‚Äôll be ready to deploy!\n\nPrerequisites\nSection titled Prerequisites\nAn existing Astro project with server-side rendering (SSR) and output: 'hybrid' configured.\n\n NOTE\n\nIf you intend to sync Keystatic‚Äôs data with GitHub, you will also need a GitHub account with write permissions on the repository for this project.\n\nInstalling dependencies\nSection titled Installing dependencies\n\nAdd both the Markdoc (for content entries) and the React (for the Keystatic Admin UI Dashboard) integrations to your Astro project, using the astro add command for your package manager.\n\nnpm\npnpm\nYarn\nTerminal window\nnpx astro add react markdoc\n\nYou will also need two Keystatic packages:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @keystatic/core @keystatic/astro\nAdding the Astro integration\nSection titled Adding the Astro integration\n\nAdd the Astro integration from @keystatic/astro in your Astro config file:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nimport react from '@astrojs/react'\nimport markdoc from '@astrojs/markdoc'\nimport keystatic from '@keystatic/astro'\n\n\n// https://astro.build/config\nexport default defineConfig({\n  integrations: [react(), markdoc(), keystatic()],\n  output: 'hybrid',\n})\nCreating a Keystatic config file\nSection titled Creating a Keystatic config file\n\nA Keystatic config file is required to define your content schema. This file will also allow you to connect a project to a specific GitHub repository (if you decide to do so).\n\nCreate a file called keystatic.config.ts in the root of the project and add the following code to define both your storage type (local) and a single content collection (posts):\n\nkeystatic.config.ts\nimport { config, fields, collection } from '@keystatic/core';\n\n\nexport default config({\n  storage: {\n    kind: 'local',\n  },\n\n\n  collections: {\n    posts: collection({\n      label: 'Posts',\n      slugField: 'title',\n      path: 'src/content/posts/*',\n      format: { contentField: 'content' },\n      schema: {\n        title: fields.slug({ name: { label: 'Title' } }),\n        content: fields.document({\n          label: 'Content',\n          formatting: true,\n          dividers: true,\n          links: true,\n          images: true,\n        }),\n      },\n    }),\n  },\n});\n\n ALREADY USING CONTENT COLLECTIONS?\n\nIf you are already using content collections in your Astro project, then update the schema above to exactly match the collection(s) defined in your existing schema.\n\nKeystatic is now configured to manage your content based on your schema.\n\nRunning Keystatic locally\nSection titled Running Keystatic locally\n\nTo launch your Keystatic Admin UI dashboard, start Astro‚Äôs dev server:\n\nTerminal window\nnpm run dev\n\nVisit http://127.0.0.1:4321/keystatic in the browser to see the Keystatic Admin UI running.\n\nCreating a new post\nSection titled Creating a new post\n\nIn the Keystatic Admin UI dashboard, click on the ‚ÄúPosts‚Äù collection.\n\nUse the button to create a new post. Add the title ‚ÄúMy First Post‚Äù and some content, then save the post.\n\nThis post should now be visible from your ‚ÄúPosts‚Äù collection. You can view and edit your individual posts from this dashboard page.\n\nReturn to view your Astro project files. You will now find a new .mdoc file inside the src/content/posts directory for this new post:\n\nDirectory\nsrc/\nDirectory\ncontent/\nDirectory\nposts/\nmy-first-post.mdoc\n\nNavigate to that file in your code editor and verify that you can see the Markdown content you entered. For example:\n\n---\ntitle: My First Post\n---\n\n\nThis is my very first post. I am **super** excited!\nRendering Keystatic content\nSection titled Rendering Keystatic content\n\nUse Astro‚Äôs Content Collections API to query and display your posts and collections, just as you would in any Astro project.\n\nDisplaying a collection list\nSection titled Displaying a collection list\n\nThe following example displays a list of each post title, with a link to an individual post page.\n\n---\nimport { getCollection } from 'astro:content'\n\n\nconst posts = await getCollection('posts')\n---\n<ul>\n  {posts.map(post => (\n    <li>\n      <a href={`/posts/${post.slug}`}>{post.data.title}</a>\n    </li>\n  ))}\n</ul>\nDisplaying a single entry\nSection titled Displaying a single entry\n\nTo display content from an individual post, you can import and use the <Content /> component to render your content to HTML:\n\n---\nimport { getEntry } from 'astro:content'\n\n\nconst post = await getEntry('posts', 'my-first-post')\nconst { Content } = await post.render()\n---\n\n\n<main>\n  <h1>{post.data.title}</h1>\n  <Content />\n</main>\n\nFor more information on querying, filtering, displaying your collections content and more, see the full content collections documentation.\n\nDeploying Keystatic + Astro\nSection titled Deploying Keystatic + Astro\n\nTo deploy your website, visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nYou‚Äôll also probably want to connect Keystatic to GitHub so you can manage content on the deployed instance of the project.\n\nOfficial Resources\nSection titled Official Resources\nCheck out the official Keystatic guide\nKeystatic starter template\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Ghost & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/ghost/",
    "html": "Ghost & Astro\n\nGhost is an open-source, headless content management system built on Node.js.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nIn this section, we‚Äôll use the Ghost content API to bring your data into your Astro project.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started you will need to have the following:\n\nAn Astro project - If you don‚Äôt have an Astro project yet, our Installation guide will get you up and running in no time.\n\nA Ghost site - It is assumed that you have a site set up with Ghost. If you don‚Äôt you can set one up on a local environment.\n\nContent API Key - You can make an integration under your site‚Äôs Settings > Integrations. From there you can find your Content API key\n\nSetting up credentials\nSection titled Setting up credentials\n\nTo add your site‚Äôs credentials to Astro, create an .env file in the root of your project with the following variable:\n\n.env\nCONTENT_API_KEY=YOUR_API_KEY\n\nNow, you should be able to use this environment variable in your project.\n\nIf you would like to have IntelliSense for your environment variable, you can create a env.d.ts file in the src/ directory and configure ImportMetaEnv like this:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly CONTENT_API_KEY: string;\n}\n\n TIP\n\nRead more about using environment variables and .env files in Astro.\n\nYour root directory should now include these new files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nInstalling dependencies\nSection titled Installing dependencies\n\nTo connect with Ghost, install the official content API wrapper @tryghost/content-api using the command below for your preferred package manager:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @tryghost/content-api\nMaking a blog with Astro and Ghost\nSection titled Making a blog with Astro and Ghost\n\nWith the setup above, you are now able to create a blog that uses Ghost as the CMS.\n\nPrerequisites\nSection titled Prerequisites\nA Ghost blog\nAn Astro project integrated with the Ghost content API - See integrating with Astro for more details on how to set up an Astro project with Ghost.\n\nThis example will create an index page that lists posts with links to dynamically-generated individual post pages.\n\nFetching Data\nSection titled Fetching Data\n\nYou can fetch your site‚Äôs data with the Ghost content API package.\n\nFirst, create a ghost.ts file under a lib directory.\n\nDirectory\nsrc/\nDirectory\nlib/\nghost.ts\nDirectory\npages/\nindex.astro\nastro.config.mjs\npackage.json\n\nInitialize an API instance with the Ghost API using the API key from the Ghost dashboard‚Äôs Integrations page.\n\nsrc/lib/ghost.ts\nimport GhostContentAPI from '@tryghost/content-api';\n\n\n// Create API instance with site credentials\nexport const ghostClient = new GhostContentAPI({\n    url: 'http://127.0.0.1:2368', // This is the default URL if your site is running on a local environment\n    key: import.meta.env.CONTENT_API_KEY,\n    version: 'v5.0',\n});\nDisplaying a list of posts\nSection titled Displaying a list of posts\n\nThe page src/pages/index.astro will display a list of posts, each with a description and link to its own page.\n\nDirectory\nsrc/\nDirectory\nlib/\nghost.ts\nDirectory\npages/\nindex.astro\nastro.config.mjs\npackage.json\n\nImport ghostClient() in the Astro frontmatter to use the posts.browse() method to access blog posts from Ghost. Set limit: all to retrieve all posts.\n\nsrc/pages/index.astro\n---\nimport { ghostClient } from '../lib/ghost';\nconst posts = await ghostClient.posts\n    .browse({\n        limit: 'all',\n    })\n    .catch((err) => {\n        console.error(err);\n    });\n---\n\nFetching via the content API returns an array of objects containing the properties for each post such as:\n\ntitle - the title of the post\nhtml - the HTML rendering of the content of the post\nfeature_image - the source URL of the featured image of the post\nslug - the slug of the post\n\nUse the posts array returned from the fetch to display a list of blog posts on the page.\n\nsrc/pages/index.astro\n---\nimport { ghostClient } from '../lib/ghost';\nconst posts = await ghostClient.posts\n    .browse({\n        limit: 'all',\n    })\n    .catch((err) => {\n        console.error(err);\n    });\n---\n\n\n<html lang=\"en\">\n    <head>\n        <title>Astro + Ghost üëª</title>\n    </head>\n    <body>\n\n\n        {\n            posts.map((post) => (\n                <a href={`/post/${post.slug}`}>\n                    <h1> {post.title} </h1>\n                </a>\n            ))\n        }\n    </body>\n</html>\nGenerating pages\nSection titled Generating pages\n\nThe page src/pages/post/[slug].astro dynamically generates a page for each post.\n\nDirectory\nsrc/\nDirectory\nlib/\nghost.ts\nDirectory\npages/\nindex.astro\nDirectory\npost/\n[slug].astro\nastro.config.mjs\npackage.json\n\nImport ghostClient() to access blog posts using posts.browse() and return a post as props to each of your dynamic routes.\n\nsrc/pages/post/[slug].astro\n---\nimport { ghostClient } from '../../lib/ghost';\n\n\nexport async function getStaticPaths() {\n    const posts = await ghostClient.posts\n        .browse({\n            limit: 'all',\n        })\n        .catch((err) => {\n            console.error(err);\n        });\n\n\n    return posts.map((post) => {\n        return {\n            params: {\n                slug: post.slug,\n            },\n            props: {\n                post: post,\n            },\n        };\n    });\n}\n\n\nconst { post } = Astro.props;\n---\n\nCreate the template for each page using the properties of each post object.\n\nsrc/pages/post/[slug].astro\n---\nimport { ghostClient } from '../../lib/ghost';\nexport async function getStaticPaths() {\n    const posts = await ghostClient.posts\n        .browse({\n            limit: 'all',\n        })\n        .catch((err) => {\n            console.error(err);\n        });\n    return posts.map((post) => {\n        return {\n            params: {\n                slug: post.slug,\n            },\n            props: {\n                post: post,\n            },\n        };\n    });\n}\nconst { post } = Astro.props;\n---\n<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <title>{post.title}</title>\n    </head>\n    <body>\n        <img src={post.feature_image} alt={post.title} />\n\n\n        <h1>{post.title}</h1>\n        <p>{post.reading_time} min read</p>\n\n\n        <Fragment set:html={post.html} />\n    </body>\n</html>\n\n NOTE\n\n<Fragment /> is a built-in Astro component which allows you to avoid an unnecessary wrapper element. This can be especially useful when fetching HTML from a CMS (e.g. Ghost or WordPress).\n\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your site visit our deployment guide and follow the instructions for your preferred hosting provider.\n\nCommunity Resources\nSection titled Community Resources\nYou can get started with this Astro Ghost Starter.\nAndre Carrera wrote a blog post showing how to use Ghost‚Äôs SDK to embed posts and previews in your Astro project.\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Front Matter CMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/frontmatter-cms/",
    "html": "Front Matter CMS & Astro\n\nFront Matter CMS brings the CMS to your editor, it runs within Visual Studio Code, GitPod, and many more.\n\nIntegration with Astro\nSection titled Integration with Astro\n\nIn this section, we‚Äôll walk through how to add Front Matter CMS to your Astro project.\n\nPrerequisites\nSection titled Prerequisites\nVisual Studio Code\nUse the Astro Blog template to provide the base configuration and sample content to start with Front Matter CMS.\nInstall the Front Matter CMS extension\nSection titled Install the Front Matter CMS extension\n\nYou can get the extension from the Visual Studio Code Marketplace - Front Matter or by clicking on the following link: open Front Matter CMS extension in VS Code\n\nProject initialization\nSection titled Project initialization\n\nOnce Front Matter CMS is installed, you will get a new icon in the Activity Bar. It will open the Front Matter CMS panel in the primary sidebar when you click on it. Follow the next steps to initialize your project:\n\nClick on the Initialize project button in the Front Matter panel\n\nThe welcome screen will open, and you can start initializing the project\n\nClick on the first step to Initialize project\n\nAs Astro is one of the supported frameworks, you can select it from the list\n\nRegister your content folders, in this case, the src/content/blog folder.\n\n NOTE\n\nFolder registration is required to let Front Matter CMS know where it can find and create your content. You can have multiple types of folders like pages, blog, docs, and many more.\n\nYou will be asked to enter the name of the folder. By default, it takes the folder name.\n\n NOTE\n\nThe name gets used during the creation process of new content. For example, having multiple folder registrations allows you to choose the type of content you want to create.\n\nClick on Show the dashboard to open the content dashboard\n\n TIP\n\nOnce Front Matter CMS is initialized, you can open the dashboard as follows:\n\nUsing the keyboard binding: alt + d (Windows & Linux) or options + d (macOS)\nOpen the command palette and search for Front Matter: Open dashboard\nClick on the Front Matter icon on the panel‚Äôs title bar or files.\nProject configuration\nSection titled Project configuration\n\nOnce the project is initialized, you will get a frontmatter.json configuration file and a .frontmatter folder in the root of your project.\n\nDirectory\n.frontmatter/\nDirectory\ndatabase/\nmediaDb.json\nDirectory\nsrc/\nastro.config.mjs\nfrontmatter.json\npackage.json\nContent-type configuration\nSection titled Content-type configuration\n\nContent-types are the way Front Matter CMS manages your content. Each content-type contains a set of fields, which can be defined per type of content you want to use for your website.\n\nThe fields correspond to the front matter of your page content.\n\nYou can configure the content-types in the frontmatter.json file.\n\nOpen the frontmatter.json file\nReplace the frontMatter.taxonomy.contentTypes array with the following content-types configuration:\nfrontmatter.json\n\"frontMatter.taxonomy.contentTypes\": [\n  {\n    \"name\": \"default\",\n    \"pageBundle\": false,\n    \"previewPath\": \"'blog'\",\n    \"filePrefix\": null,\n    \"fields\": [\n      {\n        \"title\": \"Title\",\n        \"name\": \"title\",\n        \"type\": \"string\",\n        \"single\": true\n      },\n      {\n        \"title\": \"Description\",\n        \"name\": \"description\",\n        \"type\": \"string\"\n      },\n      {\n        \"title\": \"Publishing date\",\n        \"name\": \"pubDate\",\n        \"type\": \"datetime\",\n        \"default\": \"{{now}}\",\n        \"isPublishDate\": true\n      },\n      {\n        \"title\": \"Content preview\",\n        \"name\": \"heroImage\",\n        \"type\": \"image\",\n        \"isPreviewImage\": true\n      }\n    ]\n  }\n]\n\n NOTE\n\nThis configuration ensures that the Front Matter content-type matches the content collection schema from the Astro blog template.\n\n TIP\n\nYou can find more information on content-types and the supported fields in the content creation docs section from Front Matter CMS.\n\nPreview your articles in the editor\nSection titled Preview your articles in the editor\n\nFrom the Front Matter CMS panel, click on the Start server button. This action starts the Astro local dev server. Once running, you can open the content dashboard, select one of the articles and click on the Open preview button to open the article in the editor.\n\nCreate new articles\nSection titled Create new articles\n\nOpen the Front Matter CMS Dashboard; you can do this as follows:\n\nOpen the Front Matter CMS‚Äô content dashboard\nClick on the Create content button\nFront Matter will ask you for the title of the article. Fill it in and press enter\nYour new article will be created and opened in the editor. You can start writing your article.\nUsing Markdoc with Front Matter CMS\nSection titled Using Markdoc with Front Matter CMS\n\nTo use Markdoc with Front Matter CMS, you must configure this in the frontMatter.content.supportedFileTypes. This setting lets the CMS know which types of files it can progress.\n\nYou can configure the setting as follows:\n\nfrontmatter.json\n\"frontMatter.content.supportedFileTypes\": [ \"md\", \"markdown\", \"mdx\", \"mdoc\" ]\n\nTo allow your content to be created as Markdoc, specify the fileType property on the content-type.\n\nfrontmatter.json\n\"frontMatter.taxonomy.contentTypes\": [\n  {\n    \"name\": \"default\",\n    \"pageBundle\": false,\n    \"previewPath\": \"'blog'\",\n    \"filePrefix\": null,\n    \"fileType\": \"mdoc\",\n    \"fields\": [\n      {\n        \"title\": \"Title\",\n        \"name\": \"title\",\n        \"type\": \"string\",\n        \"single\": true\n      },\n      {\n        \"title\": \"Description\",\n        \"name\": \"description\",\n        \"type\": \"string\"\n      },\n      {\n        \"title\": \"Publishing date\",\n        \"name\": \"pubDate\",\n        \"type\": \"datetime\",\n        \"default\": \"{{now}}\",\n        \"isPublishDate\": true\n      },\n      {\n        \"title\": \"Content preview\",\n        \"name\": \"heroImage\",\n        \"type\": \"image\",\n        \"isPreviewImage\": true\n      }\n    ]\n  }\n]\nOfficial Resources\nSection titled Official Resources\nFront Matter CMS\nFront Matter CMS - Documentation\nGetting started with Astro and Front Matter CMS\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Builder.io & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/builderio/",
    "html": "Builder.io & Astro\n\nBuilder.io is a visual CMS that supports drag-and-drop content editing for building websites.\n\nThis recipe will show you how to connect your Builder space to Astro with zero client-side JavaScript.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nA Builder account and space - If you don‚Äôt have an account yet, sign up for free and create a new space. If you already have a space with Builder, feel free to use it, but you will need to modify the code to match the model name (blogpost) and custom data fields.\nA Builder API key - This public key will be used to fetch your content from Builder. Read Builder‚Äôs guide on how to find your key.\nSetting up credentials\nSection titled Setting up credentials\n\nTo add your Builder API key and your Builder model name to Astro, create a .env file in the root of your project (if one does not already exist) and add the following variables:\n\n.env\nBUILDER_API_PUBLIC_KEY=YOUR_API_KEY\nBUILDER_BLOGPOST_MODEL='blogpost'\n\nNow, you should be able to use this API key in your project.\n\n NOTE\n\nAt the time of writing, this key is public, so you don‚Äôt have to worry about hiding or encrypting it.\n\nIf you would like to have IntelliSense for your environment variables, you can create a env.d.ts file in the src/ directory and configure ImportMetaEnv like this:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly BUILDER_API_PUBLIC_KEY: string;\n}\n\nYour project should now include these files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nMaking a blog with Astro and Builder\nSection titled Making a blog with Astro and Builder\nCreating a model for a blog post\nSection titled Creating a model for a blog post\n\nThe instructions below create an Astro blog using a Builder model (Type: ‚ÄúSection‚Äù) called blogpost that contains two required text fields: title and slug.\n\n FOR VISUAL TYPES\n\nYou can find videos showing this procedure in one of Builder‚Äôs official tutorials.\n\nIn the Builder app create the model that will represent a blog post: go to the Models tab and click the + Create Model button to create model with the following fields and values:\n\nType: Section\nName: ‚Äúblogpost‚Äù\nDescription: ‚ÄúThis model is for a blog post‚Äù\n\nIn your new model use the + New Custom Field button to create 2 new fields:\n\nText field\n\nName: ‚Äútitle‚Äù\nRequired: Yes\nDefault value ‚ÄúI forgot to give this a title‚Äù\n\n(leave the other parameters as their defaults)\n\nText field\n\nName: ‚Äúslug‚Äù\nRequired: Yes\nDefault value ‚Äúsome-slugs-take-their-time‚Äù\n\n(leave the other parameters as their defaults)\n\nThen click the Save button in the upper right.\n\n SLUGS\n\nThere are some pitfalls with the slug field:\n\nMake sure your slug is not just a number. This seems to break the fetch request to Builder‚Äôs API.\n\nMake sure your slugs are unique, since your site‚Äôs routing will depend on that.\n\nSetting up the preview\nSection titled Setting up the preview\n\nTo use Builder‚Äôs visual editor, create the page src/pages/builder-preview.astro that will render the special <builder-component>:\n\nDirectory\nsrc/\nDirectory\npages/\nbuilder-preview.astro\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\n\nThen add the following content:\n\nsrc/pages/builder-preview.astro\n---\nconst builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;\nconst builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;\n---\n\n\n<html lang=\"en\">\n  <head>\n    <title>Preview for builder.io</title>\n  </head>\n  <body>\n    <header>This is your header</header>\n\n\n    <builder-component model={builderModel} api-key={builderAPIpublicKey}\n    ></builder-component>\n    <script async src=\"https://cdn.builder.io/js/webcomponents\"></script>\n\n\n    <footer>This is your footer</footer>\n  </body>\n</html>\n\nIn the above example, <builder-component> tells Builder where to insert the content from its CMS.\n\nSetting the new route as the preview URL\nSection titled Setting the new route as the preview URL\n\nCopy the full URL of your preview, including the protocol, to your clipboard (e.g. https://{your host}/builder-preview).\n\nGo to the Models tab in your Builder space, pick the model you‚Äôve created and paste the URL from step 1 into the Preview URL field. Make sure the URL is complete and includes the protocol, for example https://.\n\nClick the Save button in the upper right.\n\n TIP\n\nWhen you deploy your site, change the preview URL to match your production URL, for example https://myAwesomeAstroBlog.com/builder-preview.\n\nTesting the preview URL setup\nSection titled Testing the preview URL setup\n\nMake sure your site is live (e.g. your dev server is running) and the /builder-preview route is working.\n\nIn your Builder space under the Content tab, click on New to create a new content entry for your blogpost model.\n\nIn the Builder editor that just opened, you should be able to see the builder-preview.astro page with a big Add Block in the middle.\n\n TROUBLESHOOTING\n\nThings can sometimes go wrong when setting up the preview. If something‚Äôs not right, you can try one of these things:\n\nMake sure the site is live - for example, your dev server is running.\nMake sure that the URLs match exactly - the one in your Astro project and the one set in the Builder app.\nMake sure it‚Äôs the full URL including the protocol, for example https://.\nIf you‚Äôre working in a virtual environment like StackBlitz or Gitpod, you might have to copy and paste the URL again when you restart your workspace, since this usually generates a new URL for your project.\n\nFor more ideas, read Builder‚Äôs troubleshooting guide.\n\nCreating a blog post\nSection titled Creating a blog post\nIn Builder‚Äôs visual editor, create a new content entry with the following values:\ntitle: ‚ÄòFirst post, woohoo!‚Äô\nslug: ‚Äòfirst-post-woohoo‚Äô\nComplete your post using the Add Block button and add a text field with some post content.\nIn the text field above the editor, give your entry a name. This is how it will be listed in the Builder app.\nWhen you‚Äôre ready click the Publish button in the upper right corner.\nCreate as many posts as you like, ensuring that all content entries contain a title and a slug as well as some post content.\nDisplaying a list of blog posts\nSection titled Displaying a list of blog posts\n\nAdd the following content to src/pages/index.astro in order to fetch and display a list of all post titles, each linking to its own page:\n\nsrc/pages/index.astro\n---\n\n\nconst builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;\nconst builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;\n\n\nconst { results: posts } = await fetch(\n  `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams({\n    apiKey: builderAPIpublicKey,\n    fields: [\"data.slug\", \"data.title\"].join(\",\"),\n    cachebust: \"true\",\n  }).toString()}`\n)\n  .then((res) => res.json())\n  .catch();\n---\n\n\n<html lang=\"en\">\n  <head>\n    <title>Blog Index</title>\n  </head>\n  <body>\n    <ul>\n      {\n        posts.map(({ data: { slug, title } }) => (\n          <li>\n            <a href={`/posts/${slug}`}>{title}</a>\n          </li>\n        ))\n      }\n    </ul>\n  </body>\n</html>\n\nFetching via the content API returns an array of objects containing data for each post. The fields query parameter tells Builder which data is included (see highlighted code). slug and title should match the names of the custom data fields you‚Äôve added to your Builder model.\n\nThe posts array returned from the fetch displays a list of blog post titles on the home page. The individual page routes will be created in the next step.\n\n FRAMEWORK INTEGRATIONS\n\nIf you are using a JavaScript framework (e.g. Svelte, Vue, or React) in your Astro project you can use one of Builder‚Äôs integrations as an alternative to making raw fetch calls through the REST API.\n\nGo to your index route and you should be able to see a list of links each with the title of a blog post!\n\nDisplaying a single blog post\nSection titled Displaying a single blog post\n\nCreate the page src/pages/posts/[slug].astro that will dynamically generate a page for each post.\n\nDirectory\nsrc/\nDirectory\npages/\nindex.astro\nDirectory\nposts/\n[slug].astro\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\n\nThis file must contain:\n\nA getStaticPaths() function to fetch slug information from Builder and create a static route for each blog post.\nA fetch() to the Builder API using the slug identifier to return post content and metadata (e.g. a title).\nA <Fragment /> in the template to render the post content as HTML.\n\nEach of these is highlighted in the following code snippet.\n\nsrc/pages/posts/[slug].astro\n---\nexport async function getStaticPaths() {\n  const builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;\n  const builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;\n  const { results: posts } = await fetch(\n    `https://cdn.builder.io/api/v3/content/${builderModel}?${new URLSearchParams(\n      {\n        apiKey: builderAPIpublicKey,\n        fields: [\"data.slug\", \"data.title\"].join(\",\"),\n        cachebust: \"true\",\n      }\n    ).toString()}`\n  )\n    .then((res) => res.json())\n    .catch\n    // ...catch some errors...);\n    ();\n  return [\n    ...posts.map(({ data: { slug, title } }) => [\n      {\n        params: { slug },\n        props: { title },\n      },\n    ]),\n  ];\n}\nconst { slug } = Astro.params;\nconst { title } = Astro.props;\nconst builderModel = import.meta.env.BUILDER_BLOGPOST_MODEL;\nconst builderAPIpublicKey = import.meta.env.BUILDER_API_PUBLIC_KEY;\n// Builder's API requires this field but for this use case the url doesn't seem to matter - the API returns the same HTML\nconst encodedUrl = encodeURIComponent(\"moot\");\nconst { html: postHTML } = await fetch(\n  `https://cdn.builder.io/api/v1/qwik/${builderModel}?${new URLSearchParams({\n    apiKey: builderAPIpublicKey,\n    url: encodedUrl,\n    \"query.data.slug\": slug,\n    cachebust: \"true\",\n  }).toString()}`\n)\n  .then((res) => res.json())\n  .catch();\n---\n<html lang=\"en\">\n  <head>\n    <title>{title}</title>\n  </head>\n  <body>\n    <header>This is your header</header>\n    <article>\n      <Fragment set:html={postHTML} />\n    </article>\n    <footer>The is your footer</footer>\n  </body>\n</html>\n\n NOTE\n\nThe variables builderModel and builderAPIpublicKey need to be created twice, since getStaticPaths() runs in its own isolated scope.\n\nNow when you click on a link on your index route, you will be taken to the individual blog post page.\n\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your website, visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nRebuild on Builder changes\nSection titled Rebuild on Builder changes\n\nIf your project is using Astro‚Äôs default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build whenever you click Publish in the Builder editor.\n\nNetlify\nSection titled Netlify\nGo to your site dashboard, then Site Settings and click on Build & deploy.\nUnder the Continuous Deployment tab, find the Build hooks section and click on Add build hook.\nProvide a name for your webhook and select the branch you want to trigger the build on. Click on Save and copy the generated URL.\nVercel\nSection titled Vercel\nGo to your project dashboard and click on Settings.\nUnder the Git tab, find the Deploy Hooks section.\nProvide a name for your webhook and the branch you want to trigger the build on. Click Add and copy the generated URL.\nAdding a webhook to Builder\nSection titled Adding a webhook to Builder\n\n OFFICIAL RESOURCE\n\nSee Builder‚Äôs guide on adding webhooks for more information.\n\nIn your Builder dashboard, go into your blogpost model. Under Show More Options, select Edit Webhooks at the bottom.\nAdd a new webhook by clicking on Webhook. Paste the URL generated by your hosting provider into the Url field.\nClick on Show Advanced under the URL field and toggle the option to select Disable Payload. With the payload disabled, Builder sends a simpler POST request to your hosting provider, which can be helpful as your site grows. Click Done to save this selection.\n\nWith this webhook in place, whenever you click the Publish button in the Builder editor, your hosting provider rebuilds your site - and Astro fetches the newly published data for you. Nothing to do but lean back and pump out that sweet sweet content!\n\nOfficial resources\nSection titled Official resources\nCheck out the official Builder.io starter project, which uses Astro and SolidJS.\nThe official Builder quickstart guide covers both the use of the REST API as well as data fetching through an integration with a JavaScript framework like Qwik, React or Vue.\nBuilder‚Äôs API explorer can help if you need to troubleshoot your API calls.\nCommunity resources\nSection titled Community resources\nRead Connecting Builder.io‚Äôs Visual CMS to Astro by Yoav Ganbar.\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "DatoCMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/datocms/",
    "html": "DatoCMS & Astro\n\nDatoCMS is a web-based, headless CMS to manage digital content for your sites and apps.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nIn this guide, you will fetch content data from DatoCMS in your Astro project, then display it on a page.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nAn Astro project¬†- If you don‚Äôt have an Astro project yet, you can follow the instructions in our¬†Installation guide.\nA DatoCMS account and project - If you don‚Äôt have an account, you can sign up for a free account.\nThe read-only API Key for your DatoCMS project - You can find it in the admin dashboard of your project, under ‚ÄúSettings‚Äù > ‚ÄúAPI Tokens‚Äù.\nSetting up the credentials\nSection titled Setting up the credentials\n\nCreate a new file (if one does not already exist) named .env in the root of your Astro project. Add a new environment variable as follows, using the API key found in your DatoCMS admin dashboard:\n\n.env\nDATOCMS_API_KEY=YOUR_API_KEY\n\nFor TypeScript support, declare the typing of this environment variable in the env.d.ts file in the src/ folder. If this file does not exist, you can create it and add the following:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly DATOCMS_API_KEY: string;\n}\n\nYour root directory should now include these files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nCreate a Model in DatoCMS\nSection titled Create a Model in DatoCMS\n\nIn the DatoCMS admin dashboard of your project, navigate to ‚ÄúSettings‚Äù > ‚ÄúModels‚Äù and create a new Model called ‚ÄúHome‚Äù with the ‚ÄúSingle Instance‚Äù toggle selected. This will create a home page for your project. In this model, add a new text field for the page title.\n\nNavigate to the ‚ÄúContent‚Äù tab in your project and click on your newly-created home page. You can now add a title. Save the page, and continue.\n\nFetching data\nSection titled Fetching data\n\nIn your Astro project, navigate to the page that will fetch and display your CMS content. Add the following query to fetch the content for home using the DatoCMS GraphQL API.\n\nThis example displays the page title from DatoCMS on src/pages/index.astro:\n\nsrc/pages/index.astro\n---\nconst response = await fetch('https://graphql.datocms.com/', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    Authorization: `Bearer ${import.meta.env.DATOCMS_API_KEY}`,\n  },\n  body: JSON.stringify({\n    query: `query Homepage {\n          home {\n            title\n          }\n        }\n      `,\n  }),\n});\n\n\nconst json = await response.json();\nconst data = json.data.home;\n---\n\n\n<h1>{data.title}</h1>\n\nThis GraphQL query will fetch the title field in the home page from your DatoCMS Project. When you refresh your browser, you should see the title on your page.\n\nAdding Dynamic modular content blocks\nSection titled Adding Dynamic modular content blocks\n\nIf your DatosCMS project includes modular content, then you will need to build a corresponding .astro component for each block of content (e.g. a text section, a video, a quotation block, etc.) that the modular field allows in your project.\n\nThe example below is a <Text /> Astro component for displaying a ‚ÄúMultiple-paragraph text‚Äù block from DatoCMS.\n\nsrc/components/Text.astro\n---\nexport interface TextProps {\n  text: string\n}\n\n\nexport interface Props {\n  item: TextProps\n}\n\n\nconst { item } = Astro.props;\n---\n\n\n<div set:html={item.text} />\n\nTo fetch these blocks, edit your GraphQL query to include the modular content block you created in DatoCMS.\n\nIn this example, the modular content block is named content in DatoCMS. This query also includes the unique _modelApiKey of each item to check which block should be displayed in the modular field, based on which block was chosen by the content author in the DatoCMS editor. Use a switch statement in the Astro template to allow for dynamic rendering based on the data received from the query.\n\nThe following example represents a DatoCMS modular content block that allows an author to choose between a text field (<Text />) and an image (<Image />) rendered on the home page:\n\nsrc/pages/index.astro\n---\nimport Image from '../components/Image.astro';\nimport Text from '../components/Text.astro';\n\n\nconst response = await fetch('https://graphql.datocms.com/', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    Accept: 'application/json',\n    Authorization: `Bearer ${import.meta.env.DATOCMS_API_KEY}`,\n  },\n  body: JSON.stringify({\n    query: `query Homepage {\n          home {\n            title\n            content {\n              ... on ImageRecord {\n                _modelApiKey\n               image{\n                url\n               }\n              }\n              ... on TextRecord {\n                _modelApiKey\n                text(markdown: true)\n              }\n            }\n          }\n        }\n      `,\n  }),\n});\n\n\nconst json = await response.json();\nconst data = json.data.home;\n---\n\n\n<h1>{data.title}</h1>\n{\n  data.content.map((item: any) => {\n    switch (item._modelApiKey) {\n      case 'image':\n        return <Image item={item} />;\n      case 'text':\n        return <Text item={item} />;\n      default:\n        return null;\n    }\n  })\n}\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your website, visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nPublish on DatoCMS content changes\nSection titled Publish on DatoCMS content changes\n\nIf your project is using Astro‚Äôs default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build when you change content in DatoCMS.\n\nNetlify\nSection titled Netlify\n\nTo set up a webhook in Netlify:\n\nGo to your site dashboard and click on Build & deploy.\nUnder the Continuous Deployment tab, find the Build hooks section and click on Add build hook.\nProvide a name for your webhook and select the branch you want to trigger the build on. Click on Save and copy the generated URL.\nVercel\nSection titled Vercel\n\nTo set up a webhook in Vercel:\n\nGo to your project dashboard and click on Settings.\nUnder the Git tab, find the Deploy Hooks section.\nProvide a name for your webhook and the branch you want to trigger the build on. Click Add and copy the generated URL.\nAdding a webhook to DatoCMS\nSection titled Adding a webhook to DatoCMS\n\nIn your DatoCMS project admin dashboard, navigate to the Settings tab and click Webhooks. Click the plus icon to create a new webhook and give it a name. In the URL field, paste the URL generated by your preferred hosting service. As Trigger, select whichever option suits your needs. (For example: build every time a new record is published.)\n\nStarter project\nSection titled Starter project\n\nYou can also check out the Astro blog template on the DatoCMS marketplace to learn how to create a blog with Astro and DatoCMS.\n\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Cosmic & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/cosmic/",
    "html": "Cosmic & Astro\n\nCosmic is a headless CMS that provides an admin dashboard to manage content and an API that can integrate with a diverse range of frontend tools.\n\nPrerequisites\nSection titled Prerequisites\nAn Astro project- If you‚Äôd like to start with a fresh Astro project, read the installation guide. This guide follows a simplified version of the Astro Headless CMS Theme with Tailwind CSS for styling.\nA Cosmic account and Bucket - Create a free Cosmic account if you don‚Äôt have one. After creating your account, you‚Äôll be prompted to create a new empty project. There‚Äôs also a Simple Astro Blog template available (this is the same template as the Astro Headless CMS Theme) to automatically import all of the content used in this guide.\nYour Cosmic API keys - From your Cosmic dasboard, you will need to locate both the Bucket slug and Bucket read key in order to connect to Cosmic.\nIntegrating Cosmic with Astro\nSection titled Integrating Cosmic with Astro\nInstalling Necessary Dependencies\nSection titled Installing Necessary Dependencies\n\nAdd the Cosmic JavaScript SDK to fetch data from your Cosmic Bucket.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @cosmicjs/sdk\nConfiguring API Keys\nSection titled Configuring API Keys\n\nCreate a .env file at the root of your Astro project (if it does not already exist). Add both the Bucket slug and Bucket read key available from your Cosmic dashboard as public environment variables.\n\n.env\nPUBLIC_COSMIC_BUCKET_SLUG=YOUR_BUCKET_SLUG\nPUBLIC_COSMIC_READ_KEY=YOUR_READ_KEY\nFetching Data from Cosmic\nSection titled Fetching Data from Cosmic\n\nCreate a new file called cosmic.js. Place this file inside of the src/lib folder in your project.\n\nAdd the following code to fetch data from Cosmic using the SDK and your environment variables.\n\nThe example below creates a function called getAllPosts() to fetch metadata from Cosmic posts objects:\n\nsrc/lib/cosmic.js\nimport { createBucketClient } from '@cosmicjs/sdk'\n\n\nconst cosmic = createBucketClient({\n  bucketSlug: import.meta.env.PUBLIC_COSMIC_BUCKET_SLUG,\n  readKey: import.meta.env.PUBLIC_COSMIC_READ_KEY\n})\n\n\nexport async function getAllPosts() {\n  const data = await cosmic.objects\n    .find({\n      type: 'posts'\n    })\n    .props('title,slug,metadata,created_at')\n  return data.objects\n}\n\nRead more about queries in the Cosmic documentation.\n\nImport your query function in a .astro component. After fetching data, the results from the query can be used in your Astro template.\n\nThe following example shows fetching metadata from Cosmic posts and passing these values as props to a <Card /> component to create a list of blog posts:\n\nsrc/pages/index.astro\n---\nimport Card from '../components/Card.astro'\nimport { getAllPosts } from '../lib/cosmic'\n\n\nconst data = await getAllPosts()\n---\n\n\n<section>\n  <ul class=\"grid gap-8 md:grid-cols-2\">\n    {\n      data.map((post) => (\n        <Card\n          title={post.title}\n          href={post.slug}\n          body={post.metadata.excerpt}\n          tags={post.metadata.tags.map((tag) => tag)}\n        />\n      ))\n    }\n  </ul>\n</section>\n\nView source code for the Card component\n\nBuilding a Blog with Astro and Cosmic\nSection titled Building a Blog with Astro and Cosmic\n\nYou can manage your Astro blog‚Äôs content using Cosmic and create webhooks to automatically redeploy your website when you update or add new content.\n\nCosmic Content Objects\nSection titled Cosmic Content Objects\n\nThe following instructions assume that you have an Object Type in Cosmic called posts. Each individual blog post is a post that is defined in the Cosmic dashboard with the following Metafields:\n\nText input - Author\nImage - Cover Image\nRepeater - Tags\nText input - Title\nText area - Excerpt\nRich Text - Content\nDisplaying a List of Blog Posts in Astro\nSection titled Displaying a List of Blog Posts in Astro\n\nUsing the same data-fetching method as above, import the getAllPosts() query from your script file and await the data. This function provides metadata about each post which can be displayed dynamically.\n\nThe example below passes these values to a <Card /> component to display a formatted list of blog posts:\n\nsrc/pages/index.astro\n---\nimport Card from '../components/Card.astro'\nimport { getAllPosts } from '../lib/cosmic'\n\n\nconst data = await getAllPosts()\n---\n\n\n<section>\n  <ul class=\"grid gap-8 md:grid-cols-2\">\n    {\n      data.map((post) => (\n        <Card\n          title={post.title}\n          href={post.slug}\n          body={post.metadata.excerpt}\n          tags={post.metadata.tags.map((tag) => tag)}\n        />\n      ))\n    }\n  </ul>\n</section>\nGenerating Individual Blog Posts with Astro\nSection titled Generating Individual Blog Posts with Astro\n\nTo generate an individual page with full content for each blog post, create a dynamic routing page at src/pages/blog/[slug].astro.\n\nThis page will export a getStaticPaths() function to generate a page route at the slug returned from each post object. This function is called at build time and generates and renders all of your blog posts at once.\n\nTo access your data from Cosmic:\n\nQuery Cosmic inside of getStaticPaths() to fetch data about each post and provide it to the function.\nUse each post.slug as a route parameter, creating the URLs for each blog post.\nReturn each post inside of Astro.props, making the post data available to HTML template portion of the page component for rendering.\n\nThe HTML markup below uses various data from Cosmic, such as the post title, cover image, and the rich text content (full blog post content). Use set:html on the element displaying the rich text content from Cosmic to render HTML elements on the page exactly as fetched from Cosmic.\n\nsrc/pages/blog/[slug].astro\n---\nimport { getAllPosts } from '../../lib/cosmic'\nimport { Image } from 'astro:assets'\n\n\nexport async function getStaticPaths() {\n  const data = (await getAllPosts()) || []\n\n\n  return data.map((post) => {\n    return {\n      params: { slug: post.slug },\n      props: { post }\n    }\n  })\n}\n\n\nconst { post } = Astro.props\n---\n\n\n<article class=\"mx-auto max-w-screen-md pt-20\">\n  <section class=\"border-b pb-8\">\n    <h1 class=\"text-4xl font-bold\">{post.title}</h1>\n    <div class=\"my-4\"></div>\n    <span class=\"text-sm font-semibold\">{post.metadata.author?.title}</span>\n  </section>\n  {\n    post.metadata.cover_image && (\n      <Image\n        src={post.metadata.cover_image.imgix_url}\n        format=\"webp\"\n        width={1200}\n        height={675}\n        aspectRatio={16 / 9}\n        quality={50}\n        alt={`Cover image for the blog ${post.title}`}\n        class={'my-12 rounded-md shadow-lg'}\n      />\n    )\n  }\n  <div set:html={post.metadata.content} />\n</article>\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your website, visit the deployment guides and follow the instructions for your preferred hosting provider.\n\nRebuild on Cosmic content updates\nSection titled Rebuild on Cosmic content updates\n\nYou can set up a webhook in Cosmic directly to trigger a redeploy of your site on your hosting platform (e.g. Vercel) whenever you update or add content Objects.\n\nUnder ‚ÄúSettings‚Äù > ‚Äúwebhooks‚Äù, add the URL endpoint from Vercel and select the Object Type you would like to trigger the webhook. Click ‚ÄúAdd webhook‚Äù to save it.\n\nNetlify\nSection titled Netlify\n\nTo set up a webhook in Netlify:\n\nGo to your site dashboard and click on Build & deploy.\nUnder the Continuous Deployment tab, find the Build hooks section and click on Add build hook.\nProvide a name for your webhook and select the branch you want to trigger the build on. Click on Save and copy the generated URL.\nVercel\nSection titled Vercel\n\nTo set up a webhook in Vercel:\n\nGo to your project dashboard and click on Settings.\nUnder the Git tab, find the Deploy Hooks section.\nProvide a name for your webhook and the branch you want to trigger the build on. Click Add and copy the generated URL.\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "ButterCMS & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/buttercms/",
    "html": "ButterCMS & Astro\n\nButterCMS is a headless CMS and blog engine that allows you to publish structured content to use in your project.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\n NOTE\n\nFor a full blog site example, see the Astro + ButterCMS Starter Project.\n\nIn this section, we‚Äôll use the ButterCMS SDK to bring your data into your Astro project. To get started, you will need to have the following:\n\nPrerequisites\nSection titled Prerequisites\n\nAn Astro project - If you don‚Äôt have an Astro project yet, our Installation guide will get you up and running in no time.\n\nA ButterCMS account. If you don‚Äôt have an account, you can sign up for a free trial.\n\nYour ButterCMS API Token - You can find your API Token on the Settings page.\n\nSetup\nSection titled Setup\n\nCreate a .env file in the root of your project and add your API token as an environment variable:\n\n.env\nBUTTER_TOKEN=YOUR_API_TOKEN_HERE\n\n TIP\n\nRead more about using environment variables and .env files in Astro.\n\nInstall the ButterCMS SDK as a dependency:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install buttercms\n\nCreate a buttercms.js file in a new src/lib/ directory in your project:\n\nsrc/lib/buttercms.js\nimport Butter from \"buttercms\";\n\n\nexport const butterClient = Butter(import.meta.env.BUTTER_TOKEN);\n\nThis authenticates the SDK using your API Token and exports it to be used across your project.\n\nFetching Data\nSection titled Fetching Data\n\nTo fetch content, import this client and use one of its retrieve functions.\n\nIn this example, we retrieve a collection that has three fields: a short text name, a number price, and a WYSIWYG description.\n\nsrc/pages/ShopItem.astro\n---\nimport { butterClient } from \"../lib/buttercms\";\nconst response = await butterClient.content.retrieve([\"shopitem\"]);\n\n\ninterface ShopItem {\n  name: string,\n  price: number,\n  description: string,\n}\n\n\nconst items = response.data.data.shopitem as ShopItem[];\n---\n<body>\n  {items.map(item => <div>\n    <h2>{item.name} - ${item.price}</h2>\n    <p set:html={item.description}></p>\n  </div>)}\n</body>\n\nThe interface mirrors the field types. The WYSIWYG description field loads as a string of HTML, and set:html lets you render it.\n\nSimilarly, you can retrieve a page and display its fields:\n\nsrc/pages/ShopItem.astro\n---\nimport { butterClient } from \"../lib/buttercms\";\nconst response = await butterClient.page.retrieve(\"*\", \"simple-page\");\nconst pageData = response.data.data;\n\n\ninterface Fields {\n  seo_title: string,\n  headline: string,\n  hero_image: string,\n}\n\n\nconst fields = pageData.fields as Fields;\n---\n<html>\n  <title>{fields.seo_title}</title>\n  <body>\n    <h1>{fields.headline}</h1>\n    <img src={fields.hero_image} />\n  </body>\n</html>\nOfficial Resources\nSection titled Official Resources\nAstro + ButterCMS Starter Project\nThe full ButterCMS API documentation\nButterCMS‚Äôs JavaScript Guide\nCommunity Resources\nSection titled Community Resources\nAdd yours!\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Contentful & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/contentful/",
    "html": "Contentful & Astro\n\nContentful is a headless CMS that allows you to manage content, integrate with other services, and publish to multiple platforms.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nIn this section, we‚Äôll use the Contentful SDK to connect your Contentful space to Astro with zero client-side JavaScript.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nAn Astro project - If you don‚Äôt have an Astro project yet, our Installation guide will get you up and running in no time.\n\nA Contentful account and a Contentful space. If you don‚Äôt have an account, you can sign up for a free account and create a new Contentful space. You can also use an existing space if you have one.\n\nContentful credentials - You can find the following credentials in your contentful dashboard Settings > API keys. If you don‚Äôt have any API keys, create one by selecting Add API key.\n\nContentful space ID - The ID of your Contentful space.\nContentful delivery access token - The access token to consume published content from your Contentful space.\nContentful preview access token - The access token to consume unpublished content from your Contentful space.\nSetting up credentials\nSection titled Setting up credentials\n\nTo add your Contentful space‚Äôs credentials to Astro, create an .env file in the root of your project with the following variables:\n\n.env\nCONTENTFUL_SPACE_ID=YOUR_SPACE_ID\nCONTENTFUL_DELIVERY_TOKEN=YOUR_DELIVERY_TOKEN\nCONTENTFUL_PREVIEW_TOKEN=YOUR_PREVIEW_TOKEN\n\nNow, you can use these environment variables in your project.\n\nIf you would like to have IntelliSense for your Contentful environment variables, you can create a env.d.ts file in the src/ directory and configure ImportMetaEnv like this:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly CONTENTFUL_SPACE_ID: string;\n  readonly CONTENTFUL_DELIVERY_TOKEN: string;\n  readonly CONTENTFUL_PREVIEW_TOKEN: string;\n}\n\n TIP\n\nRead more about using environment variables and .env files in Astro.\n\nYour root directory should now include these new files:\n\nDirectory\nsrc/\nenv.d.ts\n.env\nastro.config.mjs\npackage.json\nInstalling dependencies\nSection titled Installing dependencies\n\nTo connect with your Contentful space, install both of the following using the single command below for your preferred package manager:\n\ncontentful.js, the official Contentful SDK for JavaScript\nrich-text-html-renderer, a package to render Contentful‚Äôs rich text fields to HTML.\nnpm\npnpm\nYarn\nTerminal window\nnpm install contentful @contentful/rich-text-html-renderer\n\nNext, create a new file called contentful.ts in the src/lib/ directory of your project.\n\nsrc/lib/contentful.ts\nimport contentful from \"contentful\";\n\n\nexport const contentfulClient = contentful.createClient({\n  space: import.meta.env.CONTENTFUL_SPACE_ID,\n  accessToken: import.meta.env.DEV\n    ? import.meta.env.CONTENTFUL_PREVIEW_TOKEN\n    : import.meta.env.CONTENTFUL_DELIVERY_TOKEN,\n  host: import.meta.env.DEV ? \"preview.contentful.com\" : \"cdn.contentful.com\",\n});\n\nThe above code snippet creates a new Contentful client, passing in credentials from the .env file.\n\n CAUTION\n\nWhile in development mode, your content will be fetched from the Contentful preview API. This means that you will be able to see unpublished content from the Contentful web app.\n\nAt build time, your content will be fetched from the Contentful delivery API. This means that only published content will be available at build time.\n\nFinally, your root directory should now include these new files:\n\nDirectory\nsrc/\nenv.d.ts\nDirectory\nlib/\ncontentful.ts\n.env\nastro.config.mjs\npackage.json\nFetching data\nSection titled Fetching data\n\nAstro components can fetch data from your Contentful account by using the contentfulClient and specifying the content_type.\n\nFor example, if you have a ‚ÄúblogPost‚Äù content type that has a text field for a title and a rich text field for content, your component might look like this:\n\n---\nimport { contentfulClient } from \"../lib/contentful\";\nimport { documentToHtmlString } from \"@contentful/rich-text-html-renderer\";\nimport type { EntryFieldTypes } from \"contentful\";\n\n\ninterface BlogPost {\n  contentTypeId: \"blogPost\",\n  fields: {\n    title: EntryFieldTypes.Text\n    content: EntryFieldTypes.RichText,\n  }\n}\n\n\nconst entries = await contentfulClient.getEntries<BlogPost>({\n  content_type: \"blogPost\",\n});\n---\n<body>\n  {entries.items.map((item) => (\n    <section>\n      <h2>{item.fields.title}</h2>\n      <article set:html={documentToHtmlString(item.fields.content)}></article>\n    </section>\n  ))}\n</body>\n\n TIP\n\nIf you have an empty Contentful space, check out setting up a Contentful model to learn how to create a basic blog model for your content.\n\nYou can find more querying options in the Contentful documentation.\n\nMaking a blog with Astro and Contentful\nSection titled Making a blog with Astro and Contentful\n\nWith the setup above, you are now able to create a blog that uses Contentful as the CMS.\n\nPrerequisites\nSection titled Prerequisites\nA Contentful space - For this tutorial we recommend starting with an empty space. If you already have a content model, feel free to use it, but you will need to modify our code snippets to match your content model.\nAn Astro project integrated with the Contentful SDK - See integrating with Astro for more details on how to set up an Astro project with Contentful.\nSetting up a Contentful model\nSection titled Setting up a Contentful model\n\nInside your Contentful space, in the Content model section, create a new content model with the following fields and values:\n\nName: Blog Post\nAPI identifier: blogPost\nDescription: This content type is for a blog post\n\nIn your newly created content type, use the Add Field button to add 5 new fields with the following parameters:\n\nText field\nName: title\nAPI identifier: title (leave the other parameters as their defaults)\nDate and time field\nName: date\nAPI identifier: date\nText field\nName: slug\nAPI identifier: slug (leave the other parameters as their defaults)\nText field\nName: description\nAPI identifier: description\nRich text field\nName: content\nAPI identifier: content\n\nClick Save to save your changes.\n\nIn the Content section of your Contentful space, create a new entry by clicking the Add Entry button. Then, fill in the fields:\n\nTitle: Astro is amazing!\nSlug: astro-is-amazing\nDescription: Astro is a new static site generator that is blazing fast and easy to use.\nDate: 2022-10-05\nContent: This is my first blog post!\n\nClick Publish to save your entry. You have just created your first blog post.\n\nFeel free to add as many blog posts as you want, then switch to your favorite code editor to start hacking with Astro!\n\nDisplaying a list of blog posts\nSection titled Displaying a list of blog posts\n\nCreate a new interface called BlogPost and add it to your contentful.ts file in src/lib/. This interface will match the fields of your blog post content type in Contentful. You will use it to type your blog post entries response.\n\nsrc/lib/contentful.ts\nimport contentful, { EntryFieldTypes } from \"contentful\";\n\n\nexport interface BlogPost {\n  contentTypeId: \"blogPost\",\n  fields: {\n    title: EntryFieldTypes.Text\n    content: EntryFieldTypes.RichText,\n    date: EntryFieldTypes.Date,\n    description: EntryFieldTypes.Text,\n    slug: EntryFieldTypes.Text\n  }\n}\n\n\nexport const contentfulClient = contentful.createClient({\n  space: import.meta.env.CONTENTFUL_SPACE_ID,\n  accessToken: import.meta.env.DEV\n    ? import.meta.env.CONTENTFUL_PREVIEW_TOKEN\n    : import.meta.env.CONTENTFUL_DELIVERY_TOKEN,\n  host: import.meta.env.DEV ? \"preview.contentful.com\" : \"cdn.contentful.com\",\n});\n\nNext, go to the Astro page where you will fetch data from Contentful. We will use the home page index.astro in src/pages/ in this example.\n\nImport BlogPost interface and contentfulClient from src/lib/contentful.ts.\n\nFetch all the entries from Contentful with a content type of blogPost while passing the BlogPost interface to type your response.\n\nsrc/pages/index.astro\n---\nimport { contentfulClient } from \"../lib/contentful\";\nimport type { BlogPost } from \"../lib/contentful\";\n\n\nconst entries = await contentfulClient.getEntries<BlogPost>({\n  content_type: \"blogPost\",\n});\n---\n\nThis fetch call will return an array of your blog posts at entries.items. You can use map() to create a new array (posts) that formats your returned data.\n\nThe example below returns the items.fields properties from our Content model to create a blog post preview, and at the same time, reformats the date to a more readable format.\n\nsrc/pages/index.astro\n---\nimport { contentfulClient } from \"../lib/contentful\";\nimport type { BlogPost } from \"../lib/contentful\";\n\n\nconst entries = await contentfulClient.getEntries<BlogPost>({\n  content_type: \"blogPost\",\n});\n\n\nconst posts = entries.items.map((item) => {\n  const { title, date, description, slug } = item.fields;\n  return {\n    title,\n    slug,\n    description,\n    date: new Date(date).toLocaleDateString()\n  };\n});\n---\n\nFinally, you can use posts in your template to show a preview of each blog post.\n\nsrc/pages/index.astro\n---\nimport { contentfulClient } from \"../lib/contentful\";\nimport type { BlogPost } from \"../lib/contentful\";\n\n\nconst entries = await contentfulClient.getEntries<BlogPost>({\n  content_type: \"blogPost\",\n});\n\n\nconst posts = entries.items.map((item) => {\n  const { title, date, description, slug } = item.fields;\n  return {\n    title,\n    slug,\n    description,\n    date: new Date(date).toLocaleDateString()\n  };\n});\n---\n<html lang=\"en\">\n  <head>\n    <title>My Blog</title>\n  </head>\n  <body>\n    <h1>My Blog</h1>\n    <ul>\n      {posts.map((post) => (\n        <li>\n          <a href={`/posts/${post.slug}/`}>\n            <h2>{post.title}</h2>\n          </a>\n          <time>{post.date}</time>\n          <p>{post.description}</p>\n        </li>\n      ))}\n    </ul>\n  </body>\n</html>\nGenerating individual blog posts\nSection titled Generating individual blog posts\n\nUse the same method to fetch your data from Contentful as above, but this time, on a page that will create a unique page route for each blog post.\n\nStatic site generation\nSection titled Static site generation\n\nIf you‚Äôre using Astro‚Äôs default static mode, you‚Äôll use dynamic routes and the getStaticPaths() function. This function will be called at build time to generate the list of paths that become pages.\n\nCreate a new file named [slug].astro in src/pages/posts/.\n\nAs you did on index.astro, import the BlogPost interface and contentfulClient from src/lib/contentful.ts.\n\nThis time, fetch your data inside a getStaticPaths() function.\n\nsrc/pages/posts/[slug].astro\n---\nimport { contentfulClient } from \"../../lib/contentful\";\nimport type { BlogPost } from \"../../lib/contentful\";\n\n\nexport async function getStaticPaths() {\n  const entries = await contentfulClient.getEntries<BlogPost>({\n    content_type: \"blogPost\",\n  });\n}\n---\n\nThen, map each item to an object with a params and props property. The params property will be used to generate the URL of the page and the props property will be passed to the page component as props.\n\nsrc/pages/posts/[slug].astro\n---\nimport { contentfulClient } from \"../../lib/contentful\";\nimport { documentToHtmlString } from \"@contentful/rich-text-html-renderer\";\nimport type { BlogPost } from \"../../lib/contentful\";\n\n\nexport async function getStaticPaths() {\n  const entries = await contentfulClient.getEntries<BlogPost>({\n    content_type: \"blogPost\",\n  });\n\n\n  const pages = entries.items.map((item) => ({\n    params: { slug: item.fields.slug },\n    props: {\n      title: item.fields.title,\n      content: documentToHtmlString(item.fields.content),\n      date: new Date(item.fields.date).toLocaleDateString(),\n    },\n  }));\n  return pages;\n}\n---\n\nThe property inside params must match the name of the dynamic route. Since our filename is [slug].astro, we use slug.\n\nIn our example, the props object passes three properties to the page:\n\ntitle (a string)\ncontent (a rich text Document converted to HTML using documentToHtmlString)\ndate (formatted using the Date constructor)\n\nFinally, you can use the page props to display your blog post.\n\nsrc/pages/posts/[slug].astro\n---\nimport { contentfulClient } from \"../../lib/contentful\";\nimport { documentToHtmlString } from \"@contentful/rich-text-html-renderer\";\nimport type { BlogPost } from \"../../lib/contentful\";\n\n\nexport async function getStaticPaths() {\n  const { items } = await contentfulClient.getEntries<BlogPost>({\n    content_type: \"blogPost\",\n  });\n  const pages = items.map((item) => ({\n    params: { slug: item.fields.slug },\n    props: {\n      title: item.fields.title,\n      content: documentToHtmlString(item.fields.content),\n      date: new Date(item.fields.date).toLocaleDateString(),\n    },\n  }));\n  return pages;\n}\n\n\nconst { content, title, date } = Astro.props;\n---\n<html lang=\"en\">\n  <head>\n    <title>{title}</title>\n  </head>\n  <body>\n    <h1>{title}</h1>\n    <time>{date}</time>\n    <article set:html={content} />\n  </body>\n</html>\n\nNavigate to http://localhost:4321/ and click on one of your posts to make sure your dynamic route is working!\n\nServer side rendering\nSection titled Server side rendering\n\nIf you‚Äôve opted in to SSR mode, you will use a dynamic route that uses a slug parameter to fetch the data from Contentful.\n\nCreate a [slug].astro page in src/pages/posts. Use Astro.params to get the slug from the URL, then pass that to getEntries:\n\nsrc/pages/posts/[slug].astro\n---\nimport { contentfulClient } from \"../../lib/contentful\";\nimport type { BlogPost } from \"../../lib/contentful\";\n\n\nconst { slug } = Astro.params;\n\n\nconst data = await contentfulClient.getEntries<BlogPost>({\n  content_type: \"blogPost\",\n  \"fields.slug\": slug,\n});\n---\n\nIf the entry is not found, you can redirect the user to the 404 page using Astro.redirect.\n\nsrc/pages/posts/[slug].astro\n---\nimport { contentfulClient } from \"../../lib/contentful\";\nimport type { BlogPost } from \"../../lib/contentful\";\n\n\nconst { slug } = Astro.params;\n\n\ntry {\n  const data = await contentfulClient.getEntries<BlogPost>({\n    content_type: \"blogPost\",\n    \"fields.slug\": slug,\n  });\n} catch (error) {\n  return Astro.redirect(\"/404\");\n}\n---\n\nTo pass post data to the template section, create a post object outside the try/catch block.\n\nUse documentToHtmlString to convert content from a Document to HTML, and use the Date constructor to format the date. title can be left as-is. Then, add these properties to your post object.\n\nsrc/pages/posts/[slug].astro\n---\nimport Layout from \"../../layouts/Layout.astro\";\nimport { contentfulClient } from \"../../lib/contentful\";\nimport { documentToHtmlString } from \"@contentful/rich-text-html-renderer\";\nimport type { BlogPost } from \"../../lib/contentful\";\n\n\nlet post;\nconst { slug } = Astro.params;\ntry {\n  const data = await contentfulClient.getEntries<BlogPost>({\n    content_type: \"blogPost\",\n    \"fields.slug\": slug,\n  });\n  const { title, date, content } = data.items[0].fields;\n  post = {\n    title,\n    date: new Date(date).toLocaleDateString(),\n    content: documentToHtmlString(content),\n  };\n} catch (error) {\n  return Astro.redirect(\"/404\");\n}\n---\n\nFinally, you can reference post to display your blog post in the template section.\n\nsrc/pages/posts/[slug].astro\n---\nimport Layout from \"../../layouts/Layout.astro\";\nimport { contentfulClient } from \"../../lib/contentful\";\nimport { documentToHtmlString } from \"@contentful/rich-text-html-renderer\";\nimport type { BlogPost } from \"../../lib/contentful\";\n\n\nlet post;\nconst { slug } = Astro.params;\ntry {\n  const data = await contentfulClient.getEntries<BlogPost>({\n    content_type: \"blogPost\",\n    \"fields.slug\": slug,\n  });\n  const { title, date, content } = data.items[0].fields;\n  post = {\n    title,\n    date: new Date(date).toLocaleDateString(),\n    content: documentToHtmlString(content),\n  };\n} catch (error) {\n  return Astro.redirect(\"/404\");\n}\n---\n<html lang=\"en\">\n  <head>\n    <title>{post?.title}</title>\n  </head>\n  <body>\n    <h1>{post?.title}</h1>\n    <time>{post?.date}</time>\n    <article set:html={post?.content} />\n  </body>\n</html>\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your website, visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nRebuild on Contentful changes\nSection titled Rebuild on Contentful changes\n\nIf your project is using Astro‚Äôs default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Contentful events.\n\nNetlify\nSection titled Netlify\n\nTo set up a webhook in Netlify:\n\nGo to your site dashboard and click on Build & deploy.\n\nUnder the Continuous Deployment tab, find the Build hooks section and click on Add build hook.\n\nProvide a name for your webhook and select the branch you want to trigger the build on. Click on Save and copy the generated URL.\n\nVercel\nSection titled Vercel\n\nTo set up a webhook in Vercel:\n\nGo to your project dashboard and click on Settings.\n\nUnder the Git tab, find the Deploy Hooks section.\n\nProvide a name for your webhook and the branch you want to trigger the build on. Click Add and copy the generated URL.\n\nAdding a webhook to Contentful\nSection titled Adding a webhook to Contentful\n\nIn your Contentful space settings, click on the Webhooks tab and create a new webhook by clicking the Add Webhook button. Provide a name for your webhook and paste the webhook URL you copied in the previous section. Finally, hit Save to create the webhook.\n\nNow, whenever you publish a new blog post in Contentful, a new build will be triggered and your blog will be updated.\n\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Storyblok & Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/storyblok/",
    "html": "Storyblok & Astro\n\nStoryblok is a component-based headless CMS that allows you to manage your content using reusable components called Bloks.\n\nIntegrating with Astro\nSection titled Integrating with Astro\n\nIn this section, you will use the Storyblok integration to connect Storyblok to Astro.\n\nPrerequisites\nSection titled Prerequisites\n\nTo get started, you will need to have the following:\n\nAn Astro project - If you don‚Äôt have an Astro project yet, our Installation guide will get you up and running in no time.\n\nA Storyblok account and space - If you don‚Äôt have an account yet, sign up for free and create a new space.\n\nStoryblok Preview token - This token will be used to fetch drafts and published versions of your content. You can find and generate your API token in the Access Tokens tab of your Storyblok space settings.\n\nSetting up credentials\nSection titled Setting up credentials\n\nTo add your Storyblok credentials to Astro, create a .env file in the root of your project with the following variable:\n\n.env\nSTORYBLOK_TOKEN=YOUR_PREVIEW_TOKEN\n\nNow, you should be able to use these environment variables in your project.\n\nYour root directory should now include this new file:\n\nDirectory\nsrc/\n.env\nastro.config.mjs\npackage.json\nInstalling dependencies\nSection titled Installing dependencies\n\nTo connect Astro with your Storyblok space, install the official Storyblok integration using the command below for your preferred package manager:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @storyblok/astro vite\nConfiguring Storyblok\nSection titled Configuring Storyblok\n\nModify your Astro config file to include the Storyblok integration:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport storyblok from '@storyblok/astro';\nimport { loadEnv } from 'vite';\n\n\nconst env = loadEnv(\"\", process.cwd(), 'STORYBLOK');\n\n\nexport default defineConfig({\n  integrations: [\n    storyblok({\n      accessToken: env.STORYBLOK_TOKEN,\n      components: {\n        // Add your components here\n      },\n      apiOptions: {\n        // Choose your Storyblok space region\n        region: 'us', // optional,  or 'eu' (default)\n      },\n    })\n  ],\n});\n\nThe Storyblok integration requires an object with the following properties:\n\naccessToken - This references the Storyblok API token that you added in the previous step.\n\n TIP\n\nSince the Astro config file does not normally support environment variables, use the loadEnv function from Vite to load them.\n\ncomponents - An object that maps Storyblok component names to paths to your local components. This is required to render your Storyblok Bloks in Astro.\n\n NOTE\n\nThe component paths are relative to the src directory. For example, if your component is located at src/storyblok/MyComponent.astro, the path would be storyblok/MyComponent (without the .astro extension).\n\napiOptions - An object containing Storyblok API options.\n\n CAUTION\n\nBy default, the region is eu. If your Storyblok space was created in the US region, you will need to set the region to us.\n\nConnecting Bloks to Astro components\nSection titled Connecting Bloks to Astro components\n\nTo connect your Bloks to Astro, create a new folder named storyblok in the src directory. This folder will contain all the Astro components that will match your Bloks in your Storyblok Blok library.\n\nIn this example, you have a blogPost Blok content type in your Storyblok library with the following fields:\n\ntitle - A text field\ndescription - A text field\ncontent - A rich text field\n\nOur goal is to create the equivalent Astro component that will use these fields to render its content. To do this, create a new file named BlogPost.astro inside src/storyblok with the following content:\n\nsrc/storyblok/BlogPost.astro\n---\nimport { storyblokEditable, renderRichText } from '@storyblok/astro'\n\n\nconst { blok } = Astro.props\nconst content = renderRichText(blok.content)\n---\n\n\n<article {...storyblokEditable(blok)}>\n  <h1>{blok.title}</h1>\n  <p>{blok.description}</p>\n  <Fragment set:html={content} />\n</article>\n\nThe blok property contains the data that you will receive from Storyblok. It also contains the fields that were defined in the blogPost content type Blok in Storyblok.\n\nTo render our content, the integration provides utility functions such as:\n\nstoryblokEditable - it adds the necessary attributes to the elements so that you can edit them in Storyblok.\nrenderRichText - it transforms the rich text field into HTML.\n\nYour root directory should include this new file:\n\nDirectory\nsrc/\nDirectory\nstoryblok/\nBlogPost.astro\n.env\nastro.config.mjs\npackage.json\n\nFinally, to connect the blogPost Blok to the BlogPost component, add a new property to your components object in your Astro config file.\n\nThe key is the name of the Blok in Storyblok. In this case, it is blogPost.\nThe value is the path to the component. In this case, it is storyblok/BlogPost.\n\n CAUTION\n\nThe key should exactly match your Blok name in Storyblok to be referenced correctly. If these don‚Äôt match, or you‚Äôre trying to reference a component that doesn‚Äôt exist in Storyblok, you‚Äôll get an error.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport storyblok from '@storyblok/astro';\nimport { loadEnv } from 'vite';\n\n\nconst env = loadEnv(\"\", process.cwd(), 'STORYBLOK');\n\n\nexport default defineConfig({\n  integrations: [\n    storyblok({\n      accessToken: env.STORYBLOK_TOKEN,\n      components: {\n        blogPost: 'storyblok/BlogPost',\n      },\n      apiOptions: {\n        region: 'us',\n      },\n    })\n  ],\n});\nFetching data\nSection titled Fetching data\n\nTo test the setup, in Storyblok create a new story with the blogPost content type named test-post. In Astro, create a new page in the src/pages/ directory named test-post.astro with the following content:\n\nsrc/pages/test-post.astro\n---\nimport { useStoryblokApi } from '@storyblok/astro'\nimport StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'\n\n\nconst storyblokApi = useStoryblokApi()\n\n\nconst { data } = await storyblokApi.get(\"cdn/stories/test-post\", {\n  version: import.meta.env.DEV ? \"draft\" : \"published\",\n});\n\n\nconst content = data.story.content;\n---\n<StoryblokComponent blok={content} />\n\nTo query your data, use the useStoryblokApi hook. This will initialize a new client instance using your integration configuration.\n\nTo render your content, pass the content property of the Story to the StoryblokComponent as a blok prop. This component will render the Bloks that are defined inside the content property. In this case, it will render the BlogPost component.\n\nMaking a blog with Astro and Storyblok\nSection titled Making a blog with Astro and Storyblok\n\nWith the integration set up, you can now create a blog with Astro and Storyblok.\n\nPrerequisites\nSection titled Prerequisites\n\nA Storyblok space - For this tutorial, we recommend using a new space. If you already have a space with Bloks, feel free to use them, but you will need to modify the code to match the Blok names and content types.\n\nAn Astro project integrated with Storyblok - See integrating with Astro for instructions on how to set up the integration.\n\nCreating a blok library\nSection titled Creating a blok library\n\nTo create Bloks, go to the Storyblok app and click on the Block Library tab. Click on the + New blok button and create the following Bloks:\n\nblogPost - A content type Blok with the following fields:\n\ntitle - A text field\ndescription - A text field\ncontent - A rich text field\n\nblogPostList - An empty nestable Blok\n\npage - A content type Blok with the following fields:\n\nbody - A nestable Blok\nCreating content\nSection titled Creating content\n\nTo add new content, go to the content section by clicking on the Content tab. Using the Blok library that you created in the previous step, create the following stories:\n\nhome - A content type story with the page Blok. Inside the body field, add a blogPostList Blok.\n\nblog/no-javascript - A story with the blogPost content type inside the blog folder.\n\ntitle: No JavaScript\ndescription: A sample blog post\ncontent: Hi there! This blog post doesn't use JavaScript.\n\nblog/astro-is-amazing - A story with the blogPost content type inside the blog folder.\n\ntitle: Astro is amazing\ndescription: We love Astro\ncontent: Hi there! This blog post was build with Astro.\n\nNow that you have your content ready, return to your Astro project and start building your blog.\n\nConnecting Bloks to components\nSection titled Connecting Bloks to components\n\nTo connect your newly created Bloks to Astro components, create a new folder named storyblok in your src directory and add the following files:\n\nPage.astro is a nestable Block content type component that will recursively render all the Bloks inside the body property of the page Blok. It also adds the storyblokEditable attributes to the parent element which will allow us to edit the page in Storyblok.\n\nsrc/storyblok/Page.astro\n---\nimport { storyblokEditable } from '@storyblok/astro'\nimport StoryblokComponent from '@storyblok/astro/components/StoryblokComponent';\nconst { blok } = Astro.props\n---\n\n\n<main {...storyblokEditable(blok)}>\n  {\n    blok.body?.map((blok) => {\n      return <StoryblokComponent blok={blok} />\n    })\n  }\n</main>\n\nBlogPost.astro will render the title, description and content properties of the blogPost Blok.\n\nTo transform the content property from a rich text field to HTML, you can use the renderRichText helper function.\n\nsrc/storyblok/BlogPost.astro\n---\nimport { storyblokEditable, renderRichText } from '@storyblok/astro'\nconst { blok } = Astro.props\nconst content = renderRichText(blok.content)\n---\n<article {...storyblokEditable(blok)}>\n  <h1>{blok.title}</h1>\n  <p>{blok.description}</p>\n  <Fragment set:html={content} />\n</article>\n\nBlogPostList.astro is a nestable Blok content type component that will render a list of blog post previews.\n\nIt uses the useStoryblokApi hook to fetch all the stories with the content type of blogPost. It uses the version query parameter to fetch the draft versions of the stories when in development mode and the published versions when building for production.\n\nAstro.props is used to set up the editor in Storyblok. Additional props can also be passed to your component here, if needed.\n\nsrc/storyblok/BlogPostList.astro\n---\nimport { storyblokEditable } from '@storyblok/astro'\nimport { useStoryblokApi } from '@storyblok/astro'\n\n\nconst storyblokApi = useStoryblokApi();\n\n\nconst { data } = await storyblokApi.get('cdn/stories', {\n  version: import.meta.env.DEV ? \"draft\" : \"published\",\n  content_type: 'blogPost',\n})\n\n\nconst posts = data.stories.map(story => {\n  return {\n    title: story.content.title,\n    date: new Date(story.published_at).toLocaleDateString(\"en-US\", {dateStyle: \"full\"}),\n    description: story.content.description,\n    slug: story.full_slug,\n  }\n})\n\n\nconst { blok } = Astro.props\n---\n\n\n<ul {...storyblokEditable(blok)}>\n  {posts.map(post => (\n    <li>\n      <time>{post.date}</time>\n      <a href={post.slug}>{post.title}</a>\n      <p>{post.description}</p>\n    </li>\n  ))}\n</ul>\n\nFinally, add your components to the components property of the storyblok config object in astro.config.mjs. The key is the name of the Blok in Storyblok, and the value is the path to the component relative to src.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport storyblok from '@storyblok/astro';\nimport { loadEnv } from 'vite';\n\n\nconst env = loadEnv(\"\", process.cwd(), 'STORYBLOK');\n\n\nexport default defineConfig({\n  integrations: [\n    storyblok({\n      accessToken: env.STORYBLOK_TOKEN,\n      components: {\n        blogPost: 'storyblok/BlogPost',\n        blogPostList: 'storyblok/BlogPostList',\n        page: 'storyblok/Page',\n      },\n      apiOptions: {\n        region: 'us',\n      },\n    })\n  ],\n});\nGenerating pages\nSection titled Generating pages\n\nTo create a route for a specific page, you can fetch its content directly from the Storyblok API and pass it to the StoryblokComponent component. Remember to make sure you have added the Page component to your astro.config.mjs.\n\nCreate an index.astro file in src/pages/ to render the home page:\n\nsrc/pages/index.astro\n---\nimport { useStoryblokApi } from '@storyblok/astro'\nimport StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'\nimport BaseLayout from '../layouts/BaseLayout.astro'\n\n\nconst storyblokApi = useStoryblokApi();\nconst { data } = await storyblokApi.get('cdn/stories/home', {\n  version: import.meta.env.DEV ? \"draft\" : \"published\",\n});\nconst content = data.story.content;\n---\n<html lang=\"en\">\n  <head>\n    <title>Storyblok & Astro</title>\n  </head>\n  <body>\n    <StoryblokComponent blok={content} />\n  </body>\n</html>\n\nTo generate pages for all of your blog posts, create a .astro page that will create dynamic routes. This approach varies depending on whether you‚Äôre using static site generation (the default) or server-side rendering.\n\nStatic site generation\nSection titled Static site generation\n\nIf you are using Astro‚Äôs default static site generation, you will use dynamic routes and the getStaticPaths function to generate your project pages.\n\nCreate a new directory src/pages/blog/ and add a new file called [...slug].astro with the following code:\n\nsrc/pages/blog/[...slug].astro\n---\nimport { useStoryblokApi } from '@storyblok/astro'\nimport StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'\n\n\nexport async function getStaticPaths() {\n  const sbApi = useStoryblokApi();\n\n\n  const { data } = await sbApi.get(\"cdn/stories\", {\n    content_type: \"blogPost\",\n    version: import.meta.env.DEV ? \"draft\" : \"published\",\n  });\n\n\n  const stories = Object.values(data.stories);\n\n\n  return stories.map((story) => {\n    return {\n      params: { slug: story.slug },\n    };\n  });\n}\n\n\nconst sbApi = useStoryblokApi();\nconst { slug } = Astro.params;\nconst { data } = await sbApi.get(`cdn/stories/blog/${slug}`, {\n  version: import.meta.env.DEV ? \"draft\" : \"published\",\n});\n\n\nconst story = data.story;\n---\n\n\n<html lang=\"en\">\n  <head>\n    <title>Storyblok & Astro</title>\n  </head>\n  <body>\n    <StoryblokComponent blok={story.content} />\n  </body>\n</html>\n\nThis file will generate a page for each story, with the slug and content fetched from the Storyblok API.\n\n NOTE\n\nWhen adding folders inside of Storyblok, include them in the slug when interacting with the Storyblok API. For example, in the GET request above we can use cdn/stories/blog, with a blog folder inside rather than using them at the root.\n\nServer-side rendering\nSection titled Server-side rendering\n\nIf you‚Äôve opted into SSR mode, you will use dynamic routes to fetch the page data from Storyblok.\n\nCreate a new directory src/pages/blog/ and add a new file called [...slug].astro with the following code:\n\nsrc/pages/blog/[...slug].astro\n---\nimport { useStoryblokApi } from '@storyblok/astro'\nimport StoryblokComponent from '@storyblok/astro/StoryblokComponent.astro'\nconst storyblokApi = useStoryblokApi()\nconst slug = Astro.params.slug;\nlet content;\ntry {\n  const { data } = await storyblokApi.get(`cdn/stories/blog/${slug}`, {\n    version: import.meta.env.DEV ? \"draft\" : \"published\",\n  });\n  content = data.story.content\n} catch (error) {\n  return Astro.redirect('/404')\n}\n---\n<html lang=\"en\">\n  <head>\n    <title>Storyblok & Astro</title>\n  </head>\n  <body>\n    <StoryblokComponent blok={content} />\n  </body>\n</html>\n\nThis file will fetch and render the page data from Storyblok that matches the dynamic slug parameter.\n\nSince you are using a redirect to /404, create a 404 page in src/pages:\n\nsrc/pages/404.astro\n<html lang=\"en\">\n  <head>\n    <title>Not found</title>\n  </head>\n  <body>\n    <p>Sorry, this page does not exist.</p>\n  </body>\n</html>\n\nIf the story is not found, the request will be redirected to the 404 page.\n\nPublishing your site\nSection titled Publishing your site\n\nTo deploy your website, visit our deployment guides and follow the instructions for your preferred hosting provider.\n\nRebuild on Storyblok changes\nSection titled Rebuild on Storyblok changes\n\nIf your project is using Astro‚Äôs default static mode, you will need to set up a webhook to trigger a new build when your content changes. If you are using Netlify or Vercel as your hosting provider, you can use its webhook feature to trigger a new build from Storyblok events.\n\nNetlify\nSection titled Netlify\n\nTo set up a webhook in Netlify:\n\nGo to your site dashboard and click on Build & deploy.\n\nUnder the Continuous Deployment tab, find the Build hooks section and click on Add build hook.\n\nProvide a name for your webhook and select the branch you want to trigger the build on. Click on Save and copy the generated URL.\n\nVercel\nSection titled Vercel\n\nTo set up a webhook in Vercel:\n\nGo to your project dashboard and click on Settings.\n\nUnder the Git tab, find the Deploy Hooks section.\n\nProvide a name for your webhook and the branch you want to trigger the build on. Click Add and copy the generated URL.\n\nAdding a webhook to Storyblok\nSection titled Adding a webhook to Storyblok\n\nIn your Storyblok space Settings, click on the Webhooks tab. Paste the webhook URL you copied in the Story published & unpublished field and hit Save to create a webhook.\n\nNow, whenever you publish a new story, a new build will be triggered and your blog will be updated.\n\nOfficial Resources\nSection titled Official Resources\nStoryblok provides an Astro Integration to add Storyblok to your project.\nCommunity Resources\nSection titled Community Resources\nGetting the Visual Editor to work for Storyblok + Astro by Sandra Rodgers\nAstro + Storyblok: SSR preview for instant visual editing by Jonas Gierer\nAstro-Storyblok Previews Site with Netlify‚Äôs Branch Deploys Feature by Sandra Rodgers\nMore CMS guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal"
  },
  {
    "title": "Migrating from WordPress üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-wordpress/",
    "html": "Migrating from WordPress\n\nWordPress is an open-source, personal publishing system built on PHP and MySQL.\n\n TIP\n\nYou can use WordPress as a headless CMS for your Astro project. Follow our guide to use your existing WordPress content in a new Astro project.\n\nKey Similarities between WordPress and Astro\nSection titled Key Similarities between WordPress and Astro\n\nWordPress and Astro share some similarities that will help you migrate your project:\n\nBoth WordPress and Astro are ideal for content-driven websites like blogs and support writing your content in Markdown (requires a plugin in WordPress). Although the process for adding new content is different, writing in Markdown files for your Astro blog should feel familiar if you have used Markdown syntax in your WordPress editor.\n\nBoth WordPress and Astro encourage you to think about the design of your site in ‚Äúblocks‚Äù (components). In Astro you will probably write more of your own code to create these blocks rather than rely on pre-built plugins. But thinking about the individual pieces of your site and how they are presented on the page should feel familiar.\n\nKey Differences between WordPress and Astro\nSection titled Key Differences between WordPress and Astro\n\nWhen you rebuild your WordPress site in Astro, you will notice some important differences:\n\nA WordPress site is edited using an online dashboard. In Astro, you will use a code editor and development environment to maintain your site. You can develop locally on your machine, or choose a cloud editor/development environment like StackBlitz, CodeSandbox or Gitpod.\n\nWordPress has an extensive plugin and theme market. In Astro, you will find some themes and integrations available, but you may now have to build many of your existing features yourself instead of looking for third-party solutions. Or, you can choose to start with an Astro theme with built-in features!\n\nWordPress stores your content in a database. In Astro, you will have individual files (typically Markdown or MDX) in your project directory for each page‚Äôs content. Or, you can choose to use a CMS for your content, even your existing WordPress site, and use Astro to fetch and present the data.\n\nSwitch from WordPress to Astro\nSection titled Switch from WordPress to Astro\n\nTo convert a WordPress blog to Astro, start with our blog theme starter template, or explore more community blog themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template blog\n\nYou can continue to use your existing WordPress blog as your CMS for Astro, which means you will keep using your WordPress dashboard for writing your posts. Your content will be managed at WordPress, but all other aspects of your Astro site will be built in your code editing environment, and you will deploy your Astro site separately from your WordPress site. (Be sure to update your domain at your host to keep the same website URL!)\n\nYou may wish to take Astro‚Äôs Build a Blog Tutorial if you are new to working in a code editor and using GitHub to store and deploy your site. It will walk you through all the accounts and setup you need! You will also learn how to build Astro components yourself, and it will show you how to add blog posts directly in Astro if you choose not to use WordPress to write your content.\n\nIf you want to move all of your existing post content to Astro, you may find this tool for exporting Markdown from WordPress helpful. You may need to make some adjustments to the result if you have to convert a large or complicated WordPress site to Markdown.\n\nTo convert other types of sites, such as a portfolio or documentation site, see more official starter templates on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\n\nBlog Post: Why I switched from WordPress to Astro by fratzinger\n\nAdd your own!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Share State Between Islands üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/sharing-state/",
    "html": "Share State Between Islands\n\nWhen building an Astro website with islands architecture / partial hydration, you may have run into this problem: I want to share state between my components.\n\nUI frameworks like React or Vue may encourage ‚Äúcontext‚Äù providers for other components to consume. But when partially hydrating components within Astro or Markdown, you can‚Äôt use these context wrappers.\n\nAstro recommends a different solution for shared client-side storage: Nano Stores.\n\nRelated recipe:\nShare State Between Astro Components\nWhy Nano Stores?\nSection titled Why Nano Stores?\n\nThe Nano Stores library allows you to author stores that any component can interact with. We recommend Nano Stores because:\n\nThey‚Äôre lightweight. Nano Stores ship the bare minimum JS you‚Äôll need (less than 1 KB) with zero dependencies.\nThey‚Äôre framework-agnostic. This means sharing state between frameworks will be seamless! Astro is built on flexibility, so we love solutions that offer a similar developer experience no matter your preference.\n\nStill, there are a number of alternatives you can explore. These include:\n\nSvelte‚Äôs built-in stores\nSolid signals outside of a component context\nVue‚Äôs reactivity API\nSending custom browser events between components\n\n FAQ\n\nüôã Can I use Nano Stores in .astro files or other server-side components?\nüôã How do Svelte stores compare to Nano Stores?\nüôã How do Solid signals compare to Nano Stores?\nInstalling Nano Stores\nSection titled Installing Nano Stores\n\nTo get started, install Nano Stores alongside their helper package for your favorite UI framework:\n\nPreact\nReact\nSolid\nSvelte\nVue\nLit\nTerminal window\nnpm install nanostores @nanostores/preact\n\nYou can jump into the Nano Stores usage guide from here, or follow along with our example below!\n\nUsage example - ecommerce cart flyout\nSection titled Usage example - ecommerce cart flyout\n\nLet‚Äôs say we‚Äôre building a simple ecommerce interface with three interactive elements:\n\nAn ‚Äúadd to cart‚Äù submission form\nA cart flyout to display those added items\nA cart flyout toggle\n\nTry the completed example on your machine or online via Stackblitz.\n\nYour base Astro file may look like this:\n\nsrc/pages/index.astro\n---\nimport CartFlyoutToggle from '../components/CartFlyoutToggle';\nimport CartFlyout from '../components/CartFlyout';\nimport AddToCartForm from '../components/AddToCartForm';\n---\n\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>...</head>\n<body>\n  <header>\n    <nav>\n      <a href=\"/\">Astro storefront</a>\n      <CartFlyoutToggle client:load />\n    </nav>\n  </header>\n  <main>\n    <AddToCartForm client:load>\n    <!-- ... -->\n    </AddToCartForm>\n  </main>\n  <CartFlyout client:load />\n</body>\n</html>\nUsing ‚Äúatoms‚Äù\nSection titled Using ‚Äúatoms‚Äù\n\nLet‚Äôs start by opening our CartFlyout whenever CartFlyoutToggle is clicked.\n\nFirst, create a new JS or TS file to contain our store. We‚Äôll use an ‚Äúatom‚Äù for this:\n\nsrc/cartStore.js\nimport { atom } from 'nanostores';\n\n\nexport const isCartOpen = atom(false);\n\nNow, we can import this store into any file that needs to read or write. We‚Äôll start by wiring up our CartFlyoutToggle:\n\nPreact\nReact\nSolid\nSvelte\nVue\nLit\nsrc/components/CartFlyoutToggle.jsx\nimport { useStore } from '@nanostores/preact';\nimport { isCartOpen } from '../cartStore';\n\n\nexport default function CartButton() {\n  // read the store value with the `useStore` hook\n  const $isCartOpen = useStore(isCartOpen);\n  // write to the imported store using `.set`\n  return (\n    <button onClick={() => isCartOpen.set(!$isCartOpen)}>Cart</button>\n  )\n}\n\nThen, we can read isCartOpen from our CartFlyout component:\n\nPreact\nReact\nSolid\nSvelte\nVue\nLit\nsrc/components/CartFlyout.jsx\nimport { useStore } from '@nanostores/preact';\nimport { isCartOpen } from '../cartStore';\n\n\nexport default function CartFlyout() {\n  const $isCartOpen = useStore(isCartOpen);\n\n\n  return $isCartOpen ? <aside>...</aside> : null;\n}\nUsing ‚Äúmaps‚Äù\nSection titled Using ‚Äúmaps‚Äù\n\n TIP\n\nMaps are a great choice for objects you write to regularly! Alongside the standard get() and set() helpers an atom provides, you‚Äôll also have a .setKey() function to efficiently update individual object keys.\n\nNow, let‚Äôs keep track of the items inside your cart. To avoid duplicates and keep track of ‚Äúquantity,‚Äù we can store your cart as an object with the item‚Äôs ID as a key. We‚Äôll use a Map for this.\n\nLet‚Äôs add a cartItem store to our cartStore.js from earlier. You can also switch to a TypeScript file to define the shape if you‚Äôre so inclined.\n\nJavaScript\nTypeScript\nsrc/cartStore.js\nimport { atom, map } from 'nanostores';\n\n\nexport const isCartOpen = atom(false);\n\n\n/**\n * @typedef {Object} CartItem\n * @property {string} id\n * @property {string} name\n * @property {string} imageSrc\n * @property {number} quantity\n */\n\n\n/** @type {import('nanostores').MapStore<Record<string, CartItem>>} */\nexport const cartItems = map({});\n\nNow, let‚Äôs export an addCartItem helper for our components to use.\n\nIf that item doesn‚Äôt exist in your cart, add the item with a starting quantity of 1.\nIf that item does already exist, bump the quantity by 1.\nJavaScript\nTypeScript\nsrc/cartStore.js\n...\nexport function addCartItem({ id, name, imageSrc }) {\n  const existingEntry = cartItems.get()[id];\n  if (existingEntry) {\n    cartItems.setKey(id, {\n      ...existingEntry,\n      quantity: existingEntry.quantity + 1,\n    })\n  } else {\n    cartItems.setKey(\n      id,\n      { id, name, imageSrc, quantity: 1 }\n    );\n  }\n}\n\n NOTE\n\nüôã Why use .get() here instead of a useStore helper?\n\nWith our store in place, we can call this function inside our AddToCartForm whenever that form is submitted. We‚Äôll also open the cart flyout so you can see a full cart summary.\n\nPreact\nReact\nSolid\nSvelte\nVue\nLit\nsrc/components/AddToCartForm.jsx\nimport { addCartItem, isCartOpen } from '../cartStore';\n\n\nexport default function AddToCartForm({ children }) {\n  // we'll hardcode the item info for simplicity!\n  const hardcodedItemInfo = {\n    id: 'astronaut-figurine',\n    name: 'Astronaut Figurine',\n    imageSrc: '/images/astronaut-figurine.png',\n  }\n\n\n  function addToCart(e) {\n    e.preventDefault();\n    isCartOpen.set(true);\n    addCartItem(hardcodedItemInfo);\n  }\n\n\n  return (\n    <form onSubmit={addToCart}>\n      {children}\n    </form>\n  )\n}\n\nFinally, we‚Äôll render those cart items inside our CartFlyout:\n\nPreact\nReact\nSolid\nSvelte\nVue\nLit\nsrc/components/CartFlyout.jsx\nimport { useStore } from '@nanostores/preact';\nimport { isCartOpen, cartItems } from '../cartStore';\n\n\nexport default function CartFlyout() {\n  const $isCartOpen = useStore(isCartOpen);\n  const $cartItems = useStore(cartItems);\n\n\n  return $isCartOpen ? (\n    <aside>\n      {Object.values($cartItems).length ? (\n        <ul>\n          {Object.values($cartItems).map(cartItem => (\n            <li>\n              <img src={cartItem.imageSrc} alt={cartItem.name} />\n              <h3>{cartItem.name}</h3>\n              <p>Quantity: {cartItem.quantity}</p>\n            </li>\n          ))}\n        </ul>\n      ) : <p>Your cart is empty!</p>}\n    </aside>\n  ) : null;\n}\n\nNow, you should have a fully interactive ecommerce example with the smallest JS bundle in the galaxy üöÄ\n\nTry the completed example on your machine or online via Stackblitz!\n\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "Migrating from VuePress üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-vuepress/",
    "html": "Migrating from VuePress\n\nVuePress is an open-source static site generator built on Vue.\n\nKey Similarities between VuePress and Astro\nSection titled Key Similarities between VuePress and Astro\n\nVuePress and Astro share some similarities that will help you migrate your project:\n\nBoth VuePress and Astro are modern Javascript static-site generators with similar project file structures. Both use a special src/pages/ folder for file-based routing. Creating and managing pages for your site should feel familiar.\n\nAstro and VuePress are both designed for content-driven websites, with excellent built-in support for Markdown files. Writing in Markdown will feel familiar, and you will be able to keep your existing content.\n\nAstro has an official integration for using Vue components and supports installing NPM packages, including several for Vue. You will be able to write Vue UI components, and may be able to keep some or all of your existing Vue components and dependencies.\n\nKey Differences between VuePress and Astro\nSection titled Key Differences between VuePress and Astro\n\nWhen you rebuild your VuePress site in Astro, you will notice some important differences.\n\nVuePress is a Vue-based single-page application (SPA). Astro sites are multi-page apps built using .astro components, but can also support React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, Lit and raw HTML templating.\n\nLayout templates: VuePress sites are created using Markdown (.md) files for page content and HTML (.html) templates for layout. Astro is component-based, and uses Astro components, which include HTML templating for pages, layouts and individual UI elements. Astro can also create pages from .md and .mdx files, using an Astro layout component for wrapping Markdown content in a page template.\n\nVuePress was designed to build content-heavy, Markdown-centric sites and has some built-in, documentation-specific website features that you would have to build yourself in Astro. Instead, Astro offers some documentation-specific features through an official docs theme. This website was the inspiration for that template! You can also find more community docs themes with built-in features in our Themes Showcase.\n\nSwitch from VuePress to Astro\nSection titled Switch from VuePress to Astro\n\nTo convert a VuePress documentation site to Astro, start with our official Starlight docs theme starter template, or explore more community docs themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template starlight\n\nBring your existing Markdown content files to create Markdown pages. You can still take advantage of file-based routing by moving these documents from docs in VuePress to src/pages/ in Astro. Create folders with names that correspond to your existing VuePress project, and you should be able to keep your existing URLs.\n\nVuePress, or any theme you installed, probably handled much of your site layout and metadata for you. You may wish to read about building Astro Layouts as Markdown page wrappers to see how to manage templating yourself in Astro, including your page <head>.\n\nYou can find Astro‚Äôs docs starter, and other templates, on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\nAdd your own!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from Pelican üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-pelican/",
    "html": "Migrating from Pelican\n\nPelican is an open-source static site generator built on Python.\n\nKey Similarities between Pelican and Astro\nSection titled Key Similarities between Pelican and Astro\n\nPelican and Astro share some similarities that will help you migrate your project:\n\nPelican and Astro are both static-site generators, ideally suited to content-driven websites like blogs.\n\nPelican and Astro both have built-in support for writing in Markdown, including frontmatter YAML properties for page metadata. However, Astro has very few reserved frontmatter properties compared to Pelican. Even though many of your existing Pelican frontmatter properties will not be ‚Äúspecial‚Äù in Astro, you can continue to use your existing Markdown files and frontmatter values.\n\nKey Differences between Pelican and Astro\nSection titled Key Differences between Pelican and Astro\n\nWhen you rebuild your Pelican site in Astro, you will notice some important differences:\n\nPelican supports writing content in Markdown and reStructured Text (.rst). Astro supports creating pages from Markdown and MDX files, but does not support reStructured Text.\n\nPelican uses HTML files and Jinja syntax for templating. Astro syntax is a JSX-like superset of HTML. All valid HTML is valid .astro syntax.\n\nPelican was designed to build content-rich websites like blogs and has some built-in, blog features that you would have to build yourself in Astro. Instead, Astro offers some of these features included in an official blog theme.\n\nSwitch from Pelican to Astro\nSection titled Switch from Pelican to Astro\n\nTo convert a Pelican documentation site to Astro, start with our official Starlight docs theme starter template, or explore more community themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template starlight\n\nBring your existing Markdown content files to create Markdown pages. You can still take advantage of file-based routing by copying these documents from Pelican‚Äôs content/ folder into src/pages/ in Astro. You may wish to read about Astro‚Äôs project structure to learn where files should be located.\n\nPelican may have handled much of your site layout and metadata for you. You may wish to read about building Astro Layouts as Markdown page wrappers to see how to manage templating yourself in Astro, including your page <head>.\n\nTo convert other types of sites, such as a portfolio or a blog, see more official starter templates on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\nAdd your own!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from SvelteKit üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-sveltekit/",
    "html": "Migrating from SvelteKit\n\nSvelteKit is a framework for building web applications on top of Svelte.\n\nKey Similarities between SvelteKit and Astro\nSection titled Key Similarities between SvelteKit and Astro\n\nSvelteKit and Astro share some similarities that will help you migrate your project:\n\nBoth SvelteKit and Astro are modern JavaScript static-site generators and server-side rendering frameworks.\n\nBoth SvelteKit and Astro use a src/ folder for your project files and a special folder for file-based routing. Creating and managing pages for your site should feel familiar.\n\nAstro has an official integration for using Svelte components and supports installing NPM packages, including several for Svelte. You will be able to write Svelte UI components, and may be able to keep some or all of your existing components and dependencies.\n\nAstro and SvelteKit both allow you to use a headless CMS, APIs or Markdown files for data. You can continue to use your preferred content authoring system, and will be able to keep your existing content.\n\nKey Differences between SvelteKit and Astro\nSection titled Key Differences between SvelteKit and Astro\n\nWhen you rebuild your SvelteKit site in Astro, you will notice some important differences:\n\nAstro sites are multi-page apps, whereas SvelteKit defaults to SPAs (single-page applications) with server-side rendering, but can also create MPAs, traditional SPAs, or you can mix and match these techniques within an app.\n\nComponents: SvelteKit uses Svelte. Astro pages are built using .astro components, but can also support React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, Lit and raw HTML templating.\n\ncontent-driven: Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing SvelteKit app might be built for high client-side interactivity. Astro has built-in capabilities for working with your content, such as page generation, but may require advanced Astro techniques to include items that are more challenging to replicate using .astro components, such as dashboards.\n\nMarkdown-ready: Astro includes built-in Markdown support, and includes a special frontmatter YAML layout property used per-file for page templating. If you are converting a SvelteKit Markdown-based blog, you will not have to install a separate Markdown integration and you will not set a layout via a configuration file. You can bring your existing Markdown files, but you may need to reorganize as Astro‚Äôs file-based routing does not require a folder for each page route.\n\nSwitch from SvelteKit to Astro\nSection titled Switch from SvelteKit to Astro\n\nTo convert a SvelteKit blog to Astro, start with our blog theme starter template, or explore more community blog themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template blog\n\nBring your existing Markdown (or MDX, with our optional integration) files as content to create Markdown or MDX pages.\n\nWhile file-based routing and layout components are similar in Astro, you may wish to read about Astro‚Äôs project structure to learn where files should be located.\n\nTo convert other types of sites, such as a portfolio or documentation site, see more official starter templates on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\n\nBlog Post: Rewriting my blog from SvelteKit to Astro\n\nAdd your own!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from Jekyll üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-jekyll/",
    "html": "Migrating from Jekyll\n\nJekyll is a static site generator built on Ruby.\n\nKey Similarities between Jekyll and Astro\nSection titled Key Similarities between Jekyll and Astro\n\nJekyll and Astro share some similarities that will help you migrate your project:\n\nBoth Jekyll and Astro are static-site generators, commonly used to create blogs.\n\nBoth Jekyll and Astro allow you to write your content in Markdown and HTML. Jekyll and Astro both provide some special frontmatter YAML properties for page layout and unpublished draft posts. You can continue to use your existing Markdown files in Astro.\n\nBoth Jekyll and Astro use file-based routing for creating pages from your blog posts. Astro provides a special src/pages/ directory for all pages and posts. Jekyll uses a similar special folder called _posts/ for your Markdown blog posts, however your site pages can exist elsewhere. Creating new blog posts should feel familiar.\n\nKey Differences between Jekyll and Astro\nSection titled Key Differences between Jekyll and Astro\n\nWhen you rebuild your Jekyll site in Astro, you will notice some important differences:\n\nAs Jekyll is primarily a blogging platform, several blog features are built-in that you may have to build yourself in Astro. Or, choose a blog starter template theme that includes these features. For example, Jekyll has built-in support for tags and categories which you will find in several Astro blog themes, but is not included in a minimal Astro project.\n\nJekyll uses Liquid templates for reusable layout elements and templating. Astro uses JSX-like .astro files for templating and components. Any .astro file can be a component, a layout or an entire page, and can import and render any other Astro components. You can also build using other UI framework components (e.g. React, Svelte, Vue, Solid) as well as content or metadata from other files in your project, such as Markdown or MDX.\n\nSwitch from Jekyll to Astro\nSection titled Switch from Jekyll to Astro\n\nTo convert a Jekyll blog to Astro, start with our blog theme starter template, or explore more community blog themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template blog\n\nBring your existing Markdown files as content to create Markdown pages, using an Astro Markdown layout instead of a Liquid template.\n\nMuch of your existing HTML page content can be converted into Astro pages, and you will additionally be able to use variables, JSX-like expressions and component imports directly in your HTML templating.\n\nAstro does not have a permalink property that accepts placeholders. You may need to read more about Astro‚Äôs page routing if you want to keep your existing URL structure. Or, consider setting redirects at a host like Netlify.\n\nTo convert other types of sites, such as a portfolio or documentation site, see more official starter templates on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\nBlog Post: Back to the Future: Our Tech Blog‚Äôs Transition from Jekyll to Astro.\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "@astrojs/tailwind üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/tailwind/",
    "html": "@astrojs/tailwind\nv5.0.2\nGitHub\nnpm\nChangelog\n\nThis Astro integration brings Tailwind‚Äôs utility CSS classes to every .astro file and framework component in your project, along with support for the Tailwind configuration file.\n\nWhy Tailwind?\nSection titled Why Tailwind?\n\nTailwind lets you use utility classes instead of writing CSS. These utility classes are mostly one-to-one with a certain CSS property setting: for example, adding the text-lg to an element is equivalent to setting font-size: 1.125rem in CSS. You might find it easier to write and maintain your styles using these predefined utility classes!\n\nIf you don‚Äôt like those predefined settings, you can customize the Tailwind configuration file to your project‚Äôs design requirements. For example, if the ‚Äúlarge text‚Äù in your design is actually 2rem, you can change the lg fontSize setting to 2rem.\n\nTailwind is also a great choice to add styles to React, Preact, or Solid components, which don‚Äôt support a <style> tag in the component file.\n\nNote: it‚Äôs generally discouraged to use both Tailwind and another styling method (e.g. Styled Components) in the same file.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add tailwind\n# Using Yarn\nyarn astro add tailwind\n# Using PNPM\npnpm astro add tailwind\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/tailwind and tailwindcss packages using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/tailwind tailwindcss\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport tailwind from '@astrojs/tailwind';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [tailwind()],\n  //             ^^^^^^^^^^\n});\n\nThen, create a tailwind.config.cjs file in your project‚Äôs root directory. You can use the following command to generate a basic configuration file for you:\n\nTerminal window\nnpx tailwindcss init\n\nFinally, add this basic configuration to your tailwind.config.cjs file:\n\ntailwind.config.cjs\n/** @type {import('tailwindcss').Config} */\nmodule.exports = {\n  content: ['./src/**/*.{astro,html,js,jsx,md,mdx,svelte,ts,tsx,vue}'],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n};\nUsage\nSection titled Usage\n\nWhen you install the integration, Tailwind‚Äôs utility classes should be ready to go right away. Head to the Tailwind docs to learn how to use Tailwind, and if you see a utility class you want to try, add it to any HTML element to your project!\n\nAutoprefixer is also set up automatically when working in dev mode, and for production builds, so Tailwind classes will work in older browsers.\n\nConfiguration\nSection titled Configuration\nConfiguring Tailwind\nSection titled Configuring Tailwind\n\nIf you used the Quick Install instructions and said yes to each prompt, you‚Äôll see a tailwind.config.mjs file in your project‚Äôs root directory. Use this file for your Tailwind configuration changes. You can learn how to customize Tailwind using this file in the Tailwind docs.\n\nIf it isn‚Äôt there, you add your own tailwind.config.(js|cjs|mjs) file to the root directory and the integration will use its configurations. This can be great if you already have Tailwind configured in another project and want to bring those settings over to this one.\n\nConfiguring the Integration\nSection titled Configuring the Integration\n\nThe Astro Tailwind integration handles the communication between Astro and Tailwind and it has its own options. Change these in the astro.config.mjs file (not the Tailwind configuration file) which is where your project‚Äôs integration settings live.\n\nconfigFile\nSection titled configFile\n\nPreviously known as config.path in @astrojs/tailwind v3. See the v4 changelog for updating your config.\n\nIf you want to use a different Tailwind configuration file instead of the default tailwind.config.(js|cjs|mjs), specify that file‚Äôs location using this integration‚Äôs configFile option. If configFile is relative, it will be resolved relative to the current working directory.\n\n CAUTION\n\nChanging this isn‚Äôt recommended since it can cause problems with other tools that integrate with Tailwind, like the official Tailwind VSCode extension.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport tailwind from '@astrojs/tailwind';\n\n\nexport default defineConfig({\n  integrations: [\n    tailwind({\n      // Example: Provide a custom path to a Tailwind config file\n      configFile: './custom-config.cjs',\n    }),\n  ],\n});\napplyBaseStyles\nSection titled applyBaseStyles\n\nPreviously known as config.applyBaseStyles in @astrojs/tailwind v3. See the v4 changelog for updating your config.\n\nBy default, the integration imports a basic base.css file on every page of your project. This basic CSS file includes the three main @tailwind directives:\n\n/* The integration's default injected base.css file */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\nTo disable this default behavior, set applyBaseStyles to false. This can be useful if you need to define your own base.css file (to include a @layer directive, for example). This can also be useful if you do not want base.css to be imported on every page of your project.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  integrations: [\n    tailwind({\n      // Example: Disable injecting a basic `base.css` import on every page.\n      // Useful if you need to define and/or import your own custom `base.css`.\n      applyBaseStyles: false,\n    }),\n  ],\n});\n\nYou can now import your own base.css as a local stylesheet.\n\nExamples\nSection titled Examples\nThe Astro Tailwind Starter gets you up and running with a base for your project that uses Tailwind for styling\nAstro‚Äôs homepage uses Tailwind. Check out its Tailwind configuration file or an example component\nThe Astro Ink, Sarissa Blog, and Creek themes use Tailwind for styling\nBrowse Astro Tailwind projects on GitHub for more examples!\nTroubleshooting\nSection titled Troubleshooting\nClass does not exist with @apply directives\nSection titled Class does not exist with @apply directives\n\nWhen using the @apply directive in an Astro, Vue, Svelte, or another component integration‚Äôs <style> tag, it may generate errors about your custom Tailwind class not existing and cause your build to fail.\n\nTerminal window\nerror   The `text-special` class does not exist. If `text-special` is a custom class, make sure it is defined within a `@layer` directive.\n\nInstead of using @layer directives in a global stylesheet, define your custom styles by adding a plugin to your Tailwind config to fix it:\n\ntailwind.config.mjs\nexport default {\n  // ...\n  plugins: [\n    function ({ addComponents, theme }) {\n      addComponents({\n        '.btn': {\n          padding: theme('spacing.4'),\n          margin: 'auto',\n        },\n      });\n    },\n  ],\n};\nClass-based modifiers do not work with @apply directives\nSection titled Class-based modifiers do not work with @apply directives\n\nCertain Tailwind classes with modifiers rely on combining classes across multiple elements. For example, group-hover:text-gray compiles to .group:hover .text-gray. When this is used with the @apply directive in Astro <style> tags, the compiled styles are removed from the build output because they do not match any markup in the .astro file. The same issue may also happen in framework components that support scoped styles like Vue and Svelte.\n\nTo fix this, you can use inline classes instead:\n\n<p class=\"text-black group-hover:text-gray\">Astro</p>\nOthers\nSection titled Others\nIf your installation doesn‚Äôt seem to be working, try restarting the dev server.\nIf you edit and save a file and don‚Äôt see your site update accordingly, try refreshing the page.\nIf refreshing the page doesn‚Äôt update your preview, or if a new installation doesn‚Äôt seem to be working, then restart the dev server.\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "Migrating from Hugo üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-hugo/",
    "html": "Migrating from Hugo\n\nHugo is an open-source static site generator built on Go.\n\nKey Similarities between Hugo and Astro\nSection titled Key Similarities between Hugo and Astro\n\nHugo and Astro share some similarities that will help you migrate your project:\n\nHugo and Astro are both modern static-site generators, ideally suited to content-driven websites like blogs.\n\nHugo and Astro both allow you to author your content in Markdown. However, Hugo includes several special frontmatter properties and allows you to write frontmatter in YAML, TOML or JSON. Even though many of your existing Hugo frontmatter properties will not be ‚Äúspecial‚Äù in Astro, you can continue to use your existing Markdown files and YAML frontmatter values.\n\nHugo and Astro both allow you to enhance your site with a variety of integrations and external packages.\n\nKey Differences between Hugo and Astro\nSection titled Key Differences between Hugo and Astro\n\nWhen you rebuild your Hugo site in Astro, you will notice some important differences:\n\nHugo uses Go Templating for page templating. Astro syntax is a JSX-like superset of HTML.\n\nAstro does not use shortcodes for dynamic content in standard Markdown files, but Astro‚Äôs MDX integration does allow you to use JSX and import components in MDX files.\n\nWhile Hugo can use ‚Äúpartials‚Äù for reusable layout elements, Astro is entirely component-based. Any .astro file can be a component, a layout or an entire page, and can import and render any other Astro components. Astro components can also include other UI framework components (e.g. React, Svelte, Vue, Solid) as well as content or metadata from other files in your project, such as Markdown or MDX.\n\nSwitch from Hugo to Astro\nSection titled Switch from Hugo to Astro\n\nTo convert a Hugo blog to Astro, start with our blog theme starter template, or explore more community blog themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template blog\n\nBring your existing Markdown (or MDX, with our optional integration) files as content to create Markdown or MDX pages. You may need to convert your frontmatter to YAML, since Astro only allows YAML frontmatter in these files.\n\nTo continue to use dynamic content such as variables, expressions or UI components within your Markdown content, add Astro‚Äôs optional MDX integration and convert your existing Markdown files to MDX pages. MDX supports YAML frontmatter, so you can keep your existing frontmatter properties. But, you must replace any shortcode syntax with MDX‚Äôs own syntax, which allows JSX expressions and/or component imports.\n\nTo convert other types of sites, such as a portfolio or documentation site, see more official starter templates on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\nBlog Post: Hugo Vs Astro - Which Static Site Generator To Choose In 2023.\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from GitBook üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gitbook/",
    "html": "Migrating from GitBook\n\nGitBook is a web-based platform for creating and publishing documentation and books in a collaborative manner, with version control integration and customizable features.\n\nKey Similarities between GitBook and Astro\nSection titled Key Similarities between GitBook and Astro\n\nGitBook and Astro share some similarities that will help you migrate your project:\n\nBoth Astro and GitBook support Markdown. You can migrate all your existing documentation utilizing GitBook‚Äôs Git Sync feature.\n\nBoth Astro and GitBook use some form of file-based routing. Using Astro‚Äôs file structure for your existing content and when adding new pages should feel familiar.\n\nKey Differences between GitBook and Astro\nSection titled Key Differences between GitBook and Astro\n\nWhen you migrate your GitBook docs to Astro, you will notice some important differences:\n\nA GitBook site is edited using an online dashboard. In Astro, you will use a code editor and development environment to maintain your site. You can develop locally on your machine, or choose a cloud editor/development environment like StackBlitz, CodeSandbox, or Gitpod.\n\nGitBook stores your content in a database. In Astro, you will have individual files (typically Markdown or MDX) in your project directory for each page‚Äôs content. Or, you can choose to use a CMS for your content and use Astro to fetch and present the data.\n\nGitBook uses a custom syntax on top of Markdown for content. Astro supports Markdoc via the optional Markdoc integration, which features a similar syntax to the one you would use in GitBook.\n\nSwitch from GitBook to Astro\nSection titled Switch from GitBook to Astro\n\nTo convert a GitBook documentation site to Astro, start with our official Starlight docs theme starter template, or explore more community docs themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template starlight\n\nOnce you have a new Astro project, you can sync your existing GitBook content to your new Astro project. GitBook has a Git Sync feature that will automatically sync your GitBook content to a GitHub/GitLab repository.\n\nTo sync directly to the docs template‚Äôs content collection, specify src/content/docs/en or src/content/docs as the project directory.\n\n CAUTION\n\nWhen enabling Git Sync be sure to specify ‚ÄùGitBook to GitHub‚Äù as the priority. This will ensure that your GitBook content is synced to your GitHub repository. Otherwise, you will overwrite your existing GitBook content.\n\nAfter syncing the content, you will now have a copy of your GitBook content in your Astro repository. Disable git sync to prevent future syncing with GitBook.\n\nNote that although you now have your content migrated to your Astro project, it will not be immediately usable. To use this content in your Astro site, you will need to spend some time manually changing GitBook‚Äôs syntax into a format compatible with Astro. In particular:\n\nAstro‚Äôs Markdoc integration requires that the file extension be .mdoc. This is to avoid conflicts with other Markdown extensions like .mdx and .md.\nGitBook syntax differs from Markdoc where the / prefix denoting a closing tag is replaced with end for GitBook files. You will need to update this notation throughout your files.\nSome features of GitBook rely on custom components. These components will not exist in Astro and must be created and added to your project through Markdoc‚Äôs config tags attribute or removed from your files.\nCommunity Resources\nSection titled Community Resources\nAdd your own!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from Gridsome üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gridsome/",
    "html": "Migrating from Gridsome\n\nGridsome is an open-source static site generator built on Vue and GraphQL.\n\nKey Similarities between Gridsome and Astro\nSection titled Key Similarities between Gridsome and Astro\n\nGridsome and Astro share some similarities that will help you migrate your project:\n\nBoth Gridsome and Astro are modern Javascript static-site generators with similar project file structures.\n\nBoth Gridsome and Astro use a src/ folder for your project files and a special src/pages/ folder for file-based routing. Creating and managing pages for your site should feel familiar.\n\nAstro has an official integration for using Vue components and supports installing NPM packages, including several for Vue. You will be able to write Vue UI components, and may be able to keep some or all of your existing Gridsome Vue components and dependencies.\n\nAstro and Gridsome both allow you to use a headless CMS, APIs or Markdown files for data. You can continue to use your preferred content authoring system, and will be able to keep your existing content.\n\nKey Differences between Gridsome and Astro\nSection titled Key Differences between Gridsome and Astro\n\nWhen you rebuild your Gridsome site in Astro, you will notice some important differences:\n\nGridsome is a Vue-based single-page application (SPA). Astro sites are multi-page apps built using .astro components, but can also support React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, Lit and raw HTML templating.\n\nAs an SPA, Gridsome uses vue-router for SPA routing, and vue-meta for managing <head>. In Astro, you will create separate HTML pages and control your page <head> directly, or in a layout component.\n\nLocal file data: Gridsome uses GraphQL to retrieve data from your project files. Astro uses ESM imports and the Astro.glob() helper to import data from local project files. Remote resources can be loaded using the standard fetch() API. GraphQL may be optionally added to your project, but is not included by default.\n\nSwitch from Gridsome to Astro\nSection titled Switch from Gridsome to Astro\n\nTo convert a Gridsome blog to Astro, start with our blog theme starter template, or explore more community blog themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template blog\n\nBring your existing Markdown (or MDX, with our optional integration) files as content to create Markdown or MDX pages.\n\nSince Gridsome‚Äôs project structure is similar to Astro‚Äôs, you may be able to copy several existing files from your project into the same location in your new Astro project. However, the two project structures are not identical. You may want to examine Astro‚Äôs project structure to see what the differences are.\n\nSince Astro queries and imports your local files differently than Gridsome, you may want to read about how to load files using Astro.glob() to understand how to work with your local files.\n\nTo convert other types of sites, such as a portfolio or documentation site, see more official starter templates on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\nBlog Post: Migration from Gridsome to Astro.\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from Eleventy üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-eleventy/",
    "html": "Migrating from Eleventy\n\nEleventy is an open-source static site generator that works with multiple template languages.\n\nKey Similarities between Eleventy (11ty) and Astro\nSection titled Key Similarities between Eleventy (11ty) and Astro\n\nEleventy (11ty) and Astro share some similarities that will help you migrate your project:\n\nBoth Astro and Eleventy are modern, JavaScript-based (Jamstack) site builders.\n\nAstro and Eleventy both allow you to use a headless CMS, APIs or Markdown files for data. You can continue to use your preferred content authoring system, and will be able to keep your existing content.\n\nKey Differences between Eleventy (11ty) and Astro\nSection titled Key Differences between Eleventy (11ty) and Astro\n\nWhen you rebuild your Eleventy (11ty) site in Astro, you will notice some important differences:\n\nEleventy supports a variety of templating languages. Astro supports including components from several popular JS Frameworks (e.g. React, Svelte, Vue, Solid), but uses Astro layouts, pages and components for most page templating.\n\nAstro uses a src/ directory for all files, including site metadata, that are available for querying and processing during site build. Within this is a special src/pages/ folder for file-based routing.\n\nAstro uses a public/ folder for static assets that do not need to be processed nor transformed during the build.\n\nIn Eleventy, bundling CSS, JavaScript, and other assets needs to be configured manually. Astro handles this for you out-of-the-box.\n\nSwitch from Eleventy to Astro\nSection titled Switch from Eleventy to Astro\n\nTo convert an Eleventy blog to Astro, start with our blog theme starter template, or explore more community blog themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template blog\n\nBring your existing Markdown (or MDX, with our optional integration) files as content to create Markdown or MDX pages.\n\nYour Eleventy project allowed you to use a variety of templating languages to build your site. In an Astro project, your page templating will mostly be achieved with Astro components, which can be used as UI elements, layouts and even full pages. You may want to explore Astro‚Äôs component syntax to see how to template in Astro using components.\n\nTo convert other types of sites, such as a portfolio or documentation site, see more official starter templates on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\nAdd your own!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from Docusaurus üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-docusaurus/",
    "html": "Migrating from Docusaurus\n\nDocusaurus is a popular documentation website builder built on React.\n\nKey Similarities between Docusaurus and Astro\nSection titled Key Similarities between Docusaurus and Astro\n\nDocusaurus and Astro share some similarities that will help you migrate your project:\n\nBoth Astro and Docusaurus are modern, JavaScript-based (Jamstack) site builders intended for content-driven websites, like documentation sites.\n\nBoth Astro and Docusaurus support MDX pages. You should be able to use your existing .mdx files to Astro.\n\nBoth Astro and Docusaurus use file-based routing to generate page routes automatically for any MDX file located in src/pages. Using Astro‚Äôs file structure for your existing content and when adding new pages should feel familiar.\n\nAstro has an official integration for using React components. Note that in Astro, React files must have a .jsx or .tsx extension.\n\nAstro supports installing NPM packages, including several for React. You may be able to keep some or all of your existing React components and dependencies.\n\nAstro‚Äôs JSX-like syntax should feel familiar if you are used to writing React.\n\nKey Differences between Docusaurus and Astro\nSection titled Key Differences between Docusaurus and Astro\n\nWhen you rebuild your Docusaurus site in Astro, you will notice some important differences:\n\nDocusaurus is a React-based single-page application (SPA). Astro sites are multi-page apps built using .astro components, but can also support React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, Lit and raw HTML templating.\n\nDocusaurus was designed to build documentation websites and has some built-in, documentation-specific website features that you would have to build yourself in Astro. Instead, Astro offers some of these features through an official docs theme. This website was the inspiration for that template! You can also find more community docs themes with built-in features in our Themes Showcase.\n\nDocusaurus sites use MDX pages for content. Astro‚Äôs docs theme uses Markdown (.md) files by default and does not require you to use MDX. You can optionally install Astro‚Äôs MDX integration and use .mdx files in addition to standard Markdown files.\n\nSwitch from Docusaurus to Astro\nSection titled Switch from Docusaurus to Astro\n\nTo convert a Docusaurus documentation site to Astro, start with our official Starlight docs theme starter template, or explore more community docs themes in our theme showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters. Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest -- --template starlight\n\nAdd our MDX integration and bring your existing content files to create MDX pages. You can still take advantage of file-based routing by copying these documents directly into src/pages/ in Astro, the same folder you currently use. Create folders with names that correspond to your existing Docusaurus project, and you should be able to keep your existing URLs.\n\nDocusaurus probably handled much of your site layout and metadata for you. You may wish to read about building Astro Layouts as page wrappers for Markdown and MDX to see how to manage templating yourself in Astro, including your page <head>.\n\nYou can find Astro‚Äôs docs starter, and other official templates, on astro.new. You‚Äôll find a link to each project‚Äôs GitHub repository, as well as one-click links to open a working project in StackBlitz, CodeSandbox and Gitpod online development environments.\n\nCommunity Resources\nSection titled Community Resources\nAdd your own!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from NuxtJS üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-nuxtjs/",
    "html": "Migrating from NuxtJS\n\nHere are some key concepts and migration strategies to help you get started. Use the rest of our docs and our Discord community to keep going!\n\nThis guide is referring to Nuxt 2, not the newer Nuxt 3. While some of the concepts are similar, Nuxt 3 is a newer version of the framework and may require different strategies for parts of your migration.\n\nKey Similarities between Nuxt and Astro\nSection titled Key Similarities between Nuxt and Astro\n\nNuxt and Astro share some similarities that will help you migrate your project:\n\nAstro projects can also be SSG or SSR with page level prerendering.\nAstro uses file-based routing, and allows specially named pages to create dynamic routes.\nAstro is component-based, and your markup structure will be similar before and after your migration.\nAstro has an official integration for using Vue components.\nAstro has support for installing NPM packages, including Vue libraries. You may be able to keep some or all of your existing Vue components and dependencies.\nKey Differences between Nuxt and Astro\nSection titled Key Differences between Nuxt and Astro\n\nWhen you rebuild your Nuxt site in Astro, you will notice some important differences:\n\nNuxt is a Vue-based SPA (single-page application). Astro sites are multi-page apps built using .astro components, but can also support React, Preact, Vue.js, Svelte, SolidJS, AlpineJS, Lit and raw HTML templating.\n\nPage Routing: Nuxt uses vue-router for SPA routing, and vue-meta for managing <head>. In Astro, you will create separate HTML page routes and control your page <head> directly, or in a layout component.\n\ncontent-driven: Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing Nuxt app may be built for high client-side interactivity. Astro has built-in capabilities for working with your content, such as page generation, but may require advanced Astro techniques to include items that are more challenging to replicate using .astro components, such as dashboards.\n\nConvert your NuxtJS Project\nSection titled Convert your NuxtJS Project\n\nEach project migration will look different, but there are some common actions you will perform when converting from Nuxt to Astro.\n\nCreate a new Astro project\nSection titled Create a new Astro project\n\nUse the create astro command for your package manager to launch Astro‚Äôs CLI wizard or choose a community theme from the Astro Theme Showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters (e.g. docs, blog, portfolio). Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\n# launch the Astro CLI Wizard\nnpm create astro@latest\n\n\n# create a new project with an official example\nnpm create astro@latest -- --template <example-name>\n\nThen, copy your existing Nuxt project files over to your new Astro project in a separate folder outside of src.\n\n TIP\n\nVisit https://astro.new for the full list of official starter templates, and links for opening a new project in StackBlitz, CodeSandbox, or Gitpod.\n\nInstall integrations (optional)\nSection titled Install integrations (optional)\n\nYou may find it useful to install some of Astro‚Äôs optional integrations to use while converting your Nuxt project to Astro:\n\n@astrojs/vue: to reuse some existing Vue UI components in your new Astro site, or keep writing with Vue components.\n\n@astrojs/mdx: to bring existing MDX files from your Nuxt project, or to use MDX in your new Astro site.\n\nPut your source code in src\nSection titled Put your source code in src\n\nMove the contents of Nuxt‚Äôs static/ folder into public/.\n\nAstro uses the public/ directory for static assets, similar to Nuxt‚Äôs static/ folder.\n\nCopy or Move Nuxt‚Äôs other files and folders (e.g. pages, layouts etc.) into Astro‚Äôs src/ folder.\n\nLike Nuxt, Astro‚Äôs src/pages/ folder is a special folder used for file-based routing. All other folders are optional, and you can organize the contents of your src/ folder any way you like. Other common folders in Astro projects include src/layouts/, src/components, src/styles, src/scripts.\n\nConvert Vue SFC pages to .astro files\nSection titled Convert Vue SFC pages to .astro files\n\nHere are some tips for converting a Nuxt .vue component into a .astro component:\n\nUse the <template> of the existing NuxtJS component function as the basis for your HTML template.\n\nChange any Nuxt or Vue syntax to Astro or to HTML web standards. This includes <NextLink>, :class, {{variable}}, and v-if, for example.\n\nMove <script> JavaScript, into a ‚Äúcode fence‚Äù (---). Convert your component‚Äôs data-fetching properties to server-side JavaScript - see Nuxt data fetching to Astro.\n\nUse Astro.props to access any additional props that were previously passed to your Vue component.\n\nDecide whether any imported components also need to be converted to Astro. With the official integration installed, you can use existing Vue components in your Astro file. But, you may want to convert them to Astro, especially if they do not need to be interactive!\n\nSee an example from a Nuxt app converted step-by-step.\n\nCompare: Vue vs Astro\nSection titled Compare: Vue vs Astro\n\nCompare the following Nuxt component and a corresponding Astro component:\n\nVue\nAstro\nPage.vue\n<template>\n  <div>\n    <p v-if=\"message === 'Not found'\">\n      The repository you're looking up doesn't exist\n    </p>\n    <div v-else>\n      <Header/>\n      <p class=\"banner\">Astro has {{stars}} üßë‚ÄçüöÄ</p>\n      <Footer />\n    </div>\n  </div>\n</template>\n\n\n<script>\nimport Vue from 'vue'\n\n\nexport default Vue.extend({\n  name: 'IndexPage',\n  async asyncData() {\n    const res = await fetch('https://api.github.com/repos/withastro/astro')\n    const json = await res.json();\n    return {\n      message: json.message,\n      stars: json.stargazers_count || 0,\n    };\n  }\n});\n</script>\n\n\n<style scoped>\n.banner {\n  background-color: #f4f4f4;\n  padding: 1em 1.5em;\n  text-align: center;\n  margin-bottom: 1em;\n}\n<style>\nMigrating Layout Files\nSection titled Migrating Layout Files\n\nYou may find it helpful to start by converting your Nuxt layouts and templates into Astro layout components.\n\nEach Astro page explicitly requires <html>, <head>, and <body> tags to be present. Your Nuxt layout.vue and templates will not include these.\n\nNote the standard HTML templating, and direct access to <head>:\n\nsrc/layouts/Layout.astro\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n    <!-- Wrap the slot element with your existing layout templating -->\n    <slot />\n  </body>\n</html>\n\nYou may also wish to reuse code from your Nuxt‚Äôs page‚Äôs head property to include additional site metadata. Notice that Astro uses neither vue-meta nor a component‚Äôs head property but instead creates <head> directly. You may import and use components, even within <head>, to separate and organize your page content.\n\nMigrating Pages and Posts\nSection titled Migrating Pages and Posts\n\nIn NuxtJS, your pages live in /pages. In Astro, all your page‚Äôs content must live within src/pages or src/content.\n\nVue Pages\nSection titled Vue Pages\n\nYour existing Nuxt Vue (.vue) pages will need to be converted from Vue files to .astro pages. You cannot use an existing Vue page file in Astro.\n\nThese .astro pages must be located within src/pages/ and will have page routes generated automatically based on their file path.\n\nDynamic File Path Naming\nSection titled Dynamic File Path Naming\n\nIn Nuxt, your dynamic pages use an underscore to represent a dynamic page property that‚Äôs then passed to the page generation:\n\nDirectory\npages/\nDirectory\npokemon/\n_name.vue\nindex.vue\nnuxt.config.js\n\nTo convert to Astro, change this underscored dynamic path property (e.g. _name.vue) to be wrapped in a pair of square brackets (e.g. [name].astro):\n\nDirectory\nsrc/\nDirectory\npages/\nDirectory\npokemon/\n[name].astro\nindex.astro\nastro.config.mjs\nMarkdown and MDX pages\nSection titled Markdown and MDX pages\n\nAstro has built-in support for Markdown and an optional integration for MDX files. You can reuse any existing Markdown and MDX pages, but they may require some adjustments to their frontmatter, such as adding Astro‚Äôs special layout frontmatter property.\n\nYou will no longer need to manually create pages for each Markdown-generated route or use an external package like @nuxt/content. These files can be placed within src/pages/ to take advantage of automatic file-based routing.\n\nWhen part of a content collection, Markdown and MDX files will live in folders within src/content/ and you will generate those pages dynamically.\n\nMigrating Tests\nSection titled Migrating Tests\n\nAs Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box, if you have been able to match the markup of your Nuxt site. Testing libraries such as Jest and Vue Testing Library can be imported and used in Astro to test your Vue components.\n\nSee Astro‚Äôs testing guide for more.\n\nReference: Convert NuxtJS Syntax to Astro\nSection titled Reference: Convert NuxtJS Syntax to Astro\nNuxt Local Variables to Astro\nSection titled Nuxt Local Variables to Astro\n\nTo use local variables in an Astro component‚Äôs HTML, change the set of two curly braces to one set of curly braces:\n\nsrc/components/Component.astro\n---\nconst message = \"Hello!\"\n---\n<p>{{message}}</p>\n<p>{message}</p>\nNuxt Property Passing to Astro\nSection titled Nuxt Property Passing to Astro\n\nTo bind an attribute or component property in an Astro component, change this syntax to the following:\n\nsrc/components/Component.astro\n---\n---\n<p v-bind:aria-label=\"message\">...</p>\n<!-- Or -->\n<p :aria-label=\"message\">...</p>\n<!-- Also support component props -->\n<Header title=\"Page\"/>\n\n\n<p aria-label={message}>...</p>\n<!-- Also support component props -->\n<Header title={\"Page\"}/>\nNuxt Links to Astro\nSection titled Nuxt Links to Astro\n\nConvert any Nuxt <NuxtLink to=\"\"> components to HTML <a href=\"\"> tags.\n\n<NuxtLink to=\"/blog\">Blog</Link>\n<a href=\"/blog\">Blog</a>\n\nAstro does not use any special component for links, although you are welcome to build custom link components. You can then import and use this <Link> just as you would any other component.\n\nsrc/components/Link.astro\n---\nconst { to } = Astro.props\n---\n<a href={to}><slot /></a>\nNuxt Imports to Astro\nSection titled Nuxt Imports to Astro\n\nIf necessary, update any file imports to reference relative file paths exactly. This can be done using import aliases, or by writing out a relative path in full.\n\nNote that .astro and several other file types must be imported with their full file extension.\n\nsrc/pages/authors/Fred.astro\n---\nimport Card from `../../components/Card.astro`;\n---\n<Card />\nNuxt Dynamic Page Generation to Astro\nSection titled Nuxt Dynamic Page Generation to Astro\n\nIn Nuxt, to generate a dynamic page you either must:\n\nUse SSR.\nUse the generate function in nuxt.config.js to define all possible static routes.\n\nIn Astro, you similarly have two choices:\n\nUse SSR.\nExport a getStaticPaths() function in the frontmatter of an Astro page to tell the framework which static routes to generate dynamically.\nConvert a generate function in Nuxt to a getStaticPaths function in Astro.\nSection titled Convert a generate function in Nuxt to a getStaticPaths function in Astro.\n\nTo generate multiple pages, replace the function to create routes in your nuxt.config.js with getStaticPaths() directly inside a dynamic routing page itself:\n\nnuxt.config.js\n{\n  // ...\n    generate: {\n        async routes() {\n          // Axios is required here unless you're using Node 18\n          const res = await axios.get(\"https://pokeapi.co/api/v2/pokemon?limit=151\")\n          const pokemons = res.data.results;\n          return pokemons.map(pokemon => {\n            return '/pokemon/' + pokemon.name\n          })\n        }\n      }\n}\nsrc/pages/pokemon/[name].astro\n---\nexport const getStaticPaths = async () => {\n  const res = await fetch(\"https://pokeapi.co/api/v2/pokemon?limit=151\")\n  const resJson = await res.json();\n  const pokemons = resJson.results;\n  return pokemons.map(({ name }) => ({\n      params: { name },\n    }))\n}\n// ...\n---\n<!-- Your template here -->\nNuxt Data Fetching to Astro\nSection titled Nuxt Data Fetching to Astro\n\nNuxt has two methods of fetching server-side data:\n\nasyncData options API\nfetch hook\n\nIn Astro, fetch data inside of your page‚Äôs code fence.\n\nMigrate the following:\n\npages/index.vue\n{\n  // ...\n  async asyncData() {\n    const res = await fetch(\"https://pokeapi.co/api/v2/pokemon?limit=151\")\n    const resJson = await res.json();\n    const pokemons = resJson.results;\n    return {\n      pokemons,\n    }\n  },\n}\n\nTo a code fence without a wrapper function:\n\nsrc/pages/index.astro\n---\nconst res = await fetch(\"https://pokeapi.co/api/v2/pokemon?limit=151\")\nconst resJson = await res.json();\nconst pokemons = resJson.results;\n---\n\n\n<!-- Your template here -->\nNuxt Styling to Astro\nSection titled Nuxt Styling to Astro\n\nNuxt utilizes Vue‚Äôs component styling to generate a page‚Äôs style.\n\npages/index.vue\n<template>\n  <!-- Your template here -->\n</template>\n\n\n<script>\n  // Your server logic here\n</script>\n\n\n<style scoped>\n    .class {\n        color: red;\n    }\n</style>\n\nSimilarly, in Astro you can drop in a <style> element in your page‚Äôs template to provide scoped styles to the component.\n\nsrc/pages/index.vue\n---\n// Your server logic here\n---\n\n\n<style>\n    .class {\n        color: red;\n    }\n</style>\nGlobal Styling\nSection titled Global Styling\n\n<style> tags are scoped by default in Astro. To make a <style> tag global, mark it with the is:global attribute:\n\nsrc/pages/index.vue\n<style is:global>\n  p {\n    color: red;\n  }\n</style>\nPre-processor support\nSection titled Pre-processor support\n\nAstro supports the most popular CSS preprocessors by installing them as a dev dependency. For example, to use SCSS:\n\nTerminal window\nnpm install -D sass\n\nAfter doing so, you‚Äôre then able to use .scss or .sass styled without modification from your Vue components.\n\nsrc/layouts/Layout.astro\n<p>Hello, world</p>\n<style lang=\"scss\">\np {\n   color: black;\n\n\n   &:hover {\n       color: red;\n   }\n}\n</style>\n\nSee more about Styling in Astro.\n\nNuxt Image Plugin to Astro\nSection titled Nuxt Image Plugin to Astro\n\nConvert any Nuxt <nuxt-img/> or <nuxt-picture/> components to Astro‚Äôs own image component in .astro or .mdx files, or to a standard HTML <img> or <picture> tag as appropriate in your Vue components.\n\nAstro‚Äôs <Image /> component works in .astro and .mdx files only. See a full list of its component attributes and note that several will differ from Nuxt‚Äôs attributes.\n\nsrc/pages/index.astro\n---\nimport { Image } from 'astro:assets';\nimport rocket from '../assets/rocket.png';\n---\n<Image src={rocket} alt=\"A rocketship in space.\" />\n<img src={rocket.src} alt=\"A rocketship in space.\">\n\nIn Vue (.vue) components within your Astro app, use standard JSX image syntax (<img />). Astro will not optimize these images, but you can install and use NPM packages for more flexibility.\n\nYou can learn more about using images in Astro in the Images Guide.\n\nGuided example: See the steps!\nSection titled Guided example: See the steps!\n\nHere is an example of Nuxt Pok√©dex data fetch converted to Astro.\n\npages/index.vue fetches and displays a list of the first 151 Pok√©mon using the REST Pok√©API.\n\nHere‚Äôs how to recreate that in src/pages/index.astro, replacing asyncData() with fetch().\n\nIdentify the <template> and <style> in the Vue SFC.\n\npages/index.vue\n<template>\n  <ul class=\"plain-list pokeList\">\n            <li v-for=\"pokemon of pokemons\" class=\"pokemonListItem\" :key=\"pokemon.name\">\n                <NuxtLink class=\"pokemonContainer\" :to=\"`/pokemon/${pokemon.name}`\">\n                    <p class=\"pokemonId\">No. {{pokemon.id}}</p>\n                    <img\n                      class=\"pokemonImage\"\n                      :src=\"`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`\"\n                      :alt=\"`${pokemon.name} picture`\"/>\n                    <h2 class=\"pokemonName\">{{pokemon.name}}</h2>\n                </NuxtLink>\n            </li>\n    </ul>\n</template>\n\n\n<script>\nimport Vue from 'vue'\nexport default Vue.extend({\n  name: 'IndexPage',\n  layout: 'default',\n  async asyncData() {\n    const res = await fetch(\"https://pokeapi.co/api/v2/pokemon?limit=151\")\n    const resJson = await res.json();\n    const pokemons = resJson.results.map(pokemon => {\n        const name = pokemon.name;\n        // https://pokeapi.co/api/v2/pokemon/1/\n        const url = pokemon.url;\n        const id = url.split(\"/\")[url.split(\"/\").length - 2];\n        return {\n            name,\n            url,\n            id\n        }\n    });\n    return {\n      pokemons,\n    }\n  },\n  head() {\n    return {\n      title: \"Pokedex: Generation 1\"\n    }\n  }\n});\n</script>\n\n\n<style scoped>\n.pokeList {\n  display: grid;\n  grid-template-columns: repeat( auto-fit, minmax(250px, 1fr) );\n  gap: 1rem;\n}\n\n\n/* ... */\n</style>\n\nCreate src/pages/index.astro\n\nUse the <template> and <style> tags of the Nuxt SFC. Convert any Nuxt or Vue syntax to Astro.\n\nNote that:\n\n<template> is removed\n\n<style> has its scoped attribute removed\n\nv-for becomes .map.\n\n:attr=\"val\" becomes attr={val}\n\n<NuxtLink> becomes <a>.\n\nThe <> </> fragment is not required in Astro templating.\n\nsrc/pages/index.astro\n---\n---\n<ul class=\"plain-list pokeList\">\n    {pokemons.map((pokemon) => (\n        <li class=\"pokemonListItem\" key={pokemon.name}>\n            <a class=\"pokemonContainer\" href={`/pokemon/${pokemon.name}`}>\n                <p class=\"pokemonId\">No. {pokemon.id}</p>\n                <img class=\"pokemonImage\" src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`} alt={`${pokemon.name} picture`}/>\n                <h2 class=\"pokemonName\">{pokemon.name}</h2>\n            </a>\n        </li>\n    ))}\n</ul>\n\n\n<style>\n.pokeList {\n  display: grid;\n  grid-template-columns: repeat( auto-fit, minmax(250px, 1fr) );\n  gap: 1rem;\n}\n\n\n/* ... */\n</style>\n\nAdd any needed imports, props and JavaScript\n\nNote that:\n\nThe asyncData function is no longer needed. Data from the API is fetched directly in the code fence.\nA <Layout> component is imported, and wraps the page templating.\nOur head() Nuxt method is passed to the <Layout> component, which is passed to the <title> element as a property.\nsrc/pages/index.astro\n---\nimport Layout from '../layouts/layout.astro';\n\n\nconst res = await fetch(\"https://pokeapi.co/api/v2/pokemon?limit=151\");\nconst resJson = await res.json();\nconst pokemons = resJson.results.map(pokemon => {\n    const name = pokemon.name;\n    // https://pokeapi.co/api/v2/pokemon/1/\n    const url = pokemon.url;\n    const id = url.split(\"/\")[url.split(\"/\").length - 2];\n    return {\n        name,\n        url,\n        id\n    }\n});\n---\n\n\n<Layout title=\"Pokedex: Generation 1\">\n  <ul class=\"plain-list pokeList\">\n      {pokemons.map((pokemon) => (\n          <li class=\"pokemonListItem\" key={pokemon.name}>\n              <a class=\"pokemonContainer\" href={`/pokemon/${pokemon.name}`}>\n                  <p class=\"pokemonId\">No. {pokemon.id}</p>\n                  <img class=\"pokemonImage\" src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`} alt={`${pokemon.name} picture`}/>\n                  <h2 class=\"pokemonName\">{pokemon.name}</h2>\n              </a>\n          </li>\n      ))}\n  </ul>\n</Layout>\n\n\n<style>\n.pokeList {\n  display: grid;\n  grid-template-columns: repeat( auto-fit, minmax(250px, 1fr) );\n  gap: 1rem;\n}\n\n\n/* ... */\n</style>\nCommunity Resources\nSection titled Community Resources\nBlog Post: From Nuxt to Astro - rebuilding with Astro\nMore migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from Next.js üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-nextjs/",
    "html": "Migrating from Next.js\n\nHere are some key concepts and migration strategies to help you get started. Use the rest of our docs and our Discord community to keep going!\n\nKey Similarities between Next.js and Astro\nSection titled Key Similarities between Next.js and Astro\n\nNext.js and Astro share some similarities that will help you migrate your project:\n\nThe syntax of .astro files is similar to JSX. Writing Astro should feel familiar.\nAstro projects can also be SSG or SSR with page-level prerendering.\nAstro uses file-based routing, and allows specially named pages to create dynamic routes.\nAstro is component-based, and your markup structure will be similar before and after your migration.\nAstro has official integrations for React, Preact, and Solid so you can use your existing JSX components. Note that in Astro, these files must have a .jsx or .tsx extension.\nAstro has support for installing NPM packages, including React libraries. Many of your existing dependencies will work in Astro.\nKey Differences between Next.js and Astro\nSection titled Key Differences between Next.js and Astro\n\nWhen you rebuild your Next.js site in Astro, you will notice some important differences:\n\nNext.js is a React single-page app, and uses index.js as your project‚Äôs root. Astro is a multi-page site, and index.astro is your home page.\n\n.astro components are not written as exported functions that return page templating. Instead, you‚Äôll split your code into a ‚Äúcode fence‚Äù for your JavaScript and a body exclusively for the HTML you generate.\n\ncontent-driven: Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing Next.js app might be built for high client-side interactivity and may require advanced Astro techniques to include items that are more challenging to replicate using .astro components, such as dashboards.\n\nConvert your Next.js Project\nSection titled Convert your Next.js Project\n\nEach project migration will look different, but there are some common actions you will perform when converting from Next.js to Astro.\n\nCreate a new Astro project\nSection titled Create a new Astro project\n\nUse the create astro command for your package manager to launch Astro‚Äôs CLI wizard or choose a community theme from the Astro Theme Showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters (e.g. docs, blog, portfolio). Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\n# launch the Astro CLI Wizard\nnpm create astro@latest\n\n\n# create a new project with an official example\nnpm create astro@latest -- --template <example-name>\n\nThen, copy your existing Next project files over to your new Astro project in a separate folder outside of src.\n\n TIP\n\nVisit https://astro.new for the full list of official starter templates, and links for opening a new project in StackBlitz, CodeSandbox, or Gitpod.\n\nInstall integrations (optional)\nSection titled Install integrations (optional)\n\nYou may find it useful to install some of Astro‚Äôs optional integrations to use while converting your Next project to Astro:\n\n@astrojs/react: to reuse some existing React UI components in your new Astro site, or keep writing with React components.\n\n@astrojs/mdx: to bring existing MDX files from your Next project, or to use MDX in your new Astro site.\n\nPut your source code in src\nSection titled Put your source code in src\n\nFollowing Astro‚Äôs project structure:\n\nKeep Next‚Äôs public/ folder untouched.\n\nAstro uses the public/ directory for static assets, just like Next. There is no change needed to this folder, nor its contents.\n\nCopy or Move Next‚Äôs other files and folders (e.g. pages, styles etc.) into Astro‚Äôs src/ folder as you rebuild your site, following Astro‚Äôs project structure.\n\nLike Next, Astro‚Äôs src/pages/ folder is a special folder used for file-based routing. All other folders are optional, and you can organize the contents of your src/ folder any way you like. Other common folders in Astro projects include src/layouts/, src/components, src/styles, src/scripts.\n\nThe Astro config file\nSection titled The Astro config file\n\nAstro has a configuration file at the root of your project called astro.config.mjs. This is used only for configuring your Astro project and any installed integrations, including SSR adapters.\n\nTips: Convert JSX files to .astro files\nSection titled Tips: Convert JSX files to .astro files\n\nHere are some tips for converting a Next .js component into a .astro component:\n\nUse the returned JSX of the existing Next.js component function as the basis for your HTML template.\n\nChange any Next or JSX syntax to Astro or to HTML web standards. This includes <Link>, <Script>, {children}, and className, for example.\n\nMove any necessary JavaScript, including import statements, into a ‚Äúcode fence‚Äù (---). Note: JavaScript to conditionally render content is often written inside the HTML template directly in Astro.\n\nUse Astro.props to access any additional props that were previously passed to your Next function.\n\nDecide whether any imported components also need to be converted to Astro. With the official integration installed, you can use existing React components in your Astro file. But, you may want to convert them to .astro components, especially if they do not need to be interactive!\n\nReplace getStaticProps() with import statements or Astro.glob() to query your local files. Use fetch() to fetch external data.\n\nSee an example of a Next .js file converted step-by-step.\n\nCompare: JSX vs Astro\nSection titled Compare: JSX vs Astro\n\nCompare the following Next component and a corresponding Astro component:\n\nJSX\nAstro\nStarCount.jsx\nimport Header from \"./header\";\nimport Footer from './footer';\nimport \"./layout.css\";\n\n\nexport async function getStaticProps() {\n    const res = await fetch('https://api.github.com/repos/withastro/astro')\n    const json = await res.json()\n    return {\n        props: { message: json.message, stars: json.stargazers_count || 0 },\n    }\n}\n\n\nconst Component = ({ stars, message }) => {\n\n\n    return (\n        <>\n            <Header />\n            <p style={{\n                backgroundColor: `#f4f4f4`,\n                padding: `1em 1.5em`,\n                textAlign: `center`,\n                marginBottom: `1em`\n            }}>Astro has {stars} üßë‚ÄçüöÄ</p>\n            <Footer />\n        </>\n    )\n}\n\n\nexport default Component;\nMigrating Layout Files\nSection titled Migrating Layout Files\n\nYou may find it helpful to start by converting your Next.js layouts and templates into Astro layout components.\n\nNext has two different methods for creating layout files, each of which handles layouts differently than Astro:\n\nThe pages directory\n\nThe /app directory (in beta)\n\nEach Astro page explicitly requires <html>, <head>, and <body> tags to be present, so it is common to reuse a layout file across pages. Astro uses a <slot /> for page content, with no import statement required. Note the standard HTML templating, and direct access to <head>:\n\nsrc/layouts/Layout.astro\n---\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>Astro</title>\n  </head>\n  <body>\n    <!-- Wrap the slot element with your existing layout templating -->\n    <slot />\n  </body>\n</html>\nMigrating from Next.js‚Äô pages directory\nSection titled Migrating from Next.js‚Äô pages directory\n\nYour Next project may have a pages/_document.jsx file that imports React components to customize your app‚Äôs <head>:\n\npages/_document.jsx\nimport Document, { Html, Head, Main, NextScript } from \"next/document\";\n\n\nexport default class MyDocument extends Document {\n  render() {\n    return (\n      <Html lang=\"en\">\n        <Head>\n          <link rel=\"icon\" href=\"/favicon.ico\" />\n        </Head>\n        <body>\n          <Main />\n          <NextScript />\n        </body>\n      </Html>\n    );\n  }\n}\n\nMake a new Astro layout file using only the returned JSX.\n\nReplace any React components with <html>, <head>, <slot>, and other HTML standard tags.\n\nsrc/layouts/Document.astro\n<html lang=\"en\">\n  <head>\n      <link rel=\"icon\" href=\"/favicon.ico\" />\n  </head>\n  <body>\n    <slot/>\n  </body>\n</html>\nMigrating from Next.js‚Äô /app directory\nSection titled Migrating from Next.js‚Äô /app directory\n\nNext.js‚Äô app/ directory layout files are created with two files: a layout.jsx file to customize the <html> and <body> contents, and a head.jsx file to customize the <head> element contents.\n\napp/layout.jsx\nexport default function Layout({ children }) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n    </html>\n  );\n}\napp/head.jsx\nexport default function Head() {\n  return (\n    <>\n      <title>My Page</title>\n    </>\n  );\n}\n\nMake a new Astro layout file using only the returned JSX.\n\nReplace both these files with a single Astro layout file that contains a page shell (<html>, <head>, and <body> tags) and a <slot/> instead of React‚Äôs {children} prop:\n\nsrc/layouts/Layout.astro\n<html lang=\"en\">\n  <head>\n      <title>My Page</title>\n  </head>\n  <body>\n    <slot/>\n  </body>\n</html>\nMigrating Pages and Posts\nSection titled Migrating Pages and Posts\n\nIn Next.js, your posts either live in /pages or /app/routeName/page.jsx.\n\nIn Astro, all your page content must live within src/, in either src/pages or src/content.\n\nReact pages\nSection titled React pages\n\nYour existing Next JSX (.js) pages will need to be converted from JSX files to .astro pages. You cannot use an existing JSX page file in Astro.\n\nThese .astro pages must be located within src/pages/ and will have page routes generated automatically based on their file path.\n\nMarkdown and MDX pages\nSection titled Markdown and MDX pages\n\nAstro has built-in support for Markdown and an optional integration for MDX files. You can reuse any existing Markdown and MDX files, but they may require some adjustments to their frontmatter, such as adding Astro‚Äôs special layout frontmatter property. You will no longer need to manually create pages for each Markdown-generated route. These files can be placed within src/pages/ to take advantage of automatic file-based routing.\n\nAlternatively, you can use content collections in Astro to store and manage your content. When part of a collection, Markdown and MDX files will live in folders within src/content/. You will retrieve the content yourself and generate those pages dynamically.\n\nMigrating Tests\nSection titled Migrating Tests\n\nAs Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box if you have been able to match the markup of your Next site. Testing libraries such as Jest and React Testing Library can be imported and used in Astro to test your React components.\n\nSee Astro‚Äôs testing guide for more.\n\nReference: Convert Next.js Syntax to Astro\nSection titled Reference: Convert Next.js Syntax to Astro\nNext Links to Astro\nSection titled Next Links to Astro\n\nConvert any Next <Link to=\"\">, <NavLink> etc. components to HTML <a href=\"\"> tags.\n\n<Link to=\"/blog\">Blog</Link>\n<a href=\"/blog\">Blog</a>\n\nAstro does not use any special component for links, although you are welcome to build your own <Link> component. You can then import and use this <Link> just as you would any other component.\n\nsrc/components/Link.astro\n---\nconst { to } = Astro.props\n---\n<a href={to}><slot /></a>\nNext Imports to Astro\nSection titled Next Imports to Astro\n\nUpdate any file imports to reference relative file paths exactly. This can be done using import aliases, or by writing out a relative path in full.\n\nNote that .astro and several other file types must be imported with their full file extension.\n\nsrc/pages/authors/Fred.astro\n---\nimport Card from `../../components/Card.astro`\n---\n<Card />\nNext Children Props to Astro\nSection titled Next Children Props to Astro\n\nConvert any instances of {children} to an Astro <slot />. Astro does not need to receive {children} as a function prop and will automatically render child content in a <slot />.\n\nsrc/components/MyComponent\n---\n---\nexport default function MyComponent(props) {\n    return (\n      <div>\n        {props.children}\n      </div>\n    );\n}\n\n\n<div>\n  <slot />\n</div>\n\nReact components that pass multiple sets of children can be migrated to an Astro component using named slots.\n\nSee more about specific <slot /> usage in Astro.\n\nNext Data Fetching to Astro\nSection titled Next Data Fetching to Astro\n\nConvert any instances of getStaticProps() to either Astro.glob() or getCollection()/getEntryBySlug() in order to access data from other files in your project source. To fetch remote data, use fetch().\n\nThese data requests are made in the frontmatter of the Astro component and use top-level await.\n\nsrc/pages/index.astro\n---\nimport { getCollection } from 'astro:content';\n\n\n// Get all `src/content/blog/` entries\nconst allBlogPosts = await getCollection('blog');\n\n\n// Get all `src/pages/posts/` entries\nconst allPosts = await Astro.glob('../pages/posts/*.md');\n\n\nconst response = await fetch('https://randomuser.me/api/');\nconst data = await response.json();\nconst randomUser = data.results[0];\n---\n\nSee more about local files imports with Astro.glob(), querying using the Collections API or fetching remote data.\n\nNext Styling to Astro\nSection titled Next Styling to Astro\n\nYou may need to replace any CSS-in-JS libraries (e.g. styled-components) with other available CSS options in Astro.\n\nIf necessary, convert any inline style objects (style={{ fontWeight: \"bold\" }}) to inline HTML style attributes (style=\"font-weight:bold;\"). Or, use an Astro <style> tag for scoped CSS styles.\n\nsrc/components/Card.astro\n<div style={{backgroundColor: `#f4f4f4`, padding: `1em`}}>{message}</div>\n<div style=\"background-color: #f4f4f4; padding: 1em;\">{message}</div>\n\nTailwind is supported after installing the Tailwind integration. No changes to your existing Tailwind code are required!\n\nSee more about Styling in Astro.\n\nNext Image Plugin to Astro\nSection titled Next Image Plugin to Astro\n\nConvert any Next <Image /> components to Astro‚Äôs own image component in .astro or .mdx files, or to a standard HTML <img> / JSX <img /> tag as appropriate in your React components.\n\nAstro‚Äôs <Image /> component works in .astro and .mdx files only. See a full list of its component attributes and note that several will differ from Next‚Äôs attributes.\n\nsrc/pages/index.astro\n---\nimport { Image } from 'astro:assets';\nimport rocket from '../assets/rocket.png';\n---\n<Image src={rocket} alt=\"A rocketship in space.\" />\n<img src={rocket.src} alt=\"A rocketship in space.\">\n\nIn React (.jsx) components, use standard JSX image syntax (<img />). Astro will not optimize these images, but you can install and use NPM packages for more flexibility.\n\nYou can learn more about using images in Astro in the Images Guide.\n\nGuided example: Next data fetching to Astro\nSection titled Guided example: Next data fetching to Astro\n\nHere is an example of Next.js Pok√©dex data fetch converted to Astro.\n\npages/index.js fetches and displays a list of the first 151 Pok√©mon using the REST Pok√©API.\n\nHere‚Äôs how to recreate that in src/pages/index.astro, replacing getStaticProps() with fetch().\n\nIdentify the return() JSX.\n\npages/index.js\nimport Link from 'next/link'\nimport styles from '../styles/poke-list.module.css';\n\n\nexport default function Home({ pokemons }) {\n    return (\n        <>\n            <ul className={`plain-list ${styles.pokeList}`}>\n                {pokemons.map((pokemon) => (\n                    <li className={styles.pokemonListItem} key={pokemon.name}>\n                        <Link className={styles.pokemonContainer} as={`/pokemon/${pokemon.name}`} href=\"/pokemon/[name]\">\n                            <p className={styles.pokemonId}>No. {pokemon.id}</p>\n                            <img className={styles.pokemonImage} src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`} alt={`${pokemon.name} picture`}></img>\n                            <h2 className={styles.pokemonName}>{pokemon.name}</h2>\n                        </Link>\n                    </li>\n                ))}\n            </ul>\n        </>\n    )\n}\n\n\nexport const getStaticProps = async () => {\n    const res = await fetch(\"https://pokeapi.co/api/v2/pokemon?limit=151\")\n    const resJson = await res.json();\n    const pokemons = resJson.results.map(pokemon => {\n        const name = pokemon.name;\n        // https://pokeapi.co/api/v2/pokemon/1/\n        const url = pokemon.url;\n        const id = url.split(\"/\")[url.split(\"/\").length - 2];\n        return {\n            name,\n            url,\n            id\n        }\n    });\n    return {\n        props: {\n            pokemons,\n        },\n    }\n}\n\nCreate src/pages/index.astro\n\nUse the return value of the Next function. Convert any Next or React syntax to Astro, including changing the case of any HTML global attributes.\n\nNote that:\n\n.map just works!\n\nclassName becomes class.\n\n<Link> becomes <a>.\n\nThe <> </> fragment is not required in Astro templating.\n\nkey is a React attribute, and is not an attribute of li in Astro.\n\nsrc/pages/index.astro\n---\n---\n<ul class=\"plain-list pokeList\">\n    {pokemons.map((pokemon) => (\n        <li class=\"pokemonListItem\">\n            <a class=\"pokemonContainer\" href={`/pokemon/${pokemon.name}`}>\n                <p class=\"pokemonId\">No. {pokemon.id}</p>\n                <img class=\"pokemonImage\" src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`} alt={`${pokemon.name} picture`}/>\n                <h2 class=\"pokemonName\">{pokemon.name}</h2>\n            </a>\n        </li>\n    ))}\n</ul>\n\nAdd any needed imports, props, and JavaScript\n\nNote that:\n\nthe getStaticProps function is no longer needed. Data from the API is fetched directly in the code fence.\nA <Layout> component is imported and wraps the page templating.\nsrc/pages/index.astro\n---\nimport Layout from '../layouts/layout.astro';\n\n\nconst res = await fetch(\"https://pokeapi.co/api/v2/pokemon?limit=151\");\nconst resJson = await res.json();\nconst pokemons = resJson.results.map(pokemon => {\n    const name = pokemon.name;\n    // https://pokeapi.co/api/v2/pokemon/1/\n    const url = pokemon.url;\n    const id = url.split(\"/\")[url.split(\"/\").length - 2];\n    return {\n        name,\n        url,\n        id\n    }\n});\n---\n\n\n<Layout>\n  <ul class=\"plain-list pokeList\">\n      {pokemons.map((pokemon) => (\n          <li class=\"pokemonListItem\" key={pokemon.name}>\n              <a class=\"pokemonContainer\" href={`/pokemon/${pokemon.name}`}>\n                  <p class=\"pokemonId\">No. {pokemon.id}</p>\n                  <img class=\"pokemonImage\" src={`https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemon.id}.png`} alt={`${pokemon.name} picture`}/>\n                  <h2 class=\"pokemonName\">{pokemon.name}</h2>\n              </a>\n          </li>\n      ))}\n  </ul>\n</Layout>\nCommunity Resources\nSection titled Community Resources\n\nVideo: NextJS to Astro: more control = faster sites.\n\nVideo: How Astro made my site 100x faster.\n\nBlog post: Migrating from Next.js to Astro.\n\nBlog Post: From NextJS to Astro.\n\nBlog Post: Converting Next.js to Astro.\n\nMore migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Migrating from Gatsby üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-gatsby/",
    "html": "Migrating from Gatsby\n\nHere are some key concepts and migration strategies to help you get started. Use the rest of our docs and our Discord community to keep going!\n\nKey Similarities between Gatsby and Astro\nSection titled Key Similarities between Gatsby and Astro\n\nGatsby and Astro share some similarities that will help you migrate your project:\n\nThe syntax of .astro files is similar to JSX. Writing Astro should feel familiar.\n\nAstro has built-in support for Markdown and an integration for using MDX files. Also, you can configure and continue to use many of your existing Markdown plugins.\n\nAstro also has an official integration for using React components. Note that in Astro, React files must have a .jsx or .tsx extension.\n\nAstro has support for installing NPM packages, including React libraries. Many of your existing dependencies will work in Astro.\n\nLike Gatsby, Astro projects can be SSG or SSR with page-level prerendering.\n\nKey Differences between Gatsby and Astro\nSection titled Key Differences between Gatsby and Astro\n\nWhen you rebuild your Gatsby site in Astro, you will notice some important differences:\n\nGatsby projects are React single-page apps and use index.js as your project‚Äôs root. Astro projects are multi-page sites, and index.astro is your home page.\n\nAstro components are not written as exported functions that return page templating. Instead, you‚Äôll split your code into a ‚Äúcode fence‚Äù for your JavaScript and a body exclusively for the HTML you generate.\n\nLocal file data: Gatsby uses GraphQL to retrieve data from your project files. Astro uses ESM imports and top-level await functions (e.g. Astro.glob(), getCollection()) to import data from your project files. You can manually add GraphQL to your Astro project but it is not included by default.\n\nConvert your Gatsby Project\nSection titled Convert your Gatsby Project\n\nEach project migration will look different, but there are some common actions you will perform when converting from Gatsby to Astro.\n\nCreate a new Astro project\nSection titled Create a new Astro project\n\nUse the create astro command for your package manager to launch Astro‚Äôs CLI wizard or choose a community theme from the Astro Theme Showcase.\n\nYou can pass a --template argument to the create astro command to start a new Astro project with one of our official starters (e.g. docs, blog, portfolio). Or, you can start a new project from any existing Astro repository on GitHub.\n\nnpm\npnpm\nYarn\nTerminal window\n# launch the Astro CLI Wizard\nnpm create astro@latest\n\n\n# create a new project with an official example\nnpm create astro@latest -- --template <example-name>\n\nThen, copy your existing Gatsby project files over to your new Astro project into a separate folder outside of src.\n\n TIP\n\nVisit https://astro.new for the full list of official starter templates, and links for opening a new project in StackBlitz, CodeSandbox, or Gitpod.\n\nInstall integrations (optional)\nSection titled Install integrations (optional)\n\nYou may find it useful to install some of Astro‚Äôs optional integrations to use while converting your Gatsby project to Astro:\n\n@astrojs/react: to reuse some existing React UI components in your new Astro site or keep writing with React components.\n\n@astrojs/mdx: to bring existing MDX files from your Gatsby project, or to use MDX in your new Astro site.\n\nPut your code in src\nSection titled Put your code in src\n\nFollowing Astro‚Äôs project structure:\n\nDelete Gatsby‚Äôs public/ folder.\n\nGatsby uses the public/ directory for its build output, so you can safely discard this folder. You will no longer need a built version of your Gatsby site. (Astro uses dist/ by default for the build output.)\n\nRename Gatsby‚Äôs static/ folder to public/, and use it as Astro‚Äôs public/ folder.\n\nAstro uses a folder called public/ for static assets. You can alternatively copy the contents of static/ into your existing Astro public/ folder.\n\nCopy or Move Gatsby‚Äôs other files and folders (e.g. components, pages, etc.) as needed into your Astro src/ folder as you rebuild your site, following Astro‚Äôs project structure.\n\nAstro‚Äôs src/pages/ folder is a special folder used for file-based routing to create your site‚Äôs pages and posts from .astro, .md and .mdx files. You will not have to configure any routing behavior for your Astro, Markdown, and MDX files.\n\nAll other folders are optional, and you can organize the contents of your src/ folder any way you like. Other common folders in Astro projects include src/layouts/, src/components, src/styles, and src/scripts.\n\nTips: Convert JSX files to .astro files\nSection titled Tips: Convert JSX files to .astro files\n\nHere are some tips for converting a Gatsby .js component into a .astro component:\n\nUse only the return() of the existing Gatsby component function as your HTML template.\n\nChange any Gatsby or JSX syntax to Astro syntax or to HTML web standards. This includes <Link to=\"\">, {children}, and className, for example.\n\nMove any necessary JavaScript, including import statements, into a ‚Äúcode fence‚Äù (---). Note: JavaScript to conditionally render content is often written inside the HTML template directly in Astro.\n\nUse Astro.props to access any additional props that were previously passed to your Gatsby function.\n\nDecide whether any imported components also need to be converted to Astro. With the official React integration installed, you can use existing React components in your Astro files. But, you may want to convert them to .astro components, especially if they do not need to be interactive!\n\nRemove any GraphQL queries. Instead, use import and Astro.glob() statements to query your local files.\n\nSee an example from Gatsby‚Äôs Blog starter template converted step-by-step\n\nCompare: .jsx vs .astro\nSection titled Compare: .jsx vs .astro\n\nCompare the following Gatsby component and a corresponding Astro component:\n\nJSX\nAstro\ncomponent.jsx\nimport * as React from \"react\"\nimport { useStaticQuery, graphql } from \"gatsby\"\nimport Header from \"./header\"\nimport Footer from \"./footer\"\nimport \"./layout.css\"\n\n\nconst Component = ({ message, children }) => {\n  const data = useStaticQuery(graphql`\n    query SiteTitleQuery {\n      site {\n        siteMetadata {\n          title\n        }\n      }\n    }\n  `)\n  return (\n    <>\n      <Header siteTitle={data.site.siteMetadata.title} />\n      <div style={{ margin: `0`, maxWidth: `960`}}>{message}</div>\n      <main>{children}</main>\n      <Footer siteTitle={data.site.siteMetadata} />\n    </>\n  )\n}\n\n\nexport default Component\nMigrating Layout Files\nSection titled Migrating Layout Files\n\nYou may find it helpful to start by converting your Gatsby layouts and templates into Astro layout components.\n\nEach Astro page explicitly requires <html>, <head>, and <body> tags to be present, so it is common to reuse a layout file across pages. Astro uses a <slot /> instead of React‚Äôs {children} prop for page content, with no import statement required. Your Gatsby layout.js and templates will not include these.\n\nNote the standard HTML templating, and direct access to <head>:\n\nsrc/layouts/Layout.astro\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n    <!-- Wrap the slot element with your existing layout templating -->\n    <slot />\n  </body>\n</html>\n\nYou may also wish to reuse code from Gatsby‚Äôs src/components/seo.js to include additional site metadata. Notice that Astro uses neither <Helmet> nor <Header> but instead creates <head> directly. You may import and use components, even within <head>, to separate and organize your page content.\n\nMigrating Pages and Posts\nSection titled Migrating Pages and Posts\n\nIn Gatsby, your pages and posts may exist in src/pages/ or outside of src in another folder, like content. In Astro, all your page content must live within src/.\n\nReact Pages\nSection titled React Pages\n\nYour existing Gatsby JSX (.js) pages will need to be converted from JSX files to .astro pages. You cannot use an existing JSX page file in Astro.\n\nThese .astro pages must be located within src/pages/ and will have page routes generated automatically based on their file path.\n\nMarkdown and MDX pages\nSection titled Markdown and MDX pages\n\nAstro has built-in support for Markdown and an optional integration for MDX files. Your existing Markdown and MDX files can be reused but may require some adjustments to their frontmatter, such as adding Astro‚Äôs special layout frontmatter property. They can also be placed within src/pages/ to take advantage of automatic file-based routing.\n\nAlternatively, you can use content collections in Astro to store and manage your content. When part of a collection, Markdown and MDX files will live in folders within src/content/. You will retrieve the content yourself and generate those pages dynamically.\n\nMigrating Tests\nSection titled Migrating Tests\n\nAs Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box if you have been able to match the markup of the older Gatsby site. Testing libraries such as Jest and React Testing Library can be imported and used in Astro to test your React components.\n\nSee Astro‚Äôs testing guide for more.\n\nRepurpose config files\nSection titled Repurpose config files\n\nGatsby has several top-level configuration files that also include site and page metadata and are used for routing. You will not use any of these gatsby-*.js files in your Astro project, but there may be some content that you can reuse as you build your Astro project:\n\ngatsby-config.js: Move your siteMetadata: {} into src/data/siteMetadata.js (or siteMetadata.json) to import data about your site (title, description, social accounts, etc.) into page layouts.\n\ngatsby-browser.js: Consider adding anything used here directly into your main layout‚Äôs <head> tag.\n\ngatsby-node.js: You will not need to create your own nodes in Astro, but viewing the schema in this file may help you with defining types in your Astro project.\n\ngatsby-ssr.js: If you choose to use SSR in Astro, you will add and configure the SSR adapter of your choice directly in astro.config.mjs.\n\nReference: Convert to Astro Syntax\nSection titled Reference: Convert to Astro Syntax\n\nThe following are some examples of Gatsby-specific syntax that you will need to convert to Astro. See more differences between Astro and JSX in the guide to writing Astro components.\n\nGatsby Links to Astro\nSection titled Gatsby Links to Astro\n\nConvert any Gatsby <Link to=\"\">, <NavLink> etc. components to HTML <a href=\"\"> tags.\n\n<Link to=\"/blog\">Blog</Link>\n<a href=\"/blog\">Blog</a>\n\nAstro does not use any special component for links, although you are welcome to build your own <Link> component. You can then import and use this <Link> just as you would any other component.\n\nsrc/components/Link.astro\n---\nconst { to } = Astro.props\n---\n<a href={to}><slot /></a>\nGatsby Imports to Astro\nSection titled Gatsby Imports to Astro\n\nIf necessary, update any file imports to reference relative file paths exactly. This can be done using import aliases, or by writing out a relative path in full.\n\nNote that .astro and several other file types must be imported with their full file extension.\n\nsrc/pages/authors/Fred.astro\n---\nimport Card from `../../components/Card.astro`;\n---\n<Card />\nGatsby Children Props to Astro\nSection titled Gatsby Children Props to Astro\n\nConvert any instances of {children} to an Astro <slot />. Astro does not need to receive {children} as a function prop and will automatically render child content in a <slot />.\n\nsrc/components/MyComponent\n---\n---\nexport default function MyComponent(props) {\n    return (\n      <div>\n        {props.children}\n      </div>\n    );\n}\n\n\n<div>\n  <slot />\n</div>\n\nReact components that pass multiple sets of children can be migrated to an Astro component using named slots.\n\nSee more about specific <slot /> usage in Astro.\n\nGatsby Styling to Astro\nSection titled Gatsby Styling to Astro\n\nYou may need to replace any CSS-in-JS libraries (e.g. styled-components) with other available CSS options in Astro.\n\nIf necessary, convert any inline style objects (style={{ fontWeight: \"bold\" }}) to inline HTML style attributes (style=\"font-weight:bold;\"). Or, use an Astro <style> tag for scoped CSS styles.\n\nsrc/components/Card.astro\n<div style={{backgroundColor: `#f4f4f4`, padding: `1em`}}>{message}</div>\n<div style=\"background-color: #f4f4f4; padding: 1em;\">{message}</div>\n\nTailwind is supported after installing the Tailwind integration. No changes to your existing Tailwind code are required!\n\nGlobal styling is achieved in Gatsby using CSS imports in gatsby-browser.js. In Astro, you will import .css files directly into a main layout component to achieve global styles.\n\nSee more about Styling in Astro.\n\nGatsby Image Plugin to Astro\nSection titled Gatsby Image Plugin to Astro\n\nConvert Gatsby‚Äôs <StaticImage /> and <GatsbyImage /> components to Astro‚Äôs own image integration components, or to a standard HTML <img> / JSX <img /> tag as appropriate in your React components.\n\nsrc/pages/index.astro\n---\nimport { Image } from 'astro:assets';\nimport rocket from '../assets/rocket.png';\n---\n<Image src={rocket} alt=\"A rocketship in space.\" />\n<img src={rocket.src} alt=\"A rocketship in space.\">\n\nAstro‚Äôs <Image /> component works in .astro and .mdx files only. See a full list of its component attributes and note that several will differ from Gatsby‚Äôs attributes.\n\nTo continue using images in Markdown (.md) files using standard Markdown syntax (![]()), you may need to update the link. Using the HTML <img> tag directy is not supported in .md files for local images, and must be converted to Markdown syntax.\n\nsrc/pages/post-1.md\n# My Markdown Page\n\n\n<!-- Local image stored at src/assets/stars.png -->\n![A starry night sky.](../assets/stars.png)\n\nIn React (.jsx) components, use standard JSX image syntax (<img />). Astro will not optimize these images, but you can install and use NPM packages for more flexibility.\n\nYou can learn more about using images in Astro in the Images Guide.\n\nGatsby GraphQL to Astro\nSection titled Gatsby GraphQL to Astro\n\nRemove all references to GraphQL queries, and instead use Astro.glob() to access data from your local files.\n\nOr, if using content collections, query your Markdown and MDX files in src/content/ using getEntry() and getCollection().\n\nThese data requests are made in the frontmatter of the Astro component using the data.\n\nsrc/pages/index.astro\n---\nimport { graphql } from \"gatsby\"\nimport { getCollection } from 'astro:content';\n\n\n// Get all `src/content/blog/` entries\nconst allBlogPosts = await getCollection('blog');\n\n\n// Get all `src/pages/posts/` entries\nconst allPosts = await Astro.glob('../pages/posts/*.md');\n---\n\n\nexport const pageQuery = graphql`\n  {\n    allMarkdownRemark(sort: { frontmatter: { date: DESC } }) {\n      nodes {\n        excerpt\n        fields {\n          slug\n        }\n        frontmatter {\n          date(formatString: \"MMMM DD, YYYY\")\n          title\n          description\n        }\n      }\n    }\n  }\n`\nGuided example: Gatsby layout to Astro\nSection titled Guided example: Gatsby layout to Astro\n\nThis example converts the main project layout (layout.js) from Gatsby‚Äôs blog starter to src/layouts/Layout.astro.\n\nThis page layout shows one header when visiting the home page, and a different header with a link back to Home for all other pages.\n\nIdentify the return() JSX.\n\nlayout.js\nimport * as React from \"react\"\nimport { Link } from \"gatsby\"\nconst Layout = ({ location, title, children }) => {\n  const rootPath = `${__PATH_PREFIX__}/`\n  const isRootPath = location.pathname === rootPath\n  let header\n  if (isRootPath) {\n    header = (\n      <h1 className=\"main-heading\">\n        <Link to=\"/\">{title}</Link>\n      </h1>\n    )\n  } else {\n    header = (\n      <Link className=\"header-link-home\" to=\"/\">\n        Home\n      </Link>\n    )\n  }\n  return (\n    <div className=\"global-wrapper\" data-is-root-path={isRootPath}>\n      <header className=\"global-header\">{header}</header>\n      <main>{children}</main>\n      <footer>\n        ¬© {new Date().getFullYear()}, Built with\n        {` `}\n        <a href=\"https://www.gatsbyjs.com\">Gatsby</a>\n      </footer>\n    </div>\n  )\n}\nexport default Layout\n\nCreate Layout.astro and add this return value, converted to Astro syntax.\n\nNote that:\n\n{new Date().getFullYear()} just works üéâ\n{children} becomes <slot /> ü¶•\nclassName becomes class üìõ\nGatsby becomes Astro üöÄ\nsrc/layouts/Layout.astro\n---\n---\n<div class=\"global-wrapper\" data-is-root-path={isRootPath}>\n  <header class=\"global-header\">{header}</header>\n  <main><slot /></main>\n  <footer>\n    ¬© {new Date().getFullYear()}, Built with\n    {` `}\n    <a href=\"https://www.astro.build\">Astro</a>\n  </footer>\n</div>\n\nAdd a page shell so that your layout provides each page with the necessary parts of an HTML document:\n\nsrc/layouts/Layout.astro\n---\n---\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n    <div class=\"global-wrapper\" data-is-root-path={isRootPath}>\n      <header class=\"global-header\">{header}</header>\n      <main>\n        <slot />\n      </main>\n      <footer>\n        &#169; {new Date().getFullYear()}, Built with\n        {` `}\n        <a href=\"https://www.astro.build\">Astro</a>\n      </footer>\n    </div>\n  </body>\n</html>\n\nAdd any needed imports, props, and JavaScript\n\nTo conditionally render a header based on the page route and title in Astro:\n\nProvide the props via Astro.props. (Remember: your Astro templating accesses props from its frontmatter, not passed into a function.)\nUse a ternary operator to show one heading if this is the home page, and a different heading otherwise.\nRemove variables for {header} and {isRootPath} as they are no longer needed.\nReplace Gatsby‚Äôs <Link/> tags with <a> anchor tags.\nUse class instead of className.\nImport a local stylesheet from your project for the class names to take effect.\nsrc/layouts/Layout.astro\n---\nimport '../styles/style.css';\nconst { title, pathname } = Astro.props\n---\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n    <div class=\"global-wrapper\">\n      <header class=\"global-header\">\n        { pathname === \"/\"\n        ?\n          <h1 class=\"main-heading\">\n          <a href=\"/\">{title}</a>\n          </h1>\n        :\n          <h1 class=\"main-heading\">\n          <a class=\"header-link-home\" href=\"/\">Home</a>\n          </h1>\n        }\n      </header>\n      <main>\n        <slot />\n      </main>\n      <footer>\n        &#169; {new Date().getFullYear()}, Built with\n        {` `}\n        <a href=\"https://www.astro.build\">Astro</a>\n      </footer>\n    </div>\n  </body>\n</html>\n\nUpdate index.astro to use this new layout and pass it the necessary title and pathname props:\n\nsrc/pages/index.astro\n---\nimport Layout from '../layouts/Layout.astro';\nconst pagePathname = Astro.url.pathname\n---\n<Layout title=\"Home Page\" pathname={pagePathname}>\n    <p>Astro</p>\n</Layout>\n\n TIP\n\nYou can get the current page‚Äôs path using Astro.url.\n\nTo test the conditional header, create a second page, about.astro using the same pattern:\n\nsrc/pages/about.astro\n---\nimport Layout from '../layouts/Layout.astro';\nconst pagePathname = Astro.url.pathname\n---\n<Layout title=\"About\" pathname={pagePathname}>\n    <p>About</p>\n</Layout>\n\nYou should see a link to ‚ÄúHome‚Äù only when visiting the About page.\n\nCommunity Resources\nSection titled Community Resources\n\nBlog Post: Migrating to Astro was EZ.\n\nBlog Post: My Switch from Gatsby to Astro.\n\nBlog Post: Why I moved to Astro from Gatsby.\n\nBlog Post: Migrating my website from Gatsby to Astro.\n\n HAVE A RESOURCE TO SHARE?\n\nIf you found (or made!) a helpful video or blog post about converting a Gatsby site to Astro, edit this page and add it here!\n\nMore migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Using streaming to improve page performance üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/streaming-improve-page-performance/",
    "html": "Using streaming to improve page performance\n\nAstro‚Äôs SSR uses HTML streaming to send each component to the browser when available for faster page loading. To improve your page‚Äôs performance even further, you can build your components strategically to optimize their loading by avoiding blocking data fetches.\n\nThe following refactoring example demonstrates how to improve page performance by moving fetch calls to other components, moving them out of a component where they block page rendering.\n\nThe following page awaits some data in its frontmatter. Astro will wait for all of the fetch calls to resolve before sending any HTML to the browser.\n\nsrc/pages/index.astro\n---\nconst personResponse = await fetch('https://randomuser.me/api/');\nconst personData = await personResponse.json();\nconst randomPerson = personData.results[0];\nconst factResponse = await fetch('https://catfact.ninja/fact');\nconst factData = await factResponse.json();\n---\n<html>\n  <head>\n    <title>A name and a fact</title>\n  </head>\n  <body>\n    <h2>A name</h2>\n    <p>{randomPerson.name.first}</p>\n    <h2>A fact</h2>\n    <p>{factData.fact}</p>\n  </body>\n</html>\n\nMoving the await calls into smaller components allows you to take advantage of Astro‚Äôs streaming. Using the following components to perform the data fetches, Astro can render some HTML first, such as the title, and then the paragraphs when the data is ready.\n\nsrc/components/RandomName.astro\n---\nconst personResponse = await fetch('https://randomuser.me/api/');\nconst personData = await personResponse.json();\nconst randomPerson = personData.results[0];\n---\n<p>{randomPerson.name.first}</p>\nsrc/components/RandomFact.astro\n---\nconst factResponse = await fetch('https://catfact.ninja/fact');\nconst factData = await factResponse.json();\n---\n<p>{factData.fact}</p>\n\nThe Astro page below using these components can render parts of the page sooner. The <head>, <body>, and <h1> tags are no longer blocked by data fetches. The server will then fetch data for RandomName and RandomFact in parallel and stream the resulting HTML to the browser.\n\nsrc/pages/index.astro\n---\nimport RandomName from '../components/RandomName.astro'\nimport RandomFact from '../components/RandomFact.astro'\n---\n<html>\n  <head>\n    <title>A name and a fact</title>\n  </head>\n  <body>\n    <h2>A name</h2>\n    <RandomName />\n    <h2>A fact</h2>\n    <RandomFact />\n  </body>\n</html>\nIncluding Promises directly\nSection titled Including Promises directly\n\nYou can also include promises directly in the template. Instead of blocking the entire component, it will resolve the promise in parallel and only block the markup that comes after it.\n\nsrc/pages/index.astro\n---\nconst personPromise = fetch('https://randomuser.me/api/')\n  .then(response => response.json())\n  .then(arr => arr[0].name.first);\nconst factPromise = fetch('https://catfact.ninja/fact')\n  .then(response => response.json())\n  .then(factData => factData.fact);\n---\n<html>\n  <head>\n    <title>A name and a fact</title>\n  </head>\n  <body>\n    <h2>A name</h2>\n    <p>{personPromise}</p>\n    <h2>A fact</h2>\n    <p>{factPromise}</p>\n  </body>\n</html>\n\nIn this example, A name will render while personPromise and factPromise are loading. Once personPromise has resolved, A fact will appear and factPromise will render when it‚Äôs finished loading.\n\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "@astrojs/sitemap üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/sitemap/",
    "html": "@astrojs/sitemap\nv3.0.3\nGitHub\nnpm\nChangelog\n\nThis Astro integration generates a sitemap based on your pages when you build your Astro project.\n\nWhy Astro Sitemap\nSection titled Why Astro Sitemap\n\nA Sitemap is an XML file that outlines all of the pages, videos, and files on your site. Search engines like Google read this file to crawl your site more efficiently. See Google‚Äôs own advice on sitemaps to learn more.\n\nA sitemap file is recommended for large multi-page sites. If you don‚Äôt use a sitemap, most search engines will still be able to list your site‚Äôs pages, but a sitemap is a great way to ensure that your site is as search engine friendly as possible.\n\nWith Astro Sitemap, you don‚Äôt have to worry about creating this XML file yourself: the Astro Sitemap integration will crawl your statically-generated routes and create the sitemap file, including dynamic routes like [...slug] or src/pages/[lang]/[version]/info.astro generated by getStaticPaths().\n\nThis integration cannot generate sitemap entries for dynamic routes in SSR mode.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add sitemap\n# Using Yarn\nyarn astro add sitemap\n# Using PNPM\npnpm astro add sitemap\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/sitemap package using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/sitemap\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [sitemap()],\n  //             ^^^^^^^^^\n});\nUsage\nSection titled Usage\n\n@astrojs/sitemap requires a deployment / site URL for generation. Add your site‚Äôs URL under your astro.config.* using the site property. This must begin with http: or https:.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\n\nexport default defineConfig({\n  // ...\n  site: 'https://stargazers.club',\n  integrations: [sitemap()],\n});\n\nNote that unlike other configuration options, site is set in the root defineConfig object, rather than inside the sitemap() call.\n\nNow, build your site for production via the astro build command. You will find both sitemap-index.xml and sitemap-0.xml in the dist/ folder (or your custom output directory if set).\n\n CAUTION\n\nIf you forget to add a site, you‚Äôll get a friendly warning when you build, and the sitemap-index.xml file won‚Äôt be generated.\n\nAfter verifying that the sitemaps are built, you can add them to your site‚Äôs <head> and the robots.txt file for crawlers to pick up.\n\nsrc/layouts/Layout.astro\n<head>\n  <link rel=\"sitemap\" href=\"/sitemap-index.xml\" />\n</head>\npublic/robots.txt\nUser-agent: *\nAllow: /\n\n\nSitemap: https://<YOUR SITE>/sitemap-index.xml\nExample of generated files for a two-page website\nSection titled Example of generated files for a two-page website\nsitemap-index.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <sitemap>\n    <loc>https://stargazers.club/sitemap-0.xml</loc>\n  </sitemap>\n</sitemapindex>\nsitemap-0.xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\" xmlns:news=\"http://www.google.com/schemas/sitemap-news/0.9\" xmlns:xhtml=\"http://www.w3.org/1999/xhtml\" xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\" xmlns:video=\"http://www.google.com/schemas/sitemap-video/1.1\">\n  <url>\n    <loc>https://stargazers.club/</loc>\n  </url>\n  <url>\n    <loc>https://stargazers.club/second-page/</loc>\n  </url>\n</urlset>\nConfiguration\nSection titled Configuration\n\nTo configure this integration, pass an object to the sitemap() function call in astro.config.mjs.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\n\nexport default defineConfig({\n  integrations: [\n    sitemap({\n      // configuration options\n    }),\n  ],\n});\nfilter\nSection titled filter\n\nAll pages are included in your sitemap by default. By adding a custom filter function, you can filter included pages by URL.\n\nastro.config.mjs\n// ...\nsitemap({\n  filter: (page) => page !== 'https://stargazers.club/secret-vip-lounge/',\n});\n\nThe function will be called for every page on your site. The page function parameter is the full URL of the page currently under considering, including your site domain. Return true to include the page in your sitemap, and false to leave it out.\n\nTo filter multiple pages, add arguments with target URLs.\n\nastro.config.mjs\n// ...\nsitemap({\n  filter: (page) =>\n    page !== 'https://stargazers.club/secret-vip-lounge-1/' &&\n    page !== 'https://stargazers.club/secret-vip-lounge-2/' &&\n    page !== 'https://stargazers.club/secret-vip-lounge-3/' &&\n    page !== 'https://stargazers.club/secret-vip-lounge-4/',\n});\ncustomPages\nSection titled customPages\n\nIn some cases, a page might be part of your deployed site but not part of your Astro project. If you‚Äôd like to include a page in your sitemap that isn‚Äôt created by Astro, you can use this option.\n\nastro.config.mjs\n// ...\nsitemap({\n  customPages: ['https://stargazers.club/external-page', 'https://stargazers.club/external-page2'],\n});\nentryLimit\nSection titled entryLimit\n\nThe maximum number entries per sitemap file. The default value is 45000. A sitemap index and multiple sitemaps are created if you have more entries. See this explanation of splitting up a large sitemap.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\n\nexport default defineConfig({\n  site: 'https://stargazers.club',\n  integrations: [\n    sitemap({\n      entryLimit: 10000,\n    }),\n  ],\n});\nchangefreq, lastmod, and priority\nSection titled changefreq, lastmod, and priority\n\nThese options correspond to the <changefreq>, <lastmod>, and <priority> tags in the Sitemap XML specification.\n\nNote that changefreq and priority are ignored by Google.\n\n NOTE\n\nDue to limitations of Astro‚Äôs Integration API, this integration can‚Äôt analyze a given page‚Äôs source code. This configuration option can set changefreq, lastmod and priority on a site-wide basis; see the next option serialize for how you can set these values on a per-page basis.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\n\nexport default defineConfig({\n  site: 'https://stargazers.club',\n  integrations: [\n    sitemap({\n      changefreq: 'weekly',\n      priority: 0.7,\n      lastmod: new Date('2022-02-24'),\n    }),\n  ],\n});\nserialize\nSection titled serialize\n\nA function called for each sitemap entry just before writing to a disk. This function can be asynchronous.\n\nIt receives as its parameter a SitemapItem object that can have these properties:\n\nurl (absolute page URL). This is the only property that is guaranteed to be on SitemapItem.\nchangefreq\nlastmod (ISO formatted date, String type)\npriority\nlinks.\n\nThis links property contains a LinkItem list of alternate pages including a parent page.\n\nThe LinkItem type has two fields: url (the fully-qualified URL for the version of this page for the specified language) and lang (a supported language code targeted by this version of the page).\n\nThe serialize function should return SitemapItem, touched or not.\n\nThe example below shows the ability to add sitemap specific properties individually.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\n\nexport default defineConfig({\n  site: 'https://stargazers.club',\n  integrations: [\n    sitemap({\n      serialize(item) {\n        if (/exclude-from-sitemap/.test(item.url)) {\n          return undefined;\n        }\n        if (/your-special-page/.test(item.url)) {\n          item.changefreq = 'daily';\n          item.lastmod = new Date();\n          item.priority = 0.9;\n        }\n        return item;\n      },\n    }),\n  ],\n});\ni18n\nSection titled i18n\n\nTo localize a sitemap, pass an object to this i18n option.\n\nThis object has two required properties:\n\ndefaultLocale: String. Its value must exist as one of locales keys.\nlocales: Record<String, String>, key/value - pairs. The key is used to look for a locale part in a page path. The value is a language attribute, only English alphabet and hyphen allowed.\n\nRead more about language attributes.\n\nRead more about localization.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport sitemap from '@astrojs/sitemap';\n\n\nexport default defineConfig({\n  site: 'https://stargazers.club',\n  integrations: [\n    sitemap({\n      i18n: {\n        defaultLocale: 'en', // All urls that don't contain `es` or `fr` after `https://stargazers.club/` will be treated as default locale, i.e. `en`\n        locales: {\n          en: 'en-US', // The `defaultLocale` value must present in `locales` keys\n          es: 'es-ES',\n          fr: 'fr-CA',\n        },\n      },\n    }),\n  ],\n});\n\nThe resulting sitemap looks like this:\n\n...\n  <url>\n    <loc>https://stargazers.club/</loc>\n    <xhtml:link rel=\"alternate\" hreflang=\"en-US\" href=\"https://stargazers.club/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"es-ES\" href=\"https://stargazers.club/es/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"fr-CA\" href=\"https://stargazers.club/fr/\"/>\n  </url>\n  <url>\n    <loc>https://stargazers.club/es/</loc>\n    <xhtml:link rel=\"alternate\" hreflang=\"en-US\" href=\"https://stargazers.club/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"es-ES\" href=\"https://stargazers.club/es/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"fr-CA\" href=\"https://stargazers.club/fr/\"/>\n  </url>\n  <url>\n    <loc>https://stargazers.club/fr/</loc>\n    <xhtml:link rel=\"alternate\" hreflang=\"en-US\" href=\"https://stargazers.club/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"es-ES\" href=\"https://stargazers.club/es/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"fr-CA\" href=\"https://stargazers.club/fr/\"/>\n  </url>\n  <url>\n    <loc>https://stargazers.club/es/second-page/</loc>\n    <xhtml:link rel=\"alternate\" hreflang=\"es-ES\" href=\"https://stargazers.club/es/second-page/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"fr-CA\" href=\"https://stargazers.club/fr/second-page/\"/>\n    <xhtml:link rel=\"alternate\" hreflang=\"en-US\" href=\"https://stargazers.club/second-page/\"/>\n  </url>\n...\nExamples\nSection titled Examples\nThe official Astro website uses Astro Sitemap to generate its sitemap.\nBrowse projects with Astro Sitemap on GitHub for more examples!\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/prefetch üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/prefetch/",
    "html": "@astrojs/prefetch\nv0.4.1\nGitHub\nnpm\nChangelog\n\nNOTE: @astrojs/prefetch is deprecated. Use the prefetch feature in Astro 3.5 instead. Check out the migration guide.\n\nWhy Prefetch?\nSection titled Why Prefetch?\n\nPage load times play a big role in usability and overall enjoyment of a site. This integration brings the benefits of near-instant page navigations to your multi-page application (MPA) by prefetching page links when they are visible on screen.\n\nTo further improve the experience, especially on similar pages, stylesheets are also prefetched along with the HTML. This is particularly useful when navigating between tabs on a static site, where most of the page‚Äôs content and styles don‚Äôt change.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add prefetch\n# Using Yarn\nyarn astro add prefetch\n# Using PNPM\npnpm astro add prefetch\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/prefetch package using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/prefetch\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport prefetch from '@astrojs/prefetch';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [prefetch()],\n  //             ^^^^^^^^^^\n});\nUsage\nSection titled Usage\n\nWhen you install the integration, the prefetch script is automatically added to every page in the project. Just add rel=\"prefetch\" to any <a /> links on your page and you‚Äôre ready to go!\n\nIn addition, you can add rel=\"prefetch-intent\" to any <a /> links on your page to prefetch them only when they are hovered over, touched, or focused. This is especially useful to conserve data usage when viewing your site.\n\nConfiguration\nSection titled Configuration\n\nThe Astro Prefetch integration handles which links on the site are prefetched and it has its own options. Change these in the astro.config.mjs file which is where your project‚Äôs integration settings live.\n\nconfig.selector\nSection titled config.selector\n\nBy default the prefetch script searches the page for any links that include a rel=\"prefetch\" attribute, ex: <a rel=\"prefetch\" /> or <a rel=\"nofollow prefetch\" />. This behavior can be changed in your astro.config.* file to use a custom query selector when finding prefetch links.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport prefetch from '@astrojs/prefetch';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [\n    prefetch({\n      // Only prefetch links with an href that begins with `/products`\n      selector: \"a[href^='/products']\",\n    }),\n  ],\n});\nconfig.intentSelector\nSection titled config.intentSelector\n\nBy default, the prefetch script also searches the page for any links that include a rel=\"prefetch-intent\" attribute, ex: <a rel=\"prefetch-intent\" />. This behavior can be changed in your astro.config.* file to use a custom query selector when finding prefetch-intent links.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport prefetch from '@astrojs/prefetch';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [\n    prefetch({\n      // Only prefetch links with an href that begins with `/products` or `/coupons`\n      intentSelector: [\"a[href^='/products']\", \"a[href^='/coupons']\"],\n\n\n      // Use a string to prefetch a single selector\n      // intentSelector: \"a[href^='/products']\"\n    }),\n  ],\n});\nconfig.throttle\nSection titled config.throttle\n\nBy default the prefetch script will only prefetch one link at a time. This behavior can be changed in your astro.config.* file to increase the limit for concurrent downloads.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport prefetch from '@astrojs/prefetch';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [\n    prefetch({\n      // Allow up to three links to be prefetched concurrently\n      throttle: 3,\n    }),\n  ],\n});\nTroubleshooting\nSection titled Troubleshooting\nIf your installation doesn‚Äôt seem to be working, try restarting the dev server.\nIf a link doesn‚Äôt seem to be prefetching, make sure that the link is pointing to a page on the same domain and matches the integration‚Äôs selector option.\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/markdoc üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/markdoc/",
    "html": "@astrojs/markdoc\nv0.7.2\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables the usage of Markdoc to create components, pages, and content collection entries.\n\nWhy Markdoc?\nSection titled Why Markdoc?\n\nMarkdoc allows you to enhance your Markdown with Astro components. If you have existing content authored in Markdoc, this integration allows you to bring those files to your Astro project using content collections.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add markdoc\n# Using Yarn\nyarn astro add markdoc\n# Using PNPM\npnpm astro add markdoc\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/markdoc package using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/markdoc\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport markdoc from '@astrojs/markdoc';\nexport default defineConfig({\n  // ...\n  integrations: [markdoc()],\n  //             ^^^^^^^^^\n});\nEditor Integration\nSection titled Editor Integration\n\nVS Code supports Markdown by default. However, for Markdoc editor support, you may wish to add the following setting in your VSCode config. This ensures authoring Markdoc files provides a Markdown-like editor experience.\n\n.vscode/settings.json\n{\n  \"files.associations\": {\n    \"*.mdoc\": \"markdown\"\n  }\n}\nUsage\nSection titled Usage\n\nMarkdoc files can only be used within content collections. Add entries to any content collection using the .mdoc extension:\n\nTerminal window\nsrc/content/docs/\n  why-markdoc.mdoc\n  quick-start.mdoc\n\nThen, query your collection using the Content Collection APIs:\n\n---\nimport { getEntryBySlug } from 'astro:content';\n\n\nconst entry = await getEntryBySlug('docs', 'why-markdoc');\nconst { Content } = await entry.render();\n---\n\n\n<!--Access frontmatter properties with `data`-->\n<h1>{entry.data.title}</h1>\n<!--Render Markdoc contents with the Content component-->\n<Content />\n\nüìö See the Astro Content Collection docs for more information.\n\nMarkdoc config\nSection titled Markdoc config\n\n@astrojs/markdoc offers configuration options to use all of Markdoc‚Äôs features and connect UI components to your content.\n\nUse Astro components as Markdoc tags\nSection titled Use Astro components as Markdoc tags\n\nYou can configure Markdoc tags that map to .astro components. You can add a new tag by creating a markdoc.config.mjs|ts file at the root of your project and configuring the tag attribute.\n\nThis example renders an Aside component, and allows a type prop to be passed as a string:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig, component } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  tags: {\n    aside: {\n      render: component('./src/components/Aside.astro'),\n      attributes: {\n        // Markdoc requires type defs for each attribute.\n        // These should mirror the `Props` type of the component\n        // you are rendering.\n        // See Markdoc's documentation on defining attributes\n        // https://markdoc.dev/docs/attributes#defining-attributes\n        type: { type: String },\n      },\n    },\n  },\n});\n\nThis component can now be used in your Markdoc files with the {% aside %} tag. Children will be passed to your component‚Äôs default slot:\n\n# Welcome to Markdoc üëã\n\n\n{% aside type=\"tip\" %}\n\n\nUse tags like this fancy \"aside\" to add some _flair_ to your docs.\n\n\n{% /aside %}\nUse Astro components from npm packages and TypeScript files\nSection titled Use Astro components from npm packages and TypeScript files\n\nYou may need to use Astro components exposed as named exports from TypeScript or JavaScript files. This is common when using npm packages and design systems.\n\nYou can pass the import name as the second argument to the component() function:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig, component } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  tags: {\n    tabs: {\n      render: component('@astrojs/starlight/components', 'Tabs'),\n    },\n  },\n});\n\nThis generates the following import statement internally:\n\nimport { Tabs } from '@astrojs/starlight/components';\nCustom headings\nSection titled Custom headings\n\n@astrojs/markdoc automatically adds anchor links to your headings, and generates a list of headings via the content collections API. To further customize how headings are rendered, you can apply an Astro component as a Markdoc node.\n\nThis example renders a Heading.astro component using the render property:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig, nodes, component } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  nodes: {\n    heading: {\n      ...nodes.heading, // Preserve default anchor link generation\n      render: component('./src/components/Heading.astro'),\n    },\n  },\n});\n\nAll Markdown headings will render the Heading.astro component and pass the following attributes as component props:\n\nlevel: number The heading level 1 - 6\nid: string An id generated from the heading‚Äôs text contents. This corresponds to the slug generated by the content render() function.\n\nFor example, the heading ### Level 3 heading! will pass level: 3 and id: 'level-3-heading' as component props.\n\nSyntax highlighting\nSection titled Syntax highlighting\n\n@astrojs/markdoc provides Shiki and Prism extensions to highlight your code blocks.\n\nShiki\nSection titled Shiki\n\nApply the shiki() extension to your Markdoc config using the extends property. You can optionally pass a shiki configuration object:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig } from '@astrojs/markdoc/config';\nimport shiki from '@astrojs/markdoc/shiki';\n\n\nexport default defineMarkdocConfig({\n  extends: [\n    shiki({\n      // Choose from Shiki's built-in themes (or add your own)\n      // Default: 'github-dark'\n      // https://github.com/shikijs/shiki/blob/main/docs/themes.md\n      theme: 'dracula',\n      // Enable word wrap to prevent horizontal scrolling\n      // Default: false\n      wrap: true,\n      // Pass custom languages\n      // Note: Shiki has countless langs built-in, including `.astro`!\n      // https://github.com/shikijs/shiki/blob/main/docs/languages.md\n      langs: [],\n    }),\n  ],\n});\nPrism\nSection titled Prism\n\nApply the prism() extension to your Markdoc config using the extends property.\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig } from '@astrojs/markdoc/config';\nimport prism from '@astrojs/markdoc/prism';\n\n\nexport default defineMarkdocConfig({\n  extends: [prism()],\n});\n\nüìö To learn about configuring Prism stylesheets, see our syntax highlighting guide.\n\nSet the root HTML element\nSection titled Set the root HTML element\n\nMarkdoc wraps documents with an <article> tag by default. This can be changed from the document Markdoc node. This accepts an HTML element name or null if you prefer to remove the wrapper element:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig, nodes } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  nodes: {\n    document: {\n      ...nodes.document, // Apply defaults for other options\n      render: null, // default 'article'\n    },\n  },\n});\nCustom Markdoc nodes / elements\nSection titled Custom Markdoc nodes / elements\n\nYou may want to render standard Markdown elements, such as paragraphs and bolded text, as Astro components. For this, you can configure a Markdoc node. If a given node receives attributes, they will be available as component props.\n\nThis example renders blockquotes with a custom Quote.astro component:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig, nodes, component } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  nodes: {\n    blockquote: {\n      ...nodes.blockquote, // Apply Markdoc's defaults for other options\n      render: component('./src/components/Quote.astro'),\n    },\n  },\n});\n\nüìö Find all of Markdoc‚Äôs built-in nodes and node attributes on their documentation.\n\nUse client-side UI components\nSection titled Use client-side UI components\n\nTags and nodes are restricted to .astro files. To embed client-side UI components in Markdoc, use a wrapper .astro component that renders a framework component with your desired client: directive.\n\nThis example wraps a React Aside.tsx component with a ClientAside.astro component:\n\nsrc/components/ClientAside.astro\n---\nimport Aside from './Aside';\n---\n\n\n<Aside {...Astro.props} client:load />\n\nThis Astro component can now be passed to the render prop for any tag or node in your config:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig, component } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  tags: {\n    aside: {\n      render: component('./src/components/ClientAside.astro'),\n      attributes: {\n        type: { type: String },\n      },\n    },\n  },\n});\nMarkdoc config\nSection titled Markdoc config\n\nThe markdoc.config.mjs|ts file accepts all Markdoc configuration options, including tags and functions.\n\nYou can pass these options from the default export in your markdoc.config.mjs|ts file:\n\nmarkdoc.config.mjs\nimport { defineMarkdocConfig } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  functions: {\n    getCountryEmoji: {\n      transform(parameters) {\n        const [country] = Object.values(parameters);\n        const countryToEmojiMap = {\n          japan: 'üáØüáµ',\n          spain: 'üá™üá∏',\n          france: 'üá´üá∑',\n        };\n        return countryToEmojiMap[country] ?? 'üè≥';\n      },\n    },\n  },\n});\n\nNow, you can call this function from any Markdoc content entry:\n\n¬°Hola {% getCountryEmoji(\"spain\") %}!\n\nüìö See the Markdoc documentation for more on using variables or functions in your content.\n\nMarkdoc Language Server\nSection titled Markdoc Language Server\n\nIf you are using VS Code, there is an official Markdoc language extension that includes syntax highlighting and autocomplete for configured tags. See the language server on GitHub for more information.\n\nTo set up the extension, create a markdoc.config.json file into the project root with following content:\n\n[\n  {\n    \"id\": \"my-site\",\n    \"path\": \"src/content\",\n    \"schema\": {\n      \"path\": \"markdoc.config.mjs\",\n      \"type\": \"esm\",\n      \"property\": \"default\",\n      \"watch\": true\n    }\n  }\n]\n\nThe schema property contains all information to configure the language server for Astro content collections. It accepts following properties:\n\npath: The path to the configuration file.\ntype: The type of module your configuration file uses (esm allows import syntax).\nproperty: The exported property name that contains the configuration object.\nwatch: Tell the server to watch for changes in the configuration.\n\nThe top-level path property tells the server where content is located. Since Markdoc is specific to content collections, you can use src/content.\n\nPass Markdoc variables\nSection titled Pass Markdoc variables\n\nYou may need to pass variables to your content. This is useful when passing SSR parameters like A/B tests.\n\nVariables can be passed as props via the Content component:\n\n---\nimport { getEntryBySlug } from 'astro:content';\n\n\nconst entry = await getEntryBySlug('docs', 'why-markdoc');\nconst { Content } = await entry.render();\n---\n\n\n<!--Pass the `abTest` param as a variable-->\n<Content abTestGroup={Astro.params.abTestGroup} />\n\nNow, abTestGroup is available as a variable in docs/why-markdoc.mdoc:\n\n{% if $abTestGroup === 'image-optimization-lover' %}\n\n\nLet me tell you about image optimization...\n\n\n{% /if %}\n\nTo make a variable global to all Markdoc files, you can use the variables attribute from your markdoc.config.mjs|ts:\n\nimport { defineMarkdocConfig } from '@astrojs/markdoc/config';\n\n\nexport default defineMarkdocConfig({\n  variables: {\n    environment: process.env.IS_PROD ? 'prod' : 'dev',\n  },\n});\nAccess frontmatter from your Markdoc content\nSection titled Access frontmatter from your Markdoc content\n\nTo access frontmatter, you can pass the entry data property as a variable where you render your content:\n\n---\nimport { getEntry } from 'astro:content';\n\n\nconst entry = await getEntry('docs', 'why-markdoc');\nconst { Content } = await entry.render();\n---\n\n\n<Content frontmatter={entry.data} />\n\nThis can now be accessed as $frontmatter in your Markdoc.\n\nIntegration config options\nSection titled Integration config options\n\nThe Astro Markdoc integration handles configuring Markdoc options and capabilities that are not available through the markdoc.config.js file.\n\nallowHTML\nSection titled allowHTML\n\nEnables writing HTML markup alongside Markdoc tags and nodes.\n\nBy default, Markdoc will not recognize HTML markup as semantic content.\n\nTo achieve a more Markdown-like experience, where HTML elements can be included alongside your content, set allowHTML:true as a markdoc integration option. This will enable HTML parsing in Markdoc markup.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport markdoc from '@astrojs/markdoc';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [markdoc({ allowHTML: true })],\n  //                       ^^^^^^^^^^^^^^^\n});\n\n CAUTION\n\nWhen allowHTML is enabled, HTML markup inside Markdoc documents will be rendered as actual HTML elements (including <script>), making attack vectors like XSS possible. Ensure that any HTML markup comes from trusted sources.\n\nignoreIndentation\nSection titled ignoreIndentation\n\nBy default, any content that is indented by four spaces is treated as a code block. Unfortunately, this behavior makes it difficult to use arbitrary levels of indentation to improve the readability of documents with complex structure.\n\nWhen using nested tags in Markdoc, it can be helpful to indent the content inside of tags so that the level of depth is clear. To support arbitrary indentation, we have to disable the indent-based code blocks and modify several other markdown-it parsing rules that account for indent-based code blocks. These changes can be applied by enabling the ignoreIndentation option.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport markdoc from '@astrojs/markdoc';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [markdoc({ ignoreIndentation: true })],\n  //                       ^^^^^^^^^^^^^^^^^^^^^^^\n});\n# Welcome to Markdoc with indented tags üëã\n\n\n# Note: Can use either spaces or tabs for indentation\n\n\n{% custom-tag %}\n{% custom-tag %} ### Tags can be indented for better readability\n\n\n    {% another-custom-tag %}\n      This is easier to follow when there is a lot of nesting\n    {% /another-custom-tag %}\n\n\n{% /custom-tag %}\n{% /custom-tag %}\nExamples\nSection titled Examples\nThe Astro Markdoc starter template shows how to use Markdoc files in your Astro project.\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/partytown üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/partytown/",
    "html": "@astrojs/partytown\nv2.0.2\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables Partytown in your Astro project.\n\nWhy Astro Partytown\nSection titled Why Astro Partytown\n\nPartytown is a lazy-loaded library to help relocate resource intensive scripts into a web worker, and off of the main thread.\n\nIf you‚Äôre using third-party scripts for things like analytics or ads, Partytown is a great way to make sure that they don‚Äôt slow down your site.\n\nThe Astro Partytown integration installs Partytown for you and makes sure it‚Äôs enabled on all of your pages.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add partytown\n# Using Yarn\nyarn astro add partytown\n# Using PNPM\npnpm astro add partytown\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/partytown package using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/partytown\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport partytown from '@astrojs/partytown';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [partytown()],\n  //             ^^^^^^^^^^^\n});\nUsage\nSection titled Usage\n\nPartytown should be ready to go with zero config. If you have an existing 3rd party script on your site, try adding the type=\"text/partytown\" attribute:\n\n<script src=\"fancy-analytics.js\"></script>\n<script type=\"text/partytown\" src=\"fancy-analytics.js\"></script>\n\nIf you open the ‚ÄúNetwork‚Äù tab from your browser‚Äôs dev tools, you should see the partytown proxy intercepting this request.\n\nConfiguration\nSection titled Configuration\n\nTo configure this integration, pass a ‚Äòconfig‚Äô object to the partytown() function call in astro.config.mjs.\n\nastro.config.mjs\n// ...\nexport default defineConfig({\n  integrations: [\n    partytown({\n      config: {\n        // options go here\n      },\n    }),\n  ],\n});\n\nThis mirrors the Partytown config object.\n\nconfig.debug\nSection titled config.debug\n\nPartytown ships with a debug mode; enable or disable it by passing true or false to config.debug. If debug mode is enabled, it will output detailed logs to the browser console.\n\nIf this option isn‚Äôt set, debug mode will be on by default in dev or preview mode.\n\nastro.config.mjs\nexport default defineConfig({\n  integrations: [\n    partytown({\n      // Example: Disable debug mode.\n      config: { debug: false },\n    }),\n  ],\n});\nconfig.forward\nSection titled config.forward\n\nThird-party scripts typically add variables to the window object so that you can communicate with them throughout your site. But when a script is loaded in a web-worker, it doesn‚Äôt have access to that global window object.\n\nTo solve this, Partytown can ‚Äúpatch‚Äù variables to the global window object and forward them to the appropriate script.\n\nYou can specify which variables to forward with the config.forward option. Read more in Partytown‚Äôs documentation.\n\nastro.config.mjs\nexport default defineConfig({\n  integrations: [\n    partytown({\n      // Example: Add dataLayer.push as a forwarding-event.\n      config: {\n        forward: ['dataLayer.push'],\n      },\n    }),\n  ],\n});\nExamples\nSection titled Examples\nBrowse projects with Astro Partytown on GitHub for more examples!\nTroubleshooting\nSection titled Troubleshooting\nIf you‚Äôre getting a Failed to fetch error, make sure you‚Äôre not using any browser extensions that are blocking the script.\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/vercel üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/vercel/",
    "html": "@astrojs/vercel\nv5.2.0\nGitHub\nnpm\nChangelog\n\nThis adapter allows Astro to deploy your SSR site to Vercel.\n\nLearn how to deploy your Astro site in our Vercel deployment guide.\n\nWhy Astro Vercel\nSection titled Why Astro Vercel\n\nIf you‚Äôre using Astro as a static site builder ‚Äî its behavior out of the box ‚Äî you don‚Äôt need an adapter.\n\nIf you wish to use server-side rendering (SSR), Astro requires an adapter that matches your deployment runtime.\n\nVercel is a deployment platform that allows you to host your site by connecting directly to your GitHub repository. This adapter enhances the Astro build process to prepare your project for deployment through Vercel.\n\nInstallation\nSection titled Installation\n\nAdd the Vercel adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\n# Using NPM\nnpx astro add vercel\n# Using Yarn\nyarn astro add vercel\n# Using PNPM\npnpm astro add vercel\nAdd dependencies manually\nSection titled Add dependencies manually\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nInstall the Vercel adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\n  npm install @astrojs/vercel\n\nAdd two new lines to your astro.config.mjs project configuration file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel(),\n});\nTargets\nSection titled Targets\n\nYou can deploy to different targets:\n\nserverless: SSR inside a Node.js function.\nstatic: generates a static website following Vercel‚Äôs output formats, redirects, etc.\n\nYou can change where to target by changing the import:\n\nimport vercel from '@astrojs/vercel/serverless';\nimport vercel from '@astrojs/vercel/static';\nUsage\nSection titled Usage\n\nüìö Read the full deployment guide here.\n\nYou can deploy by CLI (vercel deploy) or by connecting your new repo in the Vercel Dashboard. Alternatively, you can create a production build locally:\n\nTerminal window\nastro build\nvercel deploy --prebuilt\nConfiguration\nSection titled Configuration\n\nTo configure this adapter, pass an object to the vercel() function call in astro.config.mjs:\n\nWeb Analytics\nSection titled Web Analytics\n\nType: VercelWebAnalyticsConfig\nAvailable for: Serverless, Edge, Static\nAdded in: @astrojs/vercel@3.8.0\n\nYou can enable Vercel Web Analytics by setting webAnalytics: { enabled: true }. This will inject Vercel‚Äôs tracking scripts into all of your pages.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    webAnalytics: {\n      enabled: true,\n    },\n  }),\n});\nSpeed Insights\nSection titled Speed Insights\n\nYou can enable Vercel Speed Insights by setting speedInsights: { enabled: true }. This will collect and send Web Vital data to Vercel.\n\nType: VercelSpeedInsightsConfig\nAvailable for: Serverless, Edge, Static\nAdded in: @astrojs/vercel@3.8.0\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    speedInsights: {\n      enabled: true,\n    },\n  }),\n});\nimagesConfig\nSection titled imagesConfig\n\nType: VercelImageConfig\nAvailable for: Serverless, Static Added in: @astrojs/vercel@3.3.0\n\nConfiguration options for Vercel‚Äôs Image Optimization API. See Vercel‚Äôs image configuration documentation for a complete list of supported parameters.\n\nThe domains and remotePatterns properties will automatically be filled using the Astro corresponding image settings.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/static';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    imagesConfig: {\n      sizes: [320, 640, 1280],\n    },\n  }),\n});\nimageService\nSection titled imageService\n\nType: boolean\nAvailable for: Serverless, Static Added in: @astrojs/vercel@3.3.0\n\nWhen enabled, an Image Service powered by the Vercel Image Optimization API will be automatically configured and used in production. In development, the image service specified by devImageService will be used instead.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/static';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    imageService: true,\n  }),\n});\n---\nimport { Image } from 'astro:assets';\nimport astroLogo from '../assets/logo.png';\n---\n\n\n<!-- This component -->\n<Image src={astroLogo} alt=\"My super logo!\" />\n\n\n<!-- will become the following HTML -->\n<img\n  src=\"/_vercel/image?url=_astro/logo.hash.png&w=...&q=...\"\n  alt=\"My super logo!\"\n  loading=\"lazy\"\n  decoding=\"async\"\n  width=\"...\"\n  height=\"...\"\n/>\ndevImageService\nSection titled devImageService\n\nType: 'sharp' | 'squoosh' | string\nAvailable for: Serverless, Static Added in: @astrojs/vercel@3.3.0 Default: ‚Äòsharp‚Äô\n\nAllows you to configure which image service to use in development when imageService is enabled. This can be useful if you cannot install Sharp‚Äôs dependencies on your development machine, but using another image service like Squoosh would allow you to preview images in your dev environment. Build is unaffected and will always use Vercel‚Äôs Image Optimization.\n\nIt can also be set to any arbitrary value in order to use a custom image service instead of Astro‚Äôs built-in ones.\n\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    imageService: true,\n    devImageService: 'squoosh',\n  }),\n});\nincludeFiles\nSection titled includeFiles\n\nType: string[]\nAvailable for: Serverless\n\nUse this property to force files to be bundled with your function. This is helpful when you notice missing files.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    includeFiles: ['./my-data.json'],\n  }),\n});\nexcludeFiles\nSection titled excludeFiles\n\nType: string[]\nAvailable for: Serverless\n\nUse this property to exclude any files from the bundling process that would otherwise be included.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    excludeFiles: ['./src/some_big_file.jpg'],\n  }),\n});\nmaxDuration\nSection titled maxDuration\n\nType: number\nAvailable for: Serverless\n\nUse this property to extend or limit the maximum duration (in seconds) that Serverless Functions can run before timing out. See the Vercel documentation for the default and maximum limit for your account plan.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n    output: \"server\",\n    adapter: vercel({\n       maxDuration: 60\n    }),\n});\nFunction bundling configuration\nSection titled Function bundling configuration\n\nThe Vercel adapter combines all of your routes into a single function by default.\n\nYou also have the option to split builds into a separate function for each route using the functionPerRoute option. This reduces the size of each function, meaning you are less likely to exceed the size limit for an individual function. Also, code starts are faster.\n\nVerify that your Vercel plan includes an appropriate number of functions before enabling functionPerRoute. For example, Vercel‚Äôs free tier limits each deployment to no more than 12 functions. If your Vercel plan is insufficient for the number of routes in your project, you will receive an error message during deployment.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    functionPerRoute: true,\n  }),\n});\nVercel Edge Middleware\nSection titled Vercel Edge Middleware\n\nYou can use Vercel Edge middleware to intercept a request and redirect before sending a response. Vercel middleware can run for Edge, SSR, and Static deployments. You may not need to install this package for your middleware. @vercel/edge is only required to use some middleware features such as geolocation. For more information see Vercel‚Äôs middleware documentation.\n\nAdd a middleware.js file to the root of your project:\n\nmiddleware.js\nexport const config = {\n  // Only run the middleware on the admin route\n  matcher: '/admin',\n};\n\n\nexport default function middleware(request) {\n  const url = new URL(request.url);\n  // You can retrieve IP location or cookies here.\n  if (url.pathname === '/admin') {\n    url.pathname = '/';\n  }\n  return Response.redirect(url);\n}\n\nWhile developing locally, you can run vercel dev to run middleware. In production, Vercel will handle this for you.\n\n CAUTION\n\nTrying to rewrite? Currently rewriting a request with middleware only works for static files.\n\nVercel Edge Middleware with Astro middleware\nSection titled Vercel Edge Middleware with Astro middleware\n\nThe @astrojs/vercel/serverless adapter can automatically create the Vercel Edge middleware from an Astro middleware in your code base.\n\nThis is an opt-in feature, and the edgeMiddleware option needs to be set to true:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel({\n    edgeMiddleware: true,\n  }),\n});\n\nOptionally, you can create a file recognized by the adapter named vercel-edge-middleware.(js|ts) in the srcDir folder to create Astro.locals.\n\nTypings requires the @vercel/edge package.\n\nsrc/vercel-edge-middleware.js\n/**\n *\n * @param options.request {Request}\n * @param options.context {import(\"@vercel/edge\").RequestContext}\n * @returns {object}\n */\nexport default function ({ request, context }) {\n  // do something with request and context\n  return {\n    title: \"Spider-man's blog\",\n  };\n}\n\nIf you use TypeScript, you can type the function as follows:\n\nsrc/vercel-edge-middleware.ts\nimport type { RequestContext } from '@vercel/edge';\n\n\nexport default function ({ request, context }: { request: Request; context: RequestContext }) {\n  // do something with request and context\n  return {\n    title: \"Spider-man's blog\",\n  };\n}\n\nThe data returned by this function will be passed to Astro middleware.\n\nThe function:\n\nmust export a default function;\nmust return an object;\naccepts an object with a request and context as properties;\nrequest is typed as Request;\ncontext is typed as RequestContext;\nLimitations and constraints\nSection titled Limitations and constraints\n\nWhen you opt in to this feature, there are few constraints to note:\n\nThe Vercel Edge middleware will always be the first function to receive the Request and the last function to receive Response. This an architectural constraint that follows the boundaries set by Vercel.\nOnly request and context may be used to produce an Astro.locals object. Operations like redirects, etc. should be delegated to Astro middleware.\nAstro.locals must be serializable. Failing to do so will result in a runtime error. This means that you cannot store complex types like Map, function, Set, etc.\nTroubleshooting\nSection titled Troubleshooting\n\nA few known complex packages (example: puppeteer) do not support bundling and therefore will not work properly with this adapter. By default, Vercel doesn‚Äôt include npm installed files & packages from your project‚Äôs ./node_modules folder. To address this, the @astrojs/vercel adapter automatically bundles your final build output using esbuild.\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/node üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/node/",
    "html": "@astrojs/node\nv6.1.0\nGitHub\nnpm\nChangelog\n\nThis adapter allows Astro to deploy your SSR site to Node targets.\n\nWhy Astro Node.js\nSection titled Why Astro Node.js\n\nIf you‚Äôre using Astro as a static site builder‚Äîits behavior out of the box‚Äîyou don‚Äôt need an adapter.\n\nIf you wish to use server-side rendering (SSR), Astro requires an adapter that matches your deployment runtime.\n\nNode.js is a JavaScript runtime for server-side code. @astrojs/node can be used either in standalone mode or as middleware for other http servers, such as Express.\n\nInstallation\nSection titled Installation\n\nAdd the Node adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\n# Using NPM\nnpx astro add node\n# Using Yarn\nyarn astro add node\n# Using PNPM\npnpm astro add node\nAdd dependencies manually\nSection titled Add dependencies manually\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nInstall the Node adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\n  npm install @astrojs/node\n\nAdd two new lines to your astro.config.mjs project configuration file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport node from '@astrojs/node';\n\n\n export default defineConfig({\n  output: 'server',\n  adapter: node({\n    mode: 'standalone',\n  }),\n});\nConfiguration\nSection titled Configuration\n\n@astrojs/node can be configured by passing options into the adapter function. The following options are available:\n\nMode\nSection titled Mode\n\nControls whether the adapter builds to middleware or standalone mode.\n\nmiddleware mode allows the built output to be used as middleware for another Node.js server, like Express.js or Fastify.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport node from '@astrojs/node';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: node({\n    mode: 'middleware',\n  }),\n});\n\nstandalone mode builds to server that automatically starts with the entry module is run. This allows you to more easily deploy your build to a host without any additional code.\n\nUsage\nSection titled Usage\n\nFirst, performing a build. Depending on which mode selected (see above) follow the appropriate steps below:\n\nMiddleware\nSection titled Middleware\n\nThe server entrypoint is built to ./dist/server/entry.mjs by default. This module exports a handler function that can be used with any framework that supports the Node request and response objects.\n\nFor example, with Express:\n\nrun-server.mjs\nimport express from 'express';\nimport { handler as ssrHandler } from './dist/server/entry.mjs';\n\n\nconst app = express();\n// Change this based on your astro.config.mjs, `base` option.\n// They should match. The default value is \"/\".\nconst base = '/';\napp.use(base, express.static('dist/client/'));\napp.use(ssrHandler);\n\n\napp.listen(8080);\n\nOr, with Fastify (>4):\n\nrun-server.mjs\nimport Fastify from 'fastify';\nimport fastifyMiddie from '@fastify/middie';\nimport fastifyStatic from '@fastify/static';\nimport { fileURLToPath } from 'node:url';\nimport { handler as ssrHandler } from './dist/server/entry.mjs';\n\n\nconst app = Fastify({ logger: true });\n\n\nawait app\n  .register(fastifyStatic, {\n    root: fileURLToPath(new URL('./dist/client', import.meta.url)),\n  })\n  .register(fastifyMiddie);\napp.use(ssrHandler);\n\n\napp.listen({ port: 8080 });\n\nAdditionally, you can also pass in an object to be accessed with Astro.locals or in Astro middleware:\n\nrun-server.mjs\nimport express from 'express';\nimport { handler as ssrHandler } from './dist/server/entry.mjs';\n\n\nconst app = express();\napp.use(express.static('dist/client/'));\napp.use((req, res, next) => {\n  const locals = {\n    title: 'New title',\n  };\n\n\n  ssrHandler(req, res, next, locals);\n});\n\n\napp.listen(8080);\n\nNote that middleware mode does not do file serving. You‚Äôll need to configure your HTTP framework to do that for you. By default the client assets are written to ./dist/client/.\n\nStandalone\nSection titled Standalone\n\nIn standalone mode a server starts when the server entrypoint is run. By default it is built to ./dist/server/entry.mjs. You can run it with:\n\nTerminal window\nnode ./dist/server/entry.mjs\n\nFor standalone mode the server handles file servering in addition to the page and API routes.\n\nCustom host and port\nSection titled Custom host and port\n\nYou can override the host and port the standalone server runs on by passing them as environment variables at runtime:\n\nTerminal window\nHOST=0.0.0.0 PORT=4321 node ./dist/server/entry.mjs\nHTTPS\nSection titled HTTPS\n\nBy default the standalone server uses HTTP. This works well if you have a proxy server in front of it that does HTTPS. If you need the standalone server to run HTTPS itself you need to provide your SSL key and certificate.\n\nYou can pass the path to your key and certification via the environment variables SERVER_CERT_PATH and SERVER_KEY_PATH. This is how you might pass them in bash:\n\nTerminal window\nSERVER_KEY_PATH=./private/key.pem SERVER_CERT_PATH=./private/cert.pem node ./dist/server/entry.mjs\nRuntime environment variables\nSection titled Runtime environment variables\n\nIf an .env file containing environment variables is present when the build process is run, these values will be hard-coded in the output, just as when generating a static website.\n\nDuring the build, the runtime variables must be absent from the .env file, and you must provide Astro with every environment variable to expect at run-time: VARIABLE_1=placeholder astro build. This signals to Astro that the actual value will be available when the built application is run. The placeholder value will be ignored by the build process, and Astro will use the value provided at run-time.\n\nIn the case of multiple run-time variables, store them in a seperate file (e.g. .env.runtime) from .env. Start the build with the following command:\n\nTerminal window\nexport $(cat .env.runtime) && astro build\nTroubleshooting\nSection titled Troubleshooting\nSyntaxError: Named export ‚Äòcompile‚Äô not found\nSection titled SyntaxError: Named export ‚Äòcompile‚Äô not found\n\nYou may see this when running the entry script if it was built with npm or Yarn. This is a known issue that may be fixed in a future release. As a workaround, add \"path-to-regexp\" to the noExternal array:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport node from '@astrojs/node';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: node(),\n  vite: {\n    ssr: {\n      noExternal: ['path-to-regexp'],\n    },\n  },\n});\n\nFor more help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/netlify üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/netlify/",
    "html": "@astrojs/netlify\nv3.0.4\nGitHub\nnpm\nChangelog\n\nThis adapter allows Astro to deploy your SSR site to Netlify.\n\nLearn how to deploy your Astro site in our Netlify deployment guide.\n\nWhy Astro Netlify\nSection titled Why Astro Netlify\n\nIf you‚Äôre using Astro as a static site builder‚Äîits behavior out of the box‚Äîyou don‚Äôt need an adapter.\n\nIf you wish to use server-side rendering (SSR), Astro requires an adapter that matches your deployment runtime.\n\nNetlify is a deployment platform that allows you to host your site by connecting directly to your GitHub repository. This adapter enhances the Astro build process to prepare your project for deployment through Netlify.\n\nInstallation\nSection titled Installation\n\nAdd the Netlify adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\n# Using NPM\nnpx astro add netlify\n# Using Yarn\nyarn astro add netlify\n# Using PNPM\npnpm astro add netlify\nAdd dependencies manually\nSection titled Add dependencies manually\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nInstall the Netlify adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\n  npm install @astrojs/netlify\n\nAdd two new lines to your astro.config.mjs project configuration file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/functions';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: netlify(),\n});\nRun middleware in Edge Functions\nSection titled Run middleware in Edge Functions\n\nWhen deploying to Netlify Functions, you can choose to use an Edge Function to run your Astro middleware.\n\nTo enable this, set the edgeMiddleware config option to true:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/functions';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: netlify({\n    edgeMiddleware: true,\n  }),\n});\nPass edge context to your site\nSection titled Pass edge context to your site\n\nNetlify Edge Functions provide a context object including metadata about the request, such as a user‚Äôs IP, geolocation data, and cookies.\n\nTo expose values from this context to your site, create a netlify-edge-middleware.ts (or .js) file in your project‚Äôs source directory. This file must export a function that returns the data to add to Astro‚Äôs locals object, which is available in middleware and Astro routes.\n\nIn this example, visitorCountry and hasEdgeMiddleware would both be added to Astro‚Äôs locals object:\n\nsrc/netlify-edge-middleware.ts\nimport type { Context } from 'https://edge.netlify.com';\n\n\nexport default function ({ request, context }: { request: Request; context: Context }) {\n  // Return serializable data to add to Astro.locals\n  return {\n    visitorCountry: context.geo.country.name,\n    hasEdgeMiddleware: true,\n  };\n}\n\n NOTE\n\nNetlify Edge Functions run in a Deno environment, so import statements in this file must use Deno‚Äôs URL syntax.\n\nnetlify-edge-middleware.ts must provide a function as its default export. This function:\n\nmust return a JSON-serializable object, which cannot include types like Map, function, Set, etc.\nwill always run first, before any other middleware and routes.\ncannot return a response or redirect.\nPer-page functions\nSection titled Per-page functions\n\nThe Netlify adapter builds to a single function by default. Astro 2.7 added support for splitting your build into separate entry points per page. If you use this configuration, the Netlify adapter will generate a separate function for each page. This can help reduce the size of each function so they are only bundling code used on that page.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/functions';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: netlify({\n    functionPerRoute: true,\n  }),\n});\nStatic sites\nSection titled Static sites\n\nFor static sites you usually don‚Äôt need an adapter. However, if you use redirects configuration in your Astro config, the Netlify adapter can be used to translate this to the proper _redirects format.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/static';\n\n\nexport default defineConfig({\n  adapter: netlify(),\n\n\n  redirects: {\n    '/blog/old-post': '/blog/new-post',\n  },\n});\n\nOnce you run astro build there will be a dist/_redirects file. Netlify will use that to properly route pages in production.\n\n NOTE\n\nYou can still include a public/_redirects file for manual redirects. Any redirects you specify in the redirects config are appended to the end of your own.\n\nOn-demand Builders\nSection titled On-demand Builders\n\nNetlify On-demand Builders are serverless functions used to generate web content as needed that‚Äôs automatically cached on Netlify‚Äôs Edge CDN. You can enable these functions using the builders configuration.\n\nBy default, all pages will be rendered on first visit and the rendered result will be reused for every subsequent visit until you redeploy. To set a revalidation time, call the runtime.setBuildersTtl(ttl) local with the duration (in seconds).\n\nThe following example sets a revalidation time of 45, causing Netlify to store the rendered HTML for 45 seconds.\n\nsrc/pages/index.astro\n---\nimport Layout from '../components/Layout.astro';\n\n\nif (import.meta.env.PROD) {\n  Astro.locals.runtime.setBuildersTtl(45);\n}\n---\n\n\n<Layout title=\"Astro on Netlify\">\n  {new Date(Date.now())}\n</Layout>\n\nIt is important to note that On-demand Builders ignore query params when checking for cached pages. For example, if example.com/?x=y is cached, it will be served for example.com/?a=b (different query params) and example.com/ (no query params) as well.\n\nUsage\nSection titled Usage\n\nRead the full deployment guide here.\n\nAfter performing a build the netlify/ folder will contain Netlify Functions in the netlify/functions/ folder.\n\nNow you can deploy. Install the Netlify CLI and run:\n\nTerminal window\nnetlify deploy --build\n\nThe Netlify Blog post on Astro and the Netlify Documentation provide more information on how to use this integration to deploy to Netlify.\n\nConfiguration\nSection titled Configuration\n\nTo configure this adapter, pass an object to the netlify() function call in astro.config.mjs - there‚Äôs only one possible configuration option:\n\ndist\nSection titled dist\n\nWe build to the dist directory at the base of your project. To change this, use the dist option:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/functions';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: netlify({\n    dist: new URL('./dist/', import.meta.url),\n  }),\n});\n\nAnd then point to the dist in your netlify.toml:\n\nnetlify.toml\n[functions]\ndirectory = \"dist/functions\"\nbuilders\nSection titled builders\n\nYou can enable On-demand Builders using the builders option:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport netlify from '@astrojs/netlify/functions';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: netlify({\n    builders: true,\n  }),\n});\n\nOn-demand Builders are only available with the @astrojs/netlify/functions adapter and are not compatible with Edge Functions.\n\nbinaryMediaTypes\nSection titled binaryMediaTypes\n\nThis option is only needed for the Functions adapter and is not needed for Edge Functions.\n\nNetlify Functions requires binary data in the body to be base64 encoded. The @astrojs/netlify/functions adapter handles this automatically based on the Content-Type header.\n\nWe check for common mime types for audio, image, and video files. To include specific mime types that should be treated as binary data, include the binaryMediaTypes option with a list of binary mime types.\n\nsrc/pages/image.jpg.ts\nimport fs from 'node:fs';\n\n\nexport function GET() {\n  const buffer = fs.readFileSync('../image.jpg');\n\n\n  // Return the buffer directly, @astrojs/netlify will base64 encode the body\n  return new Response(buffer, {\n    status: 200,\n    headers: {\n      'content-type': 'image/jpeg',\n    },\n  });\n}\nExamples\nSection titled Examples\n\nThe Astro Netlify Edge Starter provides an example and a guide in the README.\n\nBrowse Astro Netlify projects on GitHub for more examples!\n\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/cloudflare üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/cloudflare/",
    "html": "@astrojs/cloudflare\nv7.7.1\nGitHub\nnpm\nChangelog\n\nAn SSR adapter for use with Cloudflare Pages Functions targets. Write your code in Astro/Javascript and deploy to Cloudflare Pages.\n\nInstall\nSection titled Install\n\nAdd the Cloudflare adapter to enable SSR in your Astro project with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nTerminal window\n# Using NPM\nnpx astro add cloudflare\n# Using Yarn\nyarn astro add cloudflare\n# Using PNPM\npnpm astro add cloudflare\n\nIf you prefer to install the adapter manually instead, complete the following two steps:\n\nAdd the Cloudflare adapter to your project‚Äôs dependencies using your preferred package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\nTerminal window\nnpm install @astrojs/cloudflare\nAdd the following to your astro.config.mjs file:\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport cloudflare from '@astrojs/cloudflare';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: cloudflare(),\n});\nOptions\nSection titled Options\nmode\nSection titled mode\n\nmode: \"advanced\" | \"directory\"\n\ndefault \"advanced\"\n\nThis configuration option defines how your Astro project is deployed to Cloudflare Pages.\n\nadvanced mode picks up the _worker.js file in the dist folder\ndirectory mode picks up the files in the functions folder, by default only one [[path]].js file is generated\n\nSwitching to directory mode allows you to add additional files manually such as Cloudflare Pages Plugins, Cloudflare Pages Middleware or custom functions using Cloudflare Pages Functions Routing.\n\nastro.config.mjs\nexport default defineConfig({\n  adapter: cloudflare({ mode: 'directory' }),\n});\n\nTo compile a separate bundle for each page, set the functionPerRoute option in your Cloudflare adapter config. This option requires some manual maintenance of the functions folder. Files emitted by Astro will overwrite existing files with identical names in the functions folder, so you must choose unique file names for each file you manually add. Additionally, the adapter will never empty the functions folder of outdated files, so you must clean up the folder manually when you remove pages.\n\nastro.config.mjs\nimport {defineConfig} from \"astro/config\";\nimport cloudflare from '@astrojs/cloudflare';\n\n\nexport default defineConfig({\n  adapter: cloudflare({\n    mode: 'directory',\n    functionPerRoute: true\n  })\n})\n\nThis adapter doesn‚Äôt support the edgeMiddleware option.\n\nroutes.strategy\nSection titled routes.strategy\n\nroutes.strategy: \"auto\" | \"include\" | \"exclude\"\n\ndefault \"auto\"\n\nDetermines how routes.json will be generated if no custom _routes.json is provided.\n\nThere are three options available:\n\n\"auto\" (default): Will automatically select the strategy that generates the fewest entries. This should almost always be sufficient, so choose this option unless you have a specific reason not to.\n\ninclude: Pages and endpoints that are not pre-rendered are listed as include entries, telling Cloudflare to invoke these routes as functions. exclude entries are only used to resolve conflicts. Usually the best strategy when your website has mostly static pages and only a few dynamic pages or endpoints.\n\nExample: For src/pages/index.astro (static), src/pages/company.astro (static), src/pages/users/faq.astro (static) and /src/pages/users/[id].astro (SSR) this will produce the following _routes.json:\n\n{\n  \"version\": 1,\n  \"include\": [\n    \"/_image\", // Astro's image endpoint\n    \"/users/*\" // Dynamic route\n  ],\n  \"exclude\": [\n    // Static routes that needs to be exempted from the dynamic wildcard route above\n    \"/users/faq/\",\n    \"/users/faq/index.html\"\n  ]\n}\n\nexclude: Pre-rendered pages are listed as exclude entries (telling Cloudflare to handle these routes as static assets). Usually the best strategy when your website has mostly dynamic pages or endpoints and only a few static pages.\n\nExample: For the same pages as in the previous example this will produce the following _routes.json:\n\n{\n  \"version\": 1,\n  \"include\": [\n    \"/*\" // Handle everything as function except the routes below\n  ],\n  \"exclude\": [\n    // All static assets\n    \"/\",\n    \"/company/\",\n    \"/index.html\",\n    \"/users/faq/\",\n    \"/favicon.png\",\n    \"/company/index.html\",\n    \"/users/faq/index.html\"\n  ]\n}\nroutes.include\nSection titled routes.include\n\nroutes.include: string[]\n\ndefault []\n\nIf you want to use the automatic _routes.json generation, but want to include additional routes (e.g. when having custom functions in the functions folder), you can use the routes.include option to add additional routes to the include array.\n\nroutes.exclude\nSection titled routes.exclude\n\nroutes.exclude: string[]\n\ndefault []\n\nIf you want to use the automatic _routes.json generation, but want to exclude additional routes, you can use the routes.exclude option to add additional routes to the exclude array.\n\nThe following example automatically generates _routes.json while including and excluding additional routes. Note that that is only necessary if you have custom functions in the functions folder that are not handled by Astro.\n\nastro.config.mjs\nexport default defineConfig({\n  adapter: cloudflare({\n    mode: 'directory',\n    routes: {\n      strategy: 'include',\n      include: ['/users/*'], // handled by custom function: functions/users/[id].js\n      exclude: ['/users/faq'], // handled by static page: pages/users/faq.astro\n    },\n  }),\n});\nimageService\nSection titled imageService\n\nimageService: \"passthrough\" | \"cloudflare\"\n\nDetermines which image service is used by the adapter. The adapter will default to passthrough mode when an incompatible image service is configured. Otherwise, it will use the globally configured image service:\n\ncloudflare: Uses the Cloudflare Image Resizing service.\npassthrough: Uses the existing noop service.\nwasmModuleImports\nSection titled wasmModuleImports\n\nwasmModuleImports: boolean\n\ndefault: false\n\nWhether or not to import .wasm files directly as ES modules using the .wasm?module import syntax.\n\nAdd wasmModuleImports: true to astro.config.mjs to enable this functionality in both the Cloudflare build and the Astro dev server. Read more about using Wasm modules.\n\nastro.config.mjs\nimport {defineConfig} from \"astro/config\";\nimport cloudflare from '@astrojs/cloudflare';\n\n\nexport default defineConfig({\n    adapter: cloudflare({\n      wasmModuleImports: true\n    }),\n    output: 'server'\n})\nruntime\nSection titled runtime\n\nruntime: { mode: \"off\" | \"local\", persistTo: string }\n\ndefault { mode: 'off', persistTo: '' }\n\nDetermines whether and how the Cloudflare Runtime is added to astro dev.\n\nThe Cloudflare Runtime includes Cloudflare bindings, environment variables, and the cf object. Read more about accessing the Cloudflare Runtime.\n\nThe mode property defines how the runtime is added to astro dev:\n\nlocal: uses bindings mocking and locally static placeholders\noff: no access to the Cloudflare runtime using astro dev. You can alternatively use Preview with Wrangler\n\nThe persistTo property defines where the local runtime is persisted to when using mode: local. This value is a directory relative to your astro dev execution path.\n\nThe default value is set to .wrangler/state/v3 to match the default path Wrangler uses. This means both tools are able to access and use the local state.\n\nWhichever directory is set in persistTo, .wrangler or your custom value, must be added to .gitignore.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport cloudflare from '@astrojs/cloudflare';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: cloudflare({\n   runtime: { mode: 'local' },\n  }),\n});\nCloudflare runtime\nSection titled Cloudflare runtime\n\nGives you access to environment variables, and Cloudflare bindings.\n\nCurrently supported bindings:\n\nCloudflare D1\nCloudflare R2\nCloudflare Workers KV\nCloudflare Durable Objects\n\nYou can access the runtime from Astro components through Astro.locals inside any .astro file.\n\nsrc/pages/index.astro\n---\nconst runtime = Astro.locals.runtime;\n---\n\n\n<pre>{JSON.stringify(runtime.env)}</pre>\n\nYou can access the runtime from API endpoints through context.locals:\n\nsrc/pages/api/someFile.js\nexport function GET(context) {\n  const runtime = context.locals.runtime;\n\n\n  return new Response('Some body');\n}\nTyping\nSection titled Typing\n\nIf you have configured mode: advanced, you can type the runtime object using AdvancedRuntime:\n\nsrc/env.d.ts\n/// <reference types=\"astro/client\" />\n\n\ntype KVNamespace = import('@cloudflare/workers-types/experimental').KVNamespace;\ntype ENV = {\n  SERVER_URL: string;\n  KV_BINDING: KVNamespace;\n};\n\n\ntype Runtime = import('@astrojs/cloudflare').AdvancedRuntime<ENV>;\n\n\ndeclare namespace App {\n  interface Locals extends Runtime {\n    user: {\n      name: string;\n      surname: string;\n    };\n  }\n}\n\nIf you have configured mode: directory, you can type the runtime object using DirectoryRuntime:\n\nsrc/env.d.ts\n/// <reference types=\"astro/client\" />\n\n\ntype KVNamespace = import('@cloudflare/workers-types/experimental').KVNamespace;\ntype ENV = {\n  SERVER_URL: string;\n  KV_BINDING: KVNamespace;\n};\n\n\ntype Runtime = import('@astrojs/cloudflare').DirectoryRuntime<ENV>;\n\n\ndeclare namespace App {\n  interface Locals extends Runtime {\n    user: {\n      name: string;\n      surname: string;\n    };\n  }\n}\nPlatform\nSection titled Platform\nHeaders\nSection titled Headers\n\nYou can attach custom headers to your responses by adding a _headers file in your Astro project‚Äôs public/ folder. This file will be copied to your build output directory.\n\nRedirects\nSection titled Redirects\n\nYou can declare custom redirects using Cloudflare Pages. This allows you to redirect requests to a different URL. You can add a _redirects file in your Astro project‚Äôs public/ folder. This file will be copied to your build output directory.\n\nRoutes\nSection titled Routes\n\nYou can define which routes are invoking functions and which are static assets, using Cloudflare routing via a _routes.json file. This file is automatically generated by Astro.\n\nCustom _routes.json\nSection titled Custom _routes.json\n\nBy default, @astrojs/cloudflare will generate a _routes.json file with include and exclude rules based on your applications‚Äôs dynamic and static routes. This will enable Cloudflare to serve files and process static redirects without a function invocation. Creating a custom _routes.json will override this automatic optimization. See Cloudflare‚Äôs documentation on creating a custom routes.json for more details.\n\nUse Wasm modules\nSection titled Use Wasm modules\n\nThe following is an example of importing a Wasm module that then responds to requests by adding the request‚Äôs number parameters together.\n\npages/add/[a]/[b].js\nimport mod from '../util/add.wasm?module';\n\n\n// instantiate ahead of time to share module\nconst addModule: any = new WebAssembly.Instance(mod);\n\n\nexport async function GET(context) {\n  const a = Number.parseInt(context.params.a);\n  const b = Number.parseInt(context.params.b);\n  return new Response(`${addModule.exports.add(a, b)}`);\n}\n\nWhile this example is trivial, Wasm can be used to accelerate computationally intensive operations which do not involve significant I/O such as embedding an image processing library.\n\nNode.js compatibility\nSection titled Node.js compatibility\n\nAstro‚Äôs Cloudflare adapter allows you to use any Node.js runtime API supported by Cloudflare:\n\nassert\nAsyncLocalStorage\nBuffer\nCrypto\nDiagnostics Channel\nEventEmitter\npath\nprocess\nStreams\nStringDecoder\nutil\n\nTo use these APIs, your page or endpoint must be server-side rendered (not pre-rendered) and must use the the import {} from 'node:*' import syntax.\n\npages/api/endpoint.js\nexport const prerender = false;\nimport { Buffer } from 'node:buffer';\n\nAdditionally, you‚Äôll need to enable the Compatibility Flag in Cloudflare. The configuration for this flag may vary based on where you deploy your Astro site. For detailed guidance, please refer to the Cloudflare documentation on enabling Node.js compatibility.\n\nCloudflare module support\nSection titled Cloudflare module support\n\nAll Cloudflare namespaced packages (e.g. cloudflare:sockets) are allowlisted for use. Note that the package cloudflare:sockets does not work locally without using Wrangler dev mode.\n\nPreview with Wrangler\nSection titled Preview with Wrangler\n\nTo use wrangler to run your application locally, update the preview script:\n\npackage.json\n\"preview\": \"wrangler pages dev ./dist\"\n\nwrangler gives you access to Cloudflare bindings, environment variables, and the cf object. Getting hot reloading or the astro dev server to work with Wrangler might require custom setup. See community examples.\n\nMeaningful error messages\nSection titled Meaningful error messages\n\nCurrently, errors during running your application in Wrangler are not very useful, due to the minification of your code. For better debugging, you can add vite.build.minify = false setting to your astro.config.mjs.\n\nastro.config.mjs\nexport default defineConfig({\n  adapter: cloudflare(),\n  output: 'server',\n\n\n  vite: {\n    build: {\n      minify: false,\n    },\n  },\n});\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/vue üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/vue/",
    "html": "@astrojs/vue\nv3.0.4\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables server-side rendering and client-side hydration for your Vue 3 components.\n\nInstallation\nSection titled Installation\n\nThere are two ways to add integrations to your project. Let‚Äôs try the most convenient option first!\n\nastro add command\nSection titled astro add command\n\nAstro includes a CLI tool for adding first party integrations: astro add. This command will:\n\n(Optionally) Install all necessary dependencies and peer dependencies\n(Also optionally) Update your astro.config.* file to apply this integration\n\nTo install @astrojs/vue, run the following from your project directory and follow the prompts:\n\nTerminal window\n# Using NPM\nnpx astro add vue\n# Using Yarn\nyarn astro add vue\n# Using PNPM\npnpm astro add vue\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nInstall dependencies manually\nSection titled Install dependencies manually\n\nFirst, install the @astrojs/vue integration like so:\n\nTerminal window\nnpm install @astrojs/vue\n\nMost package managers will install associated peer dependencies as well. Still, if you see a ‚ÄúCannot find package ‚Äòvue‚Äô‚Äù (or similar) warning when you start up Astro, you‚Äôll need to install Vue:\n\nTerminal window\nnpm install vue\n\nNow, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vue from '@astrojs/vue';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [vue()],\n  //             ^^^^^\n});\nGetting started\nSection titled Getting started\n\nTo use your first Vue component in Astro, head to our UI framework documentation. You‚Äôll explore:\n\nüì¶ how framework components are loaded,\nüíß client-side hydration options, and\nü§ù opportunities to mix and nest frameworks together\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nOptions\nSection titled Options\n\nThis integration is powered by @vitejs/plugin-vue. To customize the Vue compiler, options can be provided to the integration. See the @vitejs/plugin-vue docs for more details.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vue from '@astrojs/vue';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [\n    vue({\n      template: {\n        compilerOptions: {\n          // treat any tag that starts with ion- as custom elements\n          isCustomElement: (tag) => tag.startsWith('ion-'),\n        },\n      },\n      // ...\n    }),\n  ],\n});\nappEntrypoint\nSection titled appEntrypoint\n\nYou can extend the Vue app instance setting the appEntrypoint option to a root-relative import specifier (for example, appEntrypoint: \"/src/pages/_app\").\n\nThe default export of this file should be a function that accepts a Vue App instance prior to rendering, allowing the use of custom Vue plugins, app.use, and other customizations for advanced use cases.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vue from '@astrojs/vue';\n\n\nexport default defineConfig({\n  integrations: [vue({ appEntrypoint: '/src/pages/_app' })],\n});\nsrc/pages/_app.ts\nimport type { App } from 'vue';\nimport i18nPlugin from 'my-vue-i18n-plugin';\n\n\nexport default (app: App) => {\n  app.use(i18nPlugin);\n};\njsx\nSection titled jsx\n\nYou can use Vue JSX by setting jsx: true.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vue from '@astrojs/vue';\n\n\nexport default defineConfig({\n  integrations: [vue({ jsx: true })],\n});\n\nThis will enable rendering for both Vue and Vue JSX components. To customize the Vue JSX compiler, pass an options object instead of a boolean. See the @vitejs/plugin-vue-jsx docs for more details.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vue from '@astrojs/vue';\n\n\nexport default defineConfig({\n  integrations: [\n    vue({\n      jsx: {\n        // treat any tag that starts with ion- as custom elements\n        isCustomElement: (tag) => tag.startsWith('ion-'),\n      },\n    }),\n  ],\n});\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/svelte üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/svelte/",
    "html": "@astrojs/svelte\nv4.0.4\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables server-side rendering and client-side hydration for your Svelte components. It supports Svelte 3, 4, and 5 (experimental).\n\nInstallation\nSection titled Installation\n\nThere are two ways to add integrations to your project. Let‚Äôs try the most convenient option first!\n\nastro add command\nSection titled astro add command\n\nAstro includes a CLI tool for adding first party integrations: astro add. This command will:\n\n(Optionally) Install all necessary dependencies and peer dependencies\n(Also optionally) Update your astro.config.* file to apply this integration\n\nTo install @astrojs/svelte, run the following from your project directory and follow the prompts:\n\nTerminal window\n# Using NPM\nnpx astro add svelte\n# Using Yarn\nyarn astro add svelte\n# Using PNPM\npnpm astro add svelte\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nInstall dependencies manually\nSection titled Install dependencies manually\n\nFirst, install the @astrojs/svelte integration like so:\n\nTerminal window\nnpm install @astrojs/svelte\n\nMost package managers will install associated peer dependencies as well. Still, if you see a ‚ÄúCannot find package ‚Äòsvelte‚Äô‚Äù (or similar) warning when you start up Astro, you‚Äôll need to install Svelte:\n\nTerminal window\nnpm install svelte\n\nNow, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport svelte from '@astrojs/svelte';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [svelte()],\n  //             ^^^^^^^^\n});\nGetting started\nSection titled Getting started\n\nTo use your first Svelte component in Astro, head to our UI framework documentation. You‚Äôll explore:\n\nüì¶ how framework components are loaded,\nüíß client-side hydration options, and\nü§ù opportunities to mix and nest frameworks together\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nOptions\nSection titled Options\n\nThis integration is powered by @sveltejs/vite-plugin-svelte. To customize the Svelte compiler, options can be provided to the integration. See the @sveltejs/vite-plugin-svelte docs for more details.\n\nDefault options\nSection titled Default options\n\nThis integration passes the following default options to the Svelte compiler:\n\nconst defaultOptions = {\n  emitCss: true,\n  compilerOptions: { dev: isDev, hydratable: true },\n  preprocess: vitePreprocess(),\n};\n\nThese emitCss, compilerOptions.dev, and compilerOptions.hydratable values are required to build properly for Astro and cannot be overridden.\n\nProviding your own preprocess options will override the vitePreprocess() default. Make sure to enable the preprocessor flags needed for your project.\n\nYou can set options either by passing them to the svelte integration in astro.config.mjs or in svelte.config.js. Either of these would override the default preprocess setting:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport svelte from '@astrojs/svelte';\n\n\nexport default defineConfig({\n  integrations: [svelte({ preprocess: [] })],\n});\nsvelte.config.js\nexport default {\n  preprocess: [],\n};\nIntellisense for TypeScript\nSection titled Intellisense for TypeScript\n\nAdded in: @astrojs/svelte@2.0.0\n\nIf you‚Äôre using a preprocessor like TypeScript or SCSS in your Svelte files, you can create a svelte.config.js file so that the Svelte IDE extension can correctly parse the Svelte files.\n\nsvelte.config.js\nimport { vitePreprocess } from '@astrojs/svelte';\n\n\nexport default {\n  preprocess: vitePreprocess(),\n};\n\nThis config file will be automatically added for you when you run astro add svelte.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/solid-js üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/solid-js/",
    "html": "@astrojs/solid‚Å†-‚Å†js\nv3.0.2\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables server-side rendering and client-side hydration for your SolidJS components.\n\nInstallation\nSection titled Installation\n\nThere are two ways to add integrations to your project. Let‚Äôs try the most convenient option first!\n\nastro add command\nSection titled astro add command\n\nAstro includes a CLI tool for adding first party integrations: astro add. This command will:\n\n(Optionally) Install all necessary dependencies and peer dependencies\n(Also optionally) Update your astro.config.* file to apply this integration\n\nTo install @astrojs/solid-js, run the following from your project directory and follow the prompts:\n\nTerminal window\n# Using NPM\nnpx astro add solid\n# Using Yarn\nyarn astro add solid\n# Using PNPM\npnpm astro add solid\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nInstall dependencies manually\nSection titled Install dependencies manually\n\nFirst, install the @astrojs/solid-js integration like so:\n\nTerminal window\nnpm install @astrojs/solid-js\n\nMost package managers will install associated peer dependencies as well. Still, if you see a ‚ÄúCannot find package ‚Äòsolid-js‚Äô‚Äù (or similar) warning when you start up Astro, you‚Äôll need to install SolidJS:\n\nTerminal window\nnpm install solid-js\n\nNow, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport solid from '@astrojs/solid-js';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [solid()],\n  //             ^^^^^^^\n});\nGetting started\nSection titled Getting started\n\nTo use your first SolidJS component in Astro, head to our UI framework documentation. You‚Äôll explore:\n\nüì¶ how framework components are loaded,\nüíß client-side hydration options, and\nü§ù opportunities to mix and nest frameworks together\nOptions\nSection titled Options\nCombining multiple JSX frameworks\nSection titled Combining multiple JSX frameworks\n\nWhen you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed.\n\nUse the include (required) and exclude (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to include for each framework you are using. Wildcards may be used to include multiple file paths.\n\nWe recommend placing common framework components in the same folder (e.g. /components/react/ and /components/solid/) to make specifying your includes easier, but this is not required:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport preact from '@astrojs/preact';\nimport react from '@astrojs/react';\nimport svelte from '@astrojs/svelte';\nimport vue from '@astrojs/vue';\nimport solid from '@astrojs/solid-js';\n\n\nexport default defineConfig({\n  // Enable many frameworks to support all different kinds of components.\n  // No `include` is needed if you are only using a single JSX framework!\n  integrations: [\n    preact({\n      include: ['**/preact/*'],\n    }),\n    react({\n      include: ['**/react/*'],\n    }),\n    solid({\n      include: ['**/solid/*'],\n    }),\n  ],\n});\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/react üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/react/",
    "html": "@astrojs/react\nv3.0.6\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables server-side rendering and client-side hydration for your React components.\n\nInstallation\nSection titled Installation\n\nThere are two ways to add integrations to your project. Let‚Äôs try the most convenient option first!\n\nastro add command\nSection titled astro add command\n\nAstro includes a CLI tool for adding first party integrations: astro add. This command will:\n\n(Optionally) Install all necessary dependencies and peer dependencies\n(Also optionally) Update your astro.config.* file to apply this integration\n\nTo install @astrojs/react, run the following from your project directory and follow the prompts:\n\nTerminal window\n# Using NPM\nnpx astro add react\n# Using Yarn\nyarn astro add react\n# Using PNPM\npnpm astro add react\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nInstall dependencies manually\nSection titled Install dependencies manually\n\nFirst, install the @astrojs/react integration like so:\n\nTerminal window\nnpm install @astrojs/react\n\nMost package managers will install associated peer dependencies as well. Still, if you see a ‚ÄúCannot find package ‚Äòreact‚Äô‚Äù (or similar) warning when you start up Astro, you‚Äôll need to install react and react-dom:\n\nTerminal window\nnpm install react react-dom\n\nNow, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport react from '@astrojs/react';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [react()],\n  //             ^^^^^^^\n});\nGetting started\nSection titled Getting started\n\nTo use your first React component in Astro, head to our UI framework documentation. You‚Äôll explore:\n\nüì¶ how framework components are loaded,\nüíß client-side hydration options, and\nü§ù opportunities to mix and nest frameworks together\nOptions\nSection titled Options\nCombining multiple JSX frameworks\nSection titled Combining multiple JSX frameworks\n\nWhen you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed.\n\nUse the include (required) and exclude (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to include for each framework you are using. Wildcards may be used to include multiple file paths.\n\nWe recommend placing common framework components in the same folder (e.g. /components/react/ and /components/solid/) to make specifying your includes easier, but this is not required:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport preact from '@astrojs/preact';\nimport react from '@astrojs/react';\nimport svelte from '@astrojs/svelte';\nimport vue from '@astrojs/vue';\nimport solid from '@astrojs/solid-js';\n\n\nexport default defineConfig({\n  // Enable many frameworks to support all different kinds of components.\n  // No `include` is needed if you are only using a single JSX framework!\n  integrations: [\n    preact({\n      include: ['**/preact/*'],\n    }),\n    react({\n      include: ['**/react/*'],\n    }),\n    solid({\n      include: ['**/solid/*'],\n    }),\n  ],\n});\nChildren parsing\nSection titled Children parsing\n\nChildren passed into a React component from an Astro component are parsed as plain strings, not React nodes.\n\nFor example, the <ReactComponent /> below will only receive a single child element:\n\n---\nimport ReactComponent from './ReactComponent';\n---\n\n\n<ReactComponent>\n  <div>one</div>\n  <div>two</div>\n</ReactComponent>\n\nIf you are using a library that expects more than one child element to be passed, for example so that it can slot certain elements in different places, you might find this to be a blocker.\n\nYou can set the experimental flag experimentalReactChildren to tell Astro to always pass children to React as React vnodes. There is some runtime cost to this, but it can help with compatibility.\n\nYou can enable this option in the configuration for the React integration:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport react from '@astrojs/react';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [\n    react({\n      experimentalReactChildren: true,\n    }),\n  ],\n});\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/preact üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/preact/",
    "html": "@astrojs/preact\nv3.0.1\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables server-side rendering and client-side hydration for your Preact components.\n\nWhy Preact?\nSection titled Why Preact?\n\nPreact is a library that lets you build interactive UI components for the web. If you want to build interactive features on your site using JavaScript, you may prefer using its component format instead of using browser APIs directly.\n\nPreact is also a great choice if you have previously used React. Preact provides the same API as React, but in a much smaller 3kB package. It even supports rendering many React components using the compat configuration option (see below).\n\nWant to learn more about Preact before using this integration?\nCheck out ‚ÄúLearn Preact in 10 minutes‚Äù, an interactive tutorial on their website.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add preact\n# Using Yarn\nyarn astro add preact\n# Using PNPM\npnpm astro add preact\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/preact package using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/preact\n\nMost package managers will install associated peer dependencies as well. Still, if you see a ‚ÄúCannot find package ‚Äòpreact‚Äô‚Äù (or similar) warning when you start up Astro, you‚Äôll need to install Preact:\n\nTerminal window\nnpm install preact\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n import preact from '@astrojs/preact';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [preact()],\n  //             ^^^^^^^^\n});\nUsage\nSection titled Usage\n\nTo use your first Preact component in Astro, head to our UI framework documentation. You‚Äôll explore:\n\nüì¶ how framework components are loaded,\nüíß client-side hydration options, and\nü§ù opportunities to mix and nest frameworks together\n\nAlso check our Astro Integration Documentation for more on integrations.\n\nConfiguration\nSection titled Configuration\n\nThe Astro Preact integration handles how Preact components are rendered and it has its own options. Change these in the astro.config.mjs file which is where your project‚Äôs integration settings live.\n\nFor basic usage, you do not need to configure the Preact integration.\n\ncompat\nSection titled compat\n\nYou can enable preact/compat, Preact‚Äôs compatibility layer for rendering React components without needing to install or ship React‚Äôs larger libraries to your users‚Äô web browsers.\n\nTo do so, pass an object to the Preact integration and set compat: true.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport preact from '@astrojs/preact';\n\n\nexport default defineConfig({\n  integrations: [preact({ compat: true })],\n  //                      ^^^^^^^^^^^^\n});\n\nWith the compat option enabled, the Preact integration will render React components as well as Preact components in your project and also allow you to import React components inside Preact components. Read more in ‚ÄúSwitching to Preact (from React)‚Äù on the Preact website.\n\nWhen importing React component libraries, in order to swap out the react and react-dom dependencies as preact/compat, you can use overrides to do so.\n\npackage.json\n{\n  \"overrides\": {\n    \"react\": \"npm:@preact/compat@latest\",\n    \"react-dom\": \"npm:@preact/compat@latest\"\n  }\n}\n\nCheck out the pnpm overrides and yarn resolutions docs for their respective overrides features.\n\n NOTE\n\nCurrently, the compat option only works for React libraries that export code as ESM. If an error happens during build-time, try adding the library to vite.ssr.noExternal: ['the-react-library'] in your astro.config.mjs file.\n\nOptions\nSection titled Options\nCombining multiple JSX frameworks\nSection titled Combining multiple JSX frameworks\n\nWhen you are using multiple JSX frameworks (React, Preact, Solid) in the same project, Astro needs to determine which JSX framework-specific transformations should be used for each of your components. If you have only added one JSX framework integration to your project, no extra configuration is needed.\n\nUse the include (required) and exclude (optional) configuration options to specify which files belong to which framework. Provide an array of files and/or folders to include for each framework you are using. Wildcards may be used to include multiple file paths.\n\nWe recommend placing common framework components in the same folder (e.g. /components/react/ and /components/solid/) to make specifying your includes easier, but this is not required:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport preact from '@astrojs/preact';\nimport react from '@astrojs/react';\nimport svelte from '@astrojs/svelte';\nimport vue from '@astrojs/vue';\nimport solid from '@astrojs/solid-js';\n\n\nexport default defineConfig({\n  // Enable many frameworks to support all different kinds of components.\n  // No `include` is needed if you are only using a single JSX framework!\n  integrations: [\n    preact({\n      include: ['**/preact/*'],\n    }),\n    react({\n      include: ['**/react/*'],\n    }),\n    solid({\n      include: ['**/solid/*'],\n    }),\n  ],\n});\nExamples\nSection titled Examples\nThe Astro Preact example shows how to use an interactive Preact component in an Astro project.\nThe Astro Nanostores example shows how to share state between different components ‚Äî and even different frameworks! ‚Äî in an Astro project.\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/lit üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/lit/",
    "html": "@astrojs/lit\nv3.0.3\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables server-side rendering and client-side hydration for your Lit custom elements.\n\nInstallation\nSection titled Installation\n\nThere are two ways to add integrations to your project. Let‚Äôs try the most convenient option first!\n\nastro add command\nSection titled astro add command\n\nAstro includes a CLI tool for adding first party integrations: astro add. This command will:\n\n(Optionally) Install all necessary dependencies and peer dependencies\n(Also optionally) Update your astro.config.* file to apply this integration\n\nTo install @astrojs/lit, run the following from your project directory and follow the prompts:\n\nTerminal window\n# Using NPM\nnpx astro add lit\n# Using Yarn\nyarn astro add lit\n# Using PNPM\npnpm astro add lit\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nInstall dependencies manually\nSection titled Install dependencies manually\n\nFirst, install the @astrojs/lit integration like so:\n\nTerminal window\nnpm install @astrojs/lit\n\nMost package managers will install associated peer dependencies as well. Still, if you see a ‚ÄúCannot find package ‚Äòlit‚Äô‚Äù (or similar) warning when you start up Astro, you‚Äôll need to install lit and @webcomponents/template-shadowroot:\n\nTerminal window\nnpm install lit @webcomponents/template-shadowroot\n\nNow, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport lit from '@astrojs/lit';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [lit()],\n  //             ^^^^^\n});\nGetting started\nSection titled Getting started\n\nTo use your first Lit component in Astro, head to our UI framework documentation. This explains:\n\nüì¶ how framework components are loaded,\nüíß client-side hydration options, and\nü§ù opportunities to mix and nest frameworks together\n\nWriting and importing a Lit component in Astro looks like this:\n\nsrc/components/my-element.js\nimport { LitElement, html } from 'lit';\n\n\nexport class MyElement extends LitElement {\n  render() {\n    return html` <p>Hello world! From my-element</p> `;\n  }\n}\n\n\ncustomElements.define('my-element', MyElement);\n\nNow, the component is ready to be imported via the Astro frontmatter:\n\nsrc/pages/index.astro\n---\nimport { MyElement } from '../components/my-element.js';\n---\n\n\n<MyElement />\n\nNote that Lit requires browser globals such as HTMLElement and customElements to be present. For this reason the Lit renderer shims the server with these globals so Lit can run. You might run into libraries that work incorrectly because of this.\n\nPolyfills & Hydration\nSection titled Polyfills &amp; Hydration\n\nThe renderer automatically handles adding appropriate polyfills for support in browsers that don‚Äôt have Declarative Shadow DOM. The polyfill is about 1.5kB. If the browser does support Declarative Shadow DOM then less than 250 bytes are loaded (to feature detect support).\n\nHydration is also handled automatically. You can use the same hydration directives such as client:load, client:idle and client:visible as you can with other libraries that Astro supports.\n\n---\nimport { MyElement } from '../components/my-element.js';\n---\n\n\n<MyElement client:visible />\n\nThe above will only load the element‚Äôs JavaScript when the user has scrolled it into view. Since it is server rendered they will not see any jank; it will load and hydrate transparently.\n\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nCommon issues are listed below:\n\nBrowser globals\nSection titled Browser globals\n\nThe Lit integration‚Äôs SSR works by adding a few browser global properties to the global environment. Some of the properties it adds includes window, document, and location.\n\nThese globals can interfere with other libraries that might use the existence of these variables to detect that they are running in the browser, when they are actually running in the server. This can cause bugs with these libraries.\n\nBecause of this, the Lit integration might not be compatible with these types of libraries. One thing that can help is changing the order of integrations when Lit is interfering with other integrations:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vue from '@astrojs/vue';\nimport lit from '@astrojs/lit';\n\n\nexport default defineConfig({\n  integrations: [vue(), lit()]\n  integrations: [lit(), vue()]\n});\n\nThe correct order might be different depending on the underlying cause of the problem. This is not guaranteed to fix every issue however, and some libraries cannot be used if you are using the Lit integration because of this.\n\nStrict package managers\nSection titled Strict package managers\n\nWhen using a strict package manager like pnpm, you may get an error such as ReferenceError: module is not defined when running your site. To fix this, hoist Lit dependencies with an .npmrc file:\n\n.npmrc\npublic-hoist-pattern[]=*lit*\nLimitations\nSection titled Limitations\n\nThe Lit integration is powered by @lit-labs/ssr which has some limitations. See their limitations documentation to learn more.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "Add Reading Time üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/reading-time/",
    "html": "Add Reading Time\n\nCreate a remark plugin which adds a reading time property to the frontmatter of your Markdown or MDX files. Use this property to display the reading time for each page.\n\nRecipe\nSection titled Recipe\n\nInstall Helper Packages\n\nInstall these two helper packages:\n\nreading-time to calculate minutes read\nmdast-util-to-string to extract all text from your markdown\nnpm\npnpm\nYarn\nTerminal window\nnpm install reading-time mdast-util-to-string\n\nCreate a remark plugin.\n\nThis plugin uses the mdast-util-to-string package to get the Markdown file‚Äôs text. This text is then passed to the reading-time package to calculate the reading time in minutes.\n\nremark-reading-time.mjs\nimport getReadingTime from 'reading-time';\nimport { toString } from 'mdast-util-to-string';\n\n\nexport function remarkReadingTime() {\n  return function (tree, { data }) {\n    const textOnPage = toString(tree);\n    const readingTime = getReadingTime(textOnPage);\n    // readingTime.text will give us minutes read as a friendly string,\n    // i.e. \"3 min read\"\n    data.astro.frontmatter.minutesRead = readingTime.text;\n  };\n}\n\nAdd the plugin to your config:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport { remarkReadingTime } from './remark-reading-time.mjs';\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [remarkReadingTime],\n  },\n});\n\nNow all Markdown documents will have a calculated minutesRead property in their frontmatter.\n\nDisplay Reading Time\n\nIf your blog posts are stored in a content collection, access the remarkPluginFrontmatter from the entry.render() function. Then, render minutesRead in your template wherever you would like it to appear.\n\nsrc/pages/posts/[slug].astro\n---\nimport { CollectionEntry, getCollection } from 'astro:content';\n\n\nexport async function getStaticPaths() {\n  const blog = await getCollection('blog');\n  return blog.map(entry => ({\n    params: { slug: entry.slug },\n    props: { entry },\n  }));\n}\n\n\nconst { entry } = Astro.props;\nconst { Content, remarkPluginFrontmatter } = await entry.render();\n---\n\n\n<html>\n  <head>...</head>\n  <body>\n    ...\n    <p>{remarkPluginFrontmatter.minutesRead}</p>\n    ...\n  </body>\n</html>\n\nIf you‚Äôre using a Markdown layout, use the minutesRead frontmatter property from Astro.props in your layout template.\n\nsrc/layouts/BlogLayout.astro\n---\nconst { minutesRead } = Astro.props.frontmatter;\n---\n\n\n<html>\n  <head>...</head>\n  <body>\n    <p>{minutesRead}</p>\n    <slot />\n  </body>\n</html>\nMore recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown"
  },
  {
    "title": "@astrojs/alpinejs üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/alpinejs/",
    "html": "@astrojs/alpinejs\nv0.3.1\nGitHub\nnpm\nChangelog\n\nThis Astro integration adds Alpine.js to your project so that you can use Alpine.js anywhere on your page.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add alpinejs\n# Using Yarn\nyarn astro add alpinejs\n# Using PNPM\npnpm astro add alpinejs\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/alpinejs package using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/alpinejs\n\nMost package managers will install associated peer dependencies as well. However, if you see a ‚ÄúCannot find package ‚Äòalpinejs‚Äô‚Äù (or similar) warning when you start up Astro, you‚Äôll need to manually install Alpine.js yourself:\n\nTerminal window\nnpm install alpinejs @types/alpinejs\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport alpine from '@astrojs/alpinejs';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [alpine()],\n  //             ^^^^^^^^\n});\nUsage\nSection titled Usage\n\nOnce the integration is installed, you can use Alpine.js directives and syntax inside any Astro component. The Alpine.js script is automatically added and enabled on every page of your website.\n\nCheck our Astro Integration Documentation for more on integrations.\n\nLimitations\nSection titled Limitations\n\nThe Alpine.js integration does not give you control over how the script is loaded or initialized. If you require this control, consider installing and using Alpine.js manually. Astro supports all officially documented Alpine.js manual setup instructions, using <script> tags inside of an Astro component.\n\nIt is not currently possible to extend Alpine.js when using this component. If you need this feature, consider following the manual Alpine.js setup instead using an Astro script tag:\n\nsrc/pages/index.astro\n---\n---\n\n\n<!-- Example: Load AlpineJS on a single page. -->\n<script>\n  import Alpine from 'alpinejs';\n\n\n  // Optional: Extend Alpine.js\n  // Alpine.directive('foo', ...)\n\n\n  window.Alpine = Alpine;\n  Alpine.start();\n</script>\nConfiguration\nSection titled Configuration\n\nThe Alpine.js integration does not support any custom configuration at this time.\n\nExamples\nSection titled Examples\nThe Astro Alpine.js example shows how to use Alpine.js in an Astro project.\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "@astrojs/mdx üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/mdx/#installation",
    "html": "@astrojs/mdx\nv1.1.5\nGitHub\nnpm\nChangelog\n\nThis Astro integration enables the usage of MDX components and allows you to create pages as .mdx files.\n\nWhy MDX?\nSection titled Why MDX?\n\nMDX allows you to use variables, JSX expressions and components within Markdown content in Astro. If you have existing content authored in MDX, this integration allows you to bring those files to your Astro project.\n\nInstallation\nSection titled Installation\nQuick Install\nSection titled Quick Install\n\nThe astro add command-line tool automates the installation for you. Run one of the following commands in a new terminal window. (If you aren‚Äôt sure which package manager you‚Äôre using, run the first command.) Then, follow the prompts, and type ‚Äúy‚Äù in the terminal (meaning ‚Äúyes‚Äù) for each one.\n\nTerminal window\n# Using NPM\nnpx astro add mdx\n# Using Yarn\nyarn astro add mdx\n# Using PNPM\npnpm astro add mdx\n\nIf you run into any issues, feel free to report them to us on GitHub and try the manual installation steps below.\n\nManual Install\nSection titled Manual Install\n\nFirst, install the @astrojs/mdx package using your package manager. If you‚Äôre using npm or aren‚Äôt sure, run this in the terminal:\n\nTerminal window\nnpm install @astrojs/mdx\n\nThen, apply this integration to your astro.config.* file using the integrations property:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  // ...\n  integrations: [mdx()],\n  //             ^^^^^\n});\nEditor Integration\nSection titled Editor Integration\n\nFor editor support in VS Code, install the official MDX extension.\n\nFor other editors, use the MDX language server.\n\nUsage\nSection titled Usage\n\nWith the Astro MDX integration, you can add MDX pages to your project by adding .mdx files within your src/pages/ directory. You can also import .mdx files into .astro files.\n\nAstro‚Äôs MDX integration adds extra features to standard MDX, including Markdown-style frontmatter. This allows you to use most of Astro‚Äôs built-in Markdown features like a special frontmatter layout property.\n\nSee how MDX works in Astro with examples in our Markdown & MDX guide.\n\nVisit the MDX docs to learn about using standard MDX features.\n\nConfiguration\nSection titled Configuration\n\nOnce the MDX integration is installed, no configuration is necessary to use .mdx files in your Astro project.\n\nYou can configure how your MDX is rendered with the following options:\n\nOptions inherited from Markdown config\nextendMarkdownConfig\nrecmaPlugins\noptimize\nOptions inherited from Markdown config\nSection titled Options inherited from Markdown config\n\nAll markdown configuration options except drafts can be configured separately in the MDX integration. This includes remark and rehype plugins, syntax highlighting, and more. Options will default to those in your Markdown config (see the extendMarkdownConfig option to modify this).\n\n NOTE\n\nThere is no separate MDX configuration for including pages marked as draft in the build. This Markdown setting will be respected by both Markdown and MDX files and cannot be overridden for MDX files specifically.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\nimport remarkToc from 'remark-toc';\nimport rehypeMinifyHtml from 'rehype-minify-html';\n\n\nexport default defineConfig({\n  integrations: [\n    mdx({\n      syntaxHighlight: 'shiki',\n      shikiConfig: { theme: 'dracula' },\n      remarkPlugins: [remarkToc],\n      rehypePlugins: [rehypeMinifyHtml],\n      remarkRehype: { footnoteLabel: 'Footnotes' },\n      gfm: false,\n    }),\n  ],\n});\n\n CAUTION\n\nMDX does not support passing remark and rehype plugins as a string. You should install, import, and apply the plugin function instead.\n\nüìö See the Markdown Options reference for a complete list of options.\n\nextendMarkdownConfig\nSection titled extendMarkdownConfig\nType: boolean\nDefault: true\n\nMDX will extend your project‚Äôs existing Markdown configuration by default. To override individual options, you can specify their equivalent in your MDX configuration.\n\nFor example, say you need to disable GitHub-Flavored Markdown and apply a different set of remark plugins for MDX files. You can apply these options like so, with extendMarkdownConfig enabled by default:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  markdown: {\n    syntaxHighlight: 'prism',\n    remarkPlugins: [remarkPlugin1],\n    gfm: true,\n  },\n  integrations: [\n    mdx({\n      // `syntaxHighlight` inherited from Markdown\n\n\n      // Markdown `remarkPlugins` ignored,\n      // only `remarkPlugin2` applied.\n      remarkPlugins: [remarkPlugin2],\n      // `gfm` overridden to `false`\n      gfm: false,\n    }),\n  ],\n});\n\nYou may also need to disable markdown config extension in MDX. For this, set extendMarkdownConfig to false:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [remarkPlugin1],\n  },\n  integrations: [\n    mdx({\n      // Markdown config now ignored\n      extendMarkdownConfig: false,\n      // No `remarkPlugins` applied\n    }),\n  ],\n});\nrecmaPlugins\nSection titled recmaPlugins\n\nThese are plugins that modify the output estree directly. This is useful for modifying or injecting JavaScript variables in your MDX files.\n\nWe suggest using AST Explorer to play with estree outputs, and trying estree-util-visit for searching across JavaScript nodes.\n\noptimize\nSection titled optimize\nType: boolean | { customComponentNames?: string[] }\n\nThis is an optional configuration setting to optimize the MDX output for faster builds and rendering via an internal rehype plugin. This may be useful if you have many MDX files and notice slow builds. However, this option may generate some unescaped HTML, so make sure your site‚Äôs interactive parts still work correctly after enabling it.\n\nThis is disabled by default. To enable MDX optimization, add the following to your MDX integration configuration:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  integrations: [\n    mdx({\n      optimize: true,\n    }),\n  ],\n});\ncustomComponentNames\nSection titled customComponentNames\nType: string[]\n\nAn optional property of optimize to prevent the MDX optimizer from handling any custom components passed to imported MDX content via the components prop.\n\nYou will need to exclude these components from optimization as the optimizer eagerly converts content into a static string, which will break custom components that needs to be dynamically rendered.\n\nFor example, the intended MDX output of the following is <Heading>...</Heading> in place of every \"<h1>...</h1>\":\n\n---\nimport { Content, components } from '../content.mdx';\nimport Heading from '../Heading.astro';\n---\n\n\n<Content components={{ ...components, h1: Heading }} />\n\nTo configure optimization for this using the customComponentNames property, specify an array of HTML element names that should be treated as custom components:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  integrations: [\n    mdx({\n      optimize: {\n        // Prevent the optimizer from handling `h1` elements\n        // These will be treated as custom components\n        customComponentNames: ['h1'],\n      },\n    }),\n  ],\n});\n\nNote that if your MDX file configures custom components using export const components = { ... }, then you do not need to manually configure this option. The optimizer will automatically detect them.\n\nExamples\nSection titled Examples\nThe Astro MDX starter template shows how to use MDX files in your Astro project.\nTroubleshooting\nSection titled Troubleshooting\n\nFor help, check out the #support channel on Discord. Our friendly Support Squad members are here to help!\n\nYou can also check our Astro Integration Documentation for more on integrations.\n\nContributing\nSection titled Contributing\n\nThis package is maintained by Astro‚Äôs Core team. You‚Äôre welcome to submit an issue or PR!\n\nChangelog\nSection titled Changelog\n\nSee CHANGELOG.md for a history of changes to this integration.\n\nMore Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind"
  },
  {
    "title": "Congratulations! üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/6-islands/3/",
    "html": "6 ‚Ä¢ Set sail for Astro islands\n\nCongratulations!\n\nThere‚Äôs one more edit to make‚Ä¶\n\nsrc/pages/about.astro\n---\nimport BaseLayout from \"../layouts/BaseLayout.astro\";\nconst pageTitle = \"About Me\";\nconst happy = true;\nconst finished = false;\nconst finished = true;\nconst goal = 3;\nconst identity = {\n  firstName: \"Sarah\",\n  country: \"Canada\",\n  occupation: \"Technical Writer\",\n  hobbies: [\"photography\", \"birdwatching\", \"baseball\"],\n};\nconst skills = [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Astro\", \"Writing Docs\"];\nconst skillColor = \"navy\";\nconst fontWeight = \"bold\";\nconst textCase = \"uppercase\";\n---\n\nWe hope you learned a little about the basics of Astro, and had fun along the way!\n\nYou can find the code for the project in this tutorial on GitHub or StackBlitz.\n\nCheck out our docs for guides and reference material, and visit our Discord to ask questions, get help or just hang out!\n\nWelcome to the universe, astronaut. üë©üèº‚ÄçüöÄüë®üèø‚ÄçüöÄüßë‚ÄçüöÄüë©üèæ‚ÄçüöÄ\n\nChecklist\nSection titled Checklist\n I can‚Äôt wait to start my next Astro project! üöÄ\nNext Steps\nSection titled Next Steps\n\nContinue with either of our tutorial extensions to add view transitions to this project or to add a content collection to manage your blog posts\n\nStart a new Astro project\n\nJoin us on Discord\n\nShare your achievement!\nSection titled Share your achievement!\n\nCongratulations on completing the Astro blog tutorial! Share your achievement with the world and let everyone know you‚Äôre an Astronaut now!\n\nShare on Twitter\nShare on Reddit"
  },
  {
    "title": "Back on dry land. Take your blog from day to night, no island required! üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/6-islands/2/",
    "html": "6 ‚Ä¢ Set sail for Astro islands\n\nBack on dry land. Take your blog from day to night, no island required!\n\nNow that you can build Astro islands for interactive elements, don‚Äôt forget that you can go pretty far with just vanilla JavaScript and CSS!\n\nLet‚Äôs build a clickable icon to let your users toggle between light or dark mode using another <script> tag for interactivity‚Ä¶ with no framework JavaScript sent to the browser.\n\nGET READY TO‚Ä¶\n\nBuild an interactive theme toggle with only JavaScript and CSS\nSend as little JavaScript to the browser as possible!\nAdd and style a theme toggle icon\nSection titled Add and style a theme toggle icon\n\nCreate a new file at src/components/ThemeIcon.astro and paste the following code into it:\n\nsrc/components/ThemeIcon.astro\n---\n---\n<button id=\"themeToggle\">\n  <svg width=\"30px\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n    <path class=\"sun\" fill-rule=\"evenodd\" d=\"M12 17.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zm0 1.5a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm12-7a.8.8 0 0 1-.8.8h-2.4a.8.8 0 0 1 0-1.6h2.4a.8.8 0 0 1 .8.8zM4 12a.8.8 0 0 1-.8.8H.8a.8.8 0 0 1 0-1.6h2.5a.8.8 0 0 1 .8.8zm16.5-8.5a.8.8 0 0 1 0 1l-1.8 1.8a.8.8 0 0 1-1-1l1.7-1.8a.8.8 0 0 1 1 0zM6.3 17.7a.8.8 0 0 1 0 1l-1.7 1.8a.8.8 0 1 1-1-1l1.7-1.8a.8.8 0 0 1 1 0zM12 0a.8.8 0 0 1 .8.8v2.5a.8.8 0 0 1-1.6 0V.8A.8.8 0 0 1 12 0zm0 20a.8.8 0 0 1 .8.8v2.4a.8.8 0 0 1-1.6 0v-2.4a.8.8 0 0 1 .8-.8zM3.5 3.5a.8.8 0 0 1 1 0l1.8 1.8a.8.8 0 1 1-1 1L3.5 4.6a.8.8 0 0 1 0-1zm14.2 14.2a.8.8 0 0 1 1 0l1.8 1.7a.8.8 0 0 1-1 1l-1.8-1.7a.8.8 0 0 1 0-1z\"/>\n    <path class=\"moon\" fill-rule=\"evenodd\" d=\"M16.5 6A10.5 10.5 0 0 1 4.7 16.4 8.5 8.5 0 1 0 16.4 4.7l.1 1.3zm-1.7-2a9 9 0 0 1 .2 2 9 9 0 0 1-11 8.8 9.4 9.4 0 0 1-.8-.3c-.4 0-.8.3-.7.7a10 10 0 0 0 .3.8 10 10 0 0 0 9.2 6 10 10 0 0 0 4-19.2 9.7 9.7 0 0 0-.9-.3c-.3-.1-.7.3-.6.7a9 9 0 0 1 .3.8z\"/>\n  </svg>\n</button>\n\n\n<style>\n  #themeToggle {\n    border: 0;\n    background: none;\n  }\n  .sun { fill: black; }\n  .moon { fill: transparent; }\n\n\n\n\n  :global(.dark) .sun { fill: transparent; }\n  :global(.dark) .moon { fill: white; }\n</style>\n\nAdd the icon to Header.astro so that it will be displayed on all pages. Don‚Äôt forget to import the component.\n\nsrc/components/Header.astro\n---\nimport Hamburger from './Hamburger.astro';\nimport Navigation from './Navigation.astro';\nimport ThemeIcon from './ThemeIcon.astro';\n---\n<header>\n  <nav>\n    <Hamburger />\n    <ThemeIcon />\n    <Navigation />\n  </nav>\n</header>\n\nVisit your browser preview at http://localhost:4321 to see the icon now on all your pages. You can try clicking it, but you have not written a script to make it interactive yet.\n\nAdd CSS styling for a dark theme\nSection titled Add CSS styling for a dark theme\n\nChoose some alternate colors to use in dark mode.\n\nIn global.css, define some dark styles. You can choose your own, or copy and paste:\n\nsrc/styles/global.css\nhtml.dark {\n  background-color: #0d0950;\n  color: #fff;\n}\n\n\n.dark .nav-links a {\n  color: #fff;\n}\nAdd client-side interactivity\nSection titled Add client-side interactivity\n\nTo add interactivity to an Astro component, you can use a <script> tag. This script can check and set the current theme from localStorage and toggle the theme when the icon is clicked.\n\nAdd the following <script> tag in src/components/ThemeIcon.astro after your <style> tag:\n\nsrc/components/ThemeIcon.astro\n<style>\n  .sun { fill: black; }\n  .moon { fill: transparent; }\n\n\n  :global(.dark) .sun { fill: transparent; }\n  :global(.dark) .moon { fill: white; }\n</style>\n\n\n<script is:inline>\n  const theme = (() => {\n    if (typeof localStorage !== 'undefined' && localStorage.getItem('theme')) {\n      return localStorage.getItem('theme');\n    }\n    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {\n      return 'dark';\n    }\n      return 'light';\n  })();\n\n\n  if (theme === 'light') {\n    document.documentElement.classList.remove('dark');\n  } else {\n    document.documentElement.classList.add('dark');\n  }\n\n\n  window.localStorage.setItem('theme', theme);\n\n\n  const handleToggleClick = () => {\n    const element = document.documentElement;\n    element.classList.toggle(\"dark\");\n\n\n    const isDark = element.classList.contains(\"dark\");\n    localStorage.setItem(\"theme\", isDark ? \"dark\" : \"light\");\n  }\n\n\n  document.getElementById(\"themeToggle\").addEventListener(\"click\", handleToggleClick);\n</script>\n\nCheck your browser preview at http://localhost:4321 and click the theme icon. Verify that you can change between light and dark modes.\n\nTest your knowledge\nSection titled Test your knowledge\n\nChoose whether each of the following statements describes Astro <script> tags, UI framework components, or both.\n\nThey allow you to include interactive UI elements on your website.\n\nAstro <script> tags\n\nUI framework components\n\nboth\n\nSubmit\n\nThey will create static elements on your site unless you include a client: to send their JavaScript to the client and run in the browser.\n\nAstro <script> tags\n\nUI framework components\n\nboth\n\nSubmit\n\nThey allow you to ‚Äútry out‚Äù a new framework without requiring you to start an entirely new project using that tech stack.\n\nAstro <script> tags\n\nUI framework components\n\nboth\n\nSubmit\n\nThey allow you to reuse code you have written in other frameworks and you can often just drop them right into your site.\n\nAstro <script> tags\n\nUI framework components\n\nboth\n\nSubmit\n\nThey allow you to add interactivity without needing to know or learn any other JavaScript frameworks.\n\nAstro <script> tags\n\nUI framework components\n\nboth\n\nSubmit\nChecklist\nSection titled Checklist\n I can use JavaScript for interactivity when I don‚Äôt want to add a framework.\nResources\nSection titled Resources\nClient-side <script> in Astro\nNext Page\nCongratulations!"
  },
  {
    "title": "Build your first Astro island üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/6-islands/1/",
    "html": "6 ‚Ä¢ Set sail for Astro islands\n\nBuild your first Astro island\n\nUse a Preact component to greet your visitors with a randomly-selected welcome message!\n\nGET READY TO‚Ä¶\n\nAdd Preact to your Astro project\nInclude Astro islands (Preact .jsx components) on your home page\nUse client: directives to make islands interactive\nAdd Preact to your Astro project\nSection titled Add Preact to your Astro project\n\nIf it‚Äôs running, quit the dev server to have access to the terminal (keyboard shortcut: Ctrl + C).\n\nAdd the ability to use Preact components in your Astro project with a single command:\n\nTerminal window\nnpx astro add preact\n\nFollow the command line instructions to confirm adding Preact to your project.\n\nInclude a Preact greeting banner\nSection titled Include a Preact greeting banner\n\nThis component will take an array of greeting messages as a prop and randomly select one of them to show as a welcome message. The user can click a button to get a new random message.\n\nCreate a new file in src/components/ named Greeting.jsx\n\nNote the .jsx file extension. This file will be written in Preact, not Astro.\n\nAdd the following code to Greeting.jsx:\n\nsrc/components/Greeting.jsx\nimport { useState } from 'preact/hooks';\n\n\nexport default function Greeting({messages}) {\n\n\n  const randomMessage = () => messages[(Math.floor(Math.random() * messages.length))];\n\n\n  const [greeting, setGreeting] = useState(messages[0]);\n\n\n  return (\n    <div>\n      <h3>{greeting}! Thank you for visiting!</h3>\n      <button onClick={() => setGreeting(randomMessage())}>\n        New Greeting\n      </button>\n    </div>\n  );\n}\n\nImport and use this component on your Home page index.astro.\n\nsrc/pages/index.astro\n---\nimport BaseLayout from '../layouts/BaseLayout.astro';\nimport Greeting from '../components/Greeting.jsx';\nconst pageTitle = \"Home Page\";\n---\n<BaseLayout pageTitle={pageTitle}>\n  <h2>My awesome blog subtitle</h2>\n  <Greeting messages={[\"Hi\", \"Hello\", \"Howdy\", \"Hey there\"]} />\n</BaseLayout>\n\nCheck the preview in your browser: you should see a random greeting, but the button won‚Äôt work!\n\nAdd a second <Greeting /> component with the client:load directive.\n\nsrc/pages/index.astro\n---\nimport BaseLayout from '../layouts/BaseLayout.astro';\nimport Greeting from '../components/Greeting';\nconst pageTitle = \"Home Page\";\n---\n<BaseLayout pageTitle={pageTitle}>\n  <h2>My awesome blog subtitle</h2>\n  <Greeting messages={[\"Hi\", \"Hello\", \"Howdy\", \"Hey there\"]} />\n  <Greeting client:load messages={[\"Hej\", \"Hallo\", \"Hola\", \"Habari\"]} />\n</BaseLayout>\n\nRevisit your page and compare the two components. The second button works because the client:load directive tells Astro to send and rerun its JavaScript on the client when the page loads, making the component interactive. This is called a hydrated component.\n\nOnce the difference is clear, remove the non-hydrated Greeting component.\n\nsrc/pages/index.astro\n---\nimport BaseLayout from '../layouts/BaseLayout.astro';\nimport Greeting from '../components/Greeting';\nconst pageTitle = \"Home Page\";\n---\n<BaseLayout pageTitle={pageTitle}>\n  <h2>My awesome blog subtitle</h2>\n  <Greeting messages={[\"Hi\", \"Hello\", \"Howdy\", \"Hey there\"]} />\n  <Greeting client:load messages={[\"Hej\", \"Hallo\", \"Hola\", \"Habari\"]} />\n</BaseLayout>\nAnalyze the Pattern\nSection titled Analyze the Pattern\n\nThere are other client: directives to explore. Each sends the JavaScript to the client at a different time. client:visible, for example, will only send the component‚Äôs JavaScript when it is visible on the page.\n\nConsider an Astro component with the following code:\n\n---\nimport BaseLayout from '../layouts/BaseLayout.astro';\nimport AstroBanner from '../components/AstroBanner.astro';\nimport PreactBanner from '../components/PreactBanner';\nimport SvelteCounter from '../components/SvelteCounter.svelte';\n---\n<BaseLayout>\n  <AstroBanner />\n  <PreactBanner />\n  <PreactBanner client:load />\n  <SvelteCounter />\n  <SvelteCounter client:visible />\n</BaseLayout>\n\nWhich of the five components will be hydrated islands, sending JavaScript to the client?\n\n<PreactBanner client:load /> and <SvelteCounter client:visible /> will be hydrated islands.\n\nIn what way(s) will the two <PreactBanner /> components be the same? In what way(s) will they be different?\n\nSame: They both show the same HTML elements and look the same initially. Different: The component with the client:load directive will rerender after the page is loaded, and any interactive elements that it has will work.\n\nAssume the SvelteCounter component shows a number and has a button to increase it. If you couldn‚Äôt see your website‚Äôs code, only the live published page, how would you tell which of the two <SvelteCounter /> components used client:visible?\n\nTry clicking the button, and see which one is interactive. If it responds to your input, it must have had a client: directive.\n\nTest your knowledge\nSection titled Test your knowledge\n\nFor each of the following components, identify what will be sent to the browser:\n\n<ReactCounter client:load/>\n\nHTML and CSS only\n\nHTML, CSS, and JavaScript\n\nSubmit\n\n<SvelteCard />\n\nHTML and CSS only\n\nHTML, CSS, and JavaScript\n\nSubmit\nChecklist\nSection titled Checklist\n I can install an Astro integration.\n I can write UI framework components in their own language.\n I can use a client: directive for hydration on my UI framework component.\nResources\nSection titled Resources\n\nAstro Integrations Guide\n\nUsing UI Framework Components in Astro\n\nAstro client directives reference\n\nNext Page\nBack on dry land. Take your blog from day to night, no island required!"
  },
  {
    "title": "Check in: Unit 6 - Astro Islands üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/6-islands/",
    "html": "6 ‚Ä¢ Set sail for Astro islands\n\nCheck in: Unit 6 ‚Å†-‚Å† Astro Islands\n\nNow that you have a fully functioning blog, it‚Äôs time to add some interactive islands to your site!\n\nLooking ahead\nSection titled Looking ahead\n\nIn this unit, you‚Äôll use Astro islands to bring frontend framework components into your Astro site.\n\nYou will:\n\nAdd a UI framework, Preact, to your Astro project\nUse Preact to create an interactive greeting component\nLearn when you might not choose islands for interactivity\nChecklist\nSection titled Checklist\n I am ready to add some interactivity to my site, and start living that island life!\nNext Page\nBuild your first Astro island"
  },
  {
    "title": "Add an RSS feed üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/5-astro-api/4/",
    "html": "5 ‚Ä¢ Beef up your blog\n\nAdd an RSS feed\n\nGET READY TO‚Ä¶\n\nInstall an Astro package for creating an RSS feed for your website\nCreate a feed that can be subscribed to and read by RSS feed readers\nInstall Astro‚Äôs RSS package\nSection titled Install Astro‚Äôs RSS package\n\nAstro provides a custom package to quickly add an RSS feed to your website.\n\nThis official package generates a non-HTML document with information about all of your blog posts that can be read by feed readers like Feedly, The Old Reader, and more. This document is updated every time your site is rebuilt.\n\nIndividuals can subscribe to your feed in a feed reader, and receive a notification when you publish a new blog post on your site, making it a popular blog feature.\n\nQuit the Astro development server and run the following command in the terminal to install Astro‚Äôs RSS package.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @astrojs/rss\n\nRestart the dev server to begin working on your Astro project again.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm run dev\nCreate an .xml feed document\nSection titled Create an .xml feed document\n\nCreate a new file in src/pages/ called rss.xml.js\n\nCopy the following code into this new document. Customize the title and description properties, and if necessary, specify a different language in customData:\n\nsrc/pages/rss.xml.js\nimport rss, { pagesGlobToRssItems } from '@astrojs/rss';\n\n\nexport async function GET(context) {\n  return rss({\n    title: 'Astro Learner | Blog',\n    description: 'My journey learning Astro',\n    site: context.site,\n    items: await pagesGlobToRssItems(import.meta.glob('./**/*.md')),\n    customData: `<language>en-us</language>`,\n  });\n}\n\nAdd the site property to the Astro config with your site‚Äôs own unique Netlify URL.\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\n\n\nexport default defineConfig({\n  site: \"https://example.com\"\n});\n\nThis rss.xml document is only created when your site is built, so you won‚Äôt be able to see this page in your browser during development. Quit the dev server and run the following commands to first, build your site locally and then, view a preview of your build:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm run build\n\n\nnpm run preview\n\nVisit http://localhost:4321/rss.xml and verify that you can see (unformatted) text on the page with an item for each of your .md files. Each item should contain blog post information such as title, url, and description.\n\n VIEW YOUR RSS FEED IN A READER\n\nDownload a feed reader, or sign up for an online feed reader service and subscribe to your site by adding your own Netlify URL. You can also share this link with others so they can subscribe to your posts, and be notified when a new one is published.\n\nBe sure to quit the preview and restart the dev server when you want to view your site in development mode again.\n\nChecklist\nSection titled Checklist\n I can install an Astro package using the command line.\n I can create an RSS feed for my website.\nResources\nSection titled Resources\nRSS item generation in Astro\nNext Page\nCheck in: Unit 6 - Astro Islands"
  },
  {
    "title": "Build a tag index page üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/5-astro-api/3/",
    "html": "5 ‚Ä¢ Beef up your blog\n\nBuild a tag index page\n\nNow that you have individual pages for every tag, it‚Äôs time to make links to them.\n\nGET READY TO‚Ä¶\n\nAdd a new page using the /pages/folder/index.astro routing pattern\nDisplay a list of all your unique tags, linking to each tag page\nUpdate your site with navigation links to this new Tags page\nUse the /pages/folder/index.astro routing pattern\nSection titled Use the /pages/folder/index.astro routing pattern\n\nTo add a Tag Index page to your website, you could create a new file at src/pages/tags.astro.\n\nBut, since you already have the directory /tags/, you can take advantage of another routing pattern in Astro, and keep all your files related to tags together.\n\nTry it yourself - Make a Tag Index page\nSection titled Try it yourself - Make a Tag Index page\n\nCreate a new file index.astro in the directory src/pages/tags/.\n\nNavigate to http://localhost:4321/tags and verify that your site now contains a page at this URL. It will be empty, but it will exist.\n\nCreate a minimal page at src/pages/tags/index.astro that uses your layout. You have done this before!\n\nExpand to see the steps\n\nCheck your browser preview again and you should have a formatted page, ready to add content to!\n\nCreate an array of tags\nSection titled Create an array of tags\n\nYou have previously displayed items in a list from an array using map(). What would it look like to define an array of all your tags, then display them in a list on this page?\n\nSee the code\n\nYou could do this, but then you would need to come back to this file and update your array every time you use a new tag in a future blog post.\n\nFortunately, you already know a way to grab the data from all your Markdown files in one line of code, then return a list of all your tags.\n\nIn src/pages/tags/index.astro, add the line of code to the frontmatter script that will give your page access to the data from every .md blog post file.\n\nSee the code\n\nNext, add the following line of JavaScript to your page component. This is the same one you used in src/pages/tags/[tag].astro to return a list of unique tags.\n\nsrc/pages/tags/index.astro\n---\nimport BaseLayout from '../../layouts/BaseLayout.astro';\nconst allPosts = await Astro.glob('../posts/*.md');\nconst tags = [...new Set(allPosts.map((post) => post.frontmatter.tags).flat())];\nconst pageTitle = \"Tag Index\";\n---\nCreate your list of tags\nSection titled Create your list of tags\n\nInstead of creating items in an unordered list this time, create one <p> for each item, inside a <div>. The pattern should look familiar!\n\nAdd the following code to your component template:\n\nsrc/pages/tags/index.astro\n  <BaseLayout pageTitle={pageTitle}>\n    <div>{tags.map((tag) => <p>{tag}</p>)}</div>\n  </BaseLayout>\n\nIn your browser preview, verify that you can see your tags listed.\n\nTo make each tag link to its own page, add the following <a> link to each tag name:\n\nsrc/pages/tags/index.astro\n<BaseLayout pageTitle={pageTitle}>\n  <div>\n    {tags.map((tag) => (\n      <p><a href={`/tags/${tag}`}>{tag}</a></p>\n    ))}\n  </div>\n</BaseLayout>\nAdd styles to your tag list\nSection titled Add styles to your tag list\n\nAdd the following CSS classes to style both your <div> and each <p> that will be generated. Note: Astro uses HTML syntax for adding class names!\n\nsrc/pages/tags/index.astro\n<BaseLayout pageTitle={pageTitle}>\n<div class=\"tags\">\n  {tags.map((tag) => (\n    <p class=\"tag\"><a href={`/tags/${tag}`}>{tag}</a></p>\n  ))}\n</div>\n</BaseLayout>\n\nDefine these new CSS classes by adding the following <style> tag to this page:\n\nsrc/pages/tags/index.astro\n<style>\n  a {\n    color: #00539F;\n  }\n\n\n  .tags {\n    display: flex;\n    flex-wrap: wrap;\n  }\n\n\n  .tag {\n    margin: 0.25em;\n    border: dotted 1px #a1a1a1;\n    border-radius: .5em;\n    padding: .5em 1em;\n    font-size: 1.15em;\n    background-color: #F8FCFD;\n  }\n</style>\n\nCheck your browser preview at http://localhost:4321/tags to verify that you have some new styles and that each of the tags on the page has a working link to its own individual tag page.\n\nCode Check-In\nSection titled Code Check-In\n\nHere is what your new page should look like:\n\nsrc/pages/tags/index.astro\n---\nimport BaseLayout from '../../layouts/BaseLayout.astro';\nconst allPosts = await Astro.glob('../posts/*.md');\nconst tags = [...new Set(allPosts.map((post) => post.frontmatter.tags).flat())];\nconst pageTitle = \"Tag Index\";\n---\n<BaseLayout pageTitle={pageTitle}>\n  <div class=\"tags\">\n    {tags.map((tag) => (\n      <p class=\"tag\"><a href={`/tags/${tag}`}>{tag}</a></p>\n    ))}\n  </div>\n</BaseLayout>\n<style>\n  a {\n    color: #00539F;\n  }\n\n\n  .tags {\n    display: flex;\n    flex-wrap: wrap;\n  }\n\n\n  .tag {\n    margin: 0.25em;\n    border: dotted 1px #a1a1a1;\n    border-radius: .5em;\n    padding: .5em 1em;\n    font-size: 1.15em;\n    background-color: #F8FCFD;\n  }\n</style>\nAdd this page to your navigation\nSection titled Add this page to your navigation\n\nRight now, you can navigate to http://localhost:4321/tags and see this page. From this page, you can click on links to your individual tag pages.\n\nBut, you still need to make these pages discoverable from other pages on your website.\n\nIn your Navigation.astro component, include a link to this new tag index page.\n\nShow me the code\nChallenge: Include tags in your blog post layout\nSection titled Challenge: Include tags in your blog post layout\n\nYou have now written all the code you need to also display a list of tags on each blog post, and link them to their tag pages. You have existing work that you can reuse!\n\nFollow the steps below, then check your work by comparing it to the final code sample.\n\nCopy the <div class=\"tags\">...</div> and <style>...</style> from src/pages/tags/index.astro and reuse it inside MarkdownPostLayout.astro:\nsrc/layouts/MarkdownPostLayout.astro\n---\nimport BaseLayout from './BaseLayout.astro';\nconst { frontmatter } = Astro.props;\n---\n<BaseLayout pageTitle={frontmatter.title}>\n  <p><em>{frontmatter.description}</em></p>\n  <p>{frontmatter.pubDate.slice(0,10)}</p>\n\n\n  <p>Written by: {frontmatter.author}</p>\n\n\n  <img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n\n\n  <div class=\"tags\">\n    {tags.map((tag) => (\n      <p class=\"tag\"><a href={`/tags/${tag}`}>{tag}</a></p>\n    ))}\n  </div>\n\n\n  <slot />\n</BaseLayout>\n<style>\n  a {\n    color: #00539F;\n  }\n\n\n  .tags {\n    display: flex;\n    flex-wrap: wrap;\n  }\n\n\n  .tag {\n    margin: 0.25em;\n    border: dotted 1px #a1a1a1;\n    border-radius: .5em;\n    padding: .5em 1em;\n    font-size: 1.15em;\n    background-color: #F8FCFD;\n  }\n</style>\n\nBefore this code will work, you need to make one small edit to the code you pasted into MarkdownPostLayout.astro. Can you figure out what it is?\n\nGive me a hint\nGive me another hint!\nCode Check-in: MarkdownPostLayout\nSection titled Code Check-in: MarkdownPostLayout\n\nTo check your work, or if you just want complete, correct code to copy into MarkdownPostLayout.astro, here is what your Astro component should look like:\n\nsrc/layouts/MarkdownPostLayout.astro\n---\nimport BaseLayout from './BaseLayout.astro';\nconst { frontmatter } = Astro.props;\n---\n<BaseLayout pageTitle={frontmatter.title}>\n  <p><em>{frontmatter.description}</em></p>\n  <p>{frontmatter.pubDate.slice(0,10)}</p>\n\n\n  <p>Written by: {frontmatter.author}</p>\n\n\n  <img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n\n\n  <div class=\"tags\">\n    {frontmatter.tags.map((tag) => (\n      <p class=\"tag\"><a href={`/tags/${tag}`}>{tag}</a></p>\n    ))}\n  </div>\n\n\n  <slot />\n</BaseLayout>\n<style>\n  a {\n    color: #00539F;\n  }\n\n\n  .tags {\n    display: flex;\n    flex-wrap: wrap;\n  }\n\n\n  .tag {\n    margin: 0.25em;\n    border: dotted 1px #a1a1a1;\n    border-radius: .5em;\n    padding: .5em 1em;\n    font-size: 1.15em;\n    background-color: #F8FCFD;\n  }\n</style>\nTest your knowledge\nSection titled Test your knowledge\n\nMatch each file path with a second file path that will create a page at the same route.\n\nsrc/pages/categories.astro\n\nsrc/pages/posts/post.astro\nsrc/pages/posts/index.astro\nsrc/components/shoes/Shoe.astro\nsrc/pages/categories/index.astro\nSubmit\n\nsrc/pages/posts.astro\n\nsrc/pages/products/shoes.astro\nsrc/pages/posts/post.astro\nsrc/pages/posts/index.astro\nsrc/pages/categories/index.astro\nSubmit\n\nsrc/pages/products/shoes/index.astro\n\nsrc/pages/products/shoes.astro\nsrc/pages/posts/post.astro\nsrc/pages/posts/index.astro\nsrc/components/shoes/Shoe.astro\nSubmit\nChecklist\nSection titled Checklist\n I can use Astro‚Äôs /pages/folder/index.astro routing feature.\nResources\nSection titled Resources\nStatic Routing in Astro\nNext Page\nAdd an RSS feed"
  },
  {
    "title": "Check in: Unit 5 - Astro API üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/5-astro-api/",
    "html": "5 ‚Ä¢ Beef up your blog\n\nCheck in: Unit 5 ‚Å†-‚Å† Astro API\n\nNow that you have some blog posts, it‚Äôs time to use Astro‚Äôs API to work with your files!\n\nLooking ahead\nSection titled Looking ahead\n\nIn this unit, you‚Äôll supercharge your blog with an index page, tag pages, and an RSS feed.\n\nAlong the way, you‚Äôll learn how to use:\n\nAstro.glob() to access data from files in your project\ngetStaticPaths() to create multiple pages (routes) at once\nThe Astro RSS package to create an RSS feed\nChecklist\nSection titled Checklist\n I am ready to add some blog features to my Astro project!\nNext Page\nCreate a blog post archive"
  },
  {
    "title": "Create a blog post archive üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/5-astro-api/1/",
    "html": "5 ‚Ä¢ Beef up your blog\n\nCreate a blog post archive\n\nNow that you have a few blog posts to link to, it‚Äôs time to configure the Blog page to create a list of them automatically!\n\nGET READY TO‚Ä¶\n\nAccess data from all your posts at once using Astro.glob()\nDisplay a dynamically generated list of posts on your Blog page\nRefactor to use a <BlogPost /> component for each list item\nDynamically display a list of posts\nSection titled Dynamically display a list of posts\n\nAdd the following code to blog.astro to return information about all your Markdown files. Astro.glob() will return an array of objects, one for each blog post.\n\nsrc/pages/blog.astro\n---\nimport BaseLayout from '../layouts/BaseLayout.astro'\nconst allPosts = await Astro.glob('../pages/posts/*.md');\nconst pageTitle = \"My Astro Learning Blog\";\n---\n<BaseLayout pageTitle={pageTitle}>\n  <p>This is where I will post about my journey learning Astro.</p>\n  <ul>\n    <li><a href=\"/posts/post-1/\">Post 1</a></li>\n    <li><a href=\"/posts/post-2/\">Post 2</a></li>\n    <li><a href=\"/posts/post-3/\">Post 3</a></li>\n  </ul>\n</BaseLayout>\n\nTo generate the entire list of posts dynamically, using the post titles and URLs, replace your individual <li> tags with the following Astro code:\n\nsrc/pages/blog.astro\n---\nimport BaseLayout from '../layouts/BaseLayout.astro'\nconst allPosts = await Astro.glob('../pages/posts/*.md');\nconst pageTitle = \"My Astro Learning Blog\";\n---\n<BaseLayout pageTitle={pageTitle}>\n  <p>This is where I will post about my journey learning Astro.</p>\n  <ul>\n    <li><a href=\"/posts/post-1/\">Post 1</a></li>\n    <li><a href=\"/posts/post-2/\">Post 2</a></li>\n    <li><a href=\"/posts/post-3/\">Post 3</a></li>\n\n\n    {allPosts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}\n  </ul>\n</BaseLayout>\n\nYour entire list of blog posts is now being generated dynamically, by mapping over the array returned by Astro.glob().\n\nAdd a new blog post by creating a new post-4.md file in src/pages/posts/ and adding some Markdown content. Be sure to include at least the frontmatter properties used below.\n\n---\nlayout: ../../layouts/MarkdownPostLayout.astro\ntitle: My Fourth Blog Post\nauthor: Astro Learner\ndescription: \"This post will show up on its own!\"\nimage:\n    url: \"https://docs.astro.build/default-og-image.png\"\n    alt: \"The word astro against an illustration of planets and stars.\"\npubDate: 2022-08-08\ntags: [\"astro\", \"successes\"]\n---\nThis post should show up with my other blog posts, because `Astro.glob()` is returning a list of all my posts in order to create my list.\n\nRevisit your blog page in your browser preview at http://localhost:4321/blog and look for an updated list with four items, including your new blog post!\n\nChallenge: Create a BlogPost component\nSection titled Challenge: Create a BlogPost component\n\nTry on your own to make the all necessary changes to your Astro project so that you can instead use the following code to generate your list of blog posts:\n\nsrc/pages/blog.astro\n<ul>\n  {allPosts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}\n  {allPosts.map((post) => <BlogPost url={post.url} title={post.frontmatter.title} />)}\n</ul>\nExpand to see the steps\nTest your knowledge\nSection titled Test your knowledge\n\nIf your Astro component contains the following line of code:\n\n---\nconst myPosts = await Astro.glob('../pages/posts/*.md');\n---\n\nChoose the syntax you could write to represent:\n\nThe title of your third blog post.\n\nmyPosts.map((post) => <LastUpdated date={post.frontmatter.pubDate} />)\n\nmyPosts[2].frontmatter.title\n\n<a href={myPosts[0].url}>First Post!!</a>\n\nSubmit\n\nA link to the URL of your first blog post.\n\nmyPosts.map((post) => <LastUpdated date={post.frontmatter.pubDate} />)\n\nmyPosts[2].frontmatter.title\n\n<a href={myPosts[0].url}>First Post!!</a>\n\nSubmit\n\nA component for each post, displaying the date that it was last updated.\n\nmyPosts.map((post) => <LastUpdated date={post.frontmatter.pubDate} />)\n\nmyPosts[2].frontmatter.title\n\n<a href={myPosts[0].url}>First Post!!</a>\n\nSubmit\nChecklist\nSection titled Checklist\n I can query for data from my local files.\n I can display a list of all my blog posts.\nResources\nSection titled Resources\nAstro.glob() API documentation\nNext Page\nGenerate tag pages"
  },
  {
    "title": "Generate tag pages üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/5-astro-api/2/",
    "html": "5 ‚Ä¢ Beef up your blog\n\nGenerate tag pages\n\nGET READY TO‚Ä¶\n\nCreate a page to generate multiple pages\nSpecify which page routes to build, and pass each page its own props\nDynamic page routing\nSection titled Dynamic page routing\n\nYou can create entire sets of pages dynamically using .astro files that export a getStaticPaths() function.\n\nCreate pages dynamically\nSection titled Create pages dynamically\n\nCreate a new file at src/pages/tags/[tag].astro. (You will have to create a new folder.) Notice that the file name ([tag].astro) uses square brackets. Paste the following code into the file:\n\nsrc/pages/tags/[tag].astro\n---\nimport BaseLayout from '../../layouts/BaseLayout.astro';\n\n\nexport async function getStaticPaths() {\n  return [\n    { params: { tag: \"astro\" } },\n    { params: { tag: \"successes\" } },\n    { params: { tag: \"community\" } },\n    { params: { tag: \"blogging\" } },\n    { params: { tag: \"setbacks\" } },\n    { params: { tag: \"learning in public\" } },\n  ];\n}\n\n\nconst { tag } = Astro.params;\n---\n<BaseLayout pageTitle={tag}>\n  <p>Posts tagged with {tag}</p>\n</BaseLayout>\n\nThe getStaticPaths function returns an array of page routes, and all of the pages at those routes will use the same template defined in the file.\n\nIf you have customized your blog posts, then replace the individual tag values (e.g. ‚Äúastro‚Äù, ‚Äúsuccesses‚Äù, ‚Äúcommunity‚Äù, etc.) with the tags used in your own posts.\n\nMake sure that every blog post contains at least one tag, written as an array, e.g. tags: [\"blogging\"].\n\nVisit http://localhost:4321/tags/astro in your browser preview and you should see a page, generated dynamically from [tag].astro. Check that you also have pages created for each of your tags at /tags/successes, /tags/community, and /tags/learning%20in%20public, etc., or at each of your custom tags. You may need to first quit and restart the dev server to see these new pages.\n\nUse props in dynamic routes\nSection titled Use props in dynamic routes\n\nAdd the following props to your getStaticPaths() function in order to make data from all your blog posts available to each page route.\n\nBe sure to give each route in your array the new props, and then make those props available to your component template outside of your function.\n\nsrc/pages/tags/[tag].astro\n---\nimport BaseLayout from '../../layouts/BaseLayout.astro';\n\n\nexport async function getStaticPaths() {\n  const allPosts = await Astro.glob('../posts/*.md');\n\n\n  return [\n    {params: {tag: \"astro\"}, props: {posts: allPosts}},\n    {params: {tag: \"successes\"}, props: {posts: allPosts}},\n    {params: {tag: \"community\"}, props: {posts: allPosts}},\n    {params: {tag: \"blogging\"}, props: {posts: allPosts}},\n    {params: {tag: \"setbacks\"}, props: {posts: allPosts}},\n    {params: {tag: \"learning in public\"}, props: {posts: allPosts}}\n  ]\n}\n\n\nconst { tag } = Astro.params;\nconst { posts } = Astro.props;\n---\n\nFilter your list of posts to only include posts that contain the page‚Äôs own tag.\n\n/src/pages/tags/[tag].astro\n---\nconst { tag } = Astro.params;\nconst { posts } = Astro.props;\nconst filteredPosts = posts.filter((post) => post.frontmatter.tags?.includes(tag));\n---\n\nNow you can update your HTML template to show a list of each blog post containing the page‚Äôs own tag. Add the following code to [tag].astro:\n\nsrc/pages/tags/[tag].astro\n<BaseLayout pageTitle={tag}>\n  <p>Posts tagged with {tag}</p>\n  <ul>\n    {filteredPosts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}\n  </ul>\n</BaseLayout>\n\nYou can even refactor this to use your <BlogPost /> component instead! (Don‚Äôt forget to import this component at the top of [tag].astro.)\n\nsrc/pages/tags/[tag].astro\n<BaseLayout pageTitle={tag}>\n  <p>Posts tagged with {tag}</p>\n  <ul>\n    {filteredPosts.map((post) => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}\n    {filteredPosts.map((post) => <BlogPost url={post.url} title={post.frontmatter.title}/>)}\n  </ul>\n</BaseLayout>\n\nCheck your browser preview for your individual tag pages, and you should now see a list of all of your blog posts containing that particular tag.\n\nAnalyze the pattern\nSection titled Analyze the pattern\n\nFor each of the following, state whether the code is written inside the getStaticPaths() function, or outside of it.\n\nThe Astro.glob() call to receive information about all your .md files to pass to each page route.\n\ninside getStaticPaths\noutside getStaticPaths\nSubmit\n\nThe list of routes to be generated (returned) by getStaticPaths()\n\ninside getStaticPaths\noutside getStaticPaths\nSubmit\n\nThe received values of props and params to be used in the HTML template.\n\ninside getStaticPaths\noutside getStaticPaths\nSubmit\n\n TAKEAWAY\n\nIf you need information to construct the page routes, write it inside getStaticPaths().\n\nTo receive information in the HTML template of a page route, write it outside getStaticPaths().\n\nAdvanced JavaScript: Generate pages from existing tags\nSection titled Advanced JavaScript: Generate pages from existing tags\n\nYour tag pages are now defined statically in [tag].astro. If you add a new tag to a blog post, you will also have to revisit this page and update your page routes.\n\nThe following example shows how to replace your code on this page with code that will automatically look for, and generate pages for, each tag used on your blog pages.\n\n NOTE\n\nEven if it looks challenging, you can try following along with the steps to build this function yourself! If you don‚Äôt want to walk through the JavaScript required right now, you can skip ahead to the finished version of the code and use it directly in your project, replacing the existing content.\n\n1. Check that all your blog posts contain tags\nSection titled 1. Check that all your blog posts contain tags\n\nRevisit each of your existing Markdown pages and ensure that every post contains a tags array in its frontmatter. Even if you only have one tag, it should still be written as an array, e.g. tags: [\"blogging\"].\n\n2. Create an array of all your existing tags\nSection titled 2. Create an array of all your existing tags\n\nAdd the following code to provide you with a list of every tag used in your blog posts.\n\nsrc/pages/tags/[tag].astro\n---\nimport BaseLayout from '../../layouts/BaseLayout.astro';\n\n\nexport async function getStaticPaths() {\n  const allPosts = await Astro.glob('../posts/*.md');\n\n\n  const uniqueTags = [...new Set(allPosts.map((post) => post.frontmatter.tags).flat())];\nTell me what this line of code is doing in more detail!\n\nYou now have an array uniqueTags with element items \"astro\", \"successes\", \"community\", \"blogging\", \"setbacks\", \"learning in public\"\n\n3. Replace the return value of the getStaticPaths function\nSection titled 3. Replace the return value of the getStaticPaths function\nsrc/pages/tags/[tag].astro\n  return [\n        {params: {tag: \"astro\"}, props: {posts: allPosts}},\n        {params: {tag: \"successes\"}, props: {posts: allPosts}},\n        {params: {tag: \"community\"}, props: {posts: allPosts}},\n        {params: {tag: \"blogging\"}, props: {posts: allPosts}},\n        {params: {tag: \"setbacks\"}, props: {posts: allPosts}},\n        {params: {tag: \"learning in public\"}, props: {posts: allPosts}}\n      ]\n\n\n  return uniqueTags.map((tag) => {\n    const filteredPosts = allPosts.filter((post) => post.frontmatter.tags.includes(tag));\n    return {\n      params: { tag },\n      props: { posts: filteredPosts },\n    };\n  });\n\nA getStaticPaths function should always return a list of objects containing params (what to call each page route) and optionally any props (data that you want to pass to those pages). Earlier, you defined each tag name that you knew was used in your blog and passed the entire list of posts as props to each page.\n\nNow, you generate this list of objects automatically using your uniqueTags array to define each parameter.\n\nAnd, now the list of all blog posts is filtered before it is sent to each page as props. Be sure to remove the previous line of code filtering the posts, and update your HTML template to use posts instead of filteredPosts.\n\nsrc/pages/tags/[tag].astro\nconst { tag } = Astro.params;\nconst { posts } = Astro.props;\nconst filteredPosts = posts.filter((post) => post.frontmatter.tags?.includes(tag));\n---\n<!-- -->\n<ul>\n    {filteredPosts.map((post) => <BlogPost url={post.url} title={post.frontmatter.title}/>)}\n    {posts.map((post) => <BlogPost url={post.url} title={post.frontmatter.title}/>)}\n</ul>\nFinal code sample\nSection titled Final code sample\n\nTo check your work, or if you just want complete, correct code to copy into [tag].astro, here is what your Astro component should look like:\n\nsrc/pages/tags/[tag].astro\n---\nimport BaseLayout from '../../layouts/BaseLayout.astro';\nimport BlogPost from '../../components/BlogPost.astro';\n\n\nexport async function getStaticPaths() {\n  const allPosts = await Astro.glob('../posts/*.md');\n\n\n  const uniqueTags = [...new Set(allPosts.map((post) => post.frontmatter.tags).flat())];\n\n\n  return uniqueTags.map((tag) => {\n    const filteredPosts = allPosts.filter((post) => post.frontmatter.tags.includes(tag));\n    return {\n      params: { tag },\n      props: { posts: filteredPosts },\n    };\n  });\n}\n\n\nconst { tag } = Astro.params;\nconst { posts } = Astro.props;\n---\n<BaseLayout pageTitle={tag}>\n  <p>Posts tagged with {tag}</p>\n  <ul>\n    {posts.map((post) => <BlogPost url={post.url} title={post.frontmatter.title}/>)}\n  </ul>\n</BaseLayout>\n\nNow, you should be able to visit any of your tag pages in your browser preview.\n\nNavigate to http://localhost:4321/tags/community and you should see a list of only your blog posts with the tag community. Similarly http://localhost:4321/tags/learning%20in%20public should display a list of the blog posts tagged learning in public.\n\nIn the next section, you will create navigation links to these pages.\n\nTest your knowledge\nSection titled Test your knowledge\n\nChoose the term that matches the description.\n\nA function that returns an array of page routes.\n\nparams\ndynamic routing\ngetStaticPaths()\nprops\nSubmit\n\nThe process of creating multiple page routes from one file in Astro.\n\nparams\ndynamic routing\ngetStaticPaths()\nprops\nSubmit\n\nA value that defines the name of a page route generated dynamically.\n\nparams\ndynamic routing\ngetStaticPaths()\nprops\nSubmit\nChecklist\nSection titled Checklist\n I can generate pages dynamically.\n I can pass props to each page route.\nResources\nSection titled Resources\n\nDynamic Page Routing in Astro\n\ngetStaticPaths() API documentation\n\nNext Page\nBuild a tag index page"
  },
  {
    "title": "Combine layouts to get the best of both worlds üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/4-layouts/3/",
    "html": "4 ‚Ä¢ Save time and energy with reusable page layouts\n\nCombine layouts to get the best of both worlds\n\nNow that you have added a layout to each blog post, it‚Äôs time to make your posts look like the rest of the pages on your website!\n\nGET READY TO‚Ä¶\n\nNest your blog post layout inside your main page layout\nNest your two layouts\nSection titled Nest your two layouts\n\nYou already have a BaseLayout.astro for defining the overall layout of your pages.\n\nMarkdownPostLayout.astro gives you some additional templating for common blog post properties such as title and date, but your blog posts don‚Äôt look like the other pages on your site. You can match the look of your blog posts to the rest of your site by nesting layouts.\n\nIn src/layouts/MarkdownPostLayout.astro, import BaseLayout.astro and use it to wrap the entire template content. Don‚Äôt forget to pass the pageTitle prop:\n\nsrc/layouts/MarkdownPostLayout.astro\n---\nimport BaseLayout from './BaseLayout.astro';\nconst { frontmatter } = Astro.props;\n---\n<BaseLayout pageTitle={frontmatter.title}>\n  <h1>{frontmatter.title}</h1>\n  <p>{frontmatter.pubDate.slice(0,10)}</p>\n  <p><em>{frontmatter.description}</em></p>\n  <p>Written by: {frontmatter.author}</p>\n  <img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n  <slot />\n</BaseLayout>\n\nCheck your browser preview at http://localhost:4321/posts/post-1. Now you should see content rendered by:\n\nYour main page layout, including your styles, navigation links, and social footer.\nYour blog post layout, including frontmatter properties like the description, date, title, and image\nYour individual blog post Markdown content, including just the text written in this post\n\nNotice that your page title is now displayed twice, once by each layout.\n\nRemove the line that displays your page title from MarkdownPostLayout.astro:\n\nsrc/layouts/MarkdownPostLayout.astro\n<BaseLayout pageTitle={frontmatter.title}>\n  <h1>{frontmatter.title}</h1>\n  <p>{frontmatter.pubDate.slice(0,10)}</p>\n  <p><em>{frontmatter.description}</em></p>\n  <p>Written by: {frontmatter.author}</p>\n  <img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n  <slot />\n</BaseLayout>\n\nCheck your browser preview again at http://localhost:4321/posts/post-1 and verify that this line is no longer displayed and that your title is only displayed once. Make any other adjustments necessary to ensure that you do not have any duplicated content.\n\nMake sure that:\n\nEach blog post shows the same page template, and no content is missing. (If one of your blog posts is missing content, check its frontmatter properties.)\n\nNo content is duplicated on a page. (If something is being rendered twice, then be sure to remove it from MarkdownPostLayout.astro.)\n\nIf you‚Äôd like to customize your page template, you can.\n\nTest your knowledge\nSection titled Test your knowledge\n\nThis allows you to nest one layout inside another and take advantage of working with modular pieces.\n\ncontinuous deployment\n\nresponsive design\n\ncomponent-based design\n\nSubmit\n\nMultiple layouts are particularly useful for projects that contain Markdown pages, like a‚Ä¶\n\nblog\n\ndashboard\n\nchat app\n\nSubmit\n\nWhich of these provides templating for all your pages?\n\nindex.astro\n\nBaseLayout.astro\n\npost-1.md\n\nSubmit\nChecklist\nSection titled Checklist\n I can nest layouts, checking for any duplicated elements.\nResources\nSection titled Resources\nNesting Layouts in Astro\nNext Page\nCheck in: Unit 5 - Astro API"
  },
  {
    "title": "Create and pass data to a custom blog layout üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/4-layouts/2/",
    "html": "4 ‚Ä¢ Save time and energy with reusable page layouts\n\nCreate and pass data to a custom blog layout\n\nNow that you have a layout for your pages, it‚Äôs time to add a layout for blog posts!\n\nGET READY TO‚Ä¶\n\nCreate a new blog post layout for your Markdown files\nPass YAML frontmatter values as props to layout component\nAdd a layout to your blog posts\nSection titled Add a layout to your blog posts\n\nWhen you include the layout frontmatter property in an .md file, all of your frontmatter YAML values are available to the layout file.\n\nCreate a new file at src/layouts/MarkdownPostLayout.astro\n\nCopy the following code into MarkdownPostLayout.astro\n\nsrc/layouts/MarkdownPostLayout.astro\n---\nconst { frontmatter } = Astro.props;\n---\n<h1>{frontmatter.title}</h1>\n<p>Written by {frontmatter.author}</p>\n<slot />\n\nAdd the following frontmatter property in post-1.md\n\nsrc/pages/posts/post-1.md\n---\nlayout: ../../layouts/MarkdownPostLayout.astro\ntitle: 'My First Blog Post'\npubDate: 2022-07-01\ndescription: 'This is the first post of my new Astro blog.'\nauthor: 'Astro Learner'\nimage:\n    url: 'https://docs.astro.build/assets/full-logo-light.png'\n    alt: 'The full Astro logo.'\ntags: [\"astro\", \"blogging\", \"learning in public\"]\n---\n\nCheck your browser preview again at http://localhost:4321/posts/post-1 and notice what the layout has added to your page.\n\nAdd the same layout property to your two other blog posts post-2.md and post-3.md. Verify in your browser that your layout is also applied to these posts.\n\n TIP\n\nWhen using layouts, you now have the option of including elements, like a page title, in the Markdown content or in the layout. Remember to visually inspect your page preview and make any adjustments necessary to avoid duplicated elements.\n\nTry it yourself - Customize your blog post layout\nSection titled Try it yourself - Customize your blog post layout\n\nChallenge: Identify items common to every blog post, and use MarkdownPostLayout.astro to render them, instead of writing them in your Markdown in post-1.md and in every future blog post.\n\nHere‚Äôs an example of refactoring your code to include the pubDate in the layout component instead of writing it in the body of your Markdown:\n\nsrc/pages/posts/post-1.md\nPublished on: 2022-07-01\n\n\nWelcome to my _new blog_ about learning Astro! Here, I will share my learning journey as I build a new website.\nsrc/layouts/MarkdownPostLayout.astro\n---\nconst { frontmatter } = Astro.props;\n---\n<h1>{frontmatter.title}</h1>\n<p>Published on: {frontmatter.pubDate.slice(0,10)}</p>\n<p>Written by {frontmatter.author}</p>\n<slot />\n\nRefactor as much as you think is useful to you, and add as much to your layout as you want, remembering that everything that you add to your layout is one less thing you will write in each and every blog post!\n\nHere is an example of a refactored layout that leaves only individual blog post content rendered by the slot. Feel free to use this, or create your own!\n\nsrc/layouts/MarkdownPostLayout.astro\n---\nconst { frontmatter } = Astro.props;\n---\n<h1>{frontmatter.title}</h1>\n<p>{frontmatter.pubDate.slice(0,10)}</p>\n<p><em>{frontmatter.description}</em></p>\n<p>Written by: {frontmatter.author}</p>\n<img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n<slot />\n\n AVOID DUPLICATION\n\nAnything rendered by your layout does not need to be typed into your blog post! If you notice any duplication when you check your browser preview, then be sure to remove content from your Markdown file.\n\nTest your knowledge\nSection titled Test your knowledge\n\nCan you figure out what should go in the blanks so that the following two components together produce working Astro code?\n\nsrc/pages/posts/learning-astro.md\n---\nlayout: ../../__________/MyMarkdownLayout.astro\ntitle: \"Learning About Markdown in Astro\"\nauthor: Astro Learner\n____: 2022-08-08\n---\nI learned so much today! Astro allows me to write in Markdown, but also use variables from the frontmatter. I can even access those values in an Astro layout component.\nsrc/layouts/MyMarkdownLayout.astro\n---\nimport ____________ from '../components/Footer.astro'\nconst { ___________ } = Astro.props\n---\n<h1>{frontmatter.title}</h1>\n<p>Written by: {frontmatter.______} on {frontmatter.pubDate}</p>\n< _______ />\n<Footer />\nShow the blanks filled in!\nChecklist\nSection titled Checklist\n I can add a layout property to a Markdown blog post in its YAML frontmatter.\n I can create a separate layout for Markdown posts.\n I can use values from a blog post‚Äôs frontmatter in a layout component.\nResources\nSection titled Resources\n\nMarkdown Layouts in Astro\n\nMarkdown Layout Props\n\nIntroduction to YAML EXTERNAL\n\nNext Page\nCombine layouts to get the best of both worlds"
  },
  {
    "title": "Build your first layout üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/4-layouts/1/",
    "html": "4 ‚Ä¢ Save time and energy with reusable page layouts\n\nBuild your first layout\n\nGET READY TO‚Ä¶\n\nRefactor common elements into a page layout\nUse an Astro <slot /> element to place page contents within a layout\nPass page-specific values as props to its layout\n\nYou still have some Astro components repeatedly rendered on every page. It‚Äôs time to refactor again to create a shared page layout!\n\nCreate your first layout component\nSection titled Create your first layout component\n\nCreate a new file at the location src/layouts/BaseLayout.astro. (You will need to create a new layouts folder first.)\n\nCopy the entire contents of index.astro into your new file, BaseLayout.astro.\n\nsrc/layouts/BaseLayout.astro\n---\nimport Header from '../components/Header.astro';\nimport Footer from '../components/Footer.astro';\nimport '../styles/global.css';\nconst pageTitle = \"Home Page\";\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>{pageTitle}</title>\n  </head>\n  <body>\n    <Header />\n    <h1>{pageTitle}</h1>\n    <Footer />\n    <script>\n      import \"../scripts/menu.js\";\n    </script>\n  </body>\n</html>\nUse your layout on a page\nSection titled Use your layout on a page\n\nReplace the code at src/pages/index.astro with the following:\n\nsrc/pages/index.astro\n---\nimport BaseLayout from '../layouts/BaseLayout.astro';\nconst pageTitle = \"Home Page\";\n---\n<BaseLayout>\n  <h2>My awesome blog subtitle</h2>\n</BaseLayout>\n\nCheck the browser preview again to notice what did (or, spoiler alert: did not!) change.\n\nAdd a <slot /> element to src/layouts/BaseLayout.astro just above the footer component, then check the browser preview of your Home page and notice what really did change this time!\n\nsrc/layouts/BaseLayout.astro\n---\nimport Header from '../components/Header.astro';\nimport Footer from '../components/Footer.astro';\nimport '../styles/global.css';\nconst pageTitle = \"Home Page\";\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>{pageTitle}</title>\n  </head>\n  <body>\n    <Header />\n    <h1>{pageTitle}</h1>\n    <slot />\n    <Footer />\n    <script>\n      import \"../scripts/menu.js\";\n    </script>\n  </body>\n</html>\n\nThe <slot /> allows you to inject (or ‚Äúslot in‚Äù) child content written between opening and closing <Component></Component> tags to any Component.astro file.\n\nPass page-specific values as props\nSection titled Pass page-specific values as props\n\nPass the page title to your layout component from index.astro using a component attribute:\n\nsrc/pages/index.astro\n---\nimport BaseLayout from '../layouts/BaseLayout.astro';\nconst pageTitle = \"Home Page\";\n---\n<BaseLayout pageTitle={pageTitle}>\n  <h2>My awesome blog subtitle</h2>\n</BaseLayout>\n\nChange the script of your BaseLayout.astro layout component to receive a page title via Astro.props instead of defining it as a constant.\n\nsrc/layouts/BaseLayout.astro\n---\nimport Header from '../components/Header.astro';\nimport Footer from '../components/Footer.astro';\nimport '../styles/global.css';\nconst pageTitle = \"Home Page\";\nconst { pageTitle } = Astro.props;\n---\n\nCheck your browser preview to verify that your page title has not changed. It has the same value, but is now being rendered dynamically. And now, each individual page can specify its own title to the layout.\n\nTry it yourself - Use your layout everywhere\nSection titled Try it yourself - Use your layout everywhere\n\nRefactor your other pages (blog.astro and about.astro) so that they use your new <BaseLayout> component to render the common page elements.\n\nDon‚Äôt forget to:\n\nPass a page title as props via a component attribute.\n\nLet the layout be responsible for the HTML rendering of any common elements.\n\nDelete anything from each page that that page is no longer responsible for rendering, because it is being handled by the layout, including:\n\nHTML elements\nComponents and their imports\nCSS rules in a <style> tag (e.g. <h1> in your About page)\n<script> tags\nTest your knowledge\nSection titled Test your knowledge\n\nAn Astro component (.astro file) can function as a:\n\npage\nUI component\nlayout\nall of the above, because Astro components are so functional! üèóÔ∏è\nSubmit\n\nTo display a page title on the page, you can:\n\nuse a standard HTML element on the page with static text (e.g <h1>Home Page</h1>)\n\nuse a standard HTML element on the page referring to a variable defined in your component‚Äôs frontmatter script (e.g. <h1>{pageTitle}</h1>)\n\nuse a layout component on the page, passing the title as a component attribute (e.g. <BaseLayout title=\"Home Page\" /> or <BaseLayout title={pageTitle} />)\n\nall of the above, because Astro lets you use plain HTML or supercharge it with some script and components! üí™\n\nSubmit\n\nInformation can be passed from one component to another by:\n\nimporting a UI component and rendering it in the template of another component\n\npassing props to a component where it is rendered via a component attribute\n\nsending HTML content to be rendered inside another component using a <slot /> placeholder\n\nall of the above, because Astro was built to take advantage of component-based design! üß©\n\nSubmit\nChecklist\nSection titled Checklist\n I can create an Astro layout component with a <slot />.\n I can send page-specific properties to a layout.\nResources\nSection titled Resources\n\nAstro layout components\n\nAstro <slot />\n\nNext Page\nCreate and pass data to a custom blog layout"
  },
  {
    "title": "Check in: Unit 4 - Layouts üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/4-layouts/",
    "html": "4 ‚Ä¢ Save time and energy with reusable page layouts\n\nCheck in: Unit 4 ‚Å†-‚Å† Layouts\n\nNow that you can build with components, it‚Äôs time to create some custom layouts!\n\nLooking ahead\nSection titled Looking ahead\n\nIn this unit, you‚Äôll build layouts to share common elements and styles across your pages and blog posts.\n\nTo do this, you will:\n\nCreate reusable layout components\nPass content to your layouts with <slot />\nPass data from Markdown frontmatter to your layouts\nNest multiple layouts\nChecklist\nSection titled Checklist\n I am ready to take my page design to the next level with layouts!\nNext Page\nBuild your first layout"
  },
  {
    "title": "Send your first script to the browser üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/3-components/4/",
    "html": "3 ‚Ä¢ Build and design with Astro UI components\n\nSend your first script to the browser\n\nLet‚Äôs add a hamburger menu to open and close your links on mobile screen sizes, requiring some client-side interactivity!\n\nGET READY TO‚Ä¶\n\nCreate a hamburger menu component\nWrite a <script> to allow your site visitors to open and close the navigation menu\nMove your JavaScript to its .js file\nBuild a Hamburger component\nSection titled Build a Hamburger component\n\nCreate a <Hamburger /> component to open and close your mobile menu.\n\nCreate a file named Hamburger.astro in src/components/\n\nCopy the following code into your component. This will represent your 3-line ‚Äúhamburger‚Äù menu to open and close your navigation links on mobile. (You will add the new CSS styles to global.css later.)\n\nsrc/components/Hamburger.astro\n---\n---\n<div class=\"hamburger\">\n  <span class=\"line\"></span>\n  <span class=\"line\"></span>\n  <span class=\"line\"></span>\n</div>\n\nPlace this new <Hamburger /> component just before your <Navigation /> component in Header.astro.\n\nShow me the code!\n\nAdd the following styles for your Hamburger component:\n\nsrc/styles/global.css\n/* nav styles */\n.hamburger {\n  padding-right: 20px;\n  cursor: pointer;\n}\n\n\n.hamburger .line {\n  display: block;\n  width: 40px;\n  height: 5px;\n  margin-bottom: 10px;\n  background-color: #ff9776;\n}\n\n\n.nav-links {\n  width: 100%;\n  top: 5rem;\n  left: 48px;\n  background-color: #ff9776;\n  display: none;\n  margin: 0;\n}\n\n\n.nav-links a {\n  display: block;\n  text-align: center;\n  padding: 10px 0;\n  text-decoration: none;\n  font-size: 1.2rem;\n  font-weight: bold;\n  text-transform: uppercase;\n}\n\n\n.nav-links a:hover, a:focus {\n  background-color: #ff9776;\n}\n\n\n.expanded {\n  display: unset;\n}\n\n\n@media screen and (min-width: 636px) {\n  .nav-links {\n    margin-left: 5em;\n    display: block;\n    position: static;\n    width: auto;\n    background: none;\n  }\n\n\n  .nav-links a {\n    display: inline-block;\n    padding: 15px 20px;\n  }\n\n\n  .hamburger {\n    display: none;\n  }\n}\nWrite your first script tag\nSection titled Write your first script tag\n\nYour header is not yet interactive because it can‚Äôt respond to user input, like clicking on the hamburger menu to show or hide the navigation links.\n\nAdding a <script> tag provides client-side JavaScript to ‚Äúlisten‚Äù for a user event and then respond accordingly.\n\nAdd the following <script> tag to index.astro, just before the closing </body> tag.\n\nsrc/pages/index.astro\n  <Footer />\n  <script>\n    document.querySelector('.hamburger').addEventListener('click', () => {\n      document.querySelector('.nav-links').classList.toggle('expanded');\n    });\n  </script>\n</body>\n\nCheck your browser preview again at various sizes, and verify that you have a working navigation menu that is both responsive to screen size and responds to user input on this page.\n\nImporting a .js file\nSection titled Importing a .js file\n\nInstead of writing your JavaScript directly on each page, you can move the contents of your <script> tag into its own .js file in your project.\n\nCreate src/scripts/menu.js (you will have to create a new /scripts/ folder) and move your JavaScript into it.\n\nsrc/scripts/menu.js\ndocument.querySelector('.hamburger').addEventListener('click', () => {\n  document.querySelector('.nav-links').classList.toggle('expanded');\n});\n\nReplace the contents of the <script> tag on index.astro with the following file import:\n\nsrc/pages/index.astro\n  <Footer />\n  <script>\n    document.querySelector('.hamburger').addEventListener('click', () => {\n      document.querySelector('.nav-links').classList.toggle('expanded');\n    });\n\n\n    import \"../scripts/menu.js\";\n  </script>\n</body>\n\nCheck your browser preview again at a smaller size and verify that the hamburger menu still opens and closes your navigation links.\n\nAdd the same <script> with import to your other two pages, about.astro and blog.astro and verify that you have a responsive, interactive header on each page.\n\nsrc/pages/about.astro & src/pages/blog.astro\n  <Footer />\n  <script>\n    import \"../scripts/menu.js\";\n  </script>\n</body>\n\n TAKEAWAY\n\nYou had previously used some JavaScript to build parts of your site:\n\nDefining your page title and heading dynamically\nMapping through a list of skills on the About page\nConditionally displaying HTML elements\n\nThose commands are all executed at build time to create static HTML for your site, and then the code is ‚Äúthrown away.‚Äù\n\nThe JavaScript in a <script> tag is sent to the browser, and is available to run, based on user interactions like refreshing a page or toggling an input.\n\nTest your knowledge\nSection titled Test your knowledge\n\nWhen does Astro run any JavaScript written in a component‚Äôs frontmatter?\n\nAstro never runs JavaScript\n\nat build-time\n\nWhen a visitor clicks a button\n\nSubmit\n\nOptionally, Astro can send JavaScript to the browser to allow:\n\nusers to click page links\n\nfaster load times\n\nclient-side interactivity\n\nSubmit\n\nThe client-side JavaScript will be sent to a user‚Äôs browser when it is written or imported:\n\nin <script> tags\n\nbetween a .astro file‚Äôs code fences\n\nin global.css\n\nSubmit\nChecklist\nSection titled Checklist\n I can add client-side interactivity with JavaScript in a <script> tag.\n I can import a .js file into a <script> tag.\nResources\nSection titled Resources\n\nClient-side scripts in Astro\n\nNext Page\nCheck in: Unit 4 - Layouts"
  },
  {
    "title": "Build it yourself - Header üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/3-components/3/",
    "html": "3 ‚Ä¢ Build and design with Astro UI components\n\nBuild it yourself ‚Å†-‚Å† Header\n\nSince your site will be viewed on different devices, it‚Äôs time to create a page navigation that can respond to multiple screen sizes!\n\nGET READY TO‚Ä¶\n\nCreate a Header for your site that contains the Navigation component\nMake the Navigation component responsive\nTry it yourself - Build a new Header component\nSection titled Try it yourself - Build a new Header component\n\nCreate a new Header component. Import and use your existing Navigation.astro component inside a <nav> element which is inside a <header> element.\n\nShow me the code!\nTry it yourself - Update your pages\nSection titled Try it yourself - Update your pages\n\nOn each page, replace your existing <Navigation/> component with your new header.\n\nShow me the code!\n\nCheck your browser preview and verify that your header is displayed on every page. It won‚Äôt look different yet, but if you inspect your preview using dev tools, you will see that you now have elements like <header> and <nav> around your navigation links.\n\nAdd responsive styles\nSection titled Add responsive styles\n\nUpdate Navigation.astro with the CSS class to control your navigation links. Wrap the existing navigation links in a <div> with the class nav-links.\n\nsrc/components/Navigation.astro\n---\n---\n<div class=\"nav-links\">\n  <a href=\"/\">Home</a>\n  <a href=\"/about\">About</a>\n  <a href=\"/blog\">Blog</a>\n</div>\n\nCopy the CSS styles below into global.css. These styles:\n\nStyle and position the navigation links for mobile\nInclude an expanded class that can be toggled to display or hide the links on mobile\nUse a @media query to define different styles for larger screen sizes\n\n MOBILE-FIRST DESIGN\n\nStart by defining what should happen on small screen sizes first! Smaller screen sizes require simpler layouts. Then, adjust your styles to accommodate larger devices. If you design the complicated case first, then you have to work to try to make it simple again.\n\nsrc/styles/global.css\nhtml {\n  background-color: #f1f5f9;\n  font-family: sans-serif;\n}\n\n\nbody {\n  margin: 0 auto;\n  width: 100%;\n  max-width: 80ch;\n  padding: 1rem;\n  line-height: 1.5;\n}\n\n\n* {\n  box-sizing: border-box;\n}\n\n\nh1 {\n  margin: 1rem 0;\n  font-size: 2.5rem;\n}\n\n\n/* nav styles */\n\n\n.nav-links {\n  width: 100%;\n  top: 5rem;\n  left: 48px;\n  background-color: #ff9776;\n  display: none;\n  margin: 0;\n}\n\n\n.nav-links a {\n  display: block;\n  text-align: center;\n  padding: 10px 0;\n  text-decoration: none;\n  font-size: 1.2rem;\n  font-weight: bold;\n  text-transform: uppercase;\n}\n\n\n.nav-links a:hover,\n.nav-links a:focus {\n  background-color: #ff9776;\n}\n\n\n.expanded {\n  display: unset;\n}\n\n\n@media screen and (min-width: 636px) {\n  .nav-links {\n    margin-left: 5em;\n    display: block;\n    position: static;\n    width: auto;\n    background: none;\n  }\n\n\n  .nav-links a {\n    display: inline-block;\n    padding: 15px 20px;\n  }\n\n\n}\n\nResize your window and look for different styles being applied at different screen widths. Your header is now responsive to screen size through the use of @media queries.\n\nChecklist\nSection titled Checklist\n I can use CSS to add responsive elements to my site.\nResources\nSection titled Resources\n\nComponent-based Design EXTERNAL\n\nSemantic HTML Tags EXTERNAL\n\nMobile-first Design EXTERNAL\n\nNext Page\nSend your first script to the browser"
  },
  {
    "title": "Make a reusable Navigation component üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/3-components/1/",
    "html": "3 ‚Ä¢ Build and design with Astro UI components\n\nMake a reusable Navigation component\n\nNow that you have the same HTML written in multiple pages of your Astro site, it‚Äôs time to replace that duplicated content with a reusable Astro component!\n\nGET READY TO‚Ä¶\n\nCreate a new folder for components\nBuild an Astro component to display your navigation links\nReplace existing HTML with a new, reusable navigation component\nCreate a new src/components/ folder\nSection titled Create a new src/components/ folder\n\nTo hold .astro files that will generate HTML but that will not become new pages on your website, you will need a new folder in your project:src/components/.\n\nCreate a Navigation component\nSection titled Create a Navigation component\n\nCreate a new file: src/components/Navigation.astro.\n\nCopy your links to navigate between pages from the top of any page and paste them into your new file, Navigation.astro:\n\nsrc/components/Navigation.astro\n---\n---\n<a href=\"/\">Home</a>\n<a href=\"/about/\">About</a>\n<a href=\"/blog/\">Blog</a>\n\n TIP\n\nIf there is nothing in the frontmatter of your .astro file, you don‚Äôt have to write the code fences. You can always add them back in when you need them.\n\nImport and use Navigation.astro\nSection titled Import and use Navigation.astro\n\nGo back to index.astro and import your new component inside the code fence:\n\nsrc/pages/index.astro\n---\nimport Navigation from '../components/Navigation.astro';\n---\n\nThen below, replace the existing navigation HTML link elements with the new navigation component you just imported:\n\nsrc/pages/index.astro\n<a href=\"/\">Home</a>\n<a href=\"/about/\">About</a>\n<a href=\"/blog/\">Blog</a>\n<Navigation />\n\nCheck the preview in your browser and notice that it should look exactly the same‚Ä¶ and that‚Äôs what you want!\n\nYour site contains the same HTML as it did before. But now, those three lines of code are provided by your <Navigation /> component.\n\nTry it yourself - Add navigation to the rest of your site\nSection titled Try it yourself - Add navigation to the rest of your site\n\nImport and use the <Navigation /> component in the other two pages on your site (about.astro and blog.astro) using the same method.\n\nDon‚Äôt forget to\n\nAdd an import statement at the top of the component script, inside the code fence.\nReplace the existing code with the navigation component.\n\n NOTE\n\nWhen you restructure your code but do not change the way your page looks in the browser, you are refactoring. You will refactor several times in this unit as you replace parts of your page HTML with components.\n\nThis allows you to get started quickly with any working code, often duplicated throughout your project. Then, you can improve your existing code‚Äôs design incrementally without changing the outward appearance of your site.\n\nTest your knowledge\nSection titled Test your knowledge\n\nYou can do this when you have elements repeated on multiple pages:\n\nrestart the dev server\n\nrefactor to use a reusable component\n\nmake a new page\n\nSubmit\n\nAstro components are:\n\nreusable\n\nfragments of HTML\n\nboth of the above!\n\nSubmit\n\nAstro components will automatically create a new page on your site when you‚Ä¶\n\ninclude <html></html>\n\nrefactor\n\nput the .astro file within src/pages/\n\nSubmit\nChecklist\nSection titled Checklist\n I can refactor content into reusable components.\n I can add a new component to an .astro page.\nResources\nSection titled Resources\n\nAstro Component Overview\n\nRefactoring EXTERNAL\n\nNext Page\nCreate a social media footer"
  },
  {
    "title": "Create a social media footer üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/3-components/2/",
    "html": "3 ‚Ä¢ Build and design with Astro UI components\n\nCreate a social media footer\n\nGET READY TO‚Ä¶\n\nCreate a Footer component\nCreate and pass props to a Social Media component\n\nNow that you have used Astro components on a page, it‚Äôs time to use a component within another component!\n\nCreate a Footer Component\nSection titled Create a Footer Component\n\nCreate a new file at the location src/components/Footer.astro.\n\nCopy the following code into your new file, Footer.astro.\n\nsrc/components/Footer.astro\n---\nconst platform = \"github\";\nconst username = \"withastro\";\n---\n\n\n<footer>\n  <p>Learn more about my projects on <a href={`https://www.${platform}.com/${username}`}>{platform}</a>!</p>\n</footer>\nImport and use Footer.astro\nSection titled Import and use Footer.astro\n\nAdd the following import statement to the frontmatter in each of your three Astro pages (index.astro, about.astro, and blog.astro):\n\nimport Footer from '../components/Footer.astro';\n\nAdd a new <Footer /> component in your Astro template on each page, just before the closing </body> tag to display your footer at the bottom of the page.\n\n    <Footer />\n  </body>\n</html>\n\nIn your browser preview, check that you can see your new footer text on each page.\n\nTry it yourself - Personalize your footer\nSection titled Try it yourself - Personalize your footer\n\nCustomize your footer to display multiple social networks (e.g. Instagram, Twitter, LinkedIn) and include your username to link directly to your own profile.\n\nCode Check-In\nSection titled Code Check-In\n\nIf you‚Äôve been following along with each step in the tutorial, your index.astro file should look like this:\n\nsrc/pages/index.astro\n---\nimport Navigation from '../components/Navigation.astro';\nimport Footer from '../components/Footer.astro';\nimport '../styles/global.css';\n\n\nconst pageTitle = 'Home Page';\n---\n\n\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>{pageTitle}</title>\n  </head>\n  <body>\n    <Navigation />\n    <h1>{pageTitle}</h1>\n    <Footer />\n  </body>\n</html>\nCreate a Social Media component\nSection titled Create a Social Media component\n\nSince you might have multiple online accounts you can link to, you can make a single, reusable component and display it multiple times. Each time, you will pass it different properties (props) to use: the online platform and your username there.\n\nCreate a new file at the location src/components/Social.astro.\n\nCopy the following code into your new file, Social.astro.\n\nsrc/components/Social.astro\n---\nconst { platform, username } = Astro.props;\n---\n<a href={`https://www.${platform}.com/${username}`}>{platform}</a>\nImport and use Social.astro in your Footer\nSection titled Import and use Social.astro in your Footer\n\nChange the code in src/components/Footer.astro to import, then use this new component three times, passing different component attributes as props each time:\n\nsrc/components/Footer.astro\n---\nconst platform = \"github\";\nconst username = \"withastro\";\nimport Social from './Social.astro';\n---\n\n\n<footer>\n  <p>Learn more about my projects on <a href={`https://www.${platform}.com/${username}`}>{platform}</a>!</p>\n  <Social platform=\"twitter\" username=\"astrodotbuild\" />\n  <Social platform=\"github\" username=\"withastro\" />\n  <Social platform=\"youtube\" username=\"astrodotbuild\" />\n</footer>\n\nCheck your browser preview, and you should see your new footer displaying links to these three platforms on each page.\n\nStyle your Social Media Component\nSection titled Style your Social Media Component\n\nCustomize the appearance of your links by adding a <style> tag to src/components/Social.astro.\n\nsrc/components/Social.astro\n---\nconst { platform, username } = Astro.props;\n---\n<a href={`https://www.${platform}.com/${username}`}>{platform}</a>\n\n\n<style>\n  a {\n    padding: 0.5rem 1rem;\n    color: white;\n    background-color: #4c1d95;\n    text-decoration: none;\n  }\n</style>\n\nAdd a <style> tag to src/components/Footer.astro to improve the layout of its contents.\n\nsrc/components/Footer.astro\n---\nimport Social from './Social.astro';\n---\n<style>\n  footer {\n    display: flex;\n    gap: 1rem;\n    margin-top: 2rem;\n  }\n</style>\n\n\n<footer>\n  <Social platform=\"twitter\" username=\"astrodotbuild\" />\n  <Social platform=\"github\" username=\"withastro\" />\n  <Social platform=\"youtube\" username=\"astrodotbuild\" />\n</footer>\n\nCheck your browser preview again and confirm that each page shows an updated footer.\n\nTest Yourself\nSection titled Test Yourself\n\nWhat line of code do you need to write in an Astro component‚Äôs frontmatter to receive values of title, author, and date as props?\n\nconst { title, author, date } = Astro.props;\n\nimport BlogPost from '../components/BlogPost.astro'\n\n<BlogPost title=\"My First Post\" author=\"Dan\" date=\"12 Aug 2022\" />\n\nSubmit\n\nHow do you pass values as props to an Astro component?\n\nconst { title, author, date } = Astro.props;\n\nimport BlogPost from '../components/BlogPost.astro'\n\n<BlogPost title=\"My First Post\" author=\"Dan\" date=\"12 Aug 2022\" />\n\nSubmit\nChecklist\nSection titled Checklist\n I can create new .astro components in src/components/\n I can import and use Astro components inside other Astro components.\n I can pass props to an Astro component.\nResources\nSection titled Resources\nComponent Props in Astro\nNext Page\nBuild it yourself - Header"
  },
  {
    "title": "Check in: Unit 3 - Components üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/3-components/",
    "html": "3 ‚Ä¢ Build and design with Astro UI components\n\nCheck in: Unit 3 ‚Å†-‚Å† Components\n\nNow that you have .astro and .md files generating entire pages on your website, it‚Äôs time to make and reuse smaller bits of HTML with Astro components!\n\nLooking ahead\nSection titled Looking ahead\n\nIn this unit, you‚Äôll learn how to create Astro components to reuse code for common elements across your website.\n\nYou‚Äôll build:\n\nA Navigation component that presents a menu of links to your pages\nA Footer component to include at the bottom of each page\nA Social Media component, used in the Footer, that links to profile pages\nAn interactive Hamburger component to toggle the Navigation on mobile\n\nAlong the way, you‚Äôll use CSS and JavaScript to build a responsive design that reacts to screen sizes and user input.\n\nChecklist\nSection titled Checklist\n I am ready to build some Astro components!\nNext Page\nMake a reusable Navigation component"
  },
  {
    "title": "Add site-wide styling üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/2-pages/5/",
    "html": "2 ‚Ä¢ Add, style and link to pages on your site\n\nAdd site‚Å†-‚Å†wide styling\n\nNow that you have a styled About page, it‚Äôs time to add some global styles for the rest of your site!\n\nGET READY TO‚Ä¶\n\nApply styles globally\nAdd a global stylesheet\nSection titled Add a global stylesheet\n\nYou have seen that the Astro <style> tag is scoped by default, meaning that it only affects the elements in its own file.\n\nThere are a few ways to define styles globally in Astro, but in this tutorial, you will create and import a global.css file into each of your pages. This combination of stylesheet and <style> tag gives you the ability to control some styles site-wide, and to apply some specific styles exactly where you want them.\n\nCreate a new file at the location src/styles/global.css (You‚Äôll have to create a styles folder first.)\n\nCopy the following code into your new file, global.css\n\nsrc/styles/global.css\nhtml {\n  background-color: #f1f5f9;\n  font-family: sans-serif;\n}\n\n\nbody {\n  margin: 0 auto;\n  width: 100%;\n  max-width: 80ch;\n  padding: 1rem;\n  line-height: 1.5;\n}\n\n\n* {\n  box-sizing: border-box;\n}\n\n\nh1 {\n  margin: 1rem 0;\n  font-size: 2.5rem;\n}\n\nIn about.astro, add the following import statement to your frontmatter:\n\nsrc/pages/about.astro\n---\nimport '../styles/global.css';\n\n\nconst pageTitle = \"About Me\";\n\n\nconst identity = {\n  firstName: \"Sarah\",\n  country: \"Canada\",\n  occupation: \"Technical Writer\",\n  hobbies: [\"photography\", \"birdwatching\", \"baseball\"],\n};\n\n\nconst skills = [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Astro\", \"Writing Docs\"];\n\n\nconst happy = true;\nconst finished = false;\nconst goal = 3;\n\n\nconst skillColor = \"navy\";\nconst fontWeight = \"bold\";\nconst textCase = \"uppercase\";\n---\n\nCheck the browser preview of your About page, and you should now see new styles applied!\n\nTry it yourself - Import your global stylesheet\nSection titled Try it yourself - Import your global stylesheet\n\nAdd the necessary line of code to each .astro file in your project to apply your global styles to every page of your site.\n\n‚úÖ Show me the code! ‚úÖ\n\nMake any changes or additions you want to the content of your About page by adding HTML elements to the page template, either statically or dynamically. Write any additional JavaScript in your frontmatter script to provide you with values to use in your HTML. When you are happy with this page, commit your changes to GitHub before moving on to the next lesson.\n\nAnalyze the Pattern\nSection titled Analyze the Pattern\n\nYour About page is now styled using both the imported global.css file and a <style> tag.\n\nAre styles from both styling methods being applied?\n\nYes\n\nAre there any conflicting styles, and if so, which are applied?\n\nYes, <h1> has a size of 2.5rem globally, but 4rem locally in the <style> tag. The local 4rem rule is applied on the About page.\n\nDescribe how global.css and <style> work together.\n\nWhen conflicting styles are defined both globally and in a page‚Äôs local <style> tag, the local styles should overwrite any global styles. (But, there can be other factors involved, so always visually inspect your site to make sure your styles are properly applied!)\n\nHow would you choose whether to declare a style in a global.css file or a <style> tag?\n\nIf you want a style to be applied site-wide, you would choose to use a global.css file. However, if you want styles to apply to only the HTML content in a single .astro file, and not affect other elements on your site, you would choose a <style> tag.\n\nChecklist\nSection titled Checklist\n I can add global CSS styles by importing a .css file.\nResources\nSection titled Resources\n\nAstro syntax vs JSX - comparison\n\nAstro <style> tag\n\nCSS variables in Astro\n\nNext Page\nCheck in: Unit 3 - Components"
  },
  {
    "title": "Add dynamic content about you üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/2-pages/3/",
    "html": "2 ‚Ä¢ Add, style and link to pages on your site\n\nAdd dynamic content about you\n\nNow that you have a multi-page website with HTML content, it‚Äôs time to add some dynamic HTML!\n\nGET READY TO‚Ä¶\n\nDefine your page title in frontmatter, and use it in your HTML\nConditionally display HTML elements\nAdd some content about you\n\nAny HTML file is valid Astro language. But, you can do more with Astro than just regular HTML!\n\nDefine and use a variable\nSection titled Define and use a variable\n\nOpen about.astro, which should look like this:\n\nsrc/pages/about.astro\n---\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n    <a href=\"/\">Home</a>\n    <a href=\"/about/\">About</a>\n    <a href=\"/blog/\">Blog</a>\n    <h1>About Me</h1>\n    <h2>... and my new Astro site!</h2>\n\n\n    <p>I am working through Astro's introductory tutorial. This is the second page on my website, and it's the first one I built myself!</p>\n\n\n    <p>This site will update as I complete more of the tutorial, so keep checking back and see how my journey is going!</p>\n  </body>\n</html>\n\nAdd the following line of JavaScript in the frontmatter script, between the code fences:\n\nsrc/pages/about.astro\n---\nconst pageTitle = \"About Me\";\n---\n\nReplace both the static ‚ÄúAstro‚Äù title and ‚ÄúAbout Me‚Äù heading in your HTML with the dynamic variable {pageTitle}.\n\nsrc/pages/about.astro\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n    <title>{pageTitle}</title>\n  </head>\n  <body>\n    <a href=\"/\">Home</a>\n    <a href=\"/about/\">About</a>\n    <a href=\"/blog/\">Blog</a>\n    <h1>About Me</h1>\n    <h1>{pageTitle}</h1>\n    <h2>... and my new Astro site!</h2>\n\n\n    <p>I am working through Astro's introductory tutorial. This is the second page on my website, and it's the first one I built myself!</p>\n\n\n    <p>This site will update as I complete more of the tutorial, so keep checking back and see how my journey is going!</p>\n  </body>\n</html>\n\nRefresh the live preview of your /about page.\n\nYour page text should look the same, and your page title displayed in your browser tab should now read ‚ÄúAbout Me‚Äù instead of ‚ÄúAstro.‚Äù\n\nInstead of typing text directly into HTML tags, you just defined and then used a variable in the two sections of your .astro file, respectively.\n\nUse the same pattern to create a pageTitle value to use in index.astro (‚ÄúHome Page‚Äù) and blog.astro (‚ÄúMy Astro Learning Blog‚Äù). Update the HTML of these pages in both places so that your page title matches the heading displayed on each page.\n\n TAKEAWAY\n\nDefine variables in your Astro script using JavaScript or TypeScript expressions.\nUse these variables in your Astro template inside curly braces { } to tell Astro you‚Äôre using some JavaScript.\nWrite JavaScript expressions in Astro\nSection titled Write JavaScript expressions in Astro\n\nAdd the following JavaScript to your frontmatter, between the code fences:\n\n(You can customize the code for yourself, but this tutorial will use the following example.)\n\nsrc/pages/about.astro\n---\nconst pageTitle = \"About Me\";\n\n\nconst identity = {\n  firstName: \"Sarah\",\n  country: \"Canada\",\n  occupation: \"Technical Writer\",\n  hobbies: [\"photography\", \"birdwatching\", \"baseball\"],\n};\n\n\nconst skills = [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Astro\", \"Writing Docs\"];\n---\n\nThen, add the following code to your HTML template, below your existing content:\n\nsrc/pages/about.astro\n<p>Here are a few facts about me:</p>\n<ul>\n  <li>My name is {identity.firstName}.</li>\n  <li>I live in {identity.country} and I work as a {identity.occupation}.</li>\n  {identity.hobbies.length >= 2 &&\n    <li>Two of my hobbies are: {identity.hobbies[0]} and {identity.hobbies[1]}</li>\n  }\n</ul>\n<p>My skills are:</p>\n<ul>\n  {skills.map((skill) => <li>{skill}</li>)}\n</ul>\n\n TAKEAWAYS\n\nWriting an Astro template is very much like writing HTML, but you can include JavaScript expressions within it.\nThe Astro frontmatter script contains only JavaScript.\nYou can use all modern JavaScript logical operators, expressions and functions in either section of your .astro file. But, curly braces are necessary (only) in the HTML template body.\nTest your knowledge\nSection titled Test your knowledge\n\nA .astro file‚Äôs frontmatter is written in:\n\nHTML\nYAML\nJavaScript\nSubmit\n\nIn addition to HTML, Astro syntax allows you to include:\n\nJavaScript logical operators, expressions and functions\nYAML\nMarkdown\nSubmit\n\nWhen do you need to write your JavaScript inside curly braces?\n\nWhen you‚Äôre not sure whether it‚Äôs correct.\n\nWhen inside the HTML template section of an Astro component.\n\nBetween the code fences in an Astro component.\n\nSubmit\nConditionally render elements\nSection titled Conditionally render elements\n\nYou can also use your script variables to choose whether or not to render individual elements of your HTML <body> content.\n\nAdd the following lines to your frontmatter script to define variables:\n\nsrc/pages/about.astro\n---\nconst pageTitle = \"About Me\";\n\n\nconst identity = {\n  firstName: \"Sarah\",\n  country: \"Canada\",\n  occupation: \"Technical Writer\",\n  hobbies: [\"photography\", \"birdwatching\", \"baseball\"],\n};\n\n\nconst skills = [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Astro\", \"Writing Docs\"];\n\n\nconst happy = true;\nconst finished = false;\nconst goal = 3;\n---\n\nAdd the following lines below your existing paragraphs.\n\nThen, check the live preview in your browser tab to see what is displayed on the page:\n\nsrc/pages/about.astro\n{happy && <p>I am happy to be learning Astro!</p>}\n\n\n{finished && <p>I finished this tutorial!</p>}\n\n\n{goal === 3 ? <p>My goal is to finish in 3 days.</p> : <p>My goal is not 3 days.</p>}\n\nCommit your changes to GitHub before moving on. Do this any time you want to save your work and update your live website.\n\n TIP\n\nAstro‚Äôs templating syntax is similar to JSX syntax. If you‚Äôre ever wondering how to use your script in your HTML, then searching for how it is done in JSX is probably a good starting point!\n\nAnalyze the Pattern\nSection titled Analyze the Pattern\n\nGiven the following .astro script:\n\nsrc/pages/about.astro\n---\nconst operatingSystem = \"Linux\";\nconst quantity = 3;\nconst footwear = \"boots\";\nconst student = false;\n---\n\nFor each Astro template expression, can you predict the HTML (if any!) that will be sent to the browser? Click to reveal if you‚Äôre right!\n\n<p>{operatingSystem}</p>\n\n<p>Linux</p>\n\n{student && <p>I am still in school.</p>}\n\nNothing will display because student evaluates to false.\n\n<p>I have {quantity + 8} pairs of {footwear}</p>\n\n<p>I have 11 pairs of boots</p>\n\n{operatingSystem === \"MacOS\" ? <p>I am using a Mac.</p> : <p>I am not using a Mac.</p>}\n\n<p>I am not using a Mac.</p>\n\nChecklist\nSection titled Checklist\n I can define values in and use values in .astro files.\n I can conditionally render HTML elements.\nResources\nSection titled Resources\nDynamic expressions in Astro\nNext Page\nStyle your About page"
  },
  {
    "title": "Style your About page üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/2-pages/4/",
    "html": "2 ‚Ä¢ Add, style and link to pages on your site\n\nStyle your About page\n\nNow that you have an About page with content about you, it‚Äôs time to style it!\n\nGET READY TO‚Ä¶\n\nStyle items on a single page\nUse CSS variables\nStyle an individual page\nSection titled Style an individual page\n\nUsing Astro‚Äôs own <style></style> tags, you can style items on your page. Adding attributes and directives to these tags gives you even more ways to style.\n\nCopy the following code and paste it into src/pages/about.astro:\n\nsrc/pages/about.astro\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>{pageTitle}</title>\n    <style>\n      h1 {\n        color: purple;\n        font-size: 4rem;\n      }\n    </style>\n  </head>\n\nCheck all three pages in your browser preview.\n\nWhich color is the page title of:\n\nYour Home page? \nblack\nYour About page? \npurple\nYour Blog page? \nblack\n\nThe page with the biggest title text is? \nYour About page\n\n TIP\n\nIf you are unable to determine colors visually, you can use the dev tools in your browser to inspect the <h1> title elements and verify the text color applied.\n\nAdd the class name skill to the generated <li> elements on your About page, so you can style them. Your code should now look like this:\n\nsrc/pages/about.astro\n<p>My skills are:</p>\n<ul>\n  {skills.map((skill) => <li class=\"skill\">{skill}</li>)}\n</ul>\n\nAdd the following code to your existing style tag:\n\nsrc/pages/about.astro\n<style>\n  h1 {\n    color: purple;\n    font-size: 4rem;\n  }\n  .skill {\n    color: green;\n    font-weight: bold;\n  }\n</style>\n\nVisit your About page in your browser again, and verify, through visual inspection or dev tools, that each item in your list of skills is now green and bold.\n\nUse your first CSS variable\nSection titled Use your first CSS variable\n\nThe Astro <style> tag can also reference any variables from your frontmatter script using the define:vars={ {...} } directive. You can define variables within your code fence, then use them as CSS variables in your style tag.\n\nDefine a skillColor variable by adding it to the frontmatter script of src/pages/about.astro like this:\n\nsrc/pages/about.astro\n---\nconst pageTitle = \"About Me\";\n\n\nconst identity = {\n  firstName: \"Sarah\",\n  country: \"Canada\",\n  occupation: \"Technical Writer\",\n  hobbies: [\"photography\", \"birdwatching\", \"baseball\"],\n};\n\n\nconst skills = [\"HTML\", \"CSS\", \"JavaScript\", \"React\", \"Astro\", \"Writing Docs\"];\n\n\nconst happy = true;\nconst finished = false;\nconst goal = 3;\n\n\nconst skillColor = \"navy\";\n---\n\nUpdate your existing <style> tag below to first define, then use this skillColor variable inside double curly braces.\n\nsrc/pages/about.astro\n<style define:vars={{skillColor}}>\n  h1 {\n    color: purple;\n    font-size: 4rem;\n  }\n  .skill {\n    color: green;\n    color: var(--skillColor);\n    font-weight: bold;\n  }\n</style>\n\nCheck your About page in your browser preview. You should see that the skills are now navy blue, as set by the skillColor variable passed to the define:vars directive.\n\nTry it yourself - Define CSS variables\nSection titled Try it yourself - Define CSS variables\n\nUpdate the <style> tag on your About page so that it matches the one below.\n\nsrc/pages/about.astro\n<style define:vars={{skillColor, fontWeight, textCase}}>\n  h1 {\n    color: purple;\n    font-size: 4rem;\n  }\n  .skill {\n    color: var(--skillColor);\n    font-weight: var(--fontWeight);\n    text-transform: var(--textCase);\n  }\n</style>\n\nAdd any missing variable definitions in your frontmatter script so that your new <style> tag successfully applies these styles to your list of skills:\n\nThe text color is navy blue\nThe text is bold\nThe list items are in all-caps (all uppercase letters)\n‚úÖ Show me the code! ‚úÖ\nChecklist\nSection titled Checklist\n I can add CSS styles to an individual page using an Astro <style> tag.\n I can use variables to style elements on the page.\nResources\nSection titled Resources\n\nAstro syntax vs JSX - comparison\n\nAstro <style> tag\n\nCSS variables in Astro\n\nNext Page\nAdd site-wide styling"
  },
  {
    "title": "Write your first Markdown blog post üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/2-pages/2/",
    "html": "2 ‚Ä¢ Add, style and link to pages on your site\n\nWrite your first Markdown blog post\n\nNow that you have built pages using .astro files, it‚Äôs time to make some blog posts using .md files!\n\nGET READY TO‚Ä¶\n\nMake a new folder and create a new post\nWrite some Markdown content\nLink to your blog posts on your Blog page\nCreate your first .md file\nSection titled Create your first .md file\n\nCreate a new directory at src/pages/posts/.\n\nAdd a new (empty) file post-1.md inside your new /posts/ folder.\n\nLook for this page in your browser preview by adding /posts/post-1 to the end of your existing preview URL. (e.g. http://localhost:4321/posts/post-1)\n\nChange the browser preview URL to view /posts/post-2 instead. (This is a page you have not yet created.)\n\nNote the different output when previewing an ‚Äúempty‚Äù page, and one that doesn‚Äôt exist. This will help you troubleshoot in the future.\n\nWrite Markdown content\nSection titled Write Markdown content\n\nCopy or type the following code into post-1.md\n\nsrc/pages/posts/post-1.md\n---\ntitle: 'My First Blog Post'\npubDate: 2022-07-01\ndescription: 'This is the first post of my new Astro blog.'\nauthor: 'Astro Learner'\nimage:\n    url: 'https://docs.astro.build/assets/full-logo-light.png'\n    alt: 'The full Astro logo.'\ntags: [\"astro\", \"blogging\", \"learning in public\"]\n---\n# My First Blog Post\n\n\nPublished on: 2022-07-01\n\n\nWelcome to my _new blog_ about learning Astro! Here, I will share my learning journey as I build a new website.\n\n\n## What I've accomplished\n\n\n1. **Installing Astro**: First, I created a new Astro project and set up my online accounts.\n\n\n2. **Making Pages**: I then learned how to make pages by creating new `.astro` files and placing them in the `src/pages/` folder.\n\n\n3. **Making Blog Posts**: This is my first blog post! I now have Astro pages and Markdown posts!\n\n\n## What's next\n\n\nI will finish the Astro tutorial, and then keep adding more posts. Watch this space for more to come.\n\nCheck your browser preview again at http://localhost:4321/posts/post-1. You should now see content on this page. It may not yet be properly formatted, but don‚Äôt worry, you will update this later in the tutorial!\n\nUse your browser‚Äôs Dev Tools to inspect this page. Notice that although you have not typed any HTML elements, your Markdown has been converted to HTML. You can see elements such as headings, paragraphs, and list items.\n\n NOTE\n\nThe information at the top of the file, inside the code fences, is called frontmatter. This data‚Äîincluding tags and a post image‚Äîis information about your post that Astro can use. It does not appear on the page automatically, but you will access it later in the tutorial to enhance your site.\n\nLink to your posts\nSection titled Link to your posts\n\nLink to your first post with an anchor tag in src/pages/blog.astro:\n\nsrc/pages/blog.astro\n---\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n    <a href=\"/\">Home</a>\n    <a href=\"/about/\">About</a>\n    <a href=\"/blog/\">Blog</a>\n\n\n    <h1>My Astro Learning Blog</h1>\n    <p>This is where I will post about my journey learning Astro.</p>\n    <ul>\n      <li><a href=\"/posts/post-1/\">Post 1</a></li>\n    </ul>\n  </body>\n</html>\n\nNow, add two more files in src/pages/posts/: post-2.md and post-3.md. Here is some sample code you can copy and paste into your files, or, you can create your own!\n\nsrc/pages/posts/post-2.md\n---\ntitle: My Second Blog Post\nauthor: Astro Learner\ndescription: \"After learning some Astro, I couldn't stop!\"\nimage:\n    url: \"https://docs.astro.build/assets/arc.webp\"\n    alt: \"Thumbnail of Astro arcs.\"\npubDate: 2022-07-08\ntags: [\"astro\", \"blogging\", \"learning in public\", \"successes\"]\n---\nAfter a successful first week learning Astro, I decided to try some more. I wrote and imported a small component from memory!\nsrc/pages/posts/post-3.md\n---\ntitle: My Third Blog Post\nauthor: Astro Learner\ndescription: \"I had some challenges, but asking in the community really helped!\"\nimage:\n    url: \"https://docs.astro.build/assets/rays.webp\"\n    alt: \"Thumbnail of Astro rays.\"\npubDate: 2022-07-15\ntags: [\"astro\", \"learning in public\", \"setbacks\", \"community\"]\n---\nIt wasn't always smooth sailing, but I'm enjoying building with Astro. And, the [Discord community](https://astro.build/chat) is really friendly and helpful!\n\nAdd links to these new posts:\n\nsrc/pages/blog.astro\n---\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\"/>\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Astro</title>\n  </head>\n  <body>\n    <a href=\"/\">Home</a>\n    <a href=\"/about/\">About</a>\n    <a href=\"/blog/\">Blog</a>\n\n\n    <h1>My Astro Learning Blog</h1>\n    <p>This is where I will post about my journey learning Astro.</p>\n    <ul>\n      <li><a href=\"/posts/post-1/\">Post 1</a></li>\n      <li><a href=\"/posts/post-2/\">Post 2</a></li>\n      <li><a href=\"/posts/post-3/\">Post 3</a></li>\n    </ul>\n  </body>\n</html>\n\nCheck your browser preview and make sure that:\n\nAll your links for Post 1, Post 2, and Post 3 lead to a working page on your site. (If you find a mistake, check your links on blog.astro or your Markdown file names.)\nTest your knowledge\nSection titled Test your knowledge\nContent in a Markdown (.md) file is converted to:\nHTML\nCSS\nJavaScript\nSubmit\nChecklist\nSection titled Checklist\n I can create a new folder within src/pages/ for my blog posts.\n I can create a new Markdown (.md) blog post file.\n I understand that Markdown is another language that, like Astro, produces HTML in my browser.\nResources\nSection titled Resources\n\nMarkdown Cheat Sheet from The Markdown Guide EXTERNAL\n\nWhat are browser developer tools? MDN EXTERNAL\n\nYAML frontmatter EXTERNAL\n\nNext Page\nAdd dynamic content about you"
  },
  {
    "title": "Create your first Astro page üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/2-pages/1/",
    "html": "2 ‚Ä¢ Add, style and link to pages on your site\n\nCreate your first Astro page\n\nNow that you know that .astro files are responsible for pages on your website, it‚Äôs time to create one!\n\nGET READY TO‚Ä¶\n\nCreate two new pages on your website: About and Blog\nAdd navigation links to your pages\nDeploy an updated version of your website to the web\nCreate a new .astro file\nSection titled Create a new .astro file\n\nIn the files pane of your code editor, navigate to the folder src/pages/ where you will see the existing file index.astro\n\nIn that same folder, create a new file named about.astro.\n\nCopy, or retype the contents of index.astro into your new about.astro file.\n\n TIP\n\nYour editor might show a solid white circle on the tab label for this file. This means that the file is not yet saved. Under the File menu in VS Code, enable ‚ÄúAuto Save‚Äù and you should no longer need to save any files manually.\n\nAdd /about to the end of your website preview‚Äôs URL in the address bar and check that you can see a page load there. (e.g. http://localhost:4321/about)\n\nRight now, your ‚ÄúAbout‚Äù page should look exactly the same as the first page, but we‚Äôre going to change that!\n\nEdit your page\nSection titled Edit your page\n\nEdit the HTML content to make this page about you.\n\nTo change or add more content to your About page, add more HTML element tags containing content. You can copy and paste the HTML code below between the existing <body></body> tags, or create your own.\n\nsrc/pages/about.astro\n<body>\n  <h1>My Astro Site</h1>\n  <h1>About Me</h1>\n  <h2>... and my new Astro site!</h2>\n\n\n  <p>I am working through Astro's introductory tutorial. This is the second page on my website, and it's the first one I built myself!</p>\n\n\n  <p>This site will update as I complete more of the tutorial, so keep checking back and see how my journey is going!</p>\n</body>\n\nNow, visit your /about page in your browser tab again, and you should see your updated content.\n\nAdd navigation links\nSection titled Add navigation links\n\nTo make it easier to preview all your pages, add HTML page navigation links before your <h1> at the top of both of your pages (index.astro and about.astro):\n\nsrc/pages/about.astro\n<a href=\"/\">Home</a>\n<a href=\"/about/\">About</a>\n\n\n<h1>About Me</h1>\n<h2>... and my new Astro site!</h2>\n\nCheck that you can click these links to move back and forth between pages on your site.\n\n NOTE\n\nUnlike many frameworks, Astro uses standard HTML <a> elements to navigate between pages (also called routes), with traditional page refreshes.\n\nTry it yourself - Add a Blog page\nSection titled Try it yourself - Add a Blog page\n\nAdd a third page blog.astro to your site, following the same steps as above.\n\n(Don‚Äôt forget to add a third navigation link to every page.)\n\nShow me the steps.\n\nYou should now have a website with three pages that all link to each other. It‚Äôs time to add some content to the Blog page.\n\nUpdate the page content at blog.astro with:\n\nsrc/pages/blog.astro\n<body>\n  <a href=\"/\">Home</a>\n  <a href=\"/about/\">About</a>\n  <a href=\"/blog/\">Blog</a>\n\n\n  <h1>My Astro Site</h1>\n  <h1>My Astro Learning Blog</h1>\n  <p>This is where I will post about my journey learning Astro.</p>\n</body>\n\nPreview your entire site by visiting all three pages in your browser preview and check that:\n\nEvery page correctly links to all three pages\nYour two new pages each have their own descriptive heading\nYour two new pages each have their own paragraph text\nPublish your changes to the web\nSection titled Publish your changes to the web\n\nIf you‚Äôve followed our setup in Unit 1, you can publish your changes to your live website through Netlify.\n\nWhen you are happy with the way your preview looks, commit your changes to your online repository at GitHub.\n\nIn VS Code, preview the files that have changed since your last commit to GitHub.\n\nGo to the Source Control tab in the left menu. It should have a small ‚Äú3‚Äù displayed.\n\nYou should see index.astro, about.astro, and blog.astro listed as files that have changed.\n\nEnter a commit message (e.g. ‚ÄúAdded two new pages - about and blog‚Äù) in the text box, and press Ctrl + Enter (macOS: Cmd ‚åò + Enter) to commit the change to your current workspace.\n\nClick the button to Sync Changes to GitHub.\n\nAfter waiting a few minutes, visit your Netlify URL to verify that your changes are published live.\n\n COMMIT AND DEPLOY REGULARLY\n\nFollow these steps every time you pause working! Your changes will be updated in your GitHub repository. If you‚Äôve deployed to a Netlify website, it will be rebuilt and republished.\n\nChecklist\nSection titled Checklist\n I can create a new page for my website and link to it from an existing page.\n I can commit my changes back to GitHub and update my live site on Netlify.\nResources\nSection titled Resources\n\nFile-based Routing in Astro\n\nAstro page HTML\n\nNext Page\nWrite your first Markdown blog post"
  },
  {
    "title": "Deploy your site to the web üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/1-setup/5/",
    "html": "1 ‚Ä¢ Create and deploy your first Astro site\n\nDeploy your site to the web\n\nGET READY TO‚Ä¶\n\nAdd your GitHub repository as a new Netlify app\nDeploy your Astro site to the web\n\nHere, you will connect your GitHub repository to Netlify. Netlify will use that project to build and deploy your site live on the web every time you commit a change to your code.\n\n WE‚ÄôLL USE‚Ä¶\n\nThis tutorial will use Netlify, but you are welcome to use your preferred hosting service for deploying your site to the internet.\n\nCreate a new Netlify site\nSection titled Create a new Netlify site\n\nCreate a free account at Netlify if you do not already have one.\n\nMake a note of your username. You will view your dashboard and any sites you create at https://app.netlify.com/teams/username\n\nClick Add new site > Import an existing project.\n\nYou will be asked to connect to a Git provider. Choose GitHub and follow the steps onscreen to authenticate your GitHub account. Then, choose your Astro project‚Äôs GitHub repository from the list provided.\n\nAt the final step, Netlify will show you your app‚Äôs site settings. The defaults should be correct for your Astro project, so you can scroll down and click Deploy site.\n\nCongratulations, you have an Astro website!\n\nChange your project name\nSection titled Change your project name\n\nOn your site‚Äôs overview page in Netlify, you will see your randomly-generated project name, and your website URL of the form https://project-name-123456.netlify.app. You can change your project name to something more memorable, and this will automatically update your URL.\n\nVisit your new website\nSection titled Visit your new website\n\nClick on the URL in your site settings, or type it into a browser window to view your new website.\n\nTest your knowledge\nSection titled Test your knowledge\n\nYou want to update the home page of your existing website. What steps do you take?\n\nI open a terminal, run create astro, and then visit my Netlify URL.\n\nI change a setting in my Netlify app, then fork a new Astro project on StackBlitz.\n\nI make an edit to index.astro. I commit and push my changes to GitHub. Netlify will handle the rest!\n\nSubmit\nChecklist\nSection titled Checklist\n I can view my updated website online.\n I‚Äôm ready to get back to coding!\nResources\nSection titled Resources\n\nA step-by-step guide to deploying on Netlify EXTERNAL\n\nNext Page\nCheck in: Unit 2 - Pages"
  },
  {
    "title": "Check in: Unit 2 - Pages üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/2-pages/",
    "html": "2 ‚Ä¢ Add, style and link to pages on your site\n\nCheck in: Unit 2 ‚Å†-‚Å† Pages\n\nNow that you have a working site on the web, it‚Äôs time to add pages and posts!\n\nLooking ahead\nSection titled Looking ahead\n\nIn this unit, you will:\n\nCreate your first Astro pages with the .astro syntax\nAdd blog posts with Markdown (.md) files\nStyle an individual page with <style>\nApply global styles across pages\n\nAlong the way, you‚Äôll learn how the two sections of a .astro file work together to create a page, and how to use variables and conditional rendering on your pages.\n\nChecklist\nSection titled Checklist\n I am ready to make some new pages for my Astro website!\nNext Page\nCreate your first Astro page"
  },
  {
    "title": "Store your repository online üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/1-setup/4/",
    "html": "1 ‚Ä¢ Create and deploy your first Astro site\n\nStore your repository online\n\nGET READY TO‚Ä¶\n\nPut your project repository online\n\nThis tutorial will use GitHub to store our repository and connect to a web host. You are welcome to use the online git provider of your choice.\n\n NOTE\n\nIf you are already familiar with git and have your own workflow, then create a new GitHub repository for your project using your preferred method. Skip ahead to the next page: ‚ÄúDeploy your Site to the Web‚Äù.\n\nCreate a repository on GitHub\nSection titled Create a repository on GitHub\n\nAlthough there are a few ways to get your local code stored in GitHub, this tutorial will guide you through a method that does not require using git in the command line.\n\nLog in to GitHub.com in a browser and click the + in the upper right of the screen to make a new repository.\n\nChoose a name for your repository. This does not have to be the same name as your project folder.\n\nYou will be presented with options, but you do not need to change any of the defaults. Scroll down and click the button to Create Repository.\n\nYou will be presented with various setup next steps, but you won‚Äôt need to use any of them. Make a note of the URL of your repository. You can now exit this page without doing anything.\n\nCommit your local code to GitHub\nSection titled Commit your local code to GitHub\n\nIn the last section, you made a change to your page‚Äôs content. This means that your project files have changed, and VS Code should show a number on top of the ‚ÄúSource‚Äù menu icon. This source tab is where you will regularly go to update your files on GitHub.\n\nClick the Source Control tab in your VS Code to see a list of files that have changed. If you see a message that you need to install git, follow the instructions provided, then reload VS Code.\n\nClick the ‚Ä¢‚Ä¢‚Ä¢ ‚Äú3 dots‚Äù menu above the commit message and choose Remote > Add Remote.\n\nSelect Add remote from GitHub. If necessary, follow any authentication steps then return to VS Code and repeat this action.\n\nYou should see a list of all your repositories on GitHub. Choose the one you created for this project. If you don‚Äôt see your project, paste in its GitHub URL directly. You may also be asked to give this repository a local name. You can select any name you like.\n\nAt the top of the menu pane, there will be a place to enter a commit message (description of your file changes). Type in initial commit and press the Commit button to commit these changes.\n\nYou may see a message telling you that you have no ‚Äústaged‚Äù commits, and asking you if you want to stage them. Click Always and continue.\n\nLastly, the list of changed files should be replaced with a Publish button. Click this to send your committed changes to GitHub.\n\nSee your project on GitHub\nSection titled See your project on GitHub\n\nTo verify that your project is successfully stored on GitHub, visit GitHub.com and look under your account for a list of your repositories. Choose the new one you created, and verify that it contains your Astro project files.\n\nChecklist\nSection titled Checklist\n I have stored my project on GitHub.\nResources\nSection titled Resources\n\nUsing Git Source control in VS Code EXTERNAL\n\nNext Page\nDeploy your site to the web"
  },
  {
    "title": "Create your first Astro project üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/1-setup/2/",
    "html": "1 ‚Ä¢ Create and deploy your first Astro site\n\nCreate your first Astro project\n\nGET READY TO‚Ä¶\n\nRun the create astro setup wizard to create a new Astro project\nStart the Astro server in development (dev) mode\nView a live preview of your website in your browser\nLaunch the Astro setup wizard\nSection titled Launch the Astro setup wizard\n\nThe preferred way to create a new Astro site is through our create astro setup wizard.\n\nIn the command line of your terminal, run the following command using your preferred package manager:\n\nnpm\npnpm\nYarn\nTerminal window\n# create a new project with npm\nnpm create astro@latest\n\nConfirm y to install create-astro\n\nWhen the prompt asks, ‚ÄúWhere would you like to create your new project?‚Äù type in the name of a folder to create a new directory for your project, e.g. ./tutorial\n\n NOTE\n\nA new Astro project can only be created in a completely empty folder, so choose a name for your folder that does not already exist!\n\nYou will see a short list of starter templates to choose from. Use the arrow keys (up and down) to navigate to the ‚ÄúEmpty‚Äù template, and then press return (enter) to submit your choice.\n\nWhen the prompt asks, ‚ÄúWould you like to install dependencies?‚Äù type y.\n\nWhen the prompt asks you if you plan on writing TypeScript, type n.\n\nWhen the prompt asks, ‚ÄúWould you like to initialize a new git repository?‚Äù type y.\n\nWhen the install wizard is complete, you no longer need this terminal. You can now open VS Code to continue.\n\nOpen your project in VS Code\nSection titled Open your project in VS Code\n\nOpen VS Code. You will be prompted to open a folder. Choose the folder that you created during the setup wizard.\n\nIf this is your first time opening an Astro project, you should see a notification asking if you would like to install recommended extensions. Click to see the recommended extensions, and choose the Astro language support extension. This will provide syntax highlighting and autocompletions for your Astro code.\n\nMake sure the terminal is visible and that you can see the command prompt, such as:\n\nTerminal window\nuser@machine:~/tutorial$\n\n KEYBOARD SHORTCUT\n\nTo toggle the visibility of the terminal, use Ctrl + J (macOS: Cmd ‚åò + J).\n\nYou can now use the terminal built right into this window, instead of your computer‚Äôs Terminal app, for the rest of this tutorial.\n\nRun Astro in dev mode\nSection titled Run Astro in dev mode\n\nIn order to preview your project files as a website while you work, you will need Astro to be running in development (dev) mode.\n\nStart the dev server\nSection titled Start the dev server\n\nRun the command to start the Astro dev server by typing into VS Code‚Äôs terminal:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm run dev\n\nNow you should see confirmation in the terminal that Astro is running in dev mode. üöÄ\n\nView a preview of your website\nSection titled View a preview of your website\n\nYour project files contain all the code necessary to display an Astro website, but the browser is responsible for displaying your code as web pages.\n\nClick on the localhost link in your terminal window to see a live preview of your new Astro website!\n\n(Astro uses http://localhost:4321 by default if port 4321 is available.)\n\nHere‚Äôs what the Astro ‚ÄúEmpty Project‚Äù starter website should look like in the browser preview:\n\n USING THE ASTRO DEV SERVER\n\nWhile the Astro server is running in dev mode, you will NOT be able to run commands in your terminal window. Instead, this pane will give you feedback as you preview your site.\n\nYou can stop the dev server at any time and return to the command prompt by typing Ctrl + C in the terminal.\n\nSometimes the dev server will stop on its own while you are working. If your live preview stops working, go back to the terminal and restart the dev server by typing npm run dev.\n\nChecklist\nSection titled Checklist\n I can create a new Astro project.\n I can start the Astro dev server.\nResources\nSection titled Resources\n\nGetting Started with Visual Studio Code EXTERNAL ‚Äî a video tutorial for installing, setting up and working with VS Code\n\nNext Page\nWrite your first line of Astro"
  },
  {
    "title": "Write your first line of Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/1-setup/3/",
    "html": "1 ‚Ä¢ Create and deploy your first Astro site\n\nWrite your first line of Astro\n\nGET READY TO‚Ä¶\n\nMake your first edit to your new website\nEdit your home page\nSection titled Edit your home page\n\nIn your code editor, navigate in the Explorer file pane to src/pages/index.astro and click on it to open the file‚Äôs contents in an editable tab.\n\nThe contents of your index.astro file should look like this:\n\nsrc/pages/index.astro\n---\n---\n\n\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.ico\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} >\n    <title>Astro</title>\n  </head>\n  <body>\n    <h1>Astro</h1>\n  </body>\n</html>\n\nEdit the content of your page <body>.\n\nType in the editor to change the heading text on your page and save the change.\n\nsrc/pages/index.astro\n<body>\n  <h1>Astro</h1>\n  <h1>My Astro Site</h1>\n</body>\n\nCheck the browser preview and you should see your page content updated to the new text.\n\nCongratulations! You are now an Astro developer!\n\nThe rest of this unit will set you up for success with version control and a published website you can show off.\n\nChecklist\nSection titled Checklist\n I can make changes and see them in the browser.\n I am an Astro developer!\nNext Page\nStore your repository online"
  },
  {
    "title": "Prepare your dev environment üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/1-setup/1/",
    "html": "1 ‚Ä¢ Create and deploy your first Astro site\n\nPrepare your dev environment\n\nGET READY TO‚Ä¶\n\nInstall any tools that you will use to build your Astro website\nGet the dev tools you need\nSection titled Get the dev tools you need\nTerminal\nSection titled Terminal\n\nYou will use a command line (terminal) to create your Astro project and to run key commands to build, develop, and test your site.\n\nYou can access the command line through a local terminal program for your operating system. Common applications include Terminal (MacOS/Linux), Command Prompt (Windows), and Termux (Android). One of these will probably already be on your machine.\n\nNode.js\nSection titled Node.js\n\nFor Astro to run on your system, you will also need to have Node.js installed, version v18.14.1 or later.\n\nTo check to see whether you already have a compatible version installed, run the following command in your terminal:\n\nTerminal window\nnode -v\n\n\n// Example output\nv18.14.1\n\nIf the command returns a version number higher than v18.14.1, you‚Äôre good to go!\n\nIf the command returns an error message like Command 'node' not found, or a version number lower than v18.14.1, then you need to install a compatible Node.js version.\n\nCode Editor\nSection titled Code Editor\n\nAdditionally, you will need to download and install a code editor to write your code.\n\n WE‚ÄôLL USE‚Ä¶\n\nThis tutorial will use VS Code, but you can use any editor for your operating system.\n\nDownload and install VS Code or another code editor of your choice.\nTest your knowledge\nSection titled Test your knowledge\n\nWhich of the following is‚Ä¶\n\nA code editor, for making changes to your files and their content?\n\nweb browser\n\nTerminal\n\nVS Code\n\nSubmit\n\nAn online version control provider for your repository?\n\nGitHub\n\nTerminal\n\nVS Code\n\nSubmit\n\nAn application for running commands?\n\nGitHub\n\nTerminal\n\nweb browser\n\nSubmit\nChecklist for moving on\nSection titled Checklist for moving on\n I can access the command line in a terminal.\n I have Node.js installed.\n I have a code editor like VS Code.\nResources\nSection titled Resources\n\nFreeCodeCamp.org EXTERNAL ‚Äî a free educational site with full courses or quick refreshers in HTML, CSS, JS, and more.\n\nNext Page\nCreate your first Astro project"
  },
  {
    "title": "Check in: Unit 1 - Setup üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/1-setup/",
    "html": "1 ‚Ä¢ Create and deploy your first Astro site\n\nCheck in: Unit 1 ‚Å†-‚Å† Setup\n\nNow that you know what you‚Äôre going to build, it‚Äôs time to set up all the tools you‚Äôll need!\n\nThis unit shows you how to set up your development environment and deploy to Netlify. Skip ahead to Unit 2 if you are already comfortable with your environment and workflow.\n\n USING STACKBLITZ\n\nWant to complete this tutorial in an online code editor instead?\n\nFollow these instructions, then go directly to Unit 2!\nWhere are you going?\nSection titled Where are you going?\n\nIn this unit, you will create a new project that is stored online in GitHub and connected to Netlify.\n\nAs you write code, you will periodically commit your changes to GitHub. Netlify will use the files in your GitHub repository to build your website, and then publish it on the internet at a unique address where anyone can view it.\n\nEvery time you commit a change to GitHub, a notification will be sent to Netlify. Then, Netlify will automatically rebuild and republish your live site to reflect those changes.\n\nChecklist\nSection titled Checklist\n I‚Äôm ready to prepare a development environment for an Astro project!\nNext Page\nPrepare your dev environment"
  },
  {
    "title": "About this Tutorial üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/0-introduction/1/",
    "html": "0 ‚Ä¢ Welcome, world!\n\nAbout this Tutorial\nWhat do I need to know to get started?\nSection titled What do I need to know to get started?\n\nIf you have some basic familiarity with HTML, Markdown, CSS, and a little JavaScript, then you‚Äôre totally good to go! You‚Äôll be able to complete the entire tutorial just by following the instructions. Astro is for everyone! üßë‚ÄçüöÄ üë©‚ÄçüöÄ üë®‚ÄçüöÄ\n\nYou will also need a GitHub (or similar) account for publishing your project to the web.\n\nHow do I use the checklists at the bottom of each page?\nUnit 1 is things I already know how to do. Can I skip it?\nWhat if I need help, or want to learn more about Astro?\nWhere can I leave feedback about this tutorial?\nChecklist for moving on\nSection titled Checklist for moving on\n I‚Äôm ready to build this thing!\nNext Page\nCheck in: Unit 1 - Setup"
  },
  {
    "title": "Migrating from Create React App (CRA) üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/from-create-react-app/",
    "html": "Migrating from Create React App (CRA)\n\nAstro‚Äôs React integration provides support for using React components inside Astro components, including entire React apps like Create React App (CRA)!\n\nsrc/pages/index.astro\n---\n// Import your root App component\nimport App from '../cra-project/App.jsx'\n---\n<!-- Use a client directive to load your app -->\n<App client:load />\n\nMany apps will ‚Äújust work‚Äù as full React apps when you add them directly to your Astro project with the React integration installed. This is a great way to get your project up and running immediately and keep your app functional while you migrate to Astro.\n\nOver time, you can convert your structure piece-by-piece to a combination of .astro and .jsx components. You will probably discover you need fewer React components than you think!\n\nHere are some key concepts and migration strategies to help you get started. Use the rest of our docs and our Discord community to keep going!\n\nKey Similarities between CRA and Astro\nSection titled Key Similarities between CRA and Astro\n\nThe syntax of .astro files is similar to JSX. Writing Astro should feel familiar.\n\nAstro uses file-based routing, and allows specially named pages to create dynamic routes.\n\nAstro is component-based, and your markup structure will be similar before and after your migration.\n\nAstro has official integrations for React, Preact, and Solid so you can use your existing JSX components. Note that in Astro, these files must have a .jsx or .tsx extension.\n\nAstro has support for installing NPM packages, including React libraries. Many of your existing dependencies will work in Astro.\n\nKey Differences between CRA and Astro\nSection titled Key Differences between CRA and Astro\n\nWhen you rebuild your CRA site in Astro, you will notice some important differences:\n\nCRA is a single-page application that uses index.js as your project‚Äôs root. Astro is a multi-page site, and index.astro is your home page.\n\n.astro components are not written as exported functions that return page templating. Instead, you‚Äôll split your code into a ‚Äúcode fence‚Äù for your JavaScript and a body exclusively for the HTML you generate.\n\ncontent-driven: Astro was designed to showcase your content and to allow you to opt-in to interactivity only as needed. An existing CRA app might be built for high client-side interactivity and may require advanced Astro techniques to include items that are more challenging to replicate using .astro components, such as dashboards.\n\nAdd your CRA to Astro\nSection titled Add your CRA to Astro\n\nYour existing app can be rendered directly inside a new Astro project, often with no changes to your app‚Äôs code.\n\nCreate a new Astro project\nSection titled Create a new Astro project\n\nUse the create astro command for your package manager to launch Astro‚Äôs CLI wizard and select a new ‚Äúempty‚Äù Astro project.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm create astro@latest\nAdd integrations and dependencies\nSection titled Add integrations and dependencies\n\nAdd the React integration using the astro add command for your package manager. If your app uses Tailwind or MDX, you can add multiple Astro integrations using the same command:\n\nnpm\npnpm\nYarn\nTerminal window\nnpx astro add react\nnpx astro add react tailwind mdx\n\nIf your CRA requires any dependencies (e.g. NPM packages), then install them individually using the command line or by adding them to your new Astro project‚Äôs package.json manually and then running an install command. Note that many, but not all, React dependencies will work in Astro.\n\nAdd your existing app files\nSection titled Add your existing app files\n\nCopy your existing Create React App (CRA) project source files and folders (e.g. components, hooks, styles, etc.) into a new folder inside src/, keeping its file structure so your app will continue to work. Note that all .js file extensions must be renamed to .jsx or .tsx.\n\nDo not include any configuration files. You will use Astro‚Äôs own astro.config.mjs, package.json, and tsconfig.json.\n\nMove the contents of your app‚Äôs public/ folder (e.g. static assets) into Astro‚Äôs public/ folder.\n\nDirectory\npublic/\nlogo.png\nfavicon.ico\n‚Ä¶\nDirectory\nsrc/\nDirectory\ncra-project/\nApp.jsx\n‚Ä¶\nDirectory\npages/\nindex.astro\nastro.config.mjs\npackage.json\ntsconfig.json\nRender your app\nSection titled Render your app\n\nImport your app‚Äôs root component in the frontmatter section of index.astro, then render the <App /> component in your page template:\n\nsrc/pages/index.astro\n---\nimport App from '../cra-project/App.jsx'\n---\n<App client:load/>\n\n CLIENT DIRECTIVES\n\nYour app needs a client directive for interactivity. Astro will render your React app as static HTML until you opt-in to client-side JavaScript.\n\nUse client:load to ensure your app loads immediately from the server, or client:only=\"react\" to skip server-side rendering and run your app entirely client-side.\n\nSee our guide for configuring Astro for more details and available options.\n\nConvert your CRA to Astro\nSection titled Convert your CRA to Astro\n\nAfter adding your existing app to Astro, you will probably want to convert your app itself to Astro!\n\nYou will replicate a similar component-based design using Astro HTML templating components for your basic structure while importing and including individual React components (which may themselves be entire apps!) for islands of interactivity.\n\nEvery migration will look different and can be done incrementally without disrupting your working app. Convert individual pieces at your own pace so that more and more of your app is powered by Astro components over time.\n\nAs you convert your React app, you will decide which React components you will rewrite as Astro components. Your only restriction is that Astro components can import React components, but React components must only import other React components:\n\nsrc/pages/static-components.astro\n---\nimport MyReactComponent from '../components/MyReactComponent.jsx';\n---\n<html>\n  <body>\n    <h1>Use React components directly in Astro!</h1>\n    <MyReactComponent />\n  </body>\n</html>\n\nInstead of importing Astro components into React components, you can nest React components inside a single Astro component:\n\nsrc/pages/nested-components.astro\n---\nimport MyReactSidebar from '../components/MyReactSidebar.jsx';\nimport MyReactButton from '../components/MyReactButton.jsx';\n---\n<MyReactSidebar>\n  <p>Here is a sidebar with some text and a button.</p>\n  <div slot=\"actions\">\n    <MyReactButton client:idle />\n  </div>\n</MyReactSidebar>\n\nYou may find it helpful to learn about Astro islands and Astro components before restructuring your CRA as an Astro project.\n\nCompare: JSX vs Astro\nSection titled Compare: JSX vs Astro\n\nCompare the following CRA component and a corresponding Astro component:\n\nJSX\nAstro\nStarCount.jsx\nimport React, { useState, useEffect } from 'react';\nimport Header from './Header';\nimport Footer from './Footer';\n\n\nconst Component = () => {\nconst [stars, setStars] = useState(0);\nconst [message, setMessage] = useState('');\n\n\nuseEffect(() => {\n    const fetchData = async () => {\n        const res = await fetch('https://api.github.com/repos/withastro/astro');\n        const json = await res.json();\n\n\n        setStars(json.stargazers_count || 0);\n        setMessage(json.message);\n    };\n\n\n    fetchData();\n}, []);\n\n\nreturn (\n    <>\n        <Header />\n        <p style={{\n            backgroundColor: `#f4f4f4`,\n            padding: `1em 1.5em`,\n            textAlign: `center`,\n            marginBottom: `1em`\n        }}>Astro has {stars} üßë‚ÄçüöÄ</p>\n        <Footer />\n    </>\n)\n};\n\n\nexport default Component;\nConverting JSX files to .astro files\nSection titled Converting JSX files to .astro files\n\nHere are some tips for converting a CRA .js component into a .astro component:\n\nUse the returned JSX of the existing CRA component function as the basis for your HTML template.\n\nChange any CRA or JSX syntax to Astro or to HTML web standards. This includes {children} and className, for example.\n\nMove any necessary JavaScript, including import statements, into a ‚Äúcode fence‚Äù (---). Note: JavaScript to conditionally render content is often written inside the HTML template directly in Astro.\n\nUse Astro.props to access any additional props that were previously passed to your CRA function.\n\nDecide whether any imported components also need to be converted to Astro. You can keep them as React components for now, or forever. But, you may eventually want to convert them to .astro components, especially if they do not need to be interactive!\n\nReplace useEffect() with import statements or Astro.glob() to query your local files. Use fetch() to fetch external data.\n\nMigrating Tests\nSection titled Migrating Tests\n\nAs Astro outputs raw HTML, it is possible to write end-to-end tests using the output of the build step. Any end-to-end tests written previously might work out-of-the-box if you have been able to match the markup of your CRA site. Testing libraries such as Jest and React Testing Library can be imported and used in Astro to test your React components.\n\nSee Astro‚Äôs testing guide for more.\n\nReference: Convert CRA Syntax to Astro\nSection titled Reference: Convert CRA Syntax to Astro\nCRA Imports to Astro\nSection titled CRA Imports to Astro\n\nUpdate any file imports to reference relative file paths exactly. This can be done using import aliases, or by writing out a relative path in full.\n\nNote that .astro and several other file types must be imported with their full file extension.\n\nsrc/pages/authors/Fred.astro\n---\nimport Card from `../../components/Card.astro`\n---\n<Card />\nCRA Children Props to Astro\nSection titled CRA Children Props to Astro\n\nConvert any instances of {children} to an Astro <slot />. Astro does not need to receive {children} as a function prop and will automatically render child content in a <slot />.\n\nsrc/components/MyComponent\n---\n---\nexport default function MyComponent(props) {\n    return (\n      <div>\n        {props.children}\n      </div>\n    );\n}\n\n\n<div>\n  <slot />\n</div>\n\nReact components that pass multiple sets of children can be migrated to an Astro component using named slots.\n\nSee more about specific <slot /> usage in Astro.\n\nCRA Data Fetching to Astro\nSection titled CRA Data Fetching to Astro\n\nFetching data in a Create React App component is similar to Astro, with some slight differences.\n\nYou will need to remove any instances of a side effect hook (useEffect) for either Astro.glob() or getCollection()/getEntryBySlug() to access data from other files in your project source.\n\nTo fetch remote data, use fetch().\n\nThese data requests are made in the frontmatter of the Astro component and use top-level await.\n\nsrc/pages/index.astro\n---\nimport { getCollection } from 'astro:content';\n\n\n// Get all `src/content/blog/` entries\nconst allBlogPosts = await getCollection('blog');\n\n\n// Get all `src/pages/posts/` entries\nconst allPosts = await Astro.glob('../pages/posts/*.md');\n\n\n// Fetch remote data\nconst response = await fetch('https://randomuser.me/api/');\nconst data = await response.json();\nconst randomUser = data.results[0];\n---\n\nSee more about local files imports with Astro.glob(), querying using the Collections API or fetching remote data.\n\nCRA Styling to Astro\nSection titled CRA Styling to Astro\n\nYou may need to replace any CSS-in-JS libraries (e.g. styled-components) with other available CSS options in Astro.\n\nIf necessary, convert any inline style objects (style={{ fontWeight: \"bold\" }}) to inline HTML style attributes (style=\"font-weight:bold;\"). Or, use an Astro <style> tag for scoped CSS styles.\n\nsrc/components/Card.astro\n<div style={{backgroundColor: `#f4f4f4`, padding: `1em`}}>{message}</div>\n<div style=\"background-color: #f4f4f4; padding: 1em;\">{message}</div>\n\nTailwind is supported after installing the Tailwind integration. No changes to your existing Tailwind code are required!\n\nSee more about Styling in Astro.\n\nTroubleshooting\nSection titled Troubleshooting\n\nYour CRA might ‚Äújust work‚Äù in Astro! But, you may likely need to make minor adjustments to duplicate your existing app‚Äôs functionality and/or styles.\n\nIf you cannot find your answers within these docs, please visit the Astro Discord and ask questions in our support forum!\n\n EXPAND THIS STUB!\n\nThis guide is a stub.\nWant to contribute to this guide? Have a blog post, video, or another resource to share about migrating from this technology to Astro? More migration guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress"
  },
  {
    "title": "Invalid entry inside getStaticPath's return value üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/errors/invalid-get-static-paths-entry/#what-went-wrong",
    "html": "Invalid entry inside getStaticPath's return value\n\nInvalidGetStaticPathsEntry: Invalid entry returned by getStaticPaths. Expected an object, got ENTRY_TYPE\n\nWhat went wrong?\nSection titled What went wrong?\n\ngetStaticPaths‚Äôs return value must be an array of objects. In most cases, this error happens because an array of array was returned. Using .flatMap() or a .flat() call may be useful.\n\npages/blog/[id].astro\nexport async function getStaticPaths() {\n  return [ // <-- Array\n    { params: { slug: \"blog\" } }, // <-- Object\n    { params: { slug: \"about\" } }\n  ];\n}\n\nSee Also:\n\ngetStaticPaths()"
  },
  {
    "title": "Legacy v0.x Upgrade Guide üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/upgrade-to/v1/#new-configuration-api",
    "html": "Legacy v0.x Upgrade Guide\n\nThis guide will help you upgrade through breaking changes in pre-v1 versions of Astro.\n\nYou can update your project‚Äôs version of Astro to the latest version using your package manager. If you‚Äôre using Astro integrations, you‚Äôll also want to update those to the latest version.\n\nnpm\npnpm\nYarn\nTerminal window\n# updates the astro dependency:\nnpm upgrade astro\n# or, to update all dependencies:\nnpm upgrade\n\nRead the guide below for major highlights and instructions on how to handle breaking changes.\n\nAstro 1.0\nSection titled Astro 1.0\n\nAstro v1.0 introduces some changes that you should be aware of when migrating from v0.x and v1.0-beta releases. See below for more details.\n\nUpdated: Vite 3\nSection titled Updated: Vite 3\n\nAstro v1.0 has upgraded from Vite 2 to Vite 3. We‚Äôve handled most of the upgrade for you inside of Astro; however, some subtle Vite behaviors may still change between versions. Refer to the official Vite Migration Guide if you run into trouble.\n\nDeprecated: Astro.canonicalURL\nSection titled Deprecated: Astro.canonicalURL\n\nYou can now use the new Astro.url helper to construct your own canonical URL from the current page/request URL.\n\n// Before:\nconst canonicalURL = Astro.canonicalURL;\n// After:\nconst canonicalURL = new URL(Astro.url.pathname, Astro.site);\nChanged: Scoped CSS specificity\nSection titled Changed: Scoped CSS specificity\n\nSpecificity will now be preserved in scoped CSS styles. This change will cause most scoped styles to happen to take precedence over global styles. But, this behavior is no longer explicitly guaranteed.\n\nTechnically, this is accomplished using the :where() pseudo-class instead of using classes directly in Astro‚Äôs CSS output.\n\nLet‚Äôs use the following style block in an Astro component as an example:\n\n<style>\n  div { color: red; } /* 0-0-1 specificity */\n</style>\n\nPreviously, Astro would transform this into the following CSS, which has a specificity of 0-1-1 ‚Äî a higher specificity than the source CSS:\n\ndiv.astro-XXXXXX { color: red; } /* 0-1-1 specificity */\n\nNow, Astro wraps the class selector with :where(), maintaining the authored specificity:\n\ndiv:where(.astro-XXXXXX) { color: red; } /* 0-0-1 specificity */\n\nThe previous specificity increase made it hard to combine scoped styles in Astro with other CSS files or styling libraries (e.g. Tailwind, CSS Modules, Styled Components, Stitches). This change will allow Astro‚Äôs scoped styles to work consistently alongside them while still preserving the exclusive boundaries that prevent styles from applying outside the component.\n\n CAUTION\n\nWhen upgrading, please visually inspect your site output to make sure everything is styled as expected. If not, find your scoped style and increase the selector specificity manually to match the old behavior.\n\nDeprecated: Components and JSX in Markdown\nSection titled Deprecated: Components and JSX in Markdown\n\nAstro no longer supports components or JSX expressions in Markdown pages by default. For long-term support you should migrate to the @astrojs/mdx integration.\n\nTo make migrating easier, a new legacy.astroFlavoredMarkdown flag (removed in v2.0) can be used to re-enable previous Markdown features.\n\nConverting existing .md files to .mdx\nSection titled Converting existing .md files to .mdx\n\nIf you‚Äôre not familiar with MDX, here are some steps you can follow to quickly convert an existing ‚ÄúAstro Flavored Markdown‚Äù file to MDX. As you learn more about MDX, feel free to explore other ways of writing your pages!\n\nInstall the @astrojs/mdx integration.\n\nChange your existing .md file extensions to .mdx\n\nRemove any setup: properties from your frontmatter, and write any import statements below the frontmatter instead.\n\nsrc/pages/posts/my-post.mdx\n---\nlayout: '../../layouts/BaseLayout.astro'\nsetup: |\n  import ReactCounter from '../../components/ReactCounter.jsx'\ntitle: 'Migrating to MDX'\ndate: 2022-07-26\ntags: [\"markdown\", \"mdx\", \"astro\"]\n---\nimport ReactCounter from '../../components/ReactCounter.jsx'\n\n\n# {frontmatter.title}\n\n\nHere is my counter component, working in MDX:\n\n\n<ReactCounter client:load />\n\nUpdate any Astro.glob() statements that currently return .md files so that they will now return your .mdx files.\n\n CAUTION\n\nThe object returned when importing .mdx files (including using Astro.glob) differs from the object returned when importing .md files. However, frontmatter, file, and url work identically.\n\nUpdate any use of the <Content /> component to use the default export when importing MDX:\n\nsrc/pages/index.astro\n---\n// Multiple imports with Astro.glob\nconst mdxPosts = await Astro.glob('./posts/*.mdx');\n---\n\n\n{mdxPosts.map(Post => <Post.default />)}\nsrc/pages/index.astro\n---\n// Import a single page\nimport { default as About } from './about.mdx';\n---\n\n\n<About />\n\n TIP\n\nWhile you are transitioning to MDX, you may wish to enable the legacy.astroFlavoredMarkdown flag (removed in v2.0) and include both .md and .mdx files, so that your site continues to function normally even before all your files have been converted. Here is one way you can do that:\n\n---\nconst mdPosts = await Astro.glob('../pages/posts/*.md');\nconst mdxPosts = await Astro.glob('../pages/posts/*.mdx');\nconst allPosts = [...mdxPosts, ...mdPosts];\n---\n<Markdown /> Component Removed\nSection titled &lt;Markdown /&gt; Component Removed\n\nAstro‚Äôs built-in <Markdown /> component has been moved to a separate package. To continue using this component, you will now need to install @astrojs/markdown-component and update your imports accordingly. For more details, see the @astrojs/markdown README.\n\n TIP\n\nAstro now has support for MDX through our MDX integration. MDX gives you the ability to include both Markdown and imported components in the same file. MDX can be good alternative for the <Markdown /> component due to its large community and stable APIs.\n\nMigrate to v1.0.0-beta\nSection titled Migrate to v1.0.0-beta\n\nOn April 4, 2022 we released the Astro 1.0 Beta! üéâ\n\nIf you are coming from v0.25 or earlier, make sure you have read and followed the v0.26 Migration Guide below, which contained several major breaking changes.\n\nThe v1.0.0-beta.0 release of Astro contained no breaking changes. Below are small changes that were introduced during the beta period.\n\nChanged: RSS Feeds\nSection titled Changed: RSS Feeds\n\nRSS feeds should now be generated using the @astrojs/rss package, as described in our RSS guide.\n\nMigrate to v0.26\nSection titled Migrate to v0.26\nNew Configuration API\nSection titled New Configuration API\n\nOur Configuration API has been redesigned to solve a few glaring points of confusion that had built up over the last year. Most of the configuration options have just been moved or renamed, which will hopefully be a quick update for most users. A few options have been refactored more heavily, and may require a few additional changes:\n\n.buildOptions.site has been replaced with .site (your deployed domain) and a new .base (your deployed subpath) option.\n.markdownOptions has been replaced with .markdown, a mostly similar config object with some small changes to simplify Markdown configuration.\n.sitemap has been moved into the @astrojs/sitemap integration.\n\nIf you run Astro with legacy configuration, you will see a warning with instructions on how to update. See our updated Configuration Reference for more information on upgrading.\n\nRead RFC0019 for more background on these changes.\n\nNew Markdown API\nSection titled New Markdown API\n\nAstro v0.26 releases a brand new Markdown API for your content. This included three major user-facing changes:\n\nYou can now import/import() markdown content directly using an ESM import.\nA new Astro.glob() API, for easier glob imports (especially for Markdown).\nBREAKING CHANGE: Astro.fetchContent() has been removed and replaced by Astro.glob()\nBREAKING CHANGE: Markdown objects have an updated interface.\n// v0.25\nlet allPosts = Astro.fetchContent('./posts/*.md');\n// v0.26+\nlet allPosts = await Astro.glob('./posts/*.md');\n\nWhen migrating, be careful about the new Markdown object interface. Frontmatter, for example, has been moved to the .frontmatter property, so references like post.title should change to post.frontmatter.title.\n\nThis should solve many issues for Markdown users, including some nice performance boosts for larger sites.\n\nRead RFC0017 for more background on these changes.\n\nNew Default Script Behavior\nSection titled New Default Script Behavior\n\n<script> tags in Astro components are now built, bundled and optimized by default. This completes a long-term move to make our Astro component syntax more consistent, matching the default-optimized behavior our <style> tags have today.\n\nThis includes a few changes to be aware of:\n\nBREAKING: <script hoist> is the new default <script> behavior. The hoist attribute has been removed. To use the new default behaviour, make sure there are no other attributes on the <script> tag. For example, remove type=\"module\" if you were using it before.\nNew <script is:inline> directive, to revert a <script> tag to previous default behavior (unbuilt, unbundled, untouched by Astro).\nNew <style is:inline> directive, to leave a style tag inline in the page template (similar to previous <script> behavior).\nNew <style is:global> directive to replace <style global> in a future release.\n// v0.25\n<script hoist type=\"module\">\n// v0.26+\n<script>\n\nSee how to use client-side scripts in Astro for full details.\n\nRead RFC0016 for more background on these changes.\n\nUpdated Astro.request API\nSection titled Updated Astro.request API\n\nAstro.request has been changed from our custom object to a standard Request object. This is part of a project to use more web standard APIs, especially where SSR is concerned.\n\nThis includes a few changes to be aware of:\n\nChange Astro.request to become a Request object.\nMove Astro.request.params to Astro.params.\nMove Astro.request.canonicalURL to Astro.canonicalURL.\n\nRead RFC0018 for more background on these changes.\n\nOther Changes\nSection titled Other Changes\nImprove Astro.slots API to support passing arguments to function-based slots. This allows for more ergonomic utility components that accept a callback function as a child.\nUpdate CLI output formatting, especially around error reporting.\nUpdate @astrojs/compiler, fixing some bugs related to RegExp usage in frontmatter\nMigrate to v0.25\nSection titled Migrate to v0.25\nAstro Integrations\nSection titled Astro Integrations\n\nThe renderers config has been replaced by a new, official integration system! This unlocks some really exciting new features for Astro. You can read our Using Integrations guide for more details on how to use this new system.\n\nIntegrations replace our original renderers concept, and come with a few breaking changes and new defaults for existing users. These changes are covered below.\n\nRemoved: Built-in Framework Support\nSection titled Removed: Built-in Framework Support\n\nPreviously, React, Preact, Svelte, and Vue were all included with Astro by default. Starting in v0.25.0, Astro no longer comes with any built-in renderers. If you did not have a renderers configuration entry already defined for your project, you will now need to install those frameworks yourself.\n\nRead our step-by-step walkthrough to learn how to add a new Astro integration for the framework(s) that you currently use.\n\nDeprecated: Renderers\nSection titled Deprecated: Renderers\n\n NOTE\n\nRead this section if you have custom ‚Äúrenderers‚Äù already defined in your configuration file.\n\nThe new integration system replaces the previous renderers system, including the published @astrojs/renderer-* packages on npm. Going forward, @astrojs/renderer-react becomes @astrojs/react, @astrojs/renderer-vue becomes @astrojs/vue, and so on.\n\nTo migrate: update Astro to v0.25.0 and then run astro dev or astro build with your old configuration file containing the outdated \"renderers\" config. You will immediately see a notice telling you the exact changes you need to make to your astro.config.mjs file, based on your current config. You can also update your packages yourself, using the table below.\n\nFor a deeper walkthrough, read our step-by-step guide to learn how to replace existing renderers with a new Astro framework integration.\n\nTerminal window\n# Install your new integrations and frameworks:\n# (Read the full walkthrough: https://docs.astro.build/en/guides/integrations-guide)\nnpm install @astrojs/lit lit\nnpm install @astrojs/react react react-dom\n// Then, update your `astro.config.mjs` file:\n// (Read the full walkthrough: https://docs.astro.build/en/guides/integrations-guide)\nimport lit from '@astrojs/lit';\nimport react from '@astrojs/react';\n\n\nexport default {\n  renderers: ['@astrojs/renderer-lit', '@astrojs/renderer-react'],\n  integrations: [lit(), react()],\n}\nDeprecated Renderers on npm\tv0.25+ Integrations on npm\n@astrojs/renderer-react\t@astrojs/react\n@astrojs/renderer-preact\t@astrojs/preact\n@astrojs/renderer-solid\t@astrojs/solid-js\n@astrojs/renderer-vue\t@astrojs/vue\n@astrojs/renderer-svelte\t@astrojs/svelte\nHandling Peer Dependencies\nSection titled Handling Peer Dependencies\n\n NOTE\n\nRead this section if: You are on Node v14 or if you use any package manager other than npm.\n\nUnlike the old renderers, integrations no longer mark the frameworks themselves (‚Äúreact‚Äù, ‚Äúsvelte‚Äù, ‚Äúvue‚Äù, etc.) as direct dependencies of the integration. Instead, you should now install your framework packages in addition to your integrations.\n\nTerminal window\n# Example: Install integrations and frameworks together\nnpm install @astrojs/react react react-dom\n\nIf you see a \"Cannot find package 'react'\" (or similar) warning when you start up Astro,¬†that means that you need to install that package into your project. See our note on peer dependencies in the troubleshooting guide for more information.\n\nIf you are using npm & Node v16+, then this may be automatically handled for you by npm, since the latest version of npm (v7+) installs peer dependencies like this for you automatically. In that case, installing a framework like ‚Äúreact‚Äù into your project is an optional but still recommended step.\n\nUpdated: Syntax Highlighting\nSection titled Updated: Syntax Highlighting\n\nWe love to find sensible defaults that ‚Äújust work‚Äù out-of-the-box. As part of this, we decided to make Shiki our new default syntax highlighter. This comes pre-configured with the github-dark theme, providing zero-config highlighting in your code blocks without extraneous CSS classes, stylesheets, or client-side JS.\n\nCheck our new syntax highlighting docs for full details. If you prefer to keep Prism as your syntax highlighter, set the syntaxHighlight option to 'prism' in your project‚Äôs markdown configuration.\n\nThe <Prism /> component has a new home\nSection titled The &lt;Prism /&gt; component has a new home\n\nAs part of our mission to keep Astro core as lean as possible, we‚Äôve moved the built-in Prism component out of astro/components and into the @astrojs/prism package. You can now import this component from @astrojs/prism like so:\n\n---\nimport { Prism } from '@astrojs/prism';\n---\n\nSince the @astrojs/prism package is still bundled with astro core, you won‚Äôt need to install anything new, nor add Prism as an integration! However, note that we do plan to extract @astrojs/prism (and Prism syntax highlighting in general) to a separate, installable package in the future. See the <Prism /> component API reference for more.\n\nCSS Parser Upgrade\nSection titled CSS Parser Upgrade\n\nOur internal CSS parser has been updated, and comes with better support for advanced CSS syntax, like container queries. This should be a mostly invisible change for most users, but hopefully advanced users will enjoy the new CSS feature support.\n\nMigrate to v0.24\nSection titled Migrate to v0.24\n\n NOTE\n\nThe new build strategy is on by default on 0.24. If you run into a problem you can continue using the old build strategy by passing the --legacy-build flag. Please open an issue so that we can resolve problems with the new build strategy.\n\n0.24 introduced a new static build strategy that changes the behavior of a few features. In previous versions of Astro this was available behavior with an opt-in flag: --experimental-static-build.\n\nTo migrate for the transition, be aware of the following changes that will be required to move to this new build engine. You can make these changes to your codebase at any time so that you are ready ahead of schedule.\n\nDeprecated: Astro.resolve()\nSection titled Deprecated: Astro.resolve()\n\nAstro.resolve() allows you to get resolved URLs to assets that you might want to reference in the browser. This was most commonly used inside of <link> and <img> tags to load CSS files and images as needed. Unfortunately, this will no longer work due to Astro now building assets at build time rather than at render time. You‚Äôll want to upgrade your asset references to one of the following future-proof options available going forward:\n\nHow to Resolve CSS Files\nSection titled How to Resolve CSS Files\n\n1. ESM Import (Recommended)\n\nExample: import './style.css'; When to use this: If your CSS file lives inside of the src/ directory, and you want automatic CSS build and optimization features.\n\nUse an ESM import to add some CSS¬†onto the page. Astro detects these CSS imports and then builds, optimizes, and adds the CSS to the page automatically. This is the easiest way to migrate from Astro.resolve() while keeping the automatic building/bundling that Astro provides.\n\n---\n// Example: Astro will include and optimize this CSS for you automatically\nimport './style.css';\n---\n<html><!-- Your page here --></html>\n\nImporting CSS files should work anywhere that ESM imports are supported, including:\n\nJavaScript files\nTypeScript files\nAstro component frontmatter\nnon-Astro components like React, Svelte, and others\n\nWhen a CSS file is imported using this method, any @import statements are also resolved and inlined into the imported CSS file. All url() references are also resolved relative to the source file, and any url() referenced assets will be included in the final build.\n\n2. Absolute URL Path\n\nExample: <link href=\"/style.css\"> When to use this: If your CSS file lives inside of public/, and you prefer to create your HTML link element yourself.\n\nYou can reference any file inside of the public/ directory by absolute URL path in your component template. This is a good option if you want to control the <link> tag¬†on the page yourself. However, this approach also skips the CSS processing, bundling and optimizations that are provided by Astro when you use the import method described above.\n\nWe recommend using the import approach over the absolute URL approach since it provides the best possible CSS performance and features by default.\n\nHow to Resolve JavaScript Files\nSection titled How to Resolve JavaScript Files\n\n1. Absolute URL Path\n\nExample: <script src=\"/some-external-script.js\" /> When to use this: If your JavaScript file lives inside of public/.\n\nYou can reference any file inside of the public/ directory by absolute URL path in your Astro component templates. This is a good default option for external scripts because it lets you control the <script> tag¬†on the page yourself.\n\nNote that this approach skips the JavaScript processing, bundling and optimizations that are provided by Astro when you use the import method described below. However, this may be preferred for any external scripts that have already been published and minified separately from Astro. If your script was downloaded from an external source, then this method is probably preferred.\n\n2. ESM Import via <script hoist>\n\nExample: <script hoist>import './some-external-script.js';</script> When to use this: If your external script lives inside of src/ and it supports the ESM module type.\n\nUse an ESM import inside of a <script hoist> element in your Astro template, and Astro will include the JavaScript file in your final build. Astro detects these JavaScript client-side imports and then builds, optimizes, and adds the JavaScript to the page automatically. This is the easiest way to migrate from Astro.resolve() while keeping the automatic building/bundling that Astro provides.\n\n<script hoist>\n  import './some-external-script.js';\n</script>\n\nNote that Astro will bundle this external script with the rest of your client-side JavaScript, and load it in the type=\"module\" script context. Some older JavaScript files may not be written for the module context, in which case they may need to be updated to use this method.\n\nHow to Resolve Images & Other Assets\nSection titled How to Resolve Images &amp; Other Assets\n\n1. Absolute URL Path (Recommended)\n\nExample: <img src=\"/penguin.png\"> When to use this: If your asset lives inside of public/.\n\nIf you place your images inside of public/ you can safely reference them by absolute URL path directly in your component templates. This is the simplest way to reference an asset that you can use today, and it is recommended for most users who are getting started with Astro.\n\n2. ESM Import\n\nExample: import imgUrl from './penguin.png' When to use this: If your asset lives inside of the src/ directory, and you want automatic optimization features like filename hashing.\n\nThis works inside of any JavaScript or Astro component, and returns a resolved URL to the final image. Once you have the resolved URL, you can use it anywhere inside of the component template.\n\n---\n// Example: Astro will include this image file in your final build\nimport imgUrl from './penguin.png';\n---\n<img src={imgUrl} />\n\nSimilar to how Astro handles CSS, the ESM import allows Astro to perform some simple build optimizations for you automatically. For example, any asset inside of src/ that is imported using an ESM import (ex: import imgUrl from './penguin.png') will have its filename hashed automatically. This can let you cache the file more aggressively on the server, improving user performance. In the future, Astro may add more optimizations like this.\n\nTip: If you dislike static ESM imports, Astro also supports dynamic ESM imports. We only recommend this option if you prefer this syntax: <img src={(await import('./penguin.png')).default} />.\n\nDeprecated: <script> Default Processing\nSection titled Deprecated: &lt;script&gt; Default Processing\n\nPreviously, all <script> elements were read from the final HTML output and processed + bundled automatically. This behavior is no longer the default. Starting in 0.24, you must opt-in to <script> element processing via the hoist attribute. The type=\"module\" is also required for hoisted modules.\n\n<script>\n  // Will be rendered into the HTML exactly as written!\n  // ESM imports will not be resolved relative to the file.\n</script>\n<script type=\"module\" hoist>\n  // Processed! Bundled! ESM imports work, even to npm packages.\n</script>\nMigrate to v0.23\nSection titled Migrate to v0.23\nMissing Sass Error\nSection titled Missing Sass Error\nPreprocessor dependency \"sass\" not found. Did you install it?\n\nIn our quest to reduce npm install size, we‚Äôve moved Sass out to an optional dependency. If you use Sass in your project, you‚Äôll want to make sure that you run npm install sass --save-dev to save it as a dependency.\n\nDeprecated: Unescaped HTML\nSection titled Deprecated: Unescaped HTML\n\nIn Astro v0.23+, unescaped HTML content in expressions is now deprecated. In future releases, content within expressions will have strings escaped to protect against unintended HTML injection.\n\n<h1>{title}</h1> <!-- <h1>Hello <strong>World</strong></h1> -->\n<h1>{title}</h1> <!-- <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->\n\nTo continue injecting unescaped HTML, you can now use set:html.\n\n<h1>{title}</h1>\n<h1 set:html={title} />\n\nTo avoid a wrapper element, set:html can work alongside <Fragment>.\n\n<h1>{title}!</h1>\n<h1><Fragment set:html={title}>!</h1>\n\nYou can also protect against unintended HTML injection with set:text.\n\n<h1 set:text={title} /> <!-- <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->\nMigrate to v0.21\nSection titled Migrate to v0.21\nVite\nSection titled Vite\n\nStarting in v0.21, Astro is built with Vite. As a result, configurations written in snowpack.config.mjs should be moved into astro.config.mjs.\n\n// @ts-check\n\n\n/** @type {import('astro').AstroUserConfig} */\nexport default {\n  renderers: [],\n  vite: {\n    plugins: [],\n  },\n};\n\nTo learn more about configuring Vite, please visit their configuration guide.\n\nVite Plugins\nSection titled Vite Plugins\n\nIn Astro v0.21+, Vite plugins may be configured within astro.config.mjs.\n\nimport { imagetools } from 'vite-imagetools';\n\n\nexport default {\n  vite: {\n    plugins: [imagetools()],\n  },\n};\n\nTo learn more about Vite plugins, please visit their plugin guide.\n\nVite Changes to Renderers\nSection titled Vite Changes to Renderers\n\nIn Astro v0.21+, plugins should now use viteConfig().\n\nrenderer-svelte/index.js\nimport { svelte } from '@sveltejs/vite-plugin-svelte';\n\n\nexport default {\n  name: '@astrojs/renderer-svelte',\n  client: './client.js',\n  server: './server.js',\n  snowpackPlugin: '@snowpack/plugin-svelte',\n  snowpackPluginOptions: { compilerOptions: { hydratable: true } },\n  viteConfig() {\n    return {\n      optimizeDeps: {\n        include: ['@astrojs/renderer-svelte/client.js', 'svelte', 'svelte/internal'],\n        exclude: ['@astrojs/renderer-svelte/server.js'],\n      },\n      plugins: [\n        svelte({\n          emitCss: true,\n          compilerOptions: { hydratable: true },\n        }),\n      ],\n    };\n  },\n}\n\nTo learn more about Vite plugins, please visit their plugin guide.\n\n NOTE\n\nIn prior releases, these were configured with snowpackPlugin or snowpackPluginOptions.\n\nAliasing\nSection titled Aliasing\n\nIn Astro v0.21+, import aliases can be added from tsconfig.json or jsconfig.json.\n\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@/components/*\": [\"src/components/*\"]\n    }\n  }\n}\n\nThese aliases are integrated automatically into VSCode and other editors.\n\nFile Extensions in Imports\nSection titled File Extensions in Imports\n\nIn Astro v0.21+, files need to be referenced by their actual extension, exactly as it is on disk. In this example, Div.tsx would need to be referenced as Div.tsx, not Div.jsx.\n\nimport Div from './Div.jsx' // Astro v0.20\nimport Div from './Div.tsx' // Astro v0.21\n\nThis same change applies to a compile-to-css file like Div.scss:\n\n<link rel=\"stylesheet\" href={Astro.resolve('./Div.css')}>\n<link rel=\"stylesheet\" href={Astro.resolve('./Div.scss')}>\nRemoved: Components in Frontmatter\nSection titled Removed: Components in Frontmatter\n\nPreviously, you could create mini Astro Components inside of the Astro Frontmatter, using JSX syntax instead of Astro‚Äôs component syntax. This was always a bit of a hack, but in the new compiler it became impossible to support. We hope to re-introduce this feature in a future release of Astro using a different, non-JSX API.\n\nTo migrate to v0.21+, please convert all JSX Astro components (that is, any Astro components created inside of another component‚Äôs frontmatter) to standalone components.\n\nStyling Changes\nSection titled Styling Changes\nAutoprefixer\nSection titled Autoprefixer\n\nAutoprefixer is no longer run by default. To enable:\n\nInstall the latest version (npm install autoprefixer)\nCreate a postcss.config.cjs file at the root of your project with:\nmodule.exports = {\n  plugins: {\n    autoprefixer: {},\n  },\n};\nTailwind CSS\nSection titled Tailwind CSS\n\nEnsure you have PostCSS installed. This was optional in previous releases, but is required now:\n\nInstall the latest version of postcss (npm install -D postcss)\nCreate a postcss.config.cjs file at the root of your project with:\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n  },\n};\nFor more information, read the Tailwind CSS documentation\nKnown Issues\nSection titled Known Issues\nImports on top\nSection titled Imports on top\n\nIn Astro v0.21+, a bug has been introduced that requires imports inside components to be at the top of your frontmatter.\n\n---\nimport Component from '../components/Component.astro'\nconst whereShouldIPutMyImports = \"on top!\"\n---"
  },
  {
    "title": "Upgrade to Astro v2 üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/upgrade-to/v2/",
    "html": "Upgrade to Astro v2\n\nThis guide will help you migrate from Astro v1 to Astro v2.\n\nNeed to upgrade an older project to v1? See our older migration guide.\n\nUpgrade Astro\nSection titled Upgrade Astro\n\nUpdate your project‚Äôs version of Astro to the latest version using your package manager. If you‚Äôre using Astro integrations, please also update those to the latest version.\n\nnpm\npnpm\nYarn\nTerminal window\n# Upgrade to Astro v2.x\nnpm install astro@latest\n\n\n# Example: upgrade React and Tailwind integrations\nnpm install @astrojs/react@latest @astrojs/tailwind@latest\nAstro v2.0 Breaking Changes\nSection titled Astro v2.0 Breaking Changes\n\nAstro v2.0 includes some breaking changes, as well as the removal of some previously deprecated features. If your project doesn‚Äôt work as expected after upgrading to v2.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.\n\nSee the changelog for full release notes.\n\nRemoved: Support for Node 14\nSection titled Removed: Support for Node 14\n\nNode 14 is scheduled to reach its End of Life in April 2023.\n\nAstro v2.0 drops Node 14 support entirely, so that all Astro users can take advantage of Node‚Äôs more modern features.\n\nWhat should I do?\nSection titled What should I do?\n\nCheck that both your development environment and your deployment environment are using Node 16.12.0 or later.\n\nCheck your local version of Node using:\n\nTerminal window\nnode -v\n\nIf your local development environment needs upgrading, install Node.\n\nCheck your deployment environment‚Äôs own documentation to verify that they support Node 16.\n\nYou can specify Node 16.12.0 for your Astro project either in a dashboard configuration setting, or a .nvmrc file.\n\nReserved: src/content/\nSection titled Reserved: src/content/\n\nAstro v2.0 now includes the Collections API for organizing your Markdown and MDX files into content collections. This API reserves src/content/ as a special folder.\n\nWhat should I do?\nSection titled What should I do?\n\nRename an existing src/content/ folder to avoid conflicts. This folder, if it exists, can now only be used for content collections.\n\nChanged: Astro.site trailing slash\nSection titled Changed: Astro.site trailing slash\n\nIn v1.x, Astro ensured the URL you set as site in astro.config.mjs always had a trailing slash when accessed using Astro.site.\n\nAstro v2.0 no longer modifies the value of site. Astro.site will use the exact value defined, and a trailing slash must be specified if desired.\n\nWhat should I do?\nSection titled What should I do?\n\nIn astro.config.mjs, add a trailing slash to the URL set in site.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  site: 'https://example.com',\n  site: 'https://example.com/',\n});\nChanged: _astro/ folder for build assets\nSection titled Changed: _astro/ folder for build assets\n\nIn v1.x, assets were built to various locations, including assets/, chunks/, and to the root of the build output.\n\nAstro v2.0 moves and unifies the location of all build output assets to a new _astro/ folder.\n\nDirectory\ndist/\nDirectory\n_astro\nclient.9218e799.js\nindex.df3f880e0.css\n\nYou can control this location with the new build.assets configuration option.\n\nWhat should I do?\nSection titled What should I do?\n\nUpdate your deployment platform configuration if it relies on the location of these assets.\n\nChanged: Markdown plugin configuration\nSection titled Changed: Markdown plugin configuration\nRemoved: extendDefaultPlugins\nSection titled Removed: extendDefaultPlugins\n\nIn v1.x, Astro used markdown.extendDefaultPlugins to re-enable Astro‚Äôs default plugins when adding your own Markdown plugins.\n\nAstro v2.0 removes this configuration option entirely because its behavior is now the default.\n\nApplying remark and rehype plugins in your Markdown configuration no longer disables Astro‚Äôs default plugins. GitHub-Flavored Markdown and Smartypants are now applied whether or not custom remarkPlugins or rehypePlugins are configured.\n\nWhat should I do?\nSection titled What should I do?\n\nRemove extendDefaultPlugins in your configuration. This is now Astro‚Äôs default behavior in v2.0, and you can delete this line without any replacement.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  markdown: {\n    extendDefaultPlugins,\n  }\n});\nAdded: gfm and smartypants\nSection titled Added: gfm and smartypants\n\nIn v1.x, you could choose to disable both of Astro‚Äôs default Markdown plugins (GitHub-Flavored Markdown and SmartyPants) by setting markdown.extendDefaultPlugins: false.\n\nAstro v2.0 replaces markdown.extendDefaultPlugins: false with separate Boolean options to individually control each of Astro‚Äôs built-in default Markdown plugins. These are enabled by default and can be set to false independently.\n\nWhat should I do?\nSection titled What should I do?\n\nRemove extendDefaultPlugins: false and add the flags to disable each plugin individually instead.\n\nmarkdown.gfm: false disables GitHub-Flavored Markdown\nmarkdown.smartypants: false disables SmartyPants\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  markdown: {\n    extendDefaultPlugins: false,\n    smartypants: false,\n    gfm: false,\n  }\n});\nChanged: MDX plugin configuration\nSection titled Changed: MDX plugin configuration\nReplaced: extendPlugins changed to extendMarkdownConfig\nSection titled Replaced: extendPlugins changed to extendMarkdownConfig\n\nIn v1.x, the MDX integration‚Äôs extendPlugins option managed how your MDX files should inherit your Markdown configuration: all your Markdown configuration (markdown), or Astro‚Äôs default plugins only (default).\n\nAstro v2.0 replaces the behavior controlled by mdx.extendPlugins with three new, independently-configurable options that are true by default:\n\nmdx.extendMarkdownConfig to inherit all or none of your Markdown configuration\nmdx.gfm to enable or disable GitHub-Flavored Markdown in MDX\nmdx.smartypants to enable or disable SmartyPants in MDX\nWhat should I do?\nSection titled What should I do?\n\nDelete extendPlugins: 'markdown' in your configuration. This is now the default behavior.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  integrations: [\n    mdx({\n      extendPlugins: 'markdown',\n    }),\n  ],\n});\n\nReplace extendPlugins: 'defaults' with extendMarkdownConfig: false and add the separate options for GitHub-Flavored Markdown and SmartyPants to enable these default plugins individually in MDX.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  integrations: [\n    mdx({\n      extendPlugins: 'defaults',\n      extendMarkdownConfig: false,\n      smartypants: true,\n      gfm: true,\n    }),\n  ],\n});\nAdded: More MDX config options to match Markdown\nSection titled Added: More MDX config options to match Markdown\n\nAstro v2.0 allows you to now individually set every available Markdown configuration option (except drafts) separately in your MDX integration configuration.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [remarkPlugin1],\n    gfm: true,\n  },\n  integrations: [\n    mdx({\n      remarkPlugins: [remarkPlugin2],\n      gfm: false,\n    })\n  ]\n});\nWhat should I do?\nSection titled What should I do?\n\nRevisit your Markdown and MDX configuration and compare your existing config with the new options available.\n\nChanged: Plugin access to frontmatter\nSection titled Changed: Plugin access to frontmatter\n\nIn v1.x, remark and rehype plugins did not have access to user frontmatter. Astro merged plugin frontmatter with your file‚Äôs frontmatter, without passing the file frontmatter to your plugins.\n\nAstro v2.0 gives remark and rehype plugins access to user frontmatter via frontmatter injection. This allows plugin authors to modify a user‚Äôs existing frontmatter, or compute new properties based on other properties.\n\nWhat should I do?\nSection titled What should I do?\n\nCheck any remark and rehype plugins you have written to see whether their behavior has changed. Note that data.astro.frontmatter is now the complete Markdown or MDX document‚Äôs frontmatter, rather than an empty object.\n\nChanged: RSS Configuration\nSection titled Changed: RSS Configuration\n\nIn v1.x, Astro‚Äôs RSS package allowed you to use items: import.meta.glob(...) to generate a list of RSS feed items. This usage is now deprecated and will eventually be removed.\n\nAstro v2.0 introduces a pagesGlobToRssItems() wrapper to the items property.\n\nWhat should I do?\nSection titled What should I do?\n\nImport, then wrap your existing function containing import.meta.glob() with the pagesGlobToRssItems() helper.\n\nsrc/pages/rss.xml.js\nimport rss, {\n  pagesGlobToRssItems\n} from '@astrojs/rss';\n\n\nexport async function get(context) {\n  return rss({\n    items: await pagesGlobToRssItems(\n      import.meta.glob('./blog/*.{md,mdx}'),\n    ),\n  });\n}\nChanged: Svelte IDE support\nSection titled Changed: Svelte IDE support\n\nAstro v2.0 requires a svelte.config.js file in your project if you are using the @astrojs/svelte integration. This is needed to provide IDE autocompletion.\n\nWhat should I do?\nSection titled What should I do?\n\nAdd a svelte.config.js file to the root of your project:\n\nsvelte.config.js\nimport { vitePreprocess } from '@astrojs/svelte';\n\n\nexport default {\n  preprocess: vitePreprocess(),\n};\n\nFor new users, this file will be added automatically when running astro add svelte.\n\nRemoved: legacy.astroFlavoredMarkdown\nSection titled Removed: legacy.astroFlavoredMarkdown\n\nIn v1.0, Astro moved the old Astro-Flavored Markdown (also known as Components in Markdown) to a legacy feature.\n\nAstro v2.0 removes the legacy.astroFlavoredMarkdown option completely. Importing and using components in .md files will no longer work.\n\nWhat should I do?\nSection titled What should I do?\n\nRemove this legacy flag. It is no longer available in Astro.\n\nastro.config.mjs\nexport default defineConfig({\n  legacy: {\n    astroFlavoredMarkdown: true,\n  },\n})\n\nIf you were using this feature in v1.x, we recommend using the MDX integration which allows you to combine components and JSX expressions with Markdown syntax.\n\nRemoved: Astro.resolve()\nSection titled Removed: Astro.resolve()\n\nIn v0.24, Astro deprecated Astro.resolve() for getting resolved URLs to assets that you might want to reference in the browser.\n\nAstro v2.0 removes this option entirely. Astro.resolve() in your code will cause an error.\n\nWhat should I do?\nSection titled What should I do?\n\nResolve asset paths using import instead. For example:\n\nsrc/pages/index.astro\n---\nimport 'style.css';\nimport imageUrl from './image.png';\n---\n\n\n<img src={imageUrl} />\nRemoved: Astro.fetchContent()\nSection titled Removed: Astro.fetchContent()\n\nIn v0.26, Astro deprecated Astro.fetchContent() for fetching data from your local Markdown files.\n\nAstro v2.0 removes this option entirely. Astro.fetchContent() in your code will cause an error.\n\nWhat should I do?\nSection titled What should I do?\n\nUse Astro.glob() to fetch Markdown files, or convert to the Content Collections feature.\n\nsrc/pages/index.astro\n---\nconst allPosts = await Astro.glob('./posts/*.md');\n---\nRemoved: Astro.canonicalURL\nSection titled Removed: Astro.canonicalURL\n\nIn v1.0, Astro deprecated Astro.canonicalURL for constructing a canonical URL.\n\nAstro v2.0 removes this option entirely. Astro.canonicalURL in your code will cause an error.\n\nWhat should I do?\nSection titled What should I do?\n\nUse Astro.url to construct a canonical URL.\n\nsrc/pages/index.astro\n---\nconst canonicalURL = new URL(Astro.url.pathname, Astro.site);\n---\nUpdated: Vite 4\nSection titled Updated: Vite 4\n\nAstro v2.0 upgrades from Vite 3 to Vite 4, released in December 2022.\n\nWhat should I do?\nSection titled What should I do?\n\nThere should be no changes to your code necessary! We‚Äôve handled most of the upgrade for you inside of Astro; however, some subtle Vite behaviors may still change between versions.\n\nRefer to the official Vite Migration Guide if you run into trouble.\n\nAstro v2.0 Experimental Flags Removed\nSection titled Astro v2.0 Experimental Flags Removed\n\nRemove the following experimental flags from astro.config.mjs:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  experimental: {\n    contentCollections: true,\n    prerender: true,\n    errorOverlay: true,\n  },\n})\n\nThese features are now available by default:\n\nContent collections as a way to manage your Markdown and MDX files with type-safety.\nPrerendering individual pages to static HTML when using SSR to improve speed and cacheability.\nA redesigned error message overlay.\nKnown Issues\nSection titled Known Issues\n\nThere are currently no known issues."
  },
  {
    "title": "Contribute to Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/contribute/",
    "html": "Contribute to Astro\n\nWe welcome contributions of any size and contributors of any skill level. As an open-source project, we believe in giving back to our contributors. We are happy to help with guidance on PRs, technical writing, and turning any feature idea into a reality.\n\nWant to get even more involved? See our Governance doc for detailed descriptions of different roles, maintainer nomination processes, code review processes, and Code of Conduct enforcement.\n\nWays to Contribute\nSection titled Ways to Contribute\nProject repositories\nSection titled Project repositories\n\nThere are lots of ways to contribute to the Astro Project! Every Astro repository has a README with a link to a CONTRIBUTING.md file in the root of the project.\n\nVisit Astro‚Äôs GitHub profile to find the repositories for:\n\nThe main Astro codebase, including official integrations and starter templates.\n\nAstro Docs, an entire Astro website! Contribute not just written content, but also Astro code addressing a11y, CSS, UI, and UX concerns. We also make our documentation available in several languages, so we need help translating the entire site.\n\nThe Astro compiler, written in Go, distributed as WASM.\n\nAstro‚Äôs language tools, the editor tooling required for the Astro language (.astro files).\n\nStarlight, Astro‚Äôs official documentation framework.\n\nThe Astro Roadmap where the future of Astro is shaped! Ideas, suggestions, and formal RFC proposals for the Astro project.\n\nTypes of contributions\nSection titled Types of contributions\n\nIn addition to contributing your own code or content, you can also make a huge contribution by getting involved by leaving review comments on PRs, adding ideas in existing GitHub Issues and Discussions, and participating in our ‚ÄúPinned‚Äù issue maintenance tasks!\n\nEvery PR, especially translation PRs, needs reviewers! Reviewing PRs and leaving comments, suggestions, or an approving ‚ÄúLGTM!‚Äù (‚ÄúLooks Good To Me!‚Äù) is a great way to get started in any repository, and to learn more about Astro.\n\nWe also have a very active Discord community! We value the contributions of those who welcome new members, answer support questions, and share what they have built with and for Astro! Beyond traditional GitHub contributions, Astro recognizes and supports community members who engage with our community, share Astro in blog posts, videos and conference talks, and help maintain the health of our community.\n\nContributing to Docs\nSection titled Contributing to Docs\n\nWe have several guides with information on how to get started contributing to Astro Docs!\n\nMain Contributing Guide - Please consult this first!\nWriting Guide - Tips for writing in Astro Docs style.\nTranslating Guide - Information on how to help translate Astro Docs into your language.\nRecipe Guide - Learn about writing and contributing a recipe.\n\nThese are guides for the docs repository for specific roles within the Astro community.\n\nMaintainer Guide - How to maintain this repository as an Astro maintainer.\nSupport Squad Guide - How to help Team Docs as part of your Support role.\nOur contributors\nSection titled Our contributors\n\nThese docs are brought to you by all these helpful people. Join us on GitHub!"
  },
  {
    "title": "Install Astro manually üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/install/manual/",
    "html": "Install Astro manually\n\nThis guide will walk you through the steps to manually install and configure a new Astro project if you prefer not to use the automatic CLI tool.\n\nPrefer a quicker way to get started?\nSection titled Prefer a quicker way to get started?\nTry the create astro CLI wizard ‚Üí\nPrerequisites\nSection titled Prerequisites\nNode.js - v18.14.1 or higher.\nText editor - We recommend VS Code with our Official Astro extension.\nTerminal - Astro is accessed through its command-line interface (CLI).\nInstallation\nSection titled Installation\n\nIf you prefer not to use our automatic create astro CLI tool, you can set up your project yourself by following the guide below.\n\n1. Create your directory\nSection titled 1. Create your directory\n\nCreate an empty directory with the name of your project, and then navigate into it.\n\nTerminal window\nmkdir my-astro-project\ncd my-astro-project\n\nOnce you are in your new directory, create your project package.json file. This is how you will manage your project dependencies, including Astro. If you aren‚Äôt familiar with this file format, run the following command to create one.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm init --yes\n2. Install Astro\nSection titled 2. Install Astro\n\nFirst, install the Astro project dependencies inside your project.\n\n IMPORTANT\n\nAstro must be installed locally, not globally. Make sure you are not running npm install -g astro pnpm add -g astro or yarn add global astro.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install astro\n\nThen, replace any placeholder ‚Äúscripts‚Äù section of your package.json with the following:\n\npackage.json\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"dev\": \"astro dev\",\n    \"start\": \"astro dev\",\n    \"build\": \"astro build\",\n    \"preview\": \"astro preview\"\n  },\n\nYou‚Äôll use these scripts later in the guide to start Astro and run its different commands.\n\n3. Create your first page\nSection titled 3. Create your first page\n\nIn your text editor, create a new file in your directory at src/pages/index.astro. This will be your first Astro page in the project.\n\nFor this guide, copy-and-paste the following code snippet (including --- dashes) into your new file:\n\nsrc/pages/index.astro\n---\n// Welcome to Astro! Everything between these triple-dash code fences\n// is your \"component frontmatter\". It never runs in the browser.\nconsole.log('This runs in your terminal, not the browser!');\n---\n<!-- Below is your \"component template.\" It's just HTML, but with\n     some magic sprinkled in to help you build great templates. -->\n<html>\n  <body>\n    <h1>Hello, World!</h1>\n  </body>\n</html>\n<style>\n  h1 {\n    color: orange;\n  }\n</style>\n4. Create your first static asset\nSection titled 4. Create your first static asset\n\nYou will also want to create a public/ directory to store your static assets. Astro will always include these assets in your final build, so you can safely reference them from inside your component templates.\n\nIn your text editor, create a new file in your directory at public/robots.txt. robots.txt is a simple file that most sites will include to tell search bots like Google how to treat your site.\n\nFor this guide, copy-and-paste the following code snippet into your new file:\n\npublic/robots.txt\n# Example: Allow all bots to scan and index your site.\n# Full syntax: https://developers.google.com/search/docs/advanced/robots/create-robots-txt\nUser-agent: *\nAllow: /\n5. Create astro.config.mjs\nSection titled 5. Create astro.config.mjs\n\nAstro is configured using astro.config.mjs. This file is optional if you do not need to configure Astro, but you may wish to create it now.\n\nCreate astro.config.mjs at the root of your project, and copy the code below into it:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\n// https://astro.build/config\nexport default defineConfig({});\n\nIf you want to include UI framework components such as React, Svelte, etc. or use other tools such as Tailwind or Partytown in your project, here is where you will manually import and configure integrations.\n\nüìö Read Astro‚Äôs API configuration reference for more information.\n\n6. Add TypeScript support\nSection titled 6. Add TypeScript support\n\nTypeScript is configured using tsconfig.json. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file.\n\nIf you do intend to write TypeScript code, using Astro‚Äôs strict or strictest template is recommended. You can view and compare the three template configurations at astro/tsconfigs/.\n\nCreate tsconfig.json at the root of your project, and copy the code below into it. (You can use base, strict or strictest for your TypeScript template):\n\ntsconfig.json\n{\n  \"extends\": \"astro/tsconfigs/base\"\n}\n\nFinally, create src/env.d.ts to let TypeScript know about ambient types available in an Astro project:\n\nsrc/env.d.ts\n/// <reference types=\"astro/client\" />\n\nüìö Read Astro‚Äôs TypeScript setup guide for more information.\n\n7. Next Steps\nSection titled 7. Next Steps\n\nIf you have followed the steps above, your project directory should now look like this:\n\nDirectory\nnode_modules/\nDirectory\npublic/\nrobots.txt\nDirectory\nsrc/\nDirectory\npages/\nindex.astro\nenv.d.ts\nastro.config.mjs\npackage-lock.json\nor yarn.lock, pnpm-lock.yaml, etc.\npackage.json\ntsconfig.json\n\nCongratulations, you‚Äôre now set up to use Astro!\n\nIf you followed this guide completely, you can jump directly to Step 2: Start Astro to continue and learn how to run Astro for the first time."
  },
  {
    "title": "Publish to NPM üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/publish-to-npm/",
    "html": "Publish to NPM\n\nBuilding a new Astro component? Publish it to npm!\n\nPublishing an Astro component is a great way to reuse your existing work across your projects, and to share with the wider Astro community at large. Astro components can be published directly to and installed from NPM, just like any other JavaScript package.\n\nLooking for inspiration? Check out some of our favorite themes and components from the Astro community. You can also search npm to see the entire public catalog.\n\n DON‚ÄôT WANT TO GO IT ALONE?\n\nCheck out Astro Community‚Äôs component template for a community-supported, out-of-the-box template!\n\nQuick Start\nSection titled Quick Start\n\nTo get started developing your component quickly, you can use a template already set up for you.\n\nTerminal window\n# Initialize the Astro Component template in a new directory\nnpm create astro@latest my-new-component-directory -- --template component\n# yarn\nyarn create astro my-new-component-directory --template component\n# pnpm\npnpm create astro@latest my-new-component-directory -- --template component\nCreating a package\nSection titled Creating a package\n\n PREREQUISITES\n\nBefore diving in, it will help to have a basic understanding of:\n\nNode Modules\nPackage Manifest (package.json)\nWorkspaces\n\nTo create a new package, configure your development environment to use workspaces within your project. This will allow you to develop your component alongside a working copy of Astro.\n\nDirectory\nmy-new-component-directory/\nDirectory\ndemo/\n‚Ä¶\nfor testing and demonstration\npackage.json\nDirectory\npackages/\nDirectory\nmy-component/\nindex.js\npackage.json\n‚Ä¶\nadditional files used by the package\n\nThis example, named my-project, creates a project with a single package, named my-component, and a demo/ directory for testing and demonstrating the component.\n\nThis is configured in the project root‚Äôs package.json file:\n\n{\n  \"name\": \"my-project\",\n  \"workspaces\": [\"demo\", \"packages/*\"]\n}\n\nIn this example, multiple packages can be developed together from the packages directory. These packages can also be referenced from demo, where you can install a working copy of Astro.\n\nTerminal window\nnpm create astro@latest demo -- --template minimal\n# yarn\nyarn create astro demo --template minimal\n# pnpm\npnpm create astro@latest demo -- --template minimal\n\nThere are two initial files that will make up your individual package: package.json and index.js.\n\npackage.json\nSection titled package.json\n\nThe package.json in the package directory includes all of the information related to your package, including its description, dependencies, and any other package metadata.\n\n{\n  \"name\": \"my-component\",\n  \"description\": \"Component description\",\n  \"version\": \"1.0.0\",\n  \"homepage\": \"https://github.com/owner/project#readme\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./astro\": \"./MyAstroComponent.astro\",\n    \"./react\": \"./MyReactComponent.jsx\"\n  },\n  \"files\": [\"index.js\", \"MyAstroComponent.astro\", \"MyReactComponent.jsx\"],\n  \"keywords\": [\"astro\", \"withastro\", \"astro-component\", \"...\", \"...\"]\n}\ndescription\nSection titled description\n\nA short description of your component used to help others know what it does.\n\n{\n  \"description\": \"An Astro Element Generator\"\n}\ntype\nSection titled type\n\nThe module format used by Node.js and Astro to interpret your index.js files.\n\n{\n  \"type\": \"module\"\n}\n\nUse \"type\": \"module\" so that your index.js can be used as an entrypoint with import and export .\n\nhomepage\nSection titled homepage\n\nThe url to the project homepage.\n\n{\n  \"homepage\": \"https://github.com/owner/project#readme\"\n}\n\nThis is a great way to direct users to an online demo, documentation, or homepage for your project.\n\nexports\nSection titled exports\n\nThe entry points of a package when imported by name.\n\n{\n  \"exports\": {\n    \".\": \"./index.js\",\n    \"./astro\": \"./MyAstroComponent.astro\",\n    \"./react\": \"./MyReactComponent.jsx\"\n  }\n}\n\nIn this example, importing my-component would use index.js, while importing my-component/astro or my-component/react would use MyAstroComponent.astro or MyReactComponent.jsx respectively.\n\nfiles\nSection titled files\n\nAn optional optimization to exclude unnecessary files from the bundle shipped to users via npm. Note that only files listed here will be included in your package, so if you add or change files necessary for your package to work, you must update this list accordingly.\n\n{\n  \"files\": [\"index.js\", \"MyAstroComponent.astro\", \"MyReactComponent.jsx\"]\n}\nkeywords\nSection titled keywords\n\nAn array of keywords relevant to your component, used to help others find your component on npm and in any other search catalogs.\n\nAdd astro-component or withastro as a special keyword to maximize its discoverability in the Astro ecosystem.\n\n{\n  \"keywords\": [\"astro-component\", \"withastro\", \"... etc\", \"... etc\"]\n}\n\n TIP\n\nKeywords are also used by our integrations library! See below for a full list of keywords we look for in NPM.\n\nindex.js\nSection titled index.js\n\nThe main package entrypoint used whenever your package is imported.\n\nexport { default as MyAstroComponent } from './MyAstroComponent.astro';\n\n\nexport { default as MyReactComponent } from './MyReactComponent.jsx';\n\nThis allows you to package multiple components together into a single interface.\n\nExample: Using Named Imports\nSection titled Example: Using Named Imports\n---\nimport { MyAstroComponent } from 'my-component';\nimport { MyReactComponent } from 'my-component';\n---\n<MyAstroComponent />\n<MyReactComponent />\nExample: Using Namespace Imports\nSection titled Example: Using Namespace Imports\n---\nimport * as Example from 'example-astro-component';\n---\n<Example.MyAstroComponent />\n<Example.MyReactComponent />\nExample: Using Individual Imports\nSection titled Example: Using Individual Imports\n---\nimport MyAstroComponent from 'example-astro-component/astro';\nimport MyReactComponent from 'example-astro-component/react';\n---\n<MyAstroComponent />\n<MyReactComponent />\nDeveloping your package\nSection titled Developing your package\n\nAstro does not have a dedicated ‚Äúpackage¬†mode‚Äù for development. Instead, you should use a demo project to develop and test your package inside of your project. This can be a private website only used for development, or a public demo/documentation website for your package.\n\nIf you are extracting components from an existing project, you can even continue to use that project to develop your now-extracted components.\n\nTesting your component\nSection titled Testing your component\n\nAstro does not currently ship a test runner. (If you are interested in helping out with this, join us on Discord!)\n\nIn the meantime, our current recommendation for testing is:\n\nAdd a test fixtures directory to your demo/src/pages directory.\nAdd a new page for every test that you‚Äôd like to run.\nEach page should include some different component usage that you‚Äôd like to test.\nRun astro build to build your fixtures, then compare the output of the dist/__fixtures__/ directory to what you expected.\nDirectory\nmy-project/demo/src/pages/__fixtures__/\ntest-name-01.astro\ntest-name-02.astro\ntest-name-03.astro\nPublishing your component\nSection titled Publishing your component\n\nOnce you have your package ready, you can publish it to npm using the npm publish command. If that fails, make sure that you have logged in via npm login and that your package.json is correct. If it succeeds, you‚Äôre done!\n\nNotice that there was no build step for Astro packages. Any file type that Astro supports natively, such as .astro, .ts, .jsx, and .css, can be published directly without a build step.\n\nIf you need another file type that isn‚Äôt natively supported by Astro, add a build step to your package. This advanced exercise is left up to you.\n\nIntegrations Library\nSection titled Integrations Library\n\nShare your hard work by adding your integration to our integrations library!\n\npackage.json data\nSection titled package.json data\n\nThe library is automatically updated weekly, pulling in every package published to NPM with the astro-component or withastro keyword.\n\nThe integrations library reads the name, description, repository, and homepage data from your package.json.\n\nAvatars are a great way to highlight your brand in the library! Once your package is published you can file a GitHub issue with your avatar attached and we will add it to your listing.\n\n TIP\n\nNeed to override the information our library reads from NPM? No problem! File an issue with the updated information and we‚Äôll make sure the custom name, description, or homepage is used instead.\n\nCollections\nSection titled Collections\n\nIn addition to the required astro-component or withastro keyword, special keywords are also used to automatically organize packages. Including any of the keywords below will add your integration to the collection in our integrations library.\n\ncollection\tkeywords\nAccessibility\ta11y, accessibility\nAdapters\tastro-adapter\nAnalytics\tanalytics\nCSS + UI\tcss, ui, icon, icons, renderer\nFrameworks\trenderer\nPerformance + SEO\tperformance, perf, seo, optimization\nShare\nSection titled Share\n\nWe encourage you to share your work, and we really do love seeing what our talented Astronauts create. Come and share what you create with us in our Discord or mention @astrodotbuild in a Tweet!\n\nBack\nError Reference"
  },
  {
    "title": "Error reference üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/error-reference/",
    "html": "Error reference\n\nThe following reference is a complete list of the errors you may encounter while using Astro. For additional assistance, including common pitfalls, please also see our Troubleshooting Guide.\n\nAstro Errors\nSection titled Astro Errors\nUnknownCompilerError\nUnknown compiler error.\nStaticRedirectNotAvailable\nAstro.redirect is not available in static mode.\nClientAddressNotAvailable\nAstro.clientAddress is not available in current adapter.\nStaticClientAddressNotAvailable\nAstro.clientAddress is not available in static mode.\nNoMatchingStaticPathFound\nNo static path found for requested path.\nOnlyResponseCanBeReturned\nInvalid type returned by Astro page.\nMissingMediaQueryDirective\nMissing value for client:media directive.\nNoMatchingRenderer\nNo matching renderer found.\nNoClientEntrypoint\nNo client entrypoint specified in renderer.\nNoClientOnlyHint\nMissing hint on client:only directive.\nInvalidGetStaticPathParam\nInvalid value returned by a getStaticPaths path.\nInvalidGetStaticPathsEntry\nInvalid entry inside getStaticPath‚Äôs return value\nInvalidGetStaticPathsReturn\nInvalid value returned by getStaticPaths.\nGetStaticPathsRemovedRSSHelper\ngetStaticPaths RSS helper is not available anymore.\nGetStaticPathsExpectedParams\nMissing params property on getStaticPaths route.\nGetStaticPathsInvalidRouteParam\nInvalid value for getStaticPaths route parameter.\nGetStaticPathsRequired\ngetStaticPaths() function required for dynamic routes.\nReservedSlotName\nInvalid slot name.\nNoAdapterInstalled\nCannot use Server-side Rendering without an adapter.\nNoMatchingImport\nNo import found for component.\nInvalidPrerenderExport\nInvalid prerender export.\nInvalidComponentArgs\nInvalid component arguments.\nPageNumberParamNotFound\nPage number param not found.\nImageMissingAlt\nMissing alt property.\nInvalidImageService\nError while loading image service.\nMissingImageDimension\nMissing image dimensions\nUnsupportedImageFormat\nUnsupported image format\nUnsupportedImageConversion\nUnsupported image conversion\nPrerenderDynamicEndpointPathCollide\nPrerendered dynamic endpoint has path collision.\nExpectedImage\nExpected src to be an image.\nExpectedImageOptions\nExpected image options.\nIncompatibleDescriptorOptions\nCannot set both densities and widths\nImageNotFound\nImage not found.\nNoImageMetadata\nCould not process image metadata.\nMarkdownImageNotFound\nImage not found.\nResponseSentError\nUnable to set response.\nMiddlewareNoDataOrNextCalled\nThe middleware didn‚Äôt return a response or call next.\nMiddlewareNotAResponse\nThe middleware returned something that is not a Response object.\nLocalsNotAnObject\nValue assigned to locals is not accepted.\nLocalImageUsedWrongly\nLocal images must be imported.\nAstroGlobUsedOutside\nAstro.glob() used outside of an Astro file.\nAstroGlobNoMatch\nAstro.glob() did not match any files.\nRedirectWithNoLocation\nA redirect must be given a location with the Location header.\nInvalidDynamicRoute\nInvalid dynamic route.\nMissingSharp\nCould not find Sharp.\nUnknownViteError\nUnknown Vite Error.\nFailedToLoadModuleSSR\nCould not import file.\nInvalidGlob\nInvalid glob pattern.\nFailedToFindPageMapSSR\nAstro couldn‚Äôt find the correct page to render\nCSS Errors\nSection titled CSS Errors\nUnknownCSSError\nUnknown CSS Error.\nCSSSyntaxError\nCSS Syntax Error.\nMarkdown Errors\nSection titled Markdown Errors\nUnknownMarkdownError\nUnknown Markdown Error.\nMarkdownFrontmatterParseError\nFailed to parse Markdown frontmatter.\nInvalidFrontmatterInjectionError\nInvalid frontmatter injection.\nMdxIntegrationMissingError\nMDX integration missing.\nUnknownConfigError\nUnknown configuration error.\nConfigNotFound\nSpecified configuration file not found.\nConfigLegacyKey\nLegacy configuration detected.\nCLI Errors\nSection titled CLI Errors\nUnknownCLIError\nUnknown CLI Error.\nGenerateContentTypesError\nFailed to generate content types.\nContent Collection Errors\nSection titled Content Collection Errors\nUnknownContentCollectionError\nUnknown Content Collection Error.\nInvalidContentEntryFrontmatterError\nContent entry frontmatter does not match schema.\nInvalidContentEntrySlugError\nInvalid content entry slug.\nContentSchemaContainsSlugError\nContent Schema should not contain slug.\nCollectionDoesNotExistError\nCollection does not exist\nMixedContentDataCollectionError\nContent and data cannot be in same collection.\nContentCollectionTypeMismatchError\nCollection contains entries of a different type.\nDataCollectionEntryParseError\nData collection entry failed to parse.\nDuplicateContentEntrySlugError\nDuplicate content entry slug.\nUnsupportedConfigTransformError\nUnsupported transform in content config.\nBack\nThe Astro CLI\nNext Page\nNPM Package Format"
  },
  {
    "title": "CLI Commands üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/cli-reference/",
    "html": "CLI Commands\n\nYou can use the Command-Line Interface (CLI) provided by Astro to develop, build, and preview your project from a terminal window.\n\nastro commands\nSection titled astro commands\n\nUse the CLI by running one of the commands documented on this page with your preferred package manager, optionally followed by any flags. Flags customize the behavior of a command.\n\nOne of the commands you‚Äôll use most often is astro dev. This command starts the development server and gives you a live, updating preview of your site in a browser as you work:\n\nnpm\npnpm\nYarn\nTerminal window\n# start the development server\nnpx astro dev\n\nYou can type astro --help in your terminal to display a list of all available commands:\n\nnpm\npnpm\nYarn\nTerminal window\nnpx astro --help\n\nThe following message will display in your terminal:\n\nTerminal window\nastro [command] [...flags]\n\n\nCommands\n              add  Add an integration.\n            build  Build your project and write it to disk.\n            check  Check your project for errors.\n              dev  Start the development server.\n             docs  Open documentation in your web browser.\n             info  List info about your current Astro setup.\n          preview  Preview your build locally.\n             sync  Generate content collection types.\n        telemetry  Configure telemetry settings.\n\n\nGlobal Flags\n  --config <path>  Specify your config file.\n    --root <path>  Specify your project root folder.\n     --site <url>  Specify your project site.\n--base <pathname>  Specify your project base.\n        --verbose  Enable verbose logging.\n         --silent  Disable all logging.\n        --version  Show the version number and exit.\n           --open  Open the app in the browser on server start.\n           --help  Show this help message.\n\n NOTE\n\nThe extra -- before any flag is necessary for npm to pass your flags to the astro command.\n\npackage.json scripts\nSection titled package.json scripts\n\nYou can also use scripts in package.json for shorter versions of these commands. Using a script allows you to use the same commands that you may be familiar with from other projects, such as npm run build.\n\nThe following scripts for the most common astro commands (astro dev, astro build, and astro preview) are added for you automatically when you create a project using the create astro wizard.\n\nWhen you follow the instructions to install Astro manually, you are instructed to add these scripts yourself. You can also add more scripts to this list manually for any commands you use frequently.\n\npackage.json\n{\n  \"scripts\": {\n    \"dev\": \"astro dev\",\n    \"start\": \"astro dev\",\n    \"build\": \"astro build\",\n    \"preview\": \"astro preview\"\n  }\n}\n\nYou will often use these astro commands, or the scripts that run them, without any flags. Add flags to the command when you want to customize the command‚Äôs behavior. For example, you may wish to start the development server on a different port, or build your site with verbose logs for debugging.\n\nnpm\npnpm\nYarn\nTerminal window\n# run the dev server on port 8080 using the `start` script in `package.json`\nnpm run start -- --port 8080\n\n\n# build your site with verbose logs using the `build` script in `package.json`\nnpm run build -- --verbose\nastro dev\nSection titled astro dev\n\nRuns Astro‚Äôs development server. This is a local HTTP server that doesn‚Äôt bundle assets. It uses Hot Module Replacement (HMR) to update your browser as you save changes in your editor.\n\nFlags\n\nUse these flags to customize the behavior of the Astro dev server. For flags shared with other Astro commands, see common flags below.\n\n--port <number>\nSection titled --port &lt;number&gt;\n\nSpecifies which port to run on. Defaults to 4321.\n\n--host [optional host address]\nSection titled --host [optional host address]\n\nSets which network IP addresses the dev server should listen on (i.e. non-localhost IPs). This can be useful for testing your project on local devices like a mobile phone during development.\n\n--host ‚Äî listen on all addresses, including LAN and public addresses\n--host <custom-address> ‚Äî expose on a network IP address at <custom-address>\n\n CAUTION\n\nDo not use the --host flag to expose the dev server in a production environment. The dev server is designed for local use while developing your site only.\n\nastro build\nSection titled astro build\n\nBuilds your site for deployment. By default, this will generate static files and place them in a dist/ directory. If SSR is enabled, this will generate the necessary server files to serve your site.\n\nCan be combined with the common flags documented below.\n\nastro preview\nSection titled astro preview\n\nStarts a local server to serve your static dist/ directory.\n\nThis command is useful for previewing your build locally, before deploying it. It is not designed to be run in production. For help with production hosting, check out our guide on Deploying an Astro Website.\n\nSince Astro 1.5.0, astro preview also works for SSR builds if you use an adapter that supports it. Currently, only the Node adapter supports astro preview.\n\nCan be combined with the common flags documented below.\n\nastro check\nSection titled astro check\n\nRuns diagnostics (such as type-checking within .astro files) against your project and reports errors to the console. If any errors are found the process will exit with a code of 1.\n\nThis command is intended to be used in CI workflows.\n\nFlags\n\nUse these flags to customize the behavior of the command.\n\n--watch\nSection titled --watch\n\nThe command will watch for any changes in your project, and will report any errors.\n\nüìö Read more about type checking in Astro.\n\nastro sync\nSection titled astro sync\n\nAdded in: astro@2.0.0\n\n TIP\n\nRunning astro dev, astro build or astro check will run the sync command as well.\n\nGenerates TypeScript types for all Astro modules. This sets up a src/env.d.ts file for type inferencing, and defines the astro:content module for the Content Collections API.\n\nastro add\nSection titled astro add\n\nAdds an integration to your configuration. Read more in the integrations guide.\n\nastro docs\nSection titled astro docs\n\nLaunches the Astro Docs website directly from the terminal.\n\nastro info\nSection titled astro info\n\nReports useful information about your current Astro environment. Useful for providing information when opening an issue.\n\nTerminal window\nastro info\n\nExample output:\n\nAstro                    v3.0.12\nNode                     v20.5.1\nSystem                   macOS (arm64)\nPackage Manager          pnpm\nOutput                   server\nAdapter                  @astrojs/vercel/serverless\nIntegrations             none\nastro telemetry\nSection titled astro telemetry\n\nSets telemetry configuration for the current CLI user. Telemetry is anonymous data that provides the Astro team insights into which Astro features are most often used. For more information see Astro‚Äôs telemetry page.\n\nTelemetry can be disabled with this CLI command:\n\nTerminal window\nastro telemetry disable\n\nTelemetry can later be re-enabled with:\n\nTerminal window\nastro telemetry enable\n\nThe clear command resets the telemetry data:\n\nTerminal window\nastro telemetry clear\n\n WANT TO DISABLE TELEMETRY IN CI ENVIRONMENTS?\n\nAdd the astro telemetry disable command to your CI scripts or set the ASTRO_TELEMETRY_DISABLED environment variable.\n\nCommon flags\nSection titled Common flags\n--root <path>\nSection titled --root &lt;path&gt;\n\nSpecifies the path to the project root. If not specified, the current working directory is assumed to be the root.\n\nThe root is used for finding the Astro configuration file.\n\nTerminal window\nastro --root myRootFolder/myProjectFolder dev\n--config <path>\nSection titled --config &lt;path&gt;\n\nSpecifies the path to the config file relative to the project root. Defaults to astro.config.mjs. Use this if you use a different name for your configuration file or have your config file in another folder.\n\nTerminal window\nastro --config config/astro.config.mjs dev\n--outDir <path>\nSection titled --outDir &lt;path&gt;\nAdded in: astro@3.3.0\n\nConfigures the outDir for your project. Passing this flag will override the outDir value in your astro.config.mjs file, if one exists.\n\n--site <url>\nSection titled --site &lt;url&gt;\n\nConfigures the site for your project. Passing this flag will override the site value in your astro.config.mjs file, if one exists.\n\n--base <pathname>\nSection titled --base &lt;pathname&gt;\nAdded in: astro@1.4.1\n\nConfigures the base for your project. Passing this flag will override the base value in your astro.config.mjs file, if one exists.\n\n--verbose\nSection titled --verbose\n\nEnables verbose logging, which is helpful when debugging an issue.\n\n--silent\nSection titled --silent\n\nEnables silent logging, which will run the server without any console output.\n\nGlobal flags\nSection titled Global flags\n\nUse these flags to get information about the astro CLI.\n\n--version\nSection titled --version\n\nPrints the Astro version number and exits.\n\n--open\nSection titled --open\n\nAutomatically opens the app in the browser on server start.\n\n--help\nSection titled --help\n\nPrints the help message and exits.\n\nAdvanced APIs (Experimental)\nSection titled Advanced APIs (Experimental)\n\nIf you need more control when running Astro, the \"astro\" package also exports APIs to programmatically run the CLI commands.\n\nThese APIs are experimental and their API signature may change. Any updates will be mentioned in the Astro changelog and the information below will always show the current, up-to-date information.\n\nAstroInlineConfig\nSection titled AstroInlineConfig\n\nThe AstroInlineConfig type is used by all of the command APIs below. It extends from the user Astro config type:\n\ninterface AstroInlineConfig extends AstroUserConfig {\n  configFile?: string | false;\n  mode?: \"development\" | \"production\";\n  logLevel?: \"debug\" | \"info\" | \"warn\" | \"error\" | \"silent\";\n}\nconfigFile\nSection titled configFile\n\nType: string | false\nDefault: undefined\n\nA custom path to the Astro config file.\n\nIf this value is undefined (default) or unset, Astro will search for an astro.config.(js,mjs,ts) file relative to the root and load the config file if found.\n\nIf a relative path is set, it will resolve based on the current working directory.\n\nSet to false to disable loading any config files.\n\nThe inline config passed in this object will take highest priority when merging with the loaded user config.\n\nmode\nSection titled mode\n\nType: \"development\" | \"production\"\nDefault: \"development\" when running astro dev, \"production\" when running astro build\n\nThe mode used when building your site to generate either ‚Äúdevelopment‚Äù or ‚Äúproduction‚Äù code.\n\nlogLevel\nSection titled logLevel\n\nType: \"debug\" | \"info\" | \"warn\" | \"error\" | \"silent\"\nDefault: \"info\"\n\nThe logging level to filter messages logged by Astro.\n\n\"debug\": Log everything, including noisy debugging diagnostics.\n\"info\": Log informational messages, warnings, and errors.\n\"warn\": Log warnings and errors.\n\"error\": Log errors only.\n\"silent\": No logging.\ndev()\nSection titled dev()\n\nType: (inlineConfig: AstroInlineConfig) => AstroDevServer\n\nSimilar to astro dev, it runs Astro‚Äôs development server.\n\nimport { dev } from \"astro\";\n\n\nconst devServer = await dev({\n  root: \"./my-project\",\n});\n\n\n// Stop the server if needed\nawait devServer.stop();\nbuild()\nSection titled build()\n\nType: (inlineConfig: AstroInlineConfig) => void\n\nSimilar to astro build, it builds your site for deployment.\n\nimport { build } from \"astro\";\n\n\nawait build({\n  root: \"./my-project\",\n});\npreview()\nSection titled preview()\n\nType: (inlineConfig: AstroInlineConfig) => AstroPreviewServer\n\nSimilar to astro preview, it starts a local server to serve your static dist/ directory.\n\nimport { preview } from \"astro\";\n\n\nconst previewServer = await preview({\n  root: \"./my-project\",\n});\n\n\n// Stop the server if needed\nawait previewServer.stop();\nsync()\nSection titled sync()\n\nType: (inlineConfig: AstroInlineConfig) => number\n\nSimilar to astro sync, it generates TypeScript types for all Astro modules\n\nimport { sync } from \"astro\";\n\n\nconst exitCode = await sync({\n  root: \"./my-project\",\n});\n\n\nprocess.exit(exitCode)\nBack\nTemplate Directives\nNext Page\nError Reference"
  },
  {
    "title": "Template Directives Reference üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/directives-reference/",
    "html": "Template Directives Reference\n\nTemplate directives are a special kind of HTML attribute available inside of any Astro component template (.astro files), and some can also be used in .mdx files.\n\nTemplate directives are used to control an element or component‚Äôs behavior in some way. A template directive could enable some compiler feature that makes your life easier (like using class:list instead of class). Or, a directive could tell the Astro compiler to do something special with that component (like hydrating with client:load).\n\nThis page describes all of the template directives available to you in Astro, and how they work.\n\nRules\nSection titled Rules\n\nFor a template directive to be valid, it must:\n\nInclude a colon : in its name, using the form X:Y (ex: client:load).\nBe visible to the compiler (ex: <X {...attr}> would not work if attr contained a directive).\n\nSome template directives, but not all, can take a custom value:\n\n<X client:load /> (takes no value)\n<X class:list={['some-css-class']} /> (takes an array)\n\nA template directive is never included directly in the final HTML output of a component.\n\nCommon Directives\nSection titled Common Directives\nclass:list\nSection titled class:list\n\nclass:list={...} takes an array of class values and converts them into a class string. This is powered by @lukeed‚Äôs popular clsx helper library.\n\nclass:list takes an array of several different possible value kinds:\n\nstring: Added to the element class\nObject: All truthy keys are added to the element class\nArray: flattened\nfalse, null, or undefined: skipped\n<!-- This -->\n<span class:list={[ 'hello goodbye', { world: true }, [ 'friend' ] ]} />\n<!-- Becomes -->\n<span class=\"hello goodbye world friend\"></span>\nset:html\nSection titled set:html\n\nset:html={string} injects an HTML string into an element, similar to setting el.innerHTML.\n\nThe value is not automatically escaped by Astro! Be sure that you trust the value, or that you have escaped it manually before passing it to the template. Forgetting to do this will open you up to Cross Site Scripting (XSS) attacks.\n\n---\nconst rawHTMLString = \"Hello <strong>World</strong>\"\n---\n<h1>{rawHTMLString}</h1>\n  <!-- Output: <h1>Hello &lt;strong&gt;World&lt;/strong&gt;</h1> -->\n<h1 set:html={rawHTMLString} />\n  <!-- Output: <h1>Hello <strong>World</strong></h1> -->\n\nYou can also use set:html on a <Fragment> to avoid adding an unnecessary wrapper element. This can be especially useful when fetching HTML from a CMS.\n\n---\nconst cmsContent = await fetchHTMLFromMyCMS();\n---\n<Fragment set:html={cmsContent}>\n\nset:html={Promise<string>} injects an HTML string into an element that is wrapped in a Promise.\n\nThis can be used to inject HTML stored externally, such as in a database.\n\n---\nimport api from '../db/api.js';\n---\n<article set:html={api.getArticle(Astro.props.id)}></article>\n\nset:html={Promise<Response>} injects a Response into an element.\n\nThis is most helpful when using fetch(). For example, fetching old posts from a previous static-site generator.\n\n<article set:html={fetch('http://example/old-posts/making-soup.html')}></article>\n\nset:html can be used on any tag and does not have to include HTML. For example, use with JSON.stringify() on a <script> tag to add a JSON-LD schema to your page.\n\n<script type=\"application/ld+json\" set:html={JSON.stringify({\n  \"@context\": \"https://schema.org/\",\n  \"@type\": \"Person\",\n  name: \"Houston\",\n  hasOccupation: {\n    \"@type\": \"Occupation\",\n    name: \"Astronaut\"\n  }\n})}/>\nset:text\nSection titled set:text\n\nset:text={string} injects a text string into an element, similar to setting el.innerText. Unlike set:html, the string value that is passed is automatically escaped by Astro.\n\nThis is equivalent to just passing a variable into a template expression directly (ex: <div>{someText}</div>) and therefore this directive is not commonly used.\n\nClient Directives\nSection titled Client Directives\n\nThese directives control how UI Framework components are hydrated on the page.\n\nBy default, a UI Framework component is not hydrated in the client. If no client:* directive is provided, its HTML is rendered onto the page without JavaScript.\n\nA client directive can only be used on a UI framework component that is directly imported into a .astro component. Hydration directives are not supported when using dynamic tags and custom components passed via the components prop.\n\nclient:load\nSection titled client:load\nPriority: High\nUseful for: Immediately-visible UI elements that need to be interactive as soon as possible.\n\nLoad and hydrate the component JavaScript immediately on page load.\n\n<BuyButton client:load />\nclient:idle\nSection titled client:idle\nPriority: Medium\nUseful for: Lower-priority UI elements that don‚Äôt need to be immediately interactive.\n\nLoad and hydrate the component JavaScript once the page is done with its initial load and the requestIdleCallback event has fired. If you are in a browser that doesn‚Äôt support requestIdleCallback, then the document load event is used.\n\n<ShowHideButton client:idle />\nclient:visible\nSection titled client:visible\nPriority: Low\nUseful for: Low-priority UI elements that are either far down the page (‚Äúbelow the fold‚Äù) or so resource-intensive to load that you would prefer not to load them at all if the user never saw the element.\n\nLoad and hydrate the component JavaScript once the component has entered the user‚Äôs viewport. This uses an IntersectionObserver internally to keep track of visibility.\n\n<HeavyImageCarousel client:visible />\nclient:media\nSection titled client:media\nPriority: Low\nUseful for: Sidebar toggles, or other elements that might only be visible on certain screen sizes.\n\nclient:media={string} loads and hydrates the component JavaScript once a certain CSS media query is met.\n\n NOTE\n\nIf the component is already hidden and shown by a media query in your CSS, then it can be easier to just use client:visible and not pass that same media query into the directive.\n\n<SidebarToggle client:media=\"(max-width: 50em)\" />\nclient:only\nSection titled client:only\n\nclient:only={string} skips HTML server-rendering, and renders only on the client. It acts similar to client:load in that it loads, renders and hydrates the component immediately on page load.\n\nYou must pass the component‚Äôs correct framework as a value! Because Astro doesn‚Äôt run the component during your build / on the server, Astro doesn‚Äôt know what framework your component uses unless you tell it explicitly.\n\n<SomeReactComponent client:only=\"react\" />\n<SomePreactComponent client:only=\"preact\" />\n<SomeSvelteComponent client:only=\"svelte\" />\n<SomeVueComponent client:only=\"vue\" />\n<SomeSolidComponent client:only=\"solid-js\" />\nCustom Client Directives\nSection titled Custom Client Directives\n\nSince Astro 2.6.0, integrations can also add custom client:* directives to change how and when components should be hydrated.\n\nVisit the addClientDirective API page to learn more about creating a custom client directive.\n\nScript & Style Directives\nSection titled Script &amp; Style Directives\n\nThese directives can only be used on HTML <script> and <style> tags, to control how your client-side JavaScript and CSS are handled on the page.\n\nis:global\nSection titled is:global\n\nBy default, Astro automatically scopes <style> CSS rules to the component. You can opt-out of this behavior with the is:global directive.\n\nis:global makes the contents of a <style> tag apply globally on the page when the component is included. This disables Astro‚Äôs CSS scoping system. This is equivalent to wrapping all of the selectors within a <style> tag with :global().\n\nYou can combine <style> and <style is:global> together in the same component, to create some global style rules while still scoping most of your component CSS.\n\nüìö See the Styling & CSS page for more details about how global styles work.\n\n<style is:global>\n  body a { color: red; }\n</style>\nis:inline\nSection titled is:inline\n\nBy default, Astro will process, optimize, and bundle any <script> and <style> tags that it sees on the page. You can opt-out of this behavior with the is:inline directive.\n\nis:inline tells Astro to leave the <script> or <style> tag as-is in the final output HTML. The contents will not be processed, optimized, or bundled. This limits some Astro features, like importing an npm package or using a compile-to-CSS language like Sass.\n\nThe is:inline directive means that <style> and <script> tags:\n\nWill not be bundled into an external file. This means that attributes like defer which control the loading of an external file will have no effect.\nWill not be deduplicated‚Äîthe element will appear as many times as it is rendered.\nWill not have its import/@import/url() references resolved relative to the .astro file.\nWill be rendered in the final output HTML exactly where it is authored.\nStyles will be global and not scoped to the component.\n\n CAUTION\n\nThe is:inline directive is implied whenever any attribute other than src is used on a <script> or <style> tag.\n\n<style is:inline>\n  /* inline: relative & npm package imports are not supported. */\n  @import '/assets/some-public-styles.css';\n  span { color: green; }\n</style>\n\n\n<script is:inline>\n  /* inline: relative & npm package imports are not supported. */\n  console.log('I am inlined right here in the final output HTML.');\n</script>\n\nüìö See how client-side scripts work in Astro components.\n\ndefine:vars\nSection titled define:vars\n\ndefine:vars={...} can pass server-side variables from your component frontmatter into the client <script> or <style> tags. Any JSON-serializable frontmatter variable is supported, including props passed to your component through Astro.props. Values are serialized with JSON.stringify().\n\n---\nconst foregroundColor = \"rgb(221 243 228)\";\nconst backgroundColor = \"rgb(24 121 78)\";\nconst message = \"Astro is awesome!\";\n---\n<style define:vars={{ textColor: foregroundColor, backgroundColor }}>\n  h1 {\n    background-color: var(--backgroundColor);\n    color: var(--textColor);\n  }\n</style>\n\n\n<script define:vars={{ message }}>\n  alert(message);\n</script>\n\n CAUTION\n\nUsing define:vars on a <script> tag implies the is:inline directive, which means your scripts won‚Äôt be bundled and will be inlined directly into the HTML.\n\nThis is because when Astro bundles a script, it includes and runs the script once even if you include the component containing the script multiple times on one page. define:vars requires a script to rerun with each set of values, so Astro creates an inline script instead.\n\nFor scripts, try passing variables to scripts manually instead.\n\nAdvanced Directives\nSection titled Advanced Directives\nis:raw\nSection titled is:raw\n\nis:raw instructs the Astro compiler to treat any children of that element as text. This means that all special Astro templating syntax will be ignored inside of this component.\n\nFor example, if you had a custom Katex component that converted some text to HTML, you could have users do this:\n\n---\nimport Katex from '../components/Katex.astro';\n---\n<Katex is:raw>Some conflicting {syntax} here</Katex>\nBack\nDev Overlay Plugin API\nNext Page\nThe Astro CLI"
  },
  {
    "title": "Dev Overlay Plugin API üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/dev-overlay-plugin-reference/",
    "html": "Dev Overlay Plugin API\n\nThe Astro Dev Overlay Plugin API allows you to create plugins that can be used to extend the Astro Dev Overlay. This allows you to add new features and integrations with third-party services.\n\n NOTE\n\nThis API is currently experimental. It is subject to change in future releases with no prior notice.\n\nAdding plugins\nSection titled Adding plugins\n\nAstro Integrations can add plugins in the astro:config:setup hook using the addDevOverlayPlugin method.\n\nintegrations.js\n/**\n * @type {() => import('astro').AstroIntegration}\n */\nexport default () => ({\n  name: \"my-integration\",\n  hooks: {\n    \"astro:config:setup\": ({ addDevOverlayPlugin }) => {\n      addDevOverlayPlugin(\"./my-plugin.js\");\n    },\n  },\n});\nStructure of a plugin\nSection titled Structure of a plugin\n\nA plugin is a .js or .ts file that default exports an object with the following required properties:\n\nsrc/my-plugin.js\nexport default {\n  id: 'super-plugin',\n  name: 'My Super Plugin',\n  icon: '<svg>...</svg>',\n  init(canvas, eventTarget) {\n    eventTarget.dispatchEvent(\n      new CustomEvent('plugin-notification', {\n        detail: {\n          state: true,\n        },\n      })\n    );\n  }\n}\nid: string\nSection titled id: string\n\nA unique identifier for the plugin. This will be used to uniquely identify the plugin in hooks and events.\n\nsrc/my-plugin.js\nexport default {\n  id: 'my-plugin',\n  // ...\n}\nname: string\nSection titled name: string\n\nThe name of the plugin. This will be shown to users whenever the plugin needs to be referenced using a human-readable name.\n\nsrc/my-plugin.js\nexport default {\n  // ...\n  name: 'My Plugin',\n  // ...\n}\nicon: Icon\nSection titled icon: Icon\n\nThe icon of the plugin. This will be used to display the plugin in the UI. This can either be an icon from the icon list, or a string containing the SVG markup of the icon.\n\nsrc/my-plugin.js\nexport default {\n  // ...\n  icon: '<svg>...</svg>', // or 'astro:logo'\n}\ninit: (canvas: ShadowRoot, eventTarget: EventTarget) => void\nSection titled init: (canvas: ShadowRoot, eventTarget: EventTarget) =&gt; void\n\nThis is the core part of the plugin. This function will be called when the plugin is loaded, which will either be when the browser is idle or when the user clicks on the plugin in the UI.\n\nThe function receives two arguments:\n\ncanvas\nSection titled canvas\n\nA ShadowRoot that the plugin can use to render its UI. Every plugin receive its own dedicated ShadowRoot for rendering its UI. Additionally, the parent element is positioned using position: absolute; and as such, the plugin UI automatically won‚Äôt affect the layout of the page.\n\nexport default {\n  id: 'super-plugin',\n  name: 'My Super Plugin',\n  icon: '<svg>...</svg>',\n  init(canvas) {\n    canvas.appendChild(document.createTextNode('Hello World!'))\n  }\n}\neventTarget\nSection titled eventTarget\n\nAn EventTarget that can be used to send and receive events from the dev overlay.\n\nbeforeTogglingOff\nSection titled beforeTogglingOff\n\nThis optional function will be called when the user clicks on the plugin icon in the UI to toggle off the plugin. This function can be used, for example, to perform cleanup operations, do an animation, or to ask the user for confirmation before toggling off the plugin.\n\nIf a falsy value is returned, the toggling off will be cancelled and the plugin will stay enabled.\n\nsrc/my-plugin.js\nexport default {\n  // ...\n  beforeTogglingOff() {\n    const confirmation = window.confirm('Are you sure you want to disable this plugin?');\n    return confirmation;\n  }\n}\ncanvas\nSection titled canvas\n\nThe ShadowRoot of the plugin, can be used to render any UI needed.\n\nClient-side Events\nSection titled Client-side Events\n\nUsing the eventTarget argument on the init hook, plugins can send and receive events from the dev overlay. The following events are available:\n\nplugin-toggled\nSection titled plugin-toggled\n\nThis event is fired when the user clicks on the plugin icon in the dev overlay bar.\n\nsrc/my-plugin.js\n  export default {\n    // ...\n    init(canvas, eventTarget) {\n      eventTarget.addEventListener('plugin-toggled', (event) => {\n        if (event.detail.state === true) {\n          console.log(\"The plugin is now enabled!\")\n        }\n      })\n    }\n  }\nstate: boolean\nSection titled state: boolean\n\nIndicates whether or not the plugin is enabled after the user‚Äôs click.\n\ntoggle-notification\nSection titled toggle-notification\n\nThis event can be sent to inform the user that the plugin requires attention.\n\nsrc/my-plugin.js\n  export default {\n    // ...\n    init(canvas, eventTarget) {\n      eventTarget.dispatchEvent(\n          new CustomEvent('toggle-notification', {\n            detail: {\n              state: true,\n            },\n          })\n        );\n    }\n  }\nstate: boolean\nSection titled state: boolean\n\nIndicates whether or not the plugin has a notification for the user. When true, the plugin icon will be highlighted using a red dot. Conversely, when false, the highlight will be removed. If this property is not specified, true will be assumed.\n\ntoggle-plugin\nSection titled toggle-plugin\n\nThis event can be sent from your plugin to change the state of your plugin. This can be useful, for instance, to implement a ‚ÄúClose‚Äù button in your plugin‚Äôs UI.\n\nsrc/my-plugin.js\n  export default {\n    // ...\n    init(canvas, eventTarget) {\n      eventTarget.dispatchEvent(\n          new CustomEvent('toggle-plugin', {\n            detail: {\n              state: false,\n            },\n          })\n        );\n    }\n  }\nstate: boolean\nSection titled state: boolean\n\nIndicates whether or not the plugin should be enabled. When true, the plugin will be enabled. Conversely, when false, the plugin will be disabled. If this property is not specified, true will be assumed.\n\nClient-Server Communication\nSection titled Client-Server Communication\n\nUsing Vite‚Äôs methods for client-server communication, dev overlay plugins can communicate with the server.\n\nIn addition to being able to send and receive custom messages, the dev overlay also sends the following messages, where PLUGIN_ID is the plugin‚Äôs ID:\n\nastro-dev-overlay:PLUGIN_ID:initialized\nSection titled astro-dev-overlay:PLUGIN_ID:initialized\n\nThis message is sent when the plugin is initialized. The data for this message is empty.\n\nintegration.ts\n{\n  // ...\n  \"astro:server:setup\": ({ server }) => {\n    server.ws.on(\"astro-dev-overlay:super-plugin:initialized\", () => {\n      console.log(\"My plugin was initialized!\");\n    });\n  },\n  // ...\n}\nastro-dev-overlay:PLUGIN_ID:toggled\nSection titled astro-dev-overlay:PLUGIN_ID:toggled\n\nThis message is sent when the user clicks on the plugin icon in the UI. The data for this message is a boolean indicating whether the plugin is enabled or not.\n\nintegration.ts\n{\n  // ...\n  \"astro:server:setup\": ({ server }) => {\n    server.ws.on(\"astro-dev-overlay:super-plugin:toggled\", (data) => {\n      console.log(`My plugin is now ${data.state ? \"enabled\" : \"disabled\"}!`);\n    });\n  },\n  // ...\n}\n\n NOTE\n\nThe built-in connection event from Vite fires before dev overlay plugins are initialized and therefore cannot be used directly by plugins. Instead, use the astro-dev-overlay:PLUGIN_ID:initialized event.\n\nUI Toolkit\nSection titled UI Toolkit\n\nThe dev overlay includes a set of web components that can be used to build plugins with a consistent look and feel.\n\nastro-dev-overlay-window\nSection titled astro-dev-overlay-window\n\nShows a window with optionally a title and an icon.\n\nwindow-title is a string that will be shown at the top of the overlay window. window-icon can either be a string of a SVG file or an icon from the icon list.\n\nThe slot of the component will be used as the content of the window.\n\n<astro-dev-overlay-window window-title=\"MyWindows\" window-icon=\"astro:logo\">\n  <p>My content</p>\n</astro-dev-overlay-window>\nastro-dev-overlay-card\nSection titled astro-dev-overlay-card\n\nShows a card with optionally an icon. Optionally, if a link is passed, the card will be clickable and will open the link in a new tab.\n\nThe slot of the component will be used as the content of the card.\n\n<astro-dev-overlay-card icon=\"astro:logo\" link=\"https://github.com/withastro/astro/issues/new/choose\">Report an issue</astro-dev-overlay-card>\nastro-dev-overlay-toggle\nSection titled astro-dev-overlay-toggle\n\nShows a toggle element, acting as a checkbox. This element internally is a simple wrapper around a native <input type=\"checkbox\"> element. The checkbox element can be accessed using the input property.\n\nconst toggle = document.createElement('astro-dev-overlay-toggle');\n\n\ntoggle.input.addEventListener('change', (evt) => {\n  console.log(`The toggle is now ${evt.currentTarget.checked ? 'enabled' : 'disabled'}!`);\n});\nastro-dev-overlay-highlight\nSection titled astro-dev-overlay-highlight\n\nCan be used to highlight an element on the page. In most cases, you‚Äôll want to position and resize this element using the top, left, width and height CSS properties to match the element you want to highlight. An icon can also be specified using the icon attribute and will be shown in the top right corner of the highlight.\n\n<!-- Highlight the entire page -->\n<astro-dev-overlay-highlight style=\"top: 0; left: 0; width: 100%; height: 100%;\"></astro-dev-overlay-highlight>\nconst elementToHighlight = document.querySelector('h1');\nconst rect = elementToHighlight.getBoundingClientRect();\n\n\nconst highlight = document.createElement('astro-dev-overlay-highlight');\n\n\nhighlight.style.top = `${Math.max(rect.top + window.scrollY - 10, 0)}px`;\nhighlight.style.left = `${Math.max(rect.left + window.scrollX - 10, 0)}px`;\nhighlight.style.width = `${rect.width + 15}px`;\nhighlight.style.height = `${rect.height + 15}px`;\nhighlight.icon = 'astro:logo';\nastro-dev-overlay-tooltip\nSection titled astro-dev-overlay-tooltip\n\nShows a tooltip with different sections. This component is set to display: none; by default and can be made visible using a data-show=\"true\" attribute.\n\nSections are defined using the sections property. This property is an array of objects with the following shape:\n\n{\n  title?: string; // Title of the section\n  inlineTitle?: string; // Title of the section, shown inline next to the title\n  icon?: Icon; // Icon of the section\n  content?: string; // Content of the section\n  clickAction?: () => void | Promise<void>; // Action to perform when clicking on the section\n  clickDescription?: string; // Description of the action to perform when clicking on the section\n}\nconst tooltip = document.createElement('astro-dev-overlay-tooltip');\n\n\ntooltip.sections = [{\n  title: 'My section',\n  icon: 'astro:logo',\n  content: 'My content',\n  clickAction: () => {\n    console.log('Clicked!')\n  },\n  clickDescription: 'Click me!'\n}]\n\nThis component is often combined with the astro-dev-overlay-highlight component to show a tooltip when hovering a highlighted element:\n\nconst highlight = document.createElement('astro-dev-overlay-highlight');\n\n\n// Position the highlight...\n\n\nconst tooltip = document.createElement('astro-dev-overlay-tooltip');\n\n\n// Add sections to the tooltip...\n\n\nhighlight.addEventListener('mouseover', () => {\n  tooltip.dataset.show = 'true';\n});\n\n\nhighlight.addEventListener('mouseout', () => {\n  tooltip.dataset.show = 'false';\n});\nIcons\nSection titled Icons\n\nCurrently, the following icons are available and can be used in any component that accepts an icon:\n\nastro:logo\nwarning\narrow-down\nbug\nfile-search\ncheck-circle\ngear\n\nIn addition to these included icons, you can also pass a string containing the SVG markup of the icon you want to use.\n\n<astro-dev-overlay-card icon=\"<svg>...</svg>\" link=\"https://docs.astro.build\">Read more in the Astro Docs!</astro-dev-overlay-card>\nBack\nImage Service API\nNext Page\nTemplate Directives"
  },
  {
    "title": "Image Service API üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/image-service-reference/",
    "html": "Image Service API\n\nastro:assets was designed to make it easy for any image optimization service to build a service on top of Astro.\n\nWhat is an Image Service?\nSection titled What is an Image Service?\n\nAstro provides two types of image services: Local and External.\n\nLocal services handle image transformations directly at build for static sites, or at runtime both in development mode and SSR. These are often wrappers around libraries like Sharp, ImageMagick, or Squoosh. In dev mode and in SSR, local services use an API endpoint to do the transformation.\nExternal services point to URLs and can add support for services such as Cloudinary, Vercel, or any RIAPI-compliant server.\nBuilding using the Image Services API\nSection titled Building using the Image Services API\n\nService definitions take the shape of an exported default object with various required methods (‚Äúhooks‚Äù).\n\nExternal services provide a getURL() that points to the src of the output <img> tag.\n\nLocal services provide a transform() method to perform transformations on your image, and getURL() and parseURL() methods to use an endpoint for dev mode and SSR.\n\nBoth types of services can provide getHTMLAttributes() to determine the other attributes of the output <img> and validateOptions() to validate and augment the passed options.\n\nExternal Services\nSection titled External Services\n\nAn external service points to a remote URL to be used as the src attribute of the final <img> tag. This remote URL is responsible for downloading, transforming, and returning the image.\n\nimport type { ExternalImageService, ImageTransform, AstroConfig } from \"astro\";\n\n\nconst service: ExternalImageService = {\n  validateOptions(options: ImageTransform, imageConfig: AstroConfig['image']) {\n    const serviceConfig = imageConfig.service.config;\n\n\n    // Enforce the user set max width.\n    if (options.width > serviceConfig.maxWidth) {\n      console.warn(`Image width ${options.width} exceeds max width ${serviceConfig.maxWidth}. Falling back to max width.`);\n      options.width = serviceConfig.maxWidth;\n    }\n\n\n    return options;\n  },\n  getURL(options, imageConfig) {\n    return `https://mysupercdn.com/${options.src}?q=${options.quality}&w=${options.width}&h=${options.height}`;\n  },\n  getHTMLAttributes(options, imageConfig) {\n    const { src, format, quality, ...attributes } = options;\n    return {\n      ...attributes,\n      loading: options.loading ?? 'lazy',\n      decoding: options.decoding ?? 'async',\n    };\n  }\n};\n\n\n\n\nexport default service;\nLocal Services\nSection titled Local Services\n\nTo create your own local service, you can point to the built-in endpoint (/_image), or you can additionally create your own endpoint that can call the service‚Äôs methods.\n\nimport type { LocalImageService, AstroConfig } from \"astro\";\n\n\nconst service: LocalImageService = {\n  getURL(options: ImageTransform, imageConfig: AstroConfig['image']) {\n    const searchParams = new URLSearchParams();\n    searchParams.append('href', typeof options.src === \"string\" ? options.src : options.src.src);\n    options.width && searchParams.append('w', options.width.toString());\n    options.height && searchParams.append('h', options.height.toString());\n    options.quality && searchParams.append('q', options.quality.toString());\n    options.format && searchParams.append('f', options.format);\n    return `/my_custom_endpoint_that_transforms_images?${searchParams}`;\n    // Or use the built-in endpoint, which will call your parseURL and transform functions:\n    // return `/_image?${searchParams}`;\n  },\n  parseURL(url: URL, imageConfig) {\n    return {\n      src: params.get('href')!,\n      width: params.has('w') ? parseInt(params.get('w')!) : undefined,\n      height: params.has('h') ? parseInt(params.get('h')!) : undefined,\n      format: params.get('f'),\n      quality: params.get('q'),\n    };\n  },\n  transform(buffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig): { data: Uint8Array, format: OutputFormat } {\n    const { buffer } = mySuperLibraryThatEncodesImages(options);\n    return {\n      data: buffer,\n      format: options.format,\n    };\n  },\n  getHTMLAttributes(options, imageConfig) {\n    let targetWidth = options.width;\n    let targetHeight = options.height;\n    if (typeof options.src === \"object\") {\n      const aspectRatio = options.src.width / options.src.height;\n\n\n      if (targetHeight && !targetWidth) {\n        targetWidth = Math.round(targetHeight * aspectRatio);\n      } else if (targetWidth && !targetHeight) {\n        targetHeight = Math.round(targetWidth / aspectRatio);\n      }\n    }\n\n\n    const { src, width, height, format, quality, ...attributes } = options;\n\n\n    return {\n      ...attributes,\n      width: targetWidth,\n      height: targetHeight,\n      loading: attributes.loading ?? 'lazy',\n      decoding: attributes.decoding ?? 'async',\n    };\n  }\n};\nexport default service;\n\nAt build time for static sites and pre-rendered routes, both <Image /> and getImage(options) call the transform() function. They pass options either through component attributes or an options argument, respectively. The transformed images will be built to a dist/_astro folder.\n\nIn dev mode and SSR mode, Astro doesn‚Äôt know ahead of time which images need to be optimized. Astro uses a GET endpoint (by default, /_image) to process the images at runtime. <Image /> and getImage() pass their options to getURL(), which will return the endpoint URL. Then, the endpoint calls parseURL() and passes the resulting properties to transform().\n\ngetConfiguredImageService & imageConfig\nSection titled getConfiguredImageService &amp; imageConfig\n\nIf you implement your own endpoint as an Astro endpoint, you can use getConfiguredImageService and imageConfg to call your service‚Äôs parseURL and transform methods and provide the image config.\n\nTo access the image service config (image.service.config), you can use imageConfig.service.config.\n\nsrc/api/my_custom_endpoint_that_transforms_images.ts\nimport type { APIRoute } from \"astro\";\nimport { getConfiguredImageService, imageConfig } from 'astro:assets';\n\n\nexport const GET: APIRoute = async ({ request }) => {\n  const imageService = await getConfiguredImageService();\n\n\n  const imageTransform = imageService.parseURL(new URL(request.url), imageConfig);\n  // ... fetch the image from imageTransform.src and store it in inputBuffer\n  const { data, format } = await imageService.transform(inputBuffer, imageTransform, imageConfig);\n  return new Response(data, {\n      status: 200,\n      headers: {\n        'Content-Type': mime.getType(format) || ''\n      }\n    }\n  );\n}\n\nSee the built-in endpoint for a full example.\n\nHooks\nSection titled Hooks\ngetURL()\nSection titled getURL()\n\nRequired for local and external services\n\ngetURL(options: ImageTransform, imageConfig: AstroConfig['image']): string\n\nFor local services, this hook returns the URL of the endpoint that generates your image (in SSR and dev mode). It is unused during build. The local endpoint that getURL() points to may call both parseURL() and transform().\n\nFor external services, this hook returns the final URL of the image.\n\nFor both types of services, options are the properties passed by the user as attributes of the <Image /> component or as options to getImage(). They are of the following type:\n\nexport type ImageTransform = {\n    // ESM imported images | remote/public image paths\n    src: ImageMetadata | string;\n    width?: number;\n    height?: number;\n    widths?: number[] | undefined;\n    densities?: (number | `${number}x`)[] | undefined;\n    quality?: ImageQuality;\n    format?: OutputFormat;\n    alt?: string;\n    [key: string]: any;\n};\nparseURL()\nSection titled parseURL()\n\nRequired for local services; unavailable for external services\n\nparseURL(url: URL, imageConfig: AstroConfig['image']): { src: string, [key: string]: any}\n\nThis hook parses the generated URLs by getURL() back into an object with the different properties to be used by transform (in SSR and dev mode). It is unused during build.\n\ntransform()\nSection titled transform()\n\nRequired for local services only; unavailable for external services\n\ntransform(buffer: Uint8Array, options: { src: string, [key: string]: any }, imageConfig: AstroConfig['image']): { data: Uint8Array, format: OutputFormat }\n\nThis hook transforms and returns the image and is called during the build to create the final asset files.\n\nYou must return a format to ensure that the proper MIME type is served to users in SSR and development mode.\n\ngetHTMLAttributes()\nSection titled getHTMLAttributes()\n\nOptional for both local and external services\n\ngetHTMLAttributes(options: ImageTransform, imageConfig: AstroConfig['image']): Record<string, any>\n\nThis hook returns all additional attributes used to render the image as HTML, based on the parameters passed by the user (options).\n\ngetSrcSet()\nSection titled getSrcSet()\nAdded in: astro@3.3.0 EXPERIMENTAL\n\nOptional for both local and external services.\n\ngetSrcSet?: (options: ImageTransform, imageConfig: AstroConfig['image']): SrcSetValue[] | Promise<SrcSetValue[]>;\n\nThis hook generates multiple variants of the specified image, for example, to generate a srcset attribute on an <img> or <picture>‚Äôs source.\n\nThis hook returns an array of objects with the following properties:\n\nexport type SrcSetValue = {\n  transform: ImageTransform;\n  descriptor?: string;\n  attributes?: Record<string, any>;\n};\nvalidateOptions()\nSection titled validateOptions()\n\nOptional for both local and external services\n\nvalidateOptions(options: ImageTransform, imageConfig: AstroConfig['image']): ImageTransform\n\nThis hook allows you to validate and augment the options passed by the user. This is useful for setting default options, or telling the user that a parameter is required.\n\nSee how validateOptions() is used in Astro built-in services.\n\nUser configuration\nSection titled User configuration\n\nConfigure the image service to use in astro.config.mjs. The config takes the following form:\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\n\n\nexport default defineConfig({\n  image: {\n    service: {\n      entrypoint: \"your-entrypoint\", // 'astro/assets/services/squoosh' | 'astro/assets/services/sharp' | string,\n      config: {\n        // ... service-specific config. Optional.\n      }\n    }\n  },\n});\nBack\nAdapter API\nNext Page\nDev Overlay Plugin API"
  },
  {
    "title": "Astro Integration API üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/integrations-reference/",
    "html": "Astro Integration API\n\nAstro Integrations add new functionality and behaviors for your project with only a few lines of code.\n\nThis reference page is for anyone writing their own integration. To learn how to use an integration in your project, check out our Using Integrations guide instead.\n\nExamples\nSection titled Examples\n\nThe official Astro integrations can act as reference for you as you go to build your own integrations.\n\nRenderers: lit, svelte, react, preact, vue, solid\nLibraries: tailwind, partytown\nFeatures: sitemap\nQuick API Reference\nSection titled Quick API Reference\ninterface AstroIntegration {\n  name: string;\n  hooks: {\n    'astro:config:setup'?: (options: {\n      config: AstroConfig;\n      command: 'dev' | 'build';\n      isRestart: boolean;\n      updateConfig: (newConfig: Record<string, any>) => void;\n      addRenderer: (renderer: AstroRenderer) => void;\n      addWatchFile: (path: URL | string) => void;\n      addClientDirective: (directive: ClientDirectiveConfig) => void;\n      addMiddleware: (middleware: AstroIntegrationMiddleware) => void;\n      addDevOverlayPlugin: (pluginEntrypoint: string) => void;\n      injectScript: (stage: InjectedScriptStage, content: string) => void;\n      injectRoute: ({ pattern: string, entryPoint: string }) => void;\n      logger: AstroIntegrationLogger;\n    }) => void;\n    'astro:config:done'?: (options: { config: AstroConfig; logger: AstroIntegrationLogger; }) => void | Promise<void>;\n    'astro:server:setup'?: (options: { server: vite.ViteDevServer; logger: AstroIntegrationLogger; }) => void | Promise<void>;\n    'astro:server:start'?: (options: { address: AddressInfo; logger: AstroIntegrationLogger; }) => void | Promise<void>;\n    'astro:server:done'?: (options: { logger: AstroIntegrationLogger; }) => void | Promise<void>;\n    'astro:build:start'?: (options: { logger: AstroIntegrationLogger; }) => void | Promise<void>;\n    'astro:build:setup'?: (options: {\n      vite: ViteConfigWithSSR;\n      pages: Map<string, PageBuildData>;\n      target: 'client' | 'server';\n      logger: AstroIntegrationLogger;\n    }) => void | Promise<void>;\n    'astro:build:generated'?: (options: { dir: URL; logger: AstroIntegrationLogger; }) => void | Promise<void>;\n    'astro:build:ssr'?: (options: {\n        manifest: SerializedSSRManifest;\n        entryPoints: Map<RouteData, URL>;\n        logger: AstroIntegrationLogger;\n    }) => void | Promise<void>;\n    'astro:build:done'?: (options: { dir: URL; routes: RouteData[]; logger: AstroIntegrationLogger; }) => void | Promise<void>;\n  };\n}\nHooks\nSection titled Hooks\nastro:config:setup\nSection titled astro:config:setup\n\nNext hook: astro:config:done\n\nWhen: On initialization, before either the Vite or Astro config have resolved.\n\nWhy: To extend the project config. This includes updating the Astro config, applying Vite plugins, adding component renderers, and injecting scripts onto the page.\n\n'astro:config:setup'?: (options: {\n  config: AstroConfig;\n  command: 'dev' | 'build';\n  isRestart: boolean;\n  updateConfig: (newConfig: Record<string, any>) => void;\n  addRenderer: (renderer: AstroRenderer) => void;\n  addClientDirective: (directive: ClientDirectiveConfig) => void;\n  addMiddleware: (middleware: AstroIntegrationMiddleware) => void;\n  addDevOverlayPlugin: (pluginEntrypoint: string) => void;\n  addWatchFile: (path: URL | string) => void;\n  injectScript: (stage: InjectedScriptStage, content: string) => void;\n  injectRoute: ({ pattern: string, entryPoint: string }) => void;\n  logger: AstroIntegrationLogger;\n}) => void;\nconfig option\nSection titled config option\n\nType: AstroConfig\n\nA read-only copy of the user-supplied Astro config. This is resolved before any other integrations have run. If you need a copy of the config after all integrations have completed their config updates, see the astro:config:done hook.\n\ncommand option\nSection titled command option\n\nType: 'dev' / 'build'\n\ndev - Project is executed with astro dev or astro preview\nbuild - Project is executed with astro build\nisRestart option\nSection titled isRestart option\n\nType: boolean\n\nfalse when the dev server starts, true when a reload is triggered. Useful to detect when this function is called more than once.\n\nupdateConfig option\nSection titled updateConfig option\n\nType: (newConfig: Record<string, any>) => void;\n\nA callback function to update the user-supplied Astro config. Any config you provide will be merged with the user config + other integration config updates, so you are free to omit keys!\n\nFor example, say you need to supply a Vite plugin to the user‚Äôs project:\n\nimport bananaCSS from '@vitejs/official-banana-css-plugin';\n\n\nexport default {\n  name: 'banana-css-integration',\n  hooks: {\n    'astro:config:setup': ({ updateConfig }) => {\n      updateConfig({\n        vite: {\n          plugins: [bananaCSS()],\n        }\n      })\n    }\n  }\n}\naddRenderer option\nSection titled addRenderer option\n\nType: (renderer: AstroRenderer ) => void; Examples: lit, svelte, react, preact, vue, solid\n\nA callback function to add a component framework renderer (i.e. React, Vue, Svelte, etc). You can browse the examples and type definition above for more advanced options, but here are the 2 main options to be aware of:\n\nclientEntrypoint - path to a file that executes on the client whenever your component is used. This is mainly for rendering or hydrating your component with JS.\nserverEntrypoint - path to a file that executes during server-side requests or static builds whenever your component is used. These should render components to static markup, with hooks for hydration where applicable. React‚Äôs renderToString callback is a classic example.\naddWatchFile option\nSection titled addWatchFile option\n\nType: URL | string\n\nIf your integration depends on some configuration file that Vite doesn‚Äôt watch and/or needs a full dev server restart to take effect, add it with addWatchFile. Whenever that file changes, the Astro dev server will be reloaded (you can check when a reload happens with isRestart).\n\nExample usage:\n\n// Must be an absolute path!\naddWatchFile('/home/user/.../my-config.json');\naddWatchFile(new URL('./tailwind.config.js', config.root));\naddClientDirective option\nSection titled addClientDirective option\nAdded in: astro@2.6.0\n\nType: (directive: ClientDirectiveConfig ) => void;\n\nAdds a custom client directive to be used in .astro files.\n\nNote that directive entrypoints are only bundled through esbuild and should be kept small so they don‚Äôt slow down component hydration.\n\nExample usage:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport clickDirective from './astro-click-directive/register.js'\n\n\n// https://astro.build/config\nexport default defineConfig({\n  integrations: [\n    clickDirective()\n  ],\n});\nastro-click-directive/register.js\n/**\n * @type {() => import('astro').AstroIntegration}\n */\nexport default () => ({\n  name: \"client:click\",\n  hooks: {\n    \"astro:config:setup\": ({ addClientDirective }) => {\n      addClientDirective({\n        name: \"click\",\n        entrypoint: \"./astro-click-directive/click.js\",\n      });\n    },\n  },\n});\nastro-click-directive/click.js\n/**\n * Hydrate on first click on the window\n * @type {import('astro').ClientDirective}\n */\nexport default (load, opts, el) => {\n  window.addEventListener('click', async () => {\n    const hydrate = await load()\n    await hydrate()\n  }, { once: true })\n}\n\nYou can also add types for the directives in your library‚Äôs type definition file:\n\nastro-click-directive/index.d.ts\nimport 'astro'\ndeclare module 'astro' {\n  interface AstroClientDirectives {\n    'client:click'?: boolean\n  }\n}\naddDevOverlayPlugin option\nSection titled addDevOverlayPlugin option\nAdded in: astro@3.4.0\n\nType: (pluginEntrypoint: string) => void;\n\nAdds a custom dev overlay plugin.\n\nExample usage:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport devOverlayIntegration from './astro-dev-overlay-plugin/integration.js'\n\n\n// https://astro.build/config\nexport default defineConfig({\n  integrations: [\n    devOverlayIntegration()\n  ],\n});\nastro-dev-overlay-plugin/integration.js\n/**\n * @type {() => import('astro').AstroIntegration}\n */\nexport default () => ({\n  name: \"dev-overlay-plugin\",\n  hooks: {\n    \"astro:config:setup\": ({ addDevOverlayPlugin }) => {\n      addDevOverlayPlugin(\"./astro-dev-overlay-plugin/plugin.js\");\n    },\n  },\n});\nastro-dev-overlay-plugin/plugin.js\n/**\n * @type {import('astro').DevOverlayPlugin}\n */\nexport default {\n  id: \"my-plugin\",\n  name: \"My Plugin\",\n  icon: \"<svg>...</svg>\",\n  init() {\n    console.log(\"I'm a dev overlay plugin!\")\n  },\n};\naddMiddleware option\nSection titled addMiddleware option\nAdded in: astro@3.5.0\n\nType: (middleware: AstroIntegrationMiddleware ) => void;\n\nAdds middleware to run on each request. Takes the entrypoint module that contains the middleware, and an order to specify whether it should run before (pre) other middleware or after (post).\n\n@my-package/integration.js\n/**\n * @type {() => import('astro').AstroIntegration}\n */\nexport default () => ({\n  name: \"my-middleware-package\",\n  hooks: {\n    \"astro:config:setup\": ({ addMiddleware }) => {\n        addMiddleware({\n          entrypoint: '@my-package/middleware',\n          order: 'pre'\n        });\n    },\n  },\n});\n\nMiddleware is defined in a package with an onRequest function, as with user-defined middleware.\n\n@my-package/middleware.js\nimport { defineMiddleware } from 'astro:middleware';\n\n\nexport const onRequest = defineMiddleware(async (context, request) => {\n  if(context.url.pathname === '/some-test-path') {\n    return Response.json({\n      ok: true\n    });\n  }\n});\ninjectRoute option\nSection titled injectRoute option\n\nType: ({ pattern: string, entryPoint: string }) => void;\n\nA callback function to inject routes into an Astro project. Injected routes can be .astro pages or .js and .ts route handlers.\n\ninjectRoute takes an object with a pattern and an entryPoint.\n\npattern - where the route should be output in the browser, for example /foo/bar. A pattern can use Astro‚Äôs filepath syntax for denoting dynamic routes, for example /foo/[bar] or /foo/[...bar]. Note that a file extension is not needed in the pattern.\nentryPoint - a bare module specifier pointing towards the .astro page or .js/.ts route handler that handles the route denoted in the pattern.\nExample usage\nSection titled Example usage\ninjectRoute({\n  // Use Astro‚Äôs pattern syntax for dynamic routes.\n  pattern: '/subfolder/[dynamic]',\n  // Use relative path syntax for a local route.\n  entryPoint: './src/dynamic-page.astro'\n});\n\nFor an integration designed to be installed in other projects, use its package name to refer to the route entrypoint. The following example shows a package published to npm as @fancy/dashboard injecting a dashboard route:\n\ninjectRoute({\n  pattern: '/fancy-dashboard',\n  entryPoint: '@fancy/dashboard/dashboard.astro'\n});\ninjectScript option\nSection titled injectScript option\n\nType: (stage: InjectedScriptStage, content: string) => void;\n\nA callback function to inject a string of JavaScript content onto every page.\n\nThe stage denotes how this script (the content) should be inserted. Some stages allow inserting scripts without modification, while others allow optimization during Vite‚Äôs bundling step:\n\n\"head-inline\": Injected into a script tag in the <head> of every page. Not optimized or resolved by Vite.\n\n\"before-hydration\": Imported client-side, before the hydration script runs. Optimized and resolved by Vite.\n\n\"page\": Similar to head-inline, except that the injected snippet is handled by Vite and bundled with any other <script> tags defined inside of Astro components on the page. The script will be loaded with a <script type=\"module\"> in the final page output, optimized and resolved by Vite.\n\n\"page-ssr\": Imported as a separate module in the frontmatter of every Astro page component. Because this stage imports your script, the Astro global is not available and your script will only be run once when the import is first evaluated.\n\nThe main use for the page-ssr stage is injecting a CSS import into every page to be optimized and resolved by Vite:\n\ninjectScript('page-ssr', 'import \"global-styles.css\";');\nastro:config:done\nSection titled astro:config:done\n\nPrevious hook: astro:config:setup\n\nNext hook: astro:server:setup when running in ‚Äúdev‚Äù mode, or astro:build:start during production builds\n\nWhen: After the Astro config has resolved and other integrations have run their astro:config:setup hooks.\n\nWhy: To retrieve the final config for use in other hooks.\n\n'astro:config:done'?: (options: { config: AstroConfig }) => void | Promise<void>;\nconfig option\nSection titled config option\n\nType: AstroConfig\n\nA read-only copy of the user-supplied Astro config. This is resolved after other integrations have run.\n\nastro:server:setup\nSection titled astro:server:setup\n\nPrevious hook: astro:config:done\n\nNext hook: astro:server:start\n\nWhen: Just after the Vite server is created in ‚Äúdev‚Äù mode, but before the listen() event is fired. See Vite‚Äôs createServer API for more.\n\nWhy: To update Vite server options and middleware.\n\n'astro:server:setup'?: (options: { server: vite.ViteDevServer }) => void | Promise<void>;\nserver option\nSection titled server option\n\nType: ViteDevServer\n\nA mutable instance of the Vite server used in ‚Äúdev‚Äù mode. For instance, this is used by our Partytown integration to inject the Partytown server as middleware:\n\nexport default {\n  name: 'partytown',\n  hooks: {\n    'astro:server:setup': ({ server }) => {\n      server.middlewares.use(\n        function middleware(req, res, next) {\n          // handle requests\n        }\n      );\n    }\n  }\n}\nastro:server:start\nSection titled astro:server:start\n\nPrevious hook: astro:server:setup\n\nNext hook: astro:server:done\n\nWhen: Just after the server‚Äôs listen() event has fired.\n\nWhy: To intercept network requests at the specified address. If you intend to use this address for middleware, consider using astro:server:setup instead.\n\n'astro:server:start'?: (options: { address: AddressInfo }) => void | Promise<void>;\naddress option\nSection titled address option\n\nType: AddressInfo\n\nThe address, family and port number supplied by the NodeJS Net module.\n\nastro:server:done\nSection titled astro:server:done\n\nPrevious hook: astro:server:start\n\nWhen: Just after the dev server is closed.\n\nWhy: To run any cleanup events you may trigger during the astro:server:setup or astro:server:start hooks.\n\n'astro:server:done'?: () => void | Promise<void>;\nastro:build:start\nSection titled astro:build:start\n\nPrevious hook: astro:config:done\n\nNext hook: astro:build:setup\n\nWhen: After the astro:config:done event, but before the production build begins.\n\nWhy: To set up any global objects or clients needed during a production build. This can also extend the build configuration options in the adapter API.\n\n'astro:build:start'?: () => void | Promise<void>;\nastro:build:setup\nSection titled astro:build:setup\n\nPrevious hook: astro:build:start\n\nNext hook: astro:build:ssr\n\nWhen: After the astro:build:start hook, runs immediately before the build.\n\nWhy: At this point, the Vite config for the build has been completely constructed, this is your final chance to modify it. This can be useful for example to overwrite some defaults. If you‚Äôre not sure whether you should use this hook or astro:build:start, use astro:build:start instead.\n\n'astro:build:setup'?: (options: {\n  vite: ViteConfigWithSSR;\n  pages: Map<string, PageBuildData>;\n  target: 'client' | 'server';\n}) => void | Promise<void>;\nastro:build:generated\nSection titled astro:build:generated\n\nPrevious hook: astro:build:setup\n\nWhen: After a static production build has finished generating routes and assets.\n\nWhy: To access generated routes and assets before build artifacts are cleaned up. This is a very uncommon use case. We recommend using astro:build:done unless you really need to access the generated files before cleanup.\n\n'astro:build:generated'?: (options: { dir: URL }) => void | Promise<void>;\nastro:build:ssr\nSection titled astro:build:ssr\n\nPrevious hook: astro:build:setup\n\nWhen: After a production SSR build has completed.\n\nWhy: To access the SSR manifest and map of the emitted entry points. This is useful when creating custom SSR builds in plugins or integrations.\n\nentryPoints maps a page route to the physical file emitted after the build;\nmiddlewareEntryPoint is the file system path of the middleware file;\n'astro:build:ssr'?: (options: {\n    manifest: SerializedSSRManifest,\n    entryPoints: Map<RouteData, URL>,\n    middlewareEntryPoint: URL\n}) => void | Promise<void>;\nastro:build:done\nSection titled astro:build:done\n\nPrevious hook: astro:build:ssr\n\nWhen: After a production build (SSG or SSR) has completed.\n\nWhy: To access generated routes and assets for extension (ex. copy content into the generated /assets directory). If you plan to transform generated assets, we recommend exploring the Vite Plugin API and configuring via astro:config:setup instead.\n\n'astro:build:done'?: (options: { dir: URL; routes: RouteData[], pages: { pathname: string }[] }) => void | Promise<void>;\ndir option\nSection titled dir option\n\nType: URL\n\nA URL path to the build output directory. Note that if you need a valid absolute path string, you should use Node‚Äôs built-in fileURLToPath utility.\n\nimport { writeFile } from 'node:fs/promises';\nimport { fileURLToPath } from 'node:url';\n\n\nexport default function myIntegration() {\n  return {\n    hooks: {\n      'astro:build:done': async ({ dir }) => {\n        const metadata = await getIntegrationMetadata();\n        // Use fileURLToPath to get a valid, cross-platform absolute path string\n        const outFile = fileURLToPath(new URL('./my-integration.json', dir));\n        await writeFile(outFile, JSON.stringify(metadata));\n      }\n    }\n  }\n}\nroutes option\nSection titled routes option\n\nType: RouteData[]\n\nA list of all generated routes alongside their associated metadata.\n\nYou can reference the full RouteData type below, but the most common properties are:\n\ncomponent - the input file path relative to the project root\npathname - the output file URL (undefined for routes using [dynamic] and [...spread] params)\nRouteData type reference\nSection titled RouteData type reference\ninterface RouteData {\n  /** Whether a given route is an HTML page or non-HTML endpoint */\n  type: 'page' | 'endpoint';\n  /** Source component URL */\n  component: string;\n  /**\n   * Output URL pathname where this route will be served\n   * note: will be undefined for [dynamic] and [...spread] routes\n   */\n  pathname?: string;\n  /**\n   * regex used for matching an input URL against a requested route\n   * ex. \"[fruit]/about.astro\" will generate the pattern: /^\\/([^/]+?)\\/about\\/?$/\n   * where pattern.test(\"banana/about\") is \"true\"\n   */\n  pattern: RegExp;\n  /**\n   * Dynamic and spread route params\n   * ex. \"/pages/[lang]/[..slug].astro\" will output the params ['lang', '...slug']\n   */\n  params: string[];\n  /**\n   * Similar to the \"params\" field, but with more associated metadata\n   * ex. \"/pages/[lang]/index.astro\" will output the segments\n   * [[ { content: 'lang', dynamic: true, spread: false } ]]\n   */\n  segments: { content: string; dynamic: boolean; spread: boolean; }[][];\n  /**\n   * Function to render component in-place from a set of input data.\n   * This is typically for internal use, so call with caution!\n   */\n  generate: (data?: any) => string;\n}\npages option\nSection titled pages option\n\nType: { pathname: string }[]\n\nA list of all generated pages. It is an object with one property.\n\npathname - the finalized path of the page.\nAllow installation with astro add\nSection titled Allow installation with astro add\n\nThe astro add command allows users to easily add integrations and adapters to their project. If you want your integration to be installable with this tool, add astro-integration to the keywords field in your package.json:\n\n{\n  \"name\": \"example\",\n  \"keywords\": [\"astro-integration\"],\n}\n\nOnce you publish your integration to npm, running astro add example will install your package with any peer dependencies specified in your package.json. This will also apply your integration to the user‚Äôs astro.config like so:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n import example from 'example';\n\n\nexport default defineConfig({\n  integrations: [example()],\n})\n\n CAUTION\n\nThis assumes your integration definition is 1) a default export and 2) a function. Ensure this is true before adding the astro-integration keyword!\n\nAstroIntegrationLogger\nSection titled AstroIntegrationLogger\n\nAn instance of the Astro logger, useful to write logs. This logger uses the same log level configured via CLI.\n\nMethods available to write to terminal:\n\nlogger.info(\"Message\");\nlogger.warn(\"Message\");\nlogger.error(\"Message\");\nlogger.debug(\"Message\");\n\nAll the messages are prepended with a label that has the same value of the integration.\n\nintegration.ts\nimport type { AstroIntegration } from \"astro\";\nexport function formatIntegration(): AstroIntegration {\n    return {\n        name: \"astro-format\",\n        hooks: {\n            \"astro:build:done\": ({ logger }) => {\n                // do something\n                logger.info(\"Integration ready.\");\n            }\n        }\n    }\n}\n\nThe example above will log a message that includes the provided info message:\n\nTerminal window\n[astro-format] Integration ready.\n\nTo log some messages with a different label, use the .fork method to specify an alternative to the default name:\n\nintegration.ts\nimport type { AstroIntegration } from \"astro\";\nexport function formatIntegration(): AstroIntegration {\n    return {\n        name: \"astro-format\",\n        hooks: {\n            \"astro:config:done\": ({ logger }) => {\n                // do something\n                logger.info(\"Integration ready.\");\n            },\n            \"astro:build:done\": ({ logger }) => {\n                const buildLogger = logger.fork(\"astro-format/build\");\n                // do something\n                buildLogger.info(\"Build finished.\")\n            }\n        }\n    }\n}\n\nThe example above will produce logs with [astro-format] by default, and [astro-format/build] when specified:\n\nTerminal window\n[astro-format] Integration ready.\n[astro-format/build] Build finished.\nIntegration Ordering\nSection titled Integration Ordering\n\nAll integrations are run in the order that they are configured. For instance, for the array [react(), svelte()] in a user‚Äôs astro.config.*, react will run before svelte.\n\nYour integration should ideally run in any order. If this isn‚Äôt possible, we recommend documenting that your integration needs to come first or last in your user‚Äôs integrations configuration array.\n\nCombine integrations into presets\nSection titled Combine integrations into presets\n\nAn integration can also be written as a collection of multiple, smaller integrations. We call these collections presets. Instead of creating a factory function that returns a single integration object, a preset returns an array of integration objects. This is useful for building complex features out of multiple integrations.\n\nintegrations: [\n  // Example: where examplePreset() returns: [integrationOne, integrationTwo, ...etc]\n  examplePreset()\n]\nCommunity Resources\nSection titled Community Resources\n\nBuild your own Astro Integrations - by Emmanuel Ohans on FreeCodeCamp\n\nBack\nRuntime API\nNext Page\nAdapter API"
  },
  {
    "title": "API Reference üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/api-reference/",
    "html": "API Reference\nAstro global\nSection titled Astro global\n\nThe Astro global is available in all contexts in .astro files. It has the following functions:\n\nAstro.glob()\nSection titled Astro.glob()\n\nAstro.glob() is a way to load many local files into your static site setup.\n\nsrc/components/my-component.astro\n---\nconst posts = await Astro.glob('../pages/post/*.md'); // returns an array of posts that live at ./src/pages/post/*.md\n---\n\n\n<div>\n{posts.slice(0, 3).map((post) => (\n  <article>\n    <h2>{post.frontmatter.title}</h2>\n    <p>{post.frontmatter.description}</p>\n    <a href={post.url}>Read more</a>\n  </article>\n))}\n</div>\n\n.glob() only takes one parameter: a relative URL glob of which local files you‚Äôd like to import. It‚Äôs asynchronous, and returns an array of the exports from matching files.\n\n.glob() can‚Äôt take variables or strings that interpolate them, as they aren‚Äôt statically analyzable. (See the troubleshooting guide for a workaround.) This is because Astro.glob() is a wrapper of Vite‚Äôs import.meta.glob().\n\n NOTE\n\nYou can also use import.meta.glob() itself in your Astro project. You may want to do this when:\n\nYou need this feature in a file that isn‚Äôt .astro, like an API route. Astro.glob() is only available in .astro files, while import.meta.glob() is available anywhere in the project.\nYou don‚Äôt want to load each file immediately. import.meta.glob() can return functions that import the file content, rather than returning the content itself. Note that this import includes all styles and scripts for any imported files. These will be bundled and added to the page whether or not a file is actually used, as this is decided by static analysis, not at runtime.\nYou want access to each file‚Äôs path. import.meta.glob() returns a map of a file‚Äôs path to its content, while Astro.glob() returns a list of content.\nYou want to pass multiple patterns; for example, you want to add a ‚Äúnegative pattern‚Äù that filters out certain files. import.meta.glob() can optionally take an array of glob strings, rather than a single string.\n\nRead more in the Vite documentation.\n\nMarkdown Files\nSection titled Markdown Files\n\nMarkdown files have the following interface:\n\nexport interface MarkdownInstance<T extends Record<string, any>> {\n  /* Any data specified in this file's YAML frontmatter */\n  frontmatter: T;\n  /* The file path of this file */\n  file: string;\n  /* The rendered path of this file */\n  url: string | undefined;\n  /* Astro Component that renders the contents of this file */\n  Content: AstroComponent;\n  /* Function that returns an array of the h1...h6 elements in this file */\n  getHeadings(): Promise<{ depth: number; slug: string; text: string }[]>;\n}\n\nYou can optionally provide a type for the frontmatter variable using a TypeScript generic.\n\n---\ninterface Frontmatter {\n  title: string;\n  description?: string;\n}\nconst posts = await Astro.glob<Frontmatter>('../pages/post/*.md');\n---\n\n\n<ul>\n  {posts.map(post => <li>{post.frontmatter.title}</li>)}\n</ul>\nAstro Files\nSection titled Astro Files\n\nAstro files have the following interface:\n\nexport interface AstroInstance {\n  /* The file path of this file */\n  file: string;\n  /* The URL for this file (if it is in the pages directory) */\n  url: string | undefined;\n  default: AstroComponent;\n}\nOther Files\nSection titled Other Files\n\nOther files may have various different interfaces, but Astro.glob() accepts a TypeScript generic if you know exactly what an unrecognized file type contains.\n\n---\ninterface CustomDataFile {\n  default: Record<string, any>;\n}\nconst data = await Astro.glob<CustomDataFile>('../data/**/*.js');\n---\nAstro.props\nSection titled Astro.props\n\nAstro.props is an object containing any values that have been passed as component attributes. Layout components for .md and .mdx files receive frontmatter values as props.\n\nsrc/components/Heading.astro\n---\nconst { title, date } = Astro.props;\n---\n<div>\n  <h1>{title}</h1>\n  <p>{date}</p>\n</div>\nsrc/pages/index.astro\n---\nimport Heading from '../components/Heading.astro';\n---\n<Heading title=\"My First Post\" date=\"09 Aug 2022\" />\n\nüìö Learn more about how Markdown and MDX Layouts handle props.\n\nüìö Learn how to add TypeScript type definitions for your props.\n\nAstro.params\nSection titled Astro.params\n\nAstro.params is an object containing the values of dynamic route segments matched for this request.\n\nIn static builds, this will be the params returned by getStaticPaths() used for prerendering dynamic routes.\n\nIn SSR builds, this can be any value matching the path segments in the dynamic route pattern.\n\nsrc/pages/posts/[id].astro\n---\nexport function getStaticPaths() {\n  return [\n    { params: { id: '1' } },\n    { params: { id: '2' } },\n    { params: { id: '3' } }\n  ];\n}\n\n\nconst { id } = Astro.params;\n---\n<h1>{id}</h1>\n\nSee also: params\n\nAstro.request\nSection titled Astro.request\n\nAstro.request is a standard Request object. It can be used to get the url, headers, method, and even body of the request.\n\n<p>Received a {Astro.request.method} request to \"{Astro.request.url}\".</p>\n<p>Received request headers: <code>{JSON.stringify(Object.fromEntries(Astro.request.headers))}</code>\n\nSee also: Astro.url\n\n NOTE\n\nWith the default output: 'static' option, Astro.request.url does not contain search parameters, like ?foo=bar, as it‚Äôs not possible to determine them ahead of time during static builds. However in output: 'server' mode, Astro.request.url does contain search parameters as it can be determined from a server request.\n\nAstro.response\nSection titled Astro.response\n\nAstro.response is a standard ResponseInit object. It has the following structure.\n\nstatus: The numeric status code of the response, e.g., 200.\nstatusText: The status message associated with the status code, e.g., 'OK'.\nheaders: A Headers instance that you can use to set the HTTP headers of the response.\n\nAstro.response is used to set the status, statusText, and headers for a page‚Äôs response.\n\n---\nif(condition) {\n  Astro.response.status = 404;\n  Astro.response.statusText = 'Not found';\n}\n---\n\nOr to set a header:\n\n---\nAstro.response.headers.set('Set-Cookie', 'a=b; Path=/;');\n---\nAstro.cookies\nSection titled Astro.cookies\nAdded in: astro@1.4.0\n\nAstro.cookies contains utilities for reading and manipulating cookies in server-side rendering mode.\n\nName\tType\tDescription\nget\t(key: string) => AstroCookie\tGets the cookie as an AstroCookie object, which contains the value and utility functions for converting the cookie to non-string types.\nhas\t(key: string) => boolean\tWhether this cookie exists. If the cookie has been set via Astro.cookies.set() this will return true, otherwise it will check cookies in the Astro.request.\nset\t(key: string, value: string | number | boolean | object, options?: CookieOptions) => void\tSets the cookie key to the given value. This will attempt to convert the cookie value to a string. Options provide ways to set cookie features, such as the maxAge or httpOnly.\ndelete\t(key: string, options?: CookieDeleteOptions) => void\tMarks the cookie as deleted. Once a cookie is deleted Astro.cookies.has() will return false and Astro.cookies.get() will return an AstroCookie with a value of undefined. Options allow setting the domain and path of the cookie to delete.\nheaders\t() => Iterator<string>\tGets the header values for Set-Cookie that will be sent out with the response.\nAstroCookie\nSection titled AstroCookie\n\nGetting a cookie via Astro.cookies.get() returns a AstroCookie type. It has the following structure.\n\nName\tType\tDescription\nvalue\tstring | undefined\tThe raw string value of the cookie.\njson\t() => Record<string, any>\tParses the cookie value via JSON.parse(), returning an object. Throws if the cookie value is not valid JSON.\nnumber\t() => number\tParses the cookie value as a Number. Returns NaN if not a valid number.\nboolean\t() => boolean\tConverts the cookie value to a boolean.\nAstro.redirect()\nSection titled Astro.redirect()\n\nAstro.redirect() allows you to redirect to another page. A page (and not a child component) must return the result of Astro.redirect() for the redirect to occur.\n\nsrc/pages/account.astro\n---\nimport { isLoggedIn } from '../utils';\n\n\nconst cookie = Astro.request.headers.get('cookie');\n\n\n// If the user is not logged in, redirect them to the login page\nif (!isLoggedIn(cookie)) {\n  return Astro.redirect('/login');\n}\n---\nAstro.canonicalURL\nSection titled Astro.canonicalURL\n\n DEPRECATED\n\nUse Astro.url to construct your own canonical URL.\n\nThe canonical URL of the current page.\n\nAstro.url\nSection titled Astro.url\nAdded in: astro@1.0.0-rc\n\nA URL object constructed from the current Astro.request.url URL string value. Useful for interacting with individual properties of the request URL, like pathname and origin.\n\nEquivalent to doing new URL(Astro.request.url).\n\n<h1>The current URL is: {Astro.url}</h1>\n<h1>The current URL pathname is: {Astro.url.pathname}</h1>\n<h1>The current URL origin is: {Astro.url.origin}</h1>\n\nYou can also use Astro.url to create new URLs by passing it as an argument to new URL().\n\nsrc/pages/index.astro\n---\n// Example: Construct a canonical URL using your production domain\nconst canonicalURL = new URL(Astro.url.pathname, Astro.site);\n// Example: Construct a URL for SEO meta tags using your current domain\nconst socialImageURL = new URL('/images/preview.png', Astro.url);\n---\n<link rel=\"canonical\" href={canonicalURL} />\n<meta property=\"og:image\" content={socialImageURL} />\nAstro.clientAddress\nSection titled Astro.clientAddress\nAdded in: astro@1.0.0-rc\n\nSpecifies the IP address of the request. This property is only available when building for SSR (server-side rendering) and should not be used for static sites.\n\n---\nconst ip = Astro.clientAddress;\n---\n\n\n<div>Your IP address is: <span class=\"address\">{ ip }</span></div>\nAstro.site\nSection titled Astro.site\n\nAstro.site returns a URL made from site in your Astro config. If site in your Astro config isn‚Äôt defined, Astro.site won‚Äôt be defined.\n\nAstro.generator\nSection titled Astro.generator\nAdded in: astro@1.0.0\n\nAstro.generator is a convenient way to add a <meta name=\"generator\"> tag with your current version of Astro. It follows the format \"Astro v1.x.x\".\n\n<html>\n  <head>\n    <meta name=\"generator\" content={Astro.generator} />\n  </head>\n  <body>\n    <footer>\n      <p>Built with <a href=\"https://astro.build\">{Astro.generator}</a></p>\n    </footer>\n  </body>\n</html>\nAstro.slots\nSection titled Astro.slots\n\nAstro.slots contains utility functions for modifying an Astro component‚Äôs slotted children.\n\nAstro.slots.has()\nSection titled Astro.slots.has()\n\nType: (slotName: string) => boolean\n\nYou can check whether content for a specific slot name exists with Astro.slots.has(). This can be useful when you want to wrap slot contents, but only want to render the wrapper elements when the slot is being used.\n\nsrc/pages/index.astro\n---\n---\n<slot />\n\n\n{Astro.slots.has('more') && (\n  <aside>\n    <h2>More</h2>\n    <slot name=\"more\" />\n  </aside>\n)}\nAstro.slots.render()\nSection titled Astro.slots.render()\n\nType: (slotName: string, args?: any[]) => Promise<string>\n\nYou can asynchronously render the contents of a slot to a string of HTML using Astro.slots.render().\n\n---\nconst html = await Astro.slots.render('default');\n---\n<Fragment set:html={html} />\n\n NOTE\n\nThis is for advanced use cases! In most circumstances, it is simpler to render slot contents with the <slot /> element.\n\nAstro.slots.render() optionally accepts a second argument: an array of parameters that will be forwarded to any function children. This can be useful for custom utility components.\n\nFor example, this <Shout /> component converts its message prop to uppercase and passes it to the default slot:\n\nsrc/components/Shout.astro\n---\nconst message = Astro.props.message.toUpperCase();\nlet html = '';\nif (Astro.slots.has('default')) {\n  html = await Astro.slots.render('default', [message]);\n}\n---\n<Fragment set:html={html} />\n\nA callback function passed as <Shout />‚Äôs child will receive the all-caps message parameter:\n\nsrc/pages/index.astro\n---\nimport Shout from \"../components/Shout.astro\";\n---\n<Shout message=\"slots!\">\n  {(message) => <div>{message}</div>}\n</Shout>\n\n\n<!-- renders as <div>SLOTS!</div> -->\nAstro.self\nSection titled Astro.self\n\nAstro.self allows Astro components to be recursively called. This behaviour lets you render an Astro component from within itself by using <Astro.self> in the component template. This can be helpful for iterating over large data stores and nested data-structures.\n\nNestedList.astro\n---\nconst { items } = Astro.props;\n---\n<ul class=\"nested-list\">\n  {items.map((item) => (\n    <li>\n      <!-- If there is a nested data-structure we render `<Astro.self>` -->\n      <!-- and can pass props through with the recursive call -->\n      {Array.isArray(item) ? (\n        <Astro.self items={item} />\n      ) : (\n        item\n      )}\n    </li>\n  ))}\n</ul>\n\nThis component could then be used like this:\n\n---\nimport NestedList from './NestedList.astro';\n---\n<NestedList items={['A', ['B', 'C'], 'D']} />\n\nAnd would render HTML like this:\n\n<ul class=\"nested-list\">\n  <li>A</li>\n  <li>\n    <ul class=\"nested-list\">\n      <li>B</li>\n      <li>C</li>\n    </ul>\n  </li>\n  <li>D</li>\n</ul>\nAstro.locals\nSection titled Astro.locals\n\nAstro.locals is an object containing any values from the context.locals object from a middleware. Use this to access data returned by middleware in your .astro files.\n\nsrc/pages/Orders.astro\n---\nconst title = Astro.locals.welcomeTitle();\nconst orders = Array.from(Astro.locals.orders.entries());\n---\n<h1>{title}</h1>\n<ul>\n    {orders.map(order => {\n        return <li>{/* do something with each order */}</li>\n    })}\n</ul>\nEndpoint Context\nSection titled Endpoint Context\n\nEndpoint functions receive a context object as the first parameter. It mirrors many of the Astro global properties.\n\nendpoint.json.ts\nimport type { APIContext } from 'astro';\n\n\nexport function GET(context: APIContext) {\n  // ...\n}\ncontext.params\nSection titled context.params\n\ncontext.params is an object containing the values of dynamic route segments matched for this request.\n\nIn static builds, this will be the params returned by getStaticPaths() used for prerendering dynamic routes.\n\nIn SSR builds, this can be any value matching the path segments in the dynamic route pattern.\n\nsrc/pages/posts/[id].json.ts\nimport type { APIContext } from 'astro';\n\n\nexport function getStaticPaths() {\n  return [\n    { params: { id: '1' } },\n    { params: { id: '2' } },\n    { params: { id: '3' } }\n  ];\n}\n\n\nexport function GET({ params }: APIContext) {\n  return {\n    body: JSON.stringify({ id: params.id })\n  };\n}\n\nSee also: params\n\ncontext.props\nSection titled context.props\n\ncontext.props is an object containing any props passed from getStaticPaths(). Because getStaticPaths() is not used when building for SSR (server-side rendering), context.props is only available in static builds.\n\nsrc/pages/posts/[id].json.ts\nimport type { APIContext } from 'astro';\n\n\nexport function getStaticPaths() {\n  return [\n    { params: { id: '1' }, props: { author: 'Blu' } },\n    { params: { id: '2' }, props: { author: 'Erika' } },\n    { params: { id: '3' }, props: { author: 'Matthew' } }\n  ];\n}\n\n\nexport function GET({ props }: APIContext) {\n  return {\n    body: JSON.stringify({ author: props.author }),\n  };\n}\n\nSee also: Data Passing with props\n\ncontext.request\nSection titled context.request\n\nA standard Request object. It can be used to get the url, headers, method, and even body of the request.\n\nimport type { APIContext } from 'astro';\n\n\nexport function GET({ request }: APIContext) {\n  return {\n    body: `Hello ${request.url}`\n  }\n}\n\nSee also: Astro.request\n\ncontext.cookies\nSection titled context.cookies\n\ncontext.cookies contains utilities for reading and manipulating cookies.\n\nSee also: Astro.cookies\n\ncontext.url\nSection titled context.url\n\nA URL object constructed from the current context.request.url URL string value.\n\nSee also: Astro.url\n\ncontext.clientAddress\nSection titled context.clientAddress\n\nSpecifies the IP address of the request. This property is only available when building for SSR (server-side rendering) and should not be used for static sites.\n\nimport type { APIContext } from 'astro';\n\n\nexport function GET({ clientAddress }: APIContext) {\n  return {\n    body: `Your IP address is: ${clientAddress}`\n  }\n}\n\nSee also: Astro.clientAddress\n\ncontext.site\nSection titled context.site\n\ncontext.site returns a URL made from site in your Astro config. If undefined, this will return a URL generated from localhost.\n\nSee also: Astro.site\n\ncontext.generator\nSection titled context.generator\n\ncontext.generator is a convenient way to indicate the version of Astro your project is running. It follows the format \"Astro v1.x.x\".\n\nsrc/pages/site-info.json.ts\nimport type { APIContext } from 'astro';\n\n\nexport function GET({ generator, site }: APIContext) {\n  const body = JSON.stringify({ generator, site });\n  return new Response(body);\n}\n\nSee also: Astro.generator\n\ncontext.redirect()\nSection titled context.redirect()\n\ncontext.redirect() returns a Response object that allows you to redirect to another page. This function is only available when building for SSR (server-side rendering) and should not be used for static sites.\n\nimport type { APIContext } from 'astro';\n\n\nexport function GET({ redirect }: APIContext) {\n  return redirect('/login', 302);\n}\n\nSee also: Astro.redirect()\n\ncontext.locals\nSection titled context.locals\n\ncontext.locals is an object used to store and access arbitrary information during the lifecycle of a request.\n\nMiddleware functions can read and write the values of context.locals:\n\nsrc/middleware.ts\nimport type { MiddlewareResponseHandler } from 'astro';\n\n\nexport const onRequest: MiddlewareResponseHandler = ({ locals }, next) => {\n  if (!locals.title) {\n    locals.title = \"Default Title\";\n  }\n  return next();\n}\n\nAPI endpoints can only read information from context.locals:\n\nsrc/pages/hello.ts\nimport type { APIContext } from 'astro';\n\n\nexport function GET({ locals }: APIContext) {\n  return {\n    body: locals.title // \"Default Title\"\n  }\n}\n\nSee also: Astro.locals\n\ngetStaticPaths()\nSection titled getStaticPaths()\n\nIf a page uses dynamic params in the filename, that component will need to export a getStaticPaths() function.\n\nThis function is required because Astro is a static site builder. That means that your entire site is built ahead of time. If Astro doesn‚Äôt know to generate a page at build time, your users won‚Äôt see it when they visit your site.\n\n---\nexport async function getStaticPaths() {\n  return [\n    { params: { /* required */ }, props: { /* optional */ } },\n    { params: { ... } },\n    { params: { ... } },\n    // ...\n  ];\n}\n---\n<!-- Your HTML template here. -->\n\nThe getStaticPaths() function should return an array of objects to determine which paths will be pre-rendered by Astro.\n\nIt can also be used in static file endpoints for dynamic routing.\n\n CAUTION\n\nThe getStaticPaths() function executes in its own isolated scope once, before any page loads. Therefore you can‚Äôt reference anything from its parent scope, other than file imports. The compiler will warn if you break this requirement.\n\nparams\nSection titled params\n\nThe params key of every returned object tells Astro what routes to build. The returned params must map back to the dynamic parameters and rest parameters defined in your component filepath.\n\nparams are encoded into the URL, so only strings are supported as values. The value for each params object must match the parameters used in the page name.\n\nFor example, suppose that you have a page at src/pages/posts/[id].astro. If you export getStaticPaths from this page and return the following for paths:\n\n---\nexport async function getStaticPaths() {\n  return [\n    { params: { id: '1' } },\n    { params: { id: '2' } },\n    { params: { id: '3' } }\n  ];\n}\n\n\nconst { id } = Astro.params;\n---\n<h1>{id}</h1>\n\nThen Astro will statically generate posts/1, posts/2, and posts/3 at build time.\n\nData Passing with props\nSection titled Data Passing with props\n\nTo pass additional data to each generated page, you can also set a props value on every returned path object. Unlike params, props are not encoded into the URL and so aren‚Äôt limited to only strings.\n\nFor example, suppose that you generate pages based off of data fetched from a remote API. You can pass the full data object to the page component inside of getStaticPaths:\n\n---\nexport async function getStaticPaths() {\n  const data = await fetch('...').then(response => response.json());\n\n\n  return data.map((post) => {\n    return {\n      params: { id: post.id },\n      props: { post },\n    };\n  });\n}\n\n\nconst { id } = Astro.params;\nconst { post } = Astro.props;\n---\n<h1>{id}: {post.name}</h1>\n\nYou can also pass a regular array, which may be helpful when generating or stubbing a known list of routes.\n\n---\nexport async function getStaticPaths() {\n  const posts = [\n    {id: '1', category: \"astro\", title: \"API Reference\"},\n    {id: '2', category: \"react\", title: \"Creating a React Counter!\"}\n  ];\n  return posts.map((post) => {\n    return {\n      params: { id: post.id },\n      props: { post }\n    };\n  });\n}\nconst {id} = Astro.params;\nconst {post} = Astro.props;\n---\n<body>\n  <h1>{id}: {post.title}</h1>\n  <h2>Category: {post.category}</h2>\n</body>\n\nThen Astro will statically generate posts/1 and posts/2 at build time using the page component in pages/posts/[id].astro. The page can reference this data using Astro.props:\n\npaginate()\nSection titled paginate()\n\nPagination is a common use-case for websites that Astro natively supports via the paginate() function. paginate() will automatically generate the array to return from getStaticPaths() that creates one URL for every page of the paginated collection. The page number will be passed as a param, and the page data will be passed as a page prop.\n\nexport async function getStaticPaths({ paginate }) {\n  // Load your data with fetch(), Astro.glob(), etc.\n  const response = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=150`);\n  const result = await response.json();\n  const allPokemon = result.results;\n\n\n  // Return a paginated collection of paths for all posts\n  return paginate(allPokemon, { pageSize: 10 });\n}\n\n\n// If set up correctly, The page prop¬†now has everything that\n// you need to render a single page (see next section).\nconst { page } = Astro.props;\n\npaginate() assumes a file name of [page].astro or [...page].astro. The page param becomes the page number in your URL:\n\n/posts/[page].astro would generate the URLs /posts/1, /posts/2, /posts/3, etc.\n/posts/[...page].astro would generate the URLs /posts, /posts/2, /posts/3, etc.\n\npaginate() has the following arguments:\n\npageSize - The number of items shown per page\nparams - Send additional parameters for creating dynamic routes\nprops - Send additional props to be available on each page\nThe pagination page prop\nSection titled The pagination page prop\n\nPagination will pass a page prop to every rendered page that represents a single page of data in the paginated collection. This includes the data that you‚Äôve paginated (page.data) as well as metadata for the page (page.url, page.start, page.end, page.total, etc). This metadata is useful for things like a ‚ÄúNext Page‚Äù button or a ‚ÄúShowing 1-10 of 100‚Äù message.\n\nName\tType\tDescription\npage.data\tArray\tArray of data returned from data() for the current page.\npage.start\tnumber\tIndex of first item on current page, starting at 0 (e.g. if pageSize: 25, this would be 0 on page 1, 25 on page 2, etc.).\npage.end\tnumber\tIndex of last item on current page.\npage.size\tnumber\tHow many items per-page.\npage.total\tnumber\tThe total number of items across all pages.\npage.currentPage\tnumber\tThe current page number, starting with 1.\npage.lastPage\tnumber\tThe total number of pages.\npage.url.current\tstring\tGet the URL of the current page (useful for canonical URLs)\npage.url.prev\tstring | undefined\tGet the URL of the previous page (will be undefined if on page 1).\npage.url.next\tstring | undefined\tGet the URL of the next page (will be undefined if no more pages).\nimport.meta\nSection titled import.meta\n\nAll ESM modules include a import.meta property. Astro adds import.meta.env through Vite.\n\nimport.meta.env.SSR can be used to know when rendering on the server. Sometimes you might want different logic, like a component that should only be rendered in the client:\n\nexport default function () {\n  return import.meta.env.SSR ? <div class=\"spinner\"></div> : <FancyComponent />;\n}\nImages (astro:assets)\nSection titled Images (astro:assets)\ngetImage()\nSection titled getImage()\n\n CAUTION\n\ngetImage() relies on server-only APIs and breaks the build when used on the client.\n\nThe getImage() function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an API Route. It also allows you to create your own custom <Image /> component.\n\ngetImage() takes an options object with the same properties as the Image component (except alt).\n\n---\nimport { getImage } from \"astro:assets\";\nimport myBackground from \"../background.png\"\n\n\nconst optimizedBackground = await getImage({src: myBackground, format: 'avif'})\n---\n\n\n<div style={`background-image: url(${optimizedBackground.src});`}></div>\n\nIt returns an object with the following properties:\n\n{\n  options: {...} // Original parameters passed\n  src: \"https//...\" // Path to the generated image\n  attributes: {...} // Additional HTML attributes needed to render the image (width, height, style, etc..)\n}\nContent Collections (astro:content)\nSection titled Content Collections (astro:content)\n\nAdded in: astro@2.0.0\n\nContent collections offer APIs to configure and query your Markdown or MDX documents in src/content/. For features and usage examples, see our content collections guide.\n\ndefineCollection()\nSection titled defineCollection()\n\ndefineCollection() is a utility to configure a collection in a src/content/config.* file.\n\nsrc/content/config.ts\nimport { z, defineCollection } from 'astro:content';\nconst blog = defineCollection({\n  type: 'content',\n  schema: z.object({\n    title: z.string(),\n    permalink: z.string().optional(),\n  }),\n});\n\n\n// Expose your defined collection to Astro\n// with the `collections` export\nexport const collections = { blog };\n\nThis function accepts the following properties:\n\ntype\nSection titled type\nAdded in: astro@2.5\n\nType: 'content' | 'data'\nDefault: 'content'\n\ntype is a string that defines the type of entries stored within a collection:\n\n'content' - for content-authoring formats like Markdown (.md), MDX (.mdx), or Markdoc (.mdoc)\n'data' - for data-only formats like JSON (.json) or YAML (.yaml)\n\n TIP\n\nThis means collections cannot store a mix of content and data formats. You must split these entries into separate collections by type.\n\nschema\nSection titled schema\n\nType: TSchema extends ZodType\n\nschema is an optional Zod object to configure the type and shape of document frontmatter for a collection. Each value must use a Zod validator.\n\nSee the Content Collection guide for example usage.\n\nreference()\nSection titled reference()\n\nType: (collection: string) => ZodEffects<ZodString, { collection, id: string } | { collection, slug: string }>\n\nThe reference() function is used in the content config to define a relationship, or ‚Äúreference,‚Äù from one collection to another. This accepts a collection name and validates the entry identifier(s) specified in your content frontmatter or data file.\n\nThis example defines references from a blog author to the authors collection and an array of related posts to the same blog collection:\n\nimport { defineCollection, reference, z } from 'astro:content';\n\n\nconst blog = defineCollection({\n  type: 'content',\n  schema: z.object({\n    // Reference a single author from the `authors` collection by `id`\n    author: reference('authors'),\n    // Reference an array of related posts from the `blog` collection by `slug`\n    relatedPosts: z.array(reference('blog')),\n  })\n});\n\n\nconst authors = defineCollection({\n  type: 'data',\n  schema: z.object({ /* ... */ })\n});\n\n\nexport const collections = { blog, authors };\n\nSee the Content Collection guide for example usage.\n\ngetCollection()\nSection titled getCollection()\n\nType: (collection: string, filter?: (entry: CollectionEntry<collection>) => boolean) => CollectionEntry<collection>[]\n\ngetCollection() is a function that retrieves a list of content collection entries by collection name.\n\nIt returns all items in the collection by default, and accepts an optional filter function to narrow by entry properties. This allows you to query for only some items in a collection based on id, slug, or frontmatter values via the data object.\n\n---\nimport { getCollection } from 'astro:content';\n\n\n// Get all `src/content/blog/` entries\nconst allBlogPosts = await getCollection('blog');\n\n\n// Only return posts with `draft: true` in the frontmatter\nconst draftBlogPosts = await getCollection('blog', ({ data }) => {\n  return data.draft === true;\n});\n---\n\nSee the Content Collection guide for example usage.\n\ngetEntry()\nSection titled getEntry()\n\nAdded in: astro@2.5.0\n\nTypes:\n\n(collection: string, contentSlugOrDataId: string) => CollectionEntry<collection>\n({ collection: string, id: string }) => CollectionEntry<collection>\n({ collection: string, slug: string }) => CollectionEntry<collection>\n\ngetEntry() is a function that retrieves a single collection entry by collection name and either the entry id (for type: 'data' collections) or entry slug (for type: 'content' collections). getEntry() can also be used to get referenced entries to access the data, body, or render() properties:\n\n---\nimport { getEntry } from 'astro:content';\n\n\n// Get `src/content/blog/enterprise.md`\nconst enterprisePost = await getEntry('blog', 'enterprise');\n\n\n// Get `src/content/captains/picard.yaml`\nconst picardProfile = await getEntry('captains', 'picard');\n\n\n// Get the profile referenced by `data.captain`\nconst enterpriseCaptainProfile = await getEntry(enterprise.data.captain);\n---\n\nSee the Content Collections guide for examples of querying collection entries.\n\ngetEntries()\nSection titled getEntries()\n\nAdded in: astro@2.5\n\nTypes:\n\n(Array<{ collection: string, id: string }>) => Array<CollectionEntry<collection>>\n(Array<{ collection: string, slug: string }>) => Array<CollectionEntry<collection>>\n\ngetEntries() is a function that retrieves multiple collection entries from the same collection. This is useful for returning an array of referenced entries to access their associated data, body, and render() properties.\n\n---\nimport { getEntries } from 'astro:content';\n\n\nconst enterprisePost = await getEntry('blog', 'enterprise');\n\n\n// Get related posts referenced by `data.relatedPosts`\nconst enterpriseRelatedPosts = await getEntries(enterprisePost.data.relatedPosts);\n---\ngetEntryBySlug()\nSection titled getEntryBySlug()\n\nType: (collection: string, slug: string) => CollectionEntry<collection>\n\n DEPRECATED\n\nUse the getEntry() function to query content entries. This accepts the same arguments as getEntryBySlug(), and supports querying by id for JSON or YAML collections.\n\ngetEntryBySlug() is a function that retrieves a single collection entry by collection name and entry slug.\n\n---\nimport { getEntryBySlug } from 'astro:content';\n\n\nconst enterprise = await getEntryBySlug('blog', 'enterprise');\n---\n\nSee the Content Collection guide for example usage.\n\nCollection Entry Type\nSection titled Collection Entry Type\n\nQuery functions including getCollection(), getEntry(), and getEntries() each return entries with the CollectionEntry type. This type is available as a utility from astro:content:\n\nimport type { CollectionEntry } from 'astro:content';\n\nThe CollectionEntry<TCollectionName> type is an object with the following values. TCollectionName is the name of the collection you‚Äôre querying (e.g. CollectionEntry<'blog'>).\n\nid\nSection titled id\n\nAvailable for: type: 'content' and type: 'data' collections\nExample Types:\n\ncontent collections: 'entry-1.md' | 'entry-2.md' | ...\ndata collections: 'author-1' | 'author-2' | ...\n\nA unique ID using the file path relative to src/content/[collection]. Enumerates all possible string values based on the collection entry file paths. Note that collections defined as type: 'content' include the file extension in their ID, while collections defined as type: 'data' do not.\n\ncollection\nSection titled collection\n\nAvailable for: type: 'content' and type: 'data' collections\nExample Type: 'blog' | 'authors' | ...\n\nThe name of a top-level folder under src/content/ in which entries are located. This is the name used to reference the collection in your schema, and in querying functions.\n\ndata\nSection titled data\n\nAvailable for: type: 'content' and type: 'data' collections\nType: CollectionSchema<TCollectionName>\n\nAn object of frontmatter properties inferred from your collection schema (see defineCollection() reference). Defaults to any if no schema is configured.\n\nslug\nSection titled slug\n\nAvailable for: type: 'content' collections only\nExample Type: 'entry-1' | 'entry-2' | ...\n\nA URL-ready slug for Markdown or MDX documents. Defaults to the id without the file extension, but can be overridden by setting the slug property in a file‚Äôs frontmatter.\n\nbody\nSection titled body\n\nAvailable for: type: 'content' collections only\nType: string\n\nA string containing the raw, uncompiled body of the Markdown or MDX document.\n\nrender()\nSection titled render()\n\nAvailable for: type: 'content' collections only\nType: () => Promise<RenderedEntry>\n\nA function to compile a given Markdown or MDX document for rendering. This returns the following properties:\n\n<Content /> - A component used to render the document‚Äôs contents in an Astro file.\nheadings - A generated list of headings, mirroring Astro‚Äôs getHeadings() utility on Markdown and MDX imports.\nremarkPluginFrontmatter - The modified frontmatter object after any remark or rehype plugins have been applied. Set to type any.\n---\nimport { getEntryBySlug } from 'astro:content';\nconst entry = await getEntryBySlug('blog', 'entry-1');\n\n\nconst { Content, headings, remarkPluginFrontmatter } = await entry.render();\n---\n\nSee the Content Collection guide for example usage.\n\nOther Content Collection Types\nSection titled Other Content Collection Types\n\nThe astro:content module also exports the following types for use in your Astro project:\n\nCollectionKey\nSection titled CollectionKey\n\nA string union of all collection names defined in your src/content/config.* file. This type can be useful when defining a generic function that accepts any collection name.\n\nimport type { CollectionKey, getCollection } from 'astro:content';\n\n\nasync function getCollection(collection: CollectionKey) {\n  return getCollection(collection);\n}\nContentCollectionKey\nSection titled ContentCollectionKey\n\nA string union of all the names of type: 'content' collections defined in your src/content/config.* file.\n\nDataCollectionKey\nSection titled DataCollectionKey\n\nA string union of all the names of type: 'data' collection defined in your src/content/config.* file.\n\nSchemaContext\nSection titled SchemaContext\n\nThe context object that defineCollection uses for the function shape of schema. This type can be useful when building reusable schemas for multiple collections.\n\nThis includes the following property:\n\nimage - The image() schema helper that allows you to use local images in Content Collections\nimport type { SchemaContext } from 'astro:content';\n\n\nexport const imageSchema = ({ image }: SchemaContext) =>\n    z.object({\n        image: image(),\n        description: z.string().optional(),\n    });\n\n\nconst blog = defineCollection({\n  type: 'content',\n  schema: ({ image }) => z.object({\n    title: z.string(),\n    permalink: z.string().optional(),\n    image: imageSchema({ image })\n  }),\n});\nMiddleware (astro:middleware)\nSection titled Middleware (astro:middleware)\n\nAdded in: astro@2.6.0\n\nMiddleware allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered. For features and usage examples, see our middleware guide.\n\nonRequest()\nSection titled onRequest()\n\nA required exported function from src/middleware.js that will be called before rendering every page or API route. It accepts two optional arguments: context and next(). onRequest() must return a Response: either directly, or by calling next().\n\nsrc/middleware.js\nexport function onRequest (context, next) {\n    // intercept response data from a request\n    // optionally, transform the response\n    // return a Response directly, or the result of calling `next()`\n    return next();\n};\nnext()\nSection titled next()\n\nA function that intercepts (reads and modifies) the Response of a Request or calls the ‚Äúnext‚Äù middleware in the chain and returns a Response. For example, this function could modify the HTML body of a response.\n\nThis is an optional argument of onRequest(), and may provide the required Response returned by the middleware.\n\nsequence()\nSection titled sequence()\n\nA function that accepts middleware functions as arguments, and will execute them in the order in which they are passed.\n\nsrc/middleware.js\nimport { sequence } from \"astro:middleware\";\n\n\nasync function validation(_, next) {...}\nasync function auth(_, next) {...}\nasync function greeting(_, next) {...}\n\n\nexport const onRequest = sequence(validation, auth, greeting);\ncreateContext()\nSection titled createContext()\n\nA low-level API to create an APIContextto be passed to an Astro middleware onRequest() function.\n\nThis function can be used by integrations/adapters to programmatically execute the Astro middleware.\n\ntrySerializeLocals()\nSection titled trySerializeLocals()\n\nA low-level API that takes in any value and tries to return a serialized version (a string) of it. If the value cannot be serialized, the function will throw a runtime error.\n\nBuilt-in Components\nSection titled Built-in Components\n\nAstro includes several built-in components for you to use in your projects. All built-in components are available in .astro files via import {} from 'astro:components';.\n\n<Code />\nSection titled &lt;Code /&gt;\n---\nimport { Code } from 'astro:components';\n---\n<!-- Syntax highlight some JavaScript code. -->\n<Code code={`const foo = 'bar';`} lang=\"js\" />\n<!-- Optional: Customize your theme. -->\n<Code code={`const foo = 'bar';`} lang=\"js\" theme=\"dark-plus\" />\n<!-- Optional: Enable word wrapping. -->\n<Code code={`const foo = 'bar';`} lang=\"js\" wrap />\n<!-- Optional: Output inline code. -->\n<p>\n  <Code code={`const foo = 'bar';`} lang=\"js\" inline />\n  will be rendered inline.\n</p>\n\nThis component provides syntax highlighting for code blocks at build time (no client-side JavaScript included). The component is powered internally by Shiki and it supports all popular themes and languages. Plus, you can add your custom themes and languages by passing them to theme and lang respectively.\n\n<Fragment />\nSection titled &lt;Fragment /&gt;\n\nA component used with set:* directives to render HTML content without any additional wrapping elements:\n\nsrc/components/SetHtml.astro\n---\nconst htmlString = '<p>Raw HTML content</p>';\n---\n<Fragment set:html={htmlString} />\n\nSee more about using fragments in Astro syntax.\n\n<Prism />\nSection titled &lt;Prism /&gt;\n\nTo use the Prism highlighter component, first install the @astrojs/prism package:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @astrojs/prism\n---\nimport { Prism } from '@astrojs/prism';\n---\n<Prism lang=\"js\" code={`const foo = 'bar';`} />\n\nThis component provides language-specific syntax highlighting for code blocks by applying Prism‚Äôs CSS classes. Note that you need to provide a Prism CSS stylesheet (or bring your own) for syntax highlighting to appear! See the Prism configuration section for more details.\n\nSee the list of languages supported by Prism where you can find a language‚Äôs corresponding alias. And, you can also display your Astro code blocks with lang=\"astro\"!\n\n<Image />\nSection titled &lt;Image /&gt;\nsrc/components/MyComponent.astro\n---\n// import the Image component and the image\nimport { Image } from 'astro:assets';\nimport myImage from \"../assets/my_image.png\"; // Image is 1600x900\n---\n\n\n<!-- `alt` is mandatory on the Image component -->\n<Image src={myImage} alt=\"A description of my image.\" />\n<!-- Output -->\n<!-- Image is optimized, proper attributes are enforced -->\n<img\n  src=\"/_astro/my_image.hash.webp\"\n  width=\"1600\"\n  height=\"900\"\n  decoding=\"async\"\n  loading=\"lazy\"\n  alt=\"A description of my image.\"\n/>\nProperties\nSection titled Properties\nsrc (required)\nalt (required)\nwidth and height (required for public/ and remote images)\nformat\nquality\ndensities\nwidths\n\nIn addition to the properties above, the <Image /> component accepts all properties accepted by the HTML <img> tag.\n\nSee more in the Images Guide.\n\n<Picture />\nSection titled &lt;Picture /&gt;\nAdded in: astro@3.3.0\n\nUse the built-in <Picture /> Astro component to display a responsive image with multiple formats and/or sizes.\n\nsrc/pages/index.astro\n---\nimport { Picture } from 'astro:assets';\nimport myImage from \"../assets/my_image.png\"; // Image is 1600x900\n---\n\n\n<!-- `alt` is mandatory on the Picture component -->\n<Picture src={myImage} formats={['avif', 'webp']} alt=\"A description of my image.\" />\n<!-- Output -->\n<picture>\n  <source srcset=\"/_astro/my_image.hash.avif\" type=\"image/avif\" />\n  <source srcset=\"/_astro/my_image.hash.webp\" type=\"image/webp\" />\n  <img\n    src=\"/_astro/my_image.hash.png\"\n    width=\"1600\"\n    height=\"900\"\n    decoding=\"async\"\n    loading=\"lazy\"\n    alt=\"A description of my image.\"\n  />\n</picture>\n\nSee more in the Images Guide.\n\nProperties\nSection titled Properties\n\n<Picture /> accepts all the properties of the <Image /> component, plus the following:\n\nformats\nSection titled formats\n\nAn array of image formats to use for the <source> tags. By default, this is set to ['webp'].\n\nfallbackFormat\nSection titled fallbackFormat\n\nFormat to use as a fallback value for the <img> tag. Defaults to .png for static images, .gif for animated images, and .svg for SVG files.\n\npictureAttributes\nSection titled pictureAttributes\n\nAn object of attributes to be added to the <picture> tag. Use this property to apply attributes to the outer <picture> element itself. Attributes applied to the <Picture /> component directly will apply to the inner <img> element, except for those used for image transformation.\n\n<Content />\nSection titled &lt;Content /&gt;\n\nA generic component used to render the content of a content collection entry.\n\nFirst, query one or more entries using getCollection() or getEntry(). Then, the entry.render() function can return the <Content /> component for use in a .astro file template.\n\nsrc/pages/render-example.astro\n---\nimport { getEntry } from 'astro:content';\nconst entry = await getEntry('blog', 'post-1');\nconst { Content } = await entry.render();\n---\n<p>Published on: {entry.data.published.toDateString()}</p>\n<Content />\n<ViewTransitions />\nSection titled &lt;ViewTransitions /&gt;\n\nOpt in to using view transitions on individual pages by importing and adding the <ViewTransitions /> routing component to <head> on every desired page.\n\nsrc/pages/index.astro\n---\nimport { ViewTransitions } from 'astro:transitions';\n---\n<html lang=\"en\">\n  <head>\n    <title>My Homepage</title>\n    <ViewTransitions />\n  </head>\n  <body>\n    <h1>Welcome to my website!</h1>\n  </body>\n</html>\n\nSee more about how to control the router and add transition directives to page elements and components.\n\n<Debug />\nSection titled &lt;Debug /&gt;\n---\nimport { Debug } from 'astro:components';\nconst serverObject = {\n  a: 0,\n  b: \"string\",\n  c: {\n    nested: \"object\"\n  }\n}\n---\n<Debug {serverObject} />\n\nThis component provides a way to inspect values on the client-side, without any JavaScript.\n\nBack\nConfiguration\nNext Page\nIntegrations API"
  },
  {
    "title": "Configuration Reference üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/configuration-reference/",
    "html": "Configuration Reference\n\nThe following reference covers all supported configuration options in Astro. To learn more about configuring Astro, read our guide on Configuring Astro.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  // your configuration options here...\n})\nTop-Level Options\nSection titled Top-Level Options\nroot\nSection titled root\n\nType: string\nCLI: --root\nDefault: \".\" (current working directory)\n\nYou should only provide this option if you run the astro CLI commands in a directory other than the project root directory. Usually, this option is provided via the CLI instead of the Astro config file, since Astro needs to know your project root before it can locate your config file.\n\nIf you provide a relative path (ex: --root: './my-project') Astro will resolve it against your current working directory.\n\nExamples\nSection titled Examples\n{\n  root: './my-project-directory'\n}\nTerminal window\n$ astro build --root ./my-project-directory\nsrcDir\nSection titled srcDir\n\nType: string\nDefault: \"./src\"\n\nSet the directory that Astro will read your site from.\n\nThe value can be either an absolute file system path or a path relative to the project root.\n\n{\n  srcDir: './www'\n}\npublicDir\nSection titled publicDir\n\nType: string\nDefault: \"./public\"\n\nSet the directory for your static assets. Files in this directory are served at / during dev and copied to your build directory during build. These files are always served or copied as-is, without transform or bundling.\n\nThe value can be either an absolute file system path or a path relative to the project root.\n\n{\n  publicDir: './my-custom-publicDir-directory'\n}\noutDir\nSection titled outDir\n\nType: string\nDefault: \"./dist\"\n\nSet the directory that astro build writes your final build to.\n\nThe value can be either an absolute file system path or a path relative to the project root.\n\n{\n  outDir: './my-custom-build-directory'\n}\n\nSee Also:\n\nbuild.server\ncacheDir\nSection titled cacheDir\n\nType: string\nDefault: \"./node_modules/.astro\"\n\nSet the directory for caching build artifacts. Files in this directory will be used in subsequent builds to speed up the build time.\n\nThe value can be either an absolute file system path or a path relative to the project root.\n\n{\n  cacheDir: './my-custom-cache-directory'\n}\nredirects\nSection titled redirects\n\nType: Record.<string, RedirectConfig>\nDefault: {}\n\n\nAdded in: astro@2.9.0\n\nSpecify a mapping of redirects where the key is the route to match and the value is the path to redirect to.\n\nYou can redirect both static and dynamic routes, but only to the same kind of route. For example you cannot have a '/article': '/blog/[...slug]' redirect.\n\n{\n  redirects: {\n    '/old': '/new',\n    '/blog/[...slug]': '/articles/[...slug]',\n  }\n}\n\nFor statically-generated sites with no adapter installed, this will produce a client redirect using a <meta http-equiv=\"refresh\"> tag and does not support status codes.\n\nWhen using SSR or with a static adapter in output: static mode, status codes are supported. Astro will serve redirected GET requests with a status of 301 and use a status of 308 for any other request method.\n\nYou can customize the redirection status code using an object in the redirect config:\n\n{\n  redirects: {\n    '/other': {\n      status: 302,\n      destination: '/place',\n    },\n  }\n}\nsite\nSection titled site\n\nType: string\n\nYour final, deployed URL. Astro uses this full URL to generate your sitemap and canonical URLs in your final build. It is strongly recommended that you set this configuration to get the most out of Astro.\n\n{\n  site: 'https://www.my-site.dev'\n}\ncompressHTML\nSection titled compressHTML\n\nType: boolean\nDefault: true\n\nThis is an option to minify your HTML output and reduce the size of your HTML files. By default, Astro removes all whitespace from your HTML, including line breaks, from .astro components. This occurs both in development mode and in the final build. To disable HTML compression, set the compressHTML flag to false.\n\n{\n  compressHTML: false\n}\nbase\nSection titled base\n\nType: string\n\nThe base path to deploy to. Astro will use this path as the root for your pages and assets both in development and in production build.\n\nIn the example below, astro dev will start your server at /docs.\n\n{\n  base: '/docs'\n}\n\nWhen using this option, all of your static asset imports and URLs should add the base as a prefix. You can access this value via import.meta.env.BASE_URL.\n\nThe value of import.meta.env.BASE_URL will be determined by your trailingSlash config, no matter what value you have set for base.\n\nA trailing slash is always included if trailingSlash: \"always\" is set. If trailingSlash: \"never\" is set, BASE_URL will not include a trailing slash, even if base includes one.\n\nAdditionally, Astro will internally manipulate the configured value of config.base before making it available to integrations. The value of config.base as read by integrations will also be determined by your trailingSlash configuration in the same way.\n\nIn the example below, the values of import.meta.env.BASE_URL and config.base when processed will both be /docs:\n\n{\n   base: '/docs/',\n   trailingSlash: \"never\"\n}\n\nIn the example below, the values of import.meta.env.BASE_URL and config.base when processed will both be /docs/:\n\n{\n   base: '/docs',\n   trailingSlash: \"always\"\n}\ntrailingSlash\nSection titled trailingSlash\n\nType: 'always' | 'never' | 'ignore'\nDefault: 'ignore'\n\nSet the route matching behavior of the dev server. Choose from the following options:\n\n'always' - Only match URLs that include a trailing slash (ex: ‚Äú/foo/‚Äú)\n'never' - Never match URLs that include a trailing slash (ex: ‚Äú/foo‚Äù)\n'ignore' - Match URLs regardless of whether a trailing ‚Äù/‚Äù exists\n\nUse this configuration option if your production host has strict handling of how trailing slashes work or do not work.\n\nYou can also set this if you prefer to be more strict yourself, so that URLs with or without trailing slashes won‚Äôt work during development.\n\n{\n  // Example: Require a trailing slash during development\n  trailingSlash: 'always'\n}\n\nSee Also:\n\nbuild.format\nscopedStyleStrategy\nSection titled scopedStyleStrategy\n\nType: 'where' | 'class' | 'attribute'\nDefault: 'attribute'\n\n\nAdded in: astro@2.4\n\nSpecify the strategy used for scoping styles within Astro components. Choose from:\n\n'where' - Use :where selectors, causing no specificity increase.\n'class' - Use class-based selectors, causing a +1 specificity increase.\n'attribute' - Use data- attributes, causing a +1 specificity increase.\n\nUsing 'class' is helpful when you want to ensure that element selectors within an Astro component override global style defaults (e.g. from a global stylesheet). Using 'where' gives you more control over specificity, but requires that you use higher-specificity selectors, layers, and other tools to control which selectors are applied. Using 'attribute' is useful when you are manipulating the class attribute of elements and need to avoid conflicts between your own styling logic and Astro‚Äôs application of styles.\n\nadapter\nSection titled adapter\n\nType: AstroIntegration\n\nDeploy to your favorite server, serverless, or edge host with build adapters. Import one of our first-party adapters for Netlify, Vercel, and more to engage Astro SSR.\n\nSee our Server-side Rendering guide for more on SSR, and our deployment guides for a complete list of hosts.\n\nimport netlify from '@astrojs/netlify/functions';\n{\n  // Example: Build for Netlify serverless deployment\n  adapter: netlify(),\n}\n\nSee Also:\n\noutput\noutput\nSection titled output\n\nType: 'static' | 'server' | 'hybrid'\nDefault: 'static'\n\nSpecifies the output target for builds.\n\n'static' - Building a static site to be deploy to any static host.\n'server' - Building an app to be deployed to a host supporting SSR (server-side rendering).\n'hybrid' - Building a static site with a few server-side rendered pages.\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  output: 'static'\n})\n\nSee Also:\n\nadapter\nBuild Options\nSection titled Build Options\nbuild.format\nSection titled build.format\n\nType: ('file' | 'directory')\nDefault: 'directory'\n\nControl the output file format of each page.\n\nIf 'file', Astro will generate an HTML file (ex: ‚Äú/foo.html‚Äù) for each page.\nIf 'directory', Astro will generate a directory with a nested index.html file (ex: ‚Äú/foo/index.html‚Äù) for each page.\n{\n  build: {\n    // Example: Generate `page.html` instead of `page/index.html` during build.\n    format: 'file'\n  }\n}\nEffect on Astro.url\nSection titled Effect on Astro.url\n\nSetting build.format controls what Astro.url is set to during the build. When it is:\n\ndirectory - The Astro.url.pathname will include a trailing slash to mimic folder behavior; ie /foo/.\nfile - The Astro.url.pathname will include .html; ie /foo.html.\n\nThis means that when you create relative URLs using new URL('./relative', Astro.url), you will get consistent behavior between dev and build.\n\nTo prevent inconsistencies with trailing slash behaviour in dev, you can restrict the trailingSlash option to 'always' or 'never' depending on your build format:\n\ndirectory - Set trailingSlash: 'always'\nfile - Set trailingSlash: 'never'\nbuild.client\nSection titled build.client\n\nType: string\nDefault: './dist/client'\n\nControls the output directory of your client-side CSS and JavaScript when output: 'server' or output: 'hybrid' only. outDir controls where the code is built to.\n\nThis value is relative to the outDir.\n\n{\n  output: 'server', // or 'hybrid'\n  build: {\n    client: './client'\n  }\n}\nbuild.server\nSection titled build.server\n\nType: string\nDefault: './dist/server'\n\nControls the output directory of server JavaScript when building to SSR.\n\nThis value is relative to the outDir.\n\n{\n  build: {\n    server: './server'\n  }\n}\nbuild.assets\nSection titled build.assets\n\nType: string\nDefault: '_astro'\n\n\nAdded in: astro@2.0.0\n\nSpecifies the directory in the build output where Astro-generated assets (bundled JS and CSS for example) should live.\n\n{\n  build: {\n    assets: '_custom'\n  }\n}\n\nSee Also:\n\noutDir\nbuild.assetsPrefix\nSection titled build.assetsPrefix\n\nType: string\nDefault: undefined\n\n\nAdded in: astro@2.2.0\n\nSpecifies the prefix for Astro-generated asset links. This can be used if assets are served from a different domain than the current site.\n\nFor example, if this is set to https://cdn.example.com, assets will be fetched from https://cdn.example.com/_astro/... (regardless of the base option). You would need to upload the files in ./dist/_astro/ to https://cdn.example.com/_astro/ to serve the assets. The process varies depending on how the third-party domain is hosted. To rename the _astro path, specify a new directory in build.assets.\n\n{\n  build: {\n    assetsPrefix: 'https://cdn.example.com'\n  }\n}\nbuild.serverEntry\nSection titled build.serverEntry\n\nType: string\nDefault: 'entry.mjs'\n\nSpecifies the file name of the server entrypoint when building to SSR. This entrypoint is usually dependent on which host you are deploying to and will be set by your adapter for you.\n\nNote that it is recommended that this file ends with .mjs so that the runtime detects that the file is a JavaScript module.\n\n{\n  build: {\n    serverEntry: 'main.mjs'\n  }\n}\nbuild.redirects\nSection titled build.redirects\n\nType: boolean\nDefault: true\n\n\nAdded in: astro@2.6.0\n\nSpecifies whether redirects will be output to HTML during the build. This option only applies to output: 'static' mode; in SSR redirects are treated the same as all responses.\n\nThis option is mostly meant to be used by adapters that have special configuration files for redirects and do not need/want HTML based redirects.\n\n{\n  build: {\n    redirects: false\n  }\n}\nbuild.inlineStylesheets\nSection titled build.inlineStylesheets\n\nType: 'always' | 'auto' | 'never'\nDefault: auto\n\n\nAdded in: astro@2.6.0\n\nControl whether project styles are sent to the browser in a separate css file or inlined into <style> tags. Choose from the following options:\n\n'always' - project styles are inlined into <style> tags\n'auto' - only stylesheets smaller than ViteConfig.build.assetsInlineLimit (default: 4kb) are inlined. Otherwise, project styles are sent in external stylesheets.\n'never' - project styles are sent in external stylesheets\n{\n  build: {\n    inlineStylesheets: `never`,\n  },\n}\nbuild.split\nSection titled build.split\n\n DEPRECATED\n\nDeprecated since version 3.0.\n\nType: boolean\nDefault: false\n\nThe build config option build.split has been replaced by the adapter configuration option functionPerRoute.\n\nPlease see your SSR adapter‚Äôs documentation for using functionPerRoute to define how your SSR code is bundled.\n\nbuild.excludeMiddleware\nSection titled build.excludeMiddleware\n\n DEPRECATED\n\nDeprecated since version 3.0.\n\nType: boolean\nDefault: false\n\nThe build config option build.excludeMiddleware has been replaced by the adapter configuration option edgeMiddleware.\n\nPlease see your SSR adapter‚Äôs documentation for using edgeMiddleware to define whether or not any SSR middleware code will be bundled when built.\n\nPrefetch Options\nSection titled Prefetch Options\n\nType: boolean | object\n\nEnable prefetching for links on your site to provide faster page transitions. (Enabled by default on pages using the <ViewTransitions /> router. Set prefetch: false to opt out of this behaviour.)\n\nThis configuration automatically adds a prefetch script to every page in the project giving you access to the data-astro-prefetch attribute. Add this attribute to any <a /> link on your page to enable prefetching for that page.\n\n<a href=\"/about\" data-astro-prefetch>About</a>\n\nFurther customize the default prefetching behavior using the prefetch.defaultStrategy and prefetch.prefetchAll options.\n\nSee the Prefetch guide for more information.\n\nprefetch.prefetchAll\nSection titled prefetch.prefetchAll\n\nType: boolean\n\nEnable prefetching for all links, including those without the data-astro-prefetch attribute. This value defaults to true when using the <ViewTransitions /> router. Otherwise, the default value is false.\n\nprefetch: {\n  prefetchAll: true\n}\n\nWhen set to true, you can disable prefetching individually by setting data-astro-prefetch=\"false\" on any individual links.\n\n<a href=\"/about\" data-astro-prefetch=\"false\">About</a>\nprefetch.defaultStrategy\nSection titled prefetch.defaultStrategy\n\nType: 'tap' | 'hover' | 'viewport'\nDefault: 'hover'\n\nThe default prefetch strategy to use when the data-astro-prefetch attribute is set on a link with no value.\n\n'tap': Prefetch just before you click on the link.\n'hover': Prefetch when you hover over or focus on the link. (default)\n'viewport': Prefetch as the links enter the viewport.\n\nYou can override this default value and select a different strategy for any individual link by setting a value on the attribute.\n\n<a href=\"/about\" data-astro-prefetch=\"viewport\">About</a>\nServer Options\nSection titled Server Options\n\nCustomize the Astro dev server, used by both astro dev and astro preview.\n\n{\n  server: { port: 1234, host: true}\n}\n\nTo set different configuration based on the command run (‚Äúdev‚Äù, ‚Äúpreview‚Äù) a function can also be passed to this configuration option.\n\n{\n  // Example: Use the function syntax to customize based on command\n  server: ({ command }) => ({ port: command === 'dev' ? 4321 : 4000 })\n}\nserver.host\nSection titled server.host\n\nType: string | boolean\nDefault: false\n\n\nAdded in: astro@0.24.0\n\nSet which network IP addresses the server should listen on (i.e. non-localhost IPs).\n\nfalse - do not expose on a network IP address\ntrue - listen on all addresses, including LAN and public addresses\n[custom-address] - expose on a network IP address at [custom-address] (ex: 192.168.0.1)\nserver.port\nSection titled server.port\n\nType: number\nDefault: 4321\n\nSet which port the server should listen on.\n\nIf the given port is already in use, Astro will automatically try the next available port.\n\n{\n  server: { port: 8080 }\n}\nserver.headers\nSection titled server.headers\n\nType: OutgoingHttpHeaders\nDefault: {}\n\n\nAdded in: astro@1.7.0\n\nSet custom HTTP response headers to be sent in astro dev and astro preview.\n\nImage Options\nSection titled Image Options\nimage.endpoint\nSection titled image.endpoint\n\nType: string\nDefault: undefined\n\n\nAdded in: astro@3.1.0\n\nSet the endpoint to use for image optimization in dev and SSR. Set to undefined to use the default endpoint.\n\nThe endpoint will always be injected at /_image.\n\n{\n  image: {\n    // Example: Use a custom image endpoint\n    endpoint: './src/image-endpoint.ts',\n  },\n}\nimage.service\nSection titled image.service\n\nType: Object\nDefault: {entrypoint: 'astro/assets/services/sharp', config?: {}}\n\n\nAdded in: astro@2.1.0\n\nSet which image service is used for Astro‚Äôs assets support.\n\nThe value should be an object with an entrypoint for the image service to use and optionally, a config object to pass to the service.\n\nThe service entrypoint can be either one of the included services, or a third-party package.\n\n{\n  image: {\n    // Example: Enable the Sharp-based image service\n    service: { entrypoint: 'astro/assets/services/sharp' },\n  },\n}\nimage.domains\nSection titled image.domains\n\nType: Array.<string>\nDefault: {domains: []}\n\n\nAdded in: astro@2.10.10\n\nDefines a list of permitted image source domains for remote image optimization. No other remote images will be optimized by Astro.\n\nThis option requires an array of individual domain names as strings. Wildcards are not permitted. Instead, use image.remotePatterns to define a list of allowed source URL patterns.\n\nastro.config.mjs\n{\n  image: {\n    // Example: Allow remote image optimization from a single domain\n    domains: ['astro.build'],\n  },\n}\nimage.remotePatterns\nSection titled image.remotePatterns\n\nType: Array.<RemotePattern>\nDefault: {remotePatterns: []}\n\n\nAdded in: astro@2.10.10\n\nDefines a list of permitted image source URL patterns for remote image optimization.\n\nremotePatterns can be configured with four properties:\n\nprotocol\nhostname\nport\npathname\n{\n  image: {\n    // Example: allow processing all images from your aws s3 bucket\n    remotePatterns: [{\n      protocol: 'https',\n      hostname: '**.amazonaws.com',\n    }],\n  },\n}\n\nYou can use wildcards to define the permitted hostname and pathname values as described below. Otherwise, only the exact values provided will be configured: hostname:\n\nStart with ‚Äô**.‚Äô to allow all subdomains (‚ÄòendsWith‚Äô).\nStart with ‚Äô*.‚Äô to allow only one level of subdomain.\n\npathname:\n\nEnd with ‚Äô/**‚Äô to allow all sub-routes (‚ÄòstartsWith‚Äô).\nEnd with ‚Äô/*‚Äô to allow only one level of sub-route.\nMarkdown Options\nSection titled Markdown Options\nmarkdown.drafts\nSection titled markdown.drafts\n\n DEPRECATED\n\nDeprecated since version 3.0. Use content collections instead.\n\nType: boolean\nDefault: false\n\nControl whether Markdown draft pages should be included in the build.\n\nA Markdown page is considered a draft if it includes draft: true in its frontmatter. Draft pages are always included & visible during development (astro dev) but by default they will not be included in your final build.\n\n{\n  markdown: {\n    // Example: Include all drafts in your final build\n    drafts: true,\n  }\n}\nmarkdown.shikiConfig\nSection titled markdown.shikiConfig\n\nType: Partial<ShikiConfig>\n\nShiki configuration options. See the Markdown configuration docs for usage.\n\nmarkdown.syntaxHighlight\nSection titled markdown.syntaxHighlight\n\nType: 'shiki' | 'prism' | false\nDefault: shiki\n\nWhich syntax highlighter to use, if any.\n\nshiki - use the Shiki highlighter\nprism - use the Prism highlighter\nfalse - do not apply syntax highlighting.\n{\n  markdown: {\n    // Example: Switch to use prism for syntax highlighting in Markdown\n    syntaxHighlight: 'prism',\n  }\n}\nmarkdown.remarkPlugins\nSection titled markdown.remarkPlugins\n\nType: RemarkPlugins\n\nPass remark plugins to customize how your Markdown is built. You can import and apply the plugin function (recommended), or pass the plugin name as a string.\n\nimport remarkToc from 'remark-toc';\n{\n  markdown: {\n    remarkPlugins: [remarkToc]\n  }\n}\nmarkdown.rehypePlugins\nSection titled markdown.rehypePlugins\n\nType: RehypePlugins\n\nPass rehype plugins to customize how your Markdown‚Äôs output HTML is processed. You can import and apply the plugin function (recommended), or pass the plugin name as a string.\n\nimport { rehypeAccessibleEmojis } from 'rehype-accessible-emojis';\n{\n  markdown: {\n    rehypePlugins: [rehypeAccessibleEmojis]\n  }\n}\nmarkdown.gfm\nSection titled markdown.gfm\n\nType: boolean\nDefault: true\n\n\nAdded in: astro@2.0.0\n\nAstro uses GitHub-flavored Markdown by default. To disable this, set the gfm flag to false:\n\n{\n  markdown: {\n    gfm: false,\n  }\n}\nmarkdown.smartypants\nSection titled markdown.smartypants\n\nType: boolean\nDefault: true\n\n\nAdded in: astro@2.0.0\n\nAstro uses the SmartyPants formatter by default. To disable this, set the smartypants flag to false:\n\n{\n  markdown: {\n    smartypants: false,\n  }\n}\nmarkdown.remarkRehype\nSection titled markdown.remarkRehype\n\nType: RemarkRehype\n\nPass options to remark-rehype.\n\n{\n  markdown: {\n    // Example: Translate the footnotes text to another language, here are the default English values\n    remarkRehype: { footnoteLabel: \"Footnotes\", footnoteBackLabel: \"Back to content\"},\n  },\n};\nIntegrations\nSection titled Integrations\n\nExtend Astro with custom integrations. Integrations are your one-stop-shop for adding framework support (like Solid.js), new features (like sitemaps), and new libraries (like Partytown).\n\nRead our Integrations Guide for help getting started with Astro Integrations.\n\nimport react from '@astrojs/react';\nimport tailwind from '@astrojs/tailwind';\n{\n  // Example: Add React + Tailwind support to Astro\n  integrations: [react(), tailwind()]\n}\nVite\nSection titled Vite\n\nPass additional configuration options to Vite. Useful when Astro doesn‚Äôt support some advanced configuration that you may need.\n\nView the full vite configuration object documentation on vitejs.dev.\n\nExamples\nSection titled Examples\n{\n  vite: {\n    ssr: {\n      // Example: Force a broken package to skip SSR processing, if needed\n      external: ['broken-npm-package'],\n    }\n  }\n}\n{\n  vite: {\n    // Example: Add custom vite plugins directly to your Astro project\n    plugins: [myPlugin()],\n  }\n}\nLegacy Flags\nSection titled Legacy Flags\n\nTo help some users migrate between versions of Astro, we occasionally introduce legacy flags. These flags allow you to opt in to some deprecated or otherwise outdated behavior of Astro in the latest version, so that you can continue to upgrade and take advantage of new Astro releases.\n\nExperimental Flags\nSection titled Experimental Flags\n\nAstro offers experimental flags to give users early access to new features. These flags are not guaranteed to be stable.\n\nexperimental.optimizeHoistedScript\nSection titled experimental.optimizeHoistedScript\n\nType: boolean\nDefault: false\n\n\nAdded in: astro@2.10.4\n\nPrevents unused components‚Äô scripts from being included in a page unexpectedly. The optimization is best-effort and may inversely miss including the used scripts. Make sure to double-check your built pages before publishing. Enable hoisted script analysis optimization by adding the experimental flag:\n\n{\n  experimental: {\n    optimizeHoistedScript: true,\n  },\n}\nexperimental.devOverlay\nSection titled experimental.devOverlay\n\nType: boolean\nDefault: false\n\n\nAdded in: astro@3.4.0\n\nEnable a dev overlay in development mode. This overlay allows you to inspect your page islands, see helpful audits on performance and accessibility, and more.\n\n{\n  experimental: {\n    devOverlay: true,\n  },\n}\nexperimental.i18n\nSection titled experimental.i18n\n\nType: object\n\n\nAdded in: astro@3.5.0\n\nConfigures experimental i18n routing and allows you to specify some customization options.\n\nSee our guide for more information on internationalization in Astro\n\nexperimental.i18n.defaultLocale\nSection titled experimental.i18n.defaultLocale\n\nType: string\n\n\nAdded in: astro@3.5.0\n\nThe default locale of your website/application. This is a required field.\n\nNo particular language format or syntax is enforced, but we suggest using lower-case and hyphens as needed (e.g. ‚Äúes‚Äù, ‚Äúpt-br‚Äù) for greatest compatibility.\n\nexperimental.i18n.locales\nSection titled experimental.i18n.locales\n\nType: Array.<string>\n\n\nAdded in: astro@3.5.0\n\nA list of all locales supported by the website (e.g. ['en', 'es', 'pt-br']). This list should also include the defaultLocale. This is a required field.\n\nNo particular language format or syntax is enforced, but your folder structure must match exactly the locales in the list.\n\nexperimental.i18n.fallback\nSection titled experimental.i18n.fallback\n\nType: Record.<string, string>\n\n\nAdded in: astro@3.5.0\n\nThe fallback strategy when navigating to pages that do not exist (e.g. a translated page has not been created).\n\nUse this object to declare a fallback locale route for each language you support. If no fallback is specified, then unavailable pages will return a 404.\n\nExample\nSection titled Example\n\nThe following example configures your content fallback strategy to redirect unavailable pages in /pt-br/ to their es version, and unavailable pages in /fr/ to their en version. Unavailable /es/ pages will return a 404.\n\nexport default defineConfig({\n  experimental: {\n    i18n: {\n      defaultLocale: \"en\",\n      locales: [\"en\", \"fr\", \"pt-br\", \"es\"],\n      fallback: {\n        pt: \"es\",\n        fr: \"en\"\n      }\n    }\n  }\n})\nexperimental.i18n.routingStrategy\nSection titled experimental.i18n.routingStrategy\n\nType: 'prefix-always' | 'prefix-other-locales'\nDefault: ‚Äòprefix-other-locales‚Äô\n\n\nAdded in: astro@3.5.0\n\nControls the routing strategy to determine your site URLs. Set this based on your folder/URL path configuration for your default language:\n\nprefix-other-locales(default): Only non-default languages will display a language prefix. The defaultLocale will not show a language prefix and content files do not exist in a localized folder. URLs will be of the form example.com/[locale]/content/ for all non-default languages, but example.com/content/ for the default locale.\nprefix-always: All URLs will display a language prefix. URLs will be of the form example.com/[locale]/content/ for every route, including the default language. Localized folders are used for every language, including the default.\nexperimental.contentCollectionCache\nSection titled experimental.contentCollectionCache\n\nType: boolean\nDefault: false\n\n\nAdded in: astro@3.5.0\n\nEnables a persistent cache for content collections when building in static mode.\n\n{\n  experimental: {\n    contentCollectionCache: true,\n  },\n}\nBack\nEnvironment Variables\nNext Page\nRuntime API"
  },
  {
    "title": "Using environment variables üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/environment-variables/",
    "html": "Using environment variables\n\nAstro uses Vite‚Äôs built-in support for environment variables, and lets you use any of its methods to work with them.\n\nNote that while all environment variables are available in server-side code, only environment variables prefixed with PUBLIC_ are available in client-side code for security purposes.\n\n.env\nSECRET_PASSWORD=password123\nPUBLIC_ANYBODY=there\n\nIn this example, PUBLIC_ANYBODY (accessible via import.meta.env.PUBLIC_ANYBODY) will be available in server or client code, while SECRET_PASSWORD (accessible via import.meta.env.SECRET_PASSWORD) will be server-side only.\n\n CAUTION\n\n.env files are not loaded inside configuration files.\n\nDefault environment variables\nSection titled Default environment variables\n\nAstro includes a few environment variables out-of-the-box:\n\nimport.meta.env.MODE: The mode your site is running in. This is development when running astro dev and production when running astro build.\nimport.meta.env.PROD: true if your site is running in production; false otherwise.\nimport.meta.env.DEV: true if your site is running in development; false otherwise. Always the opposite of import.meta.env.PROD.\nimport.meta.env.BASE_URL: The base url your site is being served from. This is determined by the base config option.\nimport.meta.env.SITE: This is set to the site option specified in your project‚Äôs astro.config.\nimport.meta.env.ASSETS_PREFIX: The prefix for Astro-generated asset links if the build.assetsPrefix config option is set. This can be used to create asset links not handled by Astro.\n\nUse them like any other environment variable.\n\nconst isProd = import.meta.env.PROD;\nconst isDev = import.meta.env.DEV;\nSetting environment variables\nSection titled Setting environment variables\n.env files\nSection titled .env files\n\nEnvironment variables can be loaded from .env files in your project directory.\n\nYou can also attach a mode (either production or development) to the filename, like .env.production or .env.development, which makes the environment variables only take effect in that mode.\n\nJust create a .env file in the project directory and add some variables to it.\n\n.env\n# This will only be available when run on the server!\nDB_PASSWORD=\"foobar\"\n# This will be available everywhere!\nPUBLIC_POKEAPI=\"https://pokeapi.co/api/v2\"\n\nFor more on .env files, see the Vite documentation.\n\nUsing the CLI\nSection titled Using the CLI\n\nYou can also add environment variables as you run your project:\n\nnpm\npnpm\nYarn\nTerminal window\nPUBLIC_POKEAPI=https://pokeapi.co/api/v2 npm run dev\nGetting environment variables\nSection titled Getting environment variables\n\nInstead of using process.env, with Vite you use import.meta.env, which uses the import.meta feature added in ES2020.\n\nFor example, use import.meta.env.PUBLIC_POKEAPI to get the PUBLIC_POKEAPI environment variable.\n\n// When import.meta.env.SSR === true\nconst data = await db(import.meta.env.DB_PASSWORD);\n\n\n// When import.meta.env.SSR === false\nconst data = fetch(`${import.meta.env.PUBLIC_POKEAPI}/pokemon/squirtle`);\n\n CAUTION\n\nBecause Vite statically replaces import.meta.env, you cannot access it with dynamic keys like import.meta.env[key].\n\nWhen using SSR, environment variables can be accessed at runtime based on the SSR adapter being used. With most adapters you can access environment variables with process.env, but some adapters work differently. For the Deno adapter, you will use Deno.env.get(). See how to access the Cloudflare runtime to handle environment variables when using the Cloudflare adapter. Astro will first check the server environment for variables, and if they don‚Äôt exist, Astro will look for them in .env files.\n\nIntelliSense for TypeScript\nSection titled IntelliSense for TypeScript\n\nBy default, Astro provides type definition for import.meta.env in astro/client.d.ts.\n\nWhile you can define more custom env variables in .env.[mode] files, you may want to get TypeScript IntelliSense for user-defined env variables which are prefixed with PUBLIC_.\n\nTo achieve this, you can create an env.d.ts in src/ and configure ImportMetaEnv like this:\n\nsrc/env.d.ts\ninterface ImportMetaEnv {\n  readonly DB_PASSWORD: string;\n  readonly PUBLIC_POKEAPI: string;\n  // more env variables...\n}\n\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv;\n}\nBack\nImport Aliases\nNext Page\nConfiguration"
  },
  {
    "title": "Aliases üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/aliases/",
    "html": "Aliases\n\nAn alias is a way to create shortcuts for your imports.\n\nAliases can help improve the development experience in codebases with many directories or relative imports.\n\nsrc/pages/about/company.astro\n---\nimport Button from '../../components/controls/Button.astro';\nimport logoUrl from '../../assets/logo.png?url';\n---\n\nIn this example, a developer would need to understand the tree relationship between src/pages/about/company.astro, src/components/controls/Button.astro, and src/assets/logo.png. And then, if the company.astro file were to be moved, these imports would also need to be updated.\n\nYou can add import aliases from either tsconfig.json or jsconfig.json.\n\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@components/*\": [\"src/components/*\"],\n      \"@assets/*\": [\"src/assets/*\"]\n    }\n  }\n}\n\n NOTE\n\nMake sure compilerOptions.baseUrl is set so the aliased paths can be resolved.\n\nWith this change, you can now import using the aliases anywhere in your project:\n\nsrc/pages/about/company.astro\n---\nimport Button from '@components/controls/Button.astro';\nimport logoUrl from '@assets/logo.png?url';\n---\n\nThese aliases are also integrated automatically into VS Code and other editors.\n\nBack\nTypeScript\nNext Page\nEnvironment Variables"
  },
  {
    "title": "TypeScript üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/typescript/",
    "html": "TypeScript\n\nAstro ships with built-in support for TypeScript. You can import .ts and .tsx files in your Astro project, write TypeScript code directly inside your Astro component, and even use an astro.config.ts file if you like.\n\nUsing TypeScript, you can prevent errors at runtime by defining the shapes of objects and components in your code. For example, if you use TypeScript to type your component‚Äôs props, you‚Äôll get an error in your editor if you set a prop that your component doesn‚Äôt accept.\n\nYou don‚Äôt need to write TypeScript code in your Astro projects to benefit from it. Astro always treats your component code as TypeScript, and the Astro VSCode Extension will infer as much as it can to provide autocompletion, hints, and errors in your editor.\n\nThe Astro dev server won‚Äôt perform any type checking, but you can use a separate script to check for type errors from the command line.\n\nSetup\nSection titled Setup\n\nAstro starter projects include a tsconfig.json file in your project. Even if you don‚Äôt write TypeScript code, this file is important so that tools like Astro and VS Code know how to understand your project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file. If you install Astro manually, be sure to create this file yourself.\n\nThree extensible tsconfig.json templates are included in Astro: base, strict, and strictest. The base template enables support for modern JavaScript features and is also used as a basis for the other templates. We recommend using strict or strictest if you plan to write TypeScript in your project. You can view and compare the three template configurations at astro/tsconfigs/.\n\nTo inherit from one of the templates, use the extends setting:\n\ntsconfig.json\n{\n  \"extends\": \"astro/tsconfigs/base\"\n}\n\nAdditionally, our templates include an env.d.ts file inside the src folder to provide Vite‚Äôs client types to your project:\n\nenv.d.ts\n/// <reference types=\"astro/client\" />\n\nIf you are not using VSCode, you can install the Astro TypeScript plugin to support importing .astro files from .ts files (which can be useful for re-exporting).\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @astrojs/ts-plugin\n\nThen, add the following to your tsconfig.json:\n\ntsconfig.json\n  \"compilerOptions\": {\n    \"plugins\": [\n      {\n        \"name\": \"@astrojs/ts-plugin\"\n      },\n    ],\n  }\n\nTo check that the plugin is working, create a .ts file and import an Astro component into it. You should have no warning messages from your editor.\n\nUI Frameworks\nSection titled UI Frameworks\n\nIf your project uses a UI framework, additional settings depending on the framework might be needed. Please see your framework‚Äôs TypeScript documentation for more information. (Vue, React, Preact, Solid)\n\nType Imports\nSection titled Type Imports\n\nUse explicit type imports and exports whenever possible.\n\nimport { SomeType } from './script';\nimport type { SomeType } from './script';\n\nThis way, you avoid edge cases where Astro‚Äôs bundler may try to incorrectly bundle your imported types as if they were JavaScript.\n\nYou can configure TypeScript to enforce type imports in your .tsconfig file. Set verbatimModuleSyntax to true. TypeScript will check your imports and tell you when import type should be used. This setting is enabled by default in all our presets.\n\ntsconfig.json\n  {\n    \"compilerOptions\": {\n      \"verbatimModuleSyntax\": true\n    }\n  }\nImport Aliases\nSection titled Import Aliases\n\nAstro supports import aliases that you define in your tsconfig.json & jsconfig.json paths configuration. Read our guide to learn more.\n\nsrc/pages/about/nate.astro\n---\nimport HelloWorld from '@components/HelloWorld.astro';\nimport Layout from '@layouts/Layout.astro';\n---\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"@components/*\": [\"src/components/*\"],\n      \"@layouts/*\": [\"src/layouts/*\"]\n    }\n  }\n}\nExtending window and globalThis\nSection titled Extending window and globalThis\n\nYou may want to add a property to the global object. You can do this by adding top-level declarations using the declare keyword to your env.d.ts file:\n\nenv.d.ts\ndeclare const myString: string;\ndeclare function myFunction(): boolean;\n\nThis will provide typing to globalThis.myString and globalThis.myFunction, as well as window.myString and window.myFunction.\n\nNote that window is only available in client-side code. globalThis is available both server-side and client-side, but its server-side value won‚Äôt be shared with the client.\n\nIf you only want to type a property on the window object, provide a Window interface instead:\n\nenv.d.ts\ninterface Window {\n  myFunction(): boolean;\n}\nComponent Props\nSection titled Component Props\n\nAstro supports typing your component props via TypeScript. To enable, add a TypeScript Props interface to your component frontmatter. An export statement may be used, but is not necessary. The Astro VSCode Extension will automatically look for the Props interface and give you proper TS support when you use that component inside another template.\n\nsrc/components/HelloProps.astro\n---\ninterface Props {\n  name: string;\n  greeting?: string;\n}\nconst { greeting = 'Hello', name } = Astro.props;\n---\n<h2>{greeting}, {name}!</h2>\nCommon prop type patterns\nSection titled Common prop type patterns\n\nIf your component takes no props or slotted content, you can use type Props = Record<string, never>.\n\nIf your component must be passed children to its default slot, you can enforce this by using type Props = { children: any; };.\n\nType Utilities\nSection titled Type Utilities\nAdded in: astro@1.6.0\n\nAstro comes with some built-in utility types for common prop type patterns. These are available under the astro/types entrypoint.\n\nBuilt-in HTML attributes\nSection titled Built-in HTML attributes\n\nAstro provides the HTMLAttributes type to check that your markup is using valid HTML attributes. You can use these types to help build component props.\n\nFor example, if you were building a <Link> component, you could do the following to mirror the default HTML attributes for <a> tags in your component‚Äôs prop types.\n\nsrc/components/Link.astro\n---\nimport type { HTMLAttributes } from 'astro/types'\n// use a `type`\ntype Props = HTMLAttributes<'a'>;\n// or extend with an `interface`\ninterface Props extends HTMLAttributes<'a'> {\n  myProp?: boolean;\n}\nconst { href, ...attrs } = Astro.props;\n---\n<a href={href} {...attrs}>\n  <slot />\n</a>\n\nIt is also possible to extend the default JSX definitions to add non-standard attributes by redeclaring the astroHTML.JSX namespace in a .d.ts file.\n\nsrc/custom-attributes.d.ts\ndeclare namespace astroHTML.JSX {\n  interface HTMLAttributes {\n    'data-count'?: number;\n    'data-label'?: string;\n  }\n}\n\n NOTE\n\nastroHTML is injected globally inside .astro components. To use it in TypeScript files, use a triple-slash directive:\n\n/// <reference types=\"astro/astro-jsx\" />\n\n\ntype MyAttributes = astroHTML.JSX.ImgHTMLAttributes;\nPolymorphic type\nSection titled Polymorphic type\nAdded in: astro@2.5.0\n\nAstro includes a helper to make it easier to build components that can render as different HTML elements with full type safety. This is useful for components like <Link> that can render as either <a> or <button> depending on the props passed to it.\n\nThe example below implements a fully-typed, polymorphic component that can render as any HTML element. The HTMLTag type is used to ensure that the as prop is a valid HTML element.\n\n---\nimport { HTMLTag, Polymorphic } from 'astro/types';\n\n\ntype Props<Tag extends HTMLTag> = Polymorphic<{ as: Tag }>;\n\n\nconst { as: Tag, ...props } = Astro.props;\n---\n\n\n<Tag {...props} />\nInfer getStaticPaths() types\nSection titled Infer getStaticPaths() types\nAdded in: astro@2.1.0\n\nAstro includes helpers for working with the types returned by your getStaticPaths() function for dynamic routes.\n\nYou can get the type of Astro.params with InferGetStaticParamsType and the type of Astro.props with InferGetStaticPropsType:\n\nsrc/pages/posts/[...slug].astro\n---\nimport { InferGetStaticParamsType, InferGetStaticPropsType, GetStaticPaths } from 'astro';\n\n\nexport const getStaticPaths = (async () => {\n  const posts = await getCollection('blog');\n  return posts.map((post) => {\n    return {\n      params: { slug: post.slug },\n      props: { draft: post.data.draft, title: post.data.title },\n    };\n  });\n}) satisfies GetStaticPaths;\n\n\ntype Params = InferGetStaticParamsType<typeof getStaticPaths>;\ntype Props = InferGetStaticPropsType<typeof getStaticPaths>;\n\n\nconst { slug } = Astro.params as Params;\n//                      ^? { slug: string; }\nconst { title } = Astro.props;\n//                      ^? { draft: boolean; title: string; }\n---\nType checking\nSection titled Type checking\n\nTo see type errors in your editor, please make sure that you have the Astro VS Code extension installed. Please note that the astro start and astro build commands will transpile the code with esbuild, but will not run any type checking. To prevent your code from building if it contains TypeScript errors, change your ‚Äúbuild‚Äù script in package.json to the following:\n\npackage.json\n  \"scripts\": {\n    \"build\": \"astro build\",\n    \"build\": \"astro check && astro build\",\n  },\n\n NOTE\n\nastro check checks all the files included in your TypeScript project. To check types within Svelte and Vue files, you can use the svelte-check and the vue-tsc packages respectively.\n\nüìö Read more about .ts file imports in Astro.\n\nüìö Read more about TypeScript Configuration.\n\nTroubleshooting\nSection titled Troubleshooting\nErrors Typing multiple JSX frameworks at the same time\nSection titled Errors Typing multiple JSX frameworks at the same time\n\nAn issue may arise when using multiple JSX frameworks in the same project, as each framework requires different, sometimes conflicting, settings inside tsconfig.json.\n\nSolution: Set the jsxImportSource setting to react (default), preact or solid-js depending on your most-used framework. Then, use a pragma comment inside any conflicting file from a different framework.\n\nFor the default setting of jsxImportSource: react, you would use:\n\n// For Preact\n/** @jsxImportSource preact */\n\n\n// For Solid\n/** @jsxImportSource solid-js */\nBack\nThe Astro Config File\nNext Page\nImport Aliases"
  },
  {
    "title": "Configuring Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/configuring-astro/",
    "html": "Configuring Astro\n\nCustomize how Astro works by adding an astro.config.mjs file in your project. This is a common file in Astro projects, and all official example templates and themes ship with one by default.\n\nüìö Read Astro‚Äôs API configuration reference for a full overview of all supported configuration options.\n\nThe Astro Config File\nSection titled The Astro Config File\n\nA valid Astro config file exports its configuration using the default export, using the recommended defineConfig helper:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  // your configuration options here...\n  // https://docs.astro.build/en/reference/configuration-reference/\n})\n\nUsing defineConfig() is recommended for automatic type hints in your IDE, but it is also optional. An absolutely bare-minimum, valid configuration file would look like this:\n\nastro.config.mjs\n// Example: Bare minimum, empty configuration file\nexport default {}\nSupported Config File Types\nSection titled Supported Config File Types\n\nAstro supports several file formats for its JavaScript configuration file: astro.config.js, astro.config.mjs, astro.config.cjs and astro.config.ts. We recommend using .mjs in most cases or .ts if you want to write TypeScript in your config file.\n\nTypeScript config file loading is handled using tsm and will respect your project tsconfig options.\n\nConfig File Resolving\nSection titled Config File Resolving\n\nAstro will automatically try to resolve a config file named astro.config.mjs inside project root. If no config file is found in your project root, Astro‚Äôs default options will be used.\n\nTerminal window\n# Example: Reads your configuration from ./astro.config.mjs\nastro build\n\nYou can explicitly set a config file to use with the --config CLI flag. This CLI flag always resolves relative to the current working directory where you ran the astro CLI command.\n\nTerminal window\n# Example: Reads your configuration from this file\nastro build --config my-config-file.js\nConfig IntelliSense\nSection titled Config IntelliSense\n\nAstro recommends using the defineConfig() helper in your configuration file. defineConfig() provides automatic IntelliSense in your IDE. Editors like VSCode are able to read Astro‚Äôs TypeScript type definitions and provide automatic jsdoc type hints, even if your configuration file isn‚Äôt written in TypeScript.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  // your configuration options here...\n  // https://docs.astro.build/en/reference/configuration-reference/\n})\n\nYou can also provide type definitions manually to VSCode, using this JSDoc notation:\n\nastro.config.mjs\nexport default /** @type {import('astro').AstroUserConfig} */ {\n  // your configuration options here...\n  // https://docs.astro.build/en/reference/configuration-reference/\n}\nReferencing Relative Files\nSection titled Referencing Relative Files\n\nIf you provide a relative path to root or the --root CLI flag, Astro will resolve it against the current working directory where you ran the astro CLI command.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  // Resolves to the \"./foo\" directory in your current working directory\n  root: 'foo'\n})\n\nAstro will resolve all other relative file and directory strings as relative to the project root:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  // Resolves to the \"./foo\" directory in your current working directory\n  root: 'foo',\n  // Resolves to the \"./foo/public\" directory in your current working directory\n  publicDir: 'public',\n})\n\nTo reference a file or directory relative to the configuration file, use import.meta.url (unless you are writing a common.js astro.config.cjs file).\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  // Resolves to the \"./foo\" directory, relative to this config file\n  root: new URL(\"./foo\", import.meta.url).toString(),\n  // Resolves to the \"./public\" directory, relative to this config file\n  publicDir: new URL(\"./public\", import.meta.url).toString(),\n})\n\n NOTE\n\nVite-specific import.meta properties, like import.meta.env or import.meta.glob, are not accessible from your configuration file. We recommend alternatives like dotenv or fast-glob for these respective use cases.\n\nCustomising Output Filenames\nSection titled Customising Output Filenames\n\nFor code that Astro processes, like imported JavaScript or CSS files, you can customise output filenames using entryFileNames, chunkFileNames, and assetFileNames in a vite.build.rollupOptions entry in your astro.config.* file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nexport default defineConfig({\n  vite: {\n    build: {\n      rollupOptions: {\n        output: {\n          entryFileNames: 'entry.[hash].mjs',\n          chunkFileNames: 'chunks/chunk.[hash].mjs',\n          assetFileNames: 'assets/asset.[hash][extname]',\n        },\n      },\n    },\n  },\n})\n\nThis can be helpful if you have scripts with names that might be impacted by ad blockers (e.g. ads.js or google-tag-manager.js).\n\nEnvironment Variables\nSection titled Environment Variables\n\nAstro evaluates configuration files before it loads your other files. As such, you can‚Äôt use import.meta.env to access environment variables that were set in .env files.\n\nYou can use process.env in a configuration file to access other environment variables, like those set by the CLI.\n\nYou can also use Vite‚Äôs loadEnv helper to manually load .env files.\n\n NOTE\n\npnpm does not allow you to import modules that are not directly installed in your project. If you are using pnpm, you will need to install vite to use the loadEnv helper.\n\nTerminal window\npnpm add vite --save-dev\nastro.config.mjs\nimport { loadEnv } from \"vite\";\nconst { SECRET_PASSWORD } = loadEnv(process.env.NODE_ENV, process.cwd(), \"\");\nConfiguration Reference\nSection titled Configuration Reference\n\nüìö Read Astro‚Äôs API configuration reference for a full overview of all supported configuration options.\n\nBack\nTroubleshooting\nNext Page\nTypeScript"
  },
  {
    "title": "Troubleshooting üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/troubleshooting/",
    "html": "Troubleshooting\n\nAstro provides several different tools to help you troubleshoot and debug your code.\n\nTips and tricks\nSection titled Tips and tricks\nDebugging with console.log()\nSection titled Debugging with console.log()\n\nconsole.log() is a simple-but-popular method of debugging your Astro¬†code. Where you write your console.log() statement will determine where your debugging output is printed:\n\n---\nconsole.log('Hi! I‚Äôm the server. This is logged in the terminal where Astro is running.');\n---\n\n\n<script>\nconsole.log('Hi! I‚Äôm the client. This is logged in browser dev console.');\n</script>\n\nA console.log() statement in Astro frontmatter will always output to the terminal running the Astro CLI. This is because Astro runs on the server, and never in the browser.\n\nCode that is written or imported inside of an Astro <script> tag is run in the browser. Any console.log() statements or other debug output will be printed to the console in your browser.\n\nDebugging framework components\nSection titled Debugging framework components\n\nFramework components (like React and Svelte) are unique: They render server-side by default, meaning that console.log() debug output will be visible in the terminal. However, they can also be hydrated for the browser, which may cause your debug logs to also appear in the browser.\n\nThis can be useful for debugging differences between the SSR output and the hydrated components in the browser.\n\nAstro <Debug /> component\nSection titled Astro &lt;Debug /&gt; component\n\nTo help you debug your Astro components, Astro provides a built-in <Debug /> component which renders any value directly into your component HTML template. This is useful for quick debugging in the browser without having to flip back-and-forth between your terminal and your browser.\n\n---\nimport { Debug } from 'astro:components';\nconst sum = (a, b) => a + b;\n---\n\n\n<!-- Example: Outputs {answer: 6} to the browser -->\n<Debug answer={sum(2, 4)} />\n\nThe Debug component supports a variety of syntax options for even more flexible and concise debugging:\n\n---\nimport { Debug } from 'astro:components';\nconst sum = (a, b) => a + b;\nconst answer = sum(2, 4);\n---\n<!-- Example: All three examples are equivalent. -->\n<Debug answer={sum(2, 4)} />\n<Debug {{answer: sum(2, 4)}} />\n<Debug {answer} />\nCommon Error Messages\nSection titled Common Error Messages\n\nHere are some common error messages you might see in the terminal, what they might mean, and what to do about them. See our full error reference guide for a complete list of Astro errors you may encounter.\n\nCannot use import statement outside a module\nSection titled Cannot use import statement outside a module\n\nIn Astro components, <script> tags are hoisted and loaded as JS modules by default. If you have included the is:inline directive or any other attribute in your tag, this default behavior is removed.\n\nSolution: If you have added any attributes to your <script> tag, you must also add the type=\"module\" attribute to be able to use import statements.\n\nStatus: Expected Astro behavior, as intended.\n\nNot sure that this is your problem?\nCheck to see if anyone else has reported this issue!\n\ndocument (or window) is not defined\nSection titled document (or window) is not defined\n\nThis error occurs when trying to access document or window on the server.\n\nAstro components run on the server, so you can‚Äôt access these browser-specific objects within the frontmatter.\n\nFramework components run on the server by default, so this error can occur when accessing document or window during rendering.\n\nSolution: Determine the code that calls document or window. If you aren‚Äôt using document or window directly and still getting this error, check to see if any packages you‚Äôre importing are meant to run on the client.\n\nIf the code is in an Astro component, move it to a <script> tag outside of the frontmatter. This tells Astro to run this code on the client, where document and window are available.\n\nIf the code is in a framework component, try to access these objects after rendering using lifecycle methods (e.g. useEffect() in React, onMounted() in Vue, and onMount() in Svelte). Tell the framework component to hydrate client-side by using a client: directive, like client:load, to run these lifecycle methods. You can also prevent the component from rendering on the server at all by adding the client:only directive.\n\nStatus: Expected Astro behavior, as intended.\n\nExpected a default export\nSection titled Expected a default export\n\nThis error can be thrown when trying to import or render an invalid component, or one that is not working properly. (This particular message occurs because of the way importing a UI component works in Astro.)\n\nSolution: Try looking for errors in any component you are importing and rendering, and make sure it‚Äôs working correctly. Consider opening an Astro starter template from astro.new and troubleshooting just your component in a minimal Astro project.\n\nStatus: Expected Astro behavior, as intended.\n\nRefused to execute inline script\nSection titled Refused to execute inline script\n\nYou may see the following error logged in the browser console:\n\nRefused to execute inline script because it violates the following Content Security Policy directive: ‚Ä¶\n\nThis means that your site‚Äôs Content Security Policy (CSP) disallows running inline <script> tags, which Astro outputs by default.\n\nSolution: Update your CSP to include script-src: 'unsafe-inline' to allow inline scripts to run.\n\nCommon gotchas\nSection titled Common gotchas\nMy component is not rendering\nSection titled My component is not rendering\n\nFirst, check to see that you have imported the component in your .astro component script or .mdx file.\n\nThen check your import statement:\n\nIs your import linking to the wrong place? (Check your import path.)\n\nDoes your import have the same name as the imported component? (Check your component name and that it follows the .astro syntax.)\n\nHave you included the extension in the import? (Check that your imported file contains an extension. e.g. .astro, .md, .vue, .svelte. Note: File extensions are not required for .js(x) and .ts(x) files only.)\n\nMy component is not interactive\nSection titled My component is not interactive\n\nIf your component is rendering (see above) but is not responding to user interaction, then you may be missing a client:* directive to hydrate your component.\n\nBy default, a UI Framework component is not hydrated in the client. If no client:* directive is provided, its HTML is rendered onto the page without JavaScript.\n\n TIP\n\nAstro components are HTML-only templating components with no client-side runtime. But, you can use a <script> tag in your Astro component template to send JavaScript to the browser that executes in the global scope.\n\nCannot find package ‚ÄòX‚Äô\nSection titled Cannot find package ‚ÄòX‚Äô\n\nIf you see a \"Cannot find package 'react'\" (or similar) warning when you start up Astro, that means that you need to install that package into your project. Not all package managers will install peer dependencies for you automatically. If you are on Node v16+ and using npm, you should not need to worry about this section.\n\nReact, for example, is a peer dependency of the @astrojs/react integration. That means that you should install the official react and react-dom packages alongside your integration. The integration will then pull from these packages automatically.\n\nTerminal window\n# Example: Install integrations and frameworks together\nnpm install @astrojs/react react react-dom\n\nSee Astro‚Äôs integration guide for instructions on adding framework renderers, CSS tools and other packages to Astro.\n\nAstro.glob() - no matches found\nSection titled Astro.glob() - no matches found\n\nWhen using Astro.glob() to import files, be sure to use the correct glob syntax that will match all the files you need.\n\nFilepaths\nSection titled Filepaths\n\nFor example, use ../components/**/*.js in src/pages/index.astro to import both of the following files:\n\nsrc/components/MyComponent.js\nsrc/components/includes/MyOtherComponent.js\nSupported Values\nSection titled Supported Values\n\nAstro.glob() does not support dynamic variables and string interpolation.\n\nThis is not a bug in Astro. It is due to a limitation of Vite‚Äôs import.meta.glob() function which only supports static string literals.\n\nA common workaround is to instead import a larger set of files that includes all the files you need using Astro.glob(), then filter them:\n\nsrc/components/featured.astro\n---\nconst { postSlug } = Astro.props;\nconst pathToMyFeaturedPost = `src/pages/blog/${postSlug}.md`;\n\n\nconst posts = await Astro.glob('../pages/blog/*.md');\nconst myFeaturedPost = posts.find(post => post.file.includes(pathToMyFeaturedPost));\n---\n\n\n<p>\n  Take a look at my favorite post, <a href={myFeaturedPost.url}>{myFeaturedPost.frontmatter.title}</a>!\n</p>\nUsing Astro with Yarn 2+ (Berry)\nSection titled Using Astro with Yarn 2+ (Berry)\n\nYarn 2+, a.k.a. Berry, uses a technique called Plug‚Äôn‚ÄôPlay (PnP) to store and manage Node modules, which can cause problems while initializing a new Astro project using create astro or while working with Astro. A workaround is to set the nodeLinker property in .yarnrc.yml to node-modules:\n\n.yarnrc.yml\nnodeLinker: \"node-modules\"\nAdding dependencies to Astro in a monorepo\nSection titled Adding dependencies to Astro in a monorepo\n\nWhen working with Astro in a monorepo setup, project dependencies should be added in each project‚Äôs own package.json file.\n\nHowever, you may also want to use Astro in the root of the monorepo (e.g. Nx projects recommend installing dependencies at the root). In this case, manually add Astro-related dependencies (e.g. @astrojs/vue, astro-component-lib) to the vite.ssr.noExternal part of Astro‚Äôs config to ensure that these dependencies are properly installed and bundled:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\nexport default defineConfig({\n  vite: {\n    ssr: {\n      noExternal: [\n        '@astrojs/vue',\n        'astro-component-lib',\n      ]\n    }\n  }\n})\nUsing <head> in a component\nSection titled Using &lt;head&gt; in a component\n\nIn Astro, using a <head> tag works like any other HTML tag: it does not get moved to the top of the page or merged with the existing <head>. Because of this, you usually only want to include one <head> tag throughout a page. We recommend writing that single <head> and its contents in a layout component.\n\nAn unexpected <script> or <style> is included\nSection titled An unexpected &lt;script&gt; or &lt;style&gt; is included\n\nYou may notice an imported component‚Äôs <script> or <style> tags included in your HTML source even if that component doesn‚Äôt appear in the final output. For example, this will occur with conditionally rendered components that are not displayed.\n\nAstro‚Äôs build process works on the module graph: once a component is included in the template, its <script> and <style> tags are processed, optimized, and bundled, whether it appears in the final output or not. This does not apply to scripts when the is:inline directive is applied.\n\nCreating minimal reproductions\nSection titled Creating minimal reproductions\n\nWhen troubleshooting your code, it can be helpful to create a minimal reproduction of the issue that you can share. This is a smaller, simplified Astro project that demonstrates your issue. Having a working reproduction in a new project helps to confirm that this is a repeatable problem, and is not caused by something else in your personal environment or existing project.\n\nSharing a minimal reproduction is helpful when asking for help in our support threads and is often required when filing a bug report to Astro.\n\nCreate a StackBlitz via astro.new\nSection titled Create a StackBlitz via astro.new\n\nYou can use astro.new to create a new Astro project with a single click. For minimal reproductions, we strongly recommend starting from the minimal (empty) example running in StackBlitz, with as little extra code as possible.\n\nStackBlitz will run this Astro project in the browser, outside of your local environment. It will also provide you with a shareable link so that any Astro maintainer or support squad member can view your minimal reproduction outside of their own local environment. This means that everyone is viewing the exact same project, with the same configuration and dependencies. This makes it easy for someone else to help troubleshoot your code. If the issue is reproducible, it allows you to verify that the issue lies within the Astro code itself and you can feel confident submitting a bug report.\n\nNote that not every issue is reproducible in StackBlitz. For example, your issue might be dependent on a specific environment or package manager, or it may involve HTML Streaming, which isn‚Äôt supported in StackBlitz. In this case, create a new minimal (empty) Astro project using the CLI, reproduce the issue, and upload it to a GitHub repository. Instead of sharing a StackBlitz URL, provide a link to the GitHub repository of your minimal reproduction.\n\nMinimal code\nSection titled Minimal code\n\nOnce your empty project is set up, go through the steps to reproduce the issue. This can include adding packages, changing configuration, and writing code.\n\nYou should only add the minimum amount of code necessary to reproduce the issue. Do not reproduce other elements of your existing project, and remove all code that is not directly related to the issue.\n\nCreate an issue\nSection titled Create an issue\n\nIf your issue can be reproduced, then it is time to create an issue and file a bug report!\n\nGo to the appropriate Astro repository on GitHub and open a new issue. Most repositories have an issue template that will ask questions or require information in order to submit. It‚Äôs important that you follow these templates because if you don‚Äôt provide the information we need, then we have to ask you for it‚Ä¶ and no one is working on your issue!\n\nInclude the link to your minimal reproduction on StackBlitz (or GitHub repository, if necessary). Start with a description of the expected versus actual behavior to provide context for the issue. Then, include clear, step-by-step instructions on how to replicate the issue in an Astro project.\n\nNeed more?\nSection titled Need more?\n\nCome and chat with us on Discord and explain your issue in the #support forum channel. We‚Äôre always happy to help!\n\nVisit the current open Issues in Astro to see if you are encountering a known problem or file a bug report.\n\nYou can also visit RFC Discussions to see whether you‚Äôve found a known limitation of Astro, and check to see whether there are current proposals related to your use case.\n\nBack\nTesting\nNext Page\nThe Astro Config File"
  },
  {
    "title": "Testing üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/testing/",
    "html": "Testing\n\nTesting helps you write and maintain working Astro code. Astro supports many popular tools for unit tests, component tests, and end-to-end tests including Jest, Mocha, Jasmine, Cypress and Playwright. You can even install framework-specific testing libraries such as React Testing Library to test your UI framework components.\n\nTesting frameworks allow you to state assertions or expectations about how your code should behave in specific situations, then compare these to the actual behavior of your current code.\n\nVitest\nSection titled Vitest\n\nA Vite-native unit test framework with ESM, TypeScript and JSX support powered by esbuild.\n\nUse Astro‚Äôs getViteConfig() helper in your vitest.config.ts configuration file to set up Vitest with your Astro project‚Äôs settings:\n\nvitest.config.ts\nimport { getViteConfig } from 'astro/config';\n\n\nexport default getViteConfig({\n  test: {\n    // Vitest configuration options\n  },\n});\n\nSee the Astro + Vitest starter template on GitHub.\n\nCypress\nSection titled Cypress\n\nCypress is a front-end testing tool built for the modern web. Cypress enables you to write end-to-end tests for your Astro site.\n\nInstallation\nSection titled Installation\n\nYou can install Cypress using the package manager of your choice.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install -D cypress\n\nThis will install Cypress locally as a dev dependency for your project.\n\nConfiguration\nSection titled Configuration\n\nIn the root of your project, create a cypress.config.js file with the following content:\n\ncypress.config.js\nimport { defineConfig } from 'cypress'\n\n\nexport default defineConfig({\n  e2e: {\n    supportFile: false\n  }\n})\nCreate your first Cypress test\nSection titled Create your first Cypress test\n\nChoose a page to test. This example will test the example page index.astro below.\n\nsrc/pages/index.astro\n---\n---\n<html lang=\"en\">\n  <head>\n    <title>Astro is awesome!</title>\n    <meta name=\"description\" content=\"Pull content from anywhere and serve it fast with Astro's next-gen island architecture.\" />\n  </head>\n  <body>\n  <h1>Hello world from Astro</h1>\n  </body>\n</html>\n\nCreate an index.cy.js file in the cypress/e2e folder. Use the following test in the file to verify that the page title and header are correct.\n\ncypress/e2e/index.cy.js\nit('titles are correct', () => {\n  const page = cy.visit('http://localhost:4321');\n\n\n  page.get('title').should('have.text', 'Astro is awesome!')\n  page.get('h1').should('have.text', 'Hello world from Astro');\n});\n\n SET A BASEURL\n\nYou can set \"baseUrl\": \"http://localhost:4321\" in the cypress.config.js configuration file to use cy.visit(\"/\") instead of cy.visit(\"http://localhost:4321/\") for a more convenient URL.\n\nRunning your Cypress tests\nSection titled Running your Cypress tests\n\nCypress can be run from the command line or from the Cypress App. The App provides a visual interface for running and debugging your tests.\n\nFirst, start the dev server so Cypress can access your live site.\n\nTo run our test from the previous example using the command line, execute the following command:\n\nTerminal window\nnpx cypress run\n\nAlternatively, to run the test using the Cypress App, execute the following command:\n\nTerminal window\nnpx cypress open\n\nOnce the Cypress App is launched, choose E2E Testing, then select the browser to be used to run tests.\n\nOnce the test run is finished, you should see green check marks in the output confirming that your test passed:\n\nOutput from npx cypress run\nRunning:  index.cy.js                                                                     (1 of 1)\n\n\n\n\n‚úì titles are correct (107ms)\n\n\n1 passing (1s)\n\n FAIL THE TEST\n\nTo check that your test really does work, you can change the following line in the index.astro file:\n\nsrc/pages/index.astro\n <body>\n   <h1>Hello world from Astro</h1>\n   <h1>Hello from Astro</h1>\n </body>\n\nThen run the test again. You should see a red ‚Äúx‚Äù in the output confirming that your test failed.\n\nNext steps\nSection titled Next steps\n\nMore information about Cypress can be found in the links below:\n\nIntroduction to Cypress\nTesting Your App\nPlaywright\nSection titled Playwright\n\nPlaywright is an end-to-end testing framework for modern web apps. Use the Playwright API in JavaScript or TypeScript to test your Astro code on all modern rendering engines including Chromium, WebKit, and Firefox.\n\nInstallation\nSection titled Installation\n\nYou can get started and run your tests using the VS Code Extension.\n\nAlternatively, you can install Playwright within your Astro project using the package manager of your choice. Follow the CLI steps to choose JavaScript/TypeScript, name your test folder, and add an optional GitHub Actions workflow.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm init playwright@latest\nCreate your first Playwright test\nSection titled Create your first Playwright test\n\nChoose a page to test. This example will test the example page index.astro below.\n\nsrc/pages/index.astro\n---\n---\n<html lang=\"en\">\n  <head>\n    <title>Astro is awesome!</title>\n    <meta name=\"description\" content=\"Pull content from anywhere and serve it fast with Astro's next-gen island architecture.\" />\n  </head>\n  <body></body>\n</html>\n\nCreate a new folder and add the following test file in src/test. Copy and paste the following test into the file to verify that the page meta information is correct. Update the value of the page <title> to match the page you are testing.\n\nsrc/test/index.spec.ts\nimport { test, expect } from '@playwright/test';\n\n\ntest('meta is correct', async ({ page }) => {\n  await page.goto(\"http://localhost:4321/\");\n\n\n  await expect(page).toHaveTitle('Astro is awesome!');\n});\n\n SET A BASEURL\n\nYou can set \"baseURL\": \"http://localhost:4321\" in the playwright.config.ts configuration file to use page.goto(\"/\") instead of page.goto(\"http://localhost:4321/\") for a more convenient URL.\n\nRunning your Playwright tests\nSection titled Running your Playwright tests\n\nYou can run a single test or several tests at once, testing one or multiple browsers. By default, your test results will be shown in the terminal. Optionally, you can open the HTML Test Reporter to show a full report and filter test results.\n\nTo run our test from the previous example using the command line, use the test command. Optionally, include the file name to run just the single test:\n\nTerminal window\nnpx playwright test index.spec.ts\n\nTo see the full HTML Test Report, open it using the following command:\n\nTerminal window\nnpx playwright show-report\n\n TIP\n\nRun your tests against your production code to more closely resemble your live, deployed site.\n\nAdvanced: Launching a development web server during the tests\nSection titled Advanced: Launching a development web server during the tests\n\nYou can also have Playwright start your server when you run your testing script by using the webServer option in the Playwright configuration file.\n\nHere is an example of the configuration and commands required when using npm:\n\nAdd a test script to your package.json file in the project root, such as \"test:e2e\": \"playwright test\".\n\nIn playwright.config.ts, add the webServer object and update the command value to npm run preview.\n\nplaywright.config.ts\nimport { defineConfig } from '@playwright/test';\n\n\nexport default defineConfig({\n  webServer: {\n    command: 'npm run preview',\n    url: 'http://localhost:4321/',\n    timeout: 120 * 1000,\n    reuseExistingServer: !process.env.CI,\n  },\n  use: {\n    baseURL: 'http://localhost:4321/',\n  },\n});\n\nRun npm run build, then run npm run test:e2e to run the Playwright tests.\n\nMore information about Playwright can be found in the links below:\n\nGetting started with Playwright\nUse a development server\nBack\nMiddleware\nNext Page\nTroubleshooting"
  },
  {
    "title": "Middleware üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/middleware/",
    "html": "Middleware\n\nMiddleware allows you to intercept requests and responses and inject behaviors dynamically every time a page or endpoint is about to be rendered.\n\nThis also allows you to set and share request-specific information across endpoints and pages by mutating a locals object that is available in all Astro components and API endpoints\n\nMiddleware is available in both SSG and SSR Astro projects.\n\nBasic Usage\nSection titled Basic Usage\n\nCreate src/middleware.js|ts (Alternatively, you can create src/middleware/index.js|ts.)\n\nInside this file, export an onRequest() function that can be passed a context object and next() function. This must not be a default export.\n\nsrc/middleware.js\nexport function onRequest ({ locals, request }, next) {\n    // intercept response data from a request\n    // optionally, transform the response by modifying `locals`\n    locals.title = \"New title\";\n\n\n    // return a Response or the result of calling `next()`\n    return next();\n};\n\nInside any .astro file, access response data using Astro.locals.\n\nsrc/components/Component.astro\n---\nconst data = Astro.locals;\n---\n<h1>{data.title}</h1>\n<p>This {data.property} is from middleware.</p>\nThe context object\nSection titled The context object\n\nThe context object includes information to be made available to other middleware, API routes and .astro routes during the rendering process.\n\nThis is an optional argument passed to onRequest() that may contain the locals object as well as any additional properties to be shared during rendering. For example, the context object may include cookies used in authentication.\n\nStoring data in context.locals\nSection titled Storing data in context.locals\n\ncontext.locals is an object containing data from a Response that can be manipulated inside middleware.\n\nThis locals object is forwarded across the request handling process and is available as a property to APIContext and AstroGlobal . This allows data to be shared between middlewares, API routes, and .astro pages. This is useful for storing request-specific data, such as user data, across the rendering step.\n\nYou can store any type of data inside locals: strings, numbers, and even complex data types such as functions and maps.\n\nsrc/middleware.js\nexport function onRequest ({ locals, request }, next) {\n    // intercept response data from a request\n    // optionally, transform the response by modifying `locals`\n    locals.user.name = \"John Wick\";\n    locals.welcomeTitle = () => {\n        return \"Welcome back \" + locals.user.name;\n    };\n\n\n    // return a Response or the result of calling `next()`\n    return next();\n};\n\nThen you can use this information inside any .astro file with Astro.locals.\n\nsrc/pages/orders.astro\n---\nconst title = Astro.locals.welcomeTitle();\nconst orders = Array.from(Astro.locals.orders.entries());\n---\n<h1>{title}</h1>\n<p>This {data.property} is from middleware.</p>\n<ul>\n    {orders.map(order => {\n        return <li>{/* do something with each order */}</li>;\n    })}\n</ul>\n\nlocals is an object that lives and dies within a single Astro route; when your route page is rendered, locals won‚Äôt exist anymore and a new one will be created. Information that needs to persist across multiple page requests must be stored elsewhere.\n\n NOTE\n\nThe value of locals cannot be overridden at run time. Doing so would risk wiping out all the information stored by the user. In dev mode, Astro performs checks and will throw an error if locals are overridden.\n\nExample: redacting sensitive information\nSection titled Example: redacting sensitive information\n\nThe example below uses middleware to replace ‚ÄúPRIVATE INFO‚Äù with the word ‚ÄúREDACTED‚Äù to allow you to render modified HTML on your page:\n\nsrc/middleware.js\nexport const onRequest = async (context, next) => {\n    const response = await next();\n    const html = await response.text();\n    const redactedHtml = html.replaceAll(\"PRIVATE INFO\", \"REDACTED\");\n\n\n    return new Response(redactedHtml, {\n        status: 200,\n        headers: response.headers\n    });\n};\nMiddleware types\nSection titled Middleware types\n\nYou can import and use the utility function defineMiddleware() to take advantage of type safety:\n\nsrc/middleware.ts\nimport { defineMiddleware } from \"astro:middleware\";\n\n\n// `context` and `next` are automatically typed\nexport const onRequest = defineMiddleware((context, next) => {\n\n\n});\n\nInstead, if you‚Äôre using JsDoc to take advantage of type safety, you can use MiddlewareResponseHandler:\n\nsrc/middleware.js\n/**\n * @type {import(\"astro\").MiddlewareResponseHandler}\n */\n// `context` and `next` are automatically typed\nexport const onRequest = (context, next) => {\n\n\n};\n\nTo type the information inside Astro.locals, which gives you autocompletion inside .astro files and middleware code, declare a global namespace in the env.d.ts file:\n\nsrc/env.d.ts\n/// <reference types=\"astro/client\" />\ndeclare namespace App {\n    interface Locals {\n        user: {\n            name: string\n        },\n        welcomeTitle: () => string,\n        orders: Map<string, object>\n    }\n}\n\nThen, inside the middleware file, you can take advantage of autocompletion and type safety.\n\nChaining middleware\nSection titled Chaining middleware\n\nMultiple middlewares can be joined in a specified order using sequence():\n\nsrc/middleware.js\nimport { sequence } from \"astro:middleware\";\n\n\nasync function validation(_, next) {\n    console.log(\"validation request\");\n    const response = await next();\n    console.log(\"validation response\");\n    return response;\n}\n\n\nasync function auth(_, next) {\n    console.log(\"auth request\");\n    const response = await next();\n    console.log(\"auth response\");\n    return response;\n}\n\n\nasync function greeting(_, next) {\n    console.log(\"greeting request\");\n    const response = await next();\n    console.log(\"greeting response\");\n    return response;\n}\n\n\nexport const onRequest = sequence(validation, auth, greeting);\n\nThis will result in the following console order:\n\nTerminal window\nvalidation request\nauth request\ngreeting request\ngreeting response\nauth response\nvalidation response\nBack\nInternationalization\nNext Page\nTesting"
  },
  {
    "title": "Internationalization üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/internationalization/",
    "html": "Internationalization\n\nAstro‚Äôs internationalization (i18n) features allow you to adapt your project for an international audience.\n\ni18n Routing (Experimental)\nSection titled i18n Routing (Experimental)\nAdded in: astro@3.5.0\n\nAstro‚Äôs experimental i18n routing allows you to add your multilingual content with support for configuring a default language, computing relative page URLs, and accepting preferred languages provided by your visitor‚Äôs browser. You can also specify fallback languages on a per-language basis so that your visitors can always be directed to existing content on your site.\n\nThis routing API helps you generate, use, and verify the URLs that your multi-language site produces. Check back and update regularly for the latest changes as this API continues to develop!\n\nConfigure i18n routing\nSection titled Configure i18n routing\n\nEnable the experimental routing option by adding an i18n object to your Astro configuration with a default location (defaultLocale) and a list of all languages to support (locales):\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\"\nexport default defineConfig({\n  experimental: {\n    i18n: {\n      defaultLocale: \"en\",\n      locales: [\"en\", \"es\", \"pt-br\"]\n    }\n  }\n})\n\nChoose and configure a routingStrategy based on the desired URL path for your defaultLocale:\n\n\"prefix-other-locales\" (default): URLs in your default language will not have a /[locale]/ prefix. All other locales will.\n\n\"prefix-always\": All URLs, including your default language, will have a /[locale]/ prefix.\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\"\nexport default defineConfig({\n  experimental: {\n    i18n: {\n      defaultLocale: \"en\",\n      locales: [\"es\", \"en\", \"fr\"],\n      routingStrategy: \"prefix-always\"\n    }\n  }\n})\n\nOrganize your content folders with localized content by language. Your folder names must match the items in locales exactly, and your folder organization must match the URL paths chosen for your routingStrategy.\n\nInclude a localized folder for your defaultLocale only if you configure prefix-always to show a localized URL path.\n\nDirectory\nsrc\nDirectory\npages\nabout.astro\nindex.astro\nDirectory\nes\nabout.astro\nindex.astro\nDirectory\npt-br\nabout.astro\nindex.astro\n\n NOTE\n\nThe localized folders do not need to be at the root of the /pages/ folder.\n\nCreate individual /[locale]/ folders anywhere within src/pages/ and Astro‚Äôs file-based routing will create your pages at corresponding URL paths.\n\nWith i18n routing configured, you can now compute links to pages within your site using the getRelativeLocaleURL() helper available from the astro:i18n module. This will always provide the correct, localized route and can help you correctly use, or check, URLs on your site. You can also still write the links manually.\n\nsrc/pages/es/index.astro\n---\nimport { getRelativeLocaleUrl } from 'astro:i18n';\n\n\n// defaultLocale is \"es\"\nconst aboutURL=getRelativeLocaleUrl(\"es\", \"about\");\n---\n\n\n<a href=\"/get-started/\">¬°Vamos!</a>\n<a href={getRelativeLocaleUrl('es', 'blog')}>Blog</a>\n<a href={aboutURL}>Acerca</a>\nroutingStrategy\nSection titled routingStrategy\n\nAstro‚Äôs built-in file-based routing automatically creates URL routes for you based on your file structure within src/pages/. When you configure i18n routing, the routingStrategy value now allows you to specify your file structure (and corresponding URL paths generated) in order to use helper functions to generate, use, and verify the routes in your project.\n\n'prefix-other-locales'\nSection titled &#39;prefix-other-locales&#39;\nastro.config.mjs\nimport { defineConfig } from \"astro/config\"\nexport default defineConfig({\n  experimental: {\n    i18n: {\n      defaultLocale: \"en\",\n      locales: [\"es\", \"en\", \"fr\"],\n      routingStrategy: \"prefix-other-locales\"\n    }\n  }\n})\n\nThis is the default value. Set this option when URLs in your default language will not have a /[locale]/ prefix and files in your default language exist at the root of src/pages/.\n\nsrc/pages/blog.astro will produce the route example.com/blog/\nsrc/pages/fr/blog.astro will produce the route example.com/fr/blog/\nIf there is no file at src/pages/es/blog.astro, then the route example.com/es/blog/ will 404 unless you specify a fallback strategy.\n'prefix-always'\nSection titled &#39;prefix-always&#39;\nastro.config.mjs\nimport { defineConfig } from \"astro/config\"\nexport default defineConfig({\n  experimental: {\n    i18n: {\n      defaultLocale: \"en\",\n      locales: [\"es\", \"en\", \"fr\"],\n      routingStrategy: \"prefix-always\"\n    }\n  }\n})\n\nSet this option when all routes will have their /locale/ prefix in their URL and when all page content files, including those for your defaultLocale, exist in a localized folder:\n\nDirectory\nsrc\nDirectory\npages\nindex.astro\nDirectory\nen\nindex.astro\nabout.astro\nDirectory\nes\nabout.astro\nindex.astro\nDirectory\npt-br\nabout.astro\nindex.astro\nURLs without a local prefix, (e.g. example.com/blog/) will return a 404 (not found) status code.\ndefaultLocale and locales\nSection titled defaultLocale and locales\n\nBoth a default language (defaultLocale) and a list of all supported languages (locales) must be specified in your i18n routing configuration.\n\nEach language must be a string (e.g. \"fr\", \"pt-br\"), but no particular language format or syntax is enforced while this feature is still experimental and under development. This may be subject to change in future versions.\n\nYour /[locale]/ folder names must match exactly the locales in the list, and your routing strategy must correspond to whether or not you have a localized folder for your default language. Every other supported language must have its own localized folder.\n\nDepending on your deploy host, you may discover transformations in URL paths, so check your deployed site to determine the best syntax for your project.\n\nBrowser language detection\nSection titled Browser language detection\n\nAstro‚Äôs i18n routing combined with one of Astro‚Äôs on-demand server rendering modes (output:'server' or output:'hybrid') allow you to access two properties for browser language detection: Astro.preferredLocale and Astro.preferredLocaleList.\n\nThese combine the browser‚Äôs Accept-Langauge header, and your locales to automatically respect your visitor‚Äôs preferred languages.\n\nAstro.preferredLocale: Astro can compute a preferred locale for your visitor if their browser‚Äôs preferred locale is included in your locales array. This value is undefined if no such match exists.\nAstro.preferredLocaleList: An array of all locales that are both requested by the browser and supported by your website. This produces a list of all compatible languages between your site and your visitor. The value is [] if none of the browser‚Äôs requested languages are found in your locales array. If the browser does not specify any preferred languages, then this value will be i18n.locales.\nAstro.currentLocale: The locale computed from the current URL, using the syntax specified in your locales configuration. If the URL does not contain a /[locale]/ prefix, then the value will default to i18n.defaultLocale.\nFallback\nSection titled Fallback\n\nAstro‚Äôs i18n routing allows you to configure a fallback routing strategy. When a page in one language doesn‚Äôt exist (e.g. a page that is not yet translated), instead of displaying a 404 page, you can redirect a user from one locale to another on a per-language basis. This is useful when you do not yet have a page for every route, but you want to still provide some content to your visitors.\n\nFor example, the configuration below sets es as the fallback locale for any missing fr routes. This means that a user visiting example.com/fr/my-page/ will be redirected to and shown the content for example.com/es/my-page/ instead of being taken to a 404 page when src/pages/fr/my-page.astro does not exist.\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\"\nexport default defineConfig({\n  experimental: {\n    i18n: {\n      defaultLocale: \"en\",\n      locales: [\"es\", \"en\", \"fr\"],\n      fallback: {\n        fr: \"es\"\n      }\n    }\n  }\n})\n\nAstro will ensure that a page is built in src/pages/fr for every page that exists in src/pages/es/. If the page does not already exist, then a page with a redirect to the corresponding es route will be created.\n\nVirtual module astro:i18n\nSection titled Virtual module astro:i18n\n\nThis module provides functions that can help you create URLs using your project‚Äôs configured locales.\n\nCreating routes for your project with the i18n router will depend on certain configuration values you have set that affect your page routes. When creating routes with these functions, be sure to take into account your individual settings for:\n\nbase\ntrailingSlash\nbuild.format\nsite\n\nAlso, note that the returned URLs created by these functions for your defaultLocale will reflect your i18n.routingStrategy configuration.\n\nURLs created when prefix-always is configured will include a /lang/ path in the URL. URLs created with prefix-other-locales will not include a language prefix.\n\ngetRelativeLocaleUrl()\nSection titled getRelativeLocaleUrl()\n\ngetRelativeLocaleUrl(locale: string, path: string, options?: GetLocaleOptions): string\n\nUse this function to retrieve a relative path for a locale. If the locale doesn‚Äôt exist, Astro throws an error.\n\n---\ngetRelativeLocaleUrl(\"fr\", \"\");\n// returns /fr\n\n\ngetRelativeLocaleUrl(\"fr\", \"getting-started\");\n// returns /fr/getting-started\n\n\ngetRelativeLocaleUrl(\"fr_CA\", \"getting-started\", {\n  prependWith: \"blog\"\n});\n// returns /blog/fr-ca/getting-started\n\n\ngetRelativeLocaleUrl(\"fr_CA\", \"getting-started\", {\n  prependWith: \"blog\",\n  normalizeLocale: false\n});\n// returns /blog/fr_CA/getting-started\n---\ngetAbsoluteLocaleUrl()\nSection titled getAbsoluteLocaleUrl()\n\ngetAbsoluteLocaleUrl(locale: string, path: string, options?: GetLocaleOptions): string\n\nUse this function to retrieve an absolute path for a locale when site has a value. If site isn‚Äôt configured, the function returns a relative URL. If the locale doesn‚Äôt exist, Astro throws an error.\n\nsrc/pages/index.astro\n---\n// If `site` is set to be `https://example.com`\n\n\ngetAbsoluteLocaleUrl(\"fr\", \"\");\n// returns https://example.com/fr\n\n\ngetAbsoluteLocaleUrl(\"fr\", \"getting-started\");\n// returns https://example.com/fr/getting-started\n\n\ngetAbsoluteLocaleUrl(\"fr_CA\", \"getting-started\", {\n  prependWith: \"blog\"\n});\n// returns https://example.com/blog/fr-ca/getting-started\n\n\ngetAbsoluteLocaleUrl(\"fr_CA\", \"getting-started\", {\n  prependWith: \"blog\",\n  normalizeLocale: false\n});\n// returns https://example.com/blog/fr_CA/getting-started\n---\ngetRelativeLocaleUrlList()\nSection titled getRelativeLocaleUrlList()\n\nUse this like getRelativeLocaleUrl to return a list of relative paths for all the locales.\n\ngetRelativeLocaleUrlList(locale: string, options?: GetLocaleOptions): string[]\n\ngetAbsoluteLocaleUrlList()\nSection titled getAbsoluteLocaleUrlList()\n\ngetAbsoluteLocaleUrlList(locale: string, options?: GetLocaleOptions): string[]\n\nUse this like getAbsoluteLocaleUrl to return a list of absolute paths for all the locales.\n\nBack\nData Fetching\nNext Page\nMiddleware"
  },
  {
    "title": "Data Fetching üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/data-fetching/",
    "html": "Data Fetching\n\n.astro files can fetch remote data to help you generate your pages.\n\nfetch() in Astro\nSection titled fetch() in Astro\n\nAll Astro components have access to the global fetch() function in their component script to make HTTP requests to APIs using the full URL (e.g. https://example.com/api or Astro.url + \"/api\").\n\nThis fetch call will be executed at build time, and the data will be available to the component template for generating dynamic HTML. If SSR mode is enabled, any fetch calls will be executed at runtime.\n\nüí° Take advantage of top-level await inside of your Astro component script.\n\nüí° Pass fetched data to both Astro and framework components, as props.\n\nsrc/components/User.astro\n---\nimport Contact from '../components/Contact.jsx';\nimport Location from '../components/Location.astro';\n\n\nconst response = await fetch('https://randomuser.me/api/');\nconst data = await response.json();\nconst randomUser = data.results[0];\n---\n<!-- Data fetched at build can be rendered in HTML -->\n<h1>User</h1>\n<h2>{randomUser.name.first} {randomUser.name.last}</h2>\n\n\n<!-- Data fetched at build can be passed to components as props -->\n<Contact client:load email={randomUser.email} />\n<Location city={randomUser.location.city} />\n\n NOTE\n\nRemember, all data in Astro components is fetched when a component is rendered.\n\nYour deployed Astro site will fetch data once, at build time. In dev, you will see data fetches on component refreshes. If you need to re-fetch data multiple times client-side, use a framework component or a client-side script in an Astro component.\n\nfetch() in Framework Components\nSection titled fetch() in Framework Components\n\nThe fetch() function is also globally available to any framework components:\n\nsrc/components/Movies.tsx\nimport type { FunctionalComponent } from 'preact';\n\n\nconst data = await fetch('https://example.com/movies.json').then((response) =>\n  response.json()\n);\n\n\n// Components that are build-time rendered also log to the CLI.\n// When rendered with a client:* directive, they also log to the browser console.\nconsole.log(data);\n\n\nconst Movies: FunctionalComponent = () => {\n// Output the result to the page\n  return <div>{JSON.stringify(data)}</div>;\n};\n\n\nexport default Movies;\nGraphQL queries\nSection titled GraphQL queries\n\nAstro can also use fetch() to query a GraphQL server with any valid GraphQL query.\n\nsrc/components/Film.astro\n---\nconst response = await fetch(\"https://swapi-graphql.netlify.app/.netlify/functions/index\",\n  {\n    method: 'POST',\n    headers: {'Content-Type':'application/json'},\n    body: JSON.stringify({\n      query: `\n        query getFilm ($id:ID!) {\n          film(id: $id) {\n            title\n            releaseDate\n          }\n        }\n      `,\n      variables: {\n        id: \"ZmlsbXM6MQ==\",\n      },\n    }),\n  });\n\n\nconst json = await response.json();\nconst { film } = json.data;\n---\n<h1>Fetching information about Star Wars: A New Hope</h1>\n<h2>Title: {film.title}</h2>\n<p>Year: {film.releaseDate}</p>\nFetch from a Headless CMS\nSection titled Fetch from a Headless CMS\n\nAstro components can fetch data from your favorite CMS and then render it as your page content. Using dynamic routes, components can even generate pages based on your CMS content.\n\nSee our CMS Guides for full details on integrating Astro with headless CMSes including Storyblok, Contentful, and WordPress.\n\nCommunity resources\nSection titled Community resources\nCreating a fullstack app with Astro + GraphQL\nBack\nEndpoints\nNext Page\nInternationalization"
  },
  {
    "title": "Endpoints üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/endpoints/",
    "html": "Endpoints\n\nAstro lets you create custom endpoints to serve any kind of data. You can use this to generate images, expose an RSS document, or use them as API Routes to build a full API for your site.\n\nIn statically-generated sites, your custom endpoints are called at build time to produce static files. If you opt in to SSR mode, custom endpoints turn into live server endpoints that are called on request. Static and SSR endpoints are defined similarly, but SSR endpoints support additional features.\n\nStatic File Endpoints\nSection titled Static File Endpoints\n\nTo create a custom endpoint, add a .js or .ts file to the /pages directory. The .js or .ts extension will be removed during the build process, so the name of the file should include the extension of the data you want to create. For example, src/pages/data.json.ts will build a /data.json endpoint.\n\nEndpoints export a GET function (optionally async) that receives a context object with properties similar to the Astro global. Here, it returns a Response object with a name and url, and Astro will call this at build time and use the contents of the body to generate the file.\n\nsrc/pages/builtwith.json.ts\n// Outputs: /builtwith.json\nexport async function GET({params, request}) {\n  return new Response(\n    JSON.stringify({\n      name: 'Astro',\n      url: 'https://astro.build/'\n    })\n  )\n}\n\nSince Astro v3.0, the returned Response object doesn‚Äôt have to include the encoding property anymore. For example, to produce a binary png image:\n\nsrc/pages/astro-logo.png.ts\nexport async function GET({ params, request }) {\n  const response = await fetch(\"https://docs.astro.build/assets/full-logo-light.png\");\n  return new Response(await response.arrayBuffer());\n}\n\nYou can also type your endpoint functions using the APIRoute type:\n\nimport type { APIRoute } from 'astro';\n\n\nexport const GET: APIRoute = async ({ params, request }) => {...}\nparams and Dynamic routing\nSection titled params and Dynamic routing\n\nEndpoints support the same dynamic routing features that pages do. Name your file with a bracketed parameter name and export a getStaticPaths() function. Then, you can access the parameter using the params property passed to the endpoint function:\n\nsrc/pages/api/[id].json.ts\nimport type { APIRoute } from 'astro';\n\n\nconst usernames = [\"Sarah\", \"Chris\", \"Yan\", \"Elian\"]\n\n\nexport const GET: APIRoute = ({ params, request }) => {\n  const id = params.id;\n  return new Response(\n    JSON.stringify({\n      name: usernames[id]\n    })\n  )\n}\n\n\nexport function getStaticPaths() {\n  return [\n    { params: { id: \"0\"} },\n    { params: { id: \"1\"} },\n    { params: { id: \"2\"} },\n    { params: { id: \"3\"} }\n  ]\n}\n\nThis will generate four JSON endpoints at build time: /api/0.json, /api/1.json, /api/2.json and /api/3.json. Dynamic routing with endpoints works the same as it does with pages, but because the endpoint is a function and not a component, props aren‚Äôt supported.\n\nrequest\nSection titled request\n\nAll endpoints receive a request property, but in static mode, you only have access to request.url. This returns the full URL of the current endpoint and works the same as Astro.request.url does for pages.\n\nsrc/pages/request-path.json.ts\nimport type { APIRoute } from 'astro';\n\n\nexport const GET: APIRoute = ({ params, request }) => {\n  return new Response(JSON.stringify({\n      path: new URL(request.url).pathname\n    })\n  )\n}\nServer Endpoints (API Routes)\nSection titled Server Endpoints (API Routes)\n\nEverything described in the static file endpoints section can also be used in SSR mode: files can export a GET function which receives a context object with properties similar to the Astro global.\n\nBut, unlike in static mode, when you configure server mode, the endpoints will be built when they are requested. This unlocks new features that are unavailable at build time, and allows you to build API routes that listen for requests and securely execute code on the server at runtime.\n\nRelated recipe:\nCall endpoints from the server\n\n NOTE\n\nBe sure to enable SSR before trying these examples.\n\nServer endpoints can access params without exporting getStaticPaths, and they can return a Response object, allowing you to set status codes and headers:\n\nsrc/pages/[id].json.js\nimport { getProduct } from '../db';\n\n\nexport async function GET({ params }) {\n  const id = params.id;\n  const product = await getProduct(id);\n\n\n  if (!product) {\n    return new Response(null, {\n      status: 404,\n      statusText: 'Not found'\n    });\n  }\n\n\n  return new Response(\n    JSON.stringify(product), {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    }\n  );\n}\n\nThis will respond to any request that matches the dynamic route. For example, if we navigate to /helmet.json, params.id will be set to helmet. If helmet exists in the mock product database, the endpoint will use create a Response object to respond with JSON and return a successful HTTP status code. If not, it will use a Response object to respond with a 404.\n\nIn SSR mode, certain providers require the Content-Type header to return an image. In this case, use a Response object to specify a headers property. For example, to produce a binary .png image:\n\nsrc/pages/astro-logo.png.ts\nexport async function GET({ params, request }) {\n  const response = await fetch(\"https://docs.astro.build/assets/full-logo-light.png\");\n  const buffer = Buffer.from(await response.arrayBuffer());\n  return new Response(buffer, {\n    headers: { \"Content-Type\": \"image/png\" },\n  });\n}\nHTTP methods\nSection titled HTTP methods\n\nIn addition to the GET function, you can export a function with the name of any HTTP method. When a request comes in, Astro will check the method and call the corresponding function.\n\nYou can also export an ALL function to match any method that doesn‚Äôt have a corresponding exported function. If there is a request with no matching method, it will redirect to your site‚Äôs 404 page.\n\nsrc/pages/methods.json.ts\nexport const GET: APIRoute = ({ params, request }) => {\n  return new Response(JSON.stringify({\n      message: \"This was a GET!\"\n    })\n  )\n}\n\n\nexport const POST: APIRoute = ({ request }) => {\n  return new Response(JSON.stringify({\n      message: \"This was a POST!\"\n    })\n  )\n}\n\n\nexport const DELETE: APIRoute = ({ request }) => {\n  return new Response(JSON.stringify({\n      message: \"This was a DELETE!\"\n    })\n  )\n}\n\n\nexport const ALL: APIRoute = ({ request }) => {\n  return new Response(JSON.stringify({\n      message: `This was a ${request.method}!`\n    })\n  )\n}\nRelated recipes\nVerify a Captcha\nBuild Forms With API Routes\nrequest\nSection titled request\n\nIn SSR mode, the request property returns a fully usable Request object that refers to the current request. This allows you to accept data and check headers:\n\nsrc/pages/test-post.json.ts\nexport const POST: APIRoute = async ({ request }) => {\n  if (request.headers.get(\"Content-Type\") === \"application/json\") {\n    const body = await request.json();\n    const name = body.name;\n    return new Response(JSON.stringify({\n      message: \"Your name was: \" + name\n    }), {\n      status: 200\n    })\n  }\n  return new Response(null, { status: 400 });\n}\nRedirects\nSection titled Redirects\n\nThe endpoint context exports a redirect() utility similar to Astro.redirect:\n\nsrc/pages/links/[id].js\nimport { getLinkUrl } from '../db';\n\n\nexport async function GET({ params, redirect }) {\n  const { id } = params;\n  const link = await getLinkUrl(id);\n\n\n  if (!link) {\n    return new Response(null, {\n      status: 404,\n      statusText: 'Not found'\n    });\n  }\n\n\n  return redirect(link, 307);\n}\nBack\nImports\nNext Page\nData Fetching"
  },
  {
    "title": "Imports üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/imports/",
    "html": "Imports\n\nAstro supports most static assets with zero configuration required. You can use the import statement anywhere in your project JavaScript (including your Astro frontmatter) and Astro will include a built, optimized copy of that static asset in your final build. @import is also supported inside of CSS & <style> tags.\n\nSupported File Types\nSection titled Supported File Types\n\nThe following file types are supported out-of-the-box by Astro:\n\nAstro Components (.astro)\nMarkdown (.md, .markdown, etc.)\nJavaScript (.js, .mjs)\nTypeScript (.ts, .tsx)\nNPM Packages\nJSON (.json)\nJSX (.jsx, .tsx)\nCSS (.css)\nCSS Modules (.module.css)\nImages & Assets (.svg, .jpg, .png, etc.)\n\nAdditionally, you can extend Astro to add support for different UI Frameworks like React, Svelte and Vue components. You can also install the Astro MDX integration and use .mdx files in your project.\n\nFiles in public/\nSection titled Files in public/\n\nYou can place any static asset in the public/ directory of your project, and Astro will copy it directly into your final build untouched. public/ files are not built or bundled by Astro, which means that any type of file is supported. You can reference a public/ file by a URL path directly in your HTML templates.\n\nImport statements\nSection titled Import statements\n\nAstro uses ESM, the same import and export syntax supported in the browser.\n\nJavaScript\nSection titled JavaScript\nimport { getUser } from './user.js';\n\nJavaScript can be imported using normal ESM import & export syntax.\n\nTypeScript\nSection titled TypeScript\nimport { getUser } from './user';\nimport type { UserType } from './user';\n\nAstro includes built-in support for TypeScript. You can import .ts and .tsx files directly in your Astro project, and even write TypeScript code directly inside your Astro component script and any hoisted script tags.\n\nAstro doesn‚Äôt perform any type checking itself. Type checking should be taken care of outside of Astro, either by your IDE or through a separate script. For type checking Astro files, the astro check command is provided.\n\n TYPESCRIPT AND FILE EXTENSIONS\n\nPer TypeScript‚Äôs module resolution rules, .ts and .tsx file extensions should not be used when importing TypeScript files. Instead, either use .js/.jsx file extensions or completely omit the file extension.\n\nimport { getUser } from './user.js'; // user.ts\nimport MyComponent from \"./MyComponent\"; // MyComponent.tsx\n\nüìö Read more about TypeScript support in Astro.\n\nJSX / TSX\nSection titled JSX / TSX\nimport { MyComponent } from './MyComponent.jsx';\n\nAstro includes built-in support for JSX (*.jsx and *.tsx) files in your project. JSX syntax is automatically transpiled to JavaScript.\n\nWhile Astro understands JSX syntax out-of-the-box, you will need to include a framework integration to properly render frameworks like React, Preact and Solid. Check out our Using Integrations guide to learn more.\n\n NOTE\n\nAstro does not support JSX in .js/.ts files. JSX will only be handled inside of files that end with the .jsx and .tsx file extensions.\n\nNPM Packages\nSection titled NPM Packages\n\nIf you‚Äôve installed an NPM package, you can import it in Astro.\n\n---\nimport { Icon } from 'astro-icon';\n---\n\nIf a package was published using a legacy format, Astro will try to convert the package to ESM so that import statements work. In some cases, you may need to adjust your vite config for it to work.\n\n CAUTION\n\nSome packages rely on a browser environment. Astro components runs on the server, so importing these packages in the frontmatter may lead to errors.\n\nJSON\nSection titled JSON\n// Load the JSON object via the default export\nimport json from './data.json';\n\nAstro supports importing JSON files directly into your application. Imported files return the full JSON object in the default import.\n\nCSS\nSection titled CSS\n// Load and inject 'style.css' onto the page\nimport './style.css';\n\nAstro supports importing CSS files directly into your application. Imported styles expose no exports, but importing one will automatically add those styles to the page. This works for all CSS files by default, and can support compile-to-CSS languages like Sass & Less via plugins.\n\nCSS Modules\nSection titled CSS Modules\n// 1. Converts './style.module.css' classnames to unique, scoped values.\n// 2. Returns an object mapping the original classnames to their final, scoped value.\nimport styles from './style.module.css';\n\n\n// This example uses JSX, but you can use CSS Modules with any framework.\nreturn <div className={styles.error}>Your Error Message</div>;\n\nAstro supports CSS Modules using the [name].module.css naming convention. Like any CSS file, importing one will automatically apply that CSS to the page. However, CSS Modules export a special default styles object that maps your original classnames to unique identifiers.\n\nCSS Modules help you enforce component scoping & isolation on the frontend with uniquely-generated class names for your stylesheets.\n\nOther Assets\nSection titled Other Assets\nimport imgReference from './image.png'; // imgReference === '/src/image.png'\nimport svgReference from './image.svg'; // svgReference === '/src/image.svg'\nimport txtReference from './words.txt'; // txtReference === '/src/words.txt'\n\n\n// This example uses JSX, but you can use import references with any framework.\n<img src={imgReference.src} alt=\"image description\" />;\n\nAll other assets not explicitly mentioned above can be imported via ESM import and will return a URL reference to the final built asset. This can be useful for referencing non-JS assets by URL, like creating an image element with a src attribute pointing to that image.\n\nIt can also be useful to place images in the public/ folder as explained on the project-structure page.\n\n NOTE\n\nAdding alt text to <img> tags is encouraged for accessibility! Don‚Äôt forget to add an alt=\"a helpful description\" attribute to your image elements. You can just leave the attribute empty if the image is purely decorative.\n\nAstro.glob()\nSection titled Astro.glob()\n\nAstro.glob() is a way to import many files at once.\n\nAstro.glob() only takes one parameter: a relative glob pattern matching the local files you‚Äôd like to import. It‚Äôs asynchronous, and returns an array of each matching file‚Äôs exports.\n\nsrc/components/my-component.astro\n---\n// imports all files that end with `.md` in `./src/pages/post/`\nconst posts = await Astro.glob('../pages/post/*.md');\n---\n<!-- Renders an <article> for the first 5 blog posts -->\n<div>\n{posts.slice(0, 4).map((post) => (\n  <article>\n    <h2>{post.frontmatter.title}</h2>\n    <p>{post.frontmatter.description}</p>\n    <a href={post.url}>Read more</a>\n  </article>\n))}\n</div>\n\nAstro components imported using Astro.glob are of type AstroInstance. You can render each component instance using its default property:\n\nsrc/pages/component-library.astro\n---\n// imports all files that end with `.astro` in `./src/components/`\nconst components = await Astro.glob('../components/*.astro');\n---\n<!-- Display all of our components -->\n{components.map((component) => (\n  <div>\n    <component.default size={24} />\n  </div>\n))}\nGlob Patterns\nSection titled Glob Patterns\n\nA glob pattern is a file path that supports special wildcard characters. This is used to reference multiple files in your project at once.\n\nFor example, the glob pattern ./pages/**/*.{md,mdx} starts within the pages subdirectory, looks through all of its subdirectories (/**), and matches any filename (/*) that ends in either .md or .mdx (.{md,mdx}).\n\nGlob Patterns in Astro\nSection titled Glob Patterns in Astro\n\nTo use with Astro.glob(), the glob pattern must be a string literal and cannot contain any variables. See the troubleshooting guide for a workaround.\n\nAdditionally, glob patterns must begin with one of the following:\n\n./ (to start in the current directory)\n../ (to start in the parent directory)\n/ (to start at the root of the project)\n\nRead more about the glob pattern syntax.\n\nAstro.glob() vs getCollection()\nSection titled Astro.glob() vs getCollection()\n\nContent collections provide a getCollection() API for loading multiple files instead of Astro.glob(). If your content files (e.g. Markdown, MDX, Markdoc) are located in collections within the src/content/ directory, use getCollection() to query a collection and return content entries.\n\nWASM\nSection titled WASM\n// Loads and initializes the requested WASM file\nconst wasm = await WebAssembly.instantiateStreaming(fetch('/example.wasm'));\n\nAstro supports loading WASM files directly into your application using the browser‚Äôs WebAssembly API.\n\nNode Builtins\nSection titled Node Builtins\n\nWe encourage Astro users to avoid Node.js builtins (fs, path, etc.) whenever possible. Astro is compatible with multiple runtimes using adapters. This includes Deno and Cloudflare Workers which do not support Node builtin modules such as fs.\n\nOur aim is to provide Astro alternatives to common Node.js builtins. However, no such alternatives exist today. So, if you really need to use these builtin modules we don‚Äôt want to stop you. Astro supports Node.js builtins using Node‚Äôs newer node: prefix. If you want to read a file, for example, you can do so like this:\n\nsrc/components/MyComponent.astro\n---\n// Example: import the \"fs/promises\" builtin from Node.js\nimport fs from 'node:fs/promises';\n\n\nconst url = new URL('../../package.json', import.meta.url);\nconst json = await fs.readFile(url, 'utf-8');\nconst data = JSON.parse(json);\n---\n\n\n<span>Version: {data.version}</span>\nExtending file type support\nSection titled Extending file type support\n\nWith Vite and compatible Rollup plugins, you can import file types which aren‚Äôt natively supported by Astro. Learn where to find the plugins you need in the Finding Plugins section of the Vite Documentation.\n\n PLUGIN CONFIGURATION\n\nRefer to your plugin‚Äôs documentation for configuration options, and how to correctly install it.\n\nRelated recipe:\nInstalling a Vite or Rollup plugin\nBack\nFonts\nNext Page\nEndpoints"
  },
  {
    "title": "Using custom fonts üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/fonts/",
    "html": "Using custom fonts\n\nThis guide will show you how to add web fonts to your project and use them in your components.\n\nUsing a local font file\nSection titled Using a local font file\n\nThis example will demonstrate adding a custom font using the font file DistantGalaxy.woff.\n\nAdd your font file to public/fonts/.\n\nAdd the following @font-face statement to your CSS. This could be in a global .css file you import, a <style is:global> block, or a <style> block in a specific layout or component where you want to use this font.\n\n/* Register your custom font family and tell the browser where to find it. */\n@font-face {\n  font-family: 'DistantGalaxy';\n  src: url('/fonts/DistantGalaxy.woff') format('woff');\n  font-weight: normal;\n  font-style: normal;\n  font-display: swap;\n}\n\nUse the font-family value from the @font-face statement to style elements in your component or layout. In this example, the <h1> heading will have the custom font applied, while the paragraph <p> will not.\n\nsrc/pages/example.astro\n---\n---\n\n\n<h1>In a galaxy far, far away...</h1>\n\n\n<p>Custom fonts make my headings much cooler!</p>\n\n\n<style>\nh1 {\n  font-family: 'DistantGalaxy', sans-serif;\n}\n</style>\nUsing Fontsource\nSection titled Using Fontsource\n\nThe Fontsource project simplifies using Google Fonts and other open-source fonts. It provides npm modules you can install for the fonts you want to use.\n\nFind the font you want to use in Fontsource‚Äôs catalog. This example will use Twinkle Star.\n\nInstall the package for your chosen font.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @fontsource/twinkle-star\n\n TIP\n\nYou‚Äôll find the correct package name in the ‚ÄúQuick Installation‚Äù section of each font page on Fontsource‚Äôs website. It will start with @fontsource/ followed by the name of the font.\n\nImport the font package in the component where you want to use the font. Usually, you will want to do this in a common layout component to make sure the font is available across your site.\n\nThe import will automatically add the necessary @font-face rules needed to set up the font.\n\nsrc/layouts/BaseLayout.astro\n---\nimport '@fontsource/twinkle-star';\n---\n\nUse the font‚Äôs name as shown in the body example on its Fontsource page as the font-family value. This will work anywhere you can write CSS in your Astro project.\n\nh1 {\n  font-family: \"Twinkle Star\", cursive;\n}\nRegister fonts in Tailwind\nSection titled Register fonts in Tailwind\n\nIf you are using the Tailwind integration, you can use either of the previous methods on this page to install your font, with some modification. You can either add an @font-face statement for a local font or use Fontsource‚Äôs import strategy to install your font.\n\nTo register your font in Tailwind:\n\nFollow either of the guides above, but skip the final step of adding font-family to your CSS.\n\nAdd the typeface name to tailwind.config.cjs.\n\nThis example adds InterVariable and Inter to the sans-serif font stack, with default fallback fonts from Tailwind CSS.\n\ntailwind.config.cjs\nconst defaultTheme = require(\"tailwindcss/defaultTheme\");\n\n\nmodule.exports = {\n  // ...\n  theme: {\n    extend: {\n      fontFamily: {\n        sans: [\"InterVariable\", \"Inter\", ...defaultTheme.fontFamily.sans],\n      },\n    },\n  },\n  // ...\n};\n\nNow, all sans-serif text (the default with Tailwind) in your project will use your chosen font and the font-sans class will also apply the Inter font.\n\nSee Tailwind‚Äôs docs on adding custom font families for more information.\n\nMore resources\nSection titled More resources\nLearn how web fonts work in MDN‚Äôs web fonts guide.\nGenerate CSS for your font with Font Squirrel‚Äôs Webfont Generator.\nBack\nImages\nNext Page\nImports"
  },
  {
    "title": "Images üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/images/",
    "html": "Images\n\nAstro provides several ways for you to use images on your site, whether they are stored locally inside your project, linked to from an external URL, or managed in a CMS or CDN!\n\nWhere to store images\nSection titled Where to store images\nsrc/ vs public/\nSection titled src/ vs public/\n\nWe recommend that local images are kept in src/ when possible so that Astro can transform, optimize and bundle them. Files in the /public directory are always served or copied into the build folder as-is, with no processing.\n\nYour local images stored in src/ can be used by all files in your project: .astro, .md, .mdx, .mdoc, and other UI frameworks. Images can be stored in any folder, including alongside your content.\n\nStore your images in the public/ folder if you want to avoid any processing or to have a direct public link to them.\n\nRemote images\nSection titled Remote images\n\nYou can also choose to store your images remotely, in a content management system (CMS) or digital asset management (DAM) platform.\n\nFor extra protection when dealing with external sources, remote images will only be processed from authorized image sources specified in your configuration. However, any remote images can be displayed.\n\nAstro can fetch your data remotely using APIs or display images from their full URL path. See our CMS guides for examples of integrating common services.\n\nImages in .astro files\nSection titled Images in .astro files\n\nIn .astro files, local images must be imported into the file in order to be used. Remote and public/ images do not require importing.\n\nImport and use Astro‚Äôs built-in <Image /> component for optimized images using astro:assets. Alternatively, Astro syntax supports writing an HTML <img> tag directly, which skips image processing.\n\nsrc/pages/blog/MyImages.astro\n---\nimport { Image } from 'astro:assets';\nimport localBirdImage from '../../images/subfolder/localBirdImage.png';\n---\n<Image src={localBirdImage} alt=\"A bird sitting on a nest of eggs.\"/>\n<Image src=\"/images/bird-in-public-folder.jpg\" alt=\"A bird.\" width=\"50\" height=\"50\"/>\n<Image src=\"https://example.com/remote-bird.jpg\" alt=\"A bird.\" width=\"50\" height=\"50\"/>\n\n\n<img src={localBirdImage.src} alt=\"A bird sitting on a nest of eggs.\">\n<img src=\"/images/bird-in-public-folder.jpg\" alt=\"A bird.\">\n<img src=\"https://example.com/remote-bird.jpg\" alt=\"A bird.\">\n\nTo dynamically import images from the src/ folder, see the following recipe:\n\nRelated recipe:\nDynamically Import Images\n<Image /> (astro:assets)\nSection titled &lt;Image /&gt; (astro:assets)\n\nUse the built-in <Image /> Astro component to display optimized versions of your local images and configured remote images.\n\nImages in the public/ folder, as well as remote images not specifically configured in your project, can also be used with the Image component, but will not be processed.\n\n<Image /> can transform a local or authorized remote image‚Äôs dimensions, file type, and quality for control over your displayed image. The resulting <img> tag includes alt, loading, and decoding attributes and infers image dimensions to avoid Cumulative Layout Shift (CLS).\n\n WHAT IS CUMULATIVE LAYOUT SHIFT?\n\nCumulative Layout Shift (CLS) is a Core Web Vital metric for measuring how much content shifted on your page during loading. The <Image /> component optimizes for CLS by automatically setting the correct width and height for your local images.\n\nsrc/components/MyComponent.astro\n---\n// import the Image component and the image\nimport { Image } from 'astro:assets';\nimport myImage from \"../assets/my_image.png\"; // Image is 1600x900\n---\n\n\n<!-- `alt` is mandatory on the Image component -->\n<Image src={myImage} alt=\"A description of my image.\" />\n<!-- Output -->\n<!-- Image is optimized, proper attributes are enforced -->\n<img\n  src=\"/_astro/my_image.hash.webp\"\n  width=\"1600\"\n  height=\"900\"\n  decoding=\"async\"\n  loading=\"lazy\"\n  alt=\"A description of my image.\"\n/>\nProperties\nSection titled Properties\nsrc (required)\nSection titled src (required)\n\nThe format of the src value of your image file depends on where your image file is located:\n\nLocal images in src/ - you must also import the image using a relative file path or configure and use an import alias. Then use the import name as the src value:\n\nsrc/pages/index.astro\n---\nimport { Image } from 'astro:assets';\nimport myImportedImage from `../assets/my-local-image.png`\n---\n<Image src={myImportedImage} alt=\"descriptive text\" />\n\nImages in the public/ folder - use the image‚Äôs file path relative to the public folder:\n\nsrc/pages/index.astro\n---\nimport { Image } from 'astro:assets';\n---\n<Image\n  src=\"/images/my-public-image.png\"\n  alt=\"descriptive text\"\n  width=\"200\"\n  height=\"150\"\n/>\n\nRemote images - use the image‚Äôs full URL as the property value:\n\nsrc/pages/index.astro\n---\nimport { Image } from 'astro:assets';\n---\n<Image\n  src=\"https://example.com/remote-image.jpg\"\n  alt=\"descriptive text\"\n  width=\"200\"\n  height=\"150\" />\nalt (required)\nSection titled alt (required)\n\nUse the required alt attribute to provide a string of descriptive alt text for images.\n\nIf an image is merely decorative (i.e. doesn‚Äôt contribute to the understanding of the page), set alt=\"\" so that screen readers and other assistive technologies know to ignore the image.\n\nwidth and height (required for public/ and remote images)\nSection titled width and height (required for public/ and remote images)\n\nThese properties define the dimensions to use for the image.\n\nWhen using local images in their original aspect ratio, the width and height can be automatically inferred from the source file and are optional.\n\nHowever, both of these properties are required for remote images and images stored in your public/ folder as Astro is unable to analyze these files.\n\ndensities\nSection titled densities\nAdded in: astro@3.3.0 EXPERIMENTAL\n\nA list of pixel densities to generate for the image.\n\nIf provided, this value will be used to generate a srcset attribute on the <img> tag. Do not provide a value for widths when using this value.\n\nDensities that are equal to widths larger than the original image will be ignored to avoid upscaling the image.\n\nsrc/components/MyComponent.astro\n---\nimport { Image } from 'astro:assets';\nimport myImage from \"../assets/my_image.png\";\n---\n<Image src={myImage} width={myImage.width / 2} densities={[1.5, 2]} alt=\"A description of my image.\" />\n<img\n  src=\"/_astro/my_image.hash.webp\"\n  srcset=\"\n    /_astro/my_image.hash.webp 1.5x\n    /_astro/my_image.hash.webp 2x\n  \"\n  alt=\"A description of my image.\"\n  width=\"800\"\n  height=\"450\"\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\nwidths\nSection titled widths\nAdded in: astro@3.3.0 EXPERIMENTAL\n\nA list of widths to generate for the image.\n\nIf provided, this value will be used to generate a srcset attribute on the <img> tag. A sizes property must also be provided.\n\nDo not provide a value for densities when using this value. Only one of these two values can be used to generate a srcset.\n\nWidths that are larger than the original image will be ignored to avoid upscaling the image.\n\n---\nimport { Image } from 'astro:assets';\nimport myImage from \"../assets/my_image.png\"; // Image is 1600x900\n---\n<Image\n  src={myImage}\n  widths={[240, 540, 720, myImage.width]}\n  sizes={`(max-width: 360px) 240px, (max-width: 720px) 540px, (max-width: 1600px) 720px, ${myImage.width}px`}\n  alt=\"A description of my image.\"\n/>\n<img\n  src=\"/_astro/my_image.hash.webp\"\n  srcset=\"\n    /_astro/my_image.hash.webp 240w,\n    /_astro/my_image.hash.webp 540w,\n    /_astro/my_image.hash.webp 720w,\n    /_astro/my_image.hash.webp 1600w\n  \"\n  sizes=\"\n    (max-width: 360px) 240px,\n    (max-width: 720px) 540px,\n    (max-width: 1600px) 720px,\n    1600px\n  \"\n  alt=\"A description of my image.\"\n  width=\"1600\"\n  height=\"900\"\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\nformat\nSection titled format\n\nYou can optionally state the image file type output to be used.\n\nBy default, the <Image /> component will produce a .webp file.\n\nquality\nSection titled quality\n\nquality is an optional property that can either be:\n\na preset (low, mid, high, max) that is automatically normalized between formats.\na number from 0 to 100 (interpreted differently between formats).\nAdditional properties\nSection titled Additional properties\n\nIn addition to the properties above, the <Image /> component accepts all properties accepted by the HTML <img> tag.\n\nFor example, you can provide a class to the final <img> element.\n\nsrc/pages/index.astro\n---\nimport { Image } from 'astro:assets';\nimport myImage from \"../assets/my_image.png\";\n---\n\n\n<!-- `alt` is mandatory on the Image component -->\n<Image src={myImage} alt=\"\" class=\"my-class\" />\n<!-- Output -->\n<img\n  src=\"/_astro/my_image.hash.webp\"\n  width=\"1600\"\n  height=\"900\"\n  decoding=\"async\"\n  loading=\"lazy\"\n  class=\"my-class\"\n  alt=\"\"\n/>\nSetting Default Values\nSection titled Setting Default Values\n\nCurrently, there is no way to specify default values for all <Image /> components. Required attributes should be set on each individual component.\n\nAs an alternative, you can wrap these components in another Astro component for reuse. For example, you could create a component for your blog post images:\n\nsrc/components/BlogPostImage.astro\n---\nimport { Image } from 'astro:assets';\n\n\nconst {src, ...attrs} = Astro.props;\n---\n<Image src={src} {...attrs} />\n\n\n<style>\n  img :global(img), svg {\n    margin-block: 2.5rem;\n    border-radius: 0.75rem;\n  }\n</style>\n<Picture />\nSection titled &lt;Picture /&gt;\nAdded in: astro@3.3.0\n\nUse the built-in <Picture /> Astro component to display a responsive image with multiple formats and/or sizes.\n\nsrc/pages/index.astro\n---\nimport { Picture } from 'astro:assets';\nimport myImage from \"../assets/my_image.png\"; // Image is 1600x900\n---\n\n\n<!-- `alt` is mandatory on the Picture component -->\n<Picture src={myImage} formats={['avif', 'webp']} alt=\"A description of my image.\" />\n<!-- Output -->\n<picture>\n  <source srcset=\"/_astro/my_image.hash.avif\" type=\"image/avif\" />\n  <source srcset=\"/_astro/my_image.hash.webp\" type=\"image/webp\" />\n  <img\n    src=\"/_astro/my_image.hash.png\"\n    width=\"1600\"\n    height=\"900\"\n    decoding=\"async\"\n    loading=\"lazy\"\n    alt=\"A description of my image.\"\n  />\n</picture>\nProperties\nSection titled Properties\n\n<Picture /> accepts all the properties of the <Image /> component, plus the following:\n\nformats\nSection titled formats\n\nAn array of image formats to use for the <source> tags. Entries will be added as <source> elements in the order they are listed, and this order determines which format is displayed. For the best performance, list the most modern format first (e.g. webp or avif). By default, this is set to ['webp'].\n\nfallbackFormat\nSection titled fallbackFormat\n\nFormat to use as a fallback value for the <img> tag.\n\nDefaults to .png for static images, .gif for animated images, and .svg for SVG files.\n\npictureAttributes\nSection titled pictureAttributes\n\nAn object of attributes to be added to the <picture> tag.\n\nUse this property to apply attributes to the outer <picture> element itself. Attributes applied to the <Picture /> component directly will apply to the inner <img> element, except for those used for image transformation.\n\nsrc/components/MyComponent.astro\n---\nimport { Picture } from \"astro:assets\";\nimport myImage from \"../my_image.png\"; // Image is 1600x900\n---\n\n\n<Picture src={myImage} alt=\"A description of my image.\" pictureAttributes={{style: \"background-color: red;\"}} />\n<picture style=\"background-color: red;\">\n  <source srcset=\"/_astro/my_image.hash.webp\" type=\"image/webp\" />\n  <img\n    src=\"/_astro/my_image.hash.png\"\n    alt=\"A description of my image.\"\n    width=\"1600\"\n    height=\"900\"\n    loading=\"lazy\"\n    decoding=\"async\"\n  />\n</picture>\n<img>\nSection titled &lt;img&gt;\n\nThe Astro template syntax also supports writing an <img> tag directly, with full control over its final output. These images will not be processed and optimized.\n\nIt accepts all HTML <img> tag properties, and the only required property is src.\n\nLocal images in src/\nSection titled Local images in src/\n\nLocal images must be imported from the relative path from the existing .astro file, or configure and use an import alias. Then, you can access the image‚Äôs src and other properties to use in the <img> tag.\n\nFor example, use the image‚Äôs own height and width properties to avoid CLS and improve Core Web Vitals.\n\nsrc/pages/posts/post-1.astro\n---\n// import local images\nimport myDog from `../../images/pets/local-dog.jpg`\n---\n// access the image properties\n<img src={myDog.src} width={myDog.width} height={myDog.height} alt=\"A barking dog.\" />\n\nImported image assets match the following signature:\n\ninterface ImageMetadata {\n  src: string;\n  width: number;\n  height: number;\n  format: string;\n}\nImages in public/\nSection titled Images in public/\n\nFor images located within public/ use the image‚Äôs file path relative to the public folder as the src value:\n\n<img src=\"/images/public-cat.jpg\" alt=\"A sleeping cat.\">\nRemote images\nSection titled Remote images\n\nFor remote images, use the image‚Äôs full URL as the src value:\n\n<img src=\"https://example.com/remote-cat.jpg\" alt=\"A sleeping cat.\">\nChoosing <Image /> vs <img>\nSection titled Choosing &lt;Image /&gt; vs &lt;img&gt;\n\nThe <Image /> component optimizes your image and infers width and height (of local images) based on the original aspect ratio to avoid CLS.\n\nUse the HTML <img> element when you cannot use the <Image /> component, for example:\n\nfor unsupported image formats\nwhen you do not want your image optimized by Astro\nto access and change the src attribute dynamically client-side\nAuthorizing remote images\nSection titled Authorizing remote images\n\nYou can configure lists of authorized image source URL domains and patterns for image optimization using image.domains and image.remotePatterns. This configuration is an extra layer of safety to protect your site when showing images from an external source.\n\nRemote images from other sources will not be optimized, but using the <Image /> component for these images will prevent Cumulative Layout Shift (CLS).\n\nFor example, the following configuration will only allow remote images from astro.build to be optimized:\n\nastro.config.mjs\nexport default defineConfig({\n  image: {\n    domains: [\"astro.build\"],\n  }\n});\n\nThe following configuration will only allow remote images from HTTPS hosts:\n\nastro.config.mjs\nexport default defineConfig({\n  image: {\n    remotePatterns: [{ protocol: \"https\" }],\n  }\n});\nUsing Images from a CMS or CDN\nSection titled Using Images from a CMS or CDN\n\nImage CDNs work with all Astro image options. Use an image‚Äôs full URL as the src attribute in the <Image /> component, an <img> tag, or in Markdown notation. For image optimization with remote images, also configure your authorized domains or URL patterns.\n\nAlternatively, if the CDN provides a Node.js SDK, you can use that in your project. For example, Cloudinary‚Äôs SDK can generate an <img> tag with the appropriate src for you.\n\nImages in Markdown files\nSection titled Images in Markdown files\n\nUse standard Markdown ![alt](src) syntax in your .md files. This syntax works with Astro‚Äôs Image Service API to optimize your local images and authorized remote images.\n\nsrc/pages/post-1.md\n# My Markdown Page\n\n\n<!-- Local image stored in src/assets/ -->\n<!-- Use a relative file path or import alias -->\n![A starry night sky.](../assets/stars.png)\n\n\n<!-- Image stored in public/images/ -->\n<!-- Use the file path relative to public/ -->\n![A starry night sky.](/images/stars.png)\n\n\n<!-- Remote image on another server -->\n<!-- Use the full URL of the image -->\n![Astro](https://example.com/images/remote-image.png)\n\nThe <img> tag is not supported for local images, and the <Image /> component is unavailable in .md files.\n\nIf you require more control over your image attributes, we recommend using the .mdx file format, which allows you to include Astro‚Äôs <Image /> component or a JSX <img /> tag in addition to the Markdown syntax. Use the MDX integration to add support for MDX to Astro.\n\nImages in MDX files\nSection titled Images in MDX files\n\nYou can use Astro‚Äôs <Image /> component and JSX <img /> tags in your .mdx files by importing both the component and your image. Use them just as they are used in .astro files.\n\nAdditionally, there is support for standard Markdown ![alt](src) syntax with no import required.\n\nsrc/pages/post-1.mdx\n---\ntitle: My Page title\n---\nimport { Image } from 'astro:assets';\nimport rocket from '../assets/rocket.png';\n\n\n# My MDX Page\n\n\n// Local image stored in src/assets/\n<Image src={rocket} alt=\"A rocketship in space.\"/>\n<img src={rocket.src} alt=\"A rocketship in space.\" />\n![A rocketship in space](../assets/rocket.png)\n\n\n// Image stored in public/images/\n<Image src=\"/images/stars.png\" alt=\"A starry night sky.\" />\n<img src=\"/images/stars.png\" alt=\"A starry night sky.\" />\n![A starry night sky.](/images/stars.png)\n\n\n// Remote image on another server\n<Image src=\"https://example.com/images/remote-image.png\" />\n<img src=\"https://example.com/images/remote-image.png\" />\n![Astro](https://example.com/images/remote-image.png)\nImages in Content Collections\nSection titled Images in Content Collections\n\nYou can declare an associated image for a content collections entry, such as a blog post‚Äôs cover image, in your frontmatter using its path relative to the current folder:\n\nsrc/content/blog/my-post.md\n---\ntitle: \"My first blog post\"\ncover: \"./firstpostcover.jpeg\" # will resolve to \"src/content/blog/firstblogcover.jpeg\"\ncoverAlt: \"A photograph of a sunset behind a mountain range.\"\n---\n\n\nThis is a blog post\n\nThe image helper for the content collections schema lets you validate the image metadata using Zod.\n\nsrc/content/config.ts\nimport { defineCollection, z } from \"astro:content\";\n\n\nconst blogCollection = defineCollection({\n  schema: ({ image }) => z.object({\n    title: z.string(),\n    cover: image().refine((img) => img.width >= 1080, {\n      message: \"Cover image must be at least 1080 pixels wide!\",\n    }),\n    coverAlt: z.string(),\n  }),\n});\n\n\nexport const collections = {\n  blog: blogCollection,\n};\n\nThe image will be imported and transformed into metadata, allowing you to pass it as a src to <Image/>, <img>, or getImage().\n\nThe example below shows a blog index page that renders the cover photo and title of each blog post from the schema above:\n\nsrc/pages/blog.astro\n---\nimport { Image } from \"astro:assets\";\nimport { getCollection } from \"astro:content\";\nconst allBlogPosts = await getCollection(\"blog\");\n---\n\n\n{\n  allBlogPosts.map((post) => (\n    <div>\n      <Image src={post.data.cover} alt={post.data.coverAlt} />\n      <h2>\n        <a href={\"/blog/\" + post.slug}>{post.data.title}</a>\n      </h2>\n    </div>\n  ))\n}\nImages in UI framework components\nSection titled Images in UI framework components\n\nWhen adding images in a UI framework component, use the framework‚Äôs own image syntax to render an image (e.g. <img /> in JSX, <img> in Svelte).\n\nLocal images must first be imported to access their image properties such as src.\n\nsrc/components/ReactImage.jsx\nimport stars from \"../assets/stars.png\"\n\n\nexport default function ReactImage() {\n  return (\n    <img src={stars.src} alt=\"A starry night sky.\" />\n  )\n}\nsrc/components/SvelteImage.svelte\n<script>\n  import stars from '../assets/stars.png'\n</script>\n\n\n<img src={stars.src} alt=\"A starry night sky.\" />\nPassing the Image component\nSection titled Passing the Image component\n\nThe <Image /> component, like any other Astro component, is unavailable to UI framework components.\n\nBut, you can pass the static content generated by <Image /> to a framework component inside a .astro file as children or using a named <slot/>:\n\nImageWrapper.astro\n---\nimport ReactComponent from './ReactComponent.jsx';\nimport { Image } from \"astro:assets\"\nimport stars from \"~/stars/docline.png\";\n---\n\n\n<ReactComponent>\n  <Image src={stars} alt=\"A starry night sky.\" />\n</ReactComponent>\nGenerating images with getImage()\nSection titled Generating images with getImage()\n\n CAUTION\n\ngetImage() relies on server-only APIs and breaks the build when used on the client.\n\nThe getImage() function is intended for generating images destined to be used somewhere else than directly in HTML, for example in an API Route. It also allows you to create your own custom <Image /> component.\n\nRelated recipe:\nBuild a custom image component\n\ngetImage() takes an options object with the same properties as the Image component (except alt).\n\n---\nimport { getImage } from \"astro:assets\";\nimport myBackground from \"../background.png\"\n\n\nconst optimizedBackground = await getImage({src: myBackground, format: 'avif'})\n---\n\n\n<div style={`background-image: url(${optimizedBackground.src});`}></div>\n\nIt returns an object with the following properties:\n\n{\n  rawOptions: {...}, // Original parameters passed\n  options: {...}, // Validated parameters passed\n  src: \"...\", // Path to the generated image\n  srcSet: {\n    values: [...], // Generated values for srcset, every entry has a url and a size descriptor\n    attribute: \"\", // Generated srcset attribute from the values\n  }\n  attributes: {...} // Additional HTML attributes needed to render the image (width, height, style, etc..)\n}\nAlt Text\nSection titled Alt Text\n\nNot all users can see images in the same way, so accessibility is an especially important concern when using images. Use the alt attribute to provide descriptive alt text for images.\n\nThis attribute is required for the <Image /> component. <Image /> will throw an error if no alt text is provided.\n\nIf the image is merely decorative (i.e. doesn‚Äôt contribute to the understanding of the page), set alt=\"\" so that screen readers know to ignore the image.\n\nDefault image service\nSection titled Default image service\n\nSharp is the default image service used for astro:assets.\n\n NOTE\n\nWhen using a strict package manager like pnpm, you may need to manually install Sharp into your project even though it is an Astro dependency:\n\nTerminal window\npnpm install sharp\nConfigure Squoosh\nSection titled Configure Squoosh\n\nIf you would prefer to use Squoosh to transform your images, update your config with the following:\n\nastro.config.mjs\nimport { defineConfig, squooshImageService } from 'astro/config';\n\n\nexport default defineConfig({\n  image: {\n    service: squooshImageService(),\n  },\n});\nConfigure no-op passthrough service\nSection titled Configure no-op passthrough service\n\nIf your adapter for server or hybrid mode does not support Astro‚Äôs built-in Squoosh and Sharp image optimization (e.g. Deno, Cloudflare), you can configure a no-op image service to allow you to use the <Image /> and <Picture /> components. Note that Astro does not perform any image transformation and processing in these environments. However, you can still enjoy the other benefits of using astro:assets, including no Cumulative Layout Shift (CLS), the enforced alt attribute, and a consistent authoring experience.\n\nConfigure the passthroughImageService() to avoid both Squoosh and Sharp image processing:\n\nastro.config.mjs\nimport { defineConfig, passthroughImageService } from 'astro/config';\n\n\nexport default defineConfig({\n  image: {\n    service: passthroughImageService()\n  }\n});\nCommunity Integrations\nSection titled Community Integrations\n\nThere are several third-party community image integrations for optimizing and working with images in your Astro project.\n\nUpgrade to v3.0 from v2.x\nSection titled Upgrade to v3.0 from v2.x\n\nastro:assets is no longer behind an experimental flag in Astro v3.0.\n\n<Image /> is now a built-in component and the previous @astrojs/image integration has been removed.\n\nThese and other accompanying changes to using images in Astro may cause some breaking changes when you upgrade your Astro project from an earlier version.\n\nPlease follow the instructions below as appropriate to upgrade an Astro v2.x project to v3.0.\n\nUpgrade from experimental.assets\nSection titled Upgrade from experimental.assets\n\nIf you had previously enabled the experimental flag for astro:assets, you will need to update your project for Astro v3.0 which now includes assets features by default.\n\nRemove experimental.assets flag\nSection titled Remove experimental.assets flag\n\nRemove the experimental flag:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  experimental: {\n    assets: true\n  }\n});\n\nIf necessary, also update your src/env.d.ts file to replace the astro/client-image reference with astro/client:\n\nsrc/env.d.ts\n/// <reference types=\"astro/client-image\" />\n/// <reference types=\"astro/client\" />\nRemove the ~/assets import alias\nSection titled Remove the ~/assets import alias\n\nThis import alias is no longer included by default with astro:assets. If you were using this alias with experimental assets, you must convert them to relative file paths, or create your own import aliases.\n\nsrc/pages/posts/post-1.astro\n---\nimport rocket from '~/assets/rocket.png'\nimport rocket from '../../assets/rocket.png';\n---\nAdd simple asset support for Cloudflare, Deno, Vercel Edge and Netlify Edge\nSection titled Add simple asset support for Cloudflare, Deno, Vercel Edge and Netlify Edge\n\nAstro v3.0 allows astro:assets to work without errors in Cloudflare, Deno, Vercel Edge and Netlify Edge, which do not support Astro‚Äôs built-in Squoosh and Sharp image optimization. Note that Astro does not perform any image transformation and processing in these environments. However, you can still enjoy the other benefits of using astro:assets, including no Cumulative Layout Shift (CLS), the enforced alt attribute, and a consistent authoring experience.\n\nIf you previously avoided using astro:assets because of these constraints, you can now use them without issues. You can configure the no-op image service to explicitly opt-in to this behavior:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  image: {\n    service: {\n      entrypoint: 'astro/assets/services/noop'\n    }\n  }\n});\nDecide where to store your images\nSection titled Decide where to store your images\n\nSee the Images guide to help you decide where to store your images. You may wish to take advantage of new options for storing your images with the added flexibility astro:assets brings. For example, relative images from your project src/ can now be referenced in Markdown, MDX, and Markdoc using standard Markdown ![alt](src) syntax.\n\nUpdate existing <img> tags\nSection titled Update existing &lt;img&gt; tags\n\nPreviously, importing an image would return a simple string with the path of the image. Now, imported image assets match the following signature:\n\ninterface ImageMetadata {\n  src: string;\n  width: number;\n  height: number;\n  format: string;\n}\n\nYou must update the src attribute of any existing <img> tags (including any images in UI framework components) and you may also update other attributes that are now available to you from the imported image.\n\nsrc/components/MyComponent.astro\n---\nimport rocket from '../images/rocket.svg';\n---\n<img src={rocket} width=\"250\" height=\"250\" alt=\"A rocketship in space.\" />\n\n\n<img src={rocket.src} width={rocket.width} height={rocket.height} alt=\"A rocketship in space.\" />\nUpdate your Markdown, MDX, and Markdoc files\nSection titled Update your Markdown, MDX, and Markdoc files\n\nRelative images from your project src/ can now be referenced in Markdown, MDX, and Markdoc using standard Markdown ![alt](src) syntax.\n\nThis allows you to move your images from the public/ directory to your project src/ where they will now be processed and optimized. Your existing images in public/ and remote images are still valid but are not optimized by Astro‚Äôs build process.\n\nsrc/pages/posts/post-1.md\n# My Markdown Page\n\n\n<!-- Local images now possible! -->\n![A starry night sky.](../../images/stars.png)\n\n\n<!-- Keep your images next to your content! -->\n![A starry night sky.](./stars.png)\n\nIf you require more control over your image attributes, we recommend using the .mdx file format, which allows you to include Astro‚Äôs <Image /> component or a JSX <img /> tag in addition to the Markdown syntax. Use the MDX integration to add support for MDX to Astro.\n\nRemove @astrojs/image\nSection titled Remove @astrojs/image\n\nIf you were using the image integration in Astro v2.x, complete the following steps:\n\nRemove the @astrojs/image integration.\n\nYou must remove the integration by uninstalling and then removing it from your astro.config.mjs file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport image from '@astrojs/image';\n\n\nexport default defineConfig({\n  integrations: [\n    image(),\n  ]\n})\n\nUpdate types (if required).\n\nIf you had special types configured for @astrojs/image in src/env.d.ts, you may need to change them back to the default Astro types if your upgrade to v3 did not complete this step for you.\n\nsrc/env.d.ts\n /// <reference types=\"@astrojs/image/client\" />\n /// <reference types=\"astro/client\" />\n\nSimilarly, update tsconfig.json if necessary:\n\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"types\": [\"@astrojs/image/client\"]\n    \"types\": [\"astro/client\"]\n  }\n}\n\nMigrate any existing <Image /> components.\n\nChange all import statements from @astrojs/image/components to astro:assets in order to use the new built-in <Image /> component.\n\nRemove any component attributes that are not currently supported image asset properties.\n\nFor example, aspectRatio is no longer supported, as it is now automatically inferred from the width and height attributes.\n\nsrc/components/MyComponent.astro\n---\nimport { Image } from '@astrojs/image/components';\nimport { Image } from 'astro:assets'\nimport localImage from \"../assets/logo.png\";\nconst localAlt = \"The Astro Logo\";\n---\n\n\n<Image\n  src={localImage}\n  width={300}\n  aspectRatio=\"16:9\"\n  alt={localAlt}\n/>\n\nChoose a default image service.\n\nSharp is now the default image service used for astro:assets. If you would like to use Sharp, no configuration is required.\n\nIf you would prefer to use Squoosh to transform your images, update your config with the following image.service option:\n\nastro.config.mjs\nimport { defineConfig, squooshImageService } from 'astro/config';\n\n\nexport default defineConfig({\n  image: {\n    service: squooshImageService(),\n  },\n});\nUpdate Content Collections schemas\nSection titled Update Content Collections schemas\n\nYou can now declare an associated image for a content collections entry, such as a blog post‚Äôs cover image, in your frontmatter using its path relative to the current folder.\n\nThe new image helper for content collections lets you validate the image metadata using Zod. Learn more about how to use images in content collections\n\nNavigating Image Imports in Astro v3.0\nSection titled Navigating Image Imports in Astro v3.0\n\nIn Astro v3.0, if you have to preserve the old import behavior for images and require a string representation of the image‚Äôs URL, append ?url to the end of your image path when importing it. For example:\n\nsrc/pages/blog/MyImages.astro\n---\nimport Sprite from '../assets/logo.svg?url';\n---\n\n\n  <svg>\n    <use xlink:href={Sprite + '#cart'} />\n  </svg>\n\nThis approach ensures you obtain the URL string. Keep in mind that during development, Astro uses a src/ path, but upon building, it generates hashed paths like /_astro/cat.a6737dd3.png.\n\nIf you prefer to work directly with the image object itself, you can access the .src property. This approach is best for tasks like managing image dimensions for Core Web Vitals metrics and preventing CLS.\n\nIf you are transitioning into the new import behavior, combining ?url and .src methods might be the right method for seamless image handling.\n\nBack\nCSS & Styling\nNext Page\nFonts"
  },
  {
    "title": "Styles & CSS üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/styling/",
    "html": "Styles & CSS\n\nAstro was designed to make styling and writing CSS a breeze. Write your own CSS directly inside of an Astro component or import your favorite CSS library like Tailwind. Advanced styling languages like Sass and Less are also supported.\n\nStyling in Astro\nSection titled Styling in Astro\n\nStyling an Astro component is as easy as adding a <style> tag to your component or page template. When you place a <style> tag inside of an Astro component, Astro will detect the CSS and handle your styles for you, automatically.\n\nsrc/components/MyComponent.astro\n<style>\n  h1 { color: red; }\n</style>\nScoped Styles\nSection titled Scoped Styles\n\nAstro <style> CSS rules are automatically scoped by default. Scoped styles are compiled behind-the-scenes to only apply to HTML written inside of that same component. The CSS that you write inside of an Astro component is automatically encapsulated inside of that component.\n\nThis CSS:\n\nindex.astro\n<style>\n  h1 {\n    color: red;\n  }\n\n\n  .text {\n    color: blue;\n  }\n</style>\n\nCompiles to this:\n\n<style>\n  h1[data-astro-cid-hhnqfkh6] {\n     color: red;\n  }\n\n\n  .text[data-astro-cid-hhnqfkh6] {\n    color: blue;\n  }\n</style>\n\nScoped styles don‚Äôt leak and won‚Äôt impact the rest of your site. In Astro, it is okay to use low-specificity selectors like h1 {} or p {} because they will be compiled with scopes in the final output.\n\nScoped styles also won‚Äôt apply to other Astro components contained inside of your template. If you need to style a child component, consider wrapping that component in a <div> (or other element) that you can then style.\n\nThe specificity of scoped styles is preserved, allowing them to work consistently alongside other CSS files or CSS libraries while still preserving the exclusive boundaries that prevent styles from applying outside the component.\n\nGlobal Styles\nSection titled Global Styles\n\nWhile we recommend scoped styles for most components, you may eventually find a valid reason to write global, unscoped CSS. You can opt-out of automatic CSS scoping with the <style is:global> attribute.\n\nsrc/components/GlobalStyles.astro\n<style is:global>\n  /* Unscoped, delivered as-is to the browser.\n     Applies to all <h1> tags on your site. */\n  h1 { color: red; }\n</style>\n\nYou can also mix global & scoped CSS rules together in the same <style> tag using the :global() selector. This becomes a powerful pattern for applying CSS styles to children of your component.\n\nsrc/components/MixedStyles.astro\n<style>\n  /* Scoped to this component, only. */\n  h1 { color: red; }\n  /* Mixed: Applies to child `h1` elements only. */\n  article :global(h1) {\n    color: blue;\n  }\n</style>\n<h1>Title</h1>\n<article><slot /></article>\n\nThis is a great way to style things like blog posts, or documents with CMS-powered content where the contents live outside of Astro. But be careful: components whose appearance differs based on whether or not they have a certain parent component can become difficult to troubleshoot.\n\nScoped styles should be used as often as possible. Global styles should be used only as-needed.\n\nCombining classes with class:list\nSection titled Combining classes with class:list\n\nIf you need to combine classes on an element dynamically, you can use the class:list utility attribute in .astro files.\n\nsrc/components/ClassList.astro\n---\nconst { isRed } = Astro.props;\n---\n<!-- If `isRed` is truthy, class will be \"box red\". -->\n<!-- If `isRed` is falsy, class will be \"box\". -->\n<div class:list={['box', { red: isRed }]}><slot /></div>\n\n\n<style>\n  .box { border: 1px solid blue; }\n  .red { border-color: red; }\n</style>\n\nüìö See our directives reference page to learn more about class:list.\n\nCSS Variables\nSection titled CSS Variables\nAdded in: astro@0.21.0\n\nThe Astro <style> can reference any CSS variables available on the page. You can also pass CSS variables directly from your component frontmatter using the define:vars directive.\n\nsrc/components/DefineVars.astro\n---\nconst foregroundColor = \"rgb(221 243 228)\";\nconst backgroundColor = \"rgb(24 121 78)\";\n---\n<style define:vars={{ foregroundColor, backgroundColor }}>\n  h1 {\n    background-color: var(--backgroundColor);\n    color: var(--foregroundColor);\n  }\n</style>\n<h1>Hello</h1>\n\nüìö See our directives reference page to learn more about define:vars.\n\nPassing a class to a child component\nSection titled Passing a class to a child component\n\nIn Astro, HTML attributes like class do not automatically pass through to child components.\n\nInstead, accept a class prop in the child component and apply it to the root element. When destructuring, you must rename it, because class is a reserved word in JavaScript.\n\nUsing the default scoped style strategy, you must also pass the data-astro-cid-* attribute. You can do this by passing the ...rest of the props to the component. If you have changed scopedStyleStrategy to 'class' or 'where', the ...rest prop is not necessary.\n\nsrc/components/MyComponent.astro\n---\nconst { class: className, ...rest } = Astro.props;\n---\n<div class={className} {...rest}>\n  <slot/>\n</div>\nsrc/pages/index.astro\n---\nimport MyComponent from \"../components/MyComponent.astro\"\n---\n<style>\n  .red {\n    color: red;\n  }\n</style>\n<MyComponent class=\"red\">This will be red!</MyComponent>\n\n SCOPED STYLES FROM PARENT COMPONENTS\n\nBecause the data-astro-cid-* attribute includes the child in its parent‚Äôs scope, it is possible for styles to cascade from parent to child. To avoid this having unintended side effects, ensure you use unique class names in the child component.\n\nInline styles\nSection titled Inline styles\n\nYou can style HTML elements inline using the style attribute. This can be a CSS string or an object of CSS properties:\n\nsrc/pages/index.astro\n// These are equivalent:\n<p style={{ color: \"brown\", textDecoration: \"underline\" }}>My text</p>\n<p style=\"color: brown; text-decoration: underline;\">My text</p>\nExternal Styles\nSection titled External Styles\n\nThere are two ways to resolve external global stylesheets: an ESM import for files located within your project source, and an absolute URL link for files in your public/ directory, or hosted outside of your project.\n\nüìö Read more about using static assets located in public/ or src/.\n\nImport a local stylesheet\nSection titled Import a local stylesheet\n\n USING AN NPM PACKAGE?\n\nYou may need to update your astro.config when importing from npm packages. See the ‚Äúimport stylesheets from an npm package‚Äù section below.\n\nYou can import stylesheets in your Astro component frontmatter using ESM import syntax. CSS imports work like any other ESM import in an Astro component, which should be referenced as relative to the component and must be written at the top of your component script, with any other imports.\n\nsrc/pages/index.astro\n---\n// Astro will bundle and optimize this CSS for you automatically\n// This also works for preprocessor files like .scss, .styl, etc.\nimport '../styles/utils.css';\n---\n<html><!-- Your page here --></html>\n\nCSS import via ESM are supported inside of any JavaScript file, including JSX components like React & Preact. This can be useful for writing granular, per-component styles for your React components.\n\nImport a stylesheet from an npm package\nSection titled Import a stylesheet from an npm package\n\nYou may also need to load stylesheets from an external npm package. This is especially common for utilities like Open Props. If your package recommends using a file extension (i.e. package-name/styles.css instead of package-name/styles), this should work like any local stylesheet:\n\nsrc/pages/random-page.astro\n---\nimport 'package-name/styles.css';\n---\n<html><!-- Your page here --></html>\n\nIf your package does not suggest using a file extension (i.e. package-name/styles), you‚Äôll need to update your Astro config first!\n\nSay you are importing a CSS file from package-name called normalize (with the file extension omitted). To ensure we can prerender your page correctly, add package-name to the vite.ssr.noExternal array:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  vite: {\n    ssr: {\n      noExternal: ['package-name'],\n    }\n  }\n})\n\n NOTE\n\nThis is a Vite-specific setting that does not relate to (or require) Astro SSR.\n\nNow, you are free to import package-name/normalize. This will be bundled and optimized by Astro like any other local stylesheet.\n\nsrc/pages/random-page.astro\n---\nimport 'package-name/normalize';\n---\n<html><!-- Your page here --></html>\nLoad a static stylesheet via ‚Äúlink‚Äù tags\nSection titled Load a static stylesheet via ‚Äúlink‚Äù tags\n\nYou can also use the <link> element to load a stylesheet on the page. This should be an absolute URL path to a CSS file located in your /public directory, or an URL to an external website. Relative <link> href values are not supported.\n\nsrc/pages/index.astro\n<head>\n  <!-- Local: /public/styles/global.css -->\n  <link rel=\"stylesheet\" href=\"/styles/global.css\" />\n  <!-- External -->\n  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/prismjs@1.24.1/themes/prism-tomorrow.css\" />\n</head>\n\nBecause this approach uses the public/ directory, it skips the normal CSS processing, bundling and optimizations that are provided by Astro. If you need these transformations, use the Import a Stylesheet method above.\n\nCascading Order\nSection titled Cascading Order\n\nAstro components will sometimes have to evaluate multiple sources of CSS. For example, your component might import a CSS stylesheet, include its own <style> tag, and be rendered inside a layout that imports CSS.\n\nWhen conflicting CSS rules apply to the same element, browsers first use specificity and then order of appearance to determine which value to show.\n\nIf one rule is more specific than another, no matter where the CSS rule appears, its value will take precedence:\n\nMyComponent.astro\n<style>\n  h1 { color: red }\n  div > h1 {\n    color: purple\n  }\n</style>\n<div>\n  <h1>\n    This header will be purple!\n  </h1>\n</div>\n\nIf two rules have the same specificity, then the order of appearance is evaluated, and the last rule‚Äôs value will take precedence:\n\nMyComponent.astro\n<style>\n  h1 { color: purple }\n  h1 { color: red }\n</style>\n<div>\n  <h1>\n    This header will be red!\n  </h1>\n</div>\n\nAstro CSS rules are evaluated in this order of appearance:\n\n<link> tags in the head (lowest precedence)\nimported styles\nscoped styles (highest precedence)\nScoped Styles\nSection titled Scoped Styles\n\nUsing scoped styles does not increase the specificity of your CSS, but they will always come last in the order of appearance. They will therefore take precedence over other styles of the same specificity. For example, if you import a stylesheet that conflicts with a scoped style, the scoped style‚Äôs value will apply:\n\nmake-it-purple.css\nh1 {\n  color: purple;\n}\nMyComponent.astro\n---\nimport \"./make-it-purple.css\"\n---\n<style>\n  h1 { color: red }\n</style>\n<div>\n  <h1>\n    This header will be red!\n  </h1>\n</div>\n\nIf you make the imported style more specific, it will have higher precedence over the scoped style:\n\nmake-it-purple.css\ndiv > h1 {\n  color: purple;\n}\nMyComponent.astro\n---\nimport \"./make-it-purple.css\"\n---\n<style>\n  h1 { color: red }\n</style>\n<div>\n  <h1>\n    This header will be purple!\n  </h1>\n</div>\nImport Order\nSection titled Import Order\n\nWhen importing multiple stylesheets in an Astro component, the CSS rules are evaluated in the order that they are imported. A higher specificity will always determine which styles to show, no matter when the CSS is evaluated. But, when conflicting styles have the same specificity, the last one imported wins:\n\nmake-it-purple.css\ndiv > h1 {\n  color: purple;\n}\nmake-it-green.css\ndiv > h1 {\n  color: green;\n}\nMyComponent.astro\n---\nimport \"./make-it-green.css\"\nimport \"./make-it-purple.css\"\n---\n<style>\n  h1 { color: red }\n</style>\n<div>\n  <h1>\n    This header will be purple!\n  </h1>\n</div>\n\nWhile <style> tags are scoped and only apply to the component that declares them, imported CSS can ‚Äúleak‚Äù. Importing a component applies any CSS it imports, even if the component is never used:\n\nPurpleComponent.astro\n---\nimport \"./make-it-purple.css\"\n---\n<div>\n  <h1>I import purple CSS.</h1>\n</div>\nMyComponent.astro\n---\nimport \"./make-it-green.css\"\nimport PurpleComponent from \"./PurpleComponent.astro\";\n---\n<style>\n  h1 { color: red }\n</style>\n<div>\n  <h1>\n    This header will be purple!\n  </h1>\n</div>\n\n TIP\n\nA common pattern in Astro is to import global CSS inside a Layout component. Be sure to import the Layout component before other imports so that it has the lowest precedence.\n\nLink Tags\nSection titled Link Tags\n\nStyle sheets loaded via link tags are evaluated in order, before any other styles in an Astro file. Therefore, these styles will have lower precedence than imported stylesheets and scoped styles:\n\nindex.astro\n---\nimport \"../components/make-it-purple.css\"\n---\n\n\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>Astro</title>\n    <link rel=\"stylesheet\" href=\"/styles/make-it-blue.css\" />\n  </head>\n  <body>\n    <div>\n      <h1>This will be purple</h1>\n    </div>\n  </body>\n</html>\nCSS Integrations\nSection titled CSS Integrations\n\nAstro comes with support for adding popular CSS libraries, tools, and frameworks to your project like Tailwind and more!\n\nTailwind\nSection titled Tailwind\n\nTo use Tailwind in your project, install the official Astro Tailwind integration using the astro add command for your package manager:\n\nnpm\npnpm\nYarn\nTerminal window\nnpx astro add tailwind\n\nüìö See the Integrations Guide for instructions on installing, importing and configuring Astro integrations.\n\nCSS Preprocessors\nSection titled CSS Preprocessors\n\nAstro supports CSS preprocessors such as Sass, Stylus, and Less through Vite.\n\nSass and SCSS\nSection titled Sass and SCSS\nTerminal window\nnpm install sass\n\nUse <style lang=\"scss\"> or <style lang=\"sass\"> in .astro files.\n\nStylus\nSection titled Stylus\nTerminal window\nnpm install stylus\n\nUse <style lang=\"styl\"> or <style lang=\"stylus\"> in .astro files.\n\nLess\nSection titled Less\nTerminal window\nnpm install less\n\nUse <style lang=\"less\"> in .astro files.\n\nIn framework components\nSection titled In framework components\n\nYou can also use all of the above CSS preprocessors within JS frameworks as well! Be sure to follow the patterns each framework recommends:\n\nReact / Preact: import Styles from './styles.module.scss';\nVue: <style lang=\"scss\">\nSvelte: <style lang=\"scss\">\nPostCSS\nSection titled PostCSS\n\nAstro comes with PostCSS included as part of Vite. To configure PostCSS for your project, create a postcss.config.cjs file in the project root. You can import plugins using require() after installing them (for example npm install autoprefixer).\n\npostcss.config.cjs\nmodule.exports = {\n  plugins: [\n    require('autoprefixer'),\n    require('cssnano'),\n  ],\n};\nFrameworks and Libraries\nSection titled Frameworks and Libraries\nüìò React / Preact\nSection titled üìò React / Preact\n\n.jsx files support both global CSS and CSS Modules. To enable the latter, use the .module.css extension (or .module.scss/.module.sass if using Sass).\n\nsrc/components/MyReactComponent.jsx\nimport './global.css'; // include global CSS\nimport Styles from './styles.module.css'; // Use CSS Modules (must end in `.module.css`, `.module.scss`, or `.module.sass`!)\nüìó Vue\nSection titled üìó Vue\n\nVue in Astro supports the same methods as vue-loader does:\n\nvue-loader - Scoped CSS\nvue-loader - CSS Modules\nüìï Svelte\nSection titled üìï Svelte\n\nSvelte in Astro also works exactly as expected: Svelte Styling Docs.\n\nMarkdown Styling\nSection titled Markdown Styling\n\nAny Astro styling methods are available to a Markdown layout component, but different methods will have different styling effects on your page.\n\nYou can apply global styles to your Markdown content by adding imported stylesheets to the layout that wraps your page content. It is also possible to style your Markdown with <style is:global> tags in the layout component. Note that any styles added are subject to Astro‚Äôs cascading order, and you should check your rendered page carefully to ensure your styles are being applied as intended.\n\nYou can also add CSS integrations including Tailwind. If you are using Tailwind, the typography plugin can be useful for styling Markdown.\n\nProduction\nSection titled Production\nBundle control\nSection titled Bundle control\n\nWhen Astro builds your site for production deployment, it minifies and combines your CSS into chunks. Each page on your site gets its own chunk, and additionally, CSS that is shared between multiple pages is further split off into their own chunks for reuse.\n\nHowever, when you have several pages sharing styles, some shared chunks can become really small. If all of them were sent separately, it would lead to many stylesheets requests and affect site performance. Therefore, by default Astro will link only those in your HTML above 4kB in size as <link rel=\"stylesheet\"> tags, while inlining smaller ones into <style type=\"text/css\">. This approach provides a balance between the number of additional requests and the volume of CSS that can be cached between pages.\n\nYou can configure the size at which stylesheets will be linked externally (in bytes) using the assetsInlineLimit vite build option. Note that this option affects script and image inlining as well.\n\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  vite: {\n    build: {\n      assetsInlineLimit: 1024,\n    }\n  };\n});\n\nIf you would rather all project styles remain external, you can configure the inlineStylesheets build option.\n\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  build: {\n    inlineStylesheets: 'never'\n  }\n});\n\nYou can also set this option to 'always' which will inline all stylesheets.\n\nAdvanced\nSection titled Advanced\n\n CAUTION\n\nBe careful when bypassing Astro‚Äôs built-in CSS bundling! Styles won‚Äôt be automatically included in the built output, and it is your responsibility to make sure that the referenced file is properly included in the final page output.\n\n?raw CSS Imports\nSection titled ?raw CSS Imports\n\nFor advanced use cases, CSS can be read directly from disk without being bundled or optimized by Astro. This can be useful when you need complete control over some snippet of CSS, and need to bypass Astro‚Äôs automatic CSS handling.\n\nThis is not recommended for most users.\n\nsrc/components/RawInlineStyles.astro\n---\n// Advanced example! Not recommended for most users.\nimport rawStylesCSS from '../styles/main.css?raw';\n---\n<style is:inline set:html={rawStylesCSS}></style>\n\nSee Vite‚Äôs docs for full details.\n\n?url CSS Imports\nSection titled ?url CSS Imports\n\nFor advanced use cases, you can import a direct URL reference for a CSS file inside of your project src/ directory. This can be useful when you need complete control over how a CSS file is loaded on the page. However, this will prevent the optimization of that CSS file with the rest of your page CSS .\n\nThis is not recommended for most users. Instead, place your CSS files inside of public/ to get a consistent URL reference.\n\n CAUTION\n\nImporting a smaller CSS file with ?url may return the base64 encoded contents of the CSS file as a data URL in your final build. Either write your code to support encoded data URLs (data:text/css;base64,...) or set the vite.build.assetsInlineLimit config option to 0 to disable this feature.\n\nsrc/components/RawStylesUrl.astro\n---\n// Advanced example! Not recommended for most users.\nimport stylesUrl from '../styles/main.css?url';\n---\n<link rel=\"preload\" href={stylesUrl} as=\"style\">\n<link rel=\"stylesheet\" href={stylesUrl}>\n\nSee Vite‚Äôs docs for full details.\n\nBack\nScripts & Event Handling\nNext Page\nImages"
  },
  {
    "title": "Scripts and Event Handling üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/client-side-scripts/",
    "html": "Scripts and Event Handling\n\nYou can add interactivity to your Astro components without using a UI framework like React, Svelte, Vue, etc. using standard HTML <script> tags. This allows you to send JavaScript to run in the browser and add functionality to your Astro components.\n\nClient-Side Scripts\nSection titled Client-Side Scripts\n\nScripts can be used to add event listeners, send analytics data, play animations, and everything else JavaScript can do on the web.\n\nsrc/components/ConfettiButton.astro\n<button data-confetti-button>Celebrate!</button>\n\n\n<script>\n  // Import npm modules.\n  import confetti from 'canvas-confetti';\n\n\n  // Find our component DOM on the page.\n  const buttons = document.querySelectorAll('[data-confetti-button]');\n\n\n  // Add event listeners to fire confetti when a button is clicked.\n  buttons.forEach((button) => {\n    button.addEventListener('click', () => confetti());\n  });\n</script>\n\nBy default, Astro processes and bundles <script> tags, adding support for importing npm modules, writing TypeScript, and more.\n\nUsing <script> in Astro\nSection titled Using &lt;script&gt; in Astro\n\nIn .astro files, you can add client-side JavaScript by adding one (or more) <script> tags.\n\nIn this example, adding the <Hello /> component to a page will log a message to the browser console.\n\nsrc/components/Hello.astro\n<h1>Welcome, world!</h1>\n\n\n<script>\n  console.log('Welcome, browser console!');\n</script>\nScript processing\nSection titled Script processing\n\nBy default, <script> tags are processed by Astro.\n\nAny imports will be bundled, allowing you to import local files or Node modules.\nThe processed script will be injected into your page‚Äôs <head> with type=\"module\".\nTypeScript is fully supported, including importing TypeScript files.\nIf your component is used several times on a page, the script will only be included once.\nsrc/components/Example.astro\n<script>\n  // Processed! Bundled! TypeScript-supported!\n  // Importing local scripts and Node modules works.\n</script>\n\nThe type=\"module\" attribute makes the browser treat the script as a JavaScript module. This has several performance benefits:\n\nRendering is not blocked. The browser continues to process the rest of the HTML while the module script and its dependencies load.\nThe browser waits for HTML to be processed before executing module scripts. You do not need to listen for the ‚Äúload‚Äù event.\nasync and defer attributes are unnecessary. Module scripts are always deferred.\n\n NOTE\n\nThe async attribute is valuable for normal scripts because it prevents them from blocking rendering. However, module scripts already have this behavior. Adding async to a module script will cause it to execute before the page has fully loaded. This is probably not what you want.\n\nOpting out of processing\nSection titled Opting out of processing\n\nTo prevent Astro from processing a script, add the is:inline directive.\n\nsrc/components/InlineScript.astro\n<script is:inline>\n  // Will be rendered into the HTML exactly as written!\n  // Local imports are not resolved and will not work.\n  // If in a component, repeats each time the component is used.\n</script>\n\n NOTE\n\nAstro will not process your script tags in some situations. In particular, adding type=\"module\" or any attribute other than src to a <script> tag will cause Astro to treat the tag as if it had an is:inline directive. The same will be true when the script is written in a JSX expression.\n\nüìö See our directives reference page for more information about the directives available on <script> tags.\n\nInclude javascript files on your page\nSection titled Include javascript files on your page\n\nYou may want to write your scripts as separate .js/.ts files or need to reference an external script on another server. You can do this by referencing these in a <script> tag‚Äôs src attribute.\n\nImport local scripts\nSection titled Import local scripts\n\nWhen to use this: when your script lives inside of src/.\n\nAstro will build, optimize, and add these scripts to the page for you, following its script processing rules.\n\nsrc/components/LocalScripts.astro\n<!-- relative path to script at `src/scripts/local.js` -->\n<script src=\"../scripts/local.js\"></script>\n\n\n<!-- also works for local TypeScript files -->\n<script src=\"./script-with-types.ts\"></script>\nLoad external scripts\nSection titled Load external scripts\n\nWhen to use this: when your JavaScript file lives inside of public/ or on a CDN.\n\nTo load scripts outside of your project‚Äôs src/ folder, include the is:inline directive. This approach skips the JavaScript processing, bundling, and optimizations that are provided by Astro when you import scripts as described above.\n\nsrc/components/ExternalScripts.astro\n<!-- absolute path to a script at `public/my-script.js` -->\n<script is:inline src=\"/my-script.js\"></script>\n\n\n<!-- full URL to a script on a remote server -->\n<script is:inline src=\"https://my-analytics.com/script.js\"></script>\nCommon script patterns\nSection titled Common script patterns\nHandle onclick and other events\nSection titled Handle onclick and other events\n\nSome UI frameworks use custom syntax for event handling like onClick={...} (React/Preact) or @click=\"...\" (Vue). Astro follows standard HTML more closely and does not use custom syntax for events.\n\nInstead, you can use addEventListener in a <script> tag to handle user interactions.\n\nsrc/components/AlertButton.astro\n<button class=\"alert\">Click me!</button>\n\n\n<script>\n  // Find all buttons with the `alert` class on the page.\n  const buttons = document.querySelectorAll('button.alert');\n\n\n  // Handle clicks on each button.\n  buttons.forEach((button) => {\n    button.addEventListener('click', () => {\n      alert('Button was clicked!');\n    });\n  });\n</script>\n\n NOTE\n\nIf you have multiple <AlertButton /> components on a page, Astro will not run the script multiple times. Scripts are bundled and only included once per page. Using querySelectorAll ensures that this script attaches the event listener to every button with the alert class found on the page.\n\nWeb components with custom elements\nSection titled Web components with custom elements\n\nYou can create your own HTML elements with custom behavior using the Web Components standard. Defining a custom element in a .astro component allows you to build interactive components without needing a UI framework library.\n\nIn this example, we define a new <astro-heart> HTML element that tracks how many times you click the heart button and updates the <span> with the latest count.\n\nsrc/components/AstroHeart.astro\n<!-- Wrap the component elements in our custom element ‚Äúastro-heart‚Äù. -->\n<astro-heart>\n  <button aria-label=\"Heart\">üíú</button> √ó <span>0</span>\n</astro-heart>\n\n\n<script>\n  // Define the behaviour for our new type of HTML element.\n  class AstroHeart extends HTMLElement {\n    constructor() {\n      super();\n      let count = 0;\n\n\n      const heartButton = this.querySelector('button');\n      const countSpan = this.querySelector('span');\n\n\n      // Each time the button is clicked, update the count.\n      heartButton.addEventListener('click', () => {\n        count++;\n        countSpan.textContent = count.toString();\n      });\n    }\n  }\n\n\n  // Tell the browser to use our AstroHeart class for <astro-heart> elements.\n  customElements.define('astro-heart', AstroHeart);\n</script>\n\nThere are two advantages to using a custom element here:\n\nInstead of searching the whole page using document.querySelector(), you can use this.querySelector(), which only searches within the current custom element instance. This makes it easier to work with only the children of one component instance at a time.\n\nAlthough a <script> only runs once, the browser will run our custom element‚Äôs constructor() method each time it finds <astro-heart> on the page. This means you can safely write code for one component at a time, even if you intend to use this component multiple times on a page.\n\nüìö You can learn more about custom elements in web.dev‚Äôs Reusable Web Components guide and MDN‚Äôs introduction to custom elements.\n\nPass frontmatter variables to scripts\nSection titled Pass frontmatter variables to scripts\n\nIn Astro components, the code in the frontmatter between the --- fences runs on the server and is not available in the browser. To send variables from the server to the client, we need a way to store our variables and then read them when JavaScript runs in the browser.\n\nOne way to do this is to use data-* attributes to store the value of variables in your HTML output. Scripts, including custom elements, can then read these attributes using an element‚Äôs dataset property once your HTML loads in the browser.\n\nIn this example component, a message prop is stored in a data-message attribute, so the custom element can read this.dataset.message and get the value of the prop in the browser.\n\nsrc/components/AstroGreet.astro\n---\nconst { message = 'Welcome, world!' } = Astro.props;\n---\n\n\n<!-- Store the message prop as a data attribute. -->\n<astro-greet data-message={message}>\n  <button>Say hi!</button>\n</astro-greet>\n\n\n<script>\n  class AstroGreet extends HTMLElement {\n    constructor() {\n      super();\n\n\n      // Read the message from the data attribute.\n      const message = this.dataset.message;\n      const button = this.querySelector('button');\n      button.addEventListener('click', () => {\n        alert(message);\n      });\n    }\n  }\n\n\n  customElements.define('astro-greet', AstroGreet);\n</script>\n\nNow we can use our component multiple times and be greeted by a different message for each one.\n\nsrc/pages/example.astro\n---\nimport AstroGreet from '../components/AstroGreet.astro';\n---\n\n\n<!-- Use the default message: ‚ÄúWelcome, world!‚Äù -->\n<AstroGreet />\n\n\n<!-- Use custom messages passed as a props. -->\n<AstroGreet message=\"Lovely day to build components!\" />\n<AstroGreet message=\"Glad you made it! üëã\" />\n\n DID YOU KNOW?\n\nThis is actually what Astro does behind the scenes when you pass props to a component written using a UI framework like React! For components with a client:* directive, Astro creates an <astro-island> custom element with a props attribute that stores your server-side props in the HTML output.\n\nBack\nMarkdown\nNext Page\nCSS & Styling"
  },
  {
    "title": "Markdown & MDX üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/markdown-content/",
    "html": "Markdown & MDX\n\nMarkdown is commonly used to author text-heavy content like blog posts and documentation. Astro includes built-in support for standard Markdown files that can also include frontmatter YAML to define custom metadata such as a title, description, and tags.\n\nWith the @astrojs/mdx integration installed, Astro also supports MDX (.mdx) files which bring added features like support for JavaScript expressions and components in your Markdown content.\n\nUse either or both types of files to write your Markdown content!\n\nMarkdown and MDX Pages\nSection titled Markdown and MDX Pages\nContent collections\nSection titled Content collections\n\nYou can manage your Markdown and MDX files in Astro in a special src/content/ folder. Content collections help you organize your content, validate your frontmatter, and provide automatic TypeScript type-safety while working with your content.\n\nDirectory\nsrc/content/\nDirectory\nnewsletter/\nweek-1.md\nweek-2.md\nDirectory\nauthors/\ngrace-hopper.md\nalan-turing.md\n\nSee more about using content collections in Astro.\n\nFile-based Routing\nSection titled File-based Routing\n\nAstro treats any .md (or alternative supported extension) or .mdx file inside of the /src/pages/ directory as a page.\n\nPlacing a file in this directory, or any sub-directory, will automatically build a page route using the pathname of the file.\n\nsrc/pages/page-1.md\n---\ntitle: Hello, World\n---\n\n\n# Hi there!\n\n\nThis Markdown file creates a page at `your-domain.com/page-1/`\n\n\nIt probably isn't styled much, but Markdown does support:\n- **bold** and _italics._\n- lists\n- [links](https://astro.build)\n- and more!\n\nüìö Read more about Astro‚Äôs file-based routing or options for creating dynamic routes.\n\nMarkdown Features\nSection titled Markdown Features\n\nAstro provides some extra, built-in Markdown features available when using Markdown and MDX files.\n\nFrontmatter layout\nSection titled Frontmatter layout\n\nAstro provides Markdown and MDX pages with a special frontmatter layout property that can specify a relative path (or alias) to an Astro layout component.\n\nsrc/pages/posts/post-1.md\n---\nlayout: ../../layouts/BlogPostLayout.astro\ntitle: Astro in brief\nauthor: Himanshu\ndescription: Find out what makes Astro awesome!\n---\nThis is a post written in Markdown.\n\nSpecific properties are then available to the layout component through Astro.props. For example, you can access frontmatter properties through Astro.props.frontmatter:\n\nsrc/layouts/BlogPostLayout.astro\n---\nconst {frontmatter} = Astro.props;\n---\n<html>\n  <!-- ... -->\n  <h1>{frontmatter.title}</h1>\n  <h2>Post author: {frontmatter.author}</h2>\n  <p>{frontmatter.description}</p>\n  <slot /> <!-- Markdown content is injected here -->\n   <!-- ... -->\n</html>\n\nYou can also style your Markdown in your layout component.\n\nüìö Learn more about Markdown Layouts.\n\nHeading IDs\nSection titled Heading IDs\n\nUsing headings in Markdown and MDX will automatically give you anchor links so you can link directly to certain sections of your page.\n\nsrc/pages/page-1.md\n---\ntitle: My page of content\n---\n## Introduction\n\n\nI can link internally to [my conclusion](#conclusion) on the same page when writing Markdown.\n\n\n## Conclusion\n\n\nI can use the URL `https://example.com/page-1/#introduction` to navigate directly to my Introduction on the page.\n\nAstro generates heading ids based on github-slugger. You can find more examples in the github-slugger documentation.\n\nEscaping special characters\nSection titled Escaping special characters\n\nCertain characters have a special meaning in Markdown and MDX. You may need to use a different syntax if you want to display them. To do this, you can use HTML entities for these characters instead.\n\nFor example, to prevent < being interpreted as the beginning of an HTML element, write &lt;. Or, to prevent { being interpreted as the beginning of a JavaScript expression in MDX, write &lcub;.\n\nMDX-only Features\nSection titled MDX-only Features\n\nAdding the Astro MDX integration enhances your Markdown authoring with JSX variables, expressions and components.\n\nIt also adds extra features to standard MDX, including support for Markdown-style frontmatter in MDX. This allows you to use most of Astro‚Äôs built-in Markdown features like a frontmatter layout property.\n\n.mdx files must be written in MDX syntax rather than Astro‚Äôs HTML-like syntax.\n\nUsing Exported Variables in MDX\nSection titled Using Exported Variables in MDX\n\nMDX supports using export statements to add variables to your MDX content. These variables are accessible both in the template itself and as named properties when importing the file somewhere else.\n\nFor example, you can export a title field from an MDX page or component to use as a heading with {JSX expressions}:\n\n/src/pages/posts/post-1.mdx\nexport const title = 'My first MDX post'\n\n\n# {title}\nUsing Frontmatter Variables in MDX\nSection titled Using Frontmatter Variables in MDX\n\nThe Astro MDX integration includes support for using frontmatter in MDX by default. Add frontmatter properties just as you would in Markdown files, and these variables are accessible to use in the template, in its layout component, and as named properties when importing the file somewhere else.\n\n/src/pages/posts/post-1.mdx\n---\nlayout: '../../layouts/BlogPostLayout.astro'\ntitle: 'My first MDX post'\n---\n\n\n# {frontmatter.title}\nUsing Components in MDX\nSection titled Using Components in MDX\n\nAfter installing the MDX integration, you can import and use both Astro components and UI framework components in MDX (.mdx) files just as you would use them in any other Astro component.\n\nDon‚Äôt forget to include a client:directive on your UI framework components, if necessary!\n\nSee more examples of using import and export statements in the MDX docs.\n\nsrc/pages/about.mdx\n---\nlayout: ../layouts/BaseLayout.astro\ntitle: About me\n---\nimport Button from '../components/Button.astro';\nimport ReactCounter from '../components/ReactCounter.jsx';\n\n\nI live on **Mars** but feel free to <Button title=\"Contact me\" />.\n\n\nHere is my counter component, working in MDX:\n\n\n<ReactCounter client:load />\nAssigning Custom Components to HTML elements\nSection titled Assigning Custom Components to HTML elements\n\nWith MDX, you can map Markdown syntax to custom components instead of their standard HTML elements. This allows you to write in standard Markdown syntax, but apply special component styling to selected elements.\n\nImport your custom component into your .mdx file, then export a components object that maps the standard HTML element to your custom component:\n\nsrc/pages/about.mdx\nimport Blockquote from '../components/Blockquote.astro';\nexport const components = {blockquote: Blockquote}\n\n\n> This quote will be a custom Blockquote\nsrc/components/Blockquote.astro\n---\nconst props = Astro.props;\n---\n<blockquote {...props} class=\"bg-blue-50 p-4\">\n  <span class=\"text-4xl text-blue-600 mb-2\">‚Äú</span>\n  <slot /> <!-- Be sure to add a `<slot/>` for child content! -->\n</blockquote>\n\nVisit the MDX website for a full list of HTML elements that can be overwritten as custom components.\n\nImporting Markdown\nSection titled Importing Markdown\n\nYou can import Markdown and MDX files directly into your Astro files. This gives you access to their Markdown content, as well as other properties such as frontmatter values that can be used within Astro‚Äôs JSX-like expressions.\n\nYou can import one specific page with an import statement, or multiple pages with Astro.glob().\n\nsrc/pages/index.astro\n---\n// Import a single file\nimport * as myPost from '../pages/post/my-post.md';\n\n\n// Import multiple files with Astro.glob\nconst posts = await Astro.glob('../pages/post/*.md');\n---\n\nWhen you import Markdown and MDX files in an Astro component, you get an object containing their exported properties.\n\n/src/pages/posts/great-post.md\n---\ntitle: 'The greatest post of all time'\nauthor: 'Ben'\n---\n\n\nHere is my _great_ post!\nsrc/pages/my-posts.astro\n---\nimport * as greatPost from '../pages/post/great-post.md';\n\n\nconst posts = await Astro.glob('../pages/post/*.md');\n---\n\n\n<p>{greatPost.frontmatter.title}</p>\n<p>Written by: {greatPost.frontmatter.author}</p>\n\n\n<p>Post Archive:</p>\n<ul>\n  {posts.map(post => <li><a href={post.url}>{post.frontmatter.title}</a></li>)}\n</ul>\n\nIn MDX files, you can access properties from both frontmatter and export statements:\n\n/src/pages/posts/mdx-post.mdx\n---\ntitle: 'The greatest post of all time'\nauthor: 'Ben'\n---\nexport const description = 'Get comfortable! This is going to be a great read.'\n\n\nHere is my _great_ post!\nsrc/pages/my-posts.astro\n---\nimport * as greatPost from '../pages/post/mdx-post.mdx';\n---\n\n\n<p>{greatPost.frontmatter.title}</p>\n<p>Written by: {greatPost.frontmatter.author}</p>\n<p>{greatPost.description}</p>\n\nYou can optionally provide a type for the frontmatter variable using a TypeScript generic:\n\nsrc/pages/index.astro\n---\ninterface Frontmatter {\n  title: string;\n  description?: string;\n}\nconst posts = await Astro.glob<Frontmatter>('../pages/post/*.md');\n---\n\n\n<ul>\n  {posts.map(post => <li>{post.frontmatter.title}</li>)}\n  <!-- post.frontmatter.title will be `string`! -->\n</ul>\nExported Properties\nSection titled Exported Properties\n\n USING AN ASTRO LAYOUT?\n\nSee the properties exported to an Astro layout component when using Astro‚Äôs special frontmatter layout.\n\nThe following properties are available to a .astro component when using an import statement or Astro.glob():\n\nfile - The absolute file path (e.g. /home/user/projects/.../file.md).\nurl - If it‚Äôs a page, the URL of the page (e.g. /en/guides/markdown-content).\nfrontmatter - Contains any data specified in the file‚Äôs YAML frontmatter.\ngetHeadings - An async function that returns an array of all headings (i.e. h1 -> h6 elements) in the file. Each heading‚Äôs slug corresponds to the generated ID for a given heading and can be used for anchor links. This list follows the type: { depth: number; slug: string; text: string }[].\nContent - A component that returns the full, rendered contents of the file.\n(Markdown only) rawContent() - A function that returns the raw Markdown document as a string.\n(Markdown only) compiledContent() - A function that returns the Markdown document compiled to an HTML string. Note this does not include layouts configured in your frontmatter! Only the markdown document itself will be returned as HTML.\n(MDX only) - MDX files can also export data with an export statement.\nThe Content Component\nSection titled The Content Component\n\nImport Content to render a component that returns the full rendered contents of a Markdown or MDX file:\n\nsrc/pages/content.astro\n---\nimport {Content as PromoBanner} from '../components/promoBanner.md';\n---\n\n\n<h2>Today's promo</h2>\n<PromoBanner />\nExample: Dynamic page routing\nSection titled Example: Dynamic page routing\n\nInstead of putting your Markdown/MDX files in the src/pages/ directory to create page routes, you can generate pages dynamically.\n\nTo access your Markdown content, pass the <Content/> component through the Astro page‚Äôs props. You can then retrieve the component from Astro.props and render it in your page template.\n\nsrc/pages/[slug].astro\n---\nexport async function getStaticPaths() {\n  const posts = await Astro.glob('../posts/**/*.md')\n\n\n  return posts.map(post => ({\n    params: {\n      slug: post.frontmatter.slug\n    },\n    props: {\n      post\n    },\n  }))\n}\n\n\nconst { Content } = Astro.props.post\n---\n<article>\n  <Content/>\n</article>\nMDX-only Exports\nSection titled MDX-only Exports\n\nMDX files can also export data with an export statement.\n\nFor example, you can export a title field from an MDX page or component.\n\n/src/pages/posts/post-1.mdx\nexport const title = 'My first MDX post'\n\nThis title will be accessible from import and Astro.glob() statements:\n\nsrc/pages/index.astro\n---\nconst posts = await Astro.glob('./*.mdx');\n---\n\n\n{posts.map(post => <p>{post.title}</p>)}\nCustom components with imported MDX\nSection titled Custom components with imported MDX\n\nWhen rendering imported MDX content, custom components can be passed via the components prop.\n\nsrc/pages/page.astro\n---\nimport { Content, components } from '../content.mdx';\nimport Heading from '../Heading.astro';\n---\n<!-- Creates a custom <h1> for the # syntax, _and_ applies any custom components defined in `content.mdx` -->\n<Content components={{...components, h1: Heading }} />\n\n NOTE\n\nCustom components defined and exported in an MDX file must be imported and then passed back to the <Content /> component via the components property.\n\nConfiguring Markdown and MDX\nSection titled Configuring Markdown and MDX\n\nMarkdown support in Astro is powered by remark, a powerful parsing and processing tool with an active ecosystem. Other Markdown parsers like Pandoc and markdown-it are not currently supported.\n\nAstro applies the GitHub-flavored Markdown and SmartyPants plugins by default. This brings some niceties like generating clickable links from text, and formatting for quotations and em-dashes.\n\nYou can customize how remark parses your Markdown in astro.config.mjs. See the full list of Markdown configuration options.\n\nMarkdown Plugins\nSection titled Markdown Plugins\n\nAstro supports adding third-party remark and rehype plugins for Markdown and MDX. These plugins allow you to extend your Markdown with new capabilities, like auto-generating a table of contents, applying accessible emoji labels, and styling your Markdown.\n\nWe encourage you to browse awesome-remark and awesome-rehype for popular plugins! See each plugin‚Äôs own README for specific installation instructions.\n\nThis example applies remark-toc and rehype-accessible-emojis to both Markdown and MDX files:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport remarkToc from 'remark-toc';\nimport { rehypeAccessibleEmojis } from 'rehype-accessible-emojis';\n\n\nexport default defineConfig({\n  markdown: {\n    // Applied to .md and .mdx files\n    remarkPlugins: [remarkToc],\n    rehypePlugins: [rehypeAccessibleEmojis],\n  },\n});\n\nNote that by default, remarkToc requires a ‚ÄúToC‚Äù or ‚ÄúTable of Contents‚Äù heading (case-insensitive) on the page to show the table of contents.\n\nHeading IDs and plugins\nSection titled Heading IDs and plugins\n\nAstro injects an id attribute into all heading elements (<h1> to <h6>) in Markdown and MDX files and provides a getHeadings() utility for retrieving these IDs in Markdown exported properties.\n\nYou can customize these heading IDs by adding a rehype plugin that injects id attributes (e.g. rehype-slug). Your custom IDs, instead of Astro‚Äôs defaults, will be reflected in the HTML output and the items returned by getHeadings().\n\nBy default, Astro injects id attributes after your rehype plugins have run. If one of your custom rehype plugins needs to access the IDs injected by Astro, you can import and use Astro‚Äôs rehypeHeadingIds plugin directly. Be sure to add rehypeHeadingIds before any plugins that rely on it:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport { rehypeHeadingIds } from '@astrojs/markdown-remark';\nimport { otherPluginThatReliesOnHeadingIDs } from 'some/plugin/source';\n\n\nexport default defineConfig({\n  markdown: {\n    rehypePlugins: [\n      rehypeHeadingIds,\n      otherPluginThatReliesOnHeadingIDs,\n    ],\n  },\n});\nCustomizing a plugin\nSection titled Customizing a plugin\n\nIn order to customize a plugin, provide an options object after it in a nested array.\n\nThe example below adds the heading option to the remarkToc plugin to change where the table of contents is placed, and the behavior option to the rehype-autolink-headings plugin in order to add the anchor tag after the headline text.\n\nastro.config.mjs\nimport remarkToc from 'remark-toc';\nimport rehypeSlug from 'rehype-slug';\nimport rehypeAutolinkHeadings from 'rehype-autolink-headings';\n\n\nexport default {\n  markdown: {\n    remarkPlugins: [ [remarkToc, { heading: \"contents\"} ] ],\n    rehypePlugins: [rehypeSlug, [rehypeAutolinkHeadings, { behavior: 'append' }]],\n  },\n}\nModifying frontmatter programmatically\nSection titled Modifying frontmatter programmatically\n\n NOTE\n\nIf you are using content collections, please see ‚ÄúModifying Frontmatter with Remark‚Äù.\n\nYou can add frontmatter properties to all of your Markdown and MDX files by using a remark or rehype plugin.\n\nAppend a customProperty to the data.astro.frontmatter property from your plugin‚Äôs file argument:\n\nexample-remark-plugin.mjs\nexport function exampleRemarkPlugin() {\n  // All remark and rehype plugins return a separate function\n  return function (tree, file) {\n    file.data.astro.frontmatter.customProperty = 'Generated property';\n  }\n}\n\n TIP\n\nAdded in: astro@2.0.0\n\ndata.astro.frontmatter contains all properties from a given Markdown or MDX document. This allows you to modify existing frontmatter properties, or compute new properties from this existing frontmatter.\n\nApply this plugin to your markdown or mdx integration config:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport { exampleRemarkPlugin } from './example-remark-plugin.mjs';\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [exampleRemarkPlugin]\n  },\n});\n\nor\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport { exampleRemarkPlugin } from './example-remark-plugin.mjs';\n\n\nexport default defineConfig({\n  integrations: [\n    mdx({\n      remarkPlugins: [exampleRemarkPlugin],\n    }),\n  ],\n});\n\nNow, every Markdown or MDX file will have customProperty in its frontmatter, making it available when importing your markdown and from the Astro.props.frontmatter property in your layouts.\n\nRelated recipe:\nAdd Reading Time\nExtending Markdown config from MDX\nSection titled Extending Markdown config from MDX\n\nAstro‚Äôs MDX integration will extend your project‚Äôs existing Markdown configuration by default. To override individual options, you can specify their equivalent in your MDX configuration.\n\nThe following example disables GitHub-Flavored Markdown and applies a different set of remark plugins for MDX files:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  markdown: {\n    syntaxHighlight: 'prism',\n    remarkPlugins: [remarkPlugin1],\n    gfm: true,\n  },\n  integrations: [\n    mdx({\n      // `syntaxHighlight` inherited from Markdown\n\n\n      // Markdown `remarkPlugins` ignored,\n      // only `remarkPlugin2` applied.\n      remarkPlugins: [remarkPlugin2],\n      // `gfm` overridden to `false`\n      gfm: false,\n    })\n  ]\n});\n\nTo avoid extending your Markdown config from MDX, set the extendMarkdownConfig option (enabled by default) to false:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport mdx from '@astrojs/mdx';\n\n\nexport default defineConfig({\n  markdown: {\n    remarkPlugins: [remarkPlugin],\n  },\n  integrations: [\n    mdx({\n      // Markdown config now ignored\n      extendMarkdownConfig: false,\n      // No `remarkPlugins` applied\n    })\n  ]\n});\nSyntax Highlighting\nSection titled Syntax Highlighting\n\nAstro comes with built-in support for Shiki (via Shikiji) and Prism. This provides syntax highlighting for:\n\nall code fences (```) used in a Markdown or MDX file.\ncontent within the built-in <Code /> component (powered by Shiki).\ncontent within the <Prism /> component (powered by Prism).\n\nShiki is enabled by default, preconfigured with the github-dark theme. The compiled output will be limited to inline styles without any extraneous CSS classes, stylesheets, or client-side JS.\n\nShiki configuration\nSection titled Shiki configuration\n\nShiki is our default syntax highlighter. You can configure all options via the shikiConfig object like so:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  markdown: {\n    shikiConfig: {\n      // Choose from Shiki's built-in themes (or add your own)\n      // https://github.com/shikijs/shiki/blob/main/docs/themes.md\n      theme: 'dracula',\n      // Alternatively, provide multiple themes\n      // https://github.com/antfu/shikiji#lightdark-dual-themes\n      experimentalThemes: {\n        light: 'github-light',\n        dark: 'github-dark',\n      },\n      // Add custom languages\n      // Note: Shiki has countless langs built-in, including .astro!\n      // https://github.com/shikijs/shiki/blob/main/docs/languages.md\n      langs: [],\n      // Enable word wrap to prevent horizontal scrolling\n      wrap: true,\n    },\n  },\n});\nAdding your own theme\nSection titled Adding your own theme\n\nInstead of using one of Shiki‚Äôs predefined themes, you can import a custom theme from a local file.\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport customTheme from './my-shiki-theme.json';\n\n\nexport default defineConfig({\n  markdown: {\n    shikiConfig: { theme: customTheme },\n  },\n});\n\nWe also suggest reading Shiki‚Äôs own theme documentation to explore more about themes, light vs dark mode toggles, or styling via CSS variables.\n\nChange Default Syntax Highlighting Mode\nSection titled Change Default Syntax Highlighting Mode\n\nIf you‚Äôd like to switch to 'prism' by default, or disable syntax highlighting entirely, you can use the markdown.syntaxHighlighting config object:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  markdown: {\n    // Can be 'shiki' (default), 'prism' or false to disable highlighting\n    syntaxHighlight: 'prism',\n  },\n});\nPrism configuration\nSection titled Prism configuration\n\nIf you opt to use Prism, Astro will apply Prism‚Äôs CSS classes instead. Note that you need to bring your own CSS stylesheet for syntax highlighting to appear!\n\nChoose a premade stylesheet from the available Prism Themes.\nAdd this stylesheet to your project‚Äôs public/ directory.\nLoad this into your page‚Äôs <head> in a layout component via a <link> tag. (See Prism basic usage.)\n\nYou can also visit the list of languages supported by Prism for options and usage.\n\nFetching Remote Markdown\nSection titled Fetching Remote Markdown\n\nAstro was primarily designed for local Markdown files that could be saved inside of your project directory. However, there may be certain cases where you need to fetch Markdown from a remote source. For example, you may need to fetch and render Markdown from a remote API when you build your website (or when a user makes a request to your website, when using SSR).\n\nAstro does not include built-in support for remote Markdown! To fetch remote Markdown and render it to HTML, you will need to install and configure your own Markdown parser from npm. This will not inherit from any of Astro‚Äôs built-in Markdown and MDX settings that you have configured. Be sure that you understand these limitations before implementing this in your project.\n\nsrc/pages/remote-example.astro\n---\n// Example: Fetch Markdown from a remote API\n// and render it to HTML, at runtime.\n// Using \"marked\" (https://github.com/markedjs/marked)\nimport { marked } from 'marked';\nconst response = await fetch('https://raw.githubusercontent.com/wiki/adam-p/markdown-here/Markdown-Cheatsheet.md');\nconst markdown = await response.text();\nconst content = marked.parse(markdown);\n---\n<article set:html={content} />\nBack\nRouting\nNext Page\nScripts & Event Handling"
  },
  {
    "title": "Routing üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/routing/",
    "html": "Routing\n\nAstro uses file-based routing to generate your build URLs based on the file layout of your project src/pages/ directory.\n\nNavigating between pages\nSection titled Navigating between pages\n\nAstro uses standard HTML <a> elements to navigate between routes. There is no framework-specific <Link> component provided.\n\nsrc/pages/index.astro\n<p>Read more <a href=\"/about/\">about</a> Astro!</p>\nStatic routes\nSection titled Static routes\n\n.astro page components as well as Markdown and MDX Files (.md, .mdx) within the src/pages/ directory automatically become pages on your website. Each page‚Äôs route corresponds to its path and filename within the src/pages/ directory.\n\n# Example: Static routes\nsrc/pages/index.astro        -> mysite.com/\nsrc/pages/about.astro        -> mysite.com/about\nsrc/pages/about/index.astro  -> mysite.com/about\nsrc/pages/about/me.astro     -> mysite.com/about/me\nsrc/pages/posts/1.md         -> mysite.com/posts/1\n\n TIP\n\nThere is no separate ‚Äúrouting config‚Äù to maintain in an Astro project! When you add a file to the src/pages/ directory, a new route is automatically created for you. In static builds, you can customize the file output format using the build.format configuration option.\n\nDynamic routes\nSection titled Dynamic routes\n\nAn Astro page file can specify dynamic route parameters in its filename to generate multiple, matching pages. For example, src/pages/authors/[author].astro generates a bio page for every author on your blog. author becomes a parameter that you can access from inside the page.\n\nIn Astro‚Äôs default static output mode, these pages are generated at build time, and so you must predetermine the list of authors that get a corresponding file. In SSR mode, a page will be generated on request for any route that matches.\n\nStatic (SSG) Mode\nSection titled Static (SSG) Mode\n\nBecause all routes must be determined at build time, a dynamic route must export a getStaticPaths() that returns an array of objects with a params property. Each of these objects will generate a corresponding route.\n\n[dog].astro defines the dynamic dog parameter in its filename, so the objects returned by getStaticPaths() must include dog in their params. The page can then access this parameter using Astro.params.\n\nsrc/pages/dogs/[dog].astro\n---\nexport function getStaticPaths() {\n  return [\n    {params: {dog: 'clifford'}},\n    {params: {dog: 'rover'}},\n    {params: {dog: 'spot'}},\n  ];\n}\n\n\nconst { dog } = Astro.params;\n---\n<div>Good dog, {dog}!</div>\n\nThis will generate three pages: /dogs/clifford, /dogs/rover, and /dogs/spot, each displaying the corresponding dog name.\n\nThe filename can include multiple parameters, which must all be included in the params objects in getStaticPaths():\n\nsrc/pages/[lang]-[version]/info.astro\n---\nexport function getStaticPaths () {\n return [\n    {params: {lang: 'en', version: 'v1'}},\n    {params: {lang: 'fr', version: 'v2'}},\n  ];\n}\n\n\nconst { lang, version } = Astro.params;\n---\n...\n\nThis will generate /en-v1/info and /fr-v2/info.\n\nParameters can be included in separate parts of the path. For example, the file src/pages/[lang]/[version]/info.astro with the same getStaticPaths() above will generate the routes /en/v1/info and /fr/v2/info.\n\nüìö Learn more about getStaticPaths().\n\nRelated recipe:\nAdd i18n features\nRest parameters\nSection titled Rest parameters\n\nIf you need more flexibility in your URL routing, you can use a rest parameter ([...path]) in your .astro filename to match file paths of any depth:\n\nsrc/pages/sequences/[...path].astro\n---\nexport function getStaticPaths() {\n  return [\n    {params: {path: 'one/two/three'}},\n    {params: {path: 'four'}},\n    {params: {path: undefined }}\n  ]\n}\n\n\nconst { path } = Astro.params;\n---\n...\n\nThis will generate /sequences/one/two/three, /sequences/four, and /sequences. (Setting the rest parameter to undefined allows it to match the top level page.)\n\nRest parameters can be used with other named parameters. For example, GitHub‚Äôs file viewer can be represented with the following dynamic route:\n\n/[org]/[repo]/tree/[branch]/[...file]\n\nIn this example, a request for /withastro/astro/tree/main/docs/public/favicon.svg would be split into the following named parameters:\n\n{\n  org: 'withastro',\n  repo: 'astro',\n  branch: 'main',\n  file: 'docs/public/favicon.svg'\n}\nExample: Dynamic pages at multiple levels\nSection titled Example: Dynamic pages at multiple levels\n\nIn the following example, a rest parameter ([...slug]) and the props feature of getStaticPaths() generate pages for slugs of different depths.\n\nsrc/pages/[...slug].astro\n---\nexport async function getStaticPaths() {\n  const pages = [\n    {\n      slug: undefined,\n      title: \"Astro Store\",\n      text: \"Welcome to the Astro store!\",\n    },\n    {\n      slug: \"products\",\n      title: \"Astro products\",\n      text: \"We have lots of products for you\",\n    },\n    {\n      slug: \"products/astro-handbook\",\n      title: \"The ultimate Astro handbook\",\n      text: \"If you want to learn Astro, you must read this book.\",\n    },\n  ];\n  return pages.map(({ slug, title, text }) => {\n    return {\n      params: { slug },\n      props: { title, text },\n    };\n  });\n}\n\n\nconst { title, text } = Astro.props;\n---\n<html>\n  <head>\n    <title>{title}</title>\n  </head>\n  <body>\n    <h1>{title}</h1>\n    <p>{text}</p>\n  </body>\n</html>\nServer (SSR) Mode\nSection titled Server (SSR) Mode\n\nIn SSR mode, dynamic routes are defined the same way: include [param] or [...path] brackets in your file names to match arbitrary strings or paths. But because the routes are no longer built ahead of time, the page will be served to any matching route. Since these are not ‚Äústatic‚Äù routes, getStaticPaths should not be used.\n\nsrc/pages/resources/[resource]/[id].astro\n---\nconst { resource, id } = Astro.params;\n---\n<h1>{resource}: {id}</h1>\n\nThis page will be served for any value of resource and id: resources/users/1, resources/colors/blue, etc.\n\nModifying the [...slug] example for SSR\nSection titled Modifying the [...slug] example for SSR\n\nBecause SSR pages can‚Äôt use getStaticPaths(), they can‚Äôt receive props. The previous example can be adapted for SSR mode by looking up the value of the slug param in an object. If the route is at the root (‚Äù/‚Äù), the slug param will be undefined. If the value doesn‚Äôt exist in the object, we redirect to a 404 page.\n\nsrc/pages/[...slug].astro\n---\nconst pages = [\n  {\n    slug: undefined,\n    title: 'Astro Store',\n    text: 'Welcome to the Astro store!',\n  },\n  {\n    slug: 'products',\n    title: 'Astro products',\n    text: 'We have lots of products for you',\n  },\n  {\n    slug: 'products/astro-handbook',\n    title: 'The ultimate Astro handbook',\n    text: 'If you want to learn Astro, you must read this book.',\n  }\n];\n\n\nconst { slug } = Astro.params;\nconst page = pages.find((page) => page.slug === slug);\nif (!page) return Astro.redirect(\"/404\");\nconst { title, text } = page;\n---\n<html>\n<head>\n  <title>{title}</title>\n</head>\n<body>\n  <h1>{title}</h1>\n  <p>{text}</p>\n</body>\n</html>\nRedirects\nSection titled Redirects\n\nSometimes you will need to redirect your readers to a new page, either permanently because your site structure has changed or in response to an action such as logging in to an authenticated route.\n\nYou can define rules to redirect users to permanently-moved pages in your Astro config. Or, redirect users dynamically as they use your site.\n\nConfigured Redirects\nSection titled Configured Redirects\nAdded in: astro@2.9.0\n\nYou can specify a mapping of permanent redirects in your Astro config with the redirects value. For most redirects, this is a mapping of an old route to the new route:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  redirects: {\n    '/old-page': '/new-page'\n  }\n});\n\nThese redirects follow the same rules as file-based routes. Dynamic routes are allowed as long as both the new and old routes contain the same parameters, for example:\n\n{\n  \"/blog/[...slug]\": \"/articles/[...slug]\"\n}\n\nUsing SSR or a static adapter, you can also provide an object as the value, allowing you to specify the status code in addition to the new destination:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  redirects: {\n    '/old-page': {\n      status: 302,\n      destination: '/new-page'\n    }\n  }\n});\n\nWhen running astro build, Astro will output HTML files with the meta refresh tag by default. Supported adapters will instead write out the host‚Äôs configuration file with the redirects.\n\nThe status code is 301 by default. If building to HTML files the status code is not used by the server.\n\nDynamic redirects\nSection titled Dynamic redirects\n\nOn the Astro global, the Astro.redirect method allows you to redirect to another page dynamically. You might do this after checking if the user is logged in by getting their session from a cookie.\n\nsrc/pages/account.astro\n---\nimport { isLoggedIn } from '../utils';\n\n\nconst cookie = Astro.request.headers.get('cookie');\n\n\n// If the user is not logged in, redirect them to the login page\nif (!isLoggedIn(cookie)) {\n  return Astro.redirect('/login');\n}\n---\n<html>\n  <!-- Page here... -->\n</html>\nRoute Priority Order\nSection titled Route Priority Order\n\nIt‚Äôs possible for multiple routes to match the same URL path. For example each of these routes would match /posts/create:\n\nDirectory\nsrc/pages/\nDirectory\nposts/\ncreate.astro\n[pid].astro\n[‚Ä¶slug].astro\n\nAstro needs to know which route should be used to build the page. To do so, it sorts them according to the following rules:\n\nStatic routes without path parameters will take precedence over all other routes\nDynamic routes using named parameters take precedence over rest parameters\nPre-rendered dynamic routes take precedence over server dynamic routes\nRest parameters have the lowest priority\nEndpoints always take precedence over pages\nTies are resolved alphabetically\n\nGiven the example above, here are a few examples of how the rules will match a requested URL to the route used to build the HTML:\n\npages/posts/create.astro - Will build /posts/create\npages/posts/[pid].astro - Will build /posts/1, /posts/abc, etc. But not /posts/create\npages/posts/[...slug].astro - Will build /posts/1/2, /posts/a/b/c, etc. But not /posts/create, /posts/1, /posts/abc\n\nRedirects also follow the same rules, but are prioritized last; if there is a file-based route and a redirect with the same route priority level, the file-based route is chosen.\n\nPagination\nSection titled Pagination\n\nAstro supports built-in pagination for large collections of data that need to be split into multiple pages. Astro will generate common pagination properties, including previous/next page URLs, total number of pages, and more.\n\nPaginated route names should use the same [bracket] syntax as a standard dynamic route. For instance, the file name /astronauts/[page].astro will generate routes for /astronauts/1, /astronauts/2, etc, where [page] is the generated page number.\n\nYou can use the paginate() function to generate these pages for an array of values like so:\n\nsrc/pages/astronauts/[page].astro\n---\nexport async function getStaticPaths({ paginate }) {\n  const astronautPages = [{\n    astronaut: 'Neil Armstrong',\n  }, {\n    astronaut: 'Buzz Aldrin',\n  }, {\n    astronaut: 'Sally Ride',\n  }, {\n    astronaut: 'John Glenn',\n  }];\n  // Generate pages from our array of astronauts, with 2 to a page\n  return paginate(astronautPages, { pageSize: 2 });\n}\n// All paginated data is passed on the \"page\" prop\nconst { page } = Astro.props;\n---\n\n\n<!--Display the current page number. Astro.params.page can also be used!-->\n<h1>Page {page.currentPage}</h1>\n<ul>\n  <!--List the array of astronaut info-->\n  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}\n</ul>\n\nThis generates the following pages, with 2 items to a page:\n\n/astronauts/1 - Page 1: Displays ‚ÄúNeil Armstrong‚Äù and ‚ÄúBuzz Aldrin‚Äù\n/astronauts/2 - Page 2: Displays ‚ÄúSally Ride‚Äù and ‚ÄúJohn Glenn‚Äù\nThe page prop\nSection titled The page prop\n\nWhen you use the paginate() function, each page will be passed its data via a page prop. The page prop has many useful properties, but here are the highlights:\n\npage.data - array containing the page‚Äôs slice of data that you passed to the paginate() function\npage.url.next - link to the next page in the set\npage.url.prev - link to the previous page in the set\nsrc/pages/astronauts/[page].astro\n---\n// Paginate same list of { astronaut } objects as the previous example\nexport async function getStaticPaths({ paginate }) { /* ... */ }\nconst { page } = Astro.props;\n---\n<h1>Page {page.currentPage}</h1>\n<ul>\n  {page.data.map(({ astronaut }) => <li>{astronaut}</li>)}\n</ul>\n{page.url.prev ? <a href={page.url.prev}>Previous</a> : null}\n{page.url.next ? <a href={page.url.next}>Next</a> : null}\nComplete API reference\nSection titled Complete API reference\ninterface Page<T = any> {\n  /** result */\n  data: T[];\n  /** metadata */\n  /** the count of the first item on the page, starting from 0 */\n  start: number;\n  /** the count of the last item on the page, starting from 0 */\n  end: number;\n  /** total number of results */\n  total: number;\n  /** the current page number, starting from 1 */\n  currentPage: number;\n  /** number of items per page (default: 25) */\n  size: number;\n  /** number of last page */\n  lastPage: number;\n  url: {\n    /** url of the current page */\n    current: string;\n    /** url of the previous page (if there is one) */\n    prev: string | undefined;\n    /** url of the next page (if there is one) */\n    next: string | undefined;\n  };\n}\nNested Pagination\nSection titled Nested Pagination\n\nA more advanced use-case for pagination is nested pagination. This is when pagination is combined with other dynamic route params. You can use nested pagination to group your paginated collection by some property or tag.\n\nFor example, if you want to group your paginated Markdown posts by some tag, you would use nested pagination by creating a /src/pages/[tag]/[page].astro page that would match the following URLS:\n\n/red/1 (tag=red)\n/red/2 (tag=red)\n/blue/1 (tag=blue)\n/green/1 (tag=green)\n\nNested pagination works by returning an array of paginate() results from getStaticPaths(), one for each grouping.\n\nIn the following example, we will implement nested pagination to build the URLs listed above:\n\nsrc/pages/[tag]/[page].astro\n---\nexport async function getStaticPaths({ paginate }) {\n  const allTags = ['red', 'blue', 'green'];\n  const allPosts = await Astro.glob('../../posts/*.md');\n  // For every tag, return a paginate() result.\n  // Make sure that you pass `{params: {tag}}` to `paginate()`\n  // so that Astro knows which tag grouping the result is for.\n  return allTags.flatMap((tag) => {\n    const filteredPosts = allPosts.filter((post) => post.frontmatter.tag === tag);\n    return paginate(filteredPosts, {\n      params: { tag },\n      pageSize: 10\n    });\n  });\n}\nconst { page } = Astro.props;\nconst params = Astro.params;\nExcluding pages\nSection titled Excluding pages\n\nYou can exclude pages or directories from being built by prefixing their names with an underscore (_). Files with the _ prefix won‚Äôt be recognized by the router and won‚Äôt be placed into the dist/ directory.\n\nYou can use this to temporarily disable pages, and also to put tests, utilities, and components in the same folder as their related pages.\n\nIn this example, only src/pages/index.astro and src/pages/posts/post1.md will be built as page routes and HTML files.\n\nDirectory\nsrc/pages/\nDirectory\n_hidden-directory/\npage1.md\npage2.md\n_hidden-page.astro\nindex.astro\nDirectory\nposts/\n_SomeComponent.astro\n_utils.js\npost1.md\nBack\nMore recipes\nNext Page\nMarkdown"
  },
  {
    "title": "More Recipes üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/recipes/",
    "html": "More Recipes\n\nSee guided examples of adding features to your Astro project.\n\nOfficial Recipes\nSection titled Official Recipes\nShare State Between Islands\n\nLearn how to share state across framework components with Nano Stores.\n\nAdd an RSS feed\n\nAdd an RSS feed to your Astro site to let users subscribe to your content.\n\nInstalling a Vite or Rollup plugin\n\nLearn how you can import YAML data by adding a Rollup plugin to your project.\n\nBuild a custom image component\n\nLearn how to build a custom image component that supports media queries using the getImage function\n\nBuild Forms With API Routes\n\nLearn how to use JavaScript to send form submissions to an API Route\n\nBuild HTML Forms in Astro Pages\n\nLearn how to build HTML forms and handle submissions in your frontmatter\n\nUse Bun with Astro\n\nLearn how to use Bun with your Astro site.\n\nCall endpoints from the server\n\nLearn how to call endpoints from the server in Astro.\n\nVerify a Captcha\n\nLearn how to create an API route and fetch it from the client.\n\nBuild your Astro Site with Docker\n\nLearn how to build your Astro site using Docker.\n\nDynamically Import Images\n\nLearn how to dynamically import images using Vite's import.meta.glob function\n\nAdd icons to external links\n\nLearn how to install a rehype plugin to add icons to external links in your Markdown files\n\nAdd i18n features\n\nUse dynamic routing and content collections to add internationalization support to your Astro site.\n\nAdd Last Modified Time\n\nBuild a remark plugin to add the last modified time to your Markdown and MDX.\n\nAdd Reading Time\n\nBuild a remark plugin to add reading time to your Markdown or MDX files.\n\nShare State Between Astro Components\n\nLearn how to share state across Astro components with Nano Stores.\n\nUsing streaming to improve page performance\n\nLearn how to use streaming to improve page performance.\n\nStyle Rendered Markdown with Tailwind Typography\n\nLearn how to use @tailwind/typography to style your rendered Markdown\n\nCommunity Resources\nSection titled Community Resources\n\nAdd your own here! See our recipes contributing guide for more info.\n\nUse a dynamic filename when importing images\nAdd animated page transitions with Swup\nUse UnoCSS in Astro\nBuild a table of contents from Astro‚Äôs Markdown headings\nCreate a Remark plugin to remove runts from your Markdown files\nAdd searching to your site with Pagefind\nAdd searching to your site with Fuse.js\nGet VSCode, ESLint & Prettier working with Astro\nEnhance your Astro builds: modify HTML files post-build\nAdd dark mode to Astro with Tailwind CSS\nGenerate localized sitemaps for your Astro and Storyblok project\nIntegrate Prettier with Astro and Tailwind CSS\nAdd an RSS feed to Astro using Storyblok‚Äôs stories\nUsing tRPC in Astro\nHow to make your Astro website multilingual with Crowdin: Astro localization guide\nAdd blog post images to your Astro RSS Feed\nSetting up micro-frontends with Astro\nAdd username and password authentication with Lucia\nAdd Github OAuth with Lucia\nIntegrating Sentry with Astro\nSet Up Draft Pages Effectively in Astro with Config-Driven Content Authoring\nHow to Send Any Data to Your RSS Feed? A Guide with Astro + RSS\nBack\nDeploy your site\nNext Page\nRouting"
  },
  {
    "title": "Deploy your Astro Site üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/deploy/",
    "html": "Deploy your Astro Site\n\nReady to build and deploy your Astro site? Follow one of our guides to different deployment services or scroll down for general guidance about deploying an Astro site.\n\nDeployment Guides\nFilter by deploy type \nSSR \nStatic\nNetlify\nSSR\nSTATIC\nVercel\nSSR\nSTATIC\nDeno Deploy\nSSR\nGitHub Pages\nSTATIC\nGitLab Pages\nSTATIC\nCloudflare Pages\nSSR\nSTATIC\nAWS\nSTATIC\nAWS via Flightcontrol\nSSR\nSTATIC\nAWS via SST\nSSR\nSTATIC\nGoogle Cloud\nSSR\nSTATIC\nFirebase Hosting\nSTATIC\nHeroku\nSTATIC\nMicrosoft Azure\nSTATIC\nBuddy\nSTATIC\nEdgio\nSSR\nSTATIC\nRender\nSTATIC\nSurge\nSTATIC\nCleavr\nSSR\nSTATIC\nKinsta\nSSR\nSTATIC\nDeta Space\nSSR\nSTATIC\nQuick Deploy Options\nSection titled Quick Deploy Options\n\nYou can build and deploy an Astro site to a number of hosts quickly using either their website‚Äôs dashboard UI or a CLI.\n\nWebsite UI\nSection titled Website UI\n\nA quick way to deploy your website is to connect your Astro project‚Äôs online Git repository (e.g. GitHub, GitLab, Bitbucket) to a host provider and take advantage of continuous deployment using Git.\n\nThese host platforms automatically detect pushes to your Astro project‚Äôs source repository, build your site and deploy it to the web at a custom URL or your personal domain. Often, setting up a deployment on these platforms will follow steps something like the following:\n\nAdd your repository to an online Git provider (e.g. in GitHub, GitLab, Bitbucket)\n\nChoose a host that supports continuous deployment (e.g. Netlify or Vercel) and import your Git repository as a new site/project.\n\nMany common hosts will recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy your site as shown below. (If not, these settings can be changed.)\n\n DEPLOY SETTINGS\n\nBuild Command: astro build or npm run build\nPublish directory: dist\n\nClick ‚ÄúDeploy‚Äù and your new website will be created at a unique URL for that host (e.g. new-astro-site.netlify.app).\n\nThe host will be automatically configured to watch your Git provider‚Äôs main branch for changes, and to rebuild and republish your site at each new commit. These settings can typically be configured in your host provider‚Äôs dashboard UI.\n\nCLI Deployment\nSection titled CLI Deployment\n\nSome hosts will have their own command line interface (CLI) you can install globally to your machine using npm. Often, using a CLI to deploy looks something like the following:\n\nInstall your host‚Äôs CLI globally, for example:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install --global netlify-cli\n\nRun the CLI and follow any instructions for authorization, setup etc.\n\nBuild your site and deploy to your host\n\nMany common hosts will build and deploy your site for you. They will usually recognize your project as an Astro site, and should choose the appropriate configuration settings to build and deploy as shown below. (If not, these settings can be changed.)\n\n DEPLOY SETTINGS\n\nBuild Command: astro build or npm run build\nPublish directory: dist\n\nOther hosts will require you to build your site locally and deploy using the command line.\n\nBuilding Your Site Locally\nSection titled Building Your Site Locally\n\nMany hosts like Netlify and Vercel will build your site for you and then publish that build output to the web. But, some sites will require you to build locally and then run a deploy command or upload your build output.\n\nYou may also wish to build locally to preview your site, or to catch any potential errors and warnings in your own environment.\n\nRun the command npm run build to build your Astro site.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm run build\n\nBy default, the build output will be placed at dist/. This location can be changed using the outDir configuration option.\n\nAdding an Adapter for SSR\nSection titled Adding an Adapter for SSR\n\n NOTE\n\nBefore deploying your Astro site with SSR (server-side rendering) enabled, make sure you have:\n\nInstalled the appropriate adapter to your project dependencies (either manually, or using the adapter‚Äôs astro add command, e.g. npx astro add netlify).\nAdded the adapter to your astro.config.mjs file‚Äôs import and default export when installing manually. (The astro add command will take care of this step for you!)\nBack\nAdd backend services\nNext Page\nMore recipes"
  },
  {
    "title": "Use a backend service with Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/backend/",
    "html": "Use a backend service with Astro\n\nReady to add features like authentication, storage or data to your Astro project? Follow one of our guides to integrate a backend service.\n\nBackend service guides\nSection titled Backend service guides\nFirebase\nSupabase\nXata\nAppwrite\nTigris\n\nNote that many of these pages are stubs: they‚Äôre collections of resources waiting for your contribution!\n\nWhat is a backend service?\nSection titled What is a backend service?\n\nA backend service is a cloud-based system that helps you build and manage your backend infrastructure. It provides a set of tools and services for managing databases, user authentication, and other server-side functionality. This enables you to focus on building your applications without having to worry about managing the underlying infrastructure.\n\nWhy would I use a backend service?\nSection titled Why would I use a backend service?\n\nYou might want to consider a backend service if your project has complex server-side needs, for example:\n\nuser sign-ups and authentication\npersistent data storage\nuser-uploaded asset storage\nAPI generation\nrealtime communication\nBack\nConnect a CMS\nNext Page\nDeploy your site"
  },
  {
    "title": "Use a CMS with Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/cms/",
    "html": "Use a CMS with Astro\n\nReady to connect a Headless CMS to your Astro project? Follow one of our guides to integrate a CMS.\n\nCMS Guides\nSection titled CMS Guides\nStoryblok\nContentful\nButterCMS\nBuilder.io\nCosmic\nDatoCMS\nFront Matter CMS\nGhost\nHygraph\nKeystatic\nKontent.ai\nStatamic\nStrapi\nTina CMS\nWordPress\nCaisy\nCloudCannon\nCrystallize\nDecap CMS\nDirectus\nKeystoneJS\nmicroCMS\nPayload CMS\nPrepr CMS\nPrismic\nSanity\nSpinal\n\nNote that many of these pages are stubs: they‚Äôre collections of resources waiting for your contribution!\n\nWhy use a CMS?\nSection titled Why use a CMS?\n\nA Content Management System lets you write content and manage assets outside of your Astro project.\n\nThis unlocks new features for working with content. Most CMSes give you a visual content editor, the ability to specify standard types of content, and a way to collaborate with others.\n\nA CMS can be useful for content that follows a particular structure, often giving you a dashboard-like experience and WYSIWYG editing tools. You might use a CMS to write blog posts using a CMS‚Äôs rich text editor instead of Markdown files. Or you might use a CMS to maintain product listings for an eCommerce shop, making certain fields required to avoid incomplete listings.\n\nYour Astro project can then fetch your content from your CMS and display it, wherever and however you want on your site.\n\nWhich CMSes work well with Astro?\nSection titled Which CMSes work well with Astro?\n\nBecause Astro takes care of the presentation of your content, you‚Äôll want to choose a headless CMS, like those in the list above. This means that the CMS helps you write your content, but doesn‚Äôt generate a site that displays it. Instead, you fetch the content data and use in your Astro project.\n\nSome headless CMSes, like Storyblok, provide an Astro integration that helps fetch the content specifically for an Astro site. Others provide a JavaScript SDK, a library that you install and use to fetch your remote content.\n\nCan I use Astro without a CMS?\nSection titled Can I use Astro without a CMS?\n\nYes! Astro provides built-in ways to author content, including support for Markdown pages.\n\nBack\nMigrate to Astro\nNext Page\nAdd backend services"
  },
  {
    "title": "Migrate an existing project to Astro üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/migrate-to-astro/",
    "html": "Migrate an existing project to Astro\n\nReady to convert your site to Astro? See one of our guides for migration tips.\n\nMigration Guides\nSection titled Migration Guides\nGatsby\nNext.js\nNuxtJS\nCreate React App\nDocusaurus\nEleventy\nGitBook\nGridsome\nHugo\nJekyll\nPelican\nSvelteKit\nVuePress\nWordPress\n\nNote that many of these pages are stubs: they‚Äôre collections of resources waiting for your contribution!\n\nWhy migrate your site to Astro?\nSection titled Why migrate your site to Astro?\n\nAstro provides many benefits: performance, simplicity, and many of the features you want built right into the framework. When you do need to extend your site, Astro provides several official and 3rd-party community integrations.\n\nMigrating may be less work than you think!\n\nDepending on your existing project, you may be able to use your existing:\n\nUI framework components directly in Astro.\n\nCSS stylesheets or libraries including Tailwind.\n\nMarkdown/MDX files, configured using your existing remark and rehype plugins.\n\nContent from a CMS through an integration or API.\n\nWhich projects can I convert to Astro?\nSection titled Which projects can I convert to Astro?\n\nMany existing sites can be built with Astro. Astro is ideally suited for your existing content-based sites like blogs, landing pages, marketing sites and portfolios. Astro integrates with several popular headless CMSs, and allows you to connect eCommerce shop carts.\n\nAstro allows you to choose between a statically-generated site and server-side rendering (SSR), making it a great replacement for SSGs or for sites that need to fetch some page data on the fly.\n\nHow will my project design change?\nSection titled How will my project design change?\n\nDepending on your existing project, you may need to think differently about:\n\nDesigning in Astro Islands to avoid sending unnecessary JavaScript to the browser.\n\nProviding client-side interactivity with client-side <script> tags or UI framework components.\n\nManaging shared state with Nano Stores or local storage instead of app-wide hooks or wrappers.\n\nBack\nSSR Adapters\nNext Page\nConnect a CMS"
  },
  {
    "title": "On-demand Rendering Adapters üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/server-side-rendering/",
    "html": "On‚Å†-‚Å†demand Rendering Adapters\n\nAstro allows you to choose on-demand rendering for some, or all of your pages and endpoints. This is also known as server-side rendering (SSR): generating HTML pages on the server when requested and sending them to the client. An adapter is used to run your project on the server and handle these requests.\n\nThis on-demand rendering allows you to:\n\nImplement sessions for login state in your app.\nRender data from an API called dynamically with fetch().\nDeploy your site to a host using an adapter.\n\nConsider enabling on-demand server rendering in your Astro project if you need the following:\n\nAPI endpoints: Create specific pages that function as API endpoints for tasks like database access, authentication, and authorization while keeping sensitive data hidden from the client.\n\nProtected pages: Restrict access to a page based on user privileges, by handling user access on the server.\n\nFrequently changing content: Generate individual pages without requiring a static rebuild of your site. This is useful when the content of a page updates frequently.\n\nEnable on-demand server rendering\nSection titled Enable on-demand server rendering\n\nBoth of Astro‚Äôs on-demand rendering output modes (server and hybrid) allow you to take advantage of static site performance by pre-rendering individual routes whenever possible, whether you have an entirely dynamic app or a mostly static site that needs on-demand rendering only for select routes.\n\nTo decide which one to use in your project, choose the output option that represents how most of your pages and routes will be rendered:\n\noutput: 'server': On-demand rendered by default. Use this when most or all of your site or app should be server-rendered on request. Any individual page or endpoint can opt-in to pre-rendering.\noutput: 'hybrid': Pre-rendered to HTML by default. Use this when most of your site should be static. Any individual page or endpoint can opt-out of pre-rendering.\n\nBecause the server will need to generate at least some pages on demand, both of these modes require you to add an adapter to carry out the server functions.\n\nConfigure server or hybrid\nSection titled Configure server or hybrid\n\nTo enable on-demand rendering, first update your output configuration to one of the two server-rendered modes.\n\nFor example, to configure a highly dynamic app where every page is rendered on demand by default, add output: 'server' to your Astro config:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport node from \"@astrojs/node\";\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: node({\n    mode: \"standalone\"\n  })\n});\n\nYou can then choose to override the default on-demand rendering of server mode on any page or route by exporting const prerender = true:\n\nsrc/pages/my-static-page.astro\n---\nexport const prerender = true;\n// ...\n---\n<html>\n  <!-- Static, pre-rendered page here... -->\n</html>\nOpting-in to pre-rendering in server mode\nSection titled Opting-in to pre-rendering in server mode\n\nFor a mostly server-rendered app configured as output: server, add export const prerender = true to any page or route to pre-render a static page or endpoint:\n\nsrc/pages/mypage.astro\n---\nexport const prerender = true;\n// ...\n---\n<html>\n  <!-- Static, pre-rendered page here... -->\n</html>\nsrc/pages/mypage.mdx\n---\nlayout: '../layouts/markdown.astro'\ntitle: 'My page'\n---\nexport const prerender = true;\n\n\n# This is my static, pre-rendered page\nsrc/pages/myendpoint.js\nexport const prerender = true;\n\n\nexport async function GET() {\n  return new Response(\n    JSON.stringify({\n      message: `This is my static endpoint`,\n    }),\n  );\n}\nOpting out of pre-rendering in hybrid mode\nSection titled Opting out of pre-rendering in hybrid mode\n\nFor a mostly static site configured as output: hybrid, add export const prerender = false to any files that should be server-rendered on demand:\n\nsrc/pages/randomnumber.js\nexport const prerender = false;\n\n\nexport async function GET() {\n  let number = Math.random();\n  return new Response(\n    JSON.stringify({\n      number,\n      message: `Here's a random number: ${number}`,\n    }),\n  );\n}\nAdd an Adapter\nSection titled Add an Adapter\n\nTo deploy a project in server or hybrid mode, you also need to add an adapter. This is because both of these modes require a server runtime: the environment that runs code on the server to generate pages when they are requested. Each adapter allows Astro to output a script that runs your project on a specific runtime, such as Vercel, Netlify or Cloudflare.\n\nYou can find both official and community adapters in our integrations directory. Choose the one that corresponds to your deployment environment.\n\nastro add install\nSection titled astro add install\n\nYou can add any of the official adapters maintained by Astro with the following astro add command. This will install the adapter and make the appropriate changes to your astro.config.mjs file in one step.\n\nFor example, to install the Vercel adapter, run:\n\nnpm\npnpm\nYarn\nTerminal window\nnpx astro add vercel\nManual Install\nSection titled Manual Install\n\nYou can also add an adapter manually by installing the package and updating astro.config.mjs yourself.\n\nFor example, to install the Vercel adapter manually:\n\nInstall the adapter to your project dependencies using your preferred package manager:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install @astrojs/vercel\n\nAdd the adapter to your astro.config.mjs file‚Äôs import and default export, along with your desired output mode:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport vercel from '@astrojs/vercel/serverless';\n\n\nexport default defineConfig({\n  output: 'server',\n  adapter: vercel(),\n});\n\nNote that different adapters may also have different configuration settings. Read each adapter‚Äôs documentation, and apply any necessary config options to your chosen adapter in astro.config.mjs\n\nOn-demand rendering features\nSection titled On-demand rendering features\nHTML streaming\nSection titled HTML streaming\n\nWith HTML streaming, a document is broken up into chunks, sent over the network in order, and rendered on the page in that order. In server or hybrid mode, Astro uses HTML streaming to send each component to the browser as it renders them. This makes sure the user sees your HTML as fast as possible, although network conditions can cause large documents to be downloaded slowly, and waiting for data fetches can block page rendering.\n\nRelated recipe:\nUsing streaming to improve page performance\n\n CAUTION\n\nFeatures that modify the Response headers are only available at the page level. (You can‚Äôt use them inside of components, including layout components.) By the time Astro runs your component code, it has already sent the Response headers and they cannot be modified.\n\nCookies\nSection titled Cookies\n\nIn server and hybrid modes, a page or API endpoint can check, set, get, and delete cookies.\n\nThe example below updates the value of a cookie for a page view counter:\n\nsrc/pages/index.astro\n---\nlet counter = 0\n\n\nif (Astro.cookies.has(\"counter\")) {\n  const cookie = Astro.cookies.get(\"counter\")\n  counter = cookie.number() + 1\n}\n\n\nAstro.cookies.set(\"counter\",counter)\n---\n<html>\n  <h1>Counter = {counter}</h1>\n</html>\n\nSee more details about Astro.cookies and the AstroCookie type in the API reference.\n\nResponse\nSection titled Response\n\nYou can also return a Response from any page using on-demand rendering.\n\nThe example below returns a 404 on a dynamic page after looking up an id in the database:\n\nsrc/pages/[id].astro\n---\nimport { getProduct } from '../api';\n\n\nconst product = await getProduct(Astro.params.id);\n\n\n// No product found\nif (!product) {\n  return new Response(null, {\n    status: 404,\n    statusText: 'Not found'\n  });\n}\n---\n<html>\n  <!-- Page here... -->\n</html>\nRequest\nSection titled Request\n\nAstro.request is a standard Request object. It can be used to get the url, headers, method, and even body of the request.\n\nIn both server and hybrid mode, you can access additional information from this object for pages that are not statically-generated.\n\nAstro.request.headers\nSection titled Astro.request.headers\n\nThe headers for the request are available on Astro.request.headers. This works like the browser‚Äôs Request.headers. It is a Headers object where you can retrieve headers such as the cookie.\n\nsrc/pages/index.astro\n---\nconst cookie = Astro.request.headers.get('cookie');\n// ...\n---\n<html>\n  <!-- Page here... -->\n</html>\nAstro.request.method\nSection titled Astro.request.method\n\nThe HTTP method used in the request is available as Astro.request.method. This works like the browser‚Äôs Request.method. It returns the string representation of the HTTP method used in the request.\n\nsrc/pages/index.astro\n---\nconsole.log(Astro.request.method) // GET (when navigated to in the browser)\n---\n\nSee more details about Astro.request in the API reference.\n\nServer Endpoints\nSection titled Server Endpoints\n\nA server endpoint, also known as an API route, is a special function exported from a .js or .ts file within the src/pages/ folder. A powerful feature of server-side rendering on demand, API routes are able to securely execute code on the server.\n\nThe function takes an endpoint context and returns a Response.\n\nTo learn more, see our Endpoints Guide.\n\nBack\nUI Frameworks\nNext Page\nMigrate to Astro"
  },
  {
    "title": "Framework Components üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/framework-components/",
    "html": "Framework Components\n\nBuild your Astro website without sacrificing your favorite component framework.\n\nAstro supports a variety of popular frameworks including React, Preact, Svelte, Vue, SolidJS, AlpineJS and Lit.\n\nInstalling Integrations\nSection titled Installing Integrations\n\nAstro ships with optional integrations for React, Preact, Svelte, Vue, SolidJS, AlpineJS and Lit. One or several of these Astro integrations can be installed and configured in your project.\n\n‚öôÔ∏è View the Integrations Guide for more details on installing and configuring Astro integrations.\n\n‚öôÔ∏è Want to see an example for the framework of your choice? Visit astro.new and select one of the framework templates.\n\nUsing Framework Components\nSection titled Using Framework Components\n\nUse your JavaScript framework components in your Astro pages, layouts and components just like Astro components! All your components can live together in /src/components, or can be organized in any way you like.\n\nTo use a framework component, import it from its relative path in your Astro component script. Then, use the component alongside other components, HTML elements and JSX-like expressions in the component template.\n\nsrc/pages/static-components.astro\n---\nimport MyReactComponent from '../components/MyReactComponent.jsx';\n---\n<html>\n  <body>\n    <h1>Use React components directly in Astro!</h1>\n    <MyReactComponent />\n  </body>\n</html>\n\nBy default, your framework components will only render on the server, as static HTML. This is useful for templating components that are not interactive and avoids sending any unnecessary JavaScript to the client.\n\nHydrating Interactive Components\nSection titled Hydrating Interactive Components\n\nA framework component can be made interactive (hydrated) using a client:* directive. These are component attributes that determine when your component‚Äôs JavaScript should be sent to the browser.\n\nWith all client directives except client:only, your component will first render on the server to generate static HTML. Component JavaScript will be sent to the browser according to the directive you chose. The component will then hydrate and become interactive.\n\nsrc/pages/interactive-components.astro\n---\n// Example: hydrating framework components in the browser.\nimport InteractiveButton from '../components/InteractiveButton.jsx';\nimport InteractiveCounter from '../components/InteractiveCounter.jsx';\nimport InteractiveModal from \"../components/InteractiveModal.svelte\"\n---\n<!-- This component's JS will begin importing when the page loads -->\n<InteractiveButton client:load />\n\n\n<!-- This component's JS will not be sent to the client until\nthe user scrolls down and the component is visible on the page -->\n<InteractiveCounter client:visible />\n\n\n<!-- This component won't render on the server, but will render on the client when the page loads -->\n<InteractiveModal client:only=\"svelte\" />\n\nThe JavaScript framework (React, Svelte, etc) needed to render the component will be sent to the browser along with the component‚Äôs own JavaScript. If two or more components on a page use the same framework, the framework will only be sent once.\n\n ACCESSIBILITY\n\nMost framework-specific accessibility patterns should work the same when these components are used in Astro. Be sure to choose a client directive that will ensure any accessibility-related JavaScript is properly loaded and executed at the appropriate time!\n\nAvailable Hydration Directives\nSection titled Available Hydration Directives\n\nThere are several hydration directives available for UI framework components: client:load, client:idle, client:visible, client:media={QUERY} and client:only={FRAMEWORK}.\n\nüìö See our directives reference page for a full description of these hydration directives, and their usage.\n\nMixing Frameworks\nSection titled Mixing Frameworks\n\nYou can import and render components from multiple frameworks in the same Astro component.\n\nsrc/pages/mixing-frameworks.astro\n---\n// Example: Mixing multiple framework components on the same page.\nimport MyReactComponent from '../components/MyReactComponent.jsx';\nimport MySvelteComponent from '../components/MySvelteComponent.svelte';\nimport MyVueComponent from '../components/MyVueComponent.vue';\n---\n<div>\n  <MySvelteComponent />\n  <MyReactComponent />\n  <MyVueComponent />\n</div>\n\n CAUTION\n\nOnly Astro components (.astro) can contain components from multiple frameworks.\n\nPassing Props to Framework Components\nSection titled Passing Props to Framework Components\n\nYou can pass props from Astro components to framework components:\n\nsrc/pages/frameworks-props.astro\n---\nimport TodoList from '../components/TodoList.jsx';\nimport Counter from '../components/Counter.svelte';\n---\n<div>\n  <TodoList initialTodos={[\"learn Astro\", \"review PRs\"]} />\n  <Counter startingCount={1} />\n</div>\n\n PASSING FUNCTIONS AS PROPS\n\nYou can pass a function as a prop to a framework component, but it only works during server rendering. If you try to use the function in a hydrated component (for example, as an event handler), an error will occur.\n\nThis is because functions can‚Äôt be serialized (transferred from the server to the client) by Astro.\n\nPassing Children to Framework Components\nSection titled Passing Children to Framework Components\n\nInside of an Astro component, you can pass children to framework components. Each framework has its own patterns for how to reference these children: React, Preact, and Solid all use a special prop named children, while Svelte and Vue use the <slot /> element.\n\nsrc/pages/component-children.astro\n---\nimport MyReactSidebar from '../components/MyReactSidebar.jsx';\n---\n<MyReactSidebar>\n  <p>Here is a sidebar with some text and a button.</p>\n</MyReactSidebar>\n\nAdditionally, you can use Named Slots to group specific children together.\n\nFor React, Preact, and Solid these slots will be converted to a top-level prop. Slot names using kebab-case will be converted to camelCase.\n\nsrc/pages/named-slots.astro\n---\nimport MySidebar from '../components/MySidebar.jsx';\n---\n<MySidebar>\n  <h2 slot=\"title\">Menu</h2>\n  <p>Here is a sidebar with some text and a button.</p>\n  <ul slot=\"social-links\">\n    <li><a href=\"https://twitter.com/astrodotbuild\">Twitter</a></li>\n    <li><a href=\"https://github.com/withastro\">GitHub</a></li>\n  </ul>\n</MySidebar>\nsrc/components/MySidebar.jsx\nexport default function MySidebar(props) {\n  return (\n    <aside>\n      <header>{props.title}</header>\n      <main>{props.children}</main>\n      <footer>{props.socialLinks}</footer>\n    </aside>\n  )\n}\n\nFor Svelte and Vue these slots can be referenced using a <slot> element with the name attribute. Slot names using kebab-case will be preserved.\n\nsrc/components/MySidebar.svelte\n<aside>\n  <header><slot name=\"title\" /></header>\n  <main><slot /></main>\n  <footer><slot name=\"social-links\" /></footer>\n</aside>\nNesting Framework Components\nSection titled Nesting Framework Components\n\nInside of an Astro file, framework component children can also be hydrated components. This means that you can recursively nest components from any of these frameworks.\n\nsrc/pages/nested-components.astro\n---\nimport MyReactSidebar from '../components/MyReactSidebar.jsx';\nimport MyReactButton from '../components/MyReactButton.jsx';\nimport MySvelteButton from '../components/MySvelteButton.svelte';\n---\n\n\n<MyReactSidebar>\n  <p>Here is a sidebar with some text and a button.</p>\n  <div slot=\"actions\">\n    <MyReactButton client:idle />\n    <MySvelteButton client:idle />\n  </div>\n</MyReactSidebar>\n\n CAUTION\n\nRemember: framework component files themselves (e.g. .jsx, .svelte) cannot mix multiple frameworks.\n\nThis allows you to build entire ‚Äúapps‚Äù in your preferred JavaScript framework and render them, via a parent component, to an Astro page.\n\n NOTE\n\nAstro components are always rendered to static HTML, even when they include framework components that are hydrated. This means that you can only pass props that don‚Äôt do any HTML rendering. Passing React‚Äôs ‚Äúrender props‚Äù to framework components from an Astro component will not work, because Astro components can‚Äôt provide the client runtime behavior that this pattern requires. Instead, use named slots.\n\nCan I use Astro Components inside my Framework Components?\nSection titled Can I use Astro Components inside my Framework Components?\n\nAny UI framework component becomes an ‚Äúisland‚Äù of that framework. These components must be written entirely as valid code for that framework, using only its own imports and packages. You cannot import .astro components in a UI framework component (e.g. .jsx or .svelte).\n\nYou can, however, use the Astro <slot /> pattern to pass static content generated by Astro components as children to your framework components inside an .astro component.\n\nsrc/pages/astro-children.astro\n---\nimport MyReactComponent from  '../components/MyReactComponent.jsx';\nimport MyAstroComponent from '../components/MyAstroComponent.astro';\n---\n<MyReactComponent>\n  <MyAstroComponent slot=\"name\" />\n</MyReactComponent>\nCan I Hydrate Astro Components?\nSection titled Can I Hydrate Astro Components?\n\nIf you try to hydrate an Astro component with a client: modifier, you will get an error.\n\nAstro components are HTML-only templating components with no client-side runtime. But, you can use a <script> tag in your Astro component template to send JavaScript to the browser that executes in the global scope.\n\nüìö Learn more about client-side <script> tags in Astro components\n\nBack\nAdd integrations\nNext Page\nSSR Adapters"
  },
  {
    "title": "Add Integrations üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/integrations-guide/",
    "html": "Add Integrations\n\nAstro integrations add new functionality and behaviors for your project with only a few lines of code. You can write a custom integration yourself, use an official integration, or use integrations built by the community.\n\nIntegrations can‚Ä¶\n\nUnlock React, Vue, Svelte, Solid, and other popular UI frameworks.\nIntegrate tools like Tailwind, and Partytown with a few lines of code.\nAdd new features to your project, like automatic sitemap generation.\nWrite custom code that hooks into the build process, dev server, and more.\nOfficial Integrations\nSection titled Official Integrations\nUI Frameworks\n@astrojs/alpinejs\n@astrojs/lit\n@astrojs/preact\n@astrojs/react\n@astrojs/solid‚Å†-‚Å†js\n@astrojs/svelte\n@astrojs/vue\nSSR Adapters\n@astrojs/cloudflare\n@astrojs/netlify\n@astrojs/node\n@astrojs/vercel\nOthers\n@astrojs/markdoc\n@astrojs/mdx\n@astrojs/partytown\n@astrojs/prefetch\n@astrojs/sitemap\n@astrojs/tailwind\nAutomatic Integration Setup\nSection titled Automatic Integration Setup\n\nAstro includes an astro add command to automate the setup of integrations.\n\nRun the astro add command using the package manager of your choice and our automatic integration wizard will update your configuration file and install any necessary dependencies.\n\nnpm\npnpm\nYarn\nTerminal window\nnpx astro add react\n\nIt‚Äôs even possible to add multiple integrations at the same time!\n\nnpm\npnpm\nYarn\nTerminal window\nnpx astro add react tailwind partytown\n\n HANDLING INTEGRATION DEPENDENCIES\n\nIf you see any warnings like Cannot find package '[package-name]' after adding an integration, your package manager may not have installed peer dependencies for you. To install these missing packages, run npm install [package-name].\n\nUsing Integrations\nSection titled Using Integrations\n\nAstro integrations are always added through the integrations property in your astro.config.mjs file.\n\nThere are three common ways to import an integration into your Astro project:\n\nInstalling an npm package integration.\n\nImport your own integration from a local file¬†inside your project.\n\nWrite your integration inline, directly in your config file.\n\nastro.config.mjs\nimport {defineConfig} from 'astro/config';\nimport installedIntegration from '@astrojs/vue';\nimport localIntegration from './my-integration.js';\n\n\nexport default defineConfig({\n  integrations: [\n    // 1. Imported from an installed npm package\n    installedIntegration(),\n    // 2. Imported from a local JS file\n    localIntegration(),\n    // 3. An inline object\n    {name: 'namespace:id', hooks: { /* ... */ }},\n  ]\n})\n\nCheck out the Integration API reference to learn all of the different ways that you can write an integration.\n\nCustom Options\nSection titled Custom Options\n\nIntegrations are almost always authored as factory functions that return the actual integration object. This lets you pass arguments and options to the factory function that customize the integration for your project.\n\nintegrations: [\n  // Example: Customize your integration with function arguments\n  sitemap({filter: true})\n]\nToggle an Integration\nSection titled Toggle an Integration\n\nFalsy integrations are ignored, so you can toggle integrations on & off without worrying about left-behind undefined and boolean values.\n\nintegrations: [\n  // Example: Skip building a sitemap on Windows\n  process.platform !== 'win32' && sitemap()\n]\nRemoving an Integration\nSection titled Removing an Integration\n\nTo remove an integration, first uninstall the integration from your project\n\nnpm\npnpm\nYarn\nTerminal window\nnpm uninstall @astrojs/react\n\nNext, remove the integration from your astro.config.* file:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config'\n\n\nimport react from \"@astrojs/react\";\n\n\nexport default defineConfig({\n  integrations: [\n    react()\n  ]\n})\nFinding More Integrations\nSection titled Finding More Integrations\n\nYou can find many integrations developed by the community in the Astro Integrations Directory. Follow links there for detailed usage and configuration instructions.\n\nBuilding Your Own Integration\nSection titled Building Your Own Integration\n\nAstro‚Äôs Integration API is inspired by Rollup and Vite, and designed to feel familiar to anyone who has ever written a Rollup or Vite plugin before.\n\nCheck out the Integration API reference to learn what integrations can do and how to write one yourself.\n\nBack\nPrefetch\nNext Page\nUI Frameworks"
  },
  {
    "title": "Prefetch üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/prefetch/",
    "html": "Prefetch\n\nPage load times play a big role in the usability and overall enjoyment of a site. Astro‚Äôs opt-in prefetching brings the benefits of near-instant page navigations to your multi-page application (MPA) as your visitors interact with the site.\n\nEnable prefetching\nSection titled Enable prefetching\n\nYou can enable prefetching with the prefetch config:\n\nastro.config.js\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  prefetch: true\n})\n\nA prefetch script will be added to all pages of your site. You can then add the data-astro-prefetch attribute to any <a /> links on your site to opt-in to prefetching. When you hover over the link, the script will fetch the page in the background.\n\n<a href=\"/about\" data-astro-prefetch>\n\nNote that prefetching only works for links within your site, and not external links.\n\nPrefetch configuration\nSection titled Prefetch configuration\n\nThe prefetch config also accepts an option object to further customize prefetching.\n\nPrefetch strategies\nSection titled Prefetch strategies\n\nAstro supports 3 prefetch strategies for various use cases:\n\nhover (default): Prefetch when you hover over or focus on the link.\ntap: Prefetch just before you click on the link.\nviewport: Prefetch as the links enter the viewport.\n\nYou can specify a strategy for an individual link by passing it to the data-astro-prefetch attribute:\n\n<a href=\"/about\" data-astro-prefetch=\"tap\">About</a>\n\nEach strategy is fine-tuned to only prefetch when needed and save your users‚Äô bandwidth. For example:\n\nIf a visitor is using data saver mode or has a slow connection, prefetch will fallback to the tap strategy.\nQuickly hovering or scrolling over links will not prefetch them.\nLinks that use the viewport strategy are prefetched with a lower priority to avoid clogging up the network.\nDefault prefetch strategy\nSection titled Default prefetch strategy\n\nThe default prefetch strategy when adding the data-astro-prefetch attribute is hover. To change it, you can configure prefetch.defaultStrategy in your astro.config.js file:\n\nastro.config.js\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  prefetch: {\n    defaultStrategy: 'viewport'\n  }\n})\nPrefetch all links by default\nSection titled Prefetch all links by default\n\nIf you want to prefetch all links, including those without the data-astro-prefetch attribute, you can set prefetch.prefetchAll to true:\n\nastro.config.js\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  prefetch: {\n    prefetchAll: true\n  }\n})\n\nYou can then opt-out of prefetching for individual links by setting data-astro-prefetch=\"false\":\n\n<a href=\"/about\" data-astro-prefetch=\"false\">About</a>\n\nThe default prefetch strategy for all links can be changed with prefetch.defaultStrategy as shown in the Default prefetch strategy section.\n\nPrefetch programmatically\nSection titled Prefetch programmatically\n\nAs some navigation might not always appear as <a /> links, you can also prefetch programmatically with the prefetch() API from the astro:prefetch module:\n\n<button id=\"btn\">Click me</button>\n\n\n<script>\n  import { prefetch } from 'astro:prefetch';\n\n\n  const btn = document.getElementById('btn');\n  btn.addEventListener('click', () => {\n    prefetch('/about');\n  });\n</script>\n\nYou can additionally configure the priority of prefetching by passing the with option:\n\n// Prefetch with `fetch()`, which has a higher priority.\nprefetch('/about', { with: 'fetch' });\n\n\n// Prefetch with `<link rel=\"prefetch\">`, which has a lower priority\n// and manually scheduled by the browser. (default)\nprefetch('/about', { with: 'link' });\n\nThe prefetch() API includes the same data saver mode and slow connection detection so that it only prefetches when needed.\n\nTo ignore slow connection detection, you can use the ignoreSlowConnection option:\n\n// Prefetch even on data saver mode or slow connection\nprefetch('/about', { ignoreSlowConnection: true });\n\nMake sure to only import prefetch() in client-side scripts as it relies on browser APIs.\n\nUsing with View Transitions\nSection titled Using with View Transitions\n\nWhen you use View Transitions on a page, prefetching will also be enabled by default. It sets a default configuration of { prefetchAll: true } which enables prefetching for all links on the page.\n\nYou can customize the prefetch configuration in astro.config.js to override the default. For example:\n\nastro.config.js\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  // Disable prefetch completely\n  prefetch: false\n})\nastro.config.js\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  // Keep prefetch, but only prefetch for links with `data-astro-prefetch`\n  prefetch: {\n    prefetchAll: false\n  }\n})\nMigrating from @astrojs/prefetch\nSection titled Migrating from @astrojs/prefetch\n\nThe @astrojs/prefetch integration was deprecated in v3.5.0 and will eventually be removed entirely. Use the following instructions to migrate to Astro‚Äôs built-in prefetching which replaces this integration.\n\nRemove the @astrojs/prefetch integration and enable the prefetch config in astro.config.js:\n\nastro.config.js\nimport { defineConfig } from 'astro/config';\nimport prefetch from '@astrojs/prefetch';\n\n\nexport default defineConfig({\n  integrations: [prefetch()],\n  prefetch: true\n})\n\nConvert from @astrojs/prefetch‚Äôs configuration options:\n\nThe deprecated integration used the selector config option to specify which links should be prefetched upon entering the viewport.\n\nAdd data-astro-prefetch=\"viewport\" to these individual links instead.\n\n<a href=\"/about\" data-astro-prefetch=\"viewport\">\n\nThe deprecated integration used the intentSelector config option to specify which links should be prefetched when they were hovered over or focused.\n\nAdd data-astro-prefetch or data-astro-prefetch=\"hover\" to these individual links instead:\n\n<!-- You can omit the value if `defaultStrategy` is set to `hover` (default) -->\n<a href=\"/about\" data-astro-prefetch>\n\n\n<!-- Otherwise, you can explicitly define the prefetch strategy -->\n<a href=\"/about\" data-astro-prefetch=\"hover\">\n\nThe throttles option from @astrojs/prefetch is no longer needed as the new prefetch feature will automatically schedule and prefetch optimally.\n\nBack\nView Transitions\nNext Page\nAdd integrations"
  },
  {
    "title": "View Transitions üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/view-transitions/",
    "html": "View Transitions\n\nAstro supports opt-in, per-page, view transitions with just a few lines of code. View transitions update your page content without the browser‚Äôs normal, full-page navigation refresh and provide seamless animations between pages.\n\nAstro provides a <ViewTransitions /> routing component that can be added to a single page‚Äôs <head> to control page transitions as you navigate away to another page. It provides a lightweight client-side router that intercepts navigation and allows you to customize the transition between pages.\n\nAdd this component to a reusable .astro component, such as a common head or layout, for animated page transitions across your entire site (SPA mode).\n\nAstro‚Äôs view transitions support is powered by the new View Transitions browser API and also includes:\n\nA few built-in animation options, such as fade, slide, and none.\nSupport for both forwards and backwards navigation animations.\nThe ability to fully customize all aspects of transition animation, and build your own animations.\nThe option to prevent client-side navigation for non-page links.\nControl over fallback behavior for browsers that do not yet support the View Transition APIs.\nAutomatic support for prefers-reduced-motion.\n\n NOTE\n\nBy default, every page will use regular, full-page, browser navigation. You must opt in to view transitions and can use them either on a per-page basis or site-wide.\n\nAdding View Transitions to a Page\nSection titled Adding View Transitions to a Page\n\nOpt in to using view transitions on individual pages by importing and adding the <ViewTransitions /> routing component to <head> on every desired page.\n\nsrc/pages/index.astro\n---\nimport { ViewTransitions } from 'astro:transitions';\n---\n<html lang=\"en\">\n  <head>\n    <title>My Homepage</title>\n    <ViewTransitions />\n  </head>\n  <body>\n    <h1>Welcome to my website!</h1>\n  </body>\n</html>\nFull site view transitions (SPA mode)\nSection titled Full site view transitions (SPA mode)\n\nImport and add the <ViewTransitions /> component to your common <head> or shared layout component. Astro will create default page animations based on the similarities between the old and new page, and will also provide fallback behavior for unsupported browsers.\n\nThe example below shows adding Astro‚Äôs default page navigation animations site-wide, including the default fallback control option for non-supporting browsers, by importing and adding this component to a <CommonHead /> Astro component:\n\ncomponents/CommonHead.astro\n---\nimport { ViewTransitions } from 'astro:transitions';\n---\n<link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n<meta name=\"generator\" content={Astro.generator} />\n\n\n<!-- Primary Meta Tags -->\n<title>{title}</title>\n<meta name=\"title\" content={title} />\n<meta name=\"description\" content={description} />\n\n\n<ViewTransitions />\n\nNo other configuration is necessary to enable Astro‚Äôs default client-side navigation!\n\nUse transition directives or override default client-side navigation on individual elements for finer control.\n\nTransition Directives\nSection titled Transition Directives\n\nAstro will automatically assign corresponding elements found in both the old page and the new page a shared, unique view-transition-name. This pair of matching elements is inferred by both the type of element and its location in the DOM.\n\nUse optional transition:* directives on page elements in your .astro components for finer control over the page transition behaviour during navigation.\n\ntransition:name: Allows you to override Astro‚Äôs default element matching for old/new content animation and specify a transition name to associate a pair of DOM elements.\ntransition:animate: Allows you to override Astro‚Äôs default animation while replacing the old element with the new one by specifying an animation type. Use Astro‚Äôs built-in animation directives or create custom transition animations.\ntransition:persist: Allows you to override Astro‚Äôs default replacing old elements for new ones and instead persist components and HTML elements when navigating to another page.\nNaming a transition\nSection titled Naming a transition\n\nIn some cases, you may want or need to identify the corresponding view transition elements yourself. You can specify a name for a pair of elements using the transition:name directive.\n\nold-page.astro\n<aside transition:name=\"hero\">\nnew-page.astro\n<aside transition:name=\"hero\">\n\nNote that the provided transition:name value can only be used once on each page. Set this manually when Astro can‚Äôt infer a proper name itself, or for more fine control over matching elements.\n\nMaintaining State\nSection titled Maintaining State\nAdded in: astro@2.10.0\n\nYou can persist components and HTML elements (instead of replacing them) across page navigations using the transition:persist directive.\n\nFor example, the following <video> will continue to play as you navigate to another page that contains the same video element. This works for both forwards and backwards navigation.\n\ncomponents/Video.astro\n<video controls=\"\" autoplay=\"\" transition:persist>\n  <source src=\"https://ia804502.us.archive.org/33/items/GoldenGa1939_3/GoldenGa1939_3_512kb.mp4\" type=\"video/mp4\">\n</video>\n\nYou can also place the directive on an Astro island (a UI framework component with a client: directive). If that component exists on the next page, the island from the old page with its current state will continue to be displayed, instead of replacing it with the island from the new page.\n\nIn the example below, the count will not be reset when navigating back and forth across pages that contain the <Counter /> component with the transition:persist attribute.\n\ncomponents/Header.astro\n<Counter client:load transition:persist count={5} />\n\nYou can also manually identify corresponding elements if the island/element is in a different component between the two pages.\n\npages/old-page.astro\n<Video controls=\"\" autoplay=\"\" transition:name=\"media-player\" transition:persist />\npages/new-page.astro\n<MyVideo controls=\"\" autoplay=\"\" transition:name=\"media-player\" transition:persist />\n\nAs a convenient shorthand, transition:persist can alternatively take a transition name as a value.\n\npages/index.astro\n<video controls=\"\" autoplay=\"\" transition:persist=\"media-player\">\nBuilt-in Animation Directives\nSection titled Built-in Animation Directives\n\nAstro comes with a few built-in animations to override the default fade transition. Add the transition:animate directive to individual elements to customize the behavior of specific transitions.\n\nfade (default): An opinionated crossfade animation. The old content fades out and the new content fades in.\ninitial: Opt out of Astro‚Äôs opinionated crossfade animation and use the browser‚Äôs default styling.\nslide: An animation where the old content slides out to the left and new content slides in from the right. On backwards navigation, the animations are the opposite.\nnone: Disable the browser‚Äôs default animations. Use on a page‚Äôs <html> element to disable the default fade for every element on the page.\n\nCombine directives for full control over your page animation. Set a page default on the <html> element, and override on any individual elements as desired.\n\nThe example below produces a slide animation for the body content while disabling the browser‚Äôs default fade animation for the rest of the page:\n\n---\nimport { CommonHead } from '../components/CommonHead.astro';\n---\n\n\n<html transition:animate=\"none\">\n  <head>\n    <CommonHead />\n  </head>\n  <body>\n    <header>\n      ...\n    </header>\n    <!-- Override your page default on a single element -->\n    <main transition:animate=\"slide\">\n      ...\n    </main>\n  </body>\n</html>\nCustomizing Animations\nSection titled Customizing Animations\n\nYou can customize all aspects of a transition with any CSS animation properties.\n\nTo customize a built-in animation, first import the animation from astro:transitions, and then pass in customization options.\n\nThe example below customizes the duration of the built-in fade animation:\n\n---\nimport { fade } from 'astro:transitions';\n---\n\n\n<header transition:animate={fade({ duration: '0.4s' })}>\n\nYou can also define your own animations for use with transition:animate by defining both the forwards and backwards behavior, as well as new and old pages, according to the following types:\n\nexport interface TransitionAnimation {\n  name: string; // The name of the keyframe\n  delay?: number | string;\n  duration?: number | string;\n  easing?: string;\n  fillMode?: string;\n  direction?: string;\n}\n\n\nexport interface TransitionAnimationPair {\n  old: TransitionAnimation | TransitionAnimation[];\n  new: TransitionAnimation | TransitionAnimation[];\n}\n\n\nexport interface TransitionDirectionalAnimations {\n  forwards: TransitionAnimationPair;\n  backwards: TransitionAnimationPair;\n}\n\nThe following example shows all the necessary properties to define a custom fade animation:\n\n---\nconst anim = {\n  old: {\n    name: 'fadeIn',\n    duration: '0.2s',\n    easing: 'linear',\n    fillMode: 'forwards',\n  },\n  new: {\n    name: 'fadeOut',\n    duration: '0.3s',\n    easing: 'linear',\n    fillMode: 'backwards',\n  }\n};\n\n\nconst myFade = {\n  forwards: anim,\n  backwards: anim,\n};\n---\n\n\n<header transition:animate={myFade}> ... </header>\nRouter control\nSection titled Router control\n\nThe <ViewTransitions /> router handles navigation by listening to:\n\nClicks on <a> elements.\nBackwards and forwards navigation events.\n\nThe following options allow you to further control when navigation occurs within the router:\n\nastro-data-reload: an <a> tag attribute to force a full-page navigation\nastro-data-history=\"auto | push | replace\": an <a> tag attribute to control the browser‚Äôs history\nnavigate(href, options): a method available to any client script or client component to trigger navigation\nPreventing client-side navigation\nSection titled Preventing client-side navigation\n\nThere are some cases where you cannot navigate via client-side routing since both pages involved must use the <ViewTransitions /> router to prevent a full-page reload. You may also not want client-side routing on every navigation change and would prefer a traditional page navigation on select routes instead.\n\nYou can opt out of client-side routing on a per-link basis by adding the data-astro-reload attribute to any <a> or <form> tag. This attribute will override any existing <ViewTransitions /> component and instead trigger a browser refresh during navigation.\n\nThe following example shows preventing client-side routing when navigating to an article from the home page only. This still allows you to have animation on shared elements, such as a hero image, when navigating to the same page from an article listing page:\n\nsrc/pages/index.astro\n<a href=\"/articles/emperor-penguins\" data-astro-reload>\nsrc/pages/articles.astro\n<a href=\"/articles/emperor-penguins\">\n\nLinks with the data-astro-reload attribute will be ignored by the router and a full-page navigation will occur.\n\nTrigger navigation\nSection titled Trigger navigation\n\nYou can also trigger client-side navigation via events not normally listened to by the <ViewTransitions /> router using navigate. This function from the astro:transitions/client module can be used in scripts, and in framework components that are hydrated with a client directive.\n\nThe following example shows an Astro component that navigates a visitor to another page they select from a menu:\n\nsrc/components/form.astro\n<script>\n    import { navigate } from 'astro:transitions/client';\n\n\n    // Navigate to the selected option automatically.\n    document.querySelector('select').onchange = (ev) => {\n        let href = ev.target.value;\n        navigate(href);\n    };\n</script>\n<select>\n    <option value=\"/play\">Play</option>\n    <option value=\"/blog\">Blog</option>\n    <option value=\"/about\">About</option>\n    <option value=\"/contact\">Contact</option>\n</select>\nsrc/pages/index.astro\n---\nimport Form from \"../components/form.astro\"\nimport { ViewTransitions } from \"astro:transitions\";\n---\n<html>\n  <head>\n    <ViewTransitions />\n  </head>\n  <body>\n    <Form />\n  </body>\n</html>\n\nThe following example implements the same using navigate() in a React <Form /> component:\n\nsrc/components/form.jsx\nimport React from 'react';\nimport { navigate } from 'astro:transitions/client';\n\n\nexport default function ClickToNavigate({ to }) {\n  return <select onChange={(ev) => navigate(e.target.value)}>\n    <option value=\"/play\">Play</option>\n    <option value=\"/blog\">Blog</option>\n    <option value=\"/about\">About</option>\n    <option value=\"/contact\">Contact</option>\n  </select>;\n}\n\nThe <Form /> component can then be rendered on an Astro page that uses the <ViewTransitions /> router, with a client directive:\n\nsrc/pages/index.astro\n---\nimport Form from \"../components/form.jsx\"\nimport { ViewTransitions } from \"astro:transitions\";\n---\n<html>\n  <head>\n    <ViewTransitions />\n  </head>\n  <body>\n    <Form client:load />\n  </body>\n</html>\n\nThe navigate method takes these arguments:\n\nhref (required) - The new page to navigate to.\noptions - An optional object with the following properties:\nhistory: 'push' | 'replace' | 'auto'\n'push': the router will use history.pushState to create a new entry in the browser history.\n'replace': the router will use history.replaceState to update the URL without adding a new entry into navigation.\n'auto' (default): the router will attempt history.pushState, but if the URL is not one that can be transitioned to, the current URL will remain with no changes to the browser history.\nformData: A FormData object for POST requests.\n\nFor backward and forward navigation through the browser history, you can combine navigate() with the built-in history.back(), history.forward() and history.go() functions of the browser. If navigate() is called during the server-side render of your component, it has no effect.\n\nReplace entries in the browser history\nSection titled Replace entries in the browser history\n\nNormally, each time you navigate, a new entry is written to the browser‚Äôs history. This allows navigation between pages using the browser‚Äôs back and forward buttons.\n\nThe <ViewTransitions /> router allows you to overwrite history entries by adding the data-astro-history attribute to any individual <a> tag.\n\nThe data-astro-history attribute can be set to the same three values as the history option of the navigate() function:\n\ndata-astro-history: 'push' | 'replace' | 'auto'\n\n'push': the router will use history.pushState to create a new entry in the browser history.\n'replace': the router will use history.replaceState to update the URL without adding a new entry into navigation.\n'auto' (default): the router will attempt history.pushState, but if the URL is not one that can be transitioned to, the current URL will remain with no changes to the browser history.\n\nThe following example navigates to the /main page but does not add a new entry to the browsing history. Instead, it reuses the current entry in the history (/confirmation) and overwrites it.\n\n/confirmation.astro\n<a href=\"/main\" data-astro-history=\"replace\">\n\nThis has the effect that if you go back from the /main page, the browser will not display the /confirmation page, but the page before it.\n\nTransitions with forms\nSection titled Transitions with forms\nAdded in: astro@3.5.0\n\nBy default, the <ViewTransitions /> router only transitions on navigation triggered by <a> clicks. You can also allow transitions on form submissions by adding the handleForms option on the router.\n\nsrc/pages/index.astro\n---\nimport { ViewTransitions } from \"astro:transitions\";\n---\n<html>\n  <head>\n    <ViewTransitions handleForms />\n  </head>\n  <body>\n    <!-- stuff here -->\n  </body>\n</html>\n\nWith this option the router will trigger in-page transitions from <form> elements, supporting both GET and POST requests. You can opt out of router transitions on any individual form using the data-astro-reload attribute:\n\nsrc/components/Form.astro\n<form action=\"/contact\" data-astro-reload>\n  <!-- -->\n</form>\nFallback control\nSection titled Fallback control\n\nThe <ViewTransitions /> router works best in browsers that support View Transitions (i.e. Chromium browsers), but also includes default fallback support for other browsers. Even if the browser does not support the View Transitions API, Astro will still provide in-browser navigation using one of the fallback options for a comparable experience.\n\nYou can override Astro‚Äôs default fallback support by adding a fallback property on the <ViewTransitions /> component and setting it to swap or none:\n\nanimate (default, recommended) - Astro will simulate view transitions using custom attributes before updating page content.\nswap - Astro will not attempt to animate the page. Instead, the old page will be immediately replaced by the new one.\nnone - Astro will not do any animated page transitions at all. Instead, you will get full page navigation in non-supporting browsers.\n---\nimport { ViewTransitions } from 'astro:transitions';\n---\n<title>My site</title>\n\n\n<ViewTransitions fallback=\"swap\">\n\n KNOWN LIMITATIONS\n\nThe initial browser animation is not simulated by Astro. So any element using this animation will not currently be animated.\n\nClient-side navigation process\nSection titled Client-side navigation process\n\nWhen using the <ViewTransitions /> router, the following steps occur to produce Astro‚Äôs client-side navigation:\n\nA visitor to your site triggers navigation by any of the following actions:\n\nClicking an <a> tag linking internally to another page on your site.\nClicking the back button.\nClicking the forward button.\n\nThe router starts fetching the next page.\n\nThe router adds the data-astro-transition attribute to the HTML element with a value of 'forward' or 'back' as appropriate.\n\nThe router calls document.startViewTransition. This triggers the browser‚Äôs own view transition process. Importantly, the browser screenshots the current state of the page.\n\nInside the startViewTransition callback, the router performs a swap, which consists of the following sequence of events:\n\nThe contents of the <head> are swapped out, with some elements kept:\n\nStylesheet DOM nodes are left in if they exist on the new page, to prevent FOUC.\nScripts are left in if they exist on the new page.\nAny other head elements with transition:persist are left in if there is a corresponding element in the new page.\n\nThe <body> is completely replaced with the new page‚Äôs body.\n\nElements marked transition:persist are moved over to the new DOM if they exist on the new page.\n\nScroll position is restored if necessary.\n\nThe astro:after-swap event is triggered on the document. This is the end of the swap process.\n\nThe router waits for any new stylesheets to load before resolving the transition.\n\nThe router executes any new scripts added to the page.\n\nThe astro:page-load event fires. This is the end of the navigation process.\n\nScript behavior during page navigation\nSection titled Script behavior during page navigation\n\nWhen navigating between pages with the <ViewTransitions /> component, scripts are run in sequential order to match browser behavior.\n\nIf you have code that sets up global state, this state will need to take into account that the script might execute more than once. Check for the global state in your <script> tag, and conditionally execute your code where possible:\n\n<script is:inline>\n  if(!window.SomeGlobal) {\n    window.SomeGlobal = {} // ....\n  }\n</script>\n\nModule scripts are only ever executed once because the browser keeps track of which modules are already loaded. For these scripts, you do not need to worry about re-execution.\n\nLifecycle events\nSection titled Lifecycle events\n\nThe <ViewTransition /> router fires a number events on the document during navigation. These events provide hooks into the lifecycle of navigation, allowing you to do things like show indicators that a new page is loading, override default behavior, and restore state as navigation is completing.\n\nThe navigation process involves a preparation phase, when new content is loaded; a DOM swap phase, where the old page‚Äôs content is replaced by the new page‚Äôs content; and a completion phase where scripts are executed, loading is reported as completed and clean-up work is carried out.\n\nAstro‚Äôs View Transition API lifecycle events in order are:\n\nastro:before-preparation\nastro:after-preparation\nastro:before-swap\nastro:after-swap\nastro:page-load\n\n TIP\n\nbefore- events allow you to influence and modify actions that are about to take place, and after- events are notifications that a phase is complete.\n\nWhile some actions can be triggered during any event, some tasks can only be performed during a specific event for best results, such as displaying a loading spinner before preparation or overriding animation pairs before swapping content.\n\nastro:before-preparation\nSection titled astro:before-preparation\nAdded in: astro@3.6.0 NEW\n\nAn event that fires at the beginning of the preparation phase, after navigation has started (e.g. after the user has clicked a link), but before content is loaded.\n\nThis event is used:\n\nTo do something before loading has started, such as showing a loading spinner.\nTo alter loading, such as loading content you‚Äôve defined in a template rather than from the external URL.\nTo change the direction of the navigation (which is usually either forward or backward) for custom animation.\n\nHere is an example of using the astro:before-preparation event to load a spinner before the content is loaded and stop it immediately after loading. Note that using the loader callback in this way allows asynchronous execution of code.\n\n<script is:inline>\n  document.addEventListener('astro:before-preparation', ev => {\n    const originalLoader = ev.loader;\n    ev.loader = async function() {\n      const { startSpinner } = await import('./spinner.js');\n      const stop = startSpinner();\n      await originalLoader();\n      stop();\n    };\n  });\n</script>\nastro:after-preparation\nSection titled astro:after-preparation\nAdded in: astro@3.6.0 NEW\n\nAn event that fires at the end of the preparation phase, after the new page‚Äôs content has been loaded and parsed into a document. This event occurs before the view transitions phase.\n\nThis example uses the astro:before-preparation event to start a loading indicator and the astro:after-preparation event to stop it:\n\n<script is:inline>\n  document.addEventListener('astro:before-preparation', () => {\n    document.querySelector('#loading').classList.add('show');\n  });\n  document.addEventListener('astro:after-preparation', () => {\n    document.querySelector('#loading').classList.remove('show');\n  });\n</script>\n\nThis is a simpler version of loading a spinner than the example shown above: if all of the listener‚Äôs code can be executed synchronously, there is no need to hook into the loader‚Äôs callback.\n\nastro:before-swap\nSection titled astro:before-swap\nAdded in: astro@3.6.0 NEW\n\nAn event that fires before the new document (which is populated during the preparation phase) replaces the current document. This event occurs inside of the view transition, where the user is still seeing a snapshot of the old page.\n\nThis event can be used to make changes before the swap occurs. The newDocument property on the event represents the incoming document. Here is an example of ensuring the browser‚Äôs light or dark mode preference in localStorage is carried over to the new page:\n\n<script is:inline>\n  function setDarkMode(document) {\n    let theme = localStorage.darkMode ? 'dark' : 'light';\n    document.documentElement.dataset.theme = theme;\n  }\n\n\n  setDarkMode(document);\n\n\n  document.addEventListener('astro:before-swap', ev => {\n    // Pass the incoming document to set the theme on it\n    setDarkMode(ev.newDocument);\n  });\n</script>\n\nThe astro:before-swap event can also be used to change the implementation of the swap. The default swap implementation diffs head content, moves persistent elements from the old document to the newDocument, and then replaces the entire body with the body of the new document.\n\nAt this point of the lifecycle, you could choose to define your own swap implementation, for example to diff the entire contents of the existing document (which some other routers do):\n\n<script is:inline>\n  document.addEventListener('astro:before-swap', ev => {\n    ev.swap = () => {\n      diff(document, ev.newDocument);\n    };\n  });\n</script>\nastro:after-swap\nSection titled astro:after-swap\n\nAn event that fires immediately after the new page replaces the old page. You can listen to this event on the document and trigger actions that will occur before the new page‚Äôs DOM elements render and scripts run.\n\nThis event, when listened to on the outgoing page, is useful to pass along and restore any state on the DOM that needs to transfer over to the new page.\n\nThis is the latest point in the lifecycle where it is still safe to, for example, add a dark mode class name (<html class=\"dark-mode\">), though you may wish to do so in an earlier event.\n\nThe astro:after-swap event occurs immediately after the browser history has been updated and the scroll position has been set. Therefore, one use of targeting this event is to override the default scroll restore for history navigation. The following example resets the horizontal and vertical scroll position to the top left corner of the page for each navigation.\n\ndocument.addEventListener('astro:after-swap',\n  () => window.scrollTo({ left: 0, top: 0, behavior: 'instant' }))\nastro:page-load\nSection titled astro:page-load\n\nAn event that fires at the end of page navigation, after the new page is visible to the user and blocking styles and scripts are loaded. You can listen to this event on the document.\n\nThe <ViewTransitions /> component fires this event both on initial page navigation for a pre-rendered page and on any subsequent navigation, either forwards or backwards.\n\nYou can use this event to run code on every page navigation, or only once ever:\n\n<script>\n  document.addEventListener('astro:page-load', () => {\n    // This only runs once.\n    setupStuff();\n  }, { once: true });\n</script>\nAccessibility\nSection titled Accessibility\n\nEnabling client-side routing and animating page transitions both come with accessibility challenges, and Astro aims to make sites opting in to View Transitions as accessible-by-default as possible.\n\nRoute announcement\nSection titled Route announcement\nAdded in: astro@3.2.0\n\nThe <ViewTransitions /> component includes a route announcer for page navigation during client-side routing. No configuration or action is needed to enable this.\n\nAssistive technologies let visitors know that the page has changed by announcing the new page title after navigation. When using server-side routing with traditional full-page browser refreshes, this happens by default after the new page loads. In client-side routing, the <ViewTransitions /> component performs this action.\n\nTo add route announcement to client-side routing, the component adds an element to the new page with the aria-live attribute set to assertive. This tells AT (assistive technology) to announce immediately. The component also checks for the following, in priority order, to determine the announcement text:\n\nThe <title>, if it exists.\nThe first <h1> it finds.\nThe pathname of the page.\n\nWe strongly recommend you always include a <title> in each page for accessibility.\n\nprefers-reduced-motion\nSection titled prefers-reduced-motion\n\nAstro‚Äôs <ViewTransitions /> component includes a CSS media query that disables all view transition animations, including fallback animation, whenever the prefer-reduced-motion setting is detected. Instead, the browser will simply swap the DOM elements without an animation.\n\nUpgrade to v3.0 from v2.x\nSection titled Upgrade to v3.0 from v2.x\n\nView transitions are no longer behind an experimental flag in Astro v3.0.\n\nIf you had not enabled this experimental flag in Astro 2.x, this will not cause any breaking changes to your project. The new View Transitions API has no effect on your existing code.\n\nIf you were previously using experimental view transitions, there may be some breaking changes when you upgrade your Astro project from an earlier version.\n\nPlease follow the instructions below as appropriate to upgrade an Astro v2.x project configured with experimental.viewTransitions: true to v3.0.\n\nUpgrade from experimental.viewTransitions\nSection titled Upgrade from experimental.viewTransitions\n\nIf you had previously enabled the experimental flag for view transitions, you will need to update your project for Astro v3.0 which now allows view transitions by default.\n\nRemove experimental.viewTransitions flag\nSection titled Remove experimental.viewTransitions flag\n\nRemove the experimental flag:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  experimental: {\n   viewTransitions: true\n  }\n});\nUpdate import source\nSection titled Update import source\n\nThe <ViewTransitions /> component has been moved from astro:components to astro:transitions. Update the import source across all occurrences in your project.\n\nsrc/layouts/BaseLayout.astro\n---\nimport { ViewTransitions } from \"astro:components astro:transitions\"\n---\n<html lang=\"en\">\n  <head>\n    <title>My Homepage</title>\n    <ViewTransitions />\n  </head>\n  <body>\n    <h1>Welcome to my website!</h1>\n  </body>\n</html>\nUpdate transition:animate directives\nSection titled Update transition:animate directives\n\nChanged: The transition:animate value morph has been renamed to initial. Also, this is no longer the default animation. If no transition:animate directive is specified, your animations will now default to fade.\n\nRename any morph animations to initial.\n\nsrc/components/MyComponent.astro\n<div transition:name=\"name\" transition:animate=\"morph initial\" />\n\nTo keep any animations that were previously using morph by default, explicitly add transition:animate=\"initial\"\n\nsrc/components/MyComponent.astro\n<div transition:name=\"name\" transition:animate=\"initial\" />\n\nYou can safely remove any animations explicitly set to fade. This is now the default behavior:\n\nsrc/components/MyComponent.astro\n<div transition:name=\"name\" transition:animate=\"fade\" />\n\nAdded: Astro also supports a new transition:animate value, none. This value can be used on a page‚Äôs <html> element to disable animated full-page transitions on an entire page. This will only override default animation behavior on page elements without an animation directive. You can still set animations on individual elements, and these specific animations will occur.\n\nYou may now disable all default transitions on an individual page, animating only elements that explicitly use a transition:animate directive:\n\n<html transition:animate=\"none\">\n  <head></head>\n  <body>\n    <h1>Hello world!</h1>\n  </body>\n</html>\nUpdate event names\nSection titled Update event names\n\nThe event astro:load has been renamed to astro:page-load. Rename all occurrences in your project.\n\nsrc/components/MyComponent.astro\n<script>\ndocument.addEventListener('astro:load astro:page-load', runSetupLogic);\n</script>\n\nThe event astro:beforeload has been renamed to astro:after-swap. Rename all occurrences in your project.\n\nsrc/components/MyComponent.astro\n<script>\ndocument.addEventListener('astro:beforeload astro:after-swap', setDarkMode);\n</script>\nBack\nContent Collections\nNext Page\nPrefetch"
  },
  {
    "title": "Content Collections üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/content-collections/",
    "html": "Content Collections\n\nAdded in: astro@2.0.0\n\nContent collections are the best way to manage and author content in any Astro project. Collections help to organize your documents, validate your frontmatter, and provide automatic TypeScript type-safety for all of your content.\n\nWhat are Content Collections?\nSection titled What are Content Collections?\n\nA content collection is any top-level directory inside the reserved src/content project directory, such as src/content/newsletter and src/content/authors. Only content collections are allowed inside the src/content directory. This directory cannot be used for anything else.\n\nA collection entry is any piece of content stored inside of your content collection directory. Entries can use content authoring formats including Markdown (.md) and MDX (.mdx using the MDX integration) or as one of two supported data formats: YAML (.yaml) and JSON (.json). We recommend using a consistent naming scheme (lower-case, dashes instead of spaces) for your files to make it easier to find and organize your content, but this is not required. You can also exclude entries from being built by prefixing the filename with an underscore (_).\n\nDirectory\nsrc/content/\nDirectory\nnewsletter/\nthe ‚Äúnewsletter‚Äù collection\nweek-1.md\na collection entry\nweek-2.md\na collection entry\nweek-3.md\na collection entry\n\nOnce you have a collection, you can start querying your content using Astro‚Äôs built-in content APIs.\n\nThe ‚Äú.astro‚Äù Directory\nSection titled The ‚Äú.astro‚Äù Directory\n\nAstro stores important metadata for content collections in an .astro directory in your project. No action is needed on your part to maintain or update this directory. You are encouraged to ignore it entirely while working in your project.\n\nThe .astro directory will be updated for you automatically anytime you run the astro dev, astro build commands. You can run astro sync at any time to update the .astro directory manually.\n\n TIP\n\nIf you‚Äôre using Git for version control, we recommend ignoring the .astro directory by adding .astro to your .gitignore. This tells Git to ignore this directory and any files inside of it.\n\nTerminal window\necho \"\\n.astro\" >> .gitignore\nOrganizing with multiple collections\nSection titled Organizing with multiple collections\n\nIf two files represent different kinds of content (e.g. a blog post and an author profile), they most likely belong in different collections. This is important because many features (frontmatter validation, automatic TypeScript type-safety) require that all entries in a collection share a similar structure.\n\nIf you find yourself working with different types of content, you should create multiple collections to represent each type. You can create as many different collections in your project as you‚Äôd like.\n\nDirectory\nsrc/content/\nDirectory\nnewsletter/\nweek-1.md\nweek-2.md\nDirectory\nblog/\npost-1.md\npost-2.md\nDirectory\nauthors/\ngrace-hopper.json\nalan-turing.json\nOrganizing with subdirectories\nSection titled Organizing with subdirectories\n\nA content collection is always a top-level folder inside of the src/content/ directory. You cannot nest one collection inside of another. However, you can use subdirectories to organize your content within a collection.\n\nFor example, you can use the following directory structure to organize i18n translations within a single docs collection. When you query this collection, you‚Äôll be able to filter the result by language using the file path.\n\nDirectory\nsrc/content/\nDirectory\ndocs/\nthis collection uses subdirectories to organize by language\nDirectory\nen/\nDirectory\nes/\nDirectory\nde/\nDefining Collections\nSection titled Defining Collections\n\n NOTE\n\nThe src/content/config.ts file is optional. However, choosing not to define your collections will disable some of their best features like frontmatter schema validation or automatic TypeScript typings.\n\nTo get the most out of your content collections, create a src/content/config.ts file in your project (.js and .mjs extensions are also supported.) This is a special file that Astro will automatically load and use to configure your content collections.\n\nsrc/content/config.ts\n// 1. Import utilities from `astro:content`\nimport { defineCollection } from 'astro:content';\n// 2. Define your collection(s)\nconst blogCollection = defineCollection({ /* ... */ });\n// 3. Export a single `collections` object to register your collection(s)\n//    This key should match your collection directory name in \"src/content\"\nexport const collections = {\n  'blog': blogCollection,\n};\nSetting up TypeScript\nSection titled Setting up TypeScript\n\nIf you do not already extend Astro‚Äôs strict or strictest recommended TypeScript settings in your tsconfig.json file, you may need to update your tsconfig.json to enable strictNullChecks.\n\ntsconfig.json\n{\n  // Note: No change needed if you use \"astro/tsconfigs/strict\" or \"astro/tsconfigs/strictest\"\n  \"extends\": \"astro/tsconfigs/base\",\n  \"compilerOptions\": {\n    \"strictNullChecks\": true\n  }\n}\n\nIf you use .js or .mjs files in an Astro project, you can enable IntelliSense and type checking in your editor by enabling allowJs in your tsconfig.json:\n\ntsconfig.json\n{\n  // Note: No change needed if you use \"astro/tsconfigs/strict\" or \"astro/tsconfigs/strictest\"\n  \"extends\": \"astro/tsconfigs/base\",\n  \"compilerOptions\": {\n    \"strictNullChecks\": true,\n    \"allowJs\": true\n  }\n}\nDefining a collection schema\nSection titled Defining a collection schema\n\nSchemas enforce consistent frontmatter or entry data within a collection. A schema guarantees that this data exists in a predictable form when you need to reference or query it. If any file violates its collection schema, Astro will provide a helpful error to let you know.\n\nSchemas also power Astro‚Äôs automatic TypeScript typings for your content. When you define a schema for your collection, Astro will automatically generate and apply a TypeScript interface to it. The result is full TypeScript support when you query your collection, including property autocompletion and type-checking.\n\nTo define your first collection, create a src/content/config.ts file if one does not already exist (.js and .mjs extensions are also supported.) This file should:\n\nImport the proper utilities from astro:content.\nDefine each collection that you‚Äôd like to validate. This includes a type (introduced in Astro v2.5.0) specifying whether the collection contains content authoring formats like Markdown (type: 'content') or data formats like JSON or YAML (type: 'data'). It also includes a schema that defines the shape of your frontmatter or entry data.\nExport a single collections object to register your collections.\nsrc/content/config.ts\n// 1. Import utilities from `astro:content`\nimport { z, defineCollection } from 'astro:content';\n\n\n// 2. Define a `type` and `schema` for each collection\nconst blogCollection = defineCollection({\n  type: 'content', // v2.5.0 and later\n  schema: z.object({\n    title: z.string(),\n    tags: z.array(z.string()),\n    image: z.string().optional(),\n  }),\n});\n\n\n// 3. Export a single `collections` object to register your collection(s)\nexport const collections = {\n  'blog': blogCollection,\n};\nDefining multiple collections\nSection titled Defining multiple collections\n\nYou can use defineCollection() as many times as you want to create multiple schemas. All collections must be exported from inside the single collections object.\n\nsrc/content/config.ts\nconst blogCollection = defineCollection({\n  type: 'content',\n  schema: z.object({ /* ... */ })\n});\nconst newsletter = defineCollection({\n  type: 'content',\n  schema: z.object({ /* ... */ })\n});\nconst authors = defineCollection({\n  type: 'data',\n  schema: z.object({ /* ... */ })\n});\n\n\nexport const collections = {\n  'blog': blogCollection,\n  'newsletter': newsletter,\n  'authors': authors,\n};\n\nAs your project grows, you are also free to reorganize your codebase and move logic out of the src/content/config.ts file. Defining your schemas separately can be useful for reusing schemas across multiple collections and sharing schemas with other parts of your project.\n\nsrc/content/config.ts\n// 1. Import your utilities and schemas\nimport { defineCollection } from 'astro:content';\nimport { blogSchema, authorSchema } from '../schemas';\n\n\n// 2. Define your collections\nconst blogCollection = defineCollection({\n  type: 'content',\n  schema: blogSchema,\n});\nconst authorCollection = defineCollection({\n  type: 'data',\n  schema: authorSchema,\n});\n\n\n// 3. Export multiple collections to register them\nexport const collections = {\n  'blog': blogCollection,\n  'authors': authorCollection,\n};\nUsing third-party collection schemas\nSection titled Using third-party collection schemas\n\nYou can import collection schemas from anywhere, including external npm packages. This can be useful when working with themes and libraries that provide their own collection schemas for you to use.\n\nsrc/content/config.ts\nimport { blogSchema } from 'my-blog-theme';\nconst blogCollection = defineCollection({ type: 'content', schema: blogSchema });\n\n\n// Export the blog collection, using an external schema from 'my-blog-theme'\nexport const collections = {\n  'blog': blogCollection,\n};\nDefining datatypes with Zod\nSection titled Defining datatypes with Zod\n\nAstro uses Zod to power its content schemas. With Zod, Astro is able to validate every file‚Äôs frontmatter within a collection and provide automatic TypeScript types when you go to query content from inside your project.\n\nTo use Zod in Astro, import the z utility from \"astro:content\". This is a re-export of the Zod library, and it supports all of the features of Zod. See Zod‚Äôs README for complete documentation on how Zod works and what features are available.\n\n// Example: A cheatsheet of many common Zod datatypes\nimport { z, defineCollection } from 'astro:content';\n\n\ndefineCollection({\n  schema: z.object({\n    isDraft: z.boolean(),\n    title: z.string(),\n    sortOrder: z.number(),\n    image: z.object({\n      src: z.string(),\n      alt: z.string(),\n    }),\n    author: z.string().default('Anonymous'),\n    language: z.enum(['en', 'es']),\n    tags: z.array(z.string()),\n    // An optional frontmatter property. Very common!\n    footnote: z.string().optional(),\n    // In frontmatter, dates written without quotes around them are interpreted as Date objects\n    publishDate: z.date(),\n    // You can also transform a date string (e.g. \"2022-07-08\") to a Date object\n    // publishDate: z.string().transform((str) => new Date(str)),\n    // Advanced: Validate that the string is also an email\n    authorContact: z.string().email(),\n    // Advanced: Validate that the string is also a URL\n    canonicalURL: z.string().url(),\n  })\n})\nDefining collection references\nSection titled Defining collection references\n\nCollection entries can also ‚Äúreference‚Äù other related entries.\n\nWith the reference() function from the Collections API, you can define a property in a collection schema as an entry from another collection. For example, you can require that every space-shuttle entry includes a pilot property which uses the pilot collection‚Äôs own schema for type checking, autocomplete, and validation.\n\nA common example is a blog post that references reusable author profiles stored as JSON, or related post URLs stored in the same collection:\n\nimport { defineCollection, reference, z } from 'astro:content';\n\n\nconst blog = defineCollection({\n  type: 'content',\n  schema: z.object({\n    title: z.string(),\n    // Reference a single author from the `authors` collection by `id`\n    author: reference('authors'),\n    // Reference an array of related posts from the `blog` collection by `slug`\n    relatedPosts: z.array(reference('blog')),\n  })\n});\n\n\nconst authors = defineCollection({\n  type: 'data',\n  schema: z.object({\n    name: z.string(),\n    portfolio: z.string().url(),\n  })\n});\n\n\nexport const collections = { blog, authors };\n\nThis example blog post specifies the slugs of related posts and the id of the post author:\n\nsrc/content/blog/welcome.md\n---\ntitle: \"Welcome to my blog\"\nauthor: ben-holmes # references `src/content/authors/ben-holmes.json`\nrelatedPosts:\n- about-me # references `src/content/blog/about-me.md`\n- my-year-in-review # references `src/content/blog/my-year-in-review.md`\n---\nDefining custom slugs\nSection titled Defining custom slugs\n\nWhen using type: 'content', every content entry generates a URL-friendly slug property from its file id. The slug is used to query the entry directly from your collection. It is also useful when creating new pages and URLs from your content.\n\nYou can override an entry‚Äôs generated slug by adding your own slug property to the file frontmatter. This is similar to the ‚Äúpermalink‚Äù feature of other web frameworks. \"slug\" is a special, reserved property name that is not allowed in your custom collection schema and will not appear in your entry‚Äôs data property.\n\n---\ntitle: My Blog Post\nslug: my-custom-slug/supports/slashes\n---\nYour blog post content here.\nQuerying Collections\nSection titled Querying Collections\n\nAstro provides two functions to query a collection and return one (or more) content entries: getCollection() and getEntry().\n\nimport { getCollection, getEntry } from 'astro:content';\n\n\n// Get all entries from a collection.\n// Requires the name of the collection as an argument.\n// Example: retrieve `src/content/blog/**`\nconst allBlogPosts = await getCollection('blog');\n\n\n// Get a single entry from a collection.\n// Requires the name of the collection and either\n// the entry `slug` (content collections) or `id` (data collections)\n// Example: retrieve `src/content/authors/grace-hopper.json`\nconst graceHopperProfile = await getEntry('authors', 'grace-hopper');\n\nBoth functions return content entries as defined by the CollectionEntry type.\n\nAccessing referenced data\nSection titled Accessing referenced data\n\nAny references defined in your schema must be queried separately after first querying your collection entry. You can use the getEntry() function again, or getEntries(), to retrieve the referenced entry from the returned data object.\n\nsrc/pages/blog/welcome.astro\n---\nimport { getEntry, getEntries } from 'astro:content';\n\n\nconst blogPost = await getEntry('blog', 'welcome');\n\n\n// Resolve a singular reference\nconst author = await getEntry(blogPost.data.author);\n// Resolve an array of references\nconst relatedPosts = await getEntries(blogPost.data.relatedPosts);\n---\n\n\n<h1>{blogPost.data.title}</h1>\n<p>Author: {author.data.name}</p>\n\n\n<!-- ... -->\n\n\n<h2>You might also like:</h2>\n{relatedPosts.map(p => (\n  <a href={p.slug}>{p.data.title}</a>\n))}\nFiltering collection queries\nSection titled Filtering collection queries\n\ngetCollection() takes an optional ‚Äúfilter‚Äù callback that allows you to filter your query based on an entry‚Äôs id or data (frontmatter) properties. For collections of type: 'content', you can also filter based on slug.\n\n NOTE\n\nThe slug property is specific to content collections, and will not be available when filtering collections of JSON or YAML.\n\nYou can use this to filter by any content criteria you like. For example, you can filter by properties like draft to prevent any draft blog posts from publishing to your blog:\n\n// Example: Filter out content entries with `draft: true`\nimport { getCollection } from 'astro:content';\nconst publishedBlogEntries = await getCollection('blog', ({ data }) => {\n  return data.draft !== true;\n});\n\nYou can also create draft pages that are available when running the dev server, but not built in production:\n\n// Example: Filter out content entries with `draft: true` only when building for production\nimport { getCollection } from 'astro:content';\nconst blogEntries = await getCollection('blog', ({ data }) => {\n  return import.meta.env.PROD ? data.draft !== true : true;\n});\n\nThe filter argument also supports filtering by nested directories within a collection. Since the id includes the full nested path, you can filter by the start of each id to only return items from a specific nested directory:\n\n// Example: Filter entries by sub-directory in the collection\nimport { getCollection } from 'astro:content';\nconst englishDocsEntries = await getCollection('docs', ({ id }) => {\n  return id.startsWith('en/');\n});\nUsing content in Astro templates\nSection titled Using content in Astro templates\n\nOnce you have queried your collection entries, you can access each entry directly inside of your Astro component template. This lets you to render HTML for things like links to your content (using the content slug) or information about your content (using the data property).\n\nFor information about rendering your content to HTML, see Rendering Content to HTML below.\n\nsrc/pages/index.astro\n---\nimport { getCollection } from 'astro:content';\nconst blogEntries = await getCollection('blog');\n---\n<ul>\n  {blogEntries.map(blogPostEntry => (\n    <li>\n      <a href={`/my-blog-url/${blogPostEntry.slug}`}>{blogPostEntry.data.title}</a>\n      <time datetime={blogPostEntry.data.publishedDate.toISOString()}>\n        {blogPostEntry.data.publishedDate.toDateString()}\n      </time>\n    </li>\n  ))}\n</ul>\nPassing content as props\nSection titled Passing content as props\n\nA component can also pass an entire content entry as a prop.\n\nIf you do this, you can use the CollectionEntry utility to correctly type your components props using TypeScript. This utility takes a string argument that matches the name of your collection schema, and will inherit all of the properties of that collection‚Äôs schema.\n\nsrc/components/BlogCard.astro\n---\nimport type { CollectionEntry } from 'astro:content';\ninterface Props {\n  post: CollectionEntry<'blog'>;\n}\n\n\n// `post` will match your 'blog' collection schema type\nconst { post } = Astro.props;\n---\nRendering content to HTML\nSection titled Rendering content to HTML\n\nOnce queried, you can render Markdown and MDX entries to HTML using the entry render() function property. Calling this function gives you access to rendered content and metadata, including both a <Content /> component and a list of all rendered headings.\n\nsrc/pages/render-example.astro\n---\nimport { getEntry } from 'astro:content';\nconst entry = await getEntry('blog', 'post-1');\nconst { Content, headings } = await entry.render();\n---\n<p>Published on: {entry.data.published.toDateString()}</p>\n<Content />\nGenerating Routes from Content\nSection titled Generating Routes from Content\n\nContent collections are stored outside of the src/pages/ directory. This means that no routes are generated for your collection items by default. You will need to manually create a new dynamic route to generate HTML pages from your collection entries. Your dynamic route will map the incoming request param (ex: Astro.params.slug in src/pages/blog/[...slug].astro) to fetch the correct entry inside a collection.\n\nThe exact method for generating routes will depend on your build output mode: ‚Äòstatic‚Äô (the default) or ‚Äòserver‚Äô (for SSR).\n\nBuilding for static output (default)\nSection titled Building for static output (default)\n\nIf you are building a static website (Astro‚Äôs default behavior), you would use the getStaticPaths() function to create multiple pages from a single src/pages/ component during your build.\n\nCall getCollection() inside of getStaticPaths() to query your content. Then, create your new URL paths using the slug property of each content entry.\n\nsrc/pages/posts/[...slug].astro\n---\nimport { getCollection } from 'astro:content';\n// 1. Generate a new path for every collection entry\nexport async function getStaticPaths() {\n  const blogEntries = await getCollection('blog');\n  return blogEntries.map(entry => ({\n    params: { slug: entry.slug }, props: { entry },\n  }));\n}\n// 2. For your template, you can get the entry directly from the prop\nconst { entry } = Astro.props;\nconst { Content } = await entry.render();\n---\n<h1>{entry.data.title}</h1>\n<Content />\n\nThis will generate a new page for every entry in the blog collection. For example, an entry at src/content/blog/hello-world.md will have a slug of hello-world, and therefore its final URL will be /posts/hello-world/.\n\n NOTE\n\nIf your custom slugs contain the / character to produce URLs with multiple path segments, you must use a rest parameter ([...slug]) in the .astro filename for this dynamic routing page.\n\nBuilding for server output (SSR)\nSection titled Building for server output (SSR)\n\nIf you are building a dynamic website (using Astro‚Äôs SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using Astro.request or Astro.params) to find the slug on-demand, and then fetch it using getEntry().\n\nsrc/pages/posts/[...slug].astro\n---\nimport { getEntry } from \"astro:content\";\n// 1. Get the slug from the incoming server request\nconst { slug } = Astro.params;\nif (slug === undefined) {\n  throw new Error(\"Slug is required\");\n}\n// 2. Query for the entry directly using the request slug\nconst entry = await getEntry(\"blog\", slug);\n// 3. Redirect if the entry does not exist\nif (entry === undefined) {\n  return Astro.redirect(\"/404\");\n}\n// 4. (Optional) Render the entry to HTML in the template\nconst { Content } = await entry.render();\n---\nMigrating from File-Based Routing\nSection titled Migrating from File-Based Routing\n\nIf you have an existing Astro project, such as a blog, that uses Markdown or MDX files in subfolders inside src/pages/, consider migrating related content or data files to content collections.\n\nSee how to convert a basic blog example from src/pages/posts/ to src/content/posts in our step-by-step tutorial that uses the codebase from the Build a Blog tutorial‚Äôs finished project.\n\nEnabling Build Caching\nSection titled Enabling Build Caching\n\nAdded in: astro@3.5.0 EXPERIMENTAL\n\nIf you are working with large collections, you may wish to enable cached builds with the experimental.contentCollectionCache flag. This experimental feature optimizes Astro‚Äôs build process, enabling unchanged collections to be stored and reused between builds.\n\nIn many cases, this can lead to significant build performance improvements.\n\nWhile this feature stabilizes, you may run into issues with the stored cache. You can always reset your build cache by running the following command:\n\nnpm run astro build -- --force\nModifying Frontmatter with Remark\nSection titled Modifying Frontmatter with Remark\n\n CAUTION\n\nNot recommended. Remark and rehype plugins access the raw Markdown or MDX document frontmatter. This means that remarkPluginFrontmatter frontmatter is handled separately from your type-safe schema, and will not reflect any changes or defaults applied through Astro. Use at your own risk!\n\nAstro supports remark or rehype plugins that modify your frontmatter directly. You can access this modified frontmatter inside of a content entry by using the remarkPluginFrontmatter property returned from render():\n\n---\nimport { getEntry } from 'astro:content';\nconst blogPost = await getEntry('blog', 'post-1');\nconst { remarkPluginFrontmatter } = await blogPost.render();\n---\n<p>{blogPost.data.title} ‚Äî {remarkPluginFrontmatter.readingTime}</p>\nRelated recipe:\nAdd Reading Time\n\nThe remark and rehype pipelines only run when your content is rendered, which explains why remarkPluginFrontmatter is only available after you call render() on your content entry. In contrast, getCollection() and getEntry() cannot return these values directly because they do not render your content.\n\nWorking with dates in the frontmatter\nSection titled Working with dates in the frontmatter\n\nSeveral date formats are possible in content collections, but your collection‚Äôs schema must match the format used in your Markdown or MDX YAML frontmatter.\n\nYAML uses the ISO-8601 standard to express dates. Use the format yyyy-mm-dd (e.g. 2021-07-28) along with a schema type of z.date():\n\nsrc/pages/posts/example-post.md\n---\ntitle: My Blog Post\npubDate: 2021-07-08\n---\n\nThe date format will be specified in UTC if a timezone is not provided. If you need to specify a timezone, you can use the ISO 8601 format.\n\nsrc/pages/posts/example-post.md\n---\ntitle: My Blog Post\npubDate: 2021-07-08T12:00:00-04:00\n---\n\nTo render only the YYYY-MM-DD from the full UTC timestamp, use the JavaScript slice method to remove the timestamp:\n\nsrc/layouts/ExampleLayout.astro\n---\nconst { frontmatter } = Astro.props;\n---\n<h1>{frontmatter.title}</h1>\n<p>{frontmatter.pubDate.slice(0,10)}</p>\n\nTo see an example of using toLocaleDateString to format the day, month, and year instead, see the <FormattedDate /> component in the official Astro blog template.\n\nBack\nRendering Modes\nNext Page\nView Transitions"
  },
  {
    "title": "Rendering Modes üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/rendering-modes/",
    "html": "Rendering Modes\n\nYour Astro project code must be rendered to HTML in order to be displayed on the web.\n\nAstro pages, routes, and API endpoints can be either pre-rendered at build time or rendered on demand by a server when a route is requested. With Astro islands, you can also include some client-side rendering when necessary.\n\nIn Astro, most of the processing occurs on the server, instead of in the browser. This generally makes your site or app faster than client-side rendering when viewed on less-powerful devices or on slower internet connections. Server-rendered HTML is fast, SEO friendly, and accessible by default.\n\nServer output modes\nSection titled Server output modes\n\nYou can configure how your pages are rendered in your output configuration.\n\nPre-rendered\nSection titled Pre-rendered\n\nThe default rendering mode is output: 'static', which creates the HTML for all your page routes at build time.\n\nIn this mode, your entire site will be pre-rendered and the server will have all pages built ahead of time and ready to send to the browser. The same HTML document is sent to the browser for every visitor, and a full-site rebuild is required to update the contents of the page. This method is also known as static site generation (SSG).\n\nBy default, all Astro projects are configured to be pre-rendered at build time (statically-generated) to provide the most lightweight browser experience. The browser does not need to wait for any HTML to build because the server does not need to generate any pages on demand. Your site is not dependent on the performance of a backend data source, and once built, will remain available to visitors as a static site as long as your server is functioning.\n\nStatic sites can include Astro islands for interactive UI components (or even entire embedded client-side rendered apps!) written in the UI framework of your choice in an otherwise static, pre-rendered page.\n\nAstro‚Äôs View Transitions API are also available in static mode for animation and state persistence across page navigation. Static sites can also use middleware to intercept and transform response data from a request.\n\n TIP\n\nAstro‚Äôs default static mode is a powerful, modern-feeling choice for content-heavy sites that update infrequently, and display the same page content to all visitors.\n\nOn-demand rendered\nSection titled On-demand rendered\n\nAstro‚Äôs other two output modes can be configured to enable on-demand rendering of some or all of your pages, routes or API endpoints:\n\noutput: 'server' for highly dynamic sites with most or all on-demand routes.\noutput: 'hybrid' for mostly static sites with some on-demand routes.\n\nSince they are generated per visit, these routes can be customized for each viewer. For example, a page rendered on demand can show a logged-in user their account information or display freshly updated data without requiring a full-site rebuild. On-demand rendering on the server at request time is also known as server-side rendering (SSR).\n\nConsider enabling server or hybrid mode in your Astro project if you need the following:\n\nAPI endpoints: Create specific pages that function as API endpoints for tasks like database access, authentication, and authorization while keeping sensitive data hidden from the client.\n\nProtected pages: Restrict access to a page based on user privileges, by handling user access on the server.\n\nFrequently changing content: Generate individual pages without requiring a static rebuild of your site. This is useful when the content of a page updates frequently, for example displaying data from an API called dynamically with fetch().\n\nBoth server and hybrid output modes allow you to include Astro islands for interactivity (or even entire embedded client-side rendered apps!) in your choice of UI frameworks. With middleware and Astro‚Äôs View Transitions API for animations and preserving state across route navigations, even highly interactive apps are possible.\n\n TIP\n\nOn demand server-rendering in Astro provides a true app experience without the JavaScript overhead of a client-side, single-page application.\n\nBack\nAstro Template Syntax\nNext Page\nContent Collections"
  },
  {
    "title": "Astro Syntax üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/astro-syntax/",
    "html": "Astro Syntax\n\nIf you know HTML, you already know enough to write your first Astro component.\n\nAstro component syntax is a superset of HTML. The syntax was designed to feel familiar to anyone with experience writing HTML or JSX, and adds support for including components and JavaScript expressions.\n\nJSX-like Expressions\nSection titled JSX-like Expressions\n\nYou can define local JavaScript variables inside of the frontmatter component script between the two code fences (---) of an Astro component. You can then inject these variables into the component‚Äôs HTML template using JSX-like expressions!\n\n DYNAMIC VS REACTIVE\n\nUsing this approach, you can include dynamic values that are calculated in the frontmatter. But once included, these values are not reactive and will never change. Astro components are templates that only run once, during the rendering step.\n\nSee below for more examples of differences between Astro and JSX.\n\nVariables\nSection titled Variables\n\nLocal variables can be added into the HTML using the curly braces syntax:\n\nsrc/components/Variables.astro\n---\nconst name = \"Astro\";\n---\n<div>\n  <h1>Hello {name}!</h1>  <!-- Outputs <h1>Hello Astro!</h1> -->\n</div>\nDynamic Attributes\nSection titled Dynamic Attributes\n\nLocal variables can be used in curly braces to pass attribute values to both HTML elements and components:\n\nsrc/components/DynamicAttributes.astro\n---\nconst name = \"Astro\";\n---\n<h1 class={name}>Attribute expressions are supported</h1>\n\n\n<MyComponent templateLiteralNameAttribute={`MyNameIs${name}`} />\n\n CAUTION\n\nHTML attributes will be converted to strings, so it is not possible to pass functions and objects to HTML elements. For example, you can‚Äôt assign an event handler to an HTML element in an Astro component:\n\ndont-do-this.astro\n---\nfunction handleClick () {\n    console.log(\"button clicked!\");\n}\n---\n<!-- ‚ùå This doesn't work! ‚ùå -->\n<button onClick={handleClick}>Nothing will happen when you click me!</button>\n\nInstead, use a client-side script to add the event handler, like you would in vanilla JavaScript:\n\ndo-this-instead.astro\n---\n---\n<button id=\"button\">Click Me</button>\n<script>\n  function handleClick () {\n    console.log(\"button clicked!\");\n  }\n  document.getElementById(\"button\").addEventListener(\"click\", handleClick);\n</script>\nDynamic HTML\nSection titled Dynamic HTML\n\nLocal variables can be used in JSX-like functions to produce dynamically-generated HTML elements:\n\nsrc/components/DynamicHtml.astro\n---\nconst items = [\"Dog\", \"Cat\", \"Platypus\"];\n---\n<ul>\n  {items.map((item) => (\n    <li>{item}</li>\n  ))}\n</ul>\n\nAstro can conditionally display HTML using JSX logical operators and ternary expressions.\n\nsrc/components/ConditionalHtml.astro\n---\nconst visible = true;\n---\n{visible && <p>Show me!</p>}\n\n\n{visible ? <p>Show me!</p> : <p>Else show me!</p>}\nDynamic Tags\nSection titled Dynamic Tags\n\nYou can also use dynamic tags by setting a variable to an HTML tag name or a component import:\n\nsrc/components/DynamicTags.astro\n---\nimport MyComponent from \"./MyComponent.astro\";\nconst Element = 'div'\nconst Component = MyComponent;\n---\n<Element>Hello!</Element> <!-- renders as <div>Hello!</div> -->\n<Component /> <!-- renders as <MyComponent /> -->\n\nWhen using dynamic tags:\n\nVariable names must be capitalized. For example, use Element, not element. Otherwise, Astro will try to render your variable name as a literal HTML tag.\n\nHydration directives are not supported. When using client:* hydration directives, Astro needs to know which components to bundle for production, and the dynamic tag pattern prevents this from working.\n\nFragments\nSection titled Fragments\n\nAstro supports using either <Fragment> </Fragment> or the shorthand <> </>.\n\nFragments can be useful to avoid wrapper elements when adding set:* directives, as in the following example:\n\nsrc/components/SetHtml.astro\n---\nconst htmlString = '<p>Raw HTML content</p>';\n---\n<Fragment set:html={htmlString} />\nDifferences between Astro and JSX\nSection titled Differences between Astro and JSX\n\nAstro component syntax is a superset of HTML. It was designed to feel familiar to anyone with HTML or JSX experience, but there are a couple of key differences between .astro files and JSX.\n\nAttributes\nSection titled Attributes\n\nIn Astro, you use the standard kebab-case format for all HTML attributes instead of the camelCase used in JSX. This even works for class, which is not supported by React.\n\nexample.astro\n<div className=\"box\" dataValue=\"3\" />\n<div class=\"box\" data-value=\"3\" />\nMultiple Elements\nSection titled Multiple Elements\n\nAn Astro component template can render multiple elements with no need to wrap everything in a single <div> or <>, unlike JavaScript or JSX.\n\nsrc/components/RootElements.astro\n---\n// Template with multiple elements\n---\n<p>No need to wrap elements in a single containing element.</p>\n<p>Astro supports multiple root elements in a template.</p>\nComments\nSection titled Comments\n\nIn Astro, you can use standard HTML comments or JavaScript-style comments.\n\nexample.astro\n---\n---\n<!-- HTML comment syntax is valid in .astro files -->\n{/* JS comment syntax is also valid */}\n\n CAUTION\n\nHTML-style comments will be included in browser DOM, while JS ones will be skipped. To leave TODO messages or other development-only explanations, you may wish to use JavaScript-style comments instead.\n\nBack\nLayouts\nNext Page\nRendering Modes"
  },
  {
    "title": "Layouts üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/layouts/",
    "html": "Layouts\n\nLayouts are Astro components used to provide a reusable UI structure, such as a page template.\n\nWe conventionally use the term ‚Äúlayout‚Äù for Astro components that provide common UI elements shared across pages such as headers, navigation bars, and footers. A typical Astro layout component provides Astro, Markdown or MDX pages with:\n\na page shell (<html>, <head> and <body> tags)\na <slot /> to specify where individual page content should be injected.\n\nBut, there is nothing special about a layout component! They can accept props and import and use other components like any other Astro component. They can include UI frameworks components and client-side scripts. They do not even have to provide a full page shell, and can instead be used as partial UI templates.\n\nLayout components are commonly placed in a src/layouts directory in your project for organization, but this is not a requirement; you can choose to place them anywhere in your project. You can even colocate layout components alongside your pages by prefixing the layout names with _.\n\nSample Layout\nSection titled Sample Layout\nsrc/layouts/MySiteLayout.astro\n---\nimport BaseHead from '../components/BaseHead.astro';\nimport Footer from '../components/Footer.astro';\nconst { title } = Astro.props\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <BaseHead title={title}/>\n  </head>\n  <body>\n    <nav>\n      <a href=\"#\">Home</a>\n      <a href=\"#\">Posts</a>\n      <a href=\"#\">Contact</a>\n    </nav>\n    <h1>{title}</h1>\n    <article>\n      <slot /> <!-- your content is injected here -->\n    </article>\n    <Footer />\n  </body>\n</html>\nsrc/pages/index.astro\n---\nimport MySiteLayout from '../layouts/MySiteLayout.astro';\n---\n<MySiteLayout title=\"Home Page\">\n  <p>My page content, wrapped in a layout!</p>\n</MySiteLayout>\n\nüìö Learn more about slots.\n\nMarkdown/MDX Layouts\nSection titled Markdown/MDX Layouts\n\nPage layouts are especially useful for Markdown and MDX pages which otherwise would not have any page formatting.\n\nAstro provides a special layout frontmatter property to specify which .astro component to use as the page layout.\n\nsrc/pages/page.md\n---\nlayout: ../layouts/BaseLayout.astro\ntitle: \"Hello, World!\"\nauthor: \"Matthew Phillips\"\ndate: \"09 Aug 2022\"\n---\nAll frontmatter properties are available as props to an Astro layout component.\n\n\nThe `layout` property is the only special one provided by Astro.\n\n\nYou can use it in both Markdown and MDX files located within `src/pages/`.\n\nA typical layout for Markdown or MDX pages includes:\n\nThe frontmatter prop to access the Markdown or MDX page‚Äôs frontmatter and other data.\nA default <slot /> to indicate where the page‚Äôs Markdown/MDX content should be rendered.\nsrc/layouts/BaseLayout.astro\n---\n// 1. The frontmatter prop gives access to frontmatter and other data\nconst { frontmatter } = Astro.props;\n---\n<html>\n  <head>\n    <!-- Add other Head elements here, like styles and meta tags. -->\n    <title>{frontmatter.title}</title>\n  </head>\n  <body>\n    <!-- Add other UI components here, like common headers and footers. -->\n    <h1>{frontmatter.title} by {frontmatter.author}</h1>\n    <!-- 2. Rendered HTML will be passed into the default slot. -->\n    <slot />\n    <p>Written on: {frontmatter.date}</p>\n  </body>\n</html>\n\nYou can set a layout‚Äôs Props type with the MarkdownLayoutProps or MDXLayoutProps helper:\n\nsrc/layouts/BaseLayout.astro\n---\nimport type { MarkdownLayoutProps } from 'astro';\n\n\ntype Props = MarkdownLayoutProps<{\n  // Define frontmatter props here\n  title: string;\n  author: string;\n  date: string;\n}>;\n\n\n// Now, `frontmatter`, `url`, and other Markdown layout properties\n// are accessible with type safety\nconst { frontmatter, url } = Astro.props;\n---\n<html>\n  <head>\n    <link rel=\"canonical\" href={new URL(url, Astro.site).pathname}>\n    <title>{frontmatter.title}</title>\n  </head>\n  <body>\n    <h1>{frontmatter.title} by {frontmatter.author}</h1>\n    <slot />\n    <p>Written on: {frontmatter.date}</p>\n  </body>\n</html>\nMarkdown Layout Props\nSection titled Markdown Layout Props\n\nA Markdown/MDX layout will have access to the following information via Astro.props:\n\nfile - The absolute path of this file (e.g. /home/user/projects/.../file.md).\nurl - If it‚Äôs a page, the URL of the page (e.g. /en/guides/markdown-content).\nfrontmatter - all frontmatter from the Markdown or MDX document.\nfrontmatter.file - The same as the top-level file property.\nfrontmatter.url - The same as the top-level url property.\nheadings - A list of headings (h1 -> h6) in the Markdown or MDX document with associated metadata. This list follows the type: { depth: number; slug: string; text: string }[].\n(Markdown only) rawContent() - A function that returns the raw Markdown document as a string.\n(Markdown only) compiledContent() - A function that returns the Markdown document compiled to an HTML string.\n\nAn example Markdown blog post may pass the following Astro.props object to its layout:\n\nAstro.props = {\n  file: \"/home/user/projects/.../file.md\",\n  url: \"/en/guides/markdown-content/\",\n  frontmatter: {\n    /** Frontmatter from a blog post */\n    title: \"Astro 0.18 Release\",\n    date: \"Tuesday, July 27 2021\",\n    author: \"Matthew Phillips\",\n    description: \"Astro 0.18 is our biggest release since Astro launch.\",\n    /** Generated values */\n    file: \"/home/user/projects/.../file.md\",\n    url: \"/en/guides/markdown-content/\"\n  },\n  headings: [\n    {\n      \"depth\": 1,\n      \"text\": \"Astro 0.18 Release\",\n      \"slug\": \"astro-018-release\"\n    },\n    {\n      \"depth\": 2,\n      \"text\": \"Responsive partial hydration\",\n      \"slug\": \"responsive-partial-hydration\"\n    }\n    /* ... */\n  ],\n\n\n  /** Available in Markdown only */\n  rawContent: () => \"# Astro 0.18 Release\\nA little over a month ago, the first public beta [...]\",\n  compiledContent: () => \"<h1>Astro 0.18 Release</h1>\\n<p>A little over a month ago, the first public beta [...]</p>\",\n}\n\n NOTE\n\nA Markdown/MDX layout will have access to all its file‚Äôs exported properties from Astro.props with some key differences:\n\nHeading information (i.e. h1 -> h6 elements) is available via the headings array, rather than a getHeadings() function.\n\nfile and url are also available as nested frontmatter properties (i.e. frontmatter.url and frontmatter.file).\n\nValues defined outside of frontmatter (e.g. export statements in MDX) are not available. Consider importing a layout instead.\n\nImporting Layouts Manually (MDX)\nSection titled Importing Layouts Manually (MDX)\n\nYou may need to pass information to your MDX layout that does not (or cannot) exist in your frontmatter. In this case, you can instead import and use a <Layout /> component and pass it props like any other component:\n\nsrc/pages/posts/first-post.mdx\n---\nlayout: ../../layouts/BaseLayout.astro\ntitle: 'My first MDX post'\npublishDate: '21 September 2022'\n---\nimport BaseLayout from '../../layouts/BaseLayout.astro';\n\n\nfunction fancyJsHelper() {\n  return \"Try doing that with YAML!\";\n}\n\n\n<BaseLayout title={frontmatter.title} fancyJsHelper={fancyJsHelper}>\n  Welcome to my new Astro blog, using MDX!\n</BaseLayout>\n\nThen, your values are available to you through Astro.props in your layout, and your MDX content will be injected into the page where your <slot /> component is written:\n\nsrc/layouts/BaseLayout.astro\n---\nconst { title, fancyJsHelper } = Astro.props;\n---\n<!-- -->\n<h1>{title}</h1>\n<slot /> <!-- your content is injected here -->\n<p>{fancyJsHelper()}</p>\n<!-- -->\n\nüìö Learn more about Astro‚Äôs Markdown and MDX support in our Markdown/MDX guide.\n\nUsing one Layout for .md, .mdx, and .astro\nSection titled Using one Layout for .md, .mdx, and .astro\n\nA single Astro layout can be written to receive the frontmatter object from .md and .mdx files, as well as any named props passed from .astro files.\n\nIn the example below, the layout will display the page title either from a frontmatter YAML title property or from an Astro component passing a title attribute:\n\nsrc/components/MyLayout.astro\n---\nconst { title } = Astro.props.frontmatter || Astro.props;\n---\n<html>\n  <head></head>\n  <body>\n    <h1>{title}</h1>\n    <slot />\n  </body>\n</html>\nNesting Layouts\nSection titled Nesting Layouts\n\nLayout components do not need to contain an entire page worth of HTML. You can break your layouts into smaller components, and combine layout components to create even more flexible, page templates. This pattern is useful when you want to share some code across multiple layouts.\n\nFor example, a BlogPostLayout.astro layout component could style a post‚Äôs title, date and author. Then, a site-wide BaseLayout.astro could handle the rest of your page template, like navigation, footers, SEO meta tags, global styles, and fonts. You can also pass props received from your post to another layout, just like any other nested component.\n\nsrc/layouts/BlogPostLayout.astro\n---\nimport BaseLayout from './BaseLayout.astro'\nconst {frontmatter} = Astro.props;\n---\n<BaseLayout url={frontmatter.url}>\n  <h1>{frontmatter.title}</h1>\n  <h2>Post author: {frontmatter.author}</h2>\n  <slot />\n</BaseLayout>\nBack\nPages\nNext Page\nAstro Template Syntax"
  },
  {
    "title": "Pages üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/astro-pages/",
    "html": "Pages\n\nPages are files that live in the src/pages/ subdirectory of your Astro project. They are responsible for handling routing, data loading, and overall page layout for every page in your website.\n\nSupported page files\nSection titled Supported page files\n\nAstro supports the following file types in the src/pages/ directory:\n\n.astro\n.md\n.mdx (with the MDX Integration installed)\n.html\n.js/.ts (as endpoints)\nFile-based routing\nSection titled File-based routing\n\nAstro leverages a routing strategy called file-based routing. Each file in your src/pages/ directory becomes an endpoint on your site based on its file path.\n\nA single file can also generate multiple pages using dynamic routing. This allows you to create pages even if your content lives outside of the special /pages/ directory, such as in a content collection or a CMS.\n\nüìö Read more about Routing in Astro.\n\nLink between pages\nSection titled Link between pages\n\nWrite standard HTML <a> elements in your Astro pages to link to other pages on your site. Use a URL path relative to your root domain as your link, not a relative file path.\n\nFor example, to link to https://example.com/authors/sonali/ from any other page on example.com:\n\nsrc/pages/index.astro\nRead more <a href=\"/authors/sonali/\">about Sonali</a>.\nAstro Pages\nSection titled Astro Pages\n\nAstro pages use the .astro file extension and support the same features as Astro components.\n\nsrc/pages/index.astro\n---\n---\n<html lang=\"en\">\n  <head>\n    <title>My Homepage</title>\n  </head>\n  <body>\n    <h1>Welcome to my website!</h1>\n  </body>\n</html>\n\nA page must produce a full HTML document. If not explicitly included, Astro will add the necessary <!DOCTYPE html> declaration and <head> content to any .astro component located within src/pages/ by default. You can opt-out of this behavior on a per-component basis by marking it as a partial page.\n\nTo avoid repeating the same HTML elements on every page, you can move common <head> and <body> elements into your own layout components. You can use as many or as few layout components as you‚Äôd like.\n\nsrc/pages/index.astro\n---\nimport MySiteLayout from '../layouts/MySiteLayout.astro';\n---\n<MySiteLayout>\n  <p>My page content, wrapped in a layout!</p>\n</MySiteLayout>\n\nüìö Read more about layout components in Astro.\n\nMarkdown/MDX Pages\nSection titled Markdown/MDX Pages\n\nAstro also treats any Markdown (.md) files inside of src/pages/ as pages in your final website. If you have the MDX Integration installed, it also treats MDX (.mdx) files the same way. These are commonly used for text-heavy pages like blog posts and documentation.\n\nCollections of Markdown or MDX page content in src/content/ can be used to generate pages dynamically.\n\nPage layouts are especially useful for Markdown files. Markdown files can use the special layout frontmatter property to specify a layout component that will wrap their Markdown content in a full <html>...</html> page document.\n\nsrc/pages/page.md\n---\nlayout: '../layouts/MySiteLayout.astro'\ntitle: 'My Markdown page'\n---\n# Title\n\n\nThis is my page, written in **Markdown.**\n\nüìö Read more about Markdown in Astro.\n\nHTML Pages\nSection titled HTML Pages\n\nFiles with the .html file extension can be placed in the src/pages/ directory and used directly as pages on your site. Note that some key Astro features are not supported in HTML Components.\n\nCustom 404 Error Page\nSection titled Custom 404 Error Page\n\nFor a custom 404 error page, you can create a 404.astro or 404.md file in /src/pages.\n\nThis will build to a 404.html page. Most deploy services will find and use it.\n\nPage Partials\nSection titled Page Partials\nAdded in: astro@3.4.0\n\n CAUTION\n\nPage partials are intended to be used in conjunction with a front-end library, such as htmx or Unpoly. You can also use them if you are comfortable writing low-level front-end JavaScript. For this reason they are an advanced feature.\n\nAdditionally, partials should not be used if the component contains scoped styles or scripts, as these elements will be stripped from the HTML output. If you need scoped styles, it is better to use regular, non-partial pages along with a frontend library that knows how to merge the contents into the head.\n\nPartials are page components located within src/pages/ that are not intended to render as full pages.\n\nLike components located outside of this folder, these files do not automatically include the <!DOCTYPE html> declaration, nor any <head> content such as scoped styles and scripts.\n\nHowever, because they are located in the special src/pages/ directory, the generated HTML is available at a URL corresponding to its file path. This allows a rendering library (e.g. htmx, Stimulus, jQuery) to access it on the client and load sections of HTML dynamically on a page without a browser refresh or page navigation.\n\nPartials, when combined with a rendering library, provide an alternative to Astro islands and <script> tags for building dynamic content in Astro.\n\nPage files that can export a value (e.g. .astro , .mdx) can be marked as partials.\n\nConfigure a file within the src/pages/ directory to be a partial by adding the following export:\n\nsrc/pages/partial.astro\n---\nexport const partial = true;\n---\n\n\n<li>I'm a partial!</li>\n\nThe export const partial must be identifiable statically. It can have the value of:\n\nThe boolean true.\nAn environment variable using import.meta.env such as import.meta.env.USE_PARTIALS.\nUsing with a library\nSection titled Using with a library\n\nPartials are used to dynamically update a section of a page using a library such as htmx.\n\nThe following example shows an hx-post attribute set to a partial‚Äôs URL. The content from the partial page will be used to update the targeted HTML element on this page.\n\nsrc/pages/index.astro\n<html>\n  <head>\n    <title>My page</title>\n    <script src=\"https://unpkg.com/htmx.org@1.9.6\"\n      integrity=\"sha384-FhXw7b6AlE/jyjlZH5iHa/tTe9EpJ1Y55RjcgPbjeWMskSxZt1v9qkxLJWNJaGni\"\n      crossorigin=\"anonymous\"></script>\n  </head>\n</html>\n<section>\n  <div id=\"parent-div\">Target here</div>\n\n\n  <button hx-post=\"/partials/clicked/\"\n    hx-trigger=\"click\"\n    hx-target=\"#parent-div\"\n    hx-swap=\"innerHTML\"\n  >\n      Click Me!\n  </button>\n</section>\n\nThe .astro partial must exist at the corresponding file path, and include an export defining the page as a partial:\n\nsrc/pages/partials/clicked.astro\n---\nexport const partial = true;\n---\n<div>I was clicked!</div>\n\nSee the htmx documentation for more details on using htmx.\n\nBack\nComponents\nNext Page\nLayouts"
  },
  {
    "title": "Components üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/astro-components/",
    "html": "Components\n\nAstro components are the basic building blocks of any Astro project. They are HTML-only templating components with no client-side runtime. You can spot an Astro component by its file extension: .astro.\n\nAstro components are extremely flexible. Often, an Astro component will contain some reusable UI on the page, like a header or a profile card. At other times, an Astro component may contain a smaller snippet of HTML, like a collection of common <meta> tags that make SEO easy to work with. Astro components can even contain an entire page layout.\n\nThe most important thing to know about Astro components is that they don‚Äôt render on the client. They render to HTML either at build-time or on-demand using server-side rendering (SSR). You can include JavaScript code inside of your component frontmatter, and all of it will be stripped from the final page sent to your users‚Äô browsers. The result is a faster site, with zero JavaScript footprint added by default.\n\nWhen your Astro component does need client-side interactivity, you can add standard HTML <script> tags or UI Framework components.\n\nComponent Structure\nSection titled Component Structure\n\nAn Astro component is made up of two main parts: the Component Script and the Component Template. Each part performs a different job, but together they provide a framework that is both easy to use and expressive enough to handle whatever you might want to build.\n\nsrc/components/EmptyComponent.astro\n---\n// Component Script (JavaScript)\n---\n<!-- Component Template (HTML + JS Expressions) -->\nThe Component Script\nSection titled The Component Script\n\nAstro uses a code fence (---) to identify the component script in your Astro component. If you‚Äôve ever written Markdown before, you may already be familiar with a similar concept called frontmatter. Astro‚Äôs idea of a component script was directly inspired by this concept.\n\nYou can use the component script to write any JavaScript code that you need to render your template. This can include:\n\nimporting other Astro components\nimporting other framework components, like React\nimporting data, like a JSON file\nfetching content from an API or database\ncreating variables that you will reference in your template\nsrc/components/MyComponent.astro\n---\nimport SomeAstroComponent from '../components/SomeAstroComponent.astro';\nimport SomeReactComponent from '../components/SomeReactComponent.jsx';\nimport someData from '../data/pokemon.json';\n\n\n// Access passed-in component props, like `<X title=\"Hello, World\" />`\nconst {title} = Astro.props;\n// Fetch external data, even from a private API or database\nconst data = await fetch('SOME_SECRET_API_URL/users').then(r => r.json());\n---\n<!-- Your template here! -->\n\nThe code fence is designed to guarantee that the JavaScript that you write in it is ‚Äúfenced in.‚Äù It won‚Äôt escape into your frontend application, or fall into your user‚Äôs hands. You can safely write code here that is expensive or sensitive (like a call to your private database) without worrying about it ever ending up in your user‚Äôs browser.\n\n TIP\n\nYou can even write TypeScript in your component script!\n\nThe Component Template\nSection titled The Component Template\n\nThe component template is below the code fence and determines the HTML output of your component.\n\nIf you write plain HTML here, your component will render that HTML in any Astro page it is imported and used.\n\nHowever, Astro‚Äôs component template syntax also supports JavaScript expressions, Astro <style> and <script> tags, imported components, and special Astro directives. Data and values defined in the component script can be used in the component template to produce dynamically-created HTML.\n\nsrc/components/MyFavoritePokemon.astro\n---\n// Your component script here!\nimport Banner from '../components/Banner.astro';\nimport ReactPokemonComponent from '../components/ReactPokemonComponent.jsx';\nconst myFavoritePokemon = [/* ... */];\nconst { title } = Astro.props;\n---\n<!-- HTML comments supported! -->\n{/* JS comment syntax is also valid! */}\n\n\n<Banner />\n<h1>Hello, world!</h1>\n\n\n<!-- Use props and other variables from the component script: -->\n<p>{title}</p>\n\n\n<!-- Include other UI framework components with a `client:` directive to hydrate: -->\n<ReactPokemonComponent client:visible />\n\n\n<!-- Mix HTML with JavaScript expressions, similar to JSX: -->\n<ul>\n  {myFavoritePokemon.map((data) => <li>{data.name}</li>)}\n</ul>\n\n\n<!-- Use a template directive to build class names from multiple strings or even objects! -->\n<p class:list={[\"add\", \"dynamic\", {classNames: true}]} />\nComponent-based design\nSection titled Component-based design\n\nComponents are designed to be reusable and composable. You can use components inside of other components to build more and more advanced UI. For example, a Button component could be used to create a ButtonGroup component:\n\nsrc/components/ButtonGroup.astro\n---\nimport Button from './Button.astro';\n---\n<div>\n  <Button title=\"Button 1\" />\n  <Button title=\"Button 2\" />\n  <Button title=\"Button 3\" />\n</div>\nComponent Props\nSection titled Component Props\n\nAn Astro component can define and accept props. These props then become available to the component template for rendering HTML. Props are available on the Astro.props global in your frontmatter script.\n\nHere is an example of a component that receives a greeting prop and a name prop. Notice that the props to be received are destructured from the global Astro.props object.\n\nsrc/components/GreetingHeadline.astro\n---\n// Usage: <GreetingHeadline greeting=\"Howdy\" name=\"Partner\" />\nconst { greeting, name } = Astro.props;\n---\n<h2>{greeting}, {name}!</h2>\n\nThis component, when imported and rendered in other Astro components, layouts or pages, can pass these props as attributes:\n\nsrc/components/GreetingCard.astro\n---\nimport GreetingHeadline from './GreetingHeadline.astro';\nconst name = \"Astro\"\n---\n<h1>Greeting Card</h1>\n<GreetingHeadline greeting=\"Hi\" name={name} />\n<p>I hope you have a wonderful day!</p>\n\nYou can also define your props with TypeScript with a Props type interface. Astro will automatically pick up the Props interface in your frontmatter and give type warnings/errors. These props can also be given default values when destructured from Astro.props.\n\nsrc/components/GreetingHeadline.astro\n---\ninterface Props {\n  name: string;\n  greeting?: string;\n}\n\n\nconst { greeting = \"Hello\", name } = Astro.props;\n---\n<h2>{greeting}, {name}!</h2>\n\nComponent props can be given default values to use when none are provided.\n\nsrc/components/GreetingHeadline.astro\n---\nconst { greeting = \"Hello\", name = \"Astronaut\" } = Astro.props;\n---\n<h2>{greeting}, {name}!</h2>\nSlots\nSection titled Slots\n\nThe <slot /> element is a placeholder for external HTML content, allowing you to inject (or ‚Äúslot‚Äù) child elements from other files into your component template.\n\nBy default, all child elements passed to a component will be rendered in its <slot />\n\n NOTE\n\nUnlike props, which are attributes passed to an Astro component available for use throughout your component with Astro.props, slots render child HTML elements where they are written.\n\nsrc/components/Wrapper.astro\n---\nimport Header from './Header.astro';\nimport Logo from './Logo.astro';\nimport Footer from './Footer.astro';\n\n\nconst { title } = Astro.props\n---\n<div id=\"content-wrapper\">\n  <Header />\n  <Logo />\n  <h1>{title}</h1>\n  <slot />  <!-- children will go here -->\n  <Footer />\n</div>\nsrc/pages/fred.astro\n---\nimport Wrapper from '../components/Wrapper.astro';\n---\n<Wrapper title=\"Fred's Page\">\n  <h2>All about Fred</h2>\n  <p>Here is some stuff about Fred.</p>\n</Wrapper>\n\nThis pattern is the basis of an Astro layout component: an entire page of HTML content can be ‚Äúwrapped‚Äù with <SomeLayoutComponent></SomeLayoutComponent> tags and sent to the component to render inside of common page elements defined there.\n\nNamed Slots\nSection titled Named Slots\n\nAn Astro component can also have named slots. This allows you to pass only HTML elements with the corresponding slot name into a slot‚Äôs location.\n\nSlots are named using the name attribute:\n\nsrc/components/Wrapper.astro\n---\nimport Header from './Header.astro';\nimport Logo from './Logo.astro';\nimport Footer from './Footer.astro';\n\n\nconst { title } = Astro.props\n---\n<div id=\"content-wrapper\">\n  <Header />\n  <slot name=\"after-header\"/>  <!--  children with the `slot=\"after-header\"` attribute will go here -->\n  <Logo />\n  <h1>{title}</h1>\n  <slot />  <!--  children without a `slot`, or with `slot=\"default\"` attribute will go here -->\n  <Footer />\n  <slot name=\"after-footer\"/>  <!--  children with the `slot=\"after-footer\"` attribute will go here -->\n</div>\n\nTo inject HTML content into a particular slot, use the slot attribute on any child element to specify the name of the slot. All other child elements of the component will be injected into the default (unnamed) <slot />.\n\nsrc/pages/fred.astro\n---\nimport Wrapper from '../components/Wrapper.astro';\n---\n<Wrapper title=\"Fred's Page\">\n  <img src=\"https://my.photo/fred.jpg\" slot=\"after-header\">\n  <h2>All about Fred</h2>\n  <p>Here is some stuff about Fred.</p>\n  <p slot=\"after-footer\">Copyright 2022</p>\n</Wrapper>\n\nUse a slot=\"my-slot\" attribute on the child element that you want to pass through to a matching <slot name=\"my-slot\" /> placeholder in your component.\n\nNote that named slots must be an immediate child of the component. You cannot pass named slots through nested elements.\n\n TIP\n\nNamed slots can also be passed to UI framework components!\n\n NOTE\n\nAn astro slot name can not be dynamically generated, such as within a map function. If this feature is needed within UI framework components, it might be best to generate these dynamic slots within the framework itself.\n\nFallback Content for Slots\nSection titled Fallback Content for Slots\n\nSlots can also render fallback content. When there are no matching children passed to a slot, a <slot /> element will render its own placeholder children.\n\nsrc/components/Wrapper.astro\n---\nimport Header from './Header.astro';\nimport Logo from './Logo.astro';\nimport Footer from './Footer.astro';\n\n\nconst { title } = Astro.props\n---\n<div id=\"content-wrapper\">\n  <Header />\n  <Logo />\n  <h1>{title}</h1>\n  <slot>\n    <p>This is my fallback content, if there is no child passed into slot</p>\n  </slot>\n  <Footer />\n</div>\nTransferring slots\nSection titled Transferring slots\n\nSlots can be transfered to other components. For example, when creating nested layouts:\n\nsrc/layouts/BaseLayout.astro\n---\n---\n\n\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <slot name=\"head\"/>\n  </head>\n  <body>\n    <slot />\n  </body>\n</html>\nsrc/layouts/HomeLayout.astro\n---\nimport BaseLayout from \"./BaseLayout.astro\";\n---\n\n\n<BaseLayout>\n  <slot name=\"head\" slot=\"head\"/>\n  <slot />\n</BaseLayout>\n\n NOTE\n\nNamed slots can be transfered to another component using both the name and slot attributes on a <slot /> tag\n\nNow, the default and head slots passed to HomeLayout will be transferred to the BaseLayout parent\n\nsrc/pages/index.astro\n---\nimport HomeLayout from \"../layouts/HomeLayout.astro\";\n---\n\n\n<HomeLayout>\n  <title slot=\"head\">Astro</title>\n  <h1>Astro</h1>\n</HomeLayout>\nHTML Components\nSection titled HTML Components\n\nAstro supports importing and using .html files as components or placing these files within the src/pages/ subdirectory as pages. You may want to use HTML components if you‚Äôre reusing code from an existing site built without a framework, or if you want to ensure that your component has no dynamic features.\n\nHTML components must contain only valid HTML, and therefore lack key Astro component features:\n\nThey don‚Äôt support frontmatter, server-side imports, or dynamic expressions.\nAny <script> tags are left unbundled, treated as if they had is:inline.\nThey can only reference assets that are in the public/ folder.\n\n NOTE\n\nA <slot /> element inside an HTML component will work as it would in an Astro component. In order to use the HTML Web Component Slot element instead, add is:inline to your <slot> element.\n\nNext Steps\nSection titled Next Steps\n\nüìö Learn about using UI framework components in your Astro project.\n\nBack\nProject Structure\nNext Page\nPages"
  },
  {
    "title": "Project Structure üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/core-concepts/project-structure/",
    "html": "Project Structure\n\nYour new Astro project generated from the create astro CLI wizard already includes some files and folders. Others, you will create yourself and add to Astro‚Äôs existing file structure.\n\nHere‚Äôs how an Astro project is organized, and some files you will find in your new project.\n\nDirectories and Files\nSection titled Directories and Files\n\nAstro leverages an opinionated folder layout for your project. Every Astro project root should include the following directories and files:\n\nsrc/* - Your project source code (components, pages, styles, etc.)\npublic/* - Your non-code, unprocessed assets (fonts, icons, etc.)\npackage.json - A project manifest.\nastro.config.mjs - An Astro configuration file. (recommended)\ntsconfig.json - A TypeScript configuration file. (recommended)\nExample Project Tree\nSection titled Example Project Tree\n\nA common Astro project directory might look like this:\n\nDirectory\npublic/\nrobots.txt\nfavicon.svg\nsocial-image.png\nDirectory\nsrc/\nDirectory\ncomponents/\nHeader.astro\nButton.jsx\nDirectory\nlayouts/\nPostLayout.astro\nDirectory\npages/\nDirectory\nposts/\npost1.md\npost2.md\npost3.md\nindex.astro\nDirectory\nstyles/\nglobal.css\nastro.config.mjs\npackage.json\ntsconfig.json\nsrc/\nSection titled src/\n\nThe src/ folder is where most of your project source code lives. This includes:\n\nPages\nLayouts\nAstro components\nUI framework components (React, etc.)\nStyles (CSS, Sass)\nMarkdown\n\nAstro processes, optimizes, and bundles your src/ files to create the final website that is shipped to the browser. Unlike the static public/ directory, your src/ files are built and handled for you by Astro.\n\nSome files (like Astro components) are not even sent to the browser as written but are instead rendered to static HTML. Other files (like CSS) are sent to the browser but may be optimized or bundled with other CSS files for performance.\n\n TIP\n\nWhile this guide describes some popular conventions used in the Astro community, the only directories reserved by Astro are src/pages/ and src/content/. You are free to rename and reorganize any other directories in a way that works best for you.\n\nsrc/components\nSection titled src/components\n\nComponents are reusable units of code for your HTML pages. These could be Astro components, or UI framework components like React or Vue. It is common to group and organize all of your project components together in this folder.\n\nThis is a common convention in Astro projects, but it is not required. Feel free to organize your components however you like!\n\nsrc/content\nSection titled src/content\n\nThe src/content/ directory is reserved to store content collections and an optional collections configuration file. No other files are allowed inside this folder.\n\nsrc/layouts\nSection titled src/layouts\n\nLayouts are Astro components that define the UI structure shared by one or more pages.\n\nJust like src/components, this directory is a common convention but not required.\n\nsrc/pages\nSection titled src/pages\n\nPages are a special kind of component used to create new pages on your site. A page can be an Astro component, or a Markdown file that represents some page of content for your site.\n\n CAUTION\n\nsrc/pages is a required sub-directory in your Astro project. Without it, your site will have no pages or routes!\n\nsrc/styles\nSection titled src/styles\n\nIt is a common convention to store your CSS or Sass files in a src/styles directory, but this is not required. As long as your styles live somewhere in the src/ directory and are imported correctly, Astro will handle and optimize them.\n\npublic/\nSection titled public/\n\nThe public/ directory is for files and assets that do not need to be processed during Astro‚Äôs build process. These files will be copied into the build folder untouched.\n\nThis behavior makes public/ ideal for common assets like images and fonts, or special files such as robots.txt and manifest.webmanifest.\n\nYou can place CSS and JavaScript in your public/ directory, but be aware that those files will not be bundled or optimized in your final build.\n\n TIP\n\nAs a general rule, any CSS or JavaScript that you write yourself should live in your src/ directory.\n\npackage.json\nSection titled package.json\n\nThis is a file used by JavaScript package managers to manage your dependencies. It also defines the scripts that are commonly used to run Astro (ex: npm start, npm run build).\n\nThere are two kinds of dependencies you can specify in a package.json: dependencies and devDependencies. In most cases, these work the same: Astro needs all dependencies at build time, and your package manager will install both. We recommend putting all of your dependencies in dependencies to start, and only use devDependencies if you find a specific need to do so.\n\nFor help creating a new package.json file for your project, check out the manual setup instructions.\n\nastro.config.mjs\nSection titled astro.config.mjs\n\nThis file is generated in every starter template and includes configuration options for your Astro project. Here you can specify integrations to use, build options, server options, and more.\n\nSee the Configuring Astro Guide for details on setting configurations.\n\ntsconfig.json\nSection titled tsconfig.json\n\nThis file is generated in every starter template and includes TypeScript configuration options for your Astro project. Some features (like npm package imports) aren‚Äôt fully supported in the editor without a tsconfig.json file.\n\nSee the TypeScript Guide for details on setting configurations.\n\nBack\nExtend with View Transitions\nNext Page\nComponents"
  },
  {
    "title": "Tutorial - Extend with View Transitions üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorials/add-view-transitions/",
    "html": "Tutorial ‚Å†-‚Å† Extend with View Transitions\n\nView transitions are a way to control what happens when visitors navigate between pages on your site. Astro‚Äôs View Transitions API allows you to add optional navigation features including smooth page transitions and animations, controlling the browser‚Äôs history stack of visited pages, and preventing full-page refreshes in order to persist some page elements and state while updating the content displayed.\n\nGET READY TO‚Ä¶\n\nImport and add the <ViewTransitions /> router to a common head element\nAdd event listeners during the navigation process to trigger <script>s when needed\nAdd page transition animations using transition directives\nOpt out of client-side routing for an individual page link\nPrerequisites\nSection titled Prerequisites\n\nYou will need an existing Astro project with a common base layout or <Head /> component.\n\nThis tutorial uses the Build a Blog tutorial‚Äôs finished project to demonstrate adding view transitions (client-side routing) to an existing Astro project. You can fork and use that codebase locally, or complete the tutorial in the browser by editing the blog tutorial‚Äôs code in StackBlitz.\n\nYou can instead follow these steps with your own Astro project, but you will need to adjust the instructions for your codebase.\n\nWe recommend using our sample project to complete this short tutorial first. Then, you can use what you have learned to create view transitions in your own project.\n\nBuild a Blog Tutorial Code\nSection titled Build a Blog Tutorial Code\n\nIn the Build a Blog introductory tutorial, you learned about Astro‚Äôs built-in file-based routing: any .astro, .md, or .mdx file anywhere within the src/pages/ folder automatically became a new page on your site.\n\nTo navigate between these pages, you used the standard HTML <a> element. For example, to create a link to your About page, you added <a href=\"/about/\">About</a> to your page header. When a visitor to your site clicked that link, the browser refreshed and loaded a new page with entirely new content.\n\nFull-page navigation vs client-side routing (SPA mode)\nSection titled Full-page navigation vs client-side routing (SPA mode)\n\nWhen a browser refreshes and loads a new page, there is no continuity between the old page and the new page. During client-side routing, a new page is displayed without a full-page browser refresh\n\nClient-side routing is a feature of single-page application (SPA) sites, where your entire site or app is ‚Äúone page‚Äù of JavaScript whose content is updated based on visitor interaction.\n\nBecause each new page does not require a full browser refresh, client-side routing allows you to control page transitions in several ways. Persistent elements, such as a common page header, do not have to be entirely rerendered on the screen. The transition from one page to another can appear much smoother. And, state can be preserved, allowing you to transfer values from one page to the next, or even keep a video playing as your visitors navigate pages!\n\nThere are times when you will want or need a full-page browser refresh. For example, when a link takes a visitor to a .pdf document, you will need the browser to load that new page from the server. Even with view transitions enabled in your Astro project, you will be able to specify how the browser should navigate both by default and on a per-link basis, even opting out of client-side routing entirely.\n\nRead more about Astro‚Äôs view transitions in our guide, or get started with the instructions below to convert a basic blog from src/pages/posts/ to src/content/posts/.\n\nTest your knowledge\nSection titled Test your knowledge\n\nAdding view transitions to my astro site‚Ä¶\n\nRequires more than 2 lines of code to implement site-wide by default\n\nChanges the default type of page navigation on a page that contains the <ViewTransitions /> router in its <head>\n\nDoes not add back accessibility features normally provided by the browser, such as route announcement and respect for prefers-reduced-motion\n\nSubmit\n\nWhich is not a benefit of Astro‚Äôs view transitions?\n\nSending some additional JavaScript to the browser for client-side routing\n\nThe option to persist individual elements and components as a visitor visits a new page\n\nControlling which kind of navigation to use on a per-link basis\n\nSubmit\n\nThe view transitions router‚Ä¶\n\nRequires me to use a UI framework such as React\n\nIs not ready for production sites\n\nIncludes fallback behavior for browsers that do not yet fully support view transitions\n\nSubmit\nExtending the blog tutorial with view transitions\nSection titled Extending the blog tutorial with view transitions\n\nThe steps below show you how to extend the final product of the Build a Blog tutorial by adding client-side routing to enhance page transitions.\n\nUpgrade dependencies\nSection titled Upgrade dependencies\n\nUpgrade to the latest version of Astro, and upgrade all integrations to their latest versions by running the following commands in your terminal:\n\nnpm\npnpm\nYarn\nTerminal window\n# Upgrade to Astro v3.x\nnpm install astro@latest\n\n\n# Example: upgrade the blog tutorial Preact integration\nnpm install @astrojs/preact@latest\n\n TIP\n\nIf you are using your own project, then be sure to update any dependencies you have installed. The example blog tutorial codebase only uses the Preact integration.\n\nAdd the <ViewTransitions /> router\nSection titled Add the &lt;ViewTransitions /&gt; router\n\nImport and add the <ViewTransitions /> component to the <head> of your page layout.\n\nIn the Blog tutorial example, the <head> element is found in src/layouts/BaseLayout.astro. The ViewTransitions router must be first imported into the component‚Äôs frontmatter. Then, add the routing component inside the <head> element.\n\nsrc/layouts/BaseLayout.astro\n---\nimport { ViewTransitions } from 'astro:transitions';\nimport Header from \"../components/Header.astro\";\nimport Footer from \"../components/Footer.astro\";\nimport \"../styles/global.css\";\nconst { pageTitle } = Astro.props;\n---\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>{pageTitle}</title>\n    <ViewTransitions />\n  </head>\n  <body>\n    <Header />\n    <h1>{pageTitle}</h1>\n    <slot />\n    <Footer />\n    <script>\n      import \"../scripts/menu.js\";\n    </script>\n  </body>\n</html>\n\nNo other configuration is necessary to enable Astro‚Äôs default client-side navigation! Astro will create default page animations based on the similarities between the old and new page, and will also provide fallback behavior for unsupported browsers.\n\nNavigate between pages in your site preview\n\nView your site preview at a large screen size, such as desktop mode. As you move between pages on your site, notice that the old page content appears to fade out as the new page content fades in. Use the view transitions guide to add custom behavior if you are not satisfied with the defaults.\n\nView your site preview at a smaller screen size, and try to use the hamburger menu to navigate between pages. Notice that your menu will no longer work after the first page load.\n\nUpdate scripts\nSection titled Update scripts\n\nWith view transitions, some scripts may no longer re-run after page navigation like they do with full-page browser refreshes. There are two events during client-side routing that you can listen for, and fire events when they occur: astro:page-load and astro:after-swap.\n\nMake the script controlling the <Hamburger /> mobile menu component available after navigating to a new page.\n\nTo make your mobile menu interactive after navigating to a new page, add the following code that listens for the astro:page-load event which runs at the end of page navigation, and in response, runs the existing script to make the hamburger menu function when clicked:\n\nsrc/scripts/menu.js\ndocument.addEventListener('astro:page-load', () => {\n  document.querySelector('.hamburger').addEventListener('click', () => {\n    document.querySelector('.nav-links').classList.toggle('expanded');\n  });\n});\n\nMake the script controlling the theme toggle available after page navigation.\n\nThe <script> that controls the light/dark theme toggle is located in the <ThemeIcon /> component. For the theme toggle to continue to function on every page, remove the is:inline attribute from the script and add the same event listener as in the previous example so that astro:page-load event can trigger your existing function.\n\nUpdate the existing script tag so that your function runs in response to the astro:page-load event, making your theme toggle interactive after the new page is fully loaded and visible to the user:\n\nsrc/components/ThemeIcon.astro\n---\n---\n<button id=\"themeToggle\"> /* ... */ </button>\n\n\n<style> /* ... */ </style>\n\n\n<script is:inline>\n  document.addEventListener('astro:page-load', () => {\n    const theme = (() => {\n      if (typeof localStorage !== \"undefined\" && localStorage.getItem(\"theme\")) {\n        return localStorage.getItem(\"theme\");\n      }\n      if (window.matchMedia(\"(prefers-color-scheme: dark)\").matches) {\n        return \"dark\";\n      }\n      return \"light\";\n    })();\n\n\n    if (theme === \"light\") {\n      document.documentElement.classList.remove(\"dark\");\n    } else {\n      document.documentElement.classList.add(\"dark\");\n    }\n\n\n    window.localStorage.setItem(\"theme\", theme);\n\n\n    const handleToggleClick = () => {\n      const element = document.documentElement;\n      element.classList.toggle(\"dark\");\n\n\n      const isDark = element.classList.contains(\"dark\");\n      localStorage.setItem(\"theme\", isDark ? \"dark\" : \"light\");\n    };\n\n\n    document\n      .getElementById(\"themeToggle\")\n      .addEventListener(\"click\", handleToggleClick);\n  });\n</script>\n\nNow, the theme toggle is interactive on every page when using the <ViewTransitions /> router, after the page has finished loading.\n\nCheck for theme earlier to prevent flashing in dark mode.\n\nThe theme toggle works on every page, but its script is loaded at the end of the navigation process, after the new page has fully loaded in the browser. There may be a flash of the light theme version of the site before this theme toggle script runs and checks which theme it should use on the page.\n\nTo check for, and if necessary set, dark mode earlier in the navigation process, create a function that will run in response to the astro:after-swap event. The following function to check the browser‚Äôs localStorage for dark theme will run immediately after the new page has replaced the old page, before the DOM elements are painted to the screen.\n\nAdd this new script to the <ThemeIcon /> component, in addition to the script that controls the theme toggle.\n\nsrc/components/ThemeIcon.astro\n<script> ... <script>\n\n\n<script>\n  document.addEventListener('astro:after-swap', () => {\n    localStorage.theme === 'dark'\n    ? document.documentElement.classList.add(\"dark\")\n    : document.documentElement.classList.add(\"light\");\n  });\n</script>\n\nNow, every page change that uses the <ViewTransitions /> router for client-side navigation (and therefore access to the astro:after-swap event) will be able to detect theme: dark from the browser‚Äôs localStorage and update the current page accordingly before the page is rendered for the viewer.\n\nTest your knowledge\nSection titled Test your knowledge\n\nWhich is the correct order of events after a visitor clicks a link to go to a new page during client-side navigation?\n\nastro:after-swap\nastro:page-load\nthe new page is visible\nastro:after-swap\nthe new page is visible\nastro:page-load\nastro:page-load\nthe new page is visible\nastro:after-swap\nSubmit\nCustomize Transition animations\nSection titled Customize Transition animations\n\nChange the default fade animation to a slide for the page title.\n\nWith view transitions enabled, you currently have a small fade in and out set for all page transition animations. Astro also provides a built-in slide animation. To change the type of animation for a single element, add the transition:animation=\"\" directive.\n\nFor example, to make the page titles slide in instead of fade in, add transition:animate=\"slide\" to the <h1> element in the BaseLayout:\n\nsrc/layouts/BaseLayout.astro\n---\nimport Header from \"../components/Header.astro\";\nimport Footer from \"../components/Footer.astro\";\nimport \"../styles/global.css\";\nimport { ViewTransitions } from 'astro:transitions';\nconst { pageTitle } = Astro.props;\n---\n\n\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"icon\" type=\"image/svg+xml\" href=\"/favicon.svg\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <meta name=\"generator\" content={Astro.generator} />\n    <title>{pageTitle}</title>\n    <ViewTransitions />\n  </head>\n  <body>\n    <Header />\n    <h1 transition:animate=\"slide\">{pageTitle}</h1>\n    <slot />\n    <Footer />\n    <script>\n      import \"../scripts/menu.js\";\n    </script>\n  </body>\n</html>\n\nIn your browser preview, you will now see the page titles slide on to the screen, while other elements such as the body text continues to fade in and out.\n\nTry it yourself - Make the navigation links slide in\nSection titled Try it yourself - Make the navigation links slide in\n\nAdd an animation directive to make the <div> in Navigation.astro containing all the header links slide in on page navigation, following the same steps as above.\n\nShow me the code.\n\nCheck your browser preview and now both the page title and the header links will slide in on every page navigation.\n\nAdd a longer fade-in on your blog post descriptions.\n\nYou can also customize Astro‚Äôs built-in animations by importing them, then providing any CSS animation properties.\n\nFor example, to make the description fade in slowly when you navigate to a blog post, import the fade animation in your layout for Markdown blog posts. Then, add the transition directive for Astro‚Äôs fade with a duration of 2s:\n\nsrc/layouts/MarkdownPostLayout.astro\n---\nimport BaseLayout from \"./BaseLayout.astro\";\nimport { fade } from 'astro:transitions';\nconst { frontmatter } = Astro.props;\n---\n\n\n<BaseLayout pageTitle={frontmatter.title}>\n  <p>{frontmatter.pubDate.slice(0, 10)}</p>\n  <p transition:animate={fade({ duration: '2s' })} ><em>{frontmatter.description}</em></p>\n  <p>Written by: {frontmatter.author}</p>\n  <img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n  <slot />\n</BaseLayout>\n\nNavigate to any blog post in your browser preview, and you will see the description fade in slower than the rest of the text.\n\nüìö Read more about the different transition directives and customizing animations.\n\nForce a full browser reload for some links\nSection titled Force a full browser reload for some links\n\nPrevent client-side routing and instead require the browser to reload when navigating to your About page.\n\nSometimes you will want a full browser reload when visitors click a certain link. For example, you may be linking to a page that does not also use the <ViewTransitions /> router, or to a file directly such as a .pdf.\n\nTo make it so that your browser refreshes every time you click the navigation link to go to your About page, add the data-astro-reload attribute to the <a> tag in your <Navigation/> component. This will override the <ViewTransitions /> router entirely, and any of the view transition animations, for this one link.\n\nsrc/components/Navigation.astro\n ---\n ---\n <div transition:animate=\"slide\" class=\"nav-links\">\n   <a href=\"/\">Home</a>\n   <a href=\"/about/\" data-astro-reload >About</a>\n   <a href=\"/blog/\">Blog</a>\n   <a href=\"/tags/\">Tags</a>\n </div>\n\nNow, when you click the navigation link to your About page, no animations will occur. The page links and title will not slide in, and the page content will not fade in when you navigate to your About page using this link.\n\nAdd a link to your About page from your author name in your Markdown layout for blog posts\n\ndata-astro-reload only triggers a full browser refresh when going to a new page from the link it is added to. It does not control all instances of navigating to your About page.\n\nIn your <MarkdownPostLayout /> component, add a link to your About page on your author name:\n\nsrc/layouts/MarkdownPostLayout.astro\n---\nimport BaseLayout from \"./BaseLayout.astro\";\nimport { fade } from 'astro:transitions';\nconst { frontmatter } = Astro.props;\n---\n\n\n<BaseLayout pageTitle={frontmatter.title}>\n  <p>{frontmatter.pubDate.slice(0, 10)}</p>\n  <p transition:animate={fade({ duration: '2s' })} ><em>{frontmatter.description}</em></p>\n  <p>Written by: <a href=\"/about/\">{frontmatter.author}</a></p>\n  <img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n  <slot />\n</BaseLayout>\n\nIf you visit any blog post in your browser preview, and then click on the linked author name to be taken to the About page, what does the page navigation look like?\n\nWhen a visitor clicks a link to the About page from an individual blog post, the page title and header navigation links \nslide in across the screen because \nthe data-astro-reload attribute is not set on these links\n\nThere is still so much more to explore! See our full View Transitions Guide for more things you can do with view transitions.\n\nFor the full example of the blog tutorial using view transitions, see the View Transitions branch of the tutorial repo.\n\nBack\nExtend with Content Collections\nNext Page\nProject Structure"
  },
  {
    "title": "Tutorial - Extend with Content Collections üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorials/add-content-collections/",
    "html": "Tutorial ‚Å†-‚Å† Extend with Content Collections\n\nContent collections are a powerful way to manage groups of similar content, such as blog posts. Collections help to organize your documents, validate your YAML frontmatter, and provide automatic TypeScript type-safety for all of your content (even if you don‚Äôt write any TypeScript yourself).\n\nGET READY TO‚Ä¶\n\nMove your folder of blog posts into src/content/\nCreate a schema to define your blog post frontmatter\nUse getCollection() to get blog post content and metadata\nPrerequisites\nSection titled Prerequisites\n\nYou will need an existing Astro project with Markdown or MDX files in the src/pages/ folder.\n\nThis tutorial uses the Build a Blog tutorial‚Äôs finished project to demonstrate converting a blog to content collections. You can fork and use that codebase locally, or complete the tutorial in the browser by editing the blog tutorial‚Äôs code in StackBlitz.\n\nYou can instead follow these steps with your own Astro project, but you will need to adjust the instructions for your codebase.\n\nWe recommend using our sample project to complete this short tutorial first. Then, you can use what you have learned to create content collections in your own project.\n\nBuild a Blog Tutorial Code\nSection titled Build a Blog Tutorial Code\n\nIn the Build a Blog introductory tutorial, you learned about Astro‚Äôs built-in file-based routing: any .astro, .md, or .mdx file anywhere within the src/pages/ folder automatically became a page on your site.\n\nTo create your first blog post at https://example.com/posts/post-1/, you created a /posts/ folder and added the file post-1.md. You then added a new Markdown file to this folder every time you wanted to add a new blog post to your site.\n\nPages vs Collections\nSection titled Pages vs Collections\n\nEven when using content collections, you will still use the src/pages/ folder for individual pages, such as your About Me page. But, moving your blog posts to the special src/content/ folder will allow you to use more powerful and performant APIs to generate your blog post index and display your individual blog posts.\n\nAt the same time, you‚Äôll receive better guidance and autocompletion in your code editor because you will have a schema to define a common structure for each post that Astro will help you enforce. In your schema, you can specify when frontmatter properties are required, such as a description or an author, and which data type each property must be, such as a string or an array. This leads to catching many mistakes sooner, with descriptive error messages telling you exactly what the problem is.\n\nRead more about Astro‚Äôs content collections in our guide, or get started with the instructions below to convert a basic blog from src/pages/posts/ to src/content/posts/.\n\nTest your knowledge\nSection titled Test your knowledge\n\nWhich type of page would you probably keep in src/pages/?\n\nBlog posts that all contain the same basic structure and metadata\n\nProduct pages in an eCommerce site\n\nA contact page, because you do not have multiple similar pages of this type.\n\nSubmit\n\nWhich is not a benefit of moving blog posts to a content collection?\n\nPages are automatically created for each file\n\nBetter error messages, because Astro knows more about each file\n\nBetter data fetching, with a more performant function\n\nSubmit\n\nContent collections uses TypeScript‚Ä¶\n\nTo make me feel bad\n\nTo understand my project, even if I don‚Äôt write any TypeScript\n\nOnly if I have the strict or strictest configuration set\n\nSubmit\nExtending the blog tutorial with content collections\nSection titled Extending the blog tutorial with content collections\n\nThe steps below show you how to extend the final product of the Build a Blog tutorial by creating a content collection for the blog posts.\n\nUpgrade dependencies\nSection titled Upgrade dependencies\n\nUpgrade to the latest version of Astro, and upgrade all integrations to their latest versions by running the following commands in your terminal:\n\nnpm\npnpm\nYarn\nTerminal window\n# Upgrade to Astro v3.x\nnpm install astro@latest\n\n\n# Example: upgrade the blog tutorial Preact integration\nnpm install @astrojs/preact@latest\n\n TIP\n\nIf you are using your own project, then be sure to update any dependencies you have installed. The example blog tutorial codebase only uses the Preact integration.\n\nThe blog tutorial uses the base (least strict) TypeScript setting. In order to use content collections, you must set up TypeScript for content collections either by using the strict or strictest setting, or by adding two options in tsconfig.json.\n\nIn order to use content collections without writing TypeScript in the rest of the blog tutorial example, add the following two TypeScript configuration options to the config file:\n\ntsconfig.json\n{\n  // Note: No change needed if you use \"astro/tsconfigs/strict\" or \"astro/tsconfigs/strictest\"\n  \"extends\": \"astro/tsconfigs/base\",\n  \"compilerOptions\": {\n    \"strictNullChecks\": true,\n    \"allowJs\": true\n  }\n}\nCreate a collection for your blog posts\nSection titled Create a collection for your blog posts\n\nCreate a new collection (folder) called src/content/posts/.\n\nMove all your existing blog posts (.md files) from src/pages/posts/ into this new collection.\n\nCreate a src/content/config.ts file to define a schema for your postsCollection. For the existing blog tutorial code, add the following contents to the file to define all the frontmatter properties used in its blog posts:\n\nsrc/content/config.ts\n// Import utilities from `astro:content`\nimport { z, defineCollection } from \"astro:content\";\n// Define a `type` and `schema` for each collection\nconst postsCollection = defineCollection({\n    type: 'content',\n    schema: z.object({\n      title: z.string(),\n      pubDate: z.date(),\n      description: z.string(),\n      author: z.string(),\n      image: z.object({\n        url: z.string(),\n        alt: z.string()\n      }),\n      tags: z.array(z.string())\n    })\n});\n// Export a single `collections` object to register your collection(s)\nexport const collections = {\n  posts: postsCollection,\n};\nGenerate pages from a collection\nSection titled Generate pages from a collection\n\nCreate a page file called src/pages/posts/[...slug].astro. Your Markdown and MDX files no longer automatically become pages using Astro‚Äôs file-based routing when they are inside a collection, so you must create a page responsible for generating each individual blog post.\n\nAdd the following code to query your collection to make each blog post‚Äôs slug and page content available to each page it will generate:\n\nsrc/pages/posts/[...slug].astro\n---\nimport { getCollection } from 'astro:content';\nimport MarkdownPostLayout from '../../layouts/MarkdownPostLayout.astro';\n\n\nexport async function getStaticPaths() {\n  const blogEntries = await getCollection('posts');\n  return blogEntries.map(entry => ({\n    params: { slug: entry.slug }, props: { entry },\n  }));\n}\n\n\nconst { entry } = Astro.props;\nconst { Content } = await entry.render();\n---\n\nRender your post <Content /> within the layout for Markdown pages. This allows you to specify a common layout for all of your posts.\n\nsrc/pages/posts/[...slug].astro\n---\nimport { getCollection } from 'astro:content';\nimport MarkdownPostLayout from '../../layouts/MarkdownPostLayout.astro';\n\n\nexport async function getStaticPaths() {\n  const blogEntries = await getCollection('posts');\n  return blogEntries.map(entry => ({\n    params: { slug: entry.slug }, props: { entry },\n  }));\n}\n\n\nconst { entry } = Astro.props;\nconst { Content } = await entry.render();\n---\n<MarkdownPostLayout frontmatter={entry.data}>\n  <Content />\n</MarkdownPostLayout>\n\nRemove the layout definition in each individual post‚Äôs frontmatter. Your content is now wrapped in a layout when rendered, and this property is no longer needed.\n\nsrc/content/posts/post-1.md\n---\nlayout: ../../layouts/MarkdownPostLayout.astro\ntitle: 'My First Blog Post'\npubDate: 2022-07-01\n...\n---\nReplace Astro.glob() with getCollection()\nSection titled Replace Astro.glob() with getCollection()\n\nAnywhere you have a list of blog posts, like the tutorial‚Äôs Blog page (src/pages/blog.astro/), you will need to replace Astro.glob() with getCollection() as the way to fetch content and metadata from your Markdown files.\n\nsrc/pages/blog.astro\n---\nimport { getCollection } from \"astro:content\";\nimport BaseLayout from \"../layouts/BaseLayout.astro\";\nimport BlogPost from \"../components/BlogPost.astro\";\n\n\nconst pageTitle = \"My Astro Learning Blog\";\nconst allPosts = await Astro.glob(\"../pages/posts/*.md\");\nconst allPosts = await getCollection(\"posts\");\n---\n\nYou will also need to update references to the data returned for each post. You will now find your frontmatter values on the data property of each object. Also, when using collections each post object will have a page slug, not a full URL.\n\nsrc/pages/blog.astro\n---\nimport { getCollection } from \"astro:content\";\nimport BaseLayout from \"../layouts/BaseLayout.astro\";\nimport BlogPost from \"../components/BlogPost.astro\";\n\n\nconst pageTitle = \"My Astro Learning Blog\";\nconst allPosts = await getCollection(\"posts\");\n---\n<BaseLayout pageTitle={pageTitle}>\n  <p>This is where I will post about my journey learning Astro.</p>\n  <ul>\n    {\n      allPosts.map((post) => (\n        <BlogPost url={post.url} title={post.frontmatter.title} />)}\n        <BlogPost url={`/posts/${post.slug}/`} title={post.data.title} />\n      ))\n    }\n  </ul>\n</BaseLayout>\n\nThe tutorial blog project also dynamically generates a page for each tag using src/pages/tags/[tag].astro and displays a list of tags at src/pages/tags/index.astro.\n\nApply the same changes as above to these two files:\n\nfetch data about all your blog posts using getCollection(\"posts\") instead of using Astro.glob()\naccess all frontmatter values using data instead of frontmatter\ncreate a page URL by adding the post‚Äôs slug to the /posts/ path\n\nThe page that generates individual tag pages now becomes:\n\nsrc/pages/tags/[tag].astro\n---\nimport { getCollection } from \"astro:content\";\nimport BaseLayout from \"../../layouts/BaseLayout.astro\";\nimport BlogPost from \"../../components/BlogPost.astro\";\n\n\nexport async function getStaticPaths() {\n  const allPosts = await getCollection(\"posts\");\n  const uniqueTags = [...new Set(allPosts.map((post) => post.data.tags).flat())];\n\n\n  return uniqueTags.map((tag) => {\n    const filteredPosts = allPosts.filter((post) =>\n      post.data.tags.includes(tag)\n    );\n    return {\n      params: { tag },\n      props: { posts: filteredPosts },\n    };\n  });\n}\n\n\nconst { tag } = Astro.params;\nconst { posts } = Astro.props;\n---\n\n\n<BaseLayout pageTitle={tag}>\n    <p>Posts tagged with {tag}</p>\n    <ul>\n        { posts.map((post) => <BlogPost url={`/posts/${post.slug}/`} title={post.data.title} />) }\n    </ul>\n</BaseLayout>\nTry it yourself - Update the query in the Tag Index page\nSection titled Try it yourself - Update the query in the Tag Index page\n\nImport and use getCollection to fetch the tags used in the blog posts on src/pages/tags/index.astro, following the same steps as above.\n\nShow me the code.\nUpdate any frontmatter values to match your schema\nSection titled Update any frontmatter values to match your schema\n\nIf necessary, update any frontmatter values throughout your project, such as in your layout, that do not match your collections schema.\n\nIn the blog tutorial example, pubDate was a string. Now, according to the schema that defines types for the post frontmatter, pubDate will be a Date object.\n\nTo render the date in the blog post layout, convert it to a string:\n\nsrc/layouts/MarkdownPostLayout.astro\n...\n<BaseLayout pageTitle={frontmatter.title}>\n  <p>{frontmatter.pubDate.toString().slice(0,10)}</p>\n  <p><em>{frontmatter.description}</em></p>\n  <p>Written by: {frontmatter.author}</p>\n  <img src={frontmatter.image.url} width=\"300\" alt={frontmatter.image.alt} />\n...\nUpdate RSS function\nSection titled Update RSS function\n\nLastly, the tutorial blog project includes an RSS feed. This function must also use getCollection() to return information from your blog posts. You will then generate the RSS items using the data object returned.\n\nsrc/pages/rss.xml.js\nimport rss from '@astrojs/rss';\nimport { pagesGlobToRssItems } from '@astrojs/rss';\nimport { getCollection } from 'astro:content';\n\n\nexport async function GET(context) {\n  const posts = await getCollection(\"posts\");\n  return rss({\n    title: 'Astro Learner | Blog',\n    description: 'My journey learning Astro',\n    site: context.site,\n    items: await pagesGlobToRssItems(import.meta.glob('./**/*.md')),\n    items: posts.map((post) => ({\n      title: post.data.title,\n      pubDate: post.data.pubDate,\n      description: post.data.description,\n      link: `/posts/${post.slug}/`,\n    })),\n    customData: `<language>en-us</language>`,\n  })\n}\n\nFor the full example of the blog tutorial using content collections, see the Content Collections branch of the tutorial repo.\n\nBack\nBuild a Blog\nNext Page\nExtend with View Transitions"
  },
  {
    "title": "Build your first Astro Blog üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/tutorial/0-introduction/",
    "html": "0 ‚Ä¢ Welcome, world!\n\nBuild your first Astro Blog\n\nIn this tutorial, you‚Äôll learn Astro‚Äôs key features by building a fully-functioning blog, from zero to full launch! üöÄ\n\nAlong the way, you‚Äôll:\n\nSet up your development environment\nCreate pages and blog posts for your website\nBuild with Astro components\nQuery and work with local files\nAdd interactivity to your site\nDeploy your site to the web\n\nWant a preview of what you‚Äôre going to build? You can view the final project on GitHub or StackBlitz.\n\n NOTE\n\nIf you would rather start exploring Astro with a pre-built Astro site, you can visit https://astro.new and choose a starter template to open and edit in an online editor.\n\nChecklist\nSection titled Checklist\n Looks great! I‚Äôm ready to get started!\nNext Page\nAbout this Tutorial"
  },
  {
    "title": "Astro Islands üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/concepts/islands/",
    "html": "Astro Islands\n\nAstro pioneered and popularized a frontend architecture called Islands. Islands architecture results in better frontend performance by helping you avoid monolithic JavaScript patterns and stripping all non-essential JavaScript from the page automatically. Developers keep using their favorite UI components and frameworks with Astro and still get these benefits.\n\nA brief history\nSection titled A brief history\n\nThe term ‚Äúcomponent island‚Äù was first coined by Etsy‚Äôs frontend architect Katie Sylor-Miller in 2019. This idea was then expanded on and documented in this post by Preact creator Jason Miller on August 11, 2020.\n\nThe general idea of an ‚ÄúIslands‚Äù architecture is deceptively simple: render HTML pages on the server, and inject placeholders or slots around highly dynamic regions [‚Ä¶] that can then be ‚Äúhydrated‚Äù on the client into small self-contained widgets, reusing their server-rendered initial HTML.\n‚Äî Jason Miller, Creator of Preact\n\nThe technique that this architectural pattern builds on is also known as partial or selective hydration.\n\nIn contrast, most JavaScript-based web frameworks hydrate & render an entire website as one large JavaScript application (also known as a single-page application, or SPA). SPAs provide simplicity and power but suffer from page-load performance problems due to heavy client-side JavaScript usage.\n\nSPAs have their place, even embedded inside an Astro page. But, SPAs lack the native ability to selectively and strategically hydrate, making them a heavy-handed choice for most projects on the web today.\n\nAstro became popular as the first mainstream JavaScript web framework with selective hydration built-in, using that component islands pattern first coined by Sylor-Miller.\n\nWhat is an island?\nSection titled What is an island?\n\nIn Astro, an ‚Äúisland‚Äù refers to any interactive UI component on the page. Think of an island as an interactive widget floating in a sea of otherwise static, lightweight, server-rendered HTML.\n\nHeader (interactive island)\nSidebar (static HTML)\n\nStatic content like text, images, etc.\n\nImage carousel (interactive island)\nFooter (static HTML)\n\nSource: Islands Architecture: Jason Miller\n\nAn island always runs in isolation from other islands on the page, and multiple islands can exist on a page. Islands can still share state and communicate with each other, even though they run in different component contexts.\n\nThis flexibility allows Astro to support multiple supported UI frameworks like React, Preact, Svelte, Vue, and SolidJS. Because they are independent, you can even mix several frameworks on each page.\n\n TIP\n\nAlthough most developers will stick to just one UI framework, Astro supports multiple frameworks in the same project. This allows you to:\n\nChoose the framework that is best for each component.\nLearn a new framework without needing to start a new project.\nCollaborate with others even when working in different frameworks.\nIncrementally convert an existing site to another framework with no downtime.\nCreating an island\nSection titled Creating an island\n\nBy default, Astro will automatically render every UI component to just HTML & CSS, stripping out all client-side JavaScript automatically.\n\nsrc/pages/index.astro\n<MyReactComponent />\n\nThis may sound strict, but this behavior is what keeps Astro websites fast by default and protects developers from accidentally sending unnecessary or unwanted JavaScript that might slow down their website.\n\nTurning any static UI component into an interactive island requires only a client:* directive. Astro then automatically builds and bundles your client-side JavaScript for optimized performance.\n\nsrc/pages/index.astro\n<!-- This component is now interactive on the page!\n     The rest of your website remains static. -->\n<MyReactComponent client:load />\n\nWith islands, client-side JavaScript is only loaded for the explicit interactive components that you mark using client:* directives.\n\nAnd because interaction is configured at the component-level, you can handle different loading priorities for each component based on its usage. For example, client:idle tells a component to load when the browser becomes idle, and client:visible tells a component to load only once it enters the viewport.\n\nWhat are the benefits of Islands?\nSection titled What are the benefits of Islands?\n\nThe most obvious benefit of building with Astro Islands is performance: the majority of your website is converted to fast, static HTML and JavaScript is only loaded for the individual components that need it. JavaScript is one of the slowest assets that you can load per-byte, so every byte counts.\n\nAnother benefit is parallel loading. In the example illustration above, the low-priority ‚Äúimage carousel‚Äù island doesn‚Äôt need to block the high-priority ‚Äúheader‚Äù island. The two load in parallel and hydrate in isolation, meaning that the header becomes interactive immediately without having to wait for the heavier carousel lower down the page.\n\nEven better, you can tell Astro exactly how and when to render each component. If that image carousel is really expensive to load, you can attach a special client directive that tells Astro to only load the carousel when it becomes visible on the page. If the user never sees it, it never loads.\n\nIn Astro, it‚Äôs up to you as the developer to explicitly tell Astro which components on the page need to also run in the browser. Astro will only hydrate exactly what‚Äôs needed on the page and leave the rest of your site as static HTML.\n\nIslands are the secret to Astro‚Äôs fast-by-default performance story!\n\nBack\nWhy Astro\nNext Page\nBuild a Blog"
  },
  {
    "title": "Why Astro? üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/concepts/why-astro/",
    "html": "Why Astro?\n\nAstro is the web framework for building content-driven websites like blogs, marketing, and e-commerce. Astro is best-known for pioneering a new frontend architecture to reduce JavaScript overhead and complexity compared to other frameworks. If you need a website that loads fast and has great SEO, then Astro is for you.\n\nFeatures\nSection titled Features\n\nAstro is an all-in-one web framework. It includes everything you need to create a website, built-in. There are also hundreds of different integrations and API hooks available to customize a project to your exact use case and needs.\n\nSome highlights include:\n\nIslands: A component-based web architecture optimized for content-driven websites.\nUI-agnostic: Supports React, Preact, Svelte, Vue, Solid, Lit, HTMX, web components, and more.\nServer-first: Moves expensive rendering off of your visitors‚Äô devices.\nZero JS, by default: Less client-side JavaScript to slow your site down.\nContent collections: Organize, validate, and provide TypeScript type-safety for your Markdown content.\nCustomizable: Tailwind, MDX, and hundreds of integrations to choose from.\nDesign Principles\nSection titled Design Principles\n\nHere are five core design principles to help explain why we built Astro, the problems that it exists to solve, and why Astro may be the best choice for your project or team.\n\nAstro is‚Ä¶\n\nContent-driven: Astro was designed to showcase your content.\nServer-first: Websites run faster when they render HTML on the server.\nFast by default: It should be impossible to build a slow website in Astro.\nEasy to use: You don‚Äôt need to be an expert to build something with Astro.\nDeveloper-focused: You should have the resources you need to be successful.\nContent-driven\nSection titled Content-driven\n\nAstro was designed for building content-rich websites. This includes marketing sites, publishing sites, documentation sites, blogs, portfolios, landing pages, community sites, and e-commerce sites. If you have content to show, it needs to reach your reader quickly.\n\nBy contrast, most modern web frameworks were designed for building web applications. These frameworks excel at building more complex, application-like experiences in the browser: logged-in admin dashboards, inboxes, social networks, todo lists, and even native-like applications like Figma and Ping. However with that complexity, they can struggle to provide great performance when delivering your content.\n\nAstro‚Äôs focus on content from its beginnings as a static site builder have allowed Astro to sensibly scale up to performant, powerful, dynamic web applications that still respect your content and your audience. Astro‚Äôs unique focus on content lets Astro make tradeoffs and deliver unmatched performance features that wouldn‚Äôt make sense for more application-focused web frameworks to implement.\n\nServer-first\nSection titled Server-first\n\nAstro leverages server-rendering over client-side rendering in the browser as much as possible. This is the same approach that traditional server-side frameworks -- PHP, WordPress, Laravel, Ruby on Rails, etc. -- have been using for decades. But you don‚Äôt need to learn a second server-side language to unlock it. With Astro, everything is still just HTML, CSS, and JavaScript (or TypeScript, if you prefer).\n\nThis approach stands in contrast to other modern JavaScript web frameworks like Next.js, SvelteKit, Nuxt, Remix, and others. These frameworks were built for client-side rendering of your entire website and include server-side rendering mainly to address performance concerns. This approach has been dubbed the Single-Page App (SPA), in contrast with Astro‚Äôs Multi-Page App (MPA) approach.\n\nThe SPA model has its benefits. However, these come at the expense of additional complexity and performance tradeoffs. These tradeoffs harm page performance -- critical metrics like Time to Interactive (TTI) -- which doesn‚Äôt make much sense for content-focused websites where first-load performance is essential.\n\nAstro‚Äôs server-first approach allows you to opt in to client-side rendering only if, and exactly as, necessary. You can choose to add UI framework components that run on the client. You can take advantage of Astro‚Äôs view transitions router for finer control over select page transitions and animations. Astro‚Äôs server-first rendering, either pre-rendered or on-demand, provides performant defaults that you can enhance and extend.\n\nFast by default\nSection titled Fast by default\n\nGood performance is always important, but it is especially critical for websites whose success depends on displaying your content. It has been well-proven that poor performance loses you engagement, conversions, and money. For example:\n\nEvery 100ms faster ‚Üí 1% more conversions (Mobify, earning +$380,000/yr)\n50% faster ‚Üí 12% more sales (AutoAnything)\n20% faster ‚Üí 10% more conversions (Furniture Village)\n40% faster ‚Üí 15% more sign-ups (Pinterest)\n850ms faster ‚Üí 7% more conversions (COOK)\nEvery 1 second slower ‚Üí 10% fewer users (BBC)\n\nIn many web frameworks, it is easy to build a website that looks great during development only to load painfully slow once deployed. JavaScript is often the culprit, since many phones and lower-powered devices rarely match the speed of a developer‚Äôs laptop.\n\nAstro‚Äôs magic is in how it combines the two values explained above -- a content focus with a server-first architecture -- to make tradeoffs and deliver features that other frameworks cannot. The result is amazing web performance for every website, out of the box. Our goal: It should be nearly impossible to build a slow website with Astro.\n\nAn Astro website can load 40% faster with 90% less JavaScript than the same site built with the most popular React web framework. But don‚Äôt take our word for it: watch Astro‚Äôs performance leave Ryan Carniato (creator of Solid.js and Marko) speechless.\n\nEasy to use\nSection titled Easy to use\n\nAstro‚Äôs goal is to be accessible to every web developer. Astro was designed to feel familiar and approachable regardless of skill level or past experience with web development.\n\nThe .astro UI language is a superset of HTML: any valid HTML is valid Astro templating syntax! So, if you can write HTML, you can write Astro components! But, it also combines some of our favorite features borrowed from other component languages like JSX expressions (React) and CSS scoping by default (Svelte and Vue). This closeness to HTML also makes it easier to use progressive enhancement and common accessibility patterns without any overhead.\n\nWe then made sure that you could also use your favorite UI component languages that you already know, and even reuse components you might already have. React, Preact, Svelte, Vue, Solid, Lit, and others, including web components, are all supported for authoring UI components in an Astro project.\n\nAstro was designed to be less complex than other UI frameworks and languages. One big reason for this is that Astro was designed to render on the server, not in the browser. That means that you don‚Äôt need to worry about: hooks (React), stale closures (also React), refs (Vue), observables (Svelte), atoms, selectors, reactions, or derivations. There is no reactivity on the server, so all of that complexity melts away.\n\nOne of our favorite sayings is: opt in to complexity. We designed Astro to remove as much ‚Äúrequired complexity‚Äù as possible from the developer experience, especially as you onboard for the first time. You can build a ‚ÄúHello World‚Äù example website in Astro with just HTML and CSS. Then, when you need to build something more powerful, you can incrementally reach for new features and APIs as you go.\n\nDeveloper-focused\nSection titled Developer-focused\n\nWe strongly believe that Astro is only a successful project if people love using it. Astro has everything you need to support you as you build with Astro.\n\nAstro invests in developer tools like a great CLI experience from the moment you open your terminal, an official VS Code extension for syntax highlighting, TypeScript and Intellisense, and documentation actively maintained by hundreds of community contributors and available in 14 languages.\n\nOur welcoming, respectful, inclusive community on Discord is ready to provide support, motivation, and encouragement. Open a #support thread to get help with your project. Visit our dedicated #showcase channel for sharing your Astro sites, blog posts, videos, and even work-in-progress for safe feedback and constructive criticism. Participate in regular live events such as our weekly community call, ‚ÄúTalking and Doc‚Äôing,‚Äù and API/bug bashes.\n\nAs an open-source project, we welcome contributions of all types and sizes from community members of all experience levels. You are invited to join in roadmap discussions to shape the future of Astro, and we hope you‚Äôll contribute fixes and features to the core codebase, compiler, docs, language tools, websites, and other projects.\n\nBack\nUpgrade to v3\nNext Page\nAstro Islands"
  },
  {
    "title": "Upgrade to Astro v3 üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/guides/upgrade-to/v3/",
    "html": "Upgrade to Astro v3\n\nThis guide will help you migrate from Astro v2 to Astro v3.\n\nNeed to upgrade an older project to v2? See our older migration guide.\n\nUpgrade Astro\nSection titled Upgrade Astro\n\nUpdate your project‚Äôs version of Astro to the latest version using your package manager. If you‚Äôre using Astro integrations, please also update those to the latest version.\n\nnpm\npnpm\nYarn\nTerminal window\n# Upgrade to Astro v3.x\nnpm install astro@latest\n\n\n# Example: upgrade React and Tailwind integrations\nnpm install @astrojs/react@latest @astrojs/tailwind@latest\n\n NEED TO CONTINUE?\n\nAfter upgrading Astro to the latest version, you may not need to make any changes to your project at all!\n\nBut, if you notice errors or unexpected behavior, please check below for what has changed that might need updating in your project.\n\nAstro v3.0 Experimental Flags Removed\nSection titled Astro v3.0 Experimental Flags Removed\n\nRemove the following experimental flags from astro.config.mjs:\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\n\n\nexport default defineConfig({\n  experimental: {\n    assets: true,\n    viewTransitions: true,\n  },\n})\n\nThese features are now available by default:\n\nView Transitions for animated page transitions and persistent islands. See view transitions API breaking changes and upgrading advice if you were using this experimental flag.\nA new image services API astro:assets for using images in Astro, including a new <Image /> component and getImage() function. Please read the detailed image upgrade advice whether or not you were using this experimental flag to see how this might affect your project.\n\nRead more about these two exciting features and more in the 3.0 Blog post!\n\nAstro v3.0 Breaking Changes\nSection titled Astro v3.0 Breaking Changes\n\nAstro v3.0 includes some breaking changes, as well as the removal of some previously deprecated features. If your project doesn‚Äôt work as expected after upgrading to v3.0, check this guide for an overview of all breaking changes and instructions on how to update your codebase.\n\nSee the changelog for full release notes.\n\nRemoved: Support for Node 16\nSection titled Removed: Support for Node 16\n\nNode 16 is scheduled to reach its End of Life in September 2023.\n\nAstro v3.0 drops Node 16 support entirely so that all Astro users can take advantage of Node‚Äôs more modern features.\n\nWhat should I do?\nSection titled What should I do?\n\nCheck that both your development environment and your deployment environment are using Node 18.14.1 or higher.\n\nCheck your local version of Node using:\n\nTerminal window\nnode -v\n\nCheck your deployment environment‚Äôs own documentation to verify that they support Node 18.\n\nYou can specify Node 18.14.1 for your Astro project either in a dashboard configuration setting or a .nvmrc file.\n\n.nvmrc\n18.14.1\nRemoved: Support for TypeScript 4\nSection titled Removed: Support for TypeScript 4\n\nIn Astro v2.x, the tsconfig.json presets include support for both TypeScript 4.x and 5.x.\n\nAstro v3.0 updates the tsconfig.json presets to only support TypeScript 5.x. Astro now assumes that you use TypeScript 5.0 (March 2023), or that your editor includes it (e.g. VS Code 1.77).\n\nWhat should I do?\nSection titled What should I do?\n\nIf you have installed TypeScript locally, update to at least v5.0.\n\nTerminal window\nnpm install typescript@latest --save-dev\nRemoved: @astrojs/image\nSection titled Removed: @astrojs/image\n\nIn Astro v2.x, Astro offered an official image integration that included Astro <Image /> and <Picture /> components.\n\nAstro v3.0 removes this integration from the codebase entirely. Astro‚Äôs new solution for images is a built-in image services API: astro:assets.\n\nWhat should I do?\nSection titled What should I do?\n\nRemove the @astrojs/image integration from your project. You will need to not only uninstall the integration but also update or remove any import statements and existing <Image /> and <Picture /> components. You might also need to configure a preferred default image processing service.\n\nYou will find complete, step-by-step instructions for removing the old image integration in our Images guide.\n\nMigrating to astro:assets will also bring some new image options and features that you may now wish to use. Please see the full v3.0 Image Upgrade Advice for full details!\n\nastro.config.mjs\nimport { defineConfig } from 'astro/config';\nimport image from '@astrojs/image';\n\n\nexport default defineConfig({\n  integrations: [\n    image(),\n  ]\n})\nRemoved: <Markdown /> component\nSection titled Removed: &lt;Markdown /&gt; component\n\nIn Astro v1.x, Astro deprecated the <Markdown /> component and moved it to an external package.\n\nAstro v3.0 completely removes the package @astrojs/markdown-component. Astro‚Äôs <Markdown /> component will no longer work in your project.\n\nWhat should I do?\nSection titled What should I do?\n\nRemove all instances of the @astrojs/markdown-component.\n\nsrc/components/MyAstroComponent.astro\n---\nimport Markdown from '@astrojs/markdown-component';\n---\n\nTo continue using a similar <Markdown /> component in your code, consider using community integrations such as astro-remote. Be sure to update your <Markdown /> component imports and attributes as necessary, according to the integration‚Äôs own documentation.\n\nOtherwise, delete all references to importing Astro‚Äôs <Markdown /> component and the component itself in your .astro files. You will need to rewrite your content as HTML directly or import Markdown from a .md file.\n\nRemoved: deprecated 1.x APIs\nSection titled Removed: deprecated 1.x APIs\n\nIn Astro v1.x, Astro deprecated our original configuration settings as well as <style global> and <script hoist> support. However, these were still supported for backwards compatibility.\n\nAstro v3.0 removes these deprecated APIs entirely. The officially supported configuration settings and modern <style is:global> and <script> syntax should be used instead.\n\nWhat should I do?\nSection titled What should I do?\n\nIf you are continuing to use v1.x APIs, use the new APIs for each feature instead:\n\nDeprecated config options: See the 0.26 migration guide\nDeprecated script/style attribute types: See the 0.26 migration guide\nRemoved: Partial shims for Web APIs in server code\nSection titled Removed: Partial shims for Web APIs in server code\n\nIn Astro v2.x, Astro provided partial shims for Web APIs such as document or localStorage in server-rendered code. These shims were often incomplete and unreliable.\n\nAstro v3.0 removes these partial shims entirely. Web APIs are no longer available in server-rendered code.\n\nWhat should I do?\nSection titled What should I do?\n\nIf you are using Web APIs in server-rendered components, you will need to either make the usage of those APIs conditional or use the client:only client directive.\n\nRemoved: image from astro:content in content collections schema\nSection titled Removed: image from astro:content in content collections schema\n\nIn Astro v2.x, the content collections API deprecated an image export from astro:content for use in your content collections schemas.\n\nAstro v3.0 removes this export entirely.\n\nWhat should I do?\nSection titled What should I do?\n\nIf you are using the deprecated image() from astro:content, remove it as this no longer exists. Validate images through the image helper from schema instead:\n\nsrc/content/config.ts\nimport { defineCollection, z, image } from \"astro:content\";\nimport { defineCollection, z } from \"astro:content\";\n\n\ndefineCollection({\n  schema: ({ image }) =>\n    z.object({\n      image: image(),\n   }),\n});\nRemoved: pre-0.14 Shiki theme names\nSection titled Removed: pre-0.14 Shiki theme names\n\nIn Astro v2.x, some Shiki theme names had been renamed, but the original names were kept for backwards compatibility.\n\nAstro v3.0 removes the original names in favor of the renamed theme names.\n\nWhat should I do?\nSection titled What should I do?\n\nIf your project uses any of the themes below, rename them to their updated name:\n\nmaterial-darker -> material-theme-darker\nmaterial-default -> material-theme\nmaterial-lighter -> material-theme-lighter\nmaterial-ocean -> material-theme-ocean\nmaterial-palenight -> material-theme-palenight\nRemoved: class:list features\nSection titled Removed: class:list features\n\nIn Astro v2.x, the class:list directive used a custom implementation inspired by clsx with a few extra features like deduplication and Set support.\n\nAstro v3.0 now uses clsx directly for class:list, which does not support deduplication or Set values.\n\nWhat should I do?\nSection titled What should I do?\n\nReplace any Set elements passed to the class:list directive with a plain Array.\n\nsrc/components/MyAstroComponent.astro\n<Component class:list={[\n  'a',\n  'b',\n  new Set(['c', 'd'])\n  ['c', 'd']\n]} />\nRemoved: passing class:list as a prop\nSection titled Removed: passing class:list as a prop\n\nIn Astro v2.x, class:list values were sent to components via Astro.props['class:list'].\n\nAstro v3.0 normalizes class:list values into a string before being sent to components via Astro.props['class']\n\nWhat should I do?\nSection titled What should I do?\n\nRemove any code that expects to receive the class:list prop.\n\nsrc/components/MyAstroComponent.astro\n---\nimport { clsx } from 'clsx';\nconst { class: className, 'class:list': classList } = Astro.props;\nconst { class: className } = Astro.props;\n---\n<div\n  class:list={[className, classList]}\n  class:list={[className]}\n/>\nRemoved: kebab-case transform for camelCase CSS variables\nSection titled Removed: kebab-case transform for camelCase CSS variables\n\nIn Astro v2.x, camelCase CSS variables passed to the style attribute were rendered as both camelCase (as written) and kebab-case (kept for backwards compatibility).\n\nAstro v3.0 removes the kebab-case transform for these camelCase CSS variable names, and only the original camelCase CSS variable is rendered.\n\nsrc/components/MyAstroComponent.astro\n---\nconst myValue = \"red\"\n---\n<!-- input -->\n<div style={{ \"--myValue\": myValue }}></div>\n\n\n<!-- output (Astro 2.x) -->\n<div style=\"--my-value:var(--myValue);--myValue:red\"></div>\n<!-- output (Astro 3.0) -->\n<div style=\"--myValue:red\"></div>\nWhat should I do?\nSection titled What should I do?\n\nIf you were relying on Astro to transform kebab-case in your styles, update your existing styles to camelCase to prevent missing styles. For example:\n\nsrc/components/MyAstroComponent.astro\n<style>\n  div {\n   color: var(--my-value);\n   color: var(--myValue);\n  }\n</style>\nRemoved: automatic flattening of getStaticPaths()‚Äôs return value\nSection titled Removed: automatic flattening of getStaticPaths()‚Äôs return value\n\nIn Astro v2.x, the return value of getStaticPaths() was automatically flattened to allow you to return an array of arrays without errors.\n\nAstro v3.0 removes automatic flattening of getStaticPaths()‚Äôs result.\n\nWhat should I do?\nSection titled What should I do?\n\nIf you‚Äôre returning an array of arrays instead of an array of objects (as is expected), .flatMap and .flat should now be used to ensure that you are returning a flat array.\n\nAn error message indicating that getStaticPath()‚Äôs return value must be an array of objects will be provided if you need to update your code.\n\nMoved: astro check now requires an external package\nSection titled Moved: astro check now requires an external package\n\nIn Astro v2.x, astro check was included in Astro by default, and its dependencies were bundled in Astro. This meant a larger package whether or not you ever used astro check. This also prevented you from having control over the version of TypeScript and the Astro Language Server to use.\n\nAstro v3.0 moves the astro check command out of Astro core and now requires an external package @astrojs/check. Additionally, you must install typescript in your project to use the astro check command.\n\nWhat should I do?\nSection titled What should I do?\n\nRun the astro check command after upgrading to Astro v3.0 and follow the prompts to install the required dependencies, or manually install @astrojs/check and typescript into your project.\n\nDeprecated: build.excludeMiddleware and build.split\nSection titled Deprecated: build.excludeMiddleware and build.split\n\nIn Astro v2.x, build.excludeMiddleware and build.split were used to change how specific files were emitted when using an adapter in SSR mode.\n\nAstro v3.0 replaces these build config options with new SSR adapter configuration options to perform the same tasks: edgeMiddleware and functionPerRoute.\n\nWhat should I do?\nSection titled What should I do?\n\nUpdate the Astro config file to now use the new options in the adapter configuration directly.\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\nimport vercel from \"@astrojs/vercel/serverless\";\n\n\nexport default defineConfig({\n    build: {\n      excludeMiddleware: true\n    },\n    adapter: vercel({\n      edgeMiddleware: true\n    }),\n});\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\nimport netlify from \"@astrojs/netlify/functions\";\n\n\nexport default defineConfig({\n     build: {\n        split: true\n     },\n     adapter: netlify({\n        functionPerRoute: true\n     }),\n});\nDeprecated: markdown.drafts\nSection titled Deprecated: markdown.drafts\n\nIn Astro v2.x, the markdown.drafts configuration allowed you to have draft pages that were available in when running the dev server, but not built in production.\n\nAstro v3.0 deprecates this feature in favor of the content collections method of handling draft pages by filtering manually instead, which gives more control over the feature.\n\nWhat should I do?\nSection titled What should I do?\n\nTo continue to mark some pages in your project as drafts, migrate to content collections and manually filter out pages with the draft: true frontmatter property instead.\n\nDeprecated: returning simple object in endpoints\nSection titled Deprecated: returning simple object in endpoints\n\nIn Astro v2.x, endpoints could return a simple object, which would be converted to a JSON response.\n\nAstro v3.0 deprecates this behavior in favor of returning a Response object directly.\n\nWhat should I do?\nSection titled What should I do?\n\nUpdate your endpoints to return a Response object directly.\n\nendpoint.json.ts\nexport async function GET() {\n  return { body: { \"title\": \"Bob's blog\" }};\n  return new Response(JSON.stringify({ \"title\": \"Bob's blog\" }));\n}\n\nIf you really need to keep the previous format, you can use the ResponseWithEncoding object but will be deprecated in the future.\n\nendpoint.json.ts\nexport async function GET() {\n  return { body: { \"title\": \"Bob's blog\" } };\n  return new ResponseWithEncoding({ body: { \"title\": \"Bob's blog\" }});\n}\nChanged default: verbatimModuleSyntax in tsconfig.json presets\nSection titled Changed default: verbatimModuleSyntax in tsconfig.json presets\n\nIn Astro v2.x, the verbatimModuleSyntax setting was off by default, with its TypeScript 4.x equivalent importsNotUsedAsValues being enabled in the strict preset.\n\nIn Astro v3.0, verbatimModuleSyntax is enabled in every preset.\n\nWhat should I do?\nSection titled What should I do?\n\nThis option requires that types are imported using the import type syntax.\n\nsrc/components/MyAstroComponent.astro\n---\nimport { type CollectionEntry, getEntry } from \"astro:content\";\n---\n\nWhile we recommend keeping it on and properly making your type imports with type (as shown above), you can disable it by setting verbatimModuleSyntax: false in your tsconfig.json file if it causes any issues.\n\ntsconfig.json\n{\n  \"compilerOptions\": {\n    \"verbatimModuleSyntax\": false\n  }\n}\nChanged default: port 3000\nSection titled Changed default: port 3000\n\nIn Astro v2.x, Astro ran on port 3000 by default.\n\nAstro v3.0 changes the default port to 4321. üöÄ\n\nWhat should I do?\nSection titled What should I do?\n\nUpdate any existing references to localhost:3000, for example in tests or in your README, to reflect the new port localhost:4321.\n\nChanged default: import.meta.env.BASE_URL trailingSlash\nSection titled Changed default: import.meta.env.BASE_URL trailingSlash\n\nIn Astro v2.x, import.meta.env.BASE_URL appended your base setting with a trailingSlash by default. trailingSlash: \"ignore\" also appended a trailing slash.\n\nAstro v3.0 no longer appends import.meta.env.BASE_URL with a trailing slash by default, nor when trailingSlash: \"ignore\" is set. (The existing behavior of base in combination with trailingSlash: \"always\" or trailingSlash: \"never\" is unchanged.)\n\nWhat should I do?\nSection titled What should I do?\n\nIf your base already has a trailing slash, no change is needed.\n\nIf your base does not have a trailing slash, add one if you wish to preserve the previous default (or trailingSlash: \"ignore\") behavior:\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\n\n\nexport default defineConfig({\n  base: 'my-base',\n  base: 'my-base/',\n});\nChanged default: compressHTML\nSection titled Changed default: compressHTML\n\nIn Astro v2.x, Astro only compressed your emitted HTML when compressHTML was explicitly set to true. The default value was false.\n\nAstro v3.0 now compresses emitted HTML by default.\n\nWhat should I do?\nSection titled What should I do?\n\nYou can now remove compressHTML: true from your configuration as this is the new default behavior.\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\n\n\nexport default defineConfig({\n  compressHTML: true\n})\n\nYou must now set compressHTML: false to opt out of HTML compression.\n\nChanged default: scopedStyleStrategy\nSection titled Changed default: scopedStyleStrategy\n\nIn Astro v2.x, the default value of scopedStyleStrategy was \"where\".\n\nAstro v3.0 introduces a new, default value: \"attribute\". By default, styles are now applied using data-* attributes.\n\nWhat should I do?\nSection titled What should I do?\n\nTo retain your project‚Äôs current style scoping, update the configuration file to the previous default value:\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\n\n\nexport default defineConfig({\n  scopedStyleStrategy: \"where\"\n})\nChanged default: inlineStyleSheets\nSection titled Changed default: inlineStyleSheets\n\nIn Astro v2.x, all project stylesheets were sent as link tags by default. You could opt in to inlining them into <style> tags every time with \"always\", or to inlining only stylesheets below a certain size with \"auto\" by setting the build.inlineStylesheets configuration. The default setting was \"never\".\n\nAstro v3.0 changes the default value of inlineStylesheets to \"auto\". Stylesheets smaller than ViteConfig.build.assetsInlineLimit (default: 4kb) are inlined by default. Otherwise, project styles are sent in external stylesheets.\n\nWhat should I do?\nSection titled What should I do?\n\nIf you want to keep your project‚Äôs current behavior, set build.inlineStylesheets to the previous default, \"never\":\n\nastro.config.mjs\nimport { defineConfig } from \"astro/config\";\n\n\nexport default defineConfig({\n   build: {\n    inlineStylesheets: \"never\"\n  }\n})\nChanged default: image service\nSection titled Changed default: image service\n\nIn Astro v2.x, Squoosh was the default image processing service.\n\nAstro v3.0 now includes Sharp as the default image processing service and instead provides a configuration option to use Squoosh.\n\nWhat should I do?\nSection titled What should I do?\n\n NOTE\n\nWhen using a strict package manager like pnpm, you may need to manually install Sharp into your project even though it is an Astro dependency:\n\nTerminal window\npnpm add sharp\n\nIf you would prefer to continue to use Squoosh to transform your images, update your config with the following:\n\nastro.config.mjs\nimport { defineConfig, squooshImageService } from \"astro/config\";\n\n\nexport default defineConfig({\n  image: {\n    service: squooshImageService(),\n  }\n})\nChanged: HTTP request methods case\nSection titled Changed: HTTP request methods case\n\nIn Astro v2.x, HTTP request methods were written using lowercase function names: get, post, put, all, and del.\n\nAstro v3.0 uses uppercase function names, including DELETE instead of del.\n\nWhat should I do?\nSection titled What should I do?\n\nRename all functions to their uppercase equivalent:\n\nget to GET\npost to POST\nput to PUT\nall to ALL\ndel to DELETE\nendpoint.ts\nexport function get() {\nexport function GET() {\n    return new Response(JSON.stringify({ \"title\": \"Bob's blog\" }));\n}\nChanged: Multiple JSX framework configuration\nSection titled Changed: Multiple JSX framework configuration\n\nIn Astro v2.x, you could use multiple JSX framework integrations (React, Solid, Preact) in the same project without needing to identify which files belonged to which framework.\n\nAstro v3.0 now requires you to specify which framework to use for your files with new include and exclude integration config options when you have multiple JSX framework integrations installed. This allows Astro to better support single-framework usage, as well as advanced features like React Fast Refresh.\n\nWhat should I do?\nSection titled What should I do?\n\nIf you are using multiple JSX frameworks in the same project, set include (and optionally exclude) to an array of files and/or folders. Wildcards may be used to include multiple file paths.\n\nWe recommend placing common framework components in the same folder (e.g. /components/react/ and /components/solid/) to make specifying your includes easier, but this is not required:\n\nimport { defineConfig } from 'astro/config';\nimport preact from '@astrojs/preact';\nimport react from '@astrojs/react';\nimport svelte from '@astrojs/svelte';\nimport vue from '@astrojs/vue';\nimport solid from '@astrojs/solid-js';\n\n\nexport default defineConfig({\n  // Enable many frameworks to support all different kinds of components.\n  // No `include` is needed if you are only using a single framework!\n  integrations: [\n    preact({\n      include: ['**/preact/*']\n    }),\n    react({\n      include: ['**/react/*']\n    }),\n    solid({\n      include: ['**/solid/*'],\n    }),\n  ]\n});\nChanged: Astro.cookies.get(key) can return undefined\nSection titled Changed: Astro.cookies.get(key) can return undefined\n\nIn Astro v2.x, Astro.cookies.get(key) would always return an AstroCookie object, even if the cookie did not exist. To check for its existence, you needed to use Astro.cookies.has(key).\n\nAstro v3.0 returns undefined for Astro.cookies.get(key) if the cookie does not exist.\n\nWhat should I do?\nSection titled What should I do?\n\nThis change will not break any code that checks for the existence of the Astro.cookie object before using Astro.cookies.get(key), but is now no longer required.\n\nYou can safely remove any code that uses has() to check if the value of Astro.cookies is undefined:\n\nif (Astro.cookies.has(id)) {\n  const id = Astro.cookies.get(id)!;\n}\n\n\nconst id = Astro.cookies.get(id);\nif (id) {\n}\nChanged: running the Astro CLI programmatically\nSection titled Changed: running the Astro CLI programmatically\n\nIn Astro v2.x, the \"astro\" package entrypoint exported and ran the Astro CLI directly. It is not recommended to run Astro this way in practice.\n\nAstro v3.0 removes the CLI from the entrypoint, and exports a new set of experimental JavaScript APIs, including dev(), build(), preview(), and sync().\n\nWhat should I do?\nSection titled What should I do?\n\nTo run the Astro CLI programatically, use the new experimental JavaScript APIs:\n\nimport { dev, build } from \"astro\";\n\n\n// Start the Astro dev server\nconst devServer = await dev();\nawait devServer.stop();\n\n\n// Build your Astro project\nawait build();\nChanged: internal Astro API entry point export paths\nSection titled Changed: internal Astro API entry point export paths\n\nIn Astro v2.x, you could import internal Astro APIs from astro/internal/* and astro/runtime/server/*.\n\nAstro v3.0 removes the two entry points in favor of the existing astro/runtime/* entrypoint. Additionally, a new astro/compiler-runtime export has been added for compiler-specific runtime code.\n\nWhat should I do?\nSection titled What should I do?\n\nThese are entry points for Astro‚Äôs internal API and should not affect your project. But if you do use these entrypoints, update as shown below:\n\nimport 'astro/internal/index.js';\nimport 'astro/runtime/server/index.js';\n\n\nimport 'astro/server/index.js';\nimport 'astro/runtime/server/index.js';\nimport { transform } from '@astrojs/compiler';\n\n\nconst result = await transform(source, {\n  internalURL: 'astro/runtime/server/index.js',\n  internalURL: 'astro/compiler-runtime',\n  // ...\n});\nCommunity Resources\nSection titled Community Resources\n\nKnow a good resource for Astro v3.0?"
  },
  {
    "title": "Editor Setup üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/editor-setup/",
    "html": "Editor Setup\n\nCustomize your code editor to improve the Astro developer experience and unlock new features.\n\nVS Code\nSection titled VS Code\n\nVS Code is a popular code editor for web developers, built by Microsoft. The VS Code engine also powers popular in-browser code editors like GitHub Codespaces and Gitpod.\n\nAstro works with any code editor. However, VS Code is our recommended editor for Astro projects. We maintain an official Astro VS Code Extension that unlocks several key features and developer experience improvements for Astro projects.\n\nSyntax highlighting for .astro files.\nTypeScript type information for .astro files.\nVS Code Intellisense for code completion, hints and more.\n\nTo get started, install the Astro VS Code Extension today.\n\nüìö See how to set up TypeScript in your Astro project.\n\nJetBrains IDEs\nSection titled JetBrains IDEs\n\nInitial support for Astro landed in WebStorm 2023.1. You can install the official plugin through JetBrains Marketplace or by searching for ‚ÄúAstro‚Äù in the IDE‚Äôs Plugins tab. This plugin includes features like syntax highlighting, code completion, and formatting, and plans to add even more advanced features in the future. It is also available to all other JetBrains IDEs with JavaScript support.\n\nJetBrains‚Äô upcoming Fleet IDE includes language server support and will be able to use the official Astro tooling.\n\nOther Code Editors\nSection titled Other Code Editors\n\nOur amazing community maintains several extensions for other popular editors, including:\n\nVS Code Extension on Open VSX OFFICIAL - The official Astro VS Code Extension, available on the Open VSX registry for open platforms like VSCodium\nNova Extension COMMUNITY - Provides syntax highlighting and code completion for Astro inside of Nova\nVim Plugin COMMUNITY - Provides syntax highlighting, indentation, and code folding support for Astro inside of Vim or Neovim\nNeovim LSP and TreeSitter Plugins COMMUNITY - Provides syntax highlighting, treesitter parsing, and code completion for Astro inside of Neovim\nEmacs - See instructions for Configuring Emacs and Eglot COMMUNITY to work with Astro\nIn-Browser Editors\nSection titled In-Browser Editors\n\nIn addition to local editors, Astro also runs well on in-browser hosted editors, including:\n\nStackBlitz and CodeSandbox - online editors that run in your browser, with built-in syntax highlighting support for .astro files. No installation or configuration required!\nGitHub.dev - allows you to install the Astro VS Code extension as a web extension, which gives you access to only some of the full extension features. Currently, only syntax highlighting is supported.\nGitpod - a full dev environment in the cloud that can install the official Astro VS Code Extension from Open VSX.\nOther tools\nSection titled Other tools\nESLint\nSection titled ESLint\n\nESLint is a popular linter for JavaScript and JSX. For Astro support, a community maintained plugin can be installed.\n\nSee the project‚Äôs User Guide for more information on how to install and set up ESLint for your project.\n\nStylelint\nSection titled Stylelint\n\nStylelint is a popular linter for CSS. A community maintained Stylelint configuration provides Astro support.\n\nInstallation instructions, editor integration, and additional information can be found in the project‚Äôs README.\n\nPrettier\nSection titled Prettier\n\nPrettier is a popular formatter for JavaScript, HTML, CSS, and more. If you‚Äôre using the Astro VS Code Extension or the Astro language server within another editor, code formatting with Prettier is included.\n\nTo add support for formatting .astro files outside of the editor (e.g. CLI) or inside editors that don‚Äôt support our editor tooling, install the official Astro Prettier plugin.\n\nTo get started, first install Prettier and the plugin:\n\nnpm\npnpm\nYarn\nTerminal window\nnpm install --save-dev prettier prettier-plugin-astro\n\nPrettier will then automatically detect the plugin and use it to process .astro files when you run it:\n\nTerminal window\nprettier --write .\n\nSee the Prettier plugin‚Äôs README for more information about its supported options, how to set up Prettier inside VS Code, and more.\n\n USING WITH PNPM\n\nDue to upstream issues inside Prettier, the plugin will not be automatically detected when using pnpm. In order to make it find the plugin, the following parameter needs to be added when running Prettier:\n\nTerminal window\nprettier --write . --plugin=prettier-plugin-astro\n\nAdditional settings are also required when using Prettier inside VS Code. See the plugin‚Äôs README for more information.\n\nBack\nInstallation\nNext Page\nUpgrade to v3"
  },
  {
    "title": "Install Astro with the Automatic CLI üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/install/auto/",
    "html": "Install Astro with the Automatic CLI\n\nReady to install Astro? Follow this guide to using the create astro CLI to get started.\n\n PREFER TO INSTALL ASTRO MANUALLY?\n\nRead our step-by-step manual installation guide instead.\n\nPrerequisites\nSection titled Prerequisites\nNode.js - v18.14.1 or higher.\nText editor - We recommend VS Code with our Official Astro extension.\nTerminal - Astro is accessed through its command-line interface (CLI).\nInstallation\nSection titled Installation\n\ncreate astro is the fastest way to start a new Astro project from scratch. It will walk you through every step of setting up your new Astro project. It allows you to choose from a few different official starter templates or you can use any existing project on GitHub with the --template argument.\n\n ONLINE PREVIEWS\n\nPrefer to try Astro in your browser? Visit astro.new to browse our starter templates and spin up a new Astro project without ever leaving your browser.\n\n1. Run the Setup Wizard\nSection titled 1. Run the Setup Wizard\n\nRun the following command in your terminal to start our handy install wizard:\n\nnpm\npnpm\nYarn\nTerminal window\n# create a new project with npm\nnpm create astro@latest\n\nYou can run create astro anywhere on your machine, so there‚Äôs no need to create a new empty directory for your project before you begin. If you don‚Äôt have an empty directory yet for your new project, the wizard will help create one for you automatically.\n\nIf all goes well, you should see a ‚ÄúLiftoff confirmed. Explore your project!‚Äù message followed by some recommended next steps. cd into your new project directory to begin using Astro.\n\nIf you skipped the npm install step during the CLI wizard, then be sure to install your dependencies before continuing.\n\n2. Start Astro ‚ú®\nSection titled 2. Start Astro ‚ú®\n\nAstro comes with a built-in development server that has everything you need for project development. The astro dev command will start the local development server so that you can see your new website in action for the very first time.\n\nEvery starter template comes with a pre-configured script that will run astro dev for you. Use your favorite package manager to run this command and start the Astro development server.\n\nnpm\npnpm\nYarn\nTerminal window\nnpm run dev\n\nIf all goes well, Astro should now be serving your project on http://localhost:4321/!\n\nAstro will listen for live file changes in your src/ directory, so you will not need to restart the server as you make changes during development.\n\nIf you aren‚Äôt able to open your project in the browser, go back to the terminal where you ran the dev command and look to see if an error occurred, or if your project is being served at a different URL than the one linked to above.\n\nStarter Templates\nSection titled Starter Templates\n\nYou can also start a new astro project based on an official example or the main branch of any GitHub repository by passing a --template argument to the create astro command.\n\nnpm\npnpm\nYarn\nTerminal window\n# create a new project with an official example\nnpm create astro@latest -- --template <example-name>\n\n\n# create a new project based on a GitHub repository‚Äôs main branch\nnpm create astro@latest -- --template <github-username>/<github-repo>\n\nBy default, this command will use the template repository‚Äôs main branch. To use a different branch name, pass it as part of the --template argument: <github-username>/<github-repo>#<branch>.\n\nExplore our themes and starters showcase where you can browse themes for blogs, portfolios, documentation, landing pages, and more! Or, search on GitHub for even more starter projects.\n\nNext Steps\nSection titled Next Steps\n\nSuccess! You are now ready to start building with Astro! ü•≥\n\nHere are a few topics that we recommend exploring next. You can read them in any order. You can even leave our documentation for a bit and go play in your new Astro project codebase, coming back here whenever you run into trouble or have a question.\n\nüìö Add a framework: Learn how to extend Astro with support for React, Svelte, Tailwind and more using npx astro add in our Integrations guide.\n\nüìö Deploy your site: Learn how to build and deploy an Astro project to the web in our Deployment guide.\n\nüìö Understand your codebase: Learn more about Astro‚Äôs project structure in our Project Structure guide.\n\nBack\nGetting Started\nNext Page\nEditor Setup"
  },
  {
    "title": "Getting Started üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/getting-started/",
    "html": "Getting Started\n\n ASTRO VERSION 3 IS HERE!\n\nWhat‚Äôs new in Astro v3? Find out in the announcement blog post.\nReady to upgrade? Follow our upgrade guide.\n\nWhat is Astro?\n\nAstro is an all-in-one web framework for building fast, content-focused websites.\n\nKey Features\nSection titled Key Features\nComponent Islands: A new web architecture for building faster websites.\nServer-first API design: Move expensive hydration off of your users‚Äô devices.\nZero JS, by default: No JavaScript runtime overhead to slow you down.\nEdge-ready: Deploy anywhere, even a global edge runtime like Deno or Cloudflare.\nCustomizable: Tailwind, MDX, and 100+ other integrations to choose from.\nUI-agnostic: Supports React, Preact, Svelte, Vue, Solid, Lit and more.\n\nCheck out our detailed Why Astro breakdown to learn more about what makes Astro special. ‚ú®\n\nTry Astro in your browser\nSection titled Try Astro in your browser\n\nVisit astro.new and choose from a variety of templates to get started. Play around with a full, working version of Astro right in your browser!\n\nLaunch basic template\nView all templates ‚Üí\nStart your first project\nSection titled Start your first project\n\nGet a new Astro project up and running locally with our helpful create astro CLI wizard!\n\nnpm\npnpm\nYarn\nTerminal window\n# create a new project with npm\nnpm create astro@latest\n\nOur Installation Guide has full, step-by-step instructions for installing Astro using our CLI wizard, creating a new project from an existing Astro GitHub repository, and for installing Astro manually.\n\nLearn Astro\nSection titled Learn Astro\n\nSee examples of some of the key concepts and patterns of an Astro site!\n\nüìö Add your first page to your site.\n\nüìö Read more about Astro‚Äôs project structure.\n\nüìö Learn about Astro‚Äôs file-based routing.\n\n‚Ä¶ find our full API documentation under the Reference tab.\n\nExtend Astro\nSection titled Extend Astro\n\nüß∞ Start your next project with a prebuilt theme\n\nüß∞ Customize your site with official and community plugins and components.\n\nüß∞ Get inspired by visiting our site showcase.\n\n‚Ä¶ see our guide to using integrations.\n\nJoin our Community\nSection titled Join our Community\n\nJoin us in the Astro Discord to share with and get help from an active, friendly community!\n\nüí¨ Say hi in our #general channel!\n\nüí¨ Ask our Support Squad a question in our #support channel!\n\nüí¨ Share what you‚Äôve been working on in our #showcase channel!\n\nWhat‚Äôs New?\nSection titled What‚Äôs New?\n\nAstro Blog\n\nAstro changelog\n\nContribute\nSection titled Contribute\n\nThese docs are brought to you by all these helpful people. Join us on GitHub!\n\nNext Page\nInstallation"
  },
  {
    "title": "Astro Adapter API üöÄ Astro Documentation",
    "url": "https://docs.astro.build/en/reference/adapter-reference/",
    "html": "Astro Adapter API\n\nAstro is designed to make it easy to deploy to any cloud provider for SSR (server-side rendering). This ability is provided by adapters, which are integrations. See the SSR guide to learn how to use an existing adapter.\n\nWhat is an adapter\nSection titled What is an adapter\n\nAn adapter is a special kind of integration that provides an entrypoint for server-side rendering. An adapter does two things:\n\nImplements host-specific APIs for handling requests.\nConfigures the build according to host conventions.\nBuilding an Adapter\nSection titled Building an Adapter\n\nAn adapter is an integration and can do anything that an integration can do.\n\nAn adapter must call the setAdapter API in the astro:config:done hook like so:\n\nmy-adapter.mjs\nexport default function createIntegration() {\n  return {\n    name: '@matthewp/my-adapter',\n    hooks: {\n      'astro:config:done': ({ setAdapter }) => {\n        setAdapter({\n          name: '@matthewp/my-adapter',\n          serverEntrypoint: '@matthewp/my-adapter/server.js',\n          supportedAstroFeatures: {\n              staticOutput: 'stable'\n          }\n        });\n      },\n    },\n  };\n}\n\nThe object passed into setAdapter is defined as:\n\ninterface AstroAdapter {\n  name: string;\n  serverEntrypoint?: string;\n  exports?: string[];\n  adapterFeatures: AstroAdapterFeatures;\n  supportedAstroFeatures: AstroFeatureMap;\n\n\n}\n\n\nexport interface AstroAdapterFeatures {\n  /**\n   * Creates an edge function that will communicate with the Astro middleware.\n   */\n  edgeMiddleware: boolean;\n  /**\n   * SSR only. Each route becomes its own function/file.\n   */\n  functionPerRoute: boolean;\n}\n\n\nexport type SupportsKind = 'unsupported' | 'stable' | 'experimental' | 'deprecated';\n\n\nexport type AstroFeatureMap = {\n  /**\n   * The adapter is able to serve static pages\n   */\n  staticOutput?: SupportsKind;\n  /**\n   * The adapter is able to serve pages that are static or rendered via server\n   */\n  hybridOutput?: SupportsKind;\n  /**\n   * The adapter is able to serve SSR pages\n   */\n  serverOutput?: SupportsKind;\n  /**\n   * The adapter can emit static assets\n   */\n  assets?: AstroAssetsFeature;\n};\n\n\nexport interface AstroAssetsFeature {\n  supportKind?: SupportsKind;\n  /**\n   * Whether this adapter deploys files in an environment that is compatible with the library `sharp`\n   */\n  isSharpCompatible?: boolean;\n  /**\n   * Whether this adapter deploys files in an environment that is compatible with the library `squoosh`\n   */\n  isSquooshCompatible?: boolean;\n}\n\nThe properties are:\n\nname: A unique name for your adapter, used for logging.\nserverEntrypoint: The entrypoint for server-side rendering.\nexports: An array of named exports when used in conjunction with createExports (explained below).\nadapterFeatures: An object that enables specific features that must be supported by the adapter. These features will change the built output, and the adapter must implement the proper logic to handle the different output.\nsupportedAstroFeatures: A map of Astro built-in features. This allows Astro to determine which features an adapter is unable or unwilling to support so appropriate error messages can be provided.\nServer Entrypoint\nSection titled Server Entrypoint\n\nAstro‚Äôs adapter API attempts to work with any type of host, and gives a flexible way to conform to the host APIs.\n\nExports\nSection titled Exports\n\nSome serverless hosts expect you to export a function, such as handler:\n\n...\nexport function handler(event, context) {\n}\n\nWith the adapter API you achieve this by implementing createExports in your serverEntrypoint:\n\nimport { App } from 'astro/app';\n\n\nexport function createExports(manifest) {\n  const app = new App(manifest);\n\n\n  const handler = (event, context) => {\n    // ...\n  };\n\n\n  return { handler };\n}\n\nAnd then in your integration, where you call setAdapter, provide this name in exports:\n\nmy-adapter.mjs\nexport default function createIntegration() {\n  return {\n    name: '@matthewp/my-adapter',\n    hooks: {\n      'astro:config:done': ({ setAdapter }) => {\n        setAdapter({\n          name: '@matthewp/my-adapter',\n          serverEntrypoint: '@matthewp/my-adapter/server.js',\n          exports: ['handler'],\n        });\n      },\n    },\n  };\n}\nStart\nSection titled Start\n\nSome hosts expect you to start the server yourselves, for example by listening to a port. For these types of hosts, the adapter API allows you to export a start function which will be called when the bundle script is run.\n\nimport { App } from 'astro/app';\n\n\nexport function start(manifest) {\n  const app = new App(manifest);\n\n\n  addEventListener('fetch', event => {\n    // ...\n  });\n}\nastro/app\nSection titled astro/app\n\nThis module is used for rendering pages that have been prebuilt through astro build. Astro uses the standard Request and Response objects. Hosts that have a different API for request/response should convert to these types in their adapter.\n\nimport { App } from 'astro/app';\nimport http from 'http';\n\n\nexport function start(manifest) {\n  const app = new App(manifest);\n\n\n  addEventListener('fetch', event => {\n    event.respondWith(\n      app.render(event.request)\n    );\n  });\n}\n\nThe following methods are provided:\n\napp.render(request, routeData, locals)\nSection titled app.render(request, routeData, locals)\n\nThis method calls the Astro page that matches the request, renders it, and returns a Promise to a Response object. This also works for API routes that do not render pages.\n\nconst response = await app.render(request);\n\nThe method accepts a mandatory request argument, and two other optional arguments: routeData and locals.\n\nProvide a value for routeData if you already know the route to render. Doing so will bypass the internal call to app.match to determine the route to render.\n\nWhen used, locals must be the third argument passed. You can pass undefined for routeData if you are not targeting a specific route.\n\nThe example below reads a header named x-private-header, attempts to parse it as an object and pass it to locals, which can then be passed to any middleware function.\n\nconst privateHeader = request.headers.get(\"x-private-header\");\nlet locals = {};\ntry {\n    if (privateHeader) {\n        locals = JSON.parse(privateHeader);\n    }\n} finally {\n    const response = await app.render(request, undefined, locals);\n}\napp.match(request)\nSection titled app.match(request)\n\nThis method is used to determine if a request is matched by the Astro app‚Äôs routing rules.\n\nif(app.match(request)) {\n  const response = await app.render(request);\n}\n\nYou can usually call app.render(request) without using .match because Astro handles 404s if you provide a 404.astro file. Use app.match(request) if you want to handle 404s in a different way.\n\nAllow installation via astro add\nSection titled Allow installation via astro add\n\nThe astro add command allows users to easily add integrations and adapters to their project. If you want your adapter to be installable with this tool, add astro-adapter to the keywords field in your package.json:\n\n{\n  \"name\": \"example\",\n  \"keywords\": [\"astro-adapter\"],\n}\n\nOnce you publish your adapter to npm, running astro add example will install your package with any peer dependencies specified in your package.json. We will also instruct users to update their project config manually.\n\nAstro features\nSection titled Astro features\nAdded in: astro@3.0.0\n\nAstro features are a way for an adapter to tell Astro whether they are able to support a feature, and also the adapter‚Äôs level of support.\n\nWhen using these properties, Astro will:\n\nrun specific validation;\nemit contextual to the logs;\n\nThese operations are run based on the features supported or not supported, their level of support, and the configuration that the user uses.\n\nThe following configuration tells Astro that this adapter has experimental support for assets, but the adapter is not compatible with the built-in services Sharp and Squoosh:\n\nmy-adapter.mjs\nexport default function createIntegration() {\n  return {\n    name: '@matthewp/my-adapter',\n    hooks: {\n      'astro:config:done': ({ setAdapter }) => {\n        setAdapter({\n          name: '@matthewp/my-adapter',\n          serverEntrypoint: '@matthewp/my-adapter/server.js',\n          supportedAstroFeatures: {\n            assets: {\n              supportKind: \"experimental\",\n              isSharpCompatible: false,\n              isSquooshCompatible: false\n            }\n          }\n        });\n      },\n    },\n  };\n}\n\nAstro will log a warning to the terminal:\n\n[@matthewp/my-adapter] The feature is experimental and subject to issues or changes.\n\nand an error if the service used for assets is not compatible with the adapter:\n\n[@matthewp/my-adapter] The currently selected adapter `@matthewp/my-adapter` is not compatible with the service \"Sharp\". Your project will NOT be able to build.\nAdapter features\nSection titled Adapter features\n\nA set of features that changes the output of the emitted files. When an adapter opts in to these features, they will get additional information inside specific hooks.\n\nfunctionPerRoute\nSection titled functionPerRoute\n\nThis is a feature that is enabled when using SSR only. By default, Astro emits a single entry.mjs file, which is responsible for emitting the rendered page on each request.\n\nWhen functionPerRoute is true, Astro will instead create a separate file for each route defined in the project.\n\nEach file emitted will only render one page. The pages will be emitted inside a dist/pages/ directory (or under a /pages/ directory in the directory specified for outDir), and the emitted files will keep the same file paths of the src/pages/ directory.\n\nThe files inside the pages/ directory of the build will mirror the directory structure of your page files in src/pages/, for example:\n\nDirectory\ndist/\nDirectory\npages/\nDirectory\nblog/\nentry._slug_.astro.mjs\nentry.about.astro.mjs\nentry.index.astro.mjs\n\nEnable the feature by passing true to the adapter.\n\nmy-adapter.mjs\nexport default function createIntegration() {\n  return {\n    name: '@matthewp/my-adapter',\n    hooks: {\n      'astro:config:done': ({ setAdapter }) => {\n        setAdapter({\n          name: '@matthewp/my-adapter',\n          serverEntrypoint: '@matthewp/my-adapter/server.js',\n          adapterFeatures: {\n              functionPerRoute: true\n          }\n        });\n      },\n    },\n  };\n}\n\nThen, consume the hook astro:build:ssr, which will give you an entryPoints object that maps a page route to the physical file emitted after the build.\n\nmy-adapter.mjs\nexport default function createIntegration() {\n  return {\n    name: '@matthewp/my-adapter',\n    hooks: {\n      'astro:config:done': ({ setAdapter }) => {\n        setAdapter({\n          name: '@matthewp/my-adapter',\n          serverEntrypoint: '@matthewp/my-adapter/server.js',\n          adapterFeatures: {\n              functionPerRoute: true\n          }\n        });\n      },\n\n\n      'astro:build:ssr': ({ entryPoints }) => {\n          for (const [route, entryFile] of entryPoints) {\n              // do something with route and entryFile\n          }\n      }\n    },\n  };\n}\n\n CAUTION\n\nThe entryFile is of type URL and represents the physical path of the file in the file system. This means that the paths change based on the OS where the code runs.\n\nServerless environments\nSection titled Serverless environments\n\nSetting functionPerRoute: true in a serverless environment creates a JavaScript file (handler) for each route. A handler might have different names based on your hosting platform: lambda, function, page, etc.\n\nEach of these routes is subject to a cold start when the handler runs, which may cause some delay. This delay is influenced by different factors.\n\nWith functionPerRoute: false, there is only one single handler in charge of rendering all your routes. When this handler is first triggered, you will be subject to a cold start. Then, all other routes should function without delay. However, you will lose the benefit of code splitting that functionPerRoute: true provides.\n\n NOTE\n\nIt‚Äôs important that you understand your hosting platform, and how it works, in order to choose the appropriate functionPerRoute configuration for your project.\n\nedgeMiddleware\nSection titled edgeMiddleware\n\nDefines whether any SSR middleware code will be bundled when built.\n\nWhen enabled, this prevents middleware code from being bundled and imported by all pages during the build:\n\nmy-adapter.mjs\nexport default function createIntegration() {\n  return {\n    name: '@matthewp/my-adapter',\n    hooks: {\n      'astro:config:done': ({ setAdapter }) => {\n        setAdapter({\n          name: '@matthewp/my-adapter',\n          serverEntrypoint: '@matthewp/my-adapter/server.js',\n          adapterFeatures: {\n              edgeMiddleware: true\n          }\n        });\n      },\n    },\n  };\n}\n\nThen, consume the hook astro:build:ssr, which will give you a middlewareEntryPoint, an URL to the physical file on the file system.\n\nmy-adapter.mjs\nexport default function createIntegration() {\n  return {\n    name: '@matthewp/my-adapter',\n    hooks: {\n      'astro:config:done': ({ setAdapter }) => {\n        setAdapter({\n          name: '@matthewp/my-adapter',\n          serverEntrypoint: '@matthewp/my-adapter/server.js',\n          adapterFeatures: {\n              edgeMiddleware: true\n          }\n        });\n      },\n\n\n      'astro:build:ssr': ({ middlewareEntryPoint }) => {\n          // remember to check if this property exits, it will be `undefined` if the adapter doesn't opt in to the feature\n          if (middlewareEntryPoint) {\n             createEdgeMiddleware(middlewareEntryPoint)\n          }\n      }\n    },\n  };\n}\n\n\nfunction createEdgeMiddleware(middlewareEntryPoint) {\n    // emit a new physical file using your bundler\n}\nBack\nIntegrations API\nNext Page\nImage Service API"
  }
]
