[
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/transition",
    "html": "Transition\n\nThe Transition component lets you add enter/leave transitions to conditionally rendered elements, using CSS classes to control the actual transition styles in the different stages of the transition.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nThe Transition accepts a show prop that controls whether the children should be shown or hidden, and a set of lifecycle props (like enterFrom, and leaveTo) that let you add CSS classes at specific phases of a transition.\n\nimport { Transition } from '@headlessui/react'\nimport { useState } from 'react'\n\nfunction MyComponent() {\n  const [isShowing, setIsShowing] = useState(false)\n\n  return (\n    <>\n      <button onClick={() => setIsShowing((isShowing) => !isShowing)}>\n        Toggle\n      </button>\n      <Transition\n        show={isShowing}\n        enter=\"transition-opacity duration-75\"\n        enterFrom=\"opacity-0\"\n        enterTo=\"opacity-100\"\n        leave=\"transition-opacity duration-150\"\n        leaveFrom=\"opacity-100\"\n        leaveTo=\"opacity-0\"\n      >\n        I will fade in and out\n      </Transition>\n    </>\n  )\n}\nShowing and hiding content\n\nWrap the content that should be conditionally rendered in a <Transition> component, and use the show prop to control whether the content should be visible or hidden.\n\nimport { Transition } from '@headlessui/react'\nimport { useState } from 'react'\n\nfunction MyComponent() {\n  const [isShowing, setIsShowing] = useState(false)\n\n  return (\n    <>\n      <button onClick={() => setIsShowing((isShowing) => !isShowing)}>\n\n        Toggle\n      </button>\n      <Transition show={isShowing}>I will appear and disappear.</Transition>\n    </>\n  )\n}\n\n\nThe Transition component will render a div by default, but you can use the as prop to render a different element instead if needed. Any other HTML attributes (like className) can be added directly to the Transition the same way they would be to regular elements.\n\nimport { Transition } from '@headlessui/react'\nimport { useState } from 'react'\n\nfunction MyComponent() {\n  const [isShowing, setIsShowing] = useState(false)\n\n  return (\n    <>\n      <button onClick={() => setIsShowing((isShowing) => !isShowing)}>\n\n        Toggle\n      </button>\n      <Transition show={isShowing} as=\"a\" href=\"/my-url\" className=\"font-bold\">\n        I will appear and disappear.\n      </Transition>\n    </>\n  )\n}\n\nAnimating transitions\n\nBy default, a Transition will enter and leave instantly, which is probably not what you're looking for if you're using this component.\n\nTo animate your enter/leave transitions, add classes that provide the styling for each phase of the transitions using these props:\n\nenter: Applied the entire time an element is entering. Usually you define your duration and what properties you want to transition here, for example transition-opacity duration-75.\nenterFrom: The starting point to enter from, for example opacity-0 if something should fade in.\nenterTo: The ending point to enter to, for example opacity-100 after fading in.\nleave: Applied the entire time an element is leaving. Usually you define your duration and what properties you want to transition here, for example transition-opacity duration-75.\nleaveFrom: The starting point to leave from, for example opacity-100 if something should fade out.\nleaveTo: The ending point to leave to, for example opacity-0 after fading out.\n\nHere's an example:\n\nimport { Transition } from '@headlessui/react'\nimport { useState } from 'react'\n\nfunction MyComponent() {\n  const [isShowing, setIsShowing] = useState(false)\n\n  return (\n    <>\n      <button onClick={() => setIsShowing((isShowing) => !isShowing)}>\n        Toggle\n      </button>\n\n      <Transition\n        show={isShowing}\n        enter=\"transition-opacity duration-75\"\n        enterFrom=\"opacity-0\"\n        enterTo=\"opacity-100\"\n        leave=\"transition-opacity duration-150\"\n        leaveFrom=\"opacity-100\"\n        leaveTo=\"opacity-0\"\n      >\n        I will fade in and out\n      </Transition>\n    </>\n  )\n}\n\n\nIn this example, the transitioning element will take 75ms to enter (that's the duration-75 class), and will transition the opacity property during that time (that's transition-opacity).\n\nIt will start completely transparent before entering (that's opacity-0 in the enterFrom phase), and fade in to completely opaque (opacity-100) when finished (that's the enterTo phase).\n\nWhen the element is being removed (the leave phase), it will transition the opacity property, and spend 150ms doing it (transition-opacity duration-150).\n\nIt will start as completely opaque (the opacity-100 in the leaveFrom phase), and finish as completely transparent (the opacity-0 in the leaveTo phase).\n\nAll of these props are optional, and will default to just an empty string.\n\nCo-ordinating multiple transitions\n\nSometimes you need to transition multiple elements with different animations but all based on the same state. For example, say the user clicks a button to open a sidebar that slides over the screen, and you also need to fade-in a background overlay at the same time.\n\nYou can do this by wrapping the related elements with a parent Transition component, and wrapping each child that needs its own transition styles with a Transition.Child component, which will automatically communicate with the parent Transition and inherit the parent's show state.\n\nimport { Transition } from '@headlessui/react'\n\nfunction Sidebar({ isShowing }) {\n  return (\n    /* The `show` prop controls all nested `Transition.Child` components. */\n    <Transition show={isShowing}>\n      {/* Background overlay */}\n      <Transition.Child\n        enter=\"transition-opacity ease-linear duration-300\"\n        enterFrom=\"opacity-0\"\n        enterTo=\"opacity-100\"\n        leave=\"transition-opacity ease-linear duration-300\"\n        leaveFrom=\"opacity-100\"\n        leaveTo=\"opacity-0\"\n      >\n        {/* ... */}\n      </Transition.Child>\n\n      {/* Sliding sidebar */}\n      <Transition.Child\n        enter=\"transition ease-in-out duration-300 transform\"\n        enterFrom=\"-translate-x-full\"\n        enterTo=\"translate-x-0\"\n        leave=\"transition ease-in-out duration-300 transform\"\n        leaveFrom=\"translate-x-0\"\n        leaveTo=\"-translate-x-full\"\n      >\n        {/* ... */}\n      </Transition.Child>\n    </Transition>\n  )\n}\n\nThe Transition.Child component has the exact same API as the Transition component, but with no show prop, since the show value is controlled by the parent.\n\nParent Transition components will always automatically wait for all children to finish transitioning before unmounting, so you don't need to manage any of that timing yourself.\n\nTransitioning on initial mount\n\nIf you want an element to transition the very first time it's rendered, set the appear prop to true.\n\nThis is useful if you want something to transition in on initial page load, or when its parent is conditionally rendered.\n\nimport { Transition } from '@headlessui/react'\n\nfunction MyComponent({ isShowing }) {\n  return (\n    <Transition\n\n      appear={true}\n      show={isShowing}\n      enter=\"transition-opacity duration-75\"\n      enterFrom=\"opacity-0\"\n      enterTo=\"opacity-100\"\n      leave=\"transition-opacity duration-150\"\n      leaveFrom=\"opacity-100\"\n      leaveTo=\"opacity-0\"\n    >\n      {/* Your content goes here*/}\n    </Transition>\n  )\n}\n\nComponent API\nTransition\nProp\tDefault\tDescription\nshow\t—\t\nBoolean\n\nWhether the children should be shown or hidden.\n\n\nas\tdiv\t\nString | Component\n\nThe element or component to render in place of the Transition itself.\n\n\nappear\tfalse\t\nBoolean\n\nWhether the transition should run on initial mount.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the show state.\n\n\nenter\t—\t\nString\n\nClasses to add to the transitioning element during the entire enter phase.\n\n\nenterFrom\t—\t\nString\n\nClasses to add to the transitioning element before the enter phase starts.\n\n\nenterTo\t—\t\nString\n\nClasses to add to the transitioning element immediately after the enter phase starts.\n\n\nentered\t—\t\nString\n\nClasses to add to the transitioning element once the transition is done. These classes will persist after that, until it's time to leave.\n\n\nleave\t—\t\nString\n\nClasses to add to the transitioning element during the entire leave phase.\n\n\nleaveFrom\t—\t\nString\n\nClasses to add to the transitioning element before the leave phase starts.\n\n\nleaveTo\t—\t\nString\n\nClasses to add to the transitioning element immediately after the leave phase starts.\n\n\nbeforeEnter\t—\t\n() => void\n\nCallback which is called before we start the enter transition.\n\n\nafterEnter\t—\t\n() => void\n\nCallback which is called after we finished the enter transition.\n\n\nbeforeLeave\t—\t\n() => void\n\nCallback which is called before we start the leave transition.\n\n\nafterLeave\t—\t\n() => void\n\nCallback which is called after we finished the leave transition.\n\nTransition.Child\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component to render in place of the Transition itself.\n\n\nappear\tfalse\t\nBoolean\n\nWhether the transition should run on initial mount.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the show state.\n\n\nenter\t—\t\nString\n\nClasses to add to the transitioning element during the entire enter phase.\n\n\nenterFrom\t—\t\nString\n\nClasses to add to the transitioning element before the enter phase starts.\n\n\nenterTo\t—\t\nString\n\nClasses to add to the transitioning element immediately after the enter phase starts.\n\n\nentered\t—\t\nString\n\nClasses to add to the transitioning element once the transition is done. These classes will persist after that, until it's time to leave.\n\n\nleave\t—\t\nString\n\nClasses to add to the transitioning element during the entire leave phase.\n\n\nleaveFrom\t—\t\nString\n\nClasses to add to the transitioning element before the leave phase starts.\n\n\nleaveTo\t—\t\nString\n\nClasses to add to the transitioning element immediately after the leave phase starts.\n\n\nbeforeEnter\t—\t\n() => void\n\nCallback which is called before we start the enter transition.\n\n\nafterEnter\t—\t\n() => void\n\nCallback which is called after we finished the enter transition.\n\n\nbeforeLeave\t—\t\n() => void\n\nCallback which is called before we start the leave transition.\n\n\nafterLeave\t—\t\n() => void\n\nCallback which is called after we finished the leave transition.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/tabs",
    "html": "Tabs\n\nEasily create accessible, fully customizable tab interfaces, with robust focus management and keyboard navigation support.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nTabs are built using the Tab.Group, Tab.List, Tab, Tab.Panels, and Tab.Panel components. By default the first tab is selected, and clicking on any tab or selecting it with the keyboard will activate the corresponding panel.\n\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n    <Tab.Group>\n      <Tab.List>\n        <Tab>Tab 1</Tab>\n        <Tab>Tab 2</Tab>\n        <Tab>Tab 3</Tab>\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        <Tab.Panel>Content 2</Tab.Panel>\n        <Tab.Panel>Content 3</Tab.Panel>\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which tab option is currently checked, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Tab component exposes a selected state, which tells you if the tab is currently selected.\n\nimport { Fragment } from 'react'\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n    <Tab.Group>\n      <Tab.List>\n        <Tab as={Fragment}>\n\n          {({ selected }) => (\n            /* Use the `selected` state to conditionally style the selected tab. */\n            <button\n              className={\n\n                selected ? 'bg-blue-500 text-white' : 'bg-white text-black'\n              }\n            >\n              Tab 1\n            </button>\n          )}\n        </Tab>\n        {/* ...  */}\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        {/* ... */}\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Tab.Group component with some child Tab components renders when the second tab is selected:\n\n<!-- Rendered `Tab.Group` -->\n<div>\n  <button data-headlessui-state=\"\">Tab 1</button>\n  <button data-headlessui-state=\"selected\">Tab 2</button>\n  <button data-headlessui-state=\"\">Tab 3</button>\n</div>\n<div>\n  <div data-headlessui-state=\"\">Content 1</div>\n  <div data-headlessui-state=\"selected\">Content 2</div>\n  <div data-headlessui-state=\"\">Content 3</div>\n</div>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:*:\n\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n    <Tab.Group>\n      <Tab.List>\n\n        <Tab className=\"ui-selected:bg-blue-500 ui-selected:text-white ui-not-selected:bg-white ui-not-selected:text-black\">\n          Tab 1\n        </Tab>\n        {/* ...  */}\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        {/* ... */}\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\nDisabling a tab\n\nTo disable a tab, use the disabled prop on the Tab component. Disabled tabs cannot be selected with the mouse, and are also skipped when navigating the tab list using the keyboard.\n\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n    <Tab.Group>\n      <Tab.List>\n        <Tab>Tab 1</Tab>\n\n        <Tab disabled>Tab 2</Tab>\n        <Tab>Tab 3</Tab>\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        <Tab.Panel>Content 2</Tab.Panel>\n        <Tab.Panel>Content 3</Tab.Panel>\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\nManually activating tabs\n\nBy default, tabs are automatically selected as the user navigates through them using the arrow keys.\n\nIf you'd rather not change the current tab until the user presses Enter or Space, use the manual prop on the Tab.Group component. This can be helpful if selecting a tab performs an expensive operation and you don't want to run it unnecessarily.\n\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n\n    <Tab.Group manual>\n      <Tab.List>\n        <Tab>Tab 1</Tab>\n        <Tab>Tab 2</Tab>\n        <Tab>Tab 3</Tab>\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        <Tab.Panel>Content 2</Tab.Panel>\n        <Tab.Panel>Content 3</Tab.Panel>\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\n\nThe manual prop has no impact on mouse interactions — tabs will still be selected as soon as they are clicked.\n\nVertical tabs\n\nIf you've styled your Tab.List to appear vertically, use the vertical prop to enable navigating with the up and down arrow keys instead of left and right, and to update the aria-orientation attribute for assistive technologies.\n\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n\n    <Tab.Group vertical>\n      <Tab.List>\n        <Tab>Tab 1</Tab>\n        <Tab>Tab 2</Tab>\n        <Tab>Tab 3</Tab>\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        <Tab.Panel>Content 2</Tab.Panel>\n        <Tab.Panel>Content 3</Tab.Panel>\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\nSpecifying the default tab\n\nTo change which tab is selected by default, use the defaultIndex={number} prop on the Tab.Group component.\n\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n\n    <Tab.Group defaultIndex={1}>\n      <Tab.List>\n        <Tab>Tab 1</Tab>\n\n\n        {/* Selects this tab by default */}\n        <Tab>Tab 2</Tab>\n\n        <Tab>Tab 3</Tab>\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n\n\n        {/* Displays this panel by default */}\n        <Tab.Panel>Content 2</Tab.Panel>\n\n        <Tab.Panel>Content 3</Tab.Panel>\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\n\nIf you happen to provide an index that is out of bounds, then the last non-disabled tab will be selected on initial render. (For example, <Tab.Group defaultIndex={5} in the example above would render the third panel as selected.)\n\nListening for changes\n\nTo run a function whenever the selected tab changes, use the onChange prop on the Tab.Group component.\n\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n  return (\n    <Tab.Group\n\n      onChange={(index) => {\n        console.log('Changed selected tab to:', index)\n      }}\n    >\n      <Tab.List>\n        <Tab>Tab 1</Tab>\n        <Tab>Tab 2</Tab>\n        <Tab>Tab 3</Tab>\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        <Tab.Panel>Content 2</Tab.Panel>\n        <Tab.Panel>Content 3</Tab.Panel>\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\nControlling the active tab\n\nThe tabs component can also be used as a controlled component. To do this, provide the selectedIndex and manage the state yourself.\n\nimport { useState } from 'react'\nimport { Tab } from '@headlessui/react'\n\nfunction MyTabs() {\n\n  const [selectedIndex, setSelectedIndex] = useState(0)\n\n  return (\n\n    <Tab.Group selectedIndex={selectedIndex} onChange={setSelectedIndex}>\n      <Tab.List>\n        <Tab>Tab 1</Tab>\n        <Tab>Tab 2</Tab>\n        <Tab>Tab 3</Tab>\n      </Tab.List>\n      <Tab.Panels>\n        <Tab.Panel>Content 1</Tab.Panel>\n        <Tab.Panel>Content 2</Tab.Panel>\n        <Tab.Panel>Content 3</Tab.Panel>\n      </Tab.Panels>\n    </Tab.Group>\n  )\n}\n\nAccessibility notes\nMouse interaction\n\nClicking a Tab will select that tab and display the corresponding Tab.Panel.\n\nKeyboard interaction\n\nAll interactions apply when a Tab component is focused.\n\nCommand\tDescription\n\n\nArrowLeft\nand\nArrowRight\n\n\t\n\nSelects the previous/next non-disabled tab.\n\n\n\n\nArrowUp\nand\nArrowDown\nwhen vertical is set\n\n\t\n\nSelects the previous/next non-disabled tab.\n\n\n\n\nHome\nor\nPageUp\n\n\t\n\nSelects the first non-disabled tab.\n\n\n\n\nEnd\nor\nPageDown\n\n\t\n\nSelects the last non-disabled tab.\n\n\n\n\nEnter\nor\nSpace when manual is set\n\n\t\n\nActivates the selected tab.\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nFor a full reference on all accessibility features implemented in Tabs, see the ARIA spec on Tabs.\n\nComponent API\nTab.Group\n\nThe main Tab.Group component.\n\nProp\tDefault\tDescription\nas\tFragment\t\nString | Component\n\nThe element or component the Tabs should render as.\n\n\ndefaultIndex\t0\t\nNumber\n\nThe default selected index\n\n\nselectedIndex\t—\t\nnumber\n\nThe selected index if you want to use the Tabs component as a controlled component.\n\n\nonChange\t—\t\n(index: number) => void\n\nA function called whenever the active tab changes.\n\n\nvertical\tfalse\t\nBoolean\n\nWhen true, the orientation of the Tab.List will be vertical, otherwise it will be horizontal.\n\n\nmanual\tfalse\t\nBoolean\n\nWhen true, the user can only display a panel via the keyboard by first navigating to it using the arrow keys, and then by pressing Enter or Space. By default, panels are automatically displayed when navigated to via the arrow keys. Note that this prop has no affect on mouse behavior.\n\nRender Prop\tDescription\nselectedIndex\t\n\nNumber\n\nThe currently selected index.\n\nTab.List\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Tab.List should render as.\n\nRender Prop\tDescription\nselectedIndex\t\n\nNumber\n\nThe currently selected index.\n\nTab\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Tab should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the Tab is currently disabled.\n\nRender Prop\tDescription\nselected\t\n\nBoolean\n\nWhether or not the Tab is currently selected.\n\nTab.Panels\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Tab.Panels should render as.\n\nRender Prop\tDescription\nselectedIndex\t\n\nNumber\n\nThe currently selected index.\n\nTab.Panel\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Tab.Panel should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the selected index.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the selected index.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nRender Prop\tDescription\nselected\t\n\nBoolean\n\nWhether or not the Tab.Panel is currently selected.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/radio-group",
    "html": "Radio Group\n\nRadio Groups give you the same functionality as native HTML radio inputs, without any of the styling. They're perfect for building out custom UIs for selectors.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nRadio Groups are built using the RadioGroup, RadioGroup.Label, and RadioGroup.Option components.\n\nClicking an option will select it, and when the radio group is focused, the arrow keys will change the selected option.\n\nimport { useState } from 'react'\nimport { RadioGroup } from '@headlessui/react'\n\nfunction MyRadioGroup() {\n  let [plan, setPlan] = useState('startup')\n\n  return (\n    <RadioGroup value={plan} onChange={setPlan}>\n      <RadioGroup.Label>Plan</RadioGroup.Label>\n      <RadioGroup.Option value=\"startup\">\n        {({ checked }) => (\n          <span className={checked ? 'bg-blue-200' : ''}>Startup</span>\n        )}\n      </RadioGroup.Option>\n      <RadioGroup.Option value=\"business\">\n        {({ checked }) => (\n          <span className={checked ? 'bg-blue-200' : ''}>Business</span>\n        )}\n      </RadioGroup.Option>\n      <RadioGroup.Option value=\"enterprise\">\n        {({ checked }) => (\n          <span className={checked ? 'bg-blue-200' : ''}>Enterprise</span>\n        )}\n      </RadioGroup.Option>\n    </RadioGroup>\n  )\n}\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which radiogroup option is currently checked, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the RadioGroup.Option component exposes an active state, which tells you if the option is currently focused via the mouse or keyboard, and a checked state, which tells you if that option matches the current value of the RadioGroup.\n\nimport { useState, Fragment } from 'react'\nimport { RadioGroup } from '@headlessui/react'\nimport { CheckIcon } from '@heroicons/react/20/solid'\n\nconst plans = ['Statup', 'Business', 'Enterprise']\n\nfunction MyRadioGroup() {\n  const [plan, setPlan] = useState(plans[0])\n\n  return (\n    <RadioGroup value={plan} onChange={setPlan}>\n      <RadioGroup.Label>Plan</RadioGroup.Label>\n      {plans.map((plan) => (\n        /* Use the `active` state to conditionally style the active option. */\n        /* Use the `checked` state to conditionally style the checked option. */\n        <RadioGroup.Option key={plan} value={plan} as={Fragment}>\n\n          {({ active, checked }) => (\n            <li\n              className={`${\n\n                active ? 'bg-blue-500 text-white' : 'bg-white text-black'\n              }`}\n            >\n\n              {checked && <CheckIcon />}\n              {plan}\n            </li>\n          )}\n        </RadioGroup.Option>\n      ))}\n    </RadioGroup>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the RadioGroup component with some child RadioGroup.Option components renders when the radio group is open and the second option is both checked and active:\n\n<!-- Rendered `RadioGroup` -->\n<div role=\"radiogroup\">\n  <li data-headlessui-state=\"\">Statup</li>\n  <li data-headlessui-state=\"active checked\">Business</li>\n  <li data-headlessui-state=\"\">Enterprise</li>\n</div>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\nimport { useState, Fragment } from 'react'\nimport { RadioGroup } from '@headlessui/react'\nimport { CheckIcon } from '@heroicons/react/20/solid'\n\nconst plans = ['Statup', 'Business', 'Enterprise']\n\nfunction MyRadioGroup() {\n  const [plan, setPlan] = useState(plans[0])\n\n  return (\n    <RadioGroup value={plan} onChange={setPlan}>\n      <RadioGroup.Label>Plan</RadioGroup.Label>\n      {plans.map((plan) => (\n        <RadioGroup.Option\n          key={plan}\n          value={plan}\n\n          className=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n        >\n\n          <CheckIcon className=\"hidden ui-checked:block\" />\n          {plan}\n        </RadioGroup.Option>\n      ))}\n    </RadioGroup>\n  )\n}\n\nBinding objects as values\n\nUnlike native HTML form controls which only allow you to provide strings as values, Headless UI supports binding complex objects as well.\n\nimport { useState } from 'react'\nimport { RadioGroup } from '@headlessui/react'\n\n\nconst plans = [\n  { id: 1, name: 'Startup' },\n  { id: 2, name: 'Business' },\n  { id: 3, name: 'Enterprise' },\n]\n\nfunction MyRadioGroup() {\n  const [plan, setPlan] = useState(plans[0])\n\n  return (\n\n    <RadioGroup value={plan} onChange={setPlan}>\n      <RadioGroup.Label>Plan:</RadioGroup.Label>\n      {plans.map((plan) => (\n\n        <RadioGroup.Option key={plan.id} value={plan}>\n          {plan.name}\n        </RadioGroup.Option>\n      ))}\n    </RadioGroup>\n  )\n}\n\n\nWhen binding objects as values, it's important to make sure that you use the same instance of the object as both the value of the RadioGroup as well as the corresponding RadioGroup.Option, otherwise they will fail to be equal and cause the radiogroup to behave incorrectly.\n\nTo make it easier to work with different instances of the same object, you can use the by prop to compare the objects by a particular field instead of comparing object identity:\n\nimport { RadioGroup } from '@headlessui/react'\n\nconst plans = [\n  { id: 1, name: 'Startup' },\n  { id: 2, name: 'Business' },\n  { id: 3, name: 'Enterprise' },\n]\n\n\nfunction PlanPicker({ checkedPlan, onChange }) {\n  return (\n\n    <RadioGroup value={checkedPlan} by=\"id\" onChange={onChange}>\n      <RadioGroup.Label>Plan</RadioGroup.Label>\n      {plans.map((plan) => (\n        <RadioGroup.Option key={plan.id} value={plan}>\n          {plan.name}\n        </RadioGroup.Option>\n      ))}\n    </RadioGroup>\n  )\n}\n\n\nYou can also pass your own comparison function to the by prop if you'd like complete control over how objects are compared:\n\nimport { RadioGroup } from '@headlessui/react'\n\nconst plans = [\n  { id: 1, name: 'Startup' },\n  { id: 2, name: 'Business' },\n  { id: 3, name: 'Enterprise' },\n]\n\n\nfunction comparePlans(a, b) {\n  return a.name.toLowerCase() === b.name.toLowerCase()\n}\n\nfunction PlanPicker({ checkedPlan, onChange }) {\n  return (\n\n    <RadioGroup value={checkedPlan} by={comparePlans} onChange={onChange}>\n      <RadioGroup.Label>Plan</RadioGroup.Label>\n      {plans.map((plan) => (\n        <RadioGroup.Option key={plan.id} value={plan}>\n          {plan.name}\n        </RadioGroup.Option>\n      ))}\n    </RadioGroup>\n  )\n}\n\nUsing with HTML forms\n\nIf you add the name prop to your listbox, hidden input elements will be rendered and kept in sync with your selected value.\n\nimport { useState } from 'react'\nimport { RadioGroup } from '@headlessui/react'\n\nconst plans = ['startup', 'business', 'enterprise']\n\nfunction Example() {\n  const [plan, setPlan] = useState(plans[0])\n\n  return (\n    <form action=\"/billing\" method=\"post\">\n\n      <RadioGroup value={plan} onChange={setPlan} name=\"plan\">\n        <RadioGroup.Label>Plan</RadioGroup.Label>\n        {plans.map((plan) => (\n          <RadioGroup.Option key={plan} value={plan}>\n            {plan}\n          </RadioGroup.Option>\n        ))}\n      </RadioGroup>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis lets you use a radio group inside a native HTML <form> and make traditional form submissions as if your radio group was a native HTML form control.\n\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like objects will be encoded into multiple inputs using a square bracket notation for the names.\n\n<input type=\"hidden\" name=\"plan\" value=\"startup\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultValue prop to the RadioGroup instead of a value, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\nimport { RadioGroup } from '@headlessui/react'\n\nconst plans = [\n  { id: 1, name: 'Startup' },\n  { id: 2, name: 'Business' },\n  { id: 3, name: 'Enterprise' },\n]\n\nfunction Example() {\n  return (\n    <form action=\"/companies\" method=\"post\">\n\n      <RadioGroup name=\"plan\" defaultValue={plans[0]}>\n        <RadioGroup.Label>Plan</RadioGroup.Label>\n        {plans.map((plan) => (\n          <RadioGroup.Option key={plan.id} value={plan}>\n            {plan.name}\n          </RadioGroup.Option>\n        ))}\n      </RadioGroup>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis can simplify your code when using the combobox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny onChange prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nUsing the Label and Description components\n\nYou can use the RadioGroup.Label and RadioGroup.Description components to mark up each option's contents. Doing so will automatically link each component to its ancestor RadioGroup.Option component via the aria-labelledby and aria-describedby attributes and autogenerated ids, improving the semantics and accessibility of your custom selector.\n\nBy default, RatioGroup.Label renders a label element and RadioGroup.Description renders a <div>. These can also be customized using the as prop, as described in the API docs below.\n\nNote also that Labels and Descriptions can be nested. Each one will refer to its nearest ancestor component, whether than ancestor is a RadioGroup.Option or the root RadioGroup itself.\n\nimport { useState } from 'react'\nimport { RadioGroup } from '@headlessui/react'\n\nfunction MyRadioGroup() {\n  const [selected, setSelected] = useState('startup')\n\n  return (\n    <RadioGroup value={selected} onChange={setSelected}>\n      {/* This label is for the root `RadioGroup`.  */}\n\n      <RadioGroup.Label className=\"sr-only\">Plan</RadioGroup.Label>\n\n      <div className=\"rounded-md bg-white\">\n        <RadioGroup.Option\n          value=\"startup\"\n          className={({ checked }) => `\n            ${checked ? 'border-indigo-200 bg-indigo-50' : 'border-gray-200'}\n            relative flex border p-4\n          `}\n        >\n          {({ checked }) => (\n            <div className=\"flex flex-col\">\n              {/* This label is for the `RadioGroup.Option`.  */}\n\n              <RadioGroup.Label\n                as=\"span\"\n                className={`${\n                  checked ? 'text-indigo-900' : 'text-gray-900'\n                } block text-sm font-medium`}\n              >\n                Startup\n              </RadioGroup.Label>\n              {/* This description is for the `RadioGroup.Option`.  */}\n\n              <RadioGroup.Description\n                as=\"span\"\n                className={`${\n                  checked ? 'text-indigo-700' : 'text-gray-500'\n                } block text-sm`}\n              >\n                Up to 5 active job postings\n              </RadioGroup.Description>\n            </div>\n          )}\n        </RadioGroup.Option>\n      </div>\n    </RadioGroup>\n  )\n}\n\nAccessibility notes\nMouse interaction\n\nClicking a RadioGroup.Option will select it.\n\nKeyboard interaction\n\nAll interactions apply when a RadioGroup component is focused.\n\nCommand\tDescription\n\n\nArrowDown\nor\nArrowUp\nor\nArrowLeft\nor\nArrowRight\n\n\t\n\nCycles through a RadioGroup's options\n\n\n\n\nSpace when no option is selected yet\n\n\t\n\nSelects the first option\n\n\n\n\nEnter when in a form\n\n\t\n\nSubmits the form\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nRadioGroup\n\nThe main Radio Group component.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the RadioGroup should render as.\n\n\nvalue\t—\t\nT | undefined\n\nThe current selected value in the RadioGroup.\n\n\ndefaultValue\t—\t\nT\n\nThe default value when using as an uncontrolled component.\n\n\nby\t—\t\nkeyof T | ((a: T, z: T) => boolean)\n\nUse this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.\n\n\nonChange\t—\t\n() => void\n\nThe function called to update the RadioGroup value.\n\n\ndisabled\tfalse\t\nboolean\n\nWhether or not the RadioGroup and all of its RadioGroup.Option's are disabled.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\nRadioGroup.Option\n\nThe wrapper component for each selectable option.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the RadioGroup.Option should render as.\n\n\nvalue\t—\t\nT | undefined\n\nThe value of the current RadioGroup.Option. The type should match the type of the value in the RadioGroup component.\n\n\ndisabled\tfalse\t\nboolean\n\nWhether or not the RadioGroup.Option is disabled.\n\nRender Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the option is active (using the mouse or keyboard).\n\n\nchecked\t\n\nBoolean\n\nWhether or not the current option is the checked value.\n\n\ndisabled\t\n\nboolean\n\nWhether or not the current option is disabled.\n\nRadioGroup.Label\n\nRenders an element whose id attribute is automatically generated, and is then linked to its nearest ancestor RadioGroup or RadioGroup.Option component via the aria-labelledby attribute.\n\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the RadioGroup.Label should render as.\n\nRadioGroup.Description\n\nRenders an element whose id attribute is automatically generated, and is then linked to its nearest ancestor RadioGroup or RadioGroup.Option component via the aria-describedby attribute.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the RadioGroup.Description should render as.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/popover",
    "html": "Popover\n\nPopovers are perfect for floating panels with arbitrary content like navigation menus, mobile menus and flyout menus.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nPopovers are built using the Popover, Popover.Button, and Popover.Panel components.\n\nClicking the Popover.Button will automatically open/close the Popover.Panel. When the panel is open, clicking anywhere outside of its contents, pressing the Escape key, or tabbing away from it will close the Popover.\n\nimport { Popover } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    <Popover className=\"relative\">\n      <Popover.Button>Solutions</Popover.Button>\n\n      <Popover.Panel className=\"absolute z-10\">\n        <div className=\"grid grid-cols-2\">\n          <a href=\"/analytics\">Analytics</a>\n          <a href=\"/engagement\">Engagement</a>\n          <a href=\"/security\">Security</a>\n          <a href=\"/integrations\">Integrations</a>\n        </div>\n\n        <img src=\"/solutions.jpg\" alt=\"\" />\n      </Popover.Panel>\n    </Popover>\n  )\n}\n\nThese components are completely unstyled, so how you style your Popover is up to you. In our example we're using absolute positioning on the Popover.Panel to position it near the Popover.Button and not disturb the normal document flow.\n\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a popover is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Popover component exposes an open state, which tells you if the popover is currently open.\n\nimport { Popover } from '@headlessui/react'\nimport { ChevronDownIcon } from '@heroicons/react/20/solid'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n\n      {({ open }) => (\n        /* Use the `open` state to conditionally change the direction of the chevron icon. */\n        <>\n          <Popover.Button>\n            Solutions\n            <ChevronDownIcon className={open ? 'rotate-180 transform' : ''} />\n          </Popover.Button>\n\n          <Popover.Panel>\n            <a href=\"/insights\">Insights</a>\n            <a href=\"/automations\">Automations</a>\n            <a href=\"/reports\">Reports</a>\n          </Popover.Panel>\n        </>\n      )}\n    </Popover>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Popover component renders when the popover is open:\n\n<!-- Rendered `Popover` -->\n<div data-headlessui-state=\"open\">\n  <button data-headlessui-state=\"open\">Solutions</button>\n  <div data-headlessui-state=\"open\">\n    <a href=\"/insights\">Insights</a>\n    <a href=\"/automations\">Automations</a>\n    <a href=\"/reports\">Reports</a>\n  </div>\n</div>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:*:\n\nimport { Popover } from '@headlessui/react'\nimport { ChevronDownIcon } from '@heroicons/react/20/solid'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n      <Popover.Button>\n        Solutions\n\n        <ChevronDownIcon className=\"ui-open:rotate-180 ui-open:transform\" />\n      </Popover.Button>\n      <Popover.Panel>\n        <a href=\"/insights\">Insights</a>\n        <a href=\"/automations\">Automations</a>\n        <a href=\"/reports\">Reports</a>\n      </Popover.Panel>\n    </Popover>\n  )\n}\n\nPositioning the panel\n\nTo get your Popover to actually render a floating panel near your button, you'll need to use some styling technique that relies on CSS, JS, or both. In the previous example we used CSS absolute and relative positioning so that the panel renders near the button that opened it.\n\nFor more sophisticated approaches, you might use a library like Popper JS. Here we use Popper's usePopper hook to render our Popover.Panel as a floating panel near the button.\n\nimport { useState } from 'react'\nimport { Popover } from '@headlessui/react'\nimport { usePopper } from 'react-popper'\n\nfunction MyPopover() {\n\n  let [referenceElement, setReferenceElement] = useState()\n  let [popperElement, setPopperElement] = useState()\n  let { styles, attributes } = usePopper(referenceElement, popperElement)\n\n  return (\n    <Popover>\n\n      <Popover.Button ref={setReferenceElement}>Solutions</Popover.Button>\n\n      <Popover.Panel\n\n        ref={setPopperElement}\n        style={styles.popper}\n        {...attributes.popper}\n      >\n        {/* ... */}\n      </Popover.Panel>\n    </Popover>\n  )\n}\n\nShowing/hiding the popover\n\nBy default, your Popover.Panel will be shown/hidden automatically based on the internal open state tracked within the Popover component itself.\n\nimport { Popover } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n      <Popover.Button>Solutions</Popover.Button>\n\n      {/*\n        By default, the `Popover.Panel` will automatically show/hide\n        when the `Popover.Button` is pressed.\n      */}\n      <Popover.Panel>{/* ... */}</Popover.Panel>\n    </Popover>\n  )\n}\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can pass a static prop to the Popover.Panel to tell it to always render, and then use the open render prop to control when the panel is shown/hidden yourself.\n\nimport { Popover } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n      {({ open }) => (\n        <>\n          <Popover.Button>Solutions</Popover.Button>\n\n\n          {open && (\n            <div>\n              {/*\n                Using the `static` prop, the `Popover.Panel` is always\n                rendered and the `open` state is ignored.\n              */}\n              <Popover.Panel static>{/* ... */}</Popover.Panel>\n            </div>\n          )}\n        </>\n      )}\n    </Popover>\n  )\n}\n\nClosing popovers manually\n\nSince popovers can contain interactive content like form controls, we can't automatically close them when you click something inside of them like we can with Menu components.\n\nTo close a popover manually when clicking a child of its panel, render that child as a Popover.Button. You can use the as prop to customize which element is being rendered.\n\nimport { Popover } from '@headlessui/react'\nimport MyLink from './MyLink'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n      <Popover.Button>Solutions</Popover.Button>\n      <Popover.Panel>\n\n        <Popover.Button as={MyLink} href=\"/insights\">\n          Insights\n        </Popover.Button>\n        {/* ... */}\n      </Popover.Panel>\n    </Popover>\n  )\n}\n\n\nAlternatively, Popover and Popover.Panel expose a close() render prop which you can use to imperatively close the panel, say after running an async action:\n\nimport { Popover } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n      <Popover.Button>Terms</Popover.Button>\n      <Popover.Panel>\n\n        {({ close }) => (\n          <button\n            onClick={async () => {\n\n              await fetch('/accept-terms', { method: 'POST' })\n              close()\n            }}\n          >\n            Read and accept\n          </button>\n        )}\n      </Popover.Panel>\n    </Popover>\n  )\n}\n\n\nBy default the Popover.Button receives focus after calling close(), but you can change this by passing a ref into close(ref).\n\nAdding an overlay\n\nIf you'd like to style a backdrop over your application UI whenever you open a Popover, use the Popover.Overlay component:\n\nimport { Popover } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n      {({ open }) => (\n        <>\n          <Popover.Button>Solutions</Popover.Button>\n\n          <Popover.Overlay className=\"fixed inset-0 bg-black opacity-30\" />\n\n          <Popover.Panel>{/* ... */}</Popover.Panel>\n        </>\n      )}\n    </Popover>\n  )\n}\n\n\nIn this example, we put the Popover.Overlay before the Panel in the DOM so that it doesn't cover up the panel's contents.\n\nBut like all the other components, Popover.Overlay is completely headless, so how you style it is up to you.\n\nTransitions\n\nTo animate the opening/closing of the popover panel, use the provided Transition component. All you need to do is wrap the Popover.Panel in a <Transition>, and the transition will be applied automatically.\n\nimport { Popover, Transition } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n      <Popover.Button>Solutions</Popover.Button>\n\n\n      <Transition\n        enter=\"transition duration-100 ease-out\"\n        enterFrom=\"transform scale-95 opacity-0\"\n        enterTo=\"transform scale-100 opacity-100\"\n        leave=\"transition duration-75 ease-out\"\n        leaveFrom=\"transform scale-100 opacity-100\"\n        leaveTo=\"transform scale-95 opacity-0\"\n      >\n        <Popover.Panel>{/* ... */}</Popover.Panel>\n\n      </Transition>\n    </Popover>\n  )\n}\n\n\nBy default our built-in Transition component automatically communicates with the Popover components to handle the open/closed states. However, if you require more control over this behavior, you can explicitly control it:\n\nimport { Popover, Transition } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    <Popover>\n\n      {({ open }) => (\n        <>\n          <Popover.Button>Solutions</Popover.Button>\n\n          {/* Use the `Transition` component. */}\n          <Transition\n\n            show={open}\n            enter=\"transition duration-100 ease-out\"\n            enterFrom=\"transform scale-95 opacity-0\"\n            enterTo=\"transform scale-100 opacity-100\"\n            leave=\"transition duration-75 ease-out\"\n            leaveFrom=\"transform scale-100 opacity-100\"\n            leaveTo=\"transform scale-95 opacity-0\"\n          >\n            {/* Mark this component as `static` */}\n\n            <Popover.Panel static>{/* ... */}</Popover.Panel>\n          </Transition>\n        </>\n      )}\n\n    </Popover>\n  )\n}\n\n\nBecause they're renderless, Headless UI components also compose well with other animation libraries in the React ecosystem like Framer Motion and React Spring.\n\nGrouping related popovers\n\nWhen rendering several related Popovers, for example in a site's header navigation, use the Popover.Group component. This ensures panels stay open while users are tabbing between Popovers within a group, but closes any open panel once the user tabs outside of the group:\n\nimport { Popover } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n\n    <Popover.Group>\n      <Popover>\n        <Popover.Button>Product</Popover.Button>\n        <Popover.Panel>{/* ... */}</Popover.Panel>\n      </Popover>\n\n      <Popover>\n        <Popover.Button>Solutions</Popover.Button>\n        <Popover.Panel>{/* ... */}</Popover.Panel>\n      </Popover>\n\n    </Popover.Group>\n  )\n}\n\nRendering a different element for a component\n\nPopover and its subcomponents each render a default element that is sensible for that component: the Popover, Overlay, Panel and Group components all render a <div>, and the Button component renders a <button>.\n\nThis is easy to change using the as prop, which exists on every component.\n\nimport { Popover } from '@headlessui/react'\n\nfunction MyPopover() {\n  return (\n    /* Render a `nav` instead of a `div` */\n\n    <Popover as=\"nav\">\n      <Popover.Button>Solutions</Popover.Button>\n\n      {/* Render a `form` instead of a `div` */}\n\n      <Popover.Panel as=\"form\">{/* ... */}</Popover.Panel>\n    </Popover>\n  )\n}\n\nAccessibility notes\nFocus management\n\nPressing Tab on an open panel will focus the first focusable element within the panel's contents. If a Popover.Group is being used, Tab cycles from the end of an open panel's content to the next Popover's button.\n\nMouse interaction\n\nClicking a Popover.Button toggles a panel open and closed. Clicking anywhere outside of an open panel will close that panel.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\nor\nSpacewhen a Popover.Button is focused.\n\n\t\n\nToggle panel\n\n\n\n\nEsc\n\n\t\n\nCloses any open Popovers\n\n\n\n\nTab\n\n\t\n\nCycle through an open panel's contents\n\nTabbing out of an open panel will close that panel, and tabbing from one open panel to a sibling Popover's button (within a Popover.Group) closes the first panel\n\n\n\n\nShift + Tab\n\n\t\n\nCycle backwards through the focus order\n\nOther\n\nNested Popovers are supported, and all panels will close correctly whenever the root panel is closed.\n\nAll relevant ARIA attributes are automatically managed.\n\nWhen to use a Popover\n\nHere's how Popovers compare to other similar components:\n\n<Menu />. Popovers are more general-purpose than Menus. Menus only support very restricted content and have specific accessibility semantics. Arrow keys also navigate a Menu's items. Menus are best for UI elements that resemble things like the menus you'd find in the title bar of most operating systems. If your floating panel has images or more markup than simple links, use a Popover.\n\n<Disclosure />. Disclosures are useful for things that typically reflow the document, like Accordions. Popovers also have extra behavior on top of Disclosures: they render overlays, and are closed when the user either clicks the overlay (by clicking outside of the Popover's content) or presses the escape key. If your UI element needs this behavior, use a Popover instead of a Disclosure.\n\n<Dialog />. Dialogs are meant to grab the user's full attention. They typically render a floating panel in the center of the screen, and use a backdrop to dim the rest of the application's contents. They also capture focus and prevent tabbing away from the Dialog's contents until the Dialog is dismissed. Popovers are more contextual, and are usually positioned near the element that triggered them.\n\nComponent API\nPopover\n\nThe main Popover component.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Popover should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the popover and refocuses Popover.Button. Optionally pass in a ref or HTMLElement to focus that element instead.\n\nPopover.Overlay\n\nThis can be used to create an overlay for your Popover component. Clicking on the overlay will close the Popover.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Popover.Overlay should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\nPopover.Button\n\nThis is the trigger component to toggle a Popover. You can also use this Popover.Button component inside a Popover.Panel, if you do so, then it will behave as a close button. We will also make sure to provide the correct aria-* attributes onto the button.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Popover.Button should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\nPopover.Panel\n\nThis component contains the contents of your Popover.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Popover.Panel should render as.\n\n\nfocus\tfalse\t\nBoolean\n\nThis will force focus inside the Popover.Panel when the Popover is open. It will also close the Popover if focus left this component.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the popover is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the popover and refocuses Popover.Button. Optionally pass in a ref or HTMLElement to focus that element instead.\n\nPopover.Group\n\nLink related sibling popovers by wrapping them in a Popover.Group. Tabbing out of one Popover.Panel will focus the next popover's Popover.Button, and tabbing outside of the Popover.Group completely will close all popovers inside the group.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Popover.Group should render as.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/dialog",
    "html": "Dialog (Modal)\n\nA fully-managed, renderless dialog component jam-packed with accessibility and keyboard features, perfect for building completely custom modal and dialog windows for your next application.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nDialogs are built using the Dialog, Dialog.Panel, Dialog.Title and Dialog.Description components.\n\nWhen the dialog's open prop is true, the contents of the dialog will render. Focus will be moved inside the dialog and trapped there as the user cycles through the focusable elements. Scroll is locked, the rest of your application UI is hidden from screen readers, and clicking outside the Dialog.Panel or pressing the Escape key will fire the close event and close the dialog.\n\nimport { useState } from 'react'\nimport { Dialog } from '@headlessui/react'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  return (\n    <Dialog open={isOpen} onClose={() => setIsOpen(false)}>\n      <Dialog.Panel>\n        <Dialog.Title>Deactivate account</Dialog.Title>\n        <Dialog.Description>\n          This will permanently deactivate your account\n        </Dialog.Description>\n\n        <p>\n          Are you sure you want to deactivate your account? All of your data\n          will be permanently removed. This action cannot be undone.\n        </p>\n\n        <button onClick={() => setIsOpen(false)}>Deactivate</button>\n        <button onClick={() => setIsOpen(false)}>Cancel</button>\n      </Dialog.Panel>\n    </Dialog>\n  )\n}\n\nIf your dialog has a title and description, use the Dialog.Title and Dialog.Description components to provide the most accessible experience. This will link your title and description to the root dialog component via the aria-labelledby and aria-describedby attributes, ensuring their contents are announced to users using screenreaders when your dialog opens.\n\nShowing and hiding your dialog\n\nDialogs have no automatic management of their open/closed state. To show and hide your dialog, pass React state into the open prop. When open is true the dialog will render, and when it's false the dialog will unmount.\n\nThe onClose callback fires when an open dialog is dismissed, which happens when the user clicks outside the your Dialog.Panel or presses the Escape key. You can use this callback to set open back to false and close your dialog.\n\nimport { useState } from 'react'\nimport { Dialog } from '@headlessui/react'\n\nfunction MyDialog() {\n  // The open/closed state lives outside of the Dialog and is managed by you\n\n  let [isOpen, setIsOpen] = useState(true)\n\n  function handleDeactivate() {\n    // ...\n  }\n\n  return (\n    /*\n      Pass `isOpen` to the `open` prop, and use `onClose` to set\n      the state back to `false` when the user clicks outside of\n      the dialog or presses the escape key.\n    */\n\n    <Dialog open={isOpen} onClose={() => setIsOpen(false)}>\n      <Dialog.Panel>\n        <Dialog.Title>Deactivate account</Dialog.Title>\n        <Dialog.Description>\n          This will permanently deactivate your account\n        </Dialog.Description>\n\n        <p>\n          Are you sure you want to deactivate your account? All of your data\n          will be permanently removed. This action cannot be undone.\n        </p>\n\n        {/*\n          You can render additional buttons to dismiss your dialog by setting\n          `isOpen` to `false`.\n        */}\n        <button onClick={() => setIsOpen(false)}>Cancel</button>\n        <button onClick={handleDeactivate}>Deactivate</button>\n\n      </Dialog.Panel>\n    </Dialog>\n  )\n}\n\nStyling the dialog\n\nStyle the Dialog and Dialog.Panel components using the className or style props like you would with any other element. You can also introduce additional elements if needed to achieve a particular design.\n\nimport { useState } from 'react'\nimport { Dialog } from '@headlessui/react'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  return (\n    <Dialog\n      open={isOpen}\n      onClose={() => setIsOpen(false)}\n      className=\"relative z-50\"\n    >\n      <div className=\"fixed inset-0 flex w-screen items-center justify-center p-4\">\n        <Dialog.Panel className=\"w-full max-w-sm rounded bg-white\">\n          <Dialog.Title>Complete your order</Dialog.Title>\n\n          {/* ... */}\n        </Dialog.Panel>\n      </div>\n    </Dialog>\n  )\n}\n\nClicking outside the Dialog.Panel component will close the dialog, so keep that in mind when deciding which styles to apply to which elements.\n\nAdding a backdrop\n\nIf you'd like to add an overlay or backdrop behind your Dialog.Panel to bring attention to the panel itself, we recommend using a dedicated element just for the backdrop and making it a sibling to your panel container:\n\nimport { useState } from 'react'\nimport { Dialog } from '@headlessui/react'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  return (\n    <Dialog\n      open={isOpen}\n      onClose={() => setIsOpen(false)}\n      className=\"relative z-50\"\n    >\n      {/* The backdrop, rendered as a fixed sibling to the panel container */}\n\n      <div className=\"fixed inset-0 bg-black/30\" aria-hidden=\"true\" />\n\n      {/* Full-screen container to center the panel */}\n      <div className=\"fixed inset-0 flex w-screen items-center justify-center p-4\">\n        {/* The actual dialog panel  */}\n        <Dialog.Panel className=\"mx-auto max-w-sm rounded bg-white\">\n          <Dialog.Title>Complete your order</Dialog.Title>\n\n          {/* ... */}\n        </Dialog.Panel>\n      </div>\n    </Dialog>\n  )\n}\n\n\nThis lets you transition the backdrop and panel independently with their own animations, and rendering it as a sibling ensures that it doesn't interfere with your ability to scroll long dialogs.\n\nScrollable dialogs\n\nMaking a dialog scrollable is handled entirely in CSS, and the specific implementation depends on the design you are trying to achieve.\n\nHere's an example where the entire panel container is scrollable, and the panel itself moves as you scroll:\n\nimport { useState } from 'react'\nimport { Dialog } from '@headlessui/react'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  return (\n    <Dialog\n      open={isOpen}\n      onClose={() => setIsOpen(false)}\n      className=\"relative z-50\"\n    >\n      {/* The backdrop, rendered as a fixed sibling to the panel container */}\n      <div className=\"fixed inset-0 bg-black/30\" aria-hidden=\"true\" />\n\n      {/* Full-screen scrollable container */}\n\n      <div className=\"fixed inset-0 w-screen overflow-y-auto\">\n        {/* Container to center the panel */}\n\n        <div className=\"flex min-h-full items-center justify-center p-4\">\n          {/* The actual dialog panel  */}\n          <Dialog.Panel className=\"mx-auto max-w-sm rounded bg-white\">\n            <Dialog.Title>Complete your order</Dialog.Title>\n\n            {/* ... */}\n          </Dialog.Panel>\n        </div>\n      </div>\n    </Dialog>\n  )\n}\n\n\nWhen creating a scrollable dialog with a backdrop, make sure the backdrop is rendered behind the scrollable container, otherwise the scroll wheel won't work when hovering over the backdrop, and the backdrop may obscure the scrollbar and prevent users from clicking it with their mouse.\n\nManaging initial focus\n\nFor accessibility reasons, your dialog should contain at least one focusable element. By default, the Dialog component will focus the first focusable element (by DOM order) once it is rendered, and pressing the Tab key will cycle through all additional focusable elements within the contents.\n\nFocus is trapped within the dialog as long as it is rendered, so tabbing to the end will start cycling back through the beginning again. All other application elements outside of the dialog will be marked as inert and thus not focusable.\n\nIf you'd like something other than the first focusable element to receive initial focus when your dialog is initially rendered, you can use the initialFocus ref:\n\nimport { useState, useRef } from 'react'\nimport { Dialog } from '@headlessui/react'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  let completeButtonRef = useRef(null)\n\n  function completeOrder() {\n    // ...\n  }\n\n  return (\n    /* Use `initialFocus` to force initial focus to a specific ref. */\n    <Dialog\n\n      initialFocus={completeButtonRef}\n      open={isOpen}\n      onClose={() => setIsOpen(false)}\n    >\n      <Dialog.Panel>\n        <Dialog.Title>Complete your order</Dialog.Title>\n\n        <p>Your order is all ready!</p>\n\n        <button onClick={() => setIsOpen(false)}>Cancel</button>\n\n        <button ref={completeButtonRef} onClick={completeOrder}>\n          Complete order\n        </button>\n      </Dialog.Panel>\n    </Dialog>\n  )\n}\n\nRendering to a portal\n\nIf you've ever implemented a Dialog before, you've probably come across Portals in React. Portals let you invoke components from one place in the DOM (for instance deep within your application UI), but actually render to another place in the DOM entirely.\n\nSince Dialogs and their backdrops take up the full page, you typically want to render them as a sibling to the root-most node of your React application. That way you can rely on natural DOM ordering to ensure that their content is rendered on top of your existing application UI. This also makes it easy to apply scroll locking to the rest of your application, as well as ensure that your Dialog's contents and backdrop are unobstructed to receive focus and click events.\n\nBecause of these accessibility concerns, Headless UI's Dialog component actually uses a Portal under-the-hood. This way we can provide features like unobstructed event handling and making the rest of your application inert. So, when using our Dialog, there's no need to use a Portal yourself! We've already taken care of it.\n\nTransitions\n\nTo animate the opening/closing of the dialog, use the Transition component. All you need to do is wrap the Dialog in a <Transition>, and dialog will transition automatically based on the state of the show prop on the <Transition>.\n\nWhen using <Transition> with your dialogs, you can remove the open prop, as the dialog will read the show state from the <Transition> automatically.\n\nimport { useState, Fragment } from 'react'\nimport { Dialog, Transition } from '@headlessui/react'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  return (\n\n    <Transition\n      show={isOpen}\n      enter=\"transition duration-100 ease-out\"\n      enterFrom=\"transform scale-95 opacity-0\"\n      enterTo=\"transform scale-100 opacity-100\"\n      leave=\"transition duration-75 ease-out\"\n      leaveFrom=\"transform scale-100 opacity-100\"\n      leaveTo=\"transform scale-95 opacity-0\"\n      as={Fragment}\n    >\n      <Dialog onClose={() => setIsOpen(false)}>\n        <Dialog.Panel>\n          <Dialog.Title>Deactivate account</Dialog.Title>\n          {/* ... */}\n        </Dialog.Panel>\n      </Dialog>\n    </Transition>\n  )\n}\n\n\nTo animate your backdrop and panel separately, wrap your Dialog in Transition and wrap your backdrop and panel each with their own Transition.Child:\n\nimport { useState, Fragment } from 'react'\nimport { Dialog, Transition } from '@headlessui/react'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  return (\n    // Use the `Transition` component at the root level\n\n    <Transition show={isOpen} as={Fragment}>\n      <Dialog onClose={() => setIsOpen(false)}>\n        {/*\n          Use one Transition.Child to apply one transition to the backdrop...\n        */}\n\n        <Transition.Child\n          as={Fragment}\n          enter=\"ease-out duration-300\"\n          enterFrom=\"opacity-0\"\n          enterTo=\"opacity-100\"\n          leave=\"ease-in duration-200\"\n          leaveFrom=\"opacity-100\"\n          leaveTo=\"opacity-0\"\n        >\n          <div className=\"fixed inset-0 bg-black/30\" />\n        </Transition.Child>\n\n        {/*\n          ...and another Transition.Child to apply a separate transition\n          to the contents.\n        */}\n\n        <Transition.Child\n          as={Fragment}\n          enter=\"ease-out duration-300\"\n          enterFrom=\"opacity-0 scale-95\"\n          enterTo=\"opacity-100 scale-100\"\n          leave=\"ease-in duration-200\"\n          leaveFrom=\"opacity-100 scale-100\"\n          leaveTo=\"opacity-0 scale-95\"\n        >\n          <Dialog.Panel>\n            <Dialog.Title>Deactivate account</Dialog.Title>\n\n            {/* ... */}\n          </Dialog.Panel>\n        </Transition.Child>\n      </Dialog>\n    </Transition>\n  )\n}\n\n\nIf you want to animate your dialogs using another animation library like Framer Motion or React Spring and need more control, you can use the static prop to tell Headless UI not to manage rendering itself, and control it manually with another tool:\n\nimport { useState } from 'react'\nimport { Dialog } from '@headlessui/react'\nimport { AnimatePresence, motion } from 'framer-motion'\n\nfunction MyDialog() {\n  let [isOpen, setIsOpen] = useState(true)\n\n  return (\n    // Use the `Transition` component + show prop to add transitions.\n\n    <AnimatePresence>\n      {open && (\n        <Dialog\n          static\n          as={motion.div}\n          open={isOpen}\n          onClose={() => setIsOpen(false)}\n        >\n          <div className=\"fixed inset-0 bg-black/30\" />\n\n          <Dialog.Panel>\n            <Dialog.Title>Deactivate account</Dialog.Title>\n\n            {/* ... */}\n          </Dialog.Panel>\n        </Dialog>\n      )}\n\n    </AnimatePresence>\n  )\n}\n\n\nThe open prop is still used for manage scroll locking and focus trapping, but as long as static is present, the actual element will always be rendered regardless of the open value, which allows you to control it yourself externally.\n\nAccessibility notes\nFocus management\n\nWhen the Dialog's open prop is true, the contents of the Dialog will render and focus will be moved inside the Dialog and trapped there. The first focusable element according to DOM order will receive focus, although you can use the initialFocus ref to control which element receives initial focus. Pressing Tab on an open Dialog cycles through all the focusable elements.\n\nMouse interaction\n\nWhen a Dialog is rendered, clicking outside of the Dialog.Panel will close the Dialog.\n\nNo mouse interaction to open the Dialog is included out-of-the-box, though typically you will wire a <button /> element up with an onClick handler that toggles the Dialog's open prop to true.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEsc\n\n\t\n\nCloses any open Dialogs\n\n\n\n\nTab\n\n\t\n\nCycles through an open Dialog's contents\n\n\n\n\nShift + Tab\n\n\t\n\nCycles backwards through an open Dialog's contents\n\nOther\n\nWhen a Dialog is open, scroll is locked and the rest of your application UI is hidden from screen readers.\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nDialog\n\nThe main Dialog component.\n\nProp\tDefault\tDescription\nopen\t—\t\nBoolean\n\nWhether the Dialog is open or not.\n\n\nonClose\t—\t\n(false) => void\n\nCalled when the Dialog is dismissed (via outside click of the Dialog.Panel or by pressing the Escape key). Typically used to close the dialog by setting open to false.\n\n\ninitialFocus\t—\t\nReact.MutableRefObject\n\nA ref to an element that should receive focus first.\n\n\nas\tdiv\t\nString | Component\n\nThe element or component the Dialog should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialog.Panel\n\nThis indicates the panel of your actual Dialog. Clicking outside of this component will trigger the onClose of the Dialog component.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Dialog.Panel should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialog.Title\n\nThis is the title for your Dialog. When this is used, it will set the aria-labelledby on the Dialog.\n\nProp\tDefault\tDescription\nas\th2\t\nString | Component\n\nThe element or component the Dialog.Title should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialog.Description\n\nThis is the description for your Dialog. When this is used, it will set the aria-describedby on the Dialog.\n\nProp\tDefault\tDescription\nas\tp\t\nString | Component\n\nThe element or component the Dialog.Description should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n\nDialog.Overlay\n\nAs of Headless UI v1.6, Dialog.Overlay is deprecated, see the release notes for migration instructions.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Dialog.Overlay should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the dialog is open.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/disclosure",
    "html": "Disclosure\n\nA simple, accessible foundation for building custom UIs that show and hide content, like togglable accordion panels.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nDisclosures are built using the Disclosure, Disclosure.Button and Disclosure.Panel components.\n\nThe button will automatically open/close the panel when clicked, and all components will receive the appropriate aria-* related attributes like aria-expanded and aria-controls.\n\nimport { Disclosure } from '@headlessui/react'\n\nfunction MyDisclosure() {\n  return (\n    <Disclosure>\n      <Disclosure.Button className=\"py-2\">\n        Is team pricing available?\n      </Disclosure.Button>\n      <Disclosure.Panel className=\"text-gray-500\">\n        Yes! You can purchase a license that you can share with your entire\n        team.\n      </Disclosure.Panel>\n    </Disclosure>\n  )\n}\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a disclosure is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Disclosure component exposes an open state, which tells you if the disclosure is currently open.\n\nimport { Disclosure } from '@headlessui/react'\nimport { ChevronRightIcon } from '@heroicons/react/20/solid'\n\nfunction MyDisclosure() {\n  return (\n    <Disclosure>\n\n      {({ open }) => (\n        /* Use the `open` state to conditionally change the direction of an icon. */\n        <>\n          <Disclosure.Button>\n            Do you offer technical support?\n\n            <ChevronRightIcon className={open ? 'rotate-90 transform' : ''} />\n          </Disclosure.Button>\n          <Disclosure.Panel>No</Disclosure.Panel>\n        </>\n      )}\n    </Disclosure>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Disclosure component renders when the disclosure is open:\n\n<!-- Rendered `Disclosure` -->\n<div data-headlessui-state=\"open\">\n  <button data-headlessui-state=\"open\">Do you offer technical support?</button>\n  <div data-headlessui-state=\"open\">No</div>\n</div>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:*:\n\nimport { Disclosure } from '@headlessui/react'\nimport { ChevronRightIcon } from '@heroicons/react/20/solid'\n\nfunction MyDisclosure() {\n  return (\n    <Disclosure>\n      <Disclosure.Button>\n        Do you offer technical support?\n\n        <ChevronRightIcon className=\"ui-open:rotate-90 ui-open:transform\" />\n      </Disclosure.Button>\n      <Disclosure.Panel>No</Disclosure.Panel>\n    </Disclosure>\n  )\n}\n\nClosing disclosures manually\n\nTo close a disclosure manually when clicking a child of its panel, render that child as a Disclosure.Button. You can use the as prop to customize which element is being rendered.\n\nimport { Disclosure } from '@headlessui/react'\nimport MyLink from './MyLink'\n\nfunction MyDisclosure() {\n  return (\n    <Disclosure>\n      <Disclosure.Button>Open mobile menu</Disclosure.Button>\n      <Disclosure.Panel>\n\n        <Disclosure.Button as={MyLink} href=\"/home\">\n          Home\n        </Disclosure.Button>\n        {/* ... */}\n      </Disclosure.Panel>\n    </Disclosure>\n  )\n}\n\n\nThis is especially useful when using disclosures for things like mobile menus that contain links where you want the disclosure to close when navigating to the next page.\n\nAlternatively, Disclosure and Disclosure.Panel expose a close() render prop which you can use to imperatively close the panel, say after running an async action:\n\nimport { Disclosure } from '@headlessui/react'\n\nfunction MyDisclosure() {\n  return (\n    <Disclosure>\n      <Disclosure.Button>Terms</Disclosure.Button>\n      <Disclosure.Panel>\n\n        {({ close }) => (\n          <button\n            onClick={async () => {\n\n              await fetch('/accept-terms', { method: 'POST' })\n              close()\n            }}\n          >\n            Read and accept\n          </button>\n        )}\n      </Disclosure.Panel>\n    </Disclosure>\n  )\n}\n\n\nBy default the Disclosure.Button receives focus after calling close(), but you can change this by passing a ref into close(ref).\n\nTransitions\n\nTo animate the opening/closing of the menu panel, use the provided Transition component. All you need to do is wrap the Disclosure.Panel in a <Transition>, and the transition will be applied automatically.\n\nimport { Disclosure, Transition } from '@headlessui/react'\n\nfunction MyDisclosure() {\n  return (\n    <Disclosure>\n      <Disclosure.Button>Is team pricing available?</Disclosure.Button>\n\n\n      <Transition\n        enter=\"transition duration-100 ease-out\"\n        enterFrom=\"transform scale-95 opacity-0\"\n        enterTo=\"transform scale-100 opacity-100\"\n        leave=\"transition duration-75 ease-out\"\n        leaveFrom=\"transform scale-100 opacity-100\"\n        leaveTo=\"transform scale-95 opacity-0\"\n      >\n        <Disclosure.Panel>\n\n          Yes! You can purchase a license that you can share with your entire\n          team.\n        </Disclosure.Panel>\n      </Transition>\n    </Disclosure>\n  )\n}\n\n\nBy default our built-in Transition component automatically communicates with the Disclosure components to handle the open/closed states. However, if you require more control over this behavior, you can explicitly control it:\n\nimport { Disclosure, Transition } from '@headlessui/react'\n\nfunction MyDisclosure() {\n  return (\n    <Disclosure>\n\n      {({ open }) => (\n        <>\n          <Disclosure.Button>Is team pricing available?</Disclosure.Button>\n\n          {/*\n            Use the `Transition` + `open` render prop argument to add transitions.\n          */}\n\n          <Transition\n            show={open}\n            enter=\"transition duration-100 ease-out\"\n            enterFrom=\"transform scale-95 opacity-0\"\n            enterTo=\"transform scale-100 opacity-100\"\n            leave=\"transition duration-75 ease-out\"\n            leaveFrom=\"transform scale-100 opacity-100\"\n            leaveTo=\"transform scale-95 opacity-0\"\n          >\n            {/*\n              Don't forget to add `static` to your `Disclosure.Panel`!\n            */}\n\n            <Disclosure.Panel static>\n              Yes! You can purchase a license that you can share with your\n\n              entire team.\n            </Disclosure.Panel>\n          </Transition>\n        </>\n      )}\n    </Disclosure>\n  )\n}\n\n\nBecause they're renderless, Headless UI components also compose well with other animation libraries in the React ecosystem like Framer Motion and React Spring.\n\nRendering a different element for a component\n\nDisclosure and its subcomponents each render a default element that is sensible for that component: the Button renders a <button>, Panel renders a <div>. By contrast, the root Disclosure component does not render an element, and instead renders its children directly by default.\n\nThis is easy to change using the as prop, which exists on every component.\n\nimport { Fragment } from 'react'\nimport { Disclosure } from '@headlessui/react'\n\nfunction MyDisclosure() {\n  return (\n    /* Render a `div` for the root `Disclosure` component */\n\n    <Disclosure as=\"div\">\n      {/* Render a `Fragment` for the `Disclosure.Button` component */}\n\n      <Disclosure.Button as={Fragment}>\n        <button>What languages do you support?</button>\n      </Disclosure.Button>\n\n      {/* Render a `ul` for the `Disclosure.Panel` component */}\n\n      <Disclosure.Panel as=\"ul\">\n        <li>HTML</li>\n        <li>CSS</li>\n        <li>JavaScript</li>\n      </Disclosure.Panel>\n    </Disclosure>\n  )\n}\n\nAccessibility notes\nMouse interaction\n\nClicking a Disclosure.Button toggles the Disclosure's panel open and closed.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\nor\nSpace when a Disclosure.Button is focused.\n\n\t\n\nToggles panel\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nDisclosure\n\nThe main Disclosure component.\n\nProp\tDefault\tDescription\nas\tFragment\t\nString | Component\n\nThe element or component the Disclosure should render as.\n\n\ndefaultOpen\tfalse\t\nBoolean\n\nWhether or not the Disclosure component should be open by default.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the disclosure is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the disclosure and refocuses Disclosure.Button. Optionally pass in a ref or HTMLElement to focus that element instead.\n\nDisclosure.Button\n\nThe trigger component that toggles a Disclosure.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Disclosure.Button should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the disclosure is open.\n\nDisclosure.Panel\n\nThis component contains the contents of your disclosure.\n\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Disclosure.Panel should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the disclosure is open.\n\n\nclose\t\n\n(ref?: ref | HTMLElement) => void\n\nCloses the disclosure and refocuses Disclosure.Button. Optionally pass in a ref or HTMLElement to focus that element instead.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/switch",
    "html": "Switch (Toggle)\n\nSwitches are a pleasant interface for toggling a value between two states, and offer the same semantics and keyboard navigation as native checkbox elements.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nSwitches are built using the Switch component. You can toggle your Switch by clicking directly on the component, or by pressing the spacebar while its focused.\n\nToggling the switch calls the onChange function with a negated version of the checked value.\n\nimport { useState } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction MyToggle() {\n  const [enabled, setEnabled] = useState(false)\n\n  return (\n    <Switch\n      checked={enabled}\n      onChange={setEnabled}\n      className={`${\n        enabled ? 'bg-blue-600' : 'bg-gray-200'\n      } relative inline-flex h-6 w-11 items-center rounded-full`}\n    >\n      <span className=\"sr-only\">Enable notifications</span>\n      <span\n        className={`${\n          enabled ? 'translate-x-6' : 'translate-x-1'\n        } inline-block h-4 w-4 transform rounded-full bg-white transition`}\n      />\n    </Switch>\n  )\n}\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which switch option is currently selected, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Switch component exposes an checked state, which tells you if the switch is currently checked or not.\n\nimport { useState, Fragment } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction MyToggle() {\n  const [enabled, setEnabled] = useState(false)\n\n  return (\n    <Switch checked={enabled} onChange={setEnabled} as={Fragment}>\n\n      {({ checked }) => (\n        /* Use the `checked` state to conditionally style the button. */\n        <button\n          className={`${\n\n            checked ? 'bg-blue-600' : 'bg-gray-200'\n          } relative inline-flex h-6 w-11 items-center rounded-full`}\n        >\n          <span className=\"sr-only\">Enable notifications</span>\n          <span\n            className={`${\n\n              checked ? 'translate-x-6' : 'translate-x-1'\n            } inline-block h-4 w-4 transform rounded-full bg-white transition`}\n          />\n        </button>\n      )}\n    </Switch>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Switch component renders when the switch is checked:\n\n<!-- Rendered `Switch` -->\n<button data-headlessui-state=\"checked\"></button>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-checked:*:\n\nimport { useState } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction MyToggle() {\n  const [enabled, setEnabled] = useState(false)\n\n  return (\n    <Switch\n      checked={enabled}\n      onChange={setEnabled}\n\n      className=\"relative inline-flex h-6 w-11 items-center rounded-full ui-checked:bg-blue-600 ui-not-checked:bg-gray-200\"\n    >\n      <span className=\"sr-only\">Enable notifications</span>\n\n      <span className=\"inline-block h-4 w-4 transform rounded-full bg-white transition ui-checked:translate-x-6 ui-not-checked:translate-x-1\" />\n    </Switch>\n  )\n}\n\nUsing a custom label\n\nBy default, a Switch renders a button as well as whatever children you pass into it. This can make it harder to implement certain UIs, since the children will be nested within the button.\n\nIn these situations, you can use the Switch.Label component for more flexibility.\n\nThis example demonstrates how to use the Switch.Group, Switch and Switch.Label components to render a label as a sibling to the button. Note that Switch.Label works alongside a Switch component, and they both must be rendered within a parent Switch.Group component.\n\nimport { useState } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction MyToggle() {\n  const [enabled, setEnabled] = useState(false)\n\n  return (\n\n    <Switch.Group>\n      <div className=\"flex items-center\">\n\n        <Switch.Label className=\"mr-4\">Enable notifications</Switch.Label>\n        <Switch\n          checked={enabled}\n          onChange={setEnabled}\n          className={`${\n            enabled ? 'bg-blue-600' : 'bg-gray-200'\n          } relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2`}\n        >\n          <span\n            className={`${\n              enabled ? 'translate-x-6' : 'translate-x-1'\n            } inline-block h-4 w-4 transform rounded-full bg-white transition-transform`}\n          />\n        </Switch>\n      </div>\n\n    </Switch.Group>\n  )\n}\n\n\nBy default, clicking a Switch.Label will toggle the Switch, just like labels in native HTML checkboxes do. If you'd like to make the label non-clickable (which you might if it doesn't make sense for your design), you can add a passive prop to the Switch.Label component:\n\nimport { useState } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction MyToggle() {\n  const [enabled, setEnabled] = useState(false)\n\n  return (\n    <Switch.Group>\n\n      <Switch.Label passive>Enable notifications</Switch.Label>\n      <Switch checked={enabled} onChange={setEnabled}>\n        {/* ... */}\n      </Switch>\n    </Switch.Group>\n  )\n}\n\nUsing with HTML forms\n\nIf you add the name prop to your switch, a hidden input element will be rendered and kept in sync with the switch state.\n\nimport { useState } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction Example() {\n  const [enabled, setEnabled] = useState(true)\n\n  return (\n    <form action=\"/notification-settings\" method=\"post\">\n\n      <Switch checked={enabled} onChange={setEnabled} name=\"notifications\">\n        {/* ... */}\n      </Switch>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis lets you use a switch inside a native HTML <form> and make traditional form submissions as if your switch was a native HTML form control.\n\nBy default, the value will be 'on' when the switch is checked, and not present when the switch is unchecked.\n\n<input type=\"hidden\" name=\"notifications\" value=\"on\" />\n\nYou can customize the value if needed by using the value prop:\n\nimport { useState } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction Example() {\n  const [enabled, setEnabled] = useState(true)\n\n  return (\n    <form action=\"/accounts\" method=\"post\">\n      <Switch\n        checked={enabled}\n        onChange={setEnabled}\n\n        name=\"terms\"\n        value=\"accept\"\n      >\n        {/* ... */}\n      </Switch>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThe hidden input will then use your custom value when the switch is checked:\n\n<input type=\"hidden\" name=\"terms\" value=\"accept\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultChecked prop to the Switch instead of a checked prop, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\nYou can access the current state via the checked render prop on the Switch component.\n\nimport { Fragment } from 'react'\nimport { Switch } from '@headlessui/react'\n\nfunction Example() {\n  return (\n    <form action=\"/accounts\" method=\"post\">\n\n      <Switch name=\"terms-of-service\" defaultChecked={true} as={Fragment}>\n        {({ checked }) => (\n          <button\n            className={`${\n              checked ? 'bg-blue-600' : 'bg-gray-200'\n            } relative inline-flex h-6 w-11 items-center rounded-full`}\n          >\n            <span className=\"sr-only\">Enable notifications</span>\n            <span\n              className={`${\n                checked ? 'translate-x-6' : 'translate-x-1'\n              } inline-block h-4 w-4 transform rounded-full bg-white transition`}\n            />\n          </button>\n        )}\n      </Switch>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis can simplify your code when using the listbox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny onChange prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nTransitions\n\nBecause Switches are typically always rendered to the DOM (rather than being mounted/unmounted like other components), simple CSS transitions are often enough to animate your Switch:\n\nimport { useState } from \"react\";\nimport { Switch } from \"@headlessui/react\";\n\nfunction MyToggle() {\n  const [enabled, setEnabled] = useState(false);\n\n  return (\n    <Switch checked={enabled} onChange={setEnabled}>\n      <span\n        /* Transition the switch's knob on state change */\n\n        className={`transform transition ease-in-out duration-200\n          ${enabled ? \"translate-x-9\" : \"translate-x-0\"}\n        `}\n      />\n      {/* ... */}\n    </Switch>\n  );\n}\n\n\nBecause they're renderless, Headless UI components also compose well with other animation libraries in the React ecosystem like Framer Motion and React Spring.\n\nAccessibility notes\nLabels\n\nBy default, the children of a Switch will be used as the label for screen readers. If you're using Switch.Label, the content of your Switch component will be ignored by assistive technologies.\n\nMouse interaction\n\nClicking a Switch or a Switch.Label toggles the Switch on and off.\n\nKeyboard interaction\nCommand\tDescription\n\n\nSpace when a Switch is focused\n\n\t\n\nToggles the Switch\n\n\n\n\nEnter when in a form\n\n\t\n\nSubmits the form\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nSwitch\n\nThe main Switch component.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Switch should render as.\n\n\nchecked\t—\t\nBoolean\n\nWhether or not the switch is checked.\n\n\ndefaultChecked\t—\t\nT\n\nThe default checked value when using as an uncontrolled component.\n\n\nonChange\t—\t\n(value: Boolean) => void\n\nThe function to call when the switch is toggled.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\n\nvalue\t—\t\nString\n\nThe value used when using this component inside a form, if it is checked.\n\nRender Prop\tDescription\nchecked\t\n\nBoolean\n\nWhether or not the switch is checked.\n\nSwitch.Label\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the Switch.Label should render as.\n\n\npassive\tfalse\t\nBoolean\n\nWhen true, clicking the label won't toggle the Switch.\n\nSwitch.Description\nProp\tDefault\tDescription\nas\tp\t\nString | Component\n\nThe element or component the Switch.Description should render as.\n\nSwitch.Group\nProp\tDefault\tDescription\nas\tFragment\t\nString | Component\n\nThe element or component the Switch.Group should render as.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/combobox",
    "html": "Combobox (Autocomplete)\n\nComboboxes are the foundation of accessible autocompletes and command palettes for your app, complete with robust support for keyboard navigation.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nComboboxes are built using the Combobox, Combobox.Input, Combobox.Button, Combobox.Options, Combobox.Option and Combobox.Label components.\n\nThe Combobox.Input will automatically open/close the Combobox.Options when searching.\n\nYou are completely in charge of how you filter the results, whether it be with a fuzzy search library client-side or by making server-side requests to an API. In this example we will keep the logic simple for demo purposes.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  'Durward Reynolds',\n  'Kenton Towne',\n  'Therese Wunsch',\n  'Benedict Kessler',\n  'Katelyn Rohan',\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input onChange={(event) => setQuery(event.target.value)} />\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          <Combobox.Option key={person} value={person}>\n            {person}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Combobox.Option component exposes an active state, which tells you if the option is currently focused via the mouse or keyboard, and a selected state, which tells you if that option matches the current value of the Combobox.\n\nimport { useState, Fragment } from 'react'\nimport { Combobox } from '@headlessui/react'\nimport { CheckIcon } from '@heroicons/react/20/solid'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          /* Use the `active` state to conditionally style the active option. */\n          /* Use the `selected` state to conditionally style the selected option. */\n          <Combobox.Option key={person.id} value={person} as={Fragment}>\n\n            {({ active, selected }) => (\n              <li\n                className={`${\n\n                  active ? 'bg-blue-500 text-white' : 'bg-white text-black'\n                }`}\n              >\n\n                {selected && <CheckIcon />}\n                {person.name}\n              </li>\n            )}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Combobox.Options component with some child Combobox.Option components renders when the combobox is open and the second option is both selected and active:\n\n<!-- Rendered `Combobox.Options` -->\n<ul data-headlessui-state=\"open\">\n  <li data-headlessui-state=\"\">Wade Cooper</li>\n  <li data-headlessui-state=\"active selected\">Arlene Mccoy</li>\n  <li data-headlessui-state=\"\">Devon Webb</li>\n</ul>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\nimport { useState, Fragment } from 'react'\nimport { Combobox } from '@headlessui/react'\nimport { CheckIcon } from '@heroicons/react/20/solid'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          <Combobox.Option\n            key={person.id}\n            value={person}\n\n            className=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n          >\n\n            <CheckIcon className=\"hidden ui-selected:block\" />\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\nBinding objects as values\n\nUnlike native HTML form controls which only allow you to provide strings as values, Headless UI supports binding complex objects as well.\n\nWhen binding objects, make sure to set the displayValue on your Combobox.Input so that a string representation of the selected option can be rendered in the input:\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds', unavailable: false },\n  { id: 2, name: 'Kenton Towne', unavailable: false },\n  { id: 3, name: 'Therese Wunsch', unavailable: false },\n  { id: 4, name: 'Benedict Kessler', unavailable: true },\n  { id: 5, name: 'Katelyn Rohan', unavailable: false },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n\n        displayValue={(person) => person.name}\n      />\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          <Combobox.Option\n            key={person.id}\n\n            value={person}\n            disabled={person.unavailable}\n          >\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\n\nWhen binding objects as values, it's important to make sure that you use the same instance of the object as both the value of the Combobox as well as the corresponding Combobox.Option, otherwise they will fail to be equal and cause the combobox to behave incorrectly.\n\nTo make it easier to work with different instances of the same object, you can use the by prop to compare the objects by a particular field instead of comparing object identity:\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst departments = [\n  { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n  { id: 2, name: 'HR', contact: 'Kenton Towne' },\n  { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n  { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n  { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n]\n\n\nfunction DepartmentPicker({ selectedDepartment, onChange }) {\n  const [query, setQuery] = useState('')\n\n  const filteredDepartments =\n    query === ''\n      ? departments\n      : departments.filter((department) => {\n          return department.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n\n    <Combobox value={selectedDepartment} by=\"id\" onChange={onChange}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(department) => department.name}\n      />\n      <Combobox.Options>\n        {filteredDepartments.map((department) => (\n          <Combobox.Option key={department.id} value={department}>\n            {department.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\n\nYou can also pass your own comparison function to the by prop if you'd like complete control over how objects are compared:\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst departments = [\n  { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n  { id: 2, name: 'HR', contact: 'Kenton Towne' },\n  { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n  { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n  { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n]\n\n\nfunction compareDepartments(a, b) {\n  return a.name.toLowerCase() === b.name.toLowerCase()\n}\n\nfunction DepartmentPicker({ selectedDepartment, onChange }) {\n  const [query, setQuery] = useState('')\n\n  const filteredDepartments =\n    query === ''\n      ? departments\n      : departments.filter((department) => {\n          return department.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox\n      value={selectedDepartment}\n\n      by={compareDepartments}\n      onChange={onChange}\n    >\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(department) => department.name}\n      />\n      <Combobox.Options>\n        {filteredDepartments.map((department) => (\n          <Combobox.Option key={department.id} value={department}>\n            {department.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\nSelecting multiple values\n\nTo allow selecting multiple values in your combobox, use the multiple prop and pass an array to value instead of a single option.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n\n  const [selectedPeople, setSelectedPeople] = useState([people[0], people[1]])\n\n  return (\n    <Combobox value={selectedPeople} onChange={setSelectedPeople} multiple>\n      {selectedPeople.length > 0 && (\n        <ul>\n          {selectedPeople.map((person) => (\n            <li key={person.id}>{person.name}</li>\n          ))}\n        </ul>\n      )}\n\n      <Combobox.Input />\n      <Combobox.Options>\n        {people.map((person) => (\n          <Combobox.Option key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\n\nThe displayValue prop is omitted because the selectedPeople is already displayed in a list above the input. If you wish to display the items in the Combobox.Input then the displayValue receives an array.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n\n  const [selectedPeople, setSelectedPeople] = useState([people[0], people[1]])\n\n  return (\n    <Combobox value={selectedPeople} onChange={setSelectedPeople} multiple>\n      <Combobox.Input\n\n        displayValue={(people) =>\n          people.map((person) => person.name).join(', ')\n        }\n      />\n      <Combobox.Options>\n        {people.map((person) => (\n          <Combobox.Option key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\n\nThis will keep the combobox open when you are selecting options, and choosing an option will toggle it in place.\n\nYour onChange handler will be called with an array containing all selected options any time an option is added or removed.\n\nUsing a custom label\n\nBy default the Combobox will use the input contents as the label for screenreaders. If you'd like more control over what is announced to assistive technologies, use the Combobox.Label component.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n\n      <Combobox.Label>Assignee:</Combobox.Label>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          <Combobox.Option key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\nUsing with HTML forms\n\nIf you add the name prop to your combobox, hidden input elements will be rendered and kept in sync with your selected value.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction Example() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <form action=\"/projects/1/assignee\" method=\"post\">\n      <Combobox\n        value={selectedPerson}\n        onChange={setSelectedPerson}\n\n        name=\"assignee\"\n      >\n        <Combobox.Input\n          onChange={(event) => setQuery(event.target.value)}\n          displayValue={(person) => person.name}\n        />\n        <Combobox.Options>\n          {filteredPeople.map((person) => (\n            <Combobox.Option key={person.id} value={person}>\n              {person.name}\n            </Combobox.Option>\n          ))}\n        </Combobox.Options>\n      </Combobox>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis lets you use a combobox inside a native HTML <form> and make traditional form submissions as if your combobox was a native HTML form control.\n\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like objects will be encoded into multiple inputs using a square bracket notation for the names:\n\n<input type=\"hidden\" name=\"assignee[id]\" value=\"1\" />\n<input type=\"hidden\" name=\"assignee[name]\" value=\"Durward Reynolds\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultValue prop to the Combobox instead of a value, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction Example() {\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <form action=\"/projects/1/assignee\" method=\"post\">\n\n      <Combobox name=\"assignee\" defaultValue={people[0]}>\n        <Combobox.Input\n          onChange={(event) => setQuery(event.target.value)}\n          displayValue={(person) => person.name}\n        />\n        <Combobox.Options>\n          {filteredPeople.map((person) => (\n            <Combobox.Option key={person.id} value={person}>\n              {person.name}\n            </Combobox.Option>\n          ))}\n        </Combobox.Options>\n      </Combobox>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis can simplify your code when using the combobox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny onChange prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nAllowing custom values\n\nYou can allow users to enter their own value that doesn't exist in the list by including a dynamic Combobox.Option based on the query value.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction Example() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n      <Combobox.Options>\n\n        {query.length > 0 && (\n          <Combobox.Option value={{ id: null, name: query }}>\n            Create \"{query}\"\n          </Combobox.Option>\n        )}\n        {filteredPeople.map((person) => (\n          <Combobox.Option key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\nRendering the active option on the side\n\nDepending on what you're building it can sometimes make sense to render additional information about the active option outside of the <Combobox.Options>. For example, a preview of the active option within the context of a command palette. In these situations you can read the activeOption render prop argument to access this information.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n\n      {({ activeOption }) => (\n        <>\n          <Combobox.Input\n            onChange={(event) => setQuery(event.target.value)}\n            displayValue={(person) => person.name}\n          />\n          <Combobox.Options>\n            {filteredPeople.map((person) => (\n              <Combobox.Option key={person.id} value={person}>\n                {person.name}\n              </Combobox.Option>\n            ))}\n          </Combobox.Options>\n\n\n          {activeOption && (\n            <div>The current active user is: {activeOption.name}</div>\n          )}\n        </>\n      )}\n    </Combobox>\n  )\n}\n\n\nThe activeOption will be the value of the current active Combobox.Option.\n\nShowing/hiding the combobox\n\nBy default, your Combobox.Options instance will be shown/hidden automatically based on the internal open state tracked within the Combobox component itself.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n\n      {/*\n        By default, the `Combobox.Options` will automatically show/hide when\n        typing in the `Combobox.Input`, or when pressing the `Combobox.Button`.\n      */}\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          <Combobox.Option key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can add a static prop to the Combobox.Options instance to tell it to always render, and inspect the open render prop provided by Combobox to control which element is shown/hidden yourself.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n\n      {({ open }) => (\n        <>\n          <Combobox.Input\n            onChange={(event) => setQuery(event.target.value)}\n            displayValue={(person) => person.name}\n          />\n\n          {open && (\n            <div>\n              {/*\n                Using `static`, `Combobox.Options` are always rendered\n                and the `open` state is ignored.\n              */}\n\n              <Combobox.Options static>\n                {filteredPeople.map((person) => (\n                  <Combobox.Option key={person.id} value={person}>\n                    {person.name}\n                  </Combobox.Option>\n                ))}\n              </Combobox.Options>\n            </div>\n          )}\n        </>\n      )}\n    </Combobox>\n  )\n}\n\nDisabling an option\n\nUse the disabled prop to disable a Combobox.Option. This will make it unselectable via mouse and keyboard, and it will be skipped when pressing the up/down arrows.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds', unavailable: false },\n  { id: 2, name: 'Kenton Towne', unavailable: false },\n  { id: 3, name: 'Therese Wunsch', unavailable: false },\n  { id: 4, name: 'Benedict Kessler', unavailable: true },\n  { id: 5, name: 'Katelyn Rohan', unavailable: false },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          /* Disabled options will be skipped by keyboard navigation. */\n          <Combobox.Option\n            key={person.id}\n            value={person}\n\n            disabled={person.unavailable}\n          >\n            <span className={person.unavailable ? 'opacity-75' : ''}>\n              {person.name}\n            </span>\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\nAllowing empty values\n\nBy default, once you've selected a value in a combobox there is no way to clear the combobox back to an empty value — when you clear the input and tab away, the value returns to the previously selected value.\n\nIf you want to support empty values in your combobox, use the nullable prop.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds', unavailable: false },\n  { id: 2, name: 'Kenton Towne', unavailable: false },\n  { id: 3, name: 'Therese Wunsch', unavailable: false },\n  { id: 4, name: 'Benedict Kessler', unavailable: true },\n  { id: 5, name: 'Katelyn Rohan', unavailable: false },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n\n    <Combobox value={selectedPerson} onChange={setSelectedPerson} nullable>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n\n        displayValue={(person) => person?.name}\n      />\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          <Combobox.Option key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\n\nWhen the nullable prop is used, clearing the input and navigating away from the element will invoke your onChange and displayValue callbacks with null.\n\nThis prop doesn't do anything when allowing multiple values because options are toggled on and off, resulting in an empty array (rather than null) if nothing is selected.\n\nTransitions\n\nTo animate the opening/closing of the combobox panel, use the provided Transition component. All you need to do is wrap the Combobox.Options in a <Transition>, and the transition will be applied automatically.\n\nimport { useState } from 'react'\nimport { Combobox, Transition } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n\n      <Transition\n        enter=\"transition duration-100 ease-out\"\n        enterFrom=\"transform scale-95 opacity-0\"\n        enterTo=\"transform scale-100 opacity-100\"\n        leave=\"transition duration-75 ease-out\"\n        leaveFrom=\"transform scale-100 opacity-100\"\n        leaveTo=\"transform scale-95 opacity-0\"\n      >\n        <Combobox.Options>\n          {filteredPeople.map((person) => (\n            <Combobox.Option key={person.id} value={person}>\n              {person.name}\n            </Combobox.Option>\n          ))}\n        </Combobox.Options>\n\n      </Transition>\n    </Combobox>\n  )\n}\n\n\nBy default our built-in Transition component automatically communicates with the Combobox components to handle the open/closed states. However, if you require more control over this behavior, you can explicitly control it:\n\nimport { useState } from 'react'\nimport { Combobox, Transition } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n\n      {({ open }) => (\n        <>\n          <Combobox.Input\n            onChange={(event) => setQuery(event.target.value)}\n            displayValue={(person) => person.name}\n          />\n          {/*\n            Use the `Transition` + `open` render prop argument to add transitions.\n          */}\n          <Transition\n\n            show={open}\n            enter=\"transition duration-100 ease-out\"\n            enterFrom=\"transform scale-95 opacity-0\"\n            enterTo=\"transform scale-100 opacity-100\"\n            leave=\"transition duration-75 ease-out\"\n            leaveFrom=\"transform scale-100 opacity-100\"\n            leaveTo=\"transform scale-95 opacity-0\"\n          >\n            {/*\n              Don't forget to add `static` to your `Combobox.Options`!\n            */}\n\n            <Combobox.Options static>\n              {filteredPeople.map((person) => (\n                <Combobox.Option key={person.id} value={person}>\n                  {person.name}\n                </Combobox.Option>\n              ))}\n            </Combobox.Options>\n          </Transition>\n\n        </>\n      )}\n    </Combobox>\n  )\n}\n\n\nBecause they're renderless, Headless UI components also compose well with other animation libraries in the React ecosystem like Framer Motion and React Spring.\n\nRendering a different element for a component\n\nBy default, the Combobox and its subcomponents each render a default element that is sensible for that component.\n\nFor example, Combobox.Label renders a label by default, Combobox.Input renders an input, Combobox.Button renders a button, Combobox.Options renders a ul, and Combobox.Option renders a li. By contrast, Combobox does not render an element, and instead renders its children directly.\n\nThis is easy to change using the as prop, which exists on every component.\n\nimport { useState } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    /* Render a `div` instead of a React.Fragment */\n\n    <Combobox as=\"div\" value={selectedPerson} onChange={setSelectedPerson}>\n      <Combobox.Input\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      />\n\n      {/* Render a `div` instead of a `ul` */}\n\n      <Combobox.Options as=\"div\">\n        {filteredPeople.map((person) => (\n          /* Render a `span` instead of a `li` */\n\n          <Combobox.Option as=\"span\" key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\n\nTo tell an element to render its children directly with no wrapper element, use a Fragment.\n\nimport { useState, Fragment } from 'react'\nimport { Combobox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyCombobox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n  const [query, setQuery] = useState('')\n\n  const filteredPeople =\n    query === ''\n      ? people\n      : people.filter((person) => {\n          return person.name.toLowerCase().includes(query.toLowerCase())\n        })\n\n  return (\n    <Combobox value={selectedPerson} onChange={setSelectedPerson}>\n      {/* Render a `Fragment` instead of an `input` */}\n      <Combobox.Input\n\n        as={Fragment}\n        onChange={(event) => setQuery(event.target.value)}\n        displayValue={(person) => person.name}\n      >\n        <input />\n      </Combobox.Input>\n      <Combobox.Options>\n        {filteredPeople.map((person) => (\n          <Combobox.Option key={person.id} value={person}>\n            {person.name}\n          </Combobox.Option>\n        ))}\n      </Combobox.Options>\n    </Combobox>\n  )\n}\n\nAccessibility notes\nFocus management\n\nWhen a Combobox is toggled open, the Combobox.Input stays focused.\n\nThe Combobox.Button is ignored for the default tab flow, this means that pressing Tab in the Combobox.Input will skip passed the Combobox.Button.\n\nMouse interaction\n\nClicking a Combobox.Button toggles the options list open and closed. Clicking anywhere outside of the options list will close the combobox.\n\nKeyboard interaction\nCommand\tDescription\n\n\nArrowDown\n,\nor\nArrowUp\n when Combobox.Input is focused\n\n\t\n\nOpens combobox and focuses the selected item\n\n\n\n\nEnter\n,\nSpace\n,\nArrowDown\n,\nor\nArrowUp\n when Combobox.Button is focused\n\n\t\n\nOpens combobox, focuses the input and selects the selected item\n\n\n\n\nEsc when combobox is open\n\n\t\n\nCloses combobox and restores the selected item in the input field\n\n\n\n\nArrowDown\nor\nArrowUp\n when combobox is open\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nHome\nor\nPageUp when combobox is open\n\n\t\n\nFocuses first non-disabled item\n\n\n\n\nEnd\nor\nPageDown when combobox is open\n\n\t\n\nFocuses last non-disabled item\n\n\n\n\nEnter when combobox is open\n\n\t\n\nSelects the current item\n\n\n\n\nEnter when combobox is closed and in a form\n\n\t\n\nSubmits the form\n\n\n\n\nTab when combobox is open\n\n\t\n\nSelects the current active item and closes the combobox\n\n\n\n\nA–Z\nor\na–z when combobox is open\n\n\t\n\nCalls the onChange which allows you to filter the list\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nCombobox\n\nThe main Combobox component.\n\nProp\tDefault\tDescription\nas\tFragment\t\nString | Component\n\nThe element or component the Combobox should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nUse this to disable the entire combobox component & related children.\n\n\nvalue\t—\t\nT\n\nThe selected value.\n\n\ndefaultValue\t—\t\nT\n\nThe default value when using as an uncontrolled component.\n\n\nby\t—\t\nkeyof T | ((a: T, z: T) => boolean)\n\nUse this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.\n\n\nonChange\t—\t\n(value: T) => void\n\nThe function to call when a new option is selected.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\n\nnullable\t—\t\nBoolean\n\nWhether you can clear the combobox or not.\n\n\nmultiple\tfalse\t\nBoolean\n\nWhether multiple options can be selected or not.\n\nRender Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the combobox is disabled.\n\n\nactiveIndex\t\n\nNumber | null\n\nThe index of the active option or null if none is active.\n\n\nactiveOption\t\n\nT | null\n\nThe active option or null if none is active.\n\nCombobox.Input\n\nThe Combobox's input.\n\nProp\tDefault\tDescription\nas\tinput\t\nString | Component\n\nThe element or component the Combobox.Input should render as.\n\n\ndisplayValue\t—\t\n(item: T) => string\n\nThe string representation of your value.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Combobox is disabled.\n\nCombobox.Button\n\nThe Combobox's button.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Combobox.Button should render as.\n\nRender Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Combobox is disabled.\n\nCombobox.Label\n\nA label that can be used for more control over the text your Combobox will announce to screenreaders. Its id attribute will be automatically generated and linked to the root Combobox component via the aria-labelledby attribute.\n\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the Combobox.Label should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Combobox is disabled.\n\nCombobox.Options\n\nThe component that directly wraps the list of options in your custom Combobox.\n\nProp\tDefault\tDescription\nas\tul\t\nString | Component\n\nThe element or component the Combobox.Options should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nhold\tfalse\t\nboolean\n\nWhether or not the active option should stay active even when the mouse leaves the active option.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Combobox is open.\n\nCombobox.Option\n\nUsed to wrap each item within your Combobox.\n\nProp\tDefault\tDescription\nvalue\t—\t\nT\n\nThe option value.\n\n\nas\tli\t\nString | Component\n\nThe element or component the Combobox.Option should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the option should be disabled for keyboard navigation and ARIA purposes.\n\nRender Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the option is the active/focused option.\n\n\nselected\t\n\nBoolean\n\nWhether or not the option is the selected option.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the option is the disabled for keyboard navigation and ARIA purposes.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/listbox",
    "html": "Listbox (Select)\n\nListboxes are a great foundation for building custom, accessible select menus for your app, complete with robust support for keyboard navigation.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nListboxes are built using the Listbox, Listbox.Button, Listbox.Options, Listbox.Option and Listbox.Label components.\n\nThe Listbox.Button will automatically open/close the Listbox.Options when clicked, and when the menu is open, the list of items receives focus and is automatically navigable via the keyboard.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds', unavailable: false },\n  { id: 2, name: 'Kenton Towne', unavailable: false },\n  { id: 3, name: 'Therese Wunsch', unavailable: false },\n  { id: 4, name: 'Benedict Kessler', unavailable: true },\n  { id: 5, name: 'Katelyn Rohan', unavailable: false },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          <Listbox.Option\n            key={person.id}\n            value={person}\n            disabled={person.unavailable}\n          >\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Listbox.Option component exposes an active state, which tells you if the option is currently focused via the mouse or keyboard, and a selected state, which tells you if that option matches the current value of the Listbox.\n\nimport { useState, Fragment } from 'react'\nimport { Listbox } from '@headlessui/react'\nimport { CheckIcon } from '@heroicons/react/20/solid'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          /* Use the `active` state to conditionally style the active option. */\n          /* Use the `selected` state to conditionally style the selected option. */\n          <Listbox.Option key={person.id} value={person} as={Fragment}>\n\n            {({ active, selected }) => (\n              <li\n                className={`${\n\n                  active ? 'bg-blue-500 text-white' : 'bg-white text-black'\n                }`}\n              >\n\n                {selected && <CheckIcon />}\n                {person.name}\n              </li>\n            )}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Listbox.Options component with some child Listbox.Option components renders when the listbox is open and the second option is both selected and active:\n\n<!-- Rendered `Listbox.Options` -->\n<ul data-headlessui-state=\"open\">\n  <li data-headlessui-state=\"\">Wade Cooper</li>\n  <li data-headlessui-state=\"active selected\">Arlene Mccoy</li>\n  <li data-headlessui-state=\"\">Devon Webb</li>\n</ul>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\nimport { CheckIcon } from '@heroicons/react/20/solid'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          <Listbox.Option\n            key={person.id}\n            value={person}\n\n            className=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n          >\n\n            <CheckIcon className=\"hidden ui-selected:block\" />\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\nBinding objects as values\n\nUnlike native HTML form controls which only allow you to provide strings as values, Headless UI supports binding complex objects as well.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds', unavailable: false },\n  { id: 2, name: 'Kenton Towne', unavailable: false },\n  { id: 3, name: 'Therese Wunsch', unavailable: false },\n  { id: 4, name: 'Benedict Kessler', unavailable: true },\n  { id: 5, name: 'Katelyn Rohan', unavailable: false },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          <Listbox.Option\n            key={person.id}\n\n            value={person}\n            disabled={person.unavailable}\n          >\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\n\nWhen binding objects as values, it's important to make sure that you use the same instance of the object as both the value of the Listbox as well as the corresponding Listbox.Option, otherwise they will fail to be equal and cause the listbox to behave incorrectly.\n\nTo make it easier to work with different instances of the same object, you can use the by prop to compare the objects by a particular field instead of comparing object identity:\n\nimport { Listbox } from '@headlessui/react'\n\nconst departments = [\n  { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n  { id: 2, name: 'HR', contact: 'Kenton Towne' },\n  { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n  { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n  { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n]\n\n\nfunction DepartmentPicker({ selectedDepartment, onChange }) {\n  return (\n\n    <Listbox value={selectedDepartment} by=\"id\" onChange={onChange}>\n      <Listbox.Button>{selectedDepartment.name}</Listbox.Button>\n      <Listbox.Options>\n        {departments.map((department) => (\n          <Listbox.Option key={department.id} value={department}>\n            {department.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\n\nYou can also pass your own comparison function to the by prop if you'd like complete control over how objects are compared:\n\nimport { Listbox } from '@headlessui/react'\n\nconst departments = [\n  { id: 1, name: 'Marketing', contact: 'Durward Reynolds' },\n  { id: 2, name: 'HR', contact: 'Kenton Towne' },\n  { id: 3, name: 'Sales', contact: 'Therese Wunsch' },\n  { id: 4, name: 'Finance', contact: 'Benedict Kessler' },\n  { id: 5, name: 'Customer service', contact: 'Katelyn Rohan' },\n]\n\n\nfunction compareDepartments(a, b) {\n  return a.name.toLowerCase() === b.name.toLowerCase()\n}\n\nfunction DepartmentPicker({ selectedDepartment, onChange }) {\n  return (\n    <Listbox\n      value={selectedDepartment}\n\n      by={compareDepartments}\n      onChange={onChange}\n    >\n      <Listbox.Button>{selectedDepartment.name}</Listbox.Button>\n      <Listbox.Options>\n        {departments.map((department) => (\n          <Listbox.Option key={department.id} value={department}>\n            {department.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\nSelecting multiple values\n\nTo allow selecting multiple values in your listbox, use the multiple prop and pass an array to value instead of a single option.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n\n  const [selectedPeople, setSelectedPeople] = useState([people[0], people[1]])\n\n  return (\n\n    <Listbox value={selectedPeople} onChange={setSelectedPeople} multiple>\n      <Listbox.Button>\n        {selectedPeople.map((person) => person.name).join(', ')}\n      </Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          <Listbox.Option key={person.id} value={person}>\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\n\nThis will keep the listbox open when you are selecting options, and choosing an option will toggle it in place.\n\nYour onChange handler will be called with an array containing all selected options any time an option is added or removed.\n\nUsing a custom label\n\nBy default the Listbox will use the button contents as the label for screenreaders. If you'd like more control over what is announced to assistive technologies, use the Listbox.Label component.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n\n      <Listbox.Label>Assignee:</Listbox.Label>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          <Listbox.Option key={person.id} value={person}>\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\nUsing with HTML forms\n\nIf you add the name prop to your listbox, hidden input elements will be rendered and kept in sync with your selected value.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction Example() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <form action=\"/projects/1/assignee\" method=\"post\">\n      <Listbox\n        value={selectedPerson}\n        onChange={setSelectedPerson}\n\n        name=\"assignee\"\n      >\n        <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n        <Listbox.Options>\n          {people.map((person) => (\n            <Listbox.Option key={person.id} value={person}>\n              {person.name}\n            </Listbox.Option>\n          ))}\n        </Listbox.Options>\n      </Listbox>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis lets you use a listbox inside a native HTML <form> and make traditional form submissions as if your listbox was a native HTML form control.\n\nBasic values like strings will be rendered as a single hidden input containing that value, but complex values like objects will be encoded into multiple inputs using a square bracket notation for the names:\n\n<input type=\"hidden\" name=\"assignee[id]\" value=\"1\" />\n<input type=\"hidden\" name=\"assignee[name]\" value=\"Durward Reynolds\" />\nUsing as an uncontrolled component\n\nIf you provide a defaultValue prop to the Listbox instead of a value, Headless UI will track its state internally for you, allowing you to use it as an uncontrolled component.\n\nYou can access the currently selected option via the value render prop on the Listbox and Listbox.Button components.\n\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction Example() {\n  return (\n    <form action=\"/projects/1/assignee\" method=\"post\">\n\n      <Listbox name=\"assignee\" defaultValue={people[0]}>\n        <Listbox.Button>{({ value }) => value.name}</Listbox.Button>\n        <Listbox.Options>\n          {people.map((person) => (\n            <Listbox.Option key={person.id} value={person}>\n              {person.name}\n            </Listbox.Option>\n          ))}\n        </Listbox.Options>\n      </Listbox>\n      <button>Submit</button>\n    </form>\n  )\n}\n\n\nThis can simplify your code when using the listbox with HTML forms or with form APIs that collect their state using FormData instead of tracking it using React state.\n\nAny onChange prop you provide will still be called when the component's value changes in case you need to run any side effects, but you won't need to use it to track the component's state yourself.\n\nShowing/hiding the listbox\n\nBy default, your Listbox.Options instance will be shown/hidden automatically based on the internal open state tracked within the Listbox component itself.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n\n      {/*\n        By default, the `Listbox.Options` will automatically show/hide\n        when the `Listbox.Button` is pressed.\n      */}\n      <Listbox.Options>\n        {people.map((person) => (\n          <Listbox.Option key={person.id} value={person}>\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can add a static prop to the Listbox.Options instance to tell it to always render, and inspect the open render prop provided by Listbox to control which element is shown/hidden yourself.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      {({ open }) => (\n        <>\n          <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n\n          {open && (\n            <div>\n              {/*\n                Using the `static` prop, the `Listbox.Options` are always\n                rendered and the `open` state is ignored.\n              */}\n\n              <Listbox.Options static>\n                {people.map((person) => (\n                  <Listbox.Option key={person.id} value={person}>\n                    {person.name}\n                  </Listbox.Option>\n                ))}\n              </Listbox.Options>\n            </div>\n          )}\n        </>\n      )}\n    </Listbox>\n  )\n}\n\nDisabling an option\n\nUse the disabled prop to disable a Listbox.Option. This will make it unselectable via mouse and keyboard, and it will be skipped when pressing the up/down arrows.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds', unavailable: false },\n  { id: 2, name: 'Kenton Towne', unavailable: false },\n  { id: 3, name: 'Therese Wunsch', unavailable: false },\n  { id: 4, name: 'Benedict Kessler', unavailable: true },\n  { id: 5, name: 'Katelyn Rohan', unavailable: false },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          /* Disabled options will be skipped by keyboard navigation. */\n          <Listbox.Option\n            key={person.id}\n            value={person}\n\n            disabled={person.unavailable}\n          >\n            <span className={person.unavailable ? 'opacity-75' : ''}>\n              {person.name}\n            </span>\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\nTransitions\n\nTo animate the opening/closing of the listbox panel, use the provided Transition component. All you need to do is wrap the Listbox.Options in a <Transition>, and the transition will be applied automatically.\n\nimport { useState } from 'react'\nimport { Listbox, Transition } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n\n      <Transition\n        enter=\"transition duration-100 ease-out\"\n        enterFrom=\"transform scale-95 opacity-0\"\n        enterTo=\"transform scale-100 opacity-100\"\n        leave=\"transition duration-75 ease-out\"\n        leaveFrom=\"transform scale-100 opacity-100\"\n        leaveTo=\"transform scale-95 opacity-0\"\n      >\n        <Listbox.Options>\n          {people.map((person) => (\n            <Listbox.Option key={person.id} value={person}>\n              {person.name}\n            </Listbox.Option>\n          ))}\n        </Listbox.Options>\n\n      </Transition>\n    </Listbox>\n  )\n}\n\n\nBy default our built-in Transition component automatically communicates with the Listbox components to handle the open/closed states. However, if you require more control over this behavior, you can explicitly control it:\n\nimport { useState } from 'react'\nimport { Listbox, Transition } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n\n      {({ open }) => (\n        <>\n          <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n          {/*\n            Use the `Transition` + `open` render prop argument to add transitions.\n          */}\n          <Transition\n\n            show={open}\n            enter=\"transition duration-100 ease-out\"\n            enterFrom=\"transform scale-95 opacity-0\"\n            enterTo=\"transform scale-100 opacity-100\"\n            leave=\"transition duration-75 ease-out\"\n            leaveFrom=\"transform scale-100 opacity-100\"\n            leaveTo=\"transform scale-95 opacity-0\"\n          >\n            {/*\n              Don't forget to add `static` to your `Listbox.Options`!\n            */}\n\n            <Listbox.Options static>\n              {people.map((person) => (\n                <Listbox.Option key={person.id} value={person}>\n                  {person.name}\n                </Listbox.Option>\n              ))}\n            </Listbox.Options>\n          </Transition>\n\n        </>\n      )}\n    </Listbox>\n  )\n}\n\n\nBecause they're renderless, Headless UI components also compose well with other animation libraries in the React ecosystem like Framer Motion and React Spring.\n\nRendering a different element for a component\n\nBy default, the Listbox and its subcomponents each render a default element that is sensible for that component.\n\nFor example, Listbox.Label renders a label by default, Listbox.Button renders a button, Listbox.Options renders a ul, and Listbox.Option renders a li. By contrast, Listbox does not render an element, and instead renders its children directly.\n\nThis is easy to change using the as prop, which exists on every component.\n\nimport { useState } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    /* Render a `div` instead of a `React.Fragment` */\n\n    <Listbox as=\"div\" value={selectedPerson} onChange={setSelectedPerson}>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n\n      {/* Render a `div` instead of a `ul` */}\n\n      <Listbox.Options as=\"div\">\n        {people.map((person) => (\n          /* Render a `span` instead of a `li` */\n          <Listbox.Option as=\"span\" key={person.id} value={person}>\n\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\n\nTo tell an element to render its children directly with no wrapper element, use a Fragment.\n\nimport { useState, Fragment } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n    <Listbox value={selectedPerson} onChange={setSelectedPerson}>\n      {/* Render a `Fragment` instead of a `button` */}\n\n      <Listbox.Button as={Fragment}>\n        <button>{selectedPerson.name}</button>\n      </Listbox.Button>\n      <Listbox.Options>\n        {people.map((person) => (\n          <Listbox.Option key={person.id} value={person}>\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\nHorizontal options\n\nIf you've styled your Listbox.Options to appear horizontally, use the horizontal prop on the Listbox component to enable navigating the items with the left and right arrow keys instead of up and down, and to update the aria-orientation attribute for assistive technologies.\n\nimport { useState, Fragment } from 'react'\nimport { Listbox } from '@headlessui/react'\n\nconst people = [\n  { id: 1, name: 'Durward Reynolds' },\n  { id: 2, name: 'Kenton Towne' },\n  { id: 3, name: 'Therese Wunsch' },\n  { id: 4, name: 'Benedict Kessler' },\n  { id: 5, name: 'Katelyn Rohan' },\n]\n\nfunction MyListbox() {\n  const [selectedPerson, setSelectedPerson] = useState(people[0])\n\n  return (\n\n    <Listbox value={selectedPerson} onChange={setSelectedPerson} horizontal>\n      <Listbox.Button>{selectedPerson.name}</Listbox.Button>\n      <Listbox.Options className=\"flex flex-row\">\n        {people.map((person) => (\n          <Listbox.Option key={person.id} value={person}>\n            {person.name}\n          </Listbox.Option>\n        ))}\n      </Listbox.Options>\n    </Listbox>\n  )\n}\n\nAccessibility notes\nFocus management\n\nWhen a Listbox is toggled open, the Listbox.Options receives focus. Focus is trapped within the list of items until Escape is pressed or the user clicks outside the options. Closing the Listbox returns focus to the Listbox.Button.\n\nMouse interaction\n\nClicking a Listbox.Button toggles the options list open and closed. Clicking anywhere outside of the options list will close the listbox.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\n,\nSpace\n,\nArrowDown\n,\nor\nArrowUp\n when Listbox.Button is focused\n\n\t\n\nOpens listbox and focuses the selected item\n\n\n\n\nEsc when listbox is open\n\n\t\n\nCloses listbox\n\n\n\n\nArrowDown\nor\nArrowUp\n when listbox is open\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nArrowLeft\nor\nArrowRight\n when listbox is open and horizontal is set\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nHome\nor\nPageUp when listbox is open\n\n\t\n\nFocuses first non-disabled item\n\n\n\n\nEnd\nor\nPageDown when listbox is open\n\n\t\n\nFocuses last non-disabled item\n\n\n\n\nEnter\nor\nSpace when listbox is open\n\n\t\n\nSelects the current item\n\n\n\n\nA–Z\nor\na–z when listbox is open\n\n\t\n\nFocuses first item that matches keyboard input\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nComponent API\nListbox\n\nThe main Listbox component.\n\nProp\tDefault\tDescription\nas\tFragment\t\nString | Component\n\nThe element or component the Listbox should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nUse this to disable the entire Listbox component & related children.\n\n\nvalue\t—\t\nT\n\nThe selected value.\n\n\ndefaultValue\t—\t\nT\n\nThe default value when using as an uncontrolled component.\n\n\nby\t—\t\nkeyof T | ((a: T, z: T) => boolean)\n\nUse this to compare objects by a particular field, or pass your own comparison function for complete control over how objects are compared.\n\n\nonChange\t—\t\n(value: T) => void\n\nThe function to call when a new option is selected.\n\n\nhorizontal\tfalse\t\nBoolean\n\nWhen true, the orientation of the Listbox.Options will be horizontal, otherwise it will be vertical.\n\n\nname\t—\t\nString\n\nThe name used when using this component inside a form.\n\n\nmultiple\tfalse\t\nBoolean\n\nWhether multiple options can be selected or not.\n\nRender Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Listbox is disabled.\n\nListbox.Button\n\nThe Listbox's button.\n\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Listbox.Button should render as.\n\nRender Prop\tDescription\nvalue\t\n\nT\n\nThe selected value.\n\n\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Listbox is disabled.\n\nListbox.Label\n\nA label that can be used for more control over the text your Listbox will announce to screenreaders. Its id attribute will be automatically generated and linked to the root Listbox component via the aria-labelledby attribute.\n\nProp\tDefault\tDescription\nas\tlabel\t\nString | Component\n\nThe element or component the Listbox.Label should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the Listbox is disabled.\n\nListbox.Options\n\nThe component that directly wraps the list of options in your custom Listbox.\n\nProp\tDefault\tDescription\nas\tul\t\nString | Component\n\nThe element or component the Listbox.Options should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Listbox is open.\n\nListbox.Option\n\nUsed to wrap each item within your Listbox.\n\nProp\tDefault\tDescription\nvalue\t—\t\nT\n\nThe option value.\n\n\nas\tli\t\nString | Component\n\nThe element or component the Listbox.Option should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the option should be disabled for keyboard navigation and ARIA purposes.\n\nRender Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the option is the active/focused option.\n\n\nselected\t\n\nBoolean\n\nWhether or not the option is the selected option.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the option is the disabled for keyboard navigation and ARIA purposes.\n"
  },
  {
    "title": "Headless UI",
    "url": "https://headlessui.com/react/menu",
    "html": "Menu (Dropdown)\n\nMenus offer an easy way to build custom, accessible dropdown components with robust support for keyboard navigation.\n\nPreview\nCode\nCopy\nCopied!\nInstallation\n\nTo get started, install Headless UI via npm:\n\nnpm install @headlessui/react\nBasic example\n\nMenu Buttons are built using the Menu, Menu.Button, Menu.Items, and Menu.Item components.\n\nThe Menu.Button will automatically open/close the Menu.Items when clicked, and when the menu is open, the list of items receives focus and is automatically navigable via the keyboard.\n\nimport { Menu } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    <Menu>\n      <Menu.Button>More</Menu.Button>\n      <Menu.Items>\n        <Menu.Item>\n          {({ active }) => (\n            <a\n              className={`${active && 'bg-blue-500'}`}\n              href=\"/account-settings\"\n            >\n              Account settings\n            </a>\n          )}\n        </Menu.Item>\n        <Menu.Item>\n          {({ active }) => (\n            <a\n              className={`${active && 'bg-blue-500'}`}\n              href=\"/account-settings\"\n            >\n              Documentation\n            </a>\n          )}\n        </Menu.Item>\n        <Menu.Item disabled>\n          <span className=\"opacity-75\">Invite a friend (coming soon!)</span>\n        </Menu.Item>\n      </Menu.Items>\n    </Menu>\n  )\n}\nStyling different states\n\nHeadless UI keeps track of a lot of state about each component, like which listbox option is currently selected, whether a popover is open or closed, or which item in a menu is currently active via the keyboard.\n\nBut because the components are headless and completely unstyled out of the box, you can't see this information in your UI until you provide the styles you want for each state yourself.\n\nUsing render props\n\nEach component exposes information about its current state via render props that you can use to conditionally apply different styles or render different content.\n\nFor example, the Menu.Item component exposes an active state, which tells you if the item is currently focused via the mouse or keyboard.\n\nimport { Fragment } from 'react'\nimport { Menu } from '@headlessui/react'\n\nconst links = [\n  { href: '/account-settings', label: 'Account settings' },\n  { href: '/support', label: 'Support' },\n  { href: '/license', label: 'License' },\n  { href: '/sign-out', label: 'Sign out' },\n]\n\nfunction MyMenu() {\n  return (\n    <Menu>\n      <Menu.Button>Options</Menu.Button>\n      <Menu.Items>\n        {links.map((link) => (\n          /* Use the `active` state to conditionally style the active item. */\n          <Menu.Item key={link.href} as={Fragment}>\n\n            {({ active }) => (\n              <a\n                href={link.href}\n                className={`${\n\n                  active ? 'bg-blue-500 text-white' : 'bg-white text-black'\n                }`}\n              >\n                {link.label}\n              </a>\n            )}\n          </Menu.Item>\n        ))}\n      </Menu.Items>\n    </Menu>\n  )\n}\n\n\nFor the complete render prop API for each component, see the component API documentation.\n\nUsing data attributes\n\nEach component also exposes information about its current state via a data-headlessui-state attribute that you can use to conditionally apply different styles.\n\nWhen any of the states in the render prop API are true, they will be listed in this attribute as space-separated strings so you can target them with a CSS attribute selector in the form [attr~=value].\n\nFor example, here's what the Menu.Items component with some child Menu.Item components renders when the menu is open and the second item is active:\n\n<!-- Rendered `Menu.Items` -->\n<ul data-headlessui-state=\"open\">\n  <li data-headlessui-state=\"\">Account settings</li>\n  <li data-headlessui-state=\"active\">Support</li>\n  <li data-headlessui-state=\"\">License</li>\n</ul>\n\nIf you are using Tailwind CSS, you can use the @headlessui/tailwindcss plugin to target this attribute with modifiers like ui-open:* and ui-active:*:\n\nimport { Menu } from '@headlessui/react'\n\nconst links = [\n  { href: '/account-settings', label: 'Account settings' },\n  { href: '/support', label: 'Support' },\n  { href: '/license', label: 'License' },\n  { href: '/sign-out', label: 'Sign out' },\n]\n\nfunction MyMenu() {\n  return (\n    <Menu>\n      <Menu.Button>Options</Menu.Button>\n      <Menu.Items>\n        {links.map((link) => (\n          <Menu.Item\n            as=\"a\"\n            key={link.href}\n            href={link.href}\n\n            className=\"ui-active:bg-blue-500 ui-active:text-white ui-not-active:bg-white ui-not-active:text-black\"\n          >\n            {link.label}\n          </Menu.Item>\n        ))}\n      </Menu.Items>\n    </Menu>\n  )\n}\n\nShowing/hiding the menu\n\nBy default, your Menu.Items instance will be shown/hidden automatically based on the internal open state tracked within the Menu component itself.\n\nimport { Menu } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    <Menu>\n      <Menu.Button>More</Menu.Button>\n\n      {/*\n        By default, the `Menu.Items` will automatically show/hide\n        when the `Menu.Button` is pressed.\n      */}\n      <Menu.Items>\n        <Menu.Item>{/* ... */}</Menu.Item>\n        {/* ... */}\n      </Menu.Items>\n    </Menu>\n  )\n}\n\nIf you'd rather handle this yourself (perhaps because you need to add an extra wrapper element for one reason or another), you can add a static prop to the Menu.Items instance to tell it to always render, and inspect the open slot prop provided by the Menu to control which element is shown/hidden yourself.\n\nimport { Menu } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    <Menu>\n\n      {({ open }) => (\n        <>\n          <Menu.Button>More</Menu.Button>\n\n          {open && (\n            <div>\n              {/*\n                Using the `static` prop, the `Menu.Items` are always\n                rendered and the `open` state is ignored.\n              */}\n\n              <Menu.Items static>\n                <Menu.Item>{/* ... */}</Menu.Item>\n                {/* ... */}\n              </Menu.Items>\n            </div>\n          )}\n        </>\n      )}\n    </Menu>\n  )\n}\n\nClosing menus manually\n\nThe menu will already close by default, however it can happen that 3rd party Link components use event.preventDefault(), which prevents the default behaviour and therefore won't close the menu.\n\nThe Menu and Menu.Item expose a close() render prop which you can use to imperatively close the menu:\n\nimport { Menu } from '@headlessui/react'\nimport { MyCustomLink } from './MyCustomLink'\n\nfunction MyMenu() {\n  return (\n    <Menu>\n      <Menu.Button>Terms</Menu.Button>\n\n      <Menu.Items>\n        <Menu.Item>\n\n          {({ close }) => (\n            <MyCustomLink href=\"/\" onClick={close}>\n              Read and accept\n            </MyCustomLink>\n          )}\n        </Menu.Item>\n      </Menu.Items>\n    </Menu>\n  )\n}\n\nDisabling an item\n\nUse the disabled prop to disable a Menu.Item. This will make it unselectable via keyboard navigation, and it will be skipped when pressing the up/down arrows.\n\nimport { Menu } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    <Menu>\n      <Menu.Button>More</Menu.Button>\n      <Menu.Items>\n        {/* ... */}\n\n        {/* This item will be skipped by keyboard navigation. */}\n\n        <Menu.Item disabled>\n          <span className=\"opacity-75\">Invite a friend (coming soon!)</span>\n        </Menu.Item>\n\n        {/* ... */}\n      </Menu.Items>\n    </Menu>\n  )\n}\n\nTransitions\n\nTo animate the opening/closing of the menu panel, use the provided Transition component. All you need to do is wrap the Menu.Items in a <Transition>, and the transition will be applied automatically.\n\nimport { Menu, Transition } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    <Menu>\n      <Menu.Button>More</Menu.Button>\n\n      {/* Use the `Transition` component. */}\n\n      <Transition\n        enter=\"transition duration-100 ease-out\"\n        enterFrom=\"transform scale-95 opacity-0\"\n        enterTo=\"transform scale-100 opacity-100\"\n        leave=\"transition duration-75 ease-out\"\n        leaveFrom=\"transform scale-100 opacity-100\"\n        leaveTo=\"transform scale-95 opacity-0\"\n      >\n        <Menu.Items>\n          <Menu.Item>{/* ... */}</Menu.Item>\n          {/* ... */}\n        </Menu.Items>\n\n      </Transition>\n    </Menu>\n  )\n}\n\n\nBy default our built-in Transition component automatically communicates with the Menu components to handle the open/closed states. However, if you require more control over this behavior, you can explicitly control it:\n\nimport { Menu, Transition } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    <Menu>\n\n      {({ open }) => (\n        <>\n          <Menu.Button>More</Menu.Button>\n\n          {/* Use the `Transition` component. */}\n          <Transition\n\n            show={open}\n            enter=\"transition duration-100 ease-out\"\n            enterFrom=\"transform scale-95 opacity-0\"\n            enterTo=\"transform scale-100 opacity-100\"\n            leave=\"transition duration-75 ease-out\"\n            leaveFrom=\"transform scale-100 opacity-100\"\n            leaveTo=\"transform scale-95 opacity-0\"\n          >\n            {/* Mark this component as `static` */}\n\n            <Menu.Items static>\n              <Menu.Item>{/* ... */}</Menu.Item>\n              {/* ... */}\n            </Menu.Items>\n          </Transition>\n\n        </>\n      )}\n    </Menu>\n  )\n}\n\n\nBecause they're renderless, Headless UI components also compose well with other animation libraries in the React ecosystem like Framer Motion and React Spring.\n\nRendering additional content\n\nThe accessibility semantics of role=\"menu\" are fairly strict and any children of a Menu that are not Menu.Item components will be automatically hidden from assistive technology to make sure the menu works the way screen reader users expect.\n\nFor this reason, rendering any children other than Menu.Item components is discouraged as that content will be inaccessible to people using assistive technology.\n\nIf you want to build a dropdown with more flexible content, consider using Popover instead.\n\nRendering a different element for a component\n\nBy default, the Menu and its subcomponents each render a default element that is sensible for that component.\n\nFor example, Menu.Button renders a button by default, and Menu.Items renders a div. By contrast, Menu and Menu.Item do not render an element, and instead render their children directly by default.\n\nThis is easy to change using the as prop, which exists on every component.\n\nimport { Menu } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    /* Render a `div` instead of no wrapper element */\n\n    <Menu as=\"div\">\n      <Menu.Button>More</Menu.Button>\n      {/* Render a `section` instead of a `div` */}\n\n      <Menu.Items as=\"section\">\n        <Menu.Item>\n          {({ active }) => (\n            <a\n              className={`${active && 'bg-blue-500'}`}\n              href=\"/account-settings\"\n            >\n              Account settings\n            </a>\n          )}\n        </Menu.Item>\n\n        {/* ... */}\n      </Menu.Items>\n    </Menu>\n  )\n}\n\n\nTo tell an element to render its children directly with no wrapper element, use as={React.Fragment}.\n\nimport { Menu } from '@headlessui/react'\n\nfunction MyDropdown() {\n  return (\n    <Menu>\n      {/* Render no wrapper, instead pass in a `button` manually. */}\n\n      <Menu.Button as={React.Fragment}>\n        <button>More</button>\n      </Menu.Button>\n      <Menu.Items>\n        <Menu.Item>\n          {({ active }) => (\n            <a\n              className={`${active && 'bg-blue-500'}`}\n              href=\"/account-settings\"\n            >\n              Account settings\n            </a>\n          )}\n        </Menu.Item>\n        {/* ... */}\n      </Menu.Items>\n    </Menu>\n  )\n}\n\n\nThis is important if you are using an interactive element like an <a> tag inside the Menu.Item. If the Menu.Item had an as=\"div\", then the props provided by Headless UI would be forwarded to the div instead of the a, which means that you can't go to the URL provided by the <a> tag anymore via your keyboard.\n\nIntegrating with Next.js\n\nPrior to Next.js v13, the Link component did not forward unknown props to the underlying a element, preventing the menu from closing on click when used inside a Menu.Item.\n\nIf you're using Next.js v12 or older, you can work around this issue by creating your own component that wraps Link and forwards unknown props to the child a element:\n\nimport { forwardRef } from 'react'\nimport Link from 'next/link'\nimport { Menu } from '@headlessui/react'\n\n\nconst MyLink = forwardRef((props, ref) => {\n  let { href, children, ...rest } = props\n  return (\n    <Link href={href}>\n      <a ref={ref} {...rest}>\n        {children}\n      </a>\n    </Link>\n  )\n})\n\nfunction Example() {\n  return (\n    <Menu>\n      <Menu.Button>More</Menu.Button>\n      <Menu.Items>\n        <Menu.Item>\n\n          <MyLink href=\"/profile\">Profile</MyLink>\n        </Menu.Item>\n      </Menu.Items>\n    </Menu>\n  )\n}\n\n\nThis will ensure that all of the event listeners Headless UI needs to add to the a element are properly applied.\n\nThis behavior was changed in Next.js v13 making this workaround no longer necessary.\n\nAccessibility notes\nFocus management\n\nClicking the Menu.Button toggles the menu and focuses the Menu.Items component. Focus is trapped within the open menu until Escape is pressed or the user clicks outside the menu. Closing the menu returns focus to the Menu.Button.\n\nMouse interaction\n\nClicking a Menu.Button toggles the menu. Clicking anywhere outside of an open menu will close that menu.\n\nKeyboard interaction\nCommand\tDescription\n\n\nEnter\nor\nSpace when Menu.Button is focused\n\n\t\n\nOpens menu and focuses first non-disabled item\n\n\n\n\nArrowDown\nor\nArrowUp\n when Menu.Button is focused\n\n\t\n\nOpens menu and focuses first/last non-disabled item\n\n\n\n\nEsc when menu is open\n\n\t\n\nCloses any open Menus\n\n\n\n\nArrowDown\nor\nArrowUp\n when menu is open\n\n\t\n\nFocuses previous/next non-disabled item\n\n\n\n\nHome\nor\nPageUp when menu is open\n\n\t\n\nFocuses first non-disabled item\n\n\n\n\nEnd\nor\nPageDown when menu is open\n\n\t\n\nFocuses last non-disabled item\n\n\n\n\nEnter\nor\nSpace when menu is open\n\n\t\n\nActivates/clicks the current menu item\n\n\n\n\nA–Z\nor\na–z when menu is open\n\n\t\n\nFocuses first item that matches keyboard input\n\nOther\n\nAll relevant ARIA attributes are automatically managed.\n\nFor a full reference on all accessibility features implemented in Menu, see the ARIA spec on Menu Buttons.\n\nWhen to use a Menu\n\nMenus are best for UI elements that resemble things like the menus you'd find in the title bar of most operating systems. They have specific accessibility semantics, and their content should be restricted to a list of links or buttons. Focus is trapped in an open menu, so you cannot Tab through the content or away from the menu. Instead, the arrow keys navigate through a Menu's items.\n\nHere's when you might use other similar components from Headless UI:\n\n<Popover />. Popovers are general-purpose floating menus. They appear near the button that triggers them, and you can put arbitrary markup in them like images or non-clickable content. The Tab key navigates the contents of a Popover like it would any other normal markup. They're great for building header nav items with expandable content and flyout panels.\n\n<Disclosure />. Disclosures are useful for elements that expand to reveal additional information, like a toggleable FAQ section. They are typically rendered inline and reflow the document when they're shown or hidden.\n\n<Dialog />. Dialogs are meant to grab the user's full attention. They typically render a floating panel in the center of the screen, and use a backdrop to dim the rest of the application's contents. They also capture focus and prevent tabbing away from the Dialog's contents until the Dialog is dismissed.\n\nComponent API\nMenu\nProp\tDefault\tDescription\nas\tFragment\t\nString | Component\n\nThe element or component the Menu should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Menu is open.\n\n\nclose\t\n\n() => void\n\nCloses the menu and refocuses Menu.Button.\n\nMenu.Button\nProp\tDefault\tDescription\nas\tbutton\t\nString | Component\n\nThe element or component the Menu.Button should render as.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Menu is open.\n\nMenu.Items\nProp\tDefault\tDescription\nas\tdiv\t\nString | Component\n\nThe element or component the Menu.Items should render as.\n\n\nstatic\tfalse\t\nBoolean\n\nWhether the element should ignore the internally managed open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\n\nunmount\ttrue\t\nBoolean\n\nWhether the element should be unmounted or hidden based on the open/closed state.\n\nNote: static and unmount can not be used at the same time. You will get a TypeScript error if you try to do it.\n\nRender Prop\tDescription\nopen\t\n\nBoolean\n\nWhether or not the Menu is open.\n\nMenu.Item\nProp\tDefault\tDescription\nas\tFragment\t\nString | Component\n\nThe element or component the Menu.Item should render as.\n\n\ndisabled\tfalse\t\nBoolean\n\nWhether or not the item should be disabled for keyboard navigation and ARIA purposes.\n\nRender Prop\tDescription\nactive\t\n\nBoolean\n\nWhether or not the item is the active/focused item in the list.\n\n\ndisabled\t\n\nBoolean\n\nWhether or not the item is the disabled for keyboard navigation and ARIA purposes.\n\n\nclose\t\n\n() => void\n\nCloses the menu and refocuses Menu.Button.\n"
  }
]
