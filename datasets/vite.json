[
  {
    "title": "JavaScript API | Vite",
    "url": "https://vitejs.dev/guide/api-javascript",
    "html": "JavaScript API\n​\n\nVite's JavaScript APIs are fully typed, and it's recommended to use TypeScript or enable JS type checking in VS Code to leverage the intellisense and validation.\n\ncreateServer\n​\n\nType Signature:\n\nts\nasync function createServer(inlineConfig?: InlineConfig): Promise<ViteDevServer>\n\nExample Usage:\n\njs\nimport { fileURLToPath } from 'url'\nimport { createServer } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\n;(async () => {\n  const server = await createServer({\n    // any valid user config options, plus `mode` and `configFile`\n    configFile: false,\n    root: __dirname,\n    server: {\n      port: 1337,\n    },\n  })\n  await server.listen()\n\n  server.printUrls()\n  server.bindCLIShortcuts({ print: true })\n})()\n\nNOTE\n\nWhen using createServer and build in the same Node.js process, both functions rely on process.env.NODE_ENV to work properly, which also depends on the mode config option. To prevent conflicting behavior, set process.env.NODE_ENV or the mode of the two APIs to development. Otherwise, you can spawn a child process to run the APIs separately.\n\nNOTE\n\nWhen using middleware mode combined with proxy config for WebSocket, the parent http server should be provided in middlewareMode to bind the proxy correctly.\n\nExample\nInlineConfig\n​\n\nThe InlineConfig interface extends UserConfig with additional properties:\n\nconfigFile: specify config file to use. If not set, Vite will try to automatically resolve one from project root. Set to false to disable auto resolving.\nenvFile: Set to false to disable .env files.\nResolvedConfig\n​\n\nThe ResolvedConfig interface has all the same properties of a UserConfig, except most properties are resolved and non-undefined. It also contains utilities like:\n\nconfig.assetsInclude: A function to check if an id is considered an asset.\nconfig.logger: Vite's internal logger object.\nViteDevServer\n​\nts\ninterface ViteDevServer {\n  /**\n   * The resolved Vite config object.\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance\n   * - Can be used to attach custom middlewares to the dev server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks.\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * Native Node http server instance.\n   * Will be null in middleware mode.\n   */\n  httpServer: http.Server | null\n  /**\n   * Chokidar watcher instance. If `config.server.watch` is set to `null`,\n   * returns a noop event emitter.\n   * https://github.com/paulmillr/chokidar#api\n   */\n  watcher: FSWatcher\n  /**\n   * Web socket server with `send(payload)` method.\n   */\n  ws: WebSocketServer\n  /**\n   * Rollup plugin container that can run plugin hooks on a given file.\n   */\n  pluginContainer: PluginContainer\n  /**\n   * Module graph that tracks the import relationships, url to file mapping\n   * and hmr state.\n   */\n  moduleGraph: ModuleGraph\n  /**\n   * The resolved urls Vite prints on the CLI. null in middleware mode or\n   * before `server.listen` is called.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Programmatically resolve, load and transform a URL and get the result\n   * without going through the http request pipeline.\n   */\n  transformRequest(\n    url: string,\n    options?: TransformOptions,\n  ): Promise<TransformResult | null>\n  /**\n   * Apply Vite built-in HTML transforms and any plugin HTML transforms.\n   */\n  transformIndexHtml(url: string, html: string): Promise<string>\n  /**\n   * Load a given URL as an instantiated module for SSR.\n   */\n  ssrLoadModule(\n    url: string,\n    options?: { fixStacktrace?: boolean },\n  ): Promise<Record<string, any>>\n  /**\n   * Fix ssr error stacktrace.\n   */\n  ssrFixStacktrace(e: Error): void\n  /**\n   * Triggers HMR for a module in the module graph. You can use the `server.moduleGraph`\n   * API to retrieve the module to be reloaded. If `hmr` is false, this is a no-op.\n   */\n  reloadModule(module: ModuleNode): Promise<void>\n  /**\n   * Start the server.\n   */\n  listen(port?: number, isRestart?: boolean): Promise<ViteDevServer>\n  /**\n   * Restart the server.\n   *\n   * @param forceOptimize - force the optimizer to re-bundle, same as --force cli flag\n   */\n  restart(forceOptimize?: boolean): Promise<void>\n  /**\n   * Stop the server.\n   */\n  close(): Promise<void>\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<ViteDevServer>): void\n}\nbuild\n​\n\nType Signature:\n\nts\nasync function build(\n  inlineConfig?: InlineConfig,\n): Promise<RollupOutput | RollupOutput[]>\n\nExample Usage:\n\njs\nimport path from 'path'\nimport { fileURLToPath } from 'url'\nimport { build } from 'vite'\n\nconst __dirname = fileURLToPath(new URL('.', import.meta.url))\n\n;(async () => {\n  await build({\n    root: path.resolve(__dirname, './project'),\n    base: '/foo/',\n    build: {\n      rollupOptions: {\n        // ...\n      },\n    },\n  })\n})()\npreview\n​\n\nType Signature:\n\nts\nasync function preview(inlineConfig?: InlineConfig): Promise<PreviewServer>\n\nExample Usage:\n\njs\nimport { preview } from 'vite'\n;(async () => {\n  const previewServer = await preview({\n    // any valid user config options, plus `mode` and `configFile`\n    preview: {\n      port: 8080,\n      open: true,\n    },\n  })\n\n  previewServer.printUrls()\n  previewServer.bindCLIShortcuts({ print: true })\n})()\nPreviewServer\n​\nts\ninterface PreviewServer {\n  /**\n   * The resolved vite config object\n   */\n  config: ResolvedConfig\n  /**\n   * A connect app instance.\n   * - Can be used to attach custom middlewares to the preview server.\n   * - Can also be used as the handler function of a custom http server\n   *   or as a middleware in any connect-style Node.js frameworks\n   *\n   * https://github.com/senchalabs/connect#use-middleware\n   */\n  middlewares: Connect.Server\n  /**\n   * native Node http server instance\n   */\n  httpServer: http.Server\n  /**\n   * The resolved urls Vite prints on the CLI.\n   * null before server is listening.\n   */\n  resolvedUrls: ResolvedServerUrls | null\n  /**\n   * Print server urls\n   */\n  printUrls(): void\n  /**\n   * Bind CLI shortcuts\n   */\n  bindCLIShortcuts(options?: BindCLIShortcutsOptions<PreviewServer>): void\n}\nresolveConfig\n​\n\nType Signature:\n\nts\nasync function resolveConfig(\n  inlineConfig: InlineConfig,\n  command: 'build' | 'serve',\n  defaultMode = 'development',\n  defaultNodeEnv = 'development',\n  isPreview = false,\n): Promise<ResolvedConfig>\n\nThe command value is serve in dev and preview, and build in build.\n\nmergeConfig\n​\n\nType Signature:\n\nts\nfunction mergeConfig(\n  defaults: Record<string, any>,\n  overrides: Record<string, any>,\n  isRoot = true,\n): Record<string, any>\n\nDeeply merge two Vite configs. isRoot represents the level within the Vite config which is being merged. For example, set false if you're merging two build options.\n\nNOTE\n\nmergeConfig accepts only config in object form. If you have a config in callback form, you should call it before passing into mergeConfig.\n\nYou can use the defineConfig helper to merge a config in callback form with another config:\n\nts\nexport default defineConfig((configEnv) =>\n  mergeConfig(configAsCallback(configEnv), configAsObject),\n)\nsearchForWorkspaceRoot\n​\n\nType Signature:\n\nts\nfunction searchForWorkspaceRoot(\n  current: string,\n  root = searchForPackageRoot(current),\n): string\n\nRelated: server.fs.allow\n\nSearch for the root of the potential workspace if it meets the following conditions, otherwise it would fallback to root:\n\ncontains workspaces field in package.json\ncontains one of the following file\nlerna.json\npnpm-workspace.yaml\nloadEnv\n​\n\nType Signature:\n\nts\nfunction loadEnv(\n  mode: string,\n  envDir: string,\n  prefixes: string | string[] = 'VITE_',\n): Record<string, string>\n\nRelated: .env Files\n\nLoad .env files within the envDir. By default, only env variables prefixed with VITE_ are loaded, unless prefixes is changed.\n\nnormalizePath\n​\n\nType Signature:\n\nts\nfunction normalizePath(id: string): string\n\nRelated: Path Normalization\n\nNormalizes a path to interoperate between Vite plugins.\n\ntransformWithEsbuild\n​\n\nType Signature:\n\nts\nasync function transformWithEsbuild(\n  code: string,\n  filename: string,\n  options?: EsbuildTransformOptions,\n  inMap?: object,\n): Promise<ESBuildTransformResult>\n\nTransform JavaScript or TypeScript with esbuild. Useful for plugins that prefer matching Vite's internal esbuild transform.\n\nloadConfigFromFile\n​\n\nType Signature:\n\nts\nasync function loadConfigFromFile(\n  configEnv: ConfigEnv,\n  configFile?: string,\n  configRoot: string = process.cwd(),\n  logLevel?: LogLevel,\n): Promise<{\n  path: string\n  config: UserConfig\n  dependencies: string[]\n} | null>\n\nLoad a Vite config file manually with esbuild."
  },
  {
    "title": "HMR API | Vite",
    "url": "https://vitejs.dev/guide/api-hmr",
    "html": "HMR API\n​\n\nNote\n\nThis is the client HMR API. For handling HMR update in plugins, see handleHotUpdate.\n\nThe manual HMR API is primarily intended for framework and tooling authors. As an end user, HMR is likely already handled for you in the framework specific starter templates.\n\nVite exposes its manual HMR API via the special import.meta.hot object:\n\nts\ninterface ImportMeta {\n  readonly hot?: ViteHotContext\n}\n\ntype ModuleNamespace = Record<string, any> & {\n  [Symbol.toStringTag]: 'Module'\n}\n\ninterface ViteHotContext {\n  readonly data: any\n\n  accept(): void\n  accept(cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void\n  accept(\n    deps: readonly string[],\n    cb: (mods: Array<ModuleNamespace | undefined>) => void,\n  ): void\n\n  dispose(cb: (data: any) => void): void\n  prune(cb: (data: any) => void): void\n  invalidate(message?: string): void\n\n  // `InferCustomEventPayload` provides types for built-in Vite events\n  on<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  off<T extends string>(\n    event: T,\n    cb: (payload: InferCustomEventPayload<T>) => void,\n  ): void\n  send<T extends string>(event: T, data?: InferCustomEventPayload<T>): void\n}\nRequired Conditional Guard\n​\n\nFirst of all, make sure to guard all HMR API usage with a conditional block so that the code can be tree-shaken in production:\n\njs\nif (import.meta.hot) {\n  // HMR code\n}\nIntelliSense for TypeScript\n​\n\nVite provides type definitions for import.meta.hot in vite/client.d.ts. You can create an env.d.ts in the src directory so TypeScript picks up the type definitions:\n\nts\n/// <reference types=\"vite/client\" />\nhot.accept(cb)\n​\n\nFor a module to self-accept, use import.meta.hot.accept with a callback which receives the updated module:\n\njs\nexport const count = 1\n\nif (import.meta.hot) {\n  import.meta.hot.accept((newModule) => {\n    if (newModule) {\n      // newModule is undefined when SyntaxError happened\n      console.log('updated: count is now ', newModule.count)\n    }\n  })\n}\n\nA module that \"accepts\" hot updates is considered an HMR boundary.\n\nVite's HMR does not actually swap the originally imported module: if an HMR boundary module re-exports imports from a dep, then it is responsible for updating those re-exports (and these exports must be using let). In addition, importers up the chain from the boundary module will not be notified of the change. This simplified HMR implementation is sufficient for most dev use cases, while allowing us to skip the expensive work of generating proxy modules.\n\nVite requires that the call to this function appears as import.meta.hot.accept( (whitespace-sensitive) in the source code in order for the module to accept update. This is a requirement of the static analysis that Vite does to enable HMR support for a module.\n\nhot.accept(deps, cb)\n​\n\nA module can also accept updates from direct dependencies without reloading itself:\n\njs\nimport { foo } from './foo.js'\n\nfoo()\n\nif (import.meta.hot) {\n  import.meta.hot.accept('./foo.js', (newFoo) => {\n    // the callback receives the updated './foo.js' module\n    newFoo?.foo()\n  })\n\n  // Can also accept an array of dep modules:\n  import.meta.hot.accept(\n    ['./foo.js', './bar.js'],\n    ([newFooModule, newBarModule]) => {\n      // The callback receives an array where only the updated module is\n      // non null. If the update was not successful (syntax error for ex.),\n      // the array is empty\n    },\n  )\n}\nhot.dispose(cb)\n​\n\nA self-accepting module or a module that expects to be accepted by others can use hot.dispose to clean-up any persistent side effects created by its updated copy:\n\njs\nfunction setupSideEffect() {}\n\nsetupSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.dispose((data) => {\n    // cleanup side effect\n  })\n}\nhot.prune(cb)\n​\n\nRegister a callback that will call when the module is no longer imported on the page. Compared to hot.dispose, this can be used if the source code cleans up side-effects by itself on updates and you only need to clean-up when it's removed from the page. Vite currently uses this for .css imports.\n\njs\nfunction setupOrReuseSideEffect() {}\n\nsetupOrReuseSideEffect()\n\nif (import.meta.hot) {\n  import.meta.hot.prune((data) => {\n    // cleanup side effect\n  })\n}\nhot.data\n​\n\nThe import.meta.hot.data object is persisted across different instances of the same updated module. It can be used to pass on information from a previous version of the module to the next one.\n\nNote that re-assignment of data itself is not supported. Instead, you should mutate properties of the data object so information added from other handlers are preserved.\n\njs\n// ok\nimport.meta.hot.data.someValue = 'hello'\n\n// not supported\nimport.meta.hot.data = { someValue: 'hello' }\nhot.decline()\n​\n\nThis is currently a noop and is there for backward compatibility. This could change in the future if there is a new usage for it. To indicate that the module is not hot-updatable, use hot.invalidate().\n\nhot.invalidate(message?: string)\n​\n\nA self-accepting module may realize during runtime that it can't handle a HMR update, and so the update needs to be forcefully propagated to importers. By calling import.meta.hot.invalidate(), the HMR server will invalidate the importers of the caller, as if the caller wasn't self-accepting. This will log a message both in the browser console and in the terminal. You can pass a message to give some context on why the invalidation happened.\n\nNote that you should always call import.meta.hot.accept even if you plan to call invalidate immediately afterwards, or else the HMR client won't listen for future changes to the self-accepting module. To communicate your intent clearly, we recommend calling invalidate within the accept callback like so:\n\njs\nimport.meta.hot.accept((module) => {\n  // You may use the new module instance to decide whether to invalidate.\n  if (cannotHandleUpdate(module)) {\n    import.meta.hot.invalidate()\n  }\n})\nhot.on(event, cb)\n​\n\nListen to an HMR event.\n\nThe following HMR events are dispatched by Vite automatically:\n\n'vite:beforeUpdate' when an update is about to be applied (e.g. a module will be replaced)\n'vite:afterUpdate' when an update has just been applied (e.g. a module has been replaced)\n'vite:beforeFullReload' when a full reload is about to occur\n'vite:beforePrune' when modules that are no longer needed are about to be pruned\n'vite:invalidate' when a module is invalidated with import.meta.hot.invalidate()\n'vite:error' when an error occurs (e.g. syntax error)\n'vite:ws:disconnect' when the WebSocket connection is lost\n'vite:ws:connect' when the WebSocket connection is (re-)established\n\nCustom HMR events can also be sent from plugins. See handleHotUpdate for more details.\n\nhot.off(event, cb)\n​\n\nRemove callback from the event listeners\n\nhot.send(event, data)\n​\n\nSend custom events back to Vite's dev server.\n\nIf called before connected, the data will be buffered and sent once the connection is established.\n\nSee Client-server Communication for more details."
  },
  {
    "title": "Plugin API | Vite",
    "url": "https://vitejs.dev/guide/api-plugin",
    "html": "Plugin API\n​\n\nVite plugins extends Rollup's well-designed plugin interface with a few extra Vite-specific options. As a result, you can write a Vite plugin once and have it work for both dev and build.\n\nIt is recommended to go through Rollup's plugin documentation first before reading the sections below.\n\nAuthoring a Plugin\n​\n\nVite strives to offer established patterns out of the box, so before creating a new plugin make sure that you check the Features guide to see if your need is covered. Also review available community plugins, both in the form of a compatible Rollup plugin and Vite Specific plugins\n\nWhen creating a plugin, you can inline it in your vite.config.js. There is no need to create a new package for it. Once you see that a plugin was useful in your projects, consider sharing it to help others in the ecosystem.\n\nTIP\n\nWhen learning, debugging, or authoring plugins, we suggest including vite-plugin-inspect in your project. It allows you to inspect the intermediate state of Vite plugins. After installing, you can visit localhost:5173/__inspect/ to inspect the modules and transformation stack of your project. Check out install instructions in the vite-plugin-inspect docs.\n\nConventions\n​\n\nIf the plugin doesn't use Vite specific hooks and can be implemented as a Compatible Rollup Plugin, then it is recommended to use the Rollup Plugin naming conventions.\n\nRollup Plugins should have a clear name with rollup-plugin- prefix.\nInclude rollup-plugin and vite-plugin keywords in package.json.\n\nThis exposes the plugin to be also used in pure Rollup or WMR based projects\n\nFor Vite only plugins\n\nVite Plugins should have a clear name with vite-plugin- prefix.\nInclude vite-plugin keyword in package.json.\nInclude a section in the plugin docs detailing why it is a Vite only plugin (for example, it uses Vite specific plugin hooks).\n\nIf your plugin is only going to work for a particular framework, its name should be included as part of the prefix\n\nvite-plugin-vue- prefix for Vue Plugins\nvite-plugin-react- prefix for React Plugins\nvite-plugin-svelte- prefix for Svelte Plugins\n\nSee also Virtual Modules Convention.\n\nPlugins config\n​\n\nUsers will add plugins to the project devDependencies and configure them using the plugins array option.\n\njs\n// vite.config.js\nimport vitePlugin from 'vite-plugin-feature'\nimport rollupPlugin from 'rollup-plugin-feature'\n\nexport default defineConfig({\n  plugins: [vitePlugin(), rollupPlugin()],\n})\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\nplugins also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\njs\n// framework-plugin\nimport frameworkRefresh from 'vite-plugin-framework-refresh'\nimport frameworkDevtools from 'vite-plugin-framework-devtools'\n\nexport default function framework(config) {\n  return [frameworkRefresh(config), frameworkDevTools(config)]\n}\njs\n// vite.config.js\nimport { defineConfig } from 'vite'\nimport framework from 'vite-plugin-framework'\n\nexport default defineConfig({\n  plugins: [framework()],\n})\nSimple Examples\n​\n\nTIP\n\nIt is common convention to author a Vite/Rollup plugin as a factory function that returns the actual plugin object. The function can accept options which allows users to customize the behavior of the plugin.\n\nTransforming Custom File Types\n​\njs\nconst fileRegex = /\\.(my-file-ext)$/\n\nexport default function myPlugin() {\n  return {\n    name: 'transform-file',\n\n    transform(src, id) {\n      if (fileRegex.test(id)) {\n        return {\n          code: compileFileToJS(src),\n          map: null, // provide source map if available\n        }\n      }\n    },\n  }\n}\nImporting a Virtual File\n​\n\nSee the example in the next section.\n\nVirtual Modules Convention\n​\n\nVirtual modules are a useful scheme that allows you to pass build time information to the source files using normal ESM import syntax.\n\njs\nexport default function myPlugin() {\n  const virtualModuleId = 'virtual:my-module'\n  const resolvedVirtualModuleId = '\\0' + virtualModuleId\n\n  return {\n    name: 'my-plugin', // required, will show up in warnings and errors\n    resolveId(id) {\n      if (id === virtualModuleId) {\n        return resolvedVirtualModuleId\n      }\n    },\n    load(id) {\n      if (id === resolvedVirtualModuleId) {\n        return `export const msg = \"from virtual module\"`\n      }\n    },\n  }\n}\n\nWhich allows importing the module in JavaScript:\n\njs\nimport { msg } from 'virtual:my-module'\n\nconsole.log(msg)\n\nVirtual modules in Vite (and Rollup) are prefixed with virtual: for the user-facing path by convention. If possible the plugin name should be used as a namespace to avoid collisions with other plugins in the ecosystem. For example, a vite-plugin-posts could ask users to import a virtual:posts or virtual:posts/helpers virtual modules to get build time information. Internally, plugins that use virtual modules should prefix the module ID with \\0 while resolving the id, a convention from the rollup ecosystem. This prevents other plugins from trying to process the id (like node resolution), and core features like sourcemaps can use this info to differentiate between virtual modules and regular files. \\0 is not a permitted char in import URLs so we have to replace them during import analysis. A \\0{id} virtual id ends up encoded as /@id/__x00__{id} during dev in the browser. The id will be decoded back before entering the plugins pipeline, so this is not seen by plugins hooks code.\n\nNote that modules directly derived from a real file, as in the case of a script module in a Single File Component (like a .vue or .svelte SFC) don't need to follow this convention. SFCs generally generate a set of submodules when processed but the code in these can be mapped back to the filesystem. Using \\0 for these submodules would prevent sourcemaps from working correctly.\n\nUniversal Hooks\n​\n\nDuring dev, the Vite dev server creates a plugin container that invokes Rollup Build Hooks the same way Rollup does it.\n\nThe following hooks are called once on server start:\n\noptions\nbuildStart\n\nThe following hooks are called on each incoming module request:\n\nresolveId\nload\ntransform\n\nThese hooks also have an extended options parameter with additional Vite-specific properties. You can read more in the SSR documentation.\n\nSome resolveId calls' importer value may be an absolute path for a generic index.html at root as it's not always possible to derive the actual importer due to Vite's unbundled dev server pattern. For imports handled within Vite's resolve pipeline, the importer can be tracked during the import analysis phase, providing the correct importer value.\n\nThe following hooks are called when the server is closed:\n\nbuildEnd\ncloseBundle\n\nNote that the moduleParsed hook is not called during dev, because Vite avoids full AST parses for better performance.\n\nOutput Generation Hooks (except closeBundle) are not called during dev. You can think of Vite's dev server as only calling rollup.rollup() without calling bundle.generate().\n\nVite Specific Hooks\n​\n\nVite plugins can also provide hooks that serve Vite-specific purposes. These hooks are ignored by Rollup.\n\nconfig\n​\n\nType: (config: UserConfig, env: { mode: string, command: string }) => UserConfig | null | void\n\nKind: async, sequential\n\nModify Vite config before it's resolved. The hook receives the raw user config (CLI options merged with config file) and the current config env which exposes the mode and command being used. It can return a partial config object that will be deeply merged into existing config, or directly mutate the config (if the default merging cannot achieve the desired result).\n\nExample:\n\njs\n// return partial config (recommended)\nconst partialConfigPlugin = () => ({\n  name: 'return-partial',\n  config: () => ({\n    resolve: {\n      alias: {\n        foo: 'bar',\n      },\n    },\n  }),\n})\n\n// mutate the config directly (use only when merging doesn't work)\nconst mutateConfigPlugin = () => ({\n  name: 'mutate-config',\n  config(config, { command }) {\n    if (command === 'build') {\n      config.root = 'foo'\n    }\n  },\n})\n\nNote\n\nUser plugins are resolved before running this hook so injecting other plugins inside the config hook will have no effect.\n\nconfigResolved\n​\n\nType: (config: ResolvedConfig) => void | Promise<void>\n\nKind: async, parallel\n\nCalled after the Vite config is resolved. Use this hook to read and store the final resolved config. It is also useful when the plugin needs to do something different based on the command being run.\n\nExample:\n\njs\nconst examplePlugin = () => {\n  let config\n\n  return {\n    name: 'read-config',\n\n    configResolved(resolvedConfig) {\n      // store the resolved config\n      config = resolvedConfig\n    },\n\n    // use stored config in other hooks\n    transform(code, id) {\n      if (config.command === 'serve') {\n        // dev: plugin invoked by dev server\n      } else {\n        // build: plugin invoked by Rollup\n      }\n    },\n  }\n}\n\nNote that the command value is serve in dev (in the cli vite, vite dev, and vite serve are aliases).\n\nconfigureServer\n​\n\nType: (server: ViteDevServer) => (() => void) | void | Promise<(() => void) | void>\n\nKind: async, sequential\n\nSee also: ViteDevServer\n\nHook for configuring the dev server. The most common use case is adding custom middlewares to the internal connect app:\n\njs\nconst myPlugin = () => ({\n  name: 'configure-server',\n  configureServer(server) {\n    server.middlewares.use((req, res, next) => {\n      // custom handle request...\n    })\n  },\n})\n\nInjecting Post Middleware\n\nThe configureServer hook is called before internal middlewares are installed, so the custom middlewares will run before internal middlewares by default. If you want to inject a middleware after internal middlewares, you can return a function from configureServer, which will be called after internal middlewares are installed:\n\njs\nconst myPlugin = () => ({\n  name: 'configure-server',\n  configureServer(server) {\n    // return a post hook that is called after internal middlewares are\n    // installed\n    return () => {\n      server.middlewares.use((req, res, next) => {\n        // custom handle request...\n      })\n    }\n  },\n})\n\nStoring Server Access\n\nIn some cases, other plugin hooks may need access to the dev server instance (e.g. accessing the web socket server, the file system watcher, or the module graph). This hook can also be used to store the server instance for access in other hooks:\n\njs\nconst myPlugin = () => {\n  let server\n  return {\n    name: 'configure-server',\n    configureServer(_server) {\n      server = _server\n    },\n    transform(code, id) {\n      if (server) {\n        // use server...\n      }\n    },\n  }\n}\n\nNote configureServer is not called when running the production build so your other hooks need to guard against its absence.\n\nconfigurePreviewServer\n​\n\nType: (server: PreviewServer) => (() => void) | void | Promise<(() => void) | void>\n\nKind: async, sequential\n\nSee also: PreviewServer\n\nSame as configureServer but for the preview server. Similarly to configureServer, the configurePreviewServer hook is called before other middlewares are installed. If you want to inject a middleware after other middlewares, you can return a function from configurePreviewServer, which will be called after internal middlewares are installed:\n\njs\nconst myPlugin = () => ({\n  name: 'configure-preview-server',\n  configurePreviewServer(server) {\n    // return a post hook that is called after other middlewares are\n    // installed\n    return () => {\n      server.middlewares.use((req, res, next) => {\n        // custom handle request...\n      })\n    }\n  },\n})\ntransformIndexHtml\n​\n\nType: IndexHtmlTransformHook | { order?: 'pre' | 'post', handler: IndexHtmlTransformHook }\n\nKind: async, sequential\n\nDedicated hook for transforming HTML entry point files such as index.html. The hook receives the current HTML string and a transform context. The context exposes the ViteDevServer instance during dev, and exposes the Rollup output bundle during build.\n\nThe hook can be async and can return one of the following:\n\nTransformed HTML string\nAn array of tag descriptor objects ({ tag, attrs, children }) to inject to the existing HTML. Each tag can also specify where it should be injected to (default is prepending to <head>)\nAn object containing both as { html, tags }\n\nBy default order is undefined, with this hook applied after the HTML has been transformed. In order to inject a script that should go through the Vite plugins pipeline, order: 'pre' will apply the hook before processing the HTML. order: 'post' applies the hook after all hooks with order undefined are applied.\n\nBasic Example:\n\njs\nconst htmlPlugin = () => {\n  return {\n    name: 'html-transform',\n    transformIndexHtml(html) {\n      return html.replace(\n        /<title>(.*?)<\\/title>/,\n        `<title>Title replaced!</title>`,\n      )\n    },\n  }\n}\n\nFull Hook Signature:\n\nts\ntype IndexHtmlTransformHook = (\n  html: string,\n  ctx: {\n    path: string\n    filename: string\n    server?: ViteDevServer\n    bundle?: import('rollup').OutputBundle\n    chunk?: import('rollup').OutputChunk\n  },\n) =>\n  | IndexHtmlTransformResult\n  | void\n  | Promise<IndexHtmlTransformResult | void>\n\ntype IndexHtmlTransformResult =\n  | string\n  | HtmlTagDescriptor[]\n  | {\n      html: string\n      tags: HtmlTagDescriptor[]\n    }\n\ninterface HtmlTagDescriptor {\n  tag: string\n  attrs?: Record<string, string | boolean>\n  children?: string | HtmlTagDescriptor[]\n  /**\n   * default: 'head-prepend'\n   */\n  injectTo?: 'head' | 'body' | 'head-prepend' | 'body-prepend'\n}\nhandleHotUpdate\n​\n\nType: (ctx: HmrContext) => Array<ModuleNode> | void | Promise<Array<ModuleNode> | void>\n\nPerform custom HMR update handling. The hook receives a context object with the following signature:\n\nts\ninterface HmrContext {\n  file: string\n  timestamp: number\n  modules: Array<ModuleNode>\n  read: () => string | Promise<string>\n  server: ViteDevServer\n}\n\nmodules is an array of modules that are affected by the changed file. It's an array because a single file may map to multiple served modules (e.g. Vue SFCs).\n\nread is an async read function that returns the content of the file. This is provided because on some systems, the file change callback may fire too fast before the editor finishes updating the file and direct fs.readFile will return empty content. The read function passed in normalizes this behavior.\n\nThe hook can choose to:\n\nFilter and narrow down the affected module list so that the HMR is more accurate.\n\nReturn an empty array and perform complete custom HMR handling by sending custom events to the client:\n\njs\nhandleHotUpdate({ server }) {\n  server.ws.send({\n    type: 'custom',\n    event: 'special-update',\n    data: {}\n  })\n  return []\n}\n\nClient code should register corresponding handler using the HMR API (this could be injected by the same plugin's transform hook):\n\njs\nif (import.meta.hot) {\n  import.meta.hot.on('special-update', (data) => {\n    // perform custom update\n  })\n}\nPlugin Ordering\n​\n\nA Vite plugin can additionally specify an enforce property (similar to webpack loaders) to adjust its application order. The value of enforce can be either \"pre\" or \"post\". The resolved plugins will be in the following order:\n\nAlias\nUser plugins with enforce: 'pre'\nVite core plugins\nUser plugins without enforce value\nVite build plugins\nUser plugins with enforce: 'post'\nVite post build plugins (minify, manifest, reporting)\nConditional Application\n​\n\nBy default plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the apply property to only invoke them during 'build' or 'serve':\n\njs\nfunction myPlugin() {\n  return {\n    name: 'build-only',\n    apply: 'build', // or 'serve'\n  }\n}\n\nA function can also be used for more precise control:\n\njs\napply(config, { command }) {\n  // apply only on build but not for SSR\n  return command === 'build' && !config.build.ssr\n}\nRollup Plugin Compatibility\n​\n\nA fair number of Rollup plugins will work directly as a Vite plugin (e.g. @rollup/plugin-alias or @rollup/plugin-json), but not all of them, since some plugin hooks do not make sense in an unbundled dev server context.\n\nIn general, as long as a Rollup plugin fits the following criteria then it should just work as a Vite plugin:\n\nIt doesn't use the moduleParsed hook.\nIt doesn't have strong coupling between bundle-phase hooks and output-phase hooks.\n\nIf a Rollup plugin only makes sense for the build phase, then it can be specified under build.rollupOptions.plugins instead. It will work the same as a Vite plugin with enforce: 'post' and apply: 'build'.\n\nYou can also augment an existing Rollup plugin with Vite-only properties:\n\njs\n// vite.config.js\nimport example from 'rollup-plugin-example'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...example(),\n      enforce: 'post',\n      apply: 'build',\n    },\n  ],\n})\n\nCheck out Vite Rollup Plugins for a list of compatible official Rollup plugins with usage instructions.\n\nPath Normalization\n​\n\nVite normalizes paths while resolving ids to use POSIX separators ( / ) while preserving the volume in Windows. On the other hand, Rollup keeps resolved paths untouched by default, so resolved ids have win32 separators ( \\ ) in Windows. However, Rollup plugins use a normalizePath utility function from @rollup/pluginutils internally, which converts separators to POSIX before performing comparisons. This means that when these plugins are used in Vite, the include and exclude config pattern and other similar paths against resolved ids comparisons work correctly.\n\nSo, for Vite plugins, when comparing paths against resolved ids it is important to first normalize the paths to use POSIX separators. An equivalent normalizePath utility function is exported from the vite module.\n\njs\nimport { normalizePath } from 'vite'\n\nnormalizePath('foo\\\\bar') // 'foo/bar'\nnormalizePath('foo/bar') // 'foo/bar'\nFiltering, include/exclude pattern\n​\n\nVite exposes @rollup/pluginutils's createFilter function to encourage Vite specific plugins and integrations to use the standard include/exclude filtering pattern, which is also used in Vite core itself.\n\nClient-server Communication\n​\n\nSince Vite 2.9, we provide some utilities for plugins to help handle the communication with clients.\n\nServer to Client\n​\n\nOn the plugin side, we could use server.ws.send to broadcast events to all the clients:\n\njs\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        // Example: wait for a client to connect before sending a message\n        server.ws.on('connection', () => {\n          server.ws.send('my:greetings', { msg: 'hello' })\n        })\n      },\n    },\n  ],\n})\n\nNOTE\n\nWe recommend always prefixing your event names to avoid collisions with other plugins.\n\nOn the client side, use hot.on to listen to the events:\n\nts\n// client side\nif (import.meta.hot) {\n  import.meta.hot.on('my:greetings', (data) => {\n    console.log(data.msg) // hello\n  })\n}\nClient to Server\n​\n\nTo send events from the client to the server, we can use hot.send:\n\nts\n// client side\nif (import.meta.hot) {\n  import.meta.hot.send('my:from-client', { msg: 'Hey!' })\n}\n\nThen use server.ws.on and listen to the events on the server side:\n\njs\n// vite.config.js\nexport default defineConfig({\n  plugins: [\n    {\n      // ...\n      configureServer(server) {\n        server.ws.on('my:from-client', (data, client) => {\n          console.log('Message from client:', data.msg) // Hey!\n          // reply only to the client (if needed)\n          client.send('my:ack', { msg: 'Hi! I got your message!' })\n        })\n      },\n    },\n  ],\n})\nTypeScript for Custom Events\n​\n\nIt is possible to type custom events by extending the CustomEventMap interface:\n\nts\n// events.d.ts\nimport 'vite/types/customEvent'\n\ndeclare module 'vite/types/customEvent' {\n  interface CustomEventMap {\n    'custom:foo': { msg: string }\n    // 'event-key': payload\n  }\n}"
  },
  {
    "title": "Migration from v4 | Vite",
    "url": "https://vitejs.dev/guide/migration",
    "html": "Migration from v4\n​\nNode.js Support\n​\n\nVite no longer supports Node.js 14 / 16 / 17 / 19, which reached its EOL. Node.js 18 / 20+ is now required.\n\nRollup 4\n​\n\nVite is now using Rollup 4 which also brings along its breaking changes, in particular:\n\nImport assertions (assertions prop) has been renamed to import attributes (attributes prop).\nAcorn plugins are no longer supported.\nFor Vite plugins, this.resolve skipSelf option is now true by default.\nFor Vite plugins, this.parse now only supports the allowReturnOutsideFunction option for now.\n\nRead the full breaking changes in Rollup's release notes for build-related changes in build.rollupOptions.\n\nIf you are using TypeScript, make sure to set moduleResolution: 'bundler' (or node16/nodenext) as Rollup 4 requires it. Or you can set skipLibCheck: true instead.\n\nDeprecate CJS Node API\n​\n\nThe CJS Node API of Vite is deprecated. When calling require('vite'), a deprecation warning is now logged. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\nThe vite.config.js file content is using the ESM syntax.\nThe closest package.json file has \"type\": \"module\", or use the .mjs/.mts extension, e.g. vite.config.mjs or vite.config.mts.\n\nFor other projects, there are a few general approaches:\n\nConfigure ESM as default, opt-in to CJS if needed: Add \"type\": \"module\" in the project package.json. All *.js files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the .cjs extension to keep using CJS instead.\nKeep CJS as default, opt-in to ESM if needed: If the project package.json does not have \"type\": \"module\", all *.js files are interpreted as CJS. You can rename a file with the .mjs extension to use ESM instead.\nDynamically import Vite: If you need to keep using CJS, you can dynamically import Vite using import('vite') instead. This requires your code to be written in an async context, but should still be manageable as Vite's API is mostly asynchronous.\n\nSee the troubleshooting guide for more information.\n\nRework define and import.meta.env.* replacement strategy\n​\n\nIn Vite 4, the define and import.meta.env.* features use different replacement strategies in dev and build:\n\nIn dev, both features are injected as global variables to globalThis and import.meta respectively.\nIn build, both features are statically replaced with a regex.\n\nThis results in a dev and build inconsistency when trying to access the variables, and sometimes even caused failed builds. For example:\n\njs\n// vite.config.js\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('1.0.0'),\n  },\n})\njs\nconst data = { __APP_VERSION__ }\n// dev: { __APP_VERSION__: \"1.0.0\" } ✅\n// build: { \"1.0.0\" } ❌\n\nconst docs = 'I like import.meta.env.MODE'\n// dev: \"I like import.meta.env.MODE\" ✅\n// build: \"I like \"production\"\" ❌\n\nVite 5 fixes this by using esbuild to handle the replacements in builds, aligning with the dev behaviour.\n\nThis change should not affect most setups, as it's already documented that define values should follow esbuild's syntax:\n\nTo be consistent with esbuild behavior, expressions must either be a JSON object (null, boolean, number, string, array, or object) or a single identifier.\n\nHowever, if you prefer to keep statically replacing values directly, you can use @rollup/plugin-replace.\n\nGeneral Changes\n​\nSSR externalized modules value now matches production\n​\n\nIn Vite 4, SSR externalized modules are wrapped with .default and .__esModule handling for better interoperability, but it doesn't match the production behaviour when loaded by the runtime environment (e.g. Node.js), causing hard-to-catch inconsistencies. By default, all direct project dependencies are SSR externalized.\n\nVite 5 now removes the .default and .__esModule handling to match the production behaviour. In practice, this shouldn't affect properly-packaged dependencies, but if you encounter new issues loading modules, you can try these refactors:\n\njs\n// Before:\nimport { foo } from 'bar'\n\n// After:\nimport _bar from 'bar'\nconst { foo } = _bar\njs\n// Before:\nimport foo from 'bar'\n\n// After:\nimport * as _foo from 'bar'\nconst foo = _foo.default\n\nNote that these changes matches the Node.js behaviour, so you can also run the imports in Node.js to test it out. If you prefer to stick with the previous behaviour, you can set legacy.proxySsrExternalModules to true.\n\nworker.plugins is now a function\n​\n\nIn Vite 4, worker.plugins accepted an array of plugins ((Plugin | Plugin[])[]). From Vite 5, it needs to be configured as a function that returns an array of plugins (() => (Plugin | Plugin[])[]). This change is required so parallel worker builds run more consistently and predictably.\n\nAllow path containing . to fallback to index.html\n​\n\nIn Vite 4, accessing a path in dev containing . did not fallback to index.html even if appType is set to 'spa' (default). From Vite 5, it will fallback to index.html.\n\nNote that the browser will no longer show a 404 error message in the console if you point the image path to a non-existent file (e.g. <img src=\"./file-does-not-exist.png\">).\n\nAlign dev and preview HTML serving behaviour\n​\n\nIn Vite 4, the dev and preview servers serve HTML based on its directory structure and trailing slash differently. This causes inconsistencies when testing your built app. Vite 5 refactors into a single behaviour like below, given the following file structure:\n\n├── index.html\n├── file.html\n└── dir\n    └── index.html\nRequest\tBefore (dev)\tBefore (preview)\tAfter (dev & preview)\n/dir/index.html\t/dir/index.html\t/dir/index.html\t/dir/index.html\n/dir\t/index.html (SPA fallback)\t/dir/index.html\t/index.html (SPA fallback)\n/dir/\t/dir/index.html\t/dir/index.html\t/dir/index.html\n/file.html\t/file.html\t/file.html\t/file.html\n/file\t/index.html (SPA fallback)\t/file.html\t/file.html\n/file/\t/index.html (SPA fallback)\t/file.html\t/index.html (SPA fallback)\nManifest files are now generated in .vite directory by default\n​\n\nIn Vite 4, the manifest files (build.manifest and build.ssrManifest) were generated in the root of build.outDir by default.\n\nFrom Vite 5, they will be generated in the .vite directory in the build.outDir by default. This change helps deconflict public files with the same manifest file names when they are copied to the build.outDir.\n\nCLI shortcuts require an additional Enter press\n​\n\nCLI shortcuts, like r to restart the dev server, now require an additional Enter press to trigger the shortcut. For example, r + Enter to restart the dev server.\n\nThis change prevents Vite from swallowing and controlling OS-specific shortcuts, allowing better compatibility when combining the Vite dev server with other processes, and avoids the previous caveats.\n\nUpdate experimentalDecorators and useDefineForClassFields TypeScript behaviour\n​\n\nVite 5 uses esbuild 0.19 and removes the compatibility layer for esbuild 0.18, which changes how experimentalDecorators and useDefineForClassFields are handled.\n\nexperimentalDecorators is not enabled by default\n\nYou need to set compilerOptions.experimentalDecorators to true in tsconfig.json to use decorators.\n\nuseDefineForClassFields defaults depend on the TypeScript target value\n\nIf target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.\n\nAs such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.\n\njsonc\n{\n  \"compilerOptions\": {\n    // Set true if you use decorators\n    \"experimentalDecorators\": true,\n    // Set true if you see parsing errors in your browser\n    \"useDefineForClassFields\": true\n  }\n}\nRemove --https flag and https: true\n​\n\nThe --https flag sets server.https: true and preview.https: true internally. This config was meant to be used together with the automatic https certification generation feature which was dropped in Vite 3. Hence, this config is no longer useful as it will start a Vite HTTPS server without a certificate.\n\nIf you use @vitejs/plugin-basic-ssl or vite-plugin-mkcert, they will already set the https config internally, so you can remove --https, server.https: true, and preview.https: true in your setup.\n\nRemove resolvePackageEntry and resolvePackageData APIs\n​\n\nThe resolvePackageEntry and resolvePackageData APIs are removed as they exposed Vite's internals and blocked potential Vite 4.3 optimizations in the past. These APIs can be replaced with third-party packages, for example:\n\nresolvePackageEntry: import.meta.resolve or the import-meta-resolve package.\nresolvePackageData: Same as above, and crawl up the package directory to get the root package.json. Or use the community vitefu package.\njs\nimport { resolve } from 'import-meta-env'\nimport { findDepPkgJsonPath } from 'vitefu'\nimport fs from 'node:fs'\n\nconst pkg = 'my-lib'\nconst basedir = process.cwd()\n\n// `resolvePackageEntry`:\nconst packageEntry = resolve(pkg, basedir)\n\n// `resolvePackageData`:\nconst packageJsonPath = findDepPkgJsonPath(pkg, basedir)\nconst packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))\nRemoved Deprecated APIs\n​\nDefault exports of CSS files (e.g import style from './foo.css'): Use the ?inline query instead\nimport.meta.globEager: Use import.meta.glob('*', { eager: true }) instead\nssr.format: 'cjs' and legacy.buildSsrCjsExternalHeuristics (#13816)\nserver.middlewareMode: 'ssr' and server.middlewareMode: 'html': Use appType + server.middlewareMode: true instead (#8452)\nAdvanced\n​\n\nThere are some changes which only affect plugin/tool creators.\n\n[#14119] refactor!: merge PreviewServerForHook into PreviewServer type\nThe configurePreviewServer hook now accepts the PreviewServer type instead of PreviewServerForHook type.\n[#14818] refactor(preview)!: use base middleware\nMiddlewares added from the returned function in configurePreviewServer now does not have access to the base when comparing the req.url value. This aligns the behaviour with the dev server. You can check the base from the configResolved hook if needed.\n[#14834] fix(types)!: expose httpServer with Http2SecureServer union\nhttp.Server | http2.Http2SecureServer is now used instead of http.Server where appropriate.\n\nAlso there are other breaking changes which only affect few users.\n\n[#14098] fix!: avoid rewriting this (reverts #5312)\nTop level this was rewritten to globalThis by default when building. This behavior is now removed.\n[#14231] feat!: add extension to internal virtual modules\nInternal virtual modules' id now has an extension (.js).\n[#14583] refactor!: remove exporting internal APIs\nRemoved accidentally exported internal APIs: isDepsOptimizerEnabled and getDepOptimizationConfig\nRemoved exported internal types: DepOptimizationResult, DepOptimizationProcessing, and DepsOptimizer\nRenamed ResolveWorkerOptions type to ResolvedWorkerOptions\n[#5657] fix: return 404 for resources requests outside the base path\nIn the past, Vite responded to requests outside the base path without Accept: text/html, as if they were requested with the base path. Vite no longer does that and responds with 404 instead.\n[#14723] fix(resolve)!: remove special .mjs handling\nIn the past, when a library \"exports\" field maps to an .mjs file, Vite will still try to match the \"browser\" and \"module\" fields to fix compatibility with certain libraries. This behavior is now removed to align with the exports resolution algorithm.\n[#14733] feat(resolve)!: remove resolve.browserField\nresolve.browserField has been deprecated since Vite 3 in favour of an updated default of ['browser', 'module', 'jsnext:main', 'jsnext'] for resolve.mainFields.\n[#14855] feat!: add isPreview to ConfigEnv and resolveConfig\nRenamed ssrBuild to isSsrBuild in the ConfigEnv object.\nMigration from v3\n​\n\nCheck the Migration from v3 Guide in the Vite v4 docs first to see the needed changes to port your app to Vite v4, and then proceed with the changes on this page."
  },
  {
    "title": "Performance | Vite",
    "url": "https://vitejs.dev/guide/performance",
    "html": "Performance\n​\n\nWhile Vite is fast by default, performance issues can creep in as the project's requirements grow. This guide aims to help you identify and fix common performance issues, such as:\n\nSlow server starts\nSlow page loads\nSlow builds\nAudit Configured Vite Plugins\n​\n\nVite's internal and official plugins are optimized to do the least amount of work possible while providing compatibility with the broader ecosystem. For example, code transformations use regex in dev, but do a complete parse in build to ensure correctness.\n\nHowever, the performance of community plugins is out of Vite's control, which may affect the developer experience. Here are a few things you can look out for when using additional Vite plugins:\n\nLarge dependencies that are only used in certain cases should be dynamically imported to reduce the Node.js startup time. Example refactors: vite-plugin-react#212 and vite-plugin-pwa#224.\n\nThe buildStart, config, and configResolved hooks should not run long and extensive operations. These hooks are awaited during dev server startup, which delays when you can access the site in the browser.\n\nThe resolveId, load, and transform hooks may cause some files to load slower than others. While sometimes unavoidable, it's still worth checking for possible areas to optimize. For example, checking if the code contains a specific keyword, or the id matches a specific extension, before doing the full transformation.\n\nThe longer it takes to transform a file, the more significant the request waterfall will be when loading the site in the browser.\n\nYou can inspect the duration it takes to transform a file using DEBUG=\"vite:plugin-transform\" vite or vite-plugin-inspect. Note that as asynchronous operations tend to provide inaccurate timings, you should treat the numbers as a rough estimate, but it should still reveal the more expensive operations.\n\nProfiling\n\nYou can run vite --profile, visit the site, and press p + enter in your terminal to record a .cpuprofile. A tool like speedscope can then be used to inspect the profile and identify the bottlenecks. You can also share the profiles with the Vite team to help us identify performance issues.\n\nReduce Resolve Operations\n​\n\nResolving import paths can be an expensive operation when hitting its worst case often. For example, Vite supports \"guessing\" import paths with the resolve.extensions option, which defaults to ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json'].\n\nWhen you try to import ./Component.jsx with import './Component', Vite will run these steps to resolve it:\n\nCheck if ./Component exists, no.\nCheck if ./Component.mjs exists, no.\nCheck if ./Component.js exists, no.\nCheck if ./Component.mts exists, no.\nCheck if ./Component.ts exists, no.\nCheck if ./Component.jsx exists, yes!\n\nAs shown, a total of 6 filesystem checks is required to resolve an import path. The more implicit imports you have, the more time it adds up to resolve the paths.\n\nHence, it's usually better to be explicit with your import paths, e.g. import './Component.jsx'. You can also narrow down the list for resolve.extensions to reduce the general filesystem checks, but you have to make sure it works for files in node_modules too.\n\nIf you're a plugin author, make sure to only call this.resolve when needed to reduce the number of checks above.\n\nTypeScript\n\nIf you are using TypeScript, enable \"moduleResolution\": \"bundler\" and \"allowImportingTsExtensions\": true in your tsconfig.json's compilerOptions to use .ts and .tsx extensions directly in your code.\n\nAvoid Barrel Files\n​\n\nBarrel files are files that re-export the APIs of other files in the same directory. For example:\n\njs\n// src/utils/index.js\nexport * from './color.js'\nexport * from './dom.js'\nexport * from './slash.js'\n\nWhen you only import an individual API, e.g. import { slash } from './utils', all the files in that barrel file need to be fetched and transformed as they may contain the slash API and may also contain side-effects that run on initialization. This means you're loading more files than required on the initial page load, resulting in a slower page load.\n\nIf possible, you should avoid barrel files and import the individual APIs directly, e.g. import { slash } from './utils/slash.js'. You can read issue #8237 for more information.\n\nWarm Up Frequently Used Files\n​\n\nThe Vite dev server only transforms files as requested by the browser, which allows it to start up quickly and only apply transformations for used files. It can also pre-transform files if it anticipates certain files will be requested shortly. However, request waterfalls may still happen if some files take longer to transform than others. For example:\n\nGiven an import graph where the left file imports the right file:\n\nmain.js -> BigComponent.vue -> big-utils.js -> large-data.json\n\nThe import relationship can only be known after the file is transformed. If BigComponent.vue takes some time to transform, big-utils.js has to wait for its turn, and so on. This causes an internal waterfall even with pre-transformation built-in.\n\nVite allows you to warm up files that you know are frequently used, e.g. big-utils.js, using the server.warmup option. This way big-utils.js will be ready and cached to be served immediately when requested.\n\nYou can find files that are frequently used by running DEBUG=\"vite:transform\" vite and inspect the logs:\n\nbash\nvite:transform 28.72ms /@vite/client +1ms\nvite:transform 62.95ms /src/components/BigComponent.vue +1ms\nvite:transform 102.54ms /src/utils/big-utils.js +1ms\njs\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: [\n        './src/components/BigComponent.vue',\n        './src/utils/big-utils.js',\n      ],\n    },\n  },\n})\n\nNote that you should only warm up files that are frequently used to not overload the Vite dev server on startup. Check the server.warmup option for more information.\n\nUsing --open or server.open also provides a performance boost, as Vite will automatically warm up the entry point of your app or the provided URL to open.\n\nUse Lesser or Native Tooling\n​\n\nKeeping Vite fast with a growing codebase is about reducing the amount of work for the source files (JS/TS/CSS).\n\nExamples of doing less work:\n\nUse CSS instead of Sass/Less/Stylus when possible (nesting can be handled by PostCSS)\nDon't transform SVGs into UI framework components (React, Vue, etc). Import them as strings or URLs instead.\nWhen using @vitejs/plugin-react, avoid configuring the Babel options, so it skips the transformation during build (only esbuild will be used).\n\nExamples of using native tooling:\n\nUsing native tooling often brings larger installation size and as so is not the default when starting a new Vite project. But it may be worth the cost for larger applications.\n\nTry out the experimental support for LightningCSS\nUse @vitejs/plugin-react-swc in place of @vitejs/plugin-react."
  },
  {
    "title": "Project Philosophy | Vite",
    "url": "https://vitejs.dev/guide/philosophy",
    "html": "Project Philosophy\n​\nLean Extendable Core\n​\n\nVite doesn't intend to cover every use case for every user. Vite aims to support the most common patterns to build Web apps out-of-the-box, but Vite core must remain lean with a small API surface to keep the project maintainable long-term. This goal is possible thanks to Vite's rollup-based plugin system. Features that can be implemented as external plugins will generally not be added to Vite core. vite-plugin-pwa is a great example of what can be achieved out of Vite core, and there are a lot of well maintained plugins to cover your needs. Vite works closely with the Rollup project to ensure that plugins can be used in both plain-rollup and Vite projects as much as possible, trying to push needed extensions to the Plugin API upstream when possible.\n\nPushing the Modern Web\n​\n\nVite provides opinionated features that pushes writing modern code. For example:\n\nThe source code can only be written in ESM, where non-ESM dependencies needs to be pre-bundled as ESM in order to work.\nWeb workers are encouraged to be written with the new Worker syntax to follow modern standards.\nNode.js modules cannot be used in the browser.\n\nWhen adding new features, these patterns are followed to create a future-proof API, which may not always be compatible with other build tools.\n\nA Pragmatic Approach to Performance\n​\n\nVite has been focused on performance since its origins. Its dev server architecture allows HMR that stays fast as projects scale. Vite uses native tools like esbuild and SWC to implement intensive tasks but keeps the rest of the code in JS to balance speed with flexibility. When needed, framework plugins will tap into Babel to compile user code. And during build time Vite currently uses Rollup where bundling size and having access to a wide ecosystem of plugins are more important than raw speed. Vite will continue to evolve internally, using new libraries as they appear to improve DX while keeping its API stable.\n\nBuilding Frameworks on top of Vite\n​\n\nAlthough Vite can be used by users directly, it shines as a tool to create frameworks. Vite core is framework agnostic, but there are polished plugins for each UI frameworks. Its JS API allows App Framework authors to use Vite features to create tailored experiences for their users. Vite includes support for SSR primitives, usually present in higher-level tools but fundamental to building modern web frameworks. And Vite plugins complete the picture by offering a way to share between frameworks. Vite is also a great fit when paired with Backend frameworks like Ruby and Laravel.\n\nAn Active Ecosystem\n​\n\nVite evolution is a cooperation between framework and plugin maintainers, users, and the Vite team. We encourage active participation in Vite's Core development once a project adopts Vite. We work closely with the main projects in the ecosystem to minimize regressions on each release, aided by tools like vite-ecosystem-ci. It allows us to run the CI of major projects using Vite on selected PRs and gives us a clear status of how the Ecosystem would react to a release. We strive to fix regressions before they hit users and allow projects to update to the next versions as soon as they are released. If you are working with Vite, we invite you to join Vite's Discord and get involved in the project too."
  },
  {
    "title": "Troubleshooting | Vite",
    "url": "https://vitejs.dev/guide/troubleshooting",
    "html": "Troubleshooting\n​\n\nSee Rollup's troubleshooting guide for more information too.\n\nIf the suggestions here don't work, please try posting questions on GitHub Discussions or in the #help channel of Vite Land Discord.\n\nCJS\n​\nVite CJS Node API deprecated\n​\n\nThe CJS build of Vite's Node API is deprecated and will be removed in Vite 6. See the GitHub discussion for more context. You should update your files or frameworks to import the ESM build of Vite instead.\n\nIn a basic Vite project, make sure:\n\nThe vite.config.js file content is using the ESM syntax.\nThe closest package.json file has \"type\": \"module\", or use the .mjs/.mts extension, e.g. vite.config.mjs or vite.config.mts.\n\nFor other projects, there are a few general approaches:\n\nConfigure ESM as default, opt-in to CJS if needed: Add \"type\": \"module\" in the project package.json. All *.js files are now interpreted as ESM and needs to use the ESM syntax. You can rename a file with the .cjs extension to keep using CJS instead.\nKeep CJS as default, opt-in to ESM if needed: If the project package.json does not have \"type\": \"module\", all *.js files are interpreted as CJS. You can rename a file with the .mjs extension to use ESM instead.\nDynamically import Vite: If you need to keep using CJS, you can dynamically import Vite using import('vite') instead. This requires your code to be written in an async context, but should still be manageable as Vite's API is mostly asynchronous.\n\nIf you're unsure where the warning is coming from, you can run your script with the VITE_CJS_TRACE=true flag to log the stack trace:\n\nbash\nVITE_CJS_TRACE=true vite dev\n\nIf you'd like to temporarily ignore the warning, you can run your script with the VITE_CJS_IGNORE_WARNING=true flag:\n\nbash\nVITE_CJS_IGNORE_WARNING=true vite dev\n\nNote that postcss config files does not support ESM + TypeScript (.mts or .ts in \"type\": \"module\") yet. If you have postcss configs with .ts and added \"type\": \"module\" to package.json, you'll also need to rename the postcss config to use .cts.\n\nCLI\n​\nError: Cannot find module 'C:\\foo\\bar&baz\\vite\\bin\\vite.js'\n​\n\nThe path to your project folder may include &, which doesn't work with npm on Windows (npm/cmd-shim#45).\n\nYou will need to either:\n\nSwitch to another package manager (e.g. pnpm, yarn)\nRemove & from the path to your project\nConfig\n​\nThis package is ESM only\n​\n\nWhen importing a ESM only package by require, the following error happens.\n\nFailed to resolve \"foo\". This package is ESM only but it was tried to load by require.\n\n\"foo\" resolved to an ESM file. ESM file cannot be loaded by require.\n\nESM files cannot be loaded by require.\n\nWe recommend converting your config to ESM by either:\n\nadding \"type\": \"module\" to the nearest package.json\nrenaming vite.config.js/vite.config.ts to vite.config.mjs/vite.config.mts\nDev Server\n​\nRequests are stalled forever\n​\n\nIf you are using Linux, file descriptor limits and inotify limits may be causing the issue. As Vite does not bundle most of the files, browsers may request many files which require many file descriptors, going over the limit.\n\nTo solve this:\n\nIncrease file descriptor limit by ulimit\n\nshell\n# Check current limit\n$ ulimit -Sn\n# Change limit (temporary)\n$ ulimit -Sn 10000 # You might need to change the hard limit too\n# Restart your browser\n\nIncrease the following inotify related limits by sysctl\n\nshell\n# Check current limits\n$ sysctl fs.inotify\n# Change limits (temporary)\n$ sudo sysctl fs.inotify.max_queued_events=16384\n$ sudo sysctl fs.inotify.max_user_instances=8192\n$ sudo sysctl fs.inotify.max_user_watches=524288\n\nIf the above steps don't work, you can try adding DefaultLimitNOFILE=65536 as an un-commented config to the following files:\n\n/etc/systemd/system.conf\n/etc/systemd/user.conf\n\nFor Ubuntu Linux, you may need to add the line * - nofile 65536 to the file /etc/security/limits.conf instead of updating systemd config files.\n\nNote that these settings persist but a restart is required.\n\nNetwork requests stop loading\n​\n\nWhen using a self-signed SSL certificate, Chrome ignores all caching directives and reloads the content. Vite relies on these caching directives.\n\nTo resolve the problem use a trusted SSL cert.\n\nSee: Cache problems, Chrome issue\n\nmacOS\n​\n\nYou can install a trusted cert via the CLI with this command:\n\nsecurity add-trusted-cert -d -r trustRoot -k ~/Library/Keychains/login.keychain-db your-cert.cer\n\nOr, by importing it into the Keychain Access app and updating the trust of your cert to \"Always Trust.\"\n\n431 Request Header Fields Too Large\n​\n\nWhen the server / WebSocket server receives a large HTTP header, the request will be dropped and the following warning will be shown.\n\nServer responded with status code 431. See https://vitejs.dev/guide/troubleshooting.html#_431-request-header-fields-too-large.\n\nThis is because Node.js limits request header size to mitigate CVE-2018-12121.\n\nTo avoid this, try to reduce your request header size. For example, if the cookie is long, delete it. Or you can use --max-http-header-size to change max header size.\n\nHMR\n​\nVite detects a file change but the HMR is not working\n​\n\nYou may be importing a file with a different case. For example, src/foo.js exists and src/bar.js contains:\n\njs\nimport './Foo.js' // should be './foo.js'\n\nRelated issue: #964\n\nVite does not detect a file change\n​\n\nIf you are running Vite with WSL2, Vite cannot watch file changes in some conditions. See server.watch option.\n\nA full reload happens instead of HMR\n​\n\nIf HMR is not handled by Vite or a plugin, a full reload will happen as it's the only way to refresh the state.\n\nIf HMR is handled but it is within a circular dependency, a full reload will also happen to recover the execution order. To solve this, try breaking the loop. You can run vite --debug hmr to log the circular dependency path if a file change triggered it.\n\nBuild\n​\nBuilt file does not work because of CORS error\n​\n\nIf the HTML file output was opened with file protocol, the scripts won't run with the following error.\n\nAccess to script at 'file:///foo/bar.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, isolated-app, chrome-extension, chrome, https, chrome-untrusted.\n\nCross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at file:///foo/bar.js. (Reason: CORS request not http).\n\nSee Reason: CORS request not HTTP - HTTP | MDN for more information about why this happens.\n\nYou will need to access the file with http protocol. The easiest way to achieve this is to run npx vite preview.\n\nOptimized Dependencies\n​\nOutdated pre-bundled deps when linking to a local package\n​\n\nThe hash key used to invalidate optimized dependencies depend on the package lock contents, the patches applied to dependencies, and the options in the Vite config file that affects the bundling of node modules. This means that Vite will detect when a dependency is overridden using a feature as npm overrides, and re-bundle your dependencies on the next server start. Vite won't invalidate the dependencies when you use a feature like npm link. In case you link or unlink a dependency, you'll need to force re-optimization on the next server start by using vite --force. We recommend using overrides instead, which are supported now by every package manager (see also pnpm overrides and yarn resolutions).\n\nPerformance bottlenecks\n​\n\nIf you suffer any application performance bottlenecks resulting in slow load times, you can start the built-in Node.js inspector with your Vite dev server or when building your application to create the CPU profile:\n\ndev server\nbuild\nbash\nvite --profile --open\n\nVite Dev Server\n\nOnce your application is opened in the browser, just await finish loading it and then go back to the terminal and press p key (will stop the Node.js inspector) then press q key to stop the dev server.\n\nNode.js inspector will generate vite-profile-0.cpuprofile in the root folder, go to https://www.speedscope.app/, and upload the CPU profile using the BROWSE button to inspect the result.\n\nYou can install vite-plugin-inspect, which lets you inspect the intermediate state of Vite plugins and can also help you to identify which plugins or middlewares are the bottleneck in your applications. The plugin can be used in both dev and build modes. Check the readme file for more details.\n\nOthers\n​\nModule externalized for browser compatibility\n​\n\nWhen you use a Node.js module in the browser, Vite will output the following warning.\n\nModule \"fs\" has been externalized for browser compatibility. Cannot access \"fs.readFile\" in client code.\n\nThis is because Vite does not automatically polyfill Node.js modules.\n\nWe recommend avoiding Node.js modules for browser code to reduce the bundle size, although you can add polyfills manually. If the module is imported from a third-party library (that's meant to be used in the browser), it's advised to report the issue to the respective library.\n\nSyntax Error / Type Error happens\n​\n\nVite cannot handle and does not support code that only runs on non-strict mode (sloppy mode). This is because Vite uses ESM and it is always strict mode inside ESM.\n\nFor example, you might see these errors.\n\n[ERROR] With statements cannot be used with the \"esm\" output format due to strict mode\n\nTypeError: Cannot create property 'foo' on boolean 'false'\n\nIf these code are used inside dependencies, you could use patch-package (or yarn patch or pnpm patch) for an escape hatch.\n\nBrowser extensions\n​\n\nSome browser extensions (like ad-blockers) may prevent the Vite client from sending requests to the Vite dev server. You may see a white screen without logged errors in this case. Try disabling extensions if you have this issue.\n\nCross drive links on Windows\n​\n\nIf there's a cross drive links in your project on Windows, Vite may not work.\n\nAn example of cross drive links are:\n\na virtual drive linked to a folder by subst command\na symlink/junction to a different drive by mklink command (e.g. Yarn global cache)\n\nRelated issue: #10802"
  },
  {
    "title": "Comparisons | Vite",
    "url": "https://vitejs.dev/guide/comparisons",
    "html": "Comparisons\n​\nWMR\n​\n\nWMR by the Preact team provides a similar feature set, and Vite 2.0's support for Rollup's plugin interface is inspired by it.\n\nWMR is mainly designed for Preact projects, and offers more integrated features such as pre-rendering. In terms of scope, it's closer to a Preact meta framework, with the same emphasis on compact size as Preact itself. If you are using Preact, WMR is likely going to offer a more fine-tuned experience.\n\n@web/dev-server\n​\n\n@web/dev-server (previously es-dev-server) is a great project and Vite 1.0's Koa-based server setup was inspired by it.\n\n@web/dev-server is a bit lower-level in terms of scope. It does not provide official framework integrations, and requires manually setting up a Rollup configuration for the production build.\n\nOverall, Vite is a more opinionated / higher-level tool that aims to provide a more out-of-the-box workflow. That said, the @web umbrella project contains many other excellent tools that may benefit Vite users as well.\n\nSnowpack\n​\n\nSnowpack was also a no-bundle native ESM dev server, very similar in scope to Vite. The project is no longer being maintained. The Snowpack team is now working on Astro, a static site builder powered by Vite. The Astro team is now an active player in the ecosystem, and they are helping to improve Vite.\n\nAside from different implementation details, the two projects shared a lot in terms of technical advantages over traditional tooling. Vite's dependency pre-bundling is also inspired by Snowpack v1 (now esinstall). Some of the main differences between the two projects are listed in the v2 Comparisons Guide."
  },
  {
    "title": "Backend Integration | Vite",
    "url": "https://vitejs.dev/guide/backend-integration",
    "html": "Backend Integration\n​\n\nNote\n\nIf you want to serve the HTML using a traditional backend (e.g. Rails, Laravel) but use Vite for serving assets, check for existing integrations listed in Awesome Vite.\n\nIf you need a custom integration, you can follow the steps in this guide to configure it manually\n\nIn your Vite config, configure the entry and enable build manifest:\n\njs\n// vite.config.js\nexport default defineConfig({\n  build: {\n    // generate .vite/manifest.json in outDir\n    manifest: true,\n    rollupOptions: {\n      // overwrite default .html entry\n      input: '/path/to/main.js',\n    },\n  },\n})\n\nIf you haven't disabled the module preload polyfill, you also need to import the polyfill in your entry\n\njs\n// add the beginning of your app entry\nimport 'vite/modulepreload-polyfill'\n\nFor development, inject the following in your server's HTML template (substitute http://localhost:5173 with the local URL Vite is running at):\n\nhtml\n<!-- if development -->\n<script type=\"module\" src=\"http://localhost:5173/@vite/client\"></script>\n<script type=\"module\" src=\"http://localhost:5173/main.js\"></script>\n\nIn order to properly serve assets, you have two options:\n\nMake sure the server is configured to proxy static assets requests to the Vite server\nSet server.origin so that generated asset URLs will be resolved using the back-end server URL instead of a relative path\n\nThis is needed for assets such as images to load properly.\n\nNote if you are using React with @vitejs/plugin-react, you'll also need to add this before the above scripts, since the plugin is not able to modify the HTML you are serving (substitute http://localhost:5173 with the local URL Vite is running at):\n\nhtml\n<script type=\"module\">\n  import RefreshRuntime from 'http://localhost:5173/@react-refresh'\n  RefreshRuntime.injectIntoGlobalHook(window)\n  window.$RefreshReg$ = () => {}\n  window.$RefreshSig$ = () => (type) => type\n  window.__vite_plugin_react_preamble_installed__ = true\n</script>\n\nFor production: after running vite build, a .vite/manifest.json file will be generated alongside other asset files. An example manifest file looks like this:\n\njson\n{\n  \"main.js\": {\n    \"file\": \"assets/main.4889e940.js\",\n    \"src\": \"main.js\",\n    \"isEntry\": true,\n    \"dynamicImports\": [\"views/foo.js\"],\n    \"css\": [\"assets/main.b82dbe22.css\"],\n    \"assets\": [\"assets/asset.0ab0f9cd.png\"]\n  },\n  \"views/foo.js\": {\n    \"file\": \"assets/foo.869aea0d.js\",\n    \"src\": \"views/foo.js\",\n    \"isDynamicEntry\": true,\n    \"imports\": [\"_shared.83069a53.js\"]\n  },\n  \"_shared.83069a53.js\": {\n    \"file\": \"assets/shared.83069a53.js\"\n  }\n}\nThe manifest has a Record<name, chunk> structure\nFor entry or dynamic entry chunks, the key is the relative src path from project root.\nFor non entry chunks, the key is the base name of the generated file prefixed with _.\nChunks will contain information on its static and dynamic imports (both are keys that map to the corresponding chunk in the manifest), and also its corresponding CSS and asset files (if any).\n\nYou can use this file to render links or preload directives with hashed filenames (note: the syntax here is for explanation only, substitute with your server templating language):\n\nhtml\n<!-- if production -->\n<link rel=\"stylesheet\" href=\"/assets/{{ manifest['main.js'].css }}\" />\n<script type=\"module\" src=\"/assets/{{ manifest['main.js'].file }}\"></script>"
  },
  {
    "title": "Server-Side Rendering | Vite",
    "url": "https://vitejs.dev/guide/ssr",
    "html": "Server-Side Rendering\n​\n\nNote\n\nSSR specifically refers to front-end frameworks (for example React, Preact, Vue, and Svelte) that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. If you are looking for integration with traditional server-side frameworks, check out the Backend Integration guide instead.\n\nThe following guide also assumes prior experience working with SSR in your framework of choice, and will only focus on Vite-specific integration details.\n\nLow-level API\n\nThis is a low-level API meant for library and framework authors. If your goal is to create an application, make sure to check out the higher-level SSR plugins and tools at Awesome Vite SSR section first. That said, many applications are successfully built directly on top of Vite's native low-level API.\n\nHelp\n\nIf you have questions, the community is usually helpful at Vite Discord's #ssr channel.\n\nExample Projects\n​\n\nVite provides built-in support for server-side rendering (SSR). create-vite-extra contains example SSR setups you can use as references for this guide:\n\nVanilla\nVue\nReact\nPreact\nSvelte\nSolid\n\nYou can also scaffold these projects locally by running create-vite and choose Others > create-vite-extra under the framework option.\n\nSource Structure\n​\n\nA typical SSR application will have the following source file structure:\n\n- index.html\n- server.js # main application server\n- src/\n  - main.js          # exports env-agnostic (universal) app code\n  - entry-client.js  # mounts the app to a DOM element\n  - entry-server.js  # renders the app using the framework's SSR API\n\nThe index.html will need to reference entry-client.js and include a placeholder where the server-rendered markup should be injected:\n\nhtml\n<div id=\"app\"><!--ssr-outlet--></div>\n<script type=\"module\" src=\"/src/entry-client.js\"></script>\n\nYou can use any placeholder you prefer instead of <!--ssr-outlet-->, as long as it can be precisely replaced.\n\nConditional Logic\n​\n\nIf you need to perform conditional logic based on SSR vs. client, you can use\n\njs\nif (import.meta.env.SSR) {\n  // ... server only logic\n}\n\nThis is statically replaced during build so it will allow tree-shaking of unused branches.\n\nSetting Up the Dev Server\n​\n\nWhen building an SSR app, you likely want to have full control over your main server and decouple Vite from the production environment. It is therefore recommended to use Vite in middleware mode. Here is an example with express:\n\nserver.js\n\njs\nimport fs from 'fs'\nimport path from 'path'\nimport { fileURLToPath } from 'url'\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url))\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode and configure the app type as\n  // 'custom', disabling Vite's own HTML serving logic so parent server\n  // can take control\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom'\n  })\n\n  // Use vite's connect instance as middleware. If you use your own\n  // express router (express.Router()), you should use router.use\n  app.use((req, res, next) => {\n    // When the server restarts (for example after the user modifies\n    // vite.config.js), `vite.middlewares` will be reassigned. Calling\n    // `vite.middlewares` inside a wrapper handler ensures that the\n    // latest Vite middlewares are always used.\n    vite.middlewares.handle(req, res, next)\n  })\n\n  app.use('*', async (req, res) => {\n    // serve index.html - we will tackle this next\n  })\n\n  app.listen(5173)\n}\n\ncreateServer()\n\nHere vite is an instance of ViteDevServer. vite.middlewares is a Connect instance which can be used as a middleware in any connect-compatible Node.js framework.\n\nThe next step is implementing the * handler to serve server-rendered HTML:\n\njs\napp.use('*', async (req, res, next) => {\n  const url = req.originalUrl\n\n  try {\n    // 1. Read index.html\n    let template = fs.readFileSync(\n      path.resolve(__dirname, 'index.html'),\n      'utf-8',\n    )\n\n    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,\n    //    and also applies HTML transforms from Vite plugins, e.g. global\n    //    preambles from @vitejs/plugin-react\n    template = await vite.transformIndexHtml(url, template)\n\n    // 3. Load the server entry. ssrLoadModule automatically transforms\n    //    ESM source code to be usable in Node.js! There is no bundling\n    //    required, and provides efficient invalidation similar to HMR.\n    const { render } = await vite.ssrLoadModule('/src/entry-server.js')\n\n    // 4. render the app HTML. This assumes entry-server.js's exported\n    //     `render` function calls appropriate framework SSR APIs,\n    //    e.g. ReactDOMServer.renderToString()\n    const appHtml = await render(url)\n\n    // 5. Inject the app-rendered HTML into the template.\n    const html = template.replace(`<!--ssr-outlet-->`, appHtml)\n\n    // 6. Send the rendered HTML back.\n    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)\n  } catch (e) {\n    // If an error is caught, let Vite fix the stack trace so it maps back\n    // to your actual source code.\n    vite.ssrFixStacktrace(e)\n    next(e)\n  }\n})\n\nThe dev script in package.json should also be changed to use the server script instead:\n\ndiff\n  \"scripts\": {\n-   \"dev\": \"vite\"\n+   \"dev\": \"node server\"\n  }\nBuilding for Production\n​\n\nTo ship an SSR project for production, we need to:\n\nProduce a client build as normal;\nProduce an SSR build, which can be directly loaded via import() so that we don't have to go through Vite's ssrLoadModule;\n\nOur scripts in package.json will look like this:\n\njson\n{\n  \"scripts\": {\n    \"dev\": \"node server\",\n    \"build:client\": \"vite build --outDir dist/client\",\n    \"build:server\": \"vite build --outDir dist/server --ssr src/entry-server.js\"\n  }\n}\n\nNote the --ssr flag which indicates this is an SSR build. It should also specify the SSR entry.\n\nThen, in server.js we need to add some production specific logic by checking process.env.NODE_ENV:\n\nInstead of reading the root index.html, use the dist/client/index.html as the template instead, since it contains the correct asset links to the client build.\n\nInstead of await vite.ssrLoadModule('/src/entry-server.js'), use import('./dist/server/entry-server.js') instead (this file is the result of the SSR build).\n\nMove the creation and all usage of the vite dev server behind dev-only conditional branches, then add static file serving middlewares to serve files from dist/client.\n\nRefer to the example projects for a working setup.\n\nGenerating Preload Directives\n​\n\nvite build supports the --ssrManifest flag which will generate .vite/ssr-manifest.json in build output directory:\n\ndiff\n- \"build:client\": \"vite build --outDir dist/client\",\n+ \"build:client\": \"vite build --outDir dist/client --ssrManifest\",\n\nThe above script will now generate dist/client/.vite/ssr-manifest.json for the client build (Yes, the SSR manifest is generated from the client build because we want to map module IDs to client files). The manifest contains mappings of module IDs to their associated chunks and asset files.\n\nTo leverage the manifest, frameworks need to provide a way to collect the module IDs of the components that were used during a server render call.\n\n@vitejs/plugin-vue supports this out of the box and automatically registers used component module IDs on to the associated Vue SSR context:\n\njs\n// src/entry-server.js\nconst ctx = {}\nconst html = await vueServerRenderer.renderToString(app, ctx)\n// ctx.modules is now a Set of module IDs that were used during the render\n\nIn the production branch of server.js we need to read and pass the manifest to the render function exported by src/entry-server.js. This would provide us with enough information to render preload directives for files used by async routes! See demo source for a full example. You can also use this information for 103 Early Hints.\n\nPre-Rendering / SSG\n​\n\nIf the routes and the data needed for certain routes are known ahead of time, we can pre-render these routes into static HTML using the same logic as production SSR. This can also be considered a form of Static-Site Generation (SSG). See demo pre-render script for working example.\n\nSSR Externals\n​\n\nDependencies are \"externalized\" from Vite's SSR transform module system by default when running SSR. This speeds up both dev and build.\n\nIf a dependency needs to be transformed by Vite's pipeline, for example, because Vite features are used untranspiled in them, they can be added to ssr.noExternal.\n\nFor linked dependencies, they are not externalized by default to take advantage of Vite's HMR. If this isn't desired, for example, to test dependencies as if they aren't linked, you can add it to ssr.external.\n\nWorking with Aliases\n\nIf you have configured aliases that redirect one package to another, you may want to alias the actual node_modules packages instead to make it work for SSR externalized dependencies. Both Yarn and pnpm support aliasing via the npm: prefix.\n\nSSR-specific Plugin Logic\n​\n\nSome frameworks such as Vue or Svelte compile components into different formats based on client vs. SSR. To support conditional transforms, Vite passes an additional ssr property in the options object of the following plugin hooks:\n\nresolveId\nload\ntransform\n\nExample:\n\njs\nexport function mySSRPlugin() {\n  return {\n    name: 'my-ssr',\n    transform(code, id, options) {\n      if (options?.ssr) {\n        // perform ssr-specific transform...\n      }\n    },\n  }\n}\n\nThe options object in load and transform is optional, rollup is not currently using this object but may extend these hooks with additional metadata in the future.\n\nNote\n\nBefore Vite 2.7, this was informed to plugin hooks with a positional ssr param instead of using the options object. All major frameworks and plugins are updated but you may find outdated posts using the previous API.\n\nSSR Target\n​\n\nThe default target for the SSR build is a node environment, but you can also run the server in a Web Worker. Packages entry resolution is different for each platform. You can configure the target to be Web Worker using the ssr.target set to 'webworker'.\n\nSSR Bundle\n​\n\nIn some cases like webworker runtimes, you might want to bundle your SSR build into a single JavaScript file. You can enable this behavior by setting ssr.noExternal to true. This will do two things:\n\nTreat all dependencies as noExternal\nThrow an error if any Node.js built-ins are imported\nSSR Resolve Conditions\n​\n\nBy default package entry resolution will use the conditions set in resolve.conditions for the SSR build. You can use ssr.resolve.conditions and ssr.resolve.externalConditions to customize this behavior.\n\nVite CLI\n​\n\nThe CLI commands $ vite dev and $ vite preview can also be used for SSR apps. You can add your SSR middlewares to the development server with configureServer and to the preview server with configurePreviewServer.\n\nNote\n\nUse a post hook so that your SSR middleware runs after Vite's middlewares."
  },
  {
    "title": "Env Variables and Modes | Vite",
    "url": "https://vitejs.dev/guide/env-and-mode",
    "html": "Env Variables and Modes\n​\nEnv Variables\n​\n\nVite exposes env variables on the special import.meta.env object. Some built-in variables are available in all cases:\n\nimport.meta.env.MODE: {string} the mode the app is running in.\n\nimport.meta.env.BASE_URL: {string} the base url the app is being served from. This is determined by the base config option.\n\nimport.meta.env.PROD: {boolean} whether the app is running in production (running the dev server with NODE_ENV='production' or running an app built with NODE_ENV='production').\n\nimport.meta.env.DEV: {boolean} whether the app is running in development (always the opposite of import.meta.env.PROD)\n\nimport.meta.env.SSR: {boolean} whether the app is running in the server.\n\n.env Files\n​\n\nVite uses dotenv to load additional environment variables from the following files in your environment directory:\n\n.env                # loaded in all cases\n.env.local          # loaded in all cases, ignored by git\n.env.[mode]         # only loaded in specified mode\n.env.[mode].local   # only loaded in specified mode, ignored by git\n\nEnv Loading Priorities\n\nAn env file for a specific mode (e.g. .env.production) will take higher priority than a generic one (e.g. .env).\n\nIn addition, environment variables that already exist when Vite is executed have the highest priority and will not be overwritten by .env files. For example, when running VITE_SOME_KEY=123 vite build.\n\n.env files are loaded at the start of Vite. Restart the server after making changes.\n\nLoaded env variables are also exposed to your client source code via import.meta.env as strings.\n\nTo prevent accidentally leaking env variables to the client, only variables prefixed with VITE_ are exposed to your Vite-processed code. e.g. for the following env variables:\n\nVITE_SOME_KEY=123\nDB_PASSWORD=foobar\n\nOnly VITE_SOME_KEY will be exposed as import.meta.env.VITE_SOME_KEY to your client source code, but DB_PASSWORD will not.\n\njs\nconsole.log(import.meta.env.VITE_SOME_KEY) // 123\nconsole.log(import.meta.env.DB_PASSWORD) // undefined\n\nAlso, Vite uses dotenv-expand to expand variables out of the box. To learn more about the syntax, check out their docs.\n\nNote that if you want to use $ inside your environment value, you have to escape it with \\.\n\nKEY=123\nNEW_KEY1=test$foo   # test\nNEW_KEY2=test\\$foo  # test$foo\nNEW_KEY3=test$KEY   # test123\n\nIf you want to customize the env variables prefix, see the envPrefix option.\n\nSECURITY NOTES\n\n.env.*.local files are local-only and can contain sensitive variables. You should add *.local to your .gitignore to avoid them being checked into git.\n\nSince any variables exposed to your Vite source code will end up in your client bundle, VITE_* variables should not contain any sensitive information.\n\nIntelliSense for TypeScript\n​\n\nBy default, Vite provides type definitions for import.meta.env in vite/client.d.ts. While you can define more custom env variables in .env.[mode] files, you may want to get TypeScript IntelliSense for user-defined env variables that are prefixed with VITE_.\n\nTo achieve this, you can create an env.d.ts in src directory, then augment ImportMetaEnv like this:\n\ntypescript\n/// <reference types=\"vite/client\" />\n\ninterface ImportMetaEnv {\n  readonly VITE_APP_TITLE: string\n  // more env variables...\n}\n\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n\nIf your code relies on types from browser environments such as DOM and WebWorker, you can update the lib field in tsconfig.json.\n\njson\n{\n  \"lib\": [\"WebWorker\"]\n}\nHTML Env Replacement\n​\n\nVite also supports replacing env variables in HTML files. Any properties in import.meta.env can be used in HTML files with a special %ENV_NAME% syntax:\n\nhtml\n<h1>Vite is running in %MODE%</h1>\n<p>Using data from %VITE_API_URL%</p>\n\nIf the env doesn't exist in import.meta.env, e.g. %NON_EXISTENT%, it will be ignored and not replaced, unlike import.meta.env.NON_EXISTENT in JS where it's replaced as undefined.\n\nGiven that Vite is used by many frameworks, it is intentionally unopinionated about complex replacements like conditionals. Vite can be extended using an existing userland plugin or a custom plugin that implements the transformIndexHtml hook.\n\nModes\n​\n\nBy default, the dev server (dev command) runs in development mode and the build command runs in production mode.\n\nThis means when running vite build, it will load the env variables from .env.production if there is one:\n\n# .env.production\nVITE_APP_TITLE=My App\n\nIn your app, you can render the title using import.meta.env.VITE_APP_TITLE.\n\nIn some cases, you may want to run vite build with a different mode to render a different title. You can overwrite the default mode used for a command by passing the --mode option flag. For example, if you want to build your app for a staging mode:\n\nbash\nvite build --mode staging\n\nAnd create a .env.staging file:\n\n# .env.staging\nVITE_APP_TITLE=My App (staging)\n\nAs vite build runs a production build by default, you can also change this and run a development build by using a different mode and .env file configuration:\n\n# .env.testing\nNODE_ENV=development\nNODE_ENV and Modes\n​\n\nIt's important to note that NODE_ENV (process.env.NODE_ENV) and modes are two different concepts. Here's how different commands affect the NODE_ENV and mode:\n\nCommand\tNODE_ENV\tMode\nvite build\t\"production\"\t\"production\"\nvite build --mode development\t\"production\"\t\"development\"\nNODE_ENV=development vite build\t\"development\"\t\"production\"\nNODE_ENV=development vite build --mode development\t\"development\"\t\"development\"\n\nThe different values of NODE_ENV and mode also reflect on its corresponding import.meta.env properties:\n\nCommand\timport.meta.env.PROD\timport.meta.env.DEV\nNODE_ENV=production\ttrue\tfalse\nNODE_ENV=development\tfalse\ttrue\nNODE_ENV=other\tfalse\ttrue\nCommand\timport.meta.env.MODE\n--mode production\t\"production\"\n--mode development\t\"development\"\n--mode staging\t\"staging\"\n\nNODE_ENV in .env files\n\nNODE_ENV=... can be set in the command, and also in your .env file. If NODE_ENV is specified in a .env.[mode] file, the mode can be used to control its value. However, both NODE_ENV and modes remain as two different concepts.\n\nThe main benefit with NODE_ENV=... in the command is that it allows Vite to detect the value early. It also allows you to read process.env.NODE_ENV in your Vite config as Vite can only load the env files once the config is evaluated."
  },
  {
    "title": "Deploying a Static Site | Vite",
    "url": "https://vitejs.dev/guide/static-deploy",
    "html": "Deploying a Static Site\n​\n\nThe following guides are based on some shared assumptions:\n\nYou are using the default build output location (dist). This location can be changed using build.outDir, and you can extrapolate instructions from these guides in that case.\nYou are using npm. You can use equivalent commands to run the scripts if you are using Yarn or other package managers.\nVite is installed as a local dev dependency in your project, and you have setup the following npm scripts:\njson\n{\n  \"scripts\": {\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  }\n}\n\nIt is important to note that vite preview is intended for previewing the build locally and not meant as a production server.\n\nNOTE\n\nThese guides provide instructions for performing a static deployment of your Vite site. Vite also supports Server Side Rendering. SSR refers to front-end frameworks that support running the same application in Node.js, pre-rendering it to HTML, and finally hydrating it on the client. Check out the SSR Guide to learn about this feature. On the other hand, if you are looking for integration with traditional server-side frameworks, check out the Backend Integration guide instead.\n\nBuilding the App\n​\n\nYou may run npm run build command to build the app.\n\nbash\n$ npm run build\n\nBy default, the build output will be placed at dist. You may deploy this dist folder to any of your preferred platforms.\n\nTesting the App Locally\n​\n\nOnce you've built the app, you may test it locally by running npm run preview command.\n\nbash\n$ npm run build\n$ npm run preview\n\nThe vite preview command will boot up a local static web server that serves the files from dist at http://localhost:4173. It's an easy way to check if the production build looks OK in your local environment.\n\nYou may configure the port of the server by passing the --port flag as an argument.\n\njson\n{\n  \"scripts\": {\n    \"preview\": \"vite preview --port 8080\"\n  }\n}\n\nNow the preview command will launch the server at http://localhost:8080.\n\nGitHub Pages\n​\n\nSet the correct base in vite.config.js.\n\nIf you are deploying to https://<USERNAME>.github.io/, or to a custom domain through GitHub Pages (eg. www.example.com), set base to '/'. Alternatively, you can remove base from the configuration, as it defaults to '/'.\n\nIf you are deploying to https://<USERNAME>.github.io/<REPO>/ (eg. your repository is at https://github.com/<USERNAME>/<REPO>), then set base to '/<REPO>/'.\n\nGo to your GitHub Pages configuration in the repository settings page and choose the source of deployment as \"GitHub Actions\", this will lead you to create a workflow that builds and deploys your project, a sample workflow that installs dependencies and builds using npm is provided:\n\nyml\n# Simple workflow for deploying static content to GitHub Pages\nname: Deploy static content to Pages\n\non:\n  # Runs on pushes targeting the default branch\n  push:\n    branches: ['main']\n\n  # Allows you to run this workflow manually from the Actions tab\n  workflow_dispatch:\n\n# Sets the GITHUB_TOKEN permissions to allow deployment to GitHub Pages\npermissions:\n  contents: read\n  pages: write\n  id-token: write\n\n# Allow one concurrent deployment\nconcurrency:\n  group: 'pages'\n  cancel-in-progress: true\n\njobs:\n  # Single deploy job since we're just deploying\n  deploy:\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: Set up Node\n        uses: actions/setup-node@v3\n        with:\n          node-version: 18\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm install\n      - name: Build\n        run: npm run build\n      - name: Setup Pages\n        uses: actions/configure-pages@v3\n      - name: Upload artifact\n        uses: actions/upload-pages-artifact@v2\n        with:\n          # Upload dist repository\n          path: './dist'\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v2\nGitLab Pages and GitLab CI\n​\n\nSet the correct base in vite.config.js.\n\nIf you are deploying to https://<USERNAME or GROUP>.gitlab.io/, you can omit base as it defaults to '/'.\n\nIf you are deploying to https://<USERNAME or GROUP>.gitlab.io/<REPO>/, for example your repository is at https://gitlab.com/<USERNAME>/<REPO>, then set base to '/<REPO>/'.\n\nCreate a file called .gitlab-ci.yml in the root of your project with the content below. This will build and deploy your site whenever you make changes to your content:\n\nyaml\nimage: node:16.5.0\npages:\n  stage: deploy\n  cache:\n    key:\n      files:\n        - package-lock.json\n      prefix: npm\n    paths:\n      - node_modules/\n  script:\n    - npm install\n    - npm run build\n    - cp -a dist/. public/\n  artifacts:\n    paths:\n      - public\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nNetlify\n​\nNetlify CLI\n​\nInstall the Netlify CLI.\nCreate a new site using ntl init.\nDeploy using ntl deploy.\nbash\n# Install the Netlify CLI\n$ npm install -g netlify-cli\n\n# Create a new site in Netlify\n$ ntl init\n\n# Deploy to a unique preview URL\n$ ntl deploy\n\nThe Netlify CLI will share with you a preview URL to inspect. When you are ready to go into production, use the prod flag:\n\nbash\n# Deploy the site into production\n$ ntl deploy --prod\nNetlify with Git\n​\nPush your code to a git repository (GitHub, GitLab, BitBucket, Azure DevOps).\nImport the project to Netlify.\nChoose the branch, output directory, and set up environment variables if applicable.\nClick on Deploy.\nYour Vite app is deployed!\n\nAfter your project has been imported and deployed, all subsequent pushes to branches other than the production branch along with pull requests will generate Preview Deployments, and all changes made to the Production Branch (commonly “main”) will result in a Production Deployment.\n\nVercel\n​\nVercel CLI\n​\nInstall the Vercel CLI and run vercel to deploy.\nVercel will detect that you are using Vite and will enable the correct settings for your deployment.\nYour application is deployed! (e.g. vite-vue-template.vercel.app)\nbash\n$ npm i -g vercel\n$ vercel init vite\nVercel CLI\n> Success! Initialized \"vite\" example in ~/your-folder.\n- To deploy, `cd vite` and run `vercel`.\nVercel for Git\n​\nPush your code to your git repository (GitHub, GitLab, Bitbucket).\nImport your Vite project into Vercel.\nVercel will detect that you are using Vite and will enable the correct settings for your deployment.\nYour application is deployed! (e.g. vite-vue-template.vercel.app)\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate Preview Deployments, and all changes made to the Production Branch (commonly “main”) will result in a Production Deployment.\n\nLearn more about Vercel’s Git Integration.\n\nCloudflare Pages\n​\nCloudflare Pages via Wrangler\n​\nInstall Wrangler CLI.\nAuthenticate Wrangler with your Cloudflare account using wrangler login.\nRun your build command.\nDeploy using npx wrangler pages deploy dist.\nbash\n# Install Wrangler CLI\n$ npm install -g wrangler\n\n# Login to Cloudflare account from CLI\n$ wrangler login\n\n# Run your build command\n$ npm run build\n\n# Create new deployment\n$ npx wrangler pages deploy dist\n\nAfter your assets are uploaded, Wrangler will give you a preview URL to inspect your site. When you log into the Cloudflare Pages dashboard, you will see your new project.\n\nCloudflare Pages with Git\n​\nPush your code to your git repository (GitHub, GitLab).\nLog in to the Cloudflare dashboard and select your account in Account Home > Pages.\nSelect Create a new Project and the Connect Git option.\nSelect the git project you want to deploy and click Begin setup\nSelect the corresponding framework preset in the build setting depending on the Vite framework you have selected.\nThen save and deploy!\nYour application is deployed! (e.g https://<PROJECTNAME>.pages.dev/)\n\nAfter your project has been imported and deployed, all subsequent pushes to branches will generate Preview Deployments unless specified not to in your branch build controls. All changes to the Production Branch (commonly “main”) will result in a Production Deployment.\n\nYou can also add custom domains and handle custom build settings on Pages. Learn more about Cloudflare Pages Git Integration.\n\nGoogle Firebase\n​\n\nMake sure you have firebase-tools installed.\n\nCreate firebase.json and .firebaserc at the root of your project with the following content:\n\nfirebase.json:\n\njson\n{\n  \"hosting\": {\n    \"public\": \"dist\",\n    \"ignore\": [],\n    \"rewrites\": [\n      {\n        \"source\": \"**\",\n        \"destination\": \"/index.html\"\n      }\n    ]\n  }\n}\n\n.firebaserc:\n\njs\n{\n  \"projects\": {\n    \"default\": \"<YOUR_FIREBASE_ID>\"\n  }\n}\n\nAfter running npm run build, deploy using the command firebase deploy.\n\nSurge\n​\n\nFirst install surge, if you haven’t already.\n\nRun npm run build.\n\nDeploy to surge by typing surge dist.\n\nYou can also deploy to a custom domain by adding surge dist yourdomain.com.\n\nAzure Static Web Apps\n​\n\nYou can quickly deploy your Vite app with Microsoft Azure Static Web Apps service. You need:\n\nAn Azure account and a subscription key. You can create a free Azure account here.\nYour app code pushed to GitHub.\nThe SWA Extension in Visual Studio Code.\n\nInstall the extension in VS Code and navigate to your app root. Open the Static Web Apps extension, sign in to Azure, and click the '+' sign to create a new Static Web App. You will be prompted to designate which subscription key to use.\n\nFollow the wizard started by the extension to give your app a name, choose a framework preset, and designate the app root (usually /) and built file location /dist. The wizard will run and will create a GitHub action in your repo in a .github folder.\n\nThe action will work to deploy your app (watch its progress in your repo's Actions tab) and, when successfully completed, you can view your app in the address provided in the extension's progress window by clicking the 'Browse Website' button that appears when the GitHub action has run.\n\nRender\n​\n\nYou can deploy your Vite app as a Static Site on Render.\n\nCreate a Render account.\n\nIn the Dashboard, click the New button and select Static Site.\n\nConnect your GitHub/GitLab account or use a public repository.\n\nSpecify a project name and branch.\n\nBuild Command: npm run build\nPublish Directory: dist\n\nClick Create Static Site.\n\nYour app should be deployed at https://<PROJECTNAME>.onrender.com/.\n\nBy default, any new commit pushed to the specified branch will automatically trigger a new deployment. Auto-Deploy can be configured in the project settings.\n\nYou can also add a custom domain to your project.\n\nFlightcontrol\n​\n\nDeploy your static site using Flightcontrol, by following these instructions\n\nAWS Amplify Hosting\n​\n\nDeploy your static site using AWS Amplify Hosting, by following these instructions\n\nKinsta Static Site Hosting\n​\n\nYou can deploy your Vite app as a Static Site on Kinsta by following these instructions."
  },
  {
    "title": "Static Asset Handling | Vite",
    "url": "https://vitejs.dev/guide/assets",
    "html": "Static Asset Handling\n​\nRelated: Public Base Path\nRelated: assetsInclude config option\nImporting Asset as URL\n​\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n\nFor example, imgUrl will be /img.png during development, and become /assets/img.2d8efhg.png in the production build.\n\nThe behavior is similar to webpack's file-loader. The difference is that the import can be either using absolute public paths (based on project root during dev) or relative paths.\n\nurl() references in CSS are handled the same way.\n\nIf using the Vue plugin, asset references in Vue SFC templates are automatically converted into imports.\n\nCommon image, media, and font filetypes are detected as assets automatically. You can extend the internal list using the assetsInclude option.\n\nReferenced assets are included as part of the build assets graph, will get hashed file names, and can be processed by plugins for optimization.\n\nAssets smaller in bytes than the assetsInlineLimit option will be inlined as base64 data URLs.\n\nGit LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent. To get inlining, make sure to download the file contents via Git LFS before building.\n\nTypeScript, by default, does not recognize static asset imports as valid modules. To fix this, include vite/client.\n\nExplicit URL Imports\n​\n\nAssets that are not included in the internal list or in assetsInclude, can be explicitly imported as a URL using the ?url suffix. This is useful, for example, to import Houdini Paint Worklets.\n\njs\nimport workletURL from 'extra-scalloped-border/worklet.js?url'\nCSS.paintWorklet.addModule(workletURL)\nImporting Asset as String\n​\n\nAssets can be imported as strings using the ?raw suffix.\n\njs\nimport shaderString from './shader.glsl?raw'\nImporting Script as a Worker\n​\n\nScripts can be imported as web workers with the ?worker or ?sharedworker suffix.\n\njs\n// Separate chunk in the production build\nimport Worker from './shader.js?worker'\nconst worker = new Worker()\njs\n// sharedworker\nimport SharedWorker from './shader.js?sharedworker'\nconst sharedWorker = new SharedWorker()\njs\n// Inlined as base64 strings\nimport InlineWorker from './shader.js?worker&inline'\n\nCheck out the Web Worker section for more details.\n\nThe public Directory\n​\n\nIf you have assets that are:\n\nNever referenced in source code (e.g. robots.txt)\nMust retain the exact same file name (without hashing)\n...or you simply don't want to have to import an asset first just to get its URL\n\nThen you can place the asset in a special public directory under your project root. Assets in this directory will be served at root path / during dev, and copied to the root of the dist directory as-is.\n\nThe directory defaults to <root>/public, but can be configured via the publicDir option.\n\nNote that:\n\nYou should always reference public assets using root absolute path - for example, public/icon.png should be referenced in source code as /icon.png.\nAssets in public cannot be imported from JavaScript.\nnew URL(url, import.meta.url)\n​\n\nimport.meta.url is a native ESM feature that exposes the current module's URL. Combining it with the native URL constructor, we can obtain the full, resolved URL of a static asset using relative path from a JavaScript module:\n\njs\nconst imgUrl = new URL('./img.png', import.meta.url).href\n\ndocument.getElementById('hero-img').src = imgUrl\n\nThis works natively in modern browsers - in fact, Vite doesn't need to process this code at all during development!\n\nThis pattern also supports dynamic URLs via template literals:\n\njs\nfunction getImageUrl(name) {\n  return new URL(`./dir/${name}.png`, import.meta.url).href\n}\n\nDuring the production build, Vite will perform necessary transforms so that the URLs still point to the correct location even after bundling and asset hashing. However, the URL string must be static so it can be analyzed, otherwise the code will be left as is, which can cause runtime errors if build.target does not support import.meta.url\n\njs\n// Vite will not transform this\nconst imgUrl = new URL(imagePath, import.meta.url).href\n\nDoes not work with SSR\n\nThis pattern does not work if you are using Vite for Server-Side Rendering, because import.meta.url have different semantics in browsers vs. Node.js. The server bundle also cannot determine the client host URL ahead of time."
  },
  {
    "title": "Building for Production | Vite",
    "url": "https://vitejs.dev/guide/build",
    "html": "Building for Production\n​\n\nWhen it is time to deploy your app for production, simply run the vite build command. By default, it uses <root>/index.html as the build entry point, and produces an application bundle that is suitable to be served over a static hosting service. Check out the Deploying a Static Site for guides about popular services.\n\nBrowser Compatibility\n​\n\nThe production bundle assumes support for modern JavaScript. By default, Vite targets browsers which support the native ES Modules, native ESM dynamic import, and import.meta:\n\nChrome >=87\nFirefox >=78\nSafari >=14\nEdge >=88\n\nYou can specify custom targets via the build.target config option, where the lowest target is es2015.\n\nNote that by default, Vite only handles syntax transforms and does not cover polyfills. You can check out Polyfill.io which is a service that automatically generates polyfill bundles based on the user's browser UserAgent string.\n\nLegacy browsers can be supported via @vitejs/plugin-legacy, which will automatically generate legacy chunks and corresponding ES language feature polyfills. The legacy chunks are conditionally loaded only in browsers that do not have native ESM support.\n\nPublic Base Path\n​\nRelated: Asset Handling\n\nIf you are deploying your project under a nested public path, simply specify the base config option and all asset paths will be rewritten accordingly. This option can also be specified as a command line flag, e.g. vite build --base=/my/public/path/.\n\nJS-imported asset URLs, CSS url() references, and asset references in your .html files are all automatically adjusted to respect this option during build.\n\nThe exception is when you need to dynamically concatenate URLs on the fly. In this case, you can use the globally injected import.meta.env.BASE_URL variable which will be the public base path. Note this variable is statically replaced during build so it must appear exactly as-is (i.e. import.meta.env['BASE_URL'] won't work).\n\nFor advanced base path control, check out Advanced Base Options.\n\nCustomizing the Build\n​\n\nThe build can be customized via various build config options. Specifically, you can directly adjust the underlying Rollup options via build.rollupOptions:\n\njs\n// vite.config.js\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      // https://rollupjs.org/configuration-options/\n    },\n  },\n})\n\nFor example, you can specify multiple Rollup outputs with plugins that are only applied during build.\n\nChunking Strategy\n​\n\nYou can configure how chunks are split using build.rollupOptions.output.manualChunks (see Rollup docs). Until Vite 2.8, the default chunking strategy divided the chunks into index and vendor. It is a good strategy for some SPAs, but it is hard to provide a general solution for every Vite target use case. From Vite 2.9, manualChunks is no longer modified by default. You can continue to use the Split Vendor Chunk strategy by adding the splitVendorChunkPlugin in your config file:\n\njs\n// vite.config.js\nimport { splitVendorChunkPlugin } from 'vite'\nexport default defineConfig({\n  plugins: [splitVendorChunkPlugin()],\n})\n\nThis strategy is also provided as a splitVendorChunk({ cache: SplitVendorChunkCache }) factory, in case composition with custom logic is needed. cache.reset() needs to be called at buildStart for build watch mode to work correctly in this case.\n\nWARNING\n\nYou should use build.rollupOptions.output.manualChunks function form when using this plugin. If the object form is used, the plugin won't have any effect.\n\nRebuild on files changes\n​\n\nYou can enable rollup watcher with vite build --watch. Or, you can directly adjust the underlying WatcherOptions via build.watch:\n\njs\n// vite.config.js\nexport default defineConfig({\n  build: {\n    watch: {\n      // https://rollupjs.org/configuration-options/#watch\n    },\n  },\n})\n\nWith the --watch flag enabled, changes to the vite.config.js, as well as any files to be bundled, will trigger a rebuild.\n\nMulti-Page App\n​\n\nSuppose you have the following source code structure:\n\n├── package.json\n├── vite.config.js\n├── index.html\n├── main.js\n└── nested\n    ├── index.html\n    └── nested.js\n\nDuring dev, simply navigate or link to /nested/ - it works as expected, just like for a normal static file server.\n\nDuring build, all you need to do is to specify multiple .html files as entry points:\n\njs\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    rollupOptions: {\n      input: {\n        main: resolve(__dirname, 'index.html'),\n        nested: resolve(__dirname, 'nested/index.html'),\n      },\n    },\n  },\n})\n\nIf you specify a different root, remember that __dirname will still be the folder of your vite.config.js file when resolving the input paths. Therefore, you will need to add your root entry to the arguments for resolve.\n\nNote that for HTML files, Vite ignores the name given to the entry in the rollupOptions.input object and instead respects the resolved id of the file when generating the HTML asset in the dist folder. This ensures a consistent structure with the way the dev server works.\n\nLibrary Mode\n​\n\nWhen you are developing a browser-oriented library, you are likely spending most of the time on a test/demo page that imports your actual library. With Vite, you can use your index.html for that purpose to get the smooth development experience.\n\nWhen it is time to bundle your library for distribution, use the build.lib config option. Make sure to also externalize any dependencies that you do not want to bundle into your library, e.g. vue or react:\n\njs\n// vite.config.js\nimport { resolve } from 'path'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  build: {\n    lib: {\n      // Could also be a dictionary or array of multiple entry points\n      entry: resolve(__dirname, 'lib/main.js'),\n      name: 'MyLib',\n      // the proper extensions will be added\n      fileName: 'my-lib',\n    },\n    rollupOptions: {\n      // make sure to externalize deps that shouldn't be bundled\n      // into your library\n      external: ['vue'],\n      output: {\n        // Provide global variables to use in the UMD build\n        // for externalized deps\n        globals: {\n          vue: 'Vue',\n        },\n      },\n    },\n  },\n})\n\nThe entry file would contain exports that can be imported by users of your package:\n\njs\n// lib/main.js\nimport Foo from './Foo.vue'\nimport Bar from './Bar.vue'\nexport { Foo, Bar }\n\nRunning vite build with this config uses a Rollup preset that is oriented towards shipping libraries and produces two bundle formats: es and umd (configurable via build.lib):\n\n$ vite build\nbuilding for production...\ndist/my-lib.js      0.08 kB / gzip: 0.07 kB\ndist/my-lib.umd.cjs 0.30 kB / gzip: 0.16 kB\n\nRecommended package.json for your lib:\n\njson\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.umd.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.umd.cjs\"\n    }\n  }\n}\n\nOr, if exposing multiple entry points:\n\njson\n{\n  \"name\": \"my-lib\",\n  \"type\": \"module\",\n  \"files\": [\"dist\"],\n  \"main\": \"./dist/my-lib.cjs\",\n  \"module\": \"./dist/my-lib.js\",\n  \"exports\": {\n    \".\": {\n      \"import\": \"./dist/my-lib.js\",\n      \"require\": \"./dist/my-lib.cjs\"\n    },\n    \"./secondary\": {\n      \"import\": \"./dist/secondary.js\",\n      \"require\": \"./dist/secondary.cjs\"\n    }\n  }\n}\n\nFile Extensions\n\nIf the package.json does not contain \"type\": \"module\", Vite will generate different file extensions for Node.js compatibility. .js will become .mjs and .cjs will become .js.\n\nEnvironment Variables\n\nIn library mode, all import.meta.env.* usage are statically replaced when building for production. However, process.env.* usage are not, so that consumers of your library can dynamically change it. If this is undesirable, you can use define: { 'process.env.NODE_ENV': '\"production\"' } for example to statically replace them, or use esm-env for better compatibility with bundlers and runtimes.\n\nAdvanced Usage\n\nLibrary mode includes a simple and opinionated configuration for browser-oriented and JS framework libraries. If you are building non-browser libraries, or require advanced build flows, you can use Rollup or esbuild directly.\n\nAdvanced Base Options\n​\n\nWARNING\n\nThis feature is experimental. Give Feedback.\n\nFor advanced use cases, the deployed assets and public files may be in different paths, for example to use different cache strategies. A user may choose to deploy in three different paths:\n\nThe generated entry HTML files (which may be processed during SSR)\nThe generated hashed assets (JS, CSS, and other file types like images)\nThe copied public files\n\nA single static base isn't enough in these scenarios. Vite provides experimental support for advanced base options during build, using experimental.renderBuiltUrl.\n\nts\nexperimental: {\n  renderBuiltUrl(filename: string, { hostType }: { hostType: 'js' | 'css' | 'html' }) {\n    if (hostType === 'js') {\n      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }\n    } else {\n      return { relative: true }\n    }\n  }\n}\n\nIf the hashed assets and public files aren't deployed together, options for each group can be defined independently using asset type included in the second context param given to the function.\n\nts\nexperimental: {\n  renderBuiltUrl(filename: string, { hostId, hostType, type }: { hostId: string, hostType: 'js' | 'css' | 'html', type: 'public' | 'asset' }) {\n    if (type === 'public') {\n      return 'https://www.domain.com/' + filename\n    }\n    else if (path.extname(hostId) === '.js') {\n      return { runtime: `window.__assetsPath(${JSON.stringify(filename)})` }\n    }\n    else {\n      return 'https://cdn.domain.com/assets/' + filename\n    }\n  }\n}"
  },
  {
    "title": "Using Plugins | Vite",
    "url": "https://vitejs.dev/guide/using-plugins",
    "html": "Using Plugins\n​\n\nVite can be extended using plugins, which are based on Rollup's well-designed plugin interface with a few extra Vite-specific options. This means that Vite users can rely on the mature ecosystem of Rollup plugins, while also being able to extend the dev server and SSR functionality as needed.\n\nAdding a Plugin\n​\n\nTo use a plugin, it needs to be added to the devDependencies of the project and included in the plugins array in the vite.config.js config file. For example, to provide support for legacy browsers, the official @vitejs/plugin-legacy can be used:\n\n$ npm add -D @vitejs/plugin-legacy\njs\n// vite.config.js\nimport legacy from '@vitejs/plugin-legacy'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    legacy({\n      targets: ['defaults', 'not IE 11'],\n    }),\n  ],\n})\n\nplugins also accepts presets including several plugins as a single element. This is useful for complex features (like framework integration) that are implemented using several plugins. The array will be flattened internally.\n\nFalsy plugins will be ignored, which can be used to easily activate or deactivate plugins.\n\nFinding Plugins\n​\n\nNOTE\n\nVite aims to provide out-of-the-box support for common web development patterns. Before searching for a Vite or compatible Rollup plugin, check out the Features Guide. A lot of the cases where a plugin would be needed in a Rollup project are already covered in Vite.\n\nCheck out the Plugins section for information about official plugins. Community plugins are listed in awesome-vite. For compatible Rollup plugins, check out Vite Rollup Plugins for a list of compatible official Rollup plugins with usage instructions or the Rollup Plugin Compatibility section in case it is not listed there.\n\nYou can also find plugins that follow the recommended conventions using a npm search for vite-plugin for Vite plugins or a npm search for rollup-plugin for Rollup plugins.\n\nEnforcing Plugin Ordering\n​\n\nFor compatibility with some Rollup plugins, it may be needed to enforce the order of the plugin or only apply at build time. This should be an implementation detail for Vite plugins. You can enforce the position of a plugin with the enforce modifier:\n\npre: invoke plugin before Vite core plugins\ndefault: invoke plugin after Vite core plugins\npost: invoke plugin after Vite build plugins\njs\n// vite.config.js\nimport image from '@rollup/plugin-image'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...image(),\n      enforce: 'pre',\n    },\n  ],\n})\n\nCheck out Plugins API Guide for detailed information, and look out for the enforce label and usage instructions for popular plugins in the Vite Rollup Plugins compatibility listing.\n\nConditional Application\n​\n\nBy default, plugins are invoked for both serve and build. In cases where a plugin needs to be conditionally applied only during serve or build, use the apply property to only invoke them during 'build' or 'serve':\n\njs\n// vite.config.js\nimport typescript2 from 'rollup-plugin-typescript2'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    {\n      ...typescript2(),\n      apply: 'build',\n    },\n  ],\n})\nBuilding Plugins\n​\n\nCheck out the Plugins API Guide for documentation about creating plugins."
  },
  {
    "title": "Dependency Pre-Bundling | Vite",
    "url": "https://vitejs.dev/guide/dep-pre-bundling",
    "html": "Dependency Pre-Bundling\n​\n\nWhen you run vite for the first time, Vite prebundles your project dependencies before loading your site locally. It is done automatically and transparently by default.\n\nThe Why\n​\n\nThis is Vite performing what we call \"dependency pre-bundling\". This process serves two purposes:\n\nCommonJS and UMD compatibility: During development, Vite's dev serves all code as native ESM. Therefore, Vite must convert dependencies that are shipped as CommonJS or UMD into ESM first.\n\nWhen converting CommonJS dependencies, Vite performs smart import analysis so that named imports to CommonJS modules will work as expected even if the exports are dynamically assigned (e.g. React):\n\njs\n// works as expected\nimport React, { useState } from 'react'\n\nPerformance: Vite converts ESM dependencies with many internal modules into a single module to improve subsequent page load performance.\n\nSome packages ship their ES modules builds as many separate files importing one another. For example, lodash-es has over 600 internal modules! When we do import { debounce } from 'lodash-es', the browser fires off 600+ HTTP requests at the same time! Even though the server has no problem handling them, the large amount of requests create a network congestion on the browser side, causing the page to load noticeably slower.\n\nBy pre-bundling lodash-es into a single module, we now only need one HTTP request instead!\n\nNOTE\n\nDependency pre-bundling only applies in development mode, and uses esbuild to convert dependencies to ESM. In production builds, @rollup/plugin-commonjs is used instead.\n\nAutomatic Dependency Discovery\n​\n\nIf an existing cache is not found, Vite will crawl your source code and automatically discover dependency imports (i.e. \"bare imports\" that expect to be resolved from node_modules) and use these found imports as entry points for the pre-bundle. The pre-bundling is performed with esbuild so it's typically very fast.\n\nAfter the server has already started, if a new dependency import is encountered that isn't already in the cache, Vite will re-run the dep bundling process and reload the page if needed.\n\nMonorepos and Linked Dependencies\n​\n\nIn a monorepo setup, a dependency may be a linked package from the same repo. Vite automatically detects dependencies that are not resolved from node_modules and treats the linked dep as source code. It will not attempt to bundle the linked dep, and will analyze the linked dep's dependency list instead.\n\nHowever, this requires the linked dep to be exported as ESM. If not, you can add the dependency to optimizeDeps.include and build.commonjsOptions.include in your config.\n\njs\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['linked-dep'],\n  },\n  build: {\n    commonjsOptions: {\n      include: [/linked-dep/, /node_modules/],\n    },\n  },\n})\n\nWhen making changes to the linked dep, restart the dev server with the --force command line option for the changes to take effect.\n\nCustomizing the Behavior\n​\n\nThe default dependency discovery heuristics may not always be desirable. In cases where you want to explicitly include/exclude dependencies from the list, use the optimizeDeps config options.\n\nA typical use case for optimizeDeps.include or optimizeDeps.exclude is when you have an import that is not directly discoverable in the source code. For example, maybe the import is created as a result of a plugin transform. This means Vite won't be able to discover the import on the initial scan - it can only discover it after the file is requested by the browser and transformed. This will cause the server to immediately re-bundle after server start.\n\nBoth include and exclude can be used to deal with this. If the dependency is large (with many internal modules) or is CommonJS, then you should include it; If the dependency is small and is already valid ESM, you can exclude it and let the browser load it directly.\n\nYou can further customize esbuild too with the optimizeDeps.esbuildOptions option. For example, adding an esbuild plugin to handle special files in dependencies or changing the build target.\n\nCaching\n​\nFile System Cache\n​\n\nVite caches the pre-bundled dependencies in node_modules/.vite. It determines whether it needs to re-run the pre-bundling step based on a few sources:\n\nPackage manager lockfile content, e.g. package-lock.json, yarn.lock, pnpm-lock.yaml or bun.lockb.\nPatches folder modification time.\nRelevant fields in your vite.config.js, if present.\nNODE_ENV value.\n\nThe pre-bundling step will only need to be re-run when one of the above has changed.\n\nIf for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the --force command line option, or manually delete the node_modules/.vite cache directory.\n\nBrowser Cache\n​\n\nResolved dependency requests are strongly cached with HTTP headers max-age=31536000,immutable to improve page reload performance during dev. Once cached, these requests will never hit the dev server again. They are auto invalidated by the appended version query if a different version is installed (as reflected in your package manager lockfile). If you want to debug your dependencies by making local edits, you can:\n\nTemporarily disable cache via the Network tab of your browser devtools;\nRestart Vite dev server with the --force flag to re-bundle the deps;\nReload the page."
  },
  {
    "title": "Command Line Interface | Vite",
    "url": "https://vitejs.dev/guide/cli",
    "html": "Command Line Interface\n​\nDev server\n​\nvite\n​\n\nStart Vite dev server in the current directory.\n\nUsage\n​\nbash\nvite [root]\nOptions\n​\nOptions\t\n--host [host]\tSpecify hostname (string)\n--port <port>\tSpecify port (number)\n--open [path]\tOpen browser on startup (boolean | string)\n--cors\tEnable CORS (boolean)\n--strictPort\tExit if specified port is already in use (boolean)\n--force\tForce the optimizer to ignore the cache and re-bundle (boolean)\n-c, --config <file>\tUse specified config file (string)\n--base <path>\tPublic base path (default: /) (string)\n-l, --logLevel <level>\tinfo | warn | error | silent (string)\n--clearScreen\tAllow/disable clear screen when logging (boolean)\n--profile\tStart built-in Node.js inspector (check Performance bottlenecks)\n-d, --debug [feat]\tShow debug logs (string | boolean)\n-f, --filter <filter>\tFilter debug logs (string)\n-m, --mode <mode>\tSet env mode (string)\n-h, --help\tDisplay available CLI options\n-v, --version\tDisplay version number\nBuild\n​\nvite build\n​\n\nBuild for production.\n\nUsage\n​\nbash\nvite build [root]\nOptions\n​\nOptions\t\n--target <target>\tTranspile target (default: \"modules\") (string)\n--outDir <dir>\tOutput directory (default: dist) (string)\n--assetsDir <dir>\tDirectory under outDir to place assets in (default: \"assets\") (string)\n--assetsInlineLimit <number>\tStatic asset base64 inline threshold in bytes (default: 4096) (number)\n--ssr [entry]\tBuild specified entry for server-side rendering (string)\n--sourcemap [output]\tOutput source maps for build (default: false) (boolean | \"inline\" | \"hidden\")\n--minify [minifier]\tEnable/disable minification, or specify minifier to use (default: \"esbuild\") (boolean | \"terser\" | \"esbuild\")\n--manifest [name]\tEmit build manifest json (boolean | string)\n--ssrManifest [name]\tEmit ssr manifest json (boolean | string)\n--force\tForce the optimizer to ignore the cache and re-bundle (experimental)(boolean)\n--emptyOutDir\tForce empty outDir when it's outside of root (boolean)\n-w, --watch\tRebuilds when modules have changed on disk (boolean)\n-c, --config <file>\tUse specified config file (string)\n--base <path>\tPublic base path (default: /) (string)\n-l, --logLevel <level>\tInfo | warn | error | silent (string)\n--clearScreen\tAllow/disable clear screen when logging (boolean)\n--profile\tStart built-in Node.js inspector (check Performance bottlenecks)\n-d, --debug [feat]\tShow debug logs (string | boolean)\n-f, --filter <filter>\tFilter debug logs (string)\n-m, --mode <mode>\tSet env mode (string)\n-h, --help\tDisplay available CLI options\nOthers\n​\nvite optimize\n​\n\nPre-bundle dependencies.\n\nUsage\n​\nbash\nvite optimize [root]\nOptions\n​\nOptions\t\n--force\tForce the optimizer to ignore the cache and re-bundle (boolean)\n-c, --config <file>\tUse specified config file (string)\n--base <path>\tPublic base path (default: /) (string)\n-l, --logLevel <level>\tInfo | warn | error | silent (string)\n--clearScreen\tAllow/disable clear screen when logging (boolean)\n-d, --debug [feat]\tShow debug logs (string | boolean)\n-f, --filter <filter>\tFilter debug logs (string)\n-m, --mode <mode>\tSet env mode (string)\n-h, --help\tDisplay available CLI options\nvite preview\n​\n\nLocally preview the production build. Do not use this as a production server as it's not designed for it.\n\nUsage\n​\nbash\nvite preview [root]\nOptions\n​\nOptions\t\n--host [host]\tSpecify hostname (string)\n--port <port>\tSpecify port (number)\n--strictPort\tExit if specified port is already in use (boolean)\n--open [path]\tOpen browser on startup (boolean | string)\n--outDir <dir>\tOutput directory (default: dist)(string)\n-c, --config <file>\tUse specified config file (string)\n--base <path>\tPublic base path (default: /) (string)\n-l, --logLevel <level>\tInfo | warn | error | silent (string)\n--clearScreen\tAllow/disable clear screen when logging (boolean)\n-d, --debug [feat]\tShow debug logs (string | boolean)\n-f, --filter <filter>\tFilter debug logs (string)\n-m, --mode <mode>\tSet env mode (string)\n-h, --help\tDisplay available CLI options"
  },
  {
    "title": "Features | Vite",
    "url": "https://vitejs.dev/guide/features",
    "html": "Features\n​\n\nAt the very basic level, developing using Vite is not that much different from using a static file server. However, Vite provides many enhancements over native ESM imports to support various features that are typically seen in bundler-based setups.\n\nNPM Dependency Resolving and Pre-Bundling\n​\n\nNative ES imports do not support bare module imports like the following:\n\njs\nimport { someMethod } from 'my-dep'\n\nThe above will throw an error in the browser. Vite will detect such bare module imports in all served source files and perform the following:\n\nPre-bundle them to improve page loading speed and convert CommonJS / UMD modules to ESM. The pre-bundling step is performed with esbuild and makes Vite's cold start time significantly faster than any JavaScript-based bundler.\n\nRewrite the imports to valid URLs like /node_modules/.vite/deps/my-dep.js?v=f3sf2ebd so that the browser can import them properly.\n\nDependencies are Strongly Cached\n\nVite caches dependency requests via HTTP headers, so if you wish to locally edit/debug a dependency, follow the steps here.\n\nHot Module Replacement\n​\n\nVite provides an HMR API over native ESM. Frameworks with HMR capabilities can leverage the API to provide instant, precise updates without reloading the page or blowing away application state. Vite provides first-party HMR integrations for Vue Single File Components and React Fast Refresh. There are also official integrations for Preact via @prefresh/vite.\n\nNote you don't need to manually set these up - when you create an app via create-vite, the selected templates would have these pre-configured for you already.\n\nTypeScript\n​\n\nVite supports importing .ts files out of the box.\n\nTranspile Only\n​\n\nNote that Vite only performs transpilation on .ts files and does NOT perform type checking. It assumes type checking is taken care of by your IDE and build process.\n\nThe reason Vite does not perform type checking as part of the transform process is because the two jobs work fundamentally differently. Transpilation can work on a per-file basis and aligns perfectly with Vite's on-demand compile model. In comparison, type checking requires knowledge of the entire module graph. Shoe-horning type checking into Vite's transform pipeline will inevitably compromise Vite's speed benefits.\n\nVite's job is to get your source modules into a form that can run in the browser as fast as possible. To that end, we recommend separating static analysis checks from Vite's transform pipeline. This principle applies to other static analysis checks such as ESLint.\n\nFor production builds, you can run tsc --noEmit in addition to Vite's build command.\n\nDuring development, if you need more than IDE hints, we recommend running tsc --noEmit --watch in a separate process, or use vite-plugin-checker if you prefer having type errors directly reported in the browser.\n\nVite uses esbuild to transpile TypeScript into JavaScript which is about 20~30x faster than vanilla tsc, and HMR updates can reflect in the browser in under 50ms.\n\nUse the Type-Only Imports and Export syntax to avoid potential problems like type-only imports being incorrectly bundled, for example:\n\nts\nimport type { T } from 'only/types'\nexport type { T }\nTypeScript Compiler Options\n​\n\nSome configuration fields under compilerOptions in tsconfig.json require special attention.\n\nisolatedModules\n​\nTypeScript documentation\n\nShould be set to true.\n\nIt is because esbuild only performs transpilation without type information, it doesn't support certain features like const enum and implicit type-only imports.\n\nYou must set \"isolatedModules\": true in your tsconfig.json under compilerOptions, so that TS will warn you against the features that do not work with isolated transpilation.\n\nHowever, some libraries (e.g. vue) don't work well with \"isolatedModules\": true. You can use \"skipLibCheck\": true to temporarily suppress the errors until it is fixed upstream.\n\nuseDefineForClassFields\n​\nTypeScript documentation\n\nStarting from Vite 2.5.0, the default value will be true if the TypeScript target is ESNext or ES2022 or newer. It is consistent with the behavior of tsc 4.3.2 and later. It is also the standard ECMAScript runtime behavior.\n\nOther TypeScript targets will default to false.\n\nBut it may be counter-intuitive for those coming from other programming languages or older versions of TypeScript. You can read more about the transition in the TypeScript 3.7 release notes.\n\nIf you are using a library that heavily relies on class fields, please be careful about the library's intended usage of it.\n\nMost libraries expect \"useDefineForClassFields\": true, such as MobX.\n\nBut a few libraries haven't transitioned to this new default yet, including lit-element. Please explicitly set useDefineForClassFields to false in these cases.\n\ntarget\n​\nTypeScript documentation\n\nVite does not transpile TypeScript with the configured target value by default, following the same behaviour as esbuild.\n\nThe esbuild.target option can be used instead, which defaults to esnext for minimal transpilation. In builds, the build.target option takes higher priority and can also be set if needed.\n\nuseDefineForClassFields\n\nIf target is not ESNext or ES2022 or newer, or if there's no tsconfig.json file, useDefineForClassFields will default to false which can be problematic with the default esbuild.target value of esnext. It may transpile to static initialization blocks which may not be supported in your browser.\n\nAs such, it is recommended to set target to ESNext or ES2022 or newer, or set useDefineForClassFields to true explicitly when configuring tsconfig.json.\n\nOther Compiler Options Affecting the Build Result\n​\nextends\nimportsNotUsedAsValues\npreserveValueImports\nverbatimModuleSyntax\njsx\njsxFactory\njsxFragmentFactory\njsxImportSource\nexperimentalDecorators\nalwaysStrict\n\nskipLibCheck\n\nVite starter templates have \"skipLibCheck\": \"true\" by default to avoid typechecking dependencies, as they may choose to only support specific versions and configurations of TypeScript. You can learn more at vuejs/vue-cli#5688.\n\nClient Types\n​\n\nVite's default types are for its Node.js API. To shim the environment of client side code in a Vite application, add a d.ts declaration file:\n\ntypescript\n/// <reference types=\"vite/client\" />\n\nAlternatively, you can add vite/client to compilerOptions.types inside tsconfig.json:\n\njson\n{\n  \"compilerOptions\": {\n    \"types\": [\"vite/client\"]\n  }\n}\n\nThis will provide the following type shims:\n\nAsset imports (e.g. importing an .svg file)\nTypes for the Vite-injected env variables on import.meta.env\nTypes for the HMR API on import.meta.hot\n\nTIP\n\nTo override the default typing, add a type definition file that contains your typings. Then, add the type reference before vite/client.\n\nFor example, to make the default import of *.svg a React component:\n\nvite-env-override.d.ts (the file that contains your typings):\nts\ndeclare module '*.svg' {\n  const content: React.FC<React.SVGProps<SVGElement>>\n  export default content\n}\nThe file containing the reference to vite/client:\nts\n/// <reference types=\"./vite-env-override.d.ts\" />\n/// <reference types=\"vite/client\" />\nVue\n​\n\nVite provides first-class Vue support:\n\nVue 3 SFC support via @vitejs/plugin-vue\nVue 3 JSX support via @vitejs/plugin-vue-jsx\nVue 2.7 SFC support via @vitejs/plugin-vue2\nVue 2.7 JSX support via @vitejs/plugin-vue2-jsx\nJSX\n​\n\n.jsx and .tsx files are also supported out of the box. JSX transpilation is also handled via esbuild.\n\nVue users should use the official @vitejs/plugin-vue-jsx plugin, which provides Vue 3 specific features including HMR, global component resolving, directives and slots.\n\nIf not using JSX with React or Vue, custom jsxFactory and jsxFragment can be configured using the esbuild option. For example for Preact:\n\njs\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n\nMore details in esbuild docs.\n\nYou can inject the JSX helpers using jsxInject (which is a Vite-only option) to avoid manual imports:\n\njs\n// vite.config.js\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\nCSS\n​\n\nImporting .css files will inject its content to the page via a <style> tag with HMR support.\n\n@import Inlining and Rebasing\n​\n\nVite is pre-configured to support CSS @import inlining via postcss-import. Vite aliases are also respected for CSS @import. In addition, all CSS url() references, even if the imported files are in different directories, are always automatically rebased to ensure correctness.\n\n@import aliases and URL rebasing are also supported for Sass and Less files (see CSS Pre-processors).\n\nPostCSS\n​\n\nIf the project contains valid PostCSS config (any format supported by postcss-load-config, e.g. postcss.config.js), it will be automatically applied to all imported CSS.\n\nNote that CSS minification will run after PostCSS and will use build.cssTarget option.\n\nCSS Modules\n​\n\nAny CSS file ending with .module.css is considered a CSS modules file. Importing such a file will return the corresponding module object:\n\ncss\n/* example.module.css */\n.red {\n  color: red;\n}\njs\nimport classes from './example.module.css'\ndocument.getElementById('foo').className = classes.red\n\nCSS modules behavior can be configured via the css.modules option.\n\nIf css.modules.localsConvention is set to enable camelCase locals (e.g. localsConvention: 'camelCaseOnly'), you can also use named imports:\n\njs\n// .apply-color -> applyColor\nimport { applyColor } from './example.module.css'\ndocument.getElementById('foo').className = applyColor\nCSS Pre-processors\n​\n\nBecause Vite targets modern browsers only, it is recommended to use native CSS variables with PostCSS plugins that implement CSSWG drafts (e.g. postcss-nesting) and author plain, future-standards-compliant CSS.\n\nThat said, Vite does provide built-in support for .scss, .sass, .less, .styl and .stylus files. There is no need to install Vite-specific plugins for them, but the corresponding pre-processor itself must be installed:\n\nbash\n# .scss and .sass\nnpm add -D sass\n\n# .less\nnpm add -D less\n\n# .styl and .stylus\nnpm add -D stylus\n\nIf using Vue single file components, this also automatically enables <style lang=\"sass\"> et al.\n\nVite improves @import resolving for Sass and Less so that Vite aliases are also respected. In addition, relative url() references inside imported Sass/Less files that are in different directories from the root file are also automatically rebased to ensure correctness.\n\n@import alias and url rebasing are not supported for Stylus due to its API constraints.\n\nYou can also use CSS modules combined with pre-processors by prepending .module to the file extension, for example style.module.scss.\n\nDisabling CSS injection into the page\n​\n\nThe automatic injection of CSS contents can be turned off via the ?inline query parameter. In this case, the processed CSS string is returned as the module's default export as usual, but the styles aren't injected to the page.\n\njs\nimport './foo.css' // will be injected into the page\nimport otherStyles from './bar.css?inline' // will not be injected\n\nNOTE\n\nDefault and named imports from CSS files (e.g import style from './foo.css') are removed since Vite 5. Use the ?inline query instead.\n\nLightning CSS\n​\n\nStarting from Vite 4.4, there is experimental support for Lightning CSS. You can opt into it by adding css.transformer: 'lightningcss' to your config file and install the optional lightningcss dependency:\n\nbash\nnpm add -D lightningcss\n\nIf enabled, CSS files will be processed by Lightning CSS instead of PostCSS. To configure it, you can pass Lightning CSS options to the css.lightingcss config option.\n\nTo configure CSS Modules, you'll use css.lightningcss.cssModules instead of css.modules (which configures the way PostCSS handles CSS modules).\n\nBy default, Vite uses esbuild to minify CSS. Lightning CSS can also be used as the CSS minifier with build.cssMinify: 'lightningcss'.\n\nNOTE\n\nCSS Pre-processors aren't supported when using Lightning CSS.\n\nStatic Assets\n​\n\nImporting a static asset will return the resolved public URL when it is served:\n\njs\nimport imgUrl from './img.png'\ndocument.getElementById('hero-img').src = imgUrl\n\nSpecial queries can modify how assets are loaded:\n\njs\n// Explicitly load assets as URL\nimport assetAsURL from './asset.js?url'\njs\n// Load assets as strings\nimport assetAsString from './shader.glsl?raw'\njs\n// Load Web Workers\nimport Worker from './worker.js?worker'\njs\n// Web Workers inlined as base64 strings at build time\nimport InlineWorker from './worker.js?worker&inline'\n\nMore details in Static Asset Handling.\n\nJSON\n​\n\nJSON files can be directly imported - named imports are also supported:\n\njs\n// import the entire object\nimport json from './example.json'\n// import a root field as named exports - helps with tree-shaking!\nimport { field } from './example.json'\nGlob Import\n​\n\nVite supports importing multiple modules from the file system via the special import.meta.glob function:\n\njs\nconst modules = import.meta.glob('./dir/*.js')\n\nThe above will be transformed into the following:\n\njs\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n  './dir/bar.js': () => import('./dir/bar.js'),\n}\n\nYou can then iterate over the keys of the modules object to access the corresponding modules:\n\njs\nfor (const path in modules) {\n  modules[path]().then((mod) => {\n    console.log(path, mod)\n  })\n}\n\nMatched files are by default lazy-loaded via dynamic import and will be split into separate chunks during build. If you'd rather import all the modules directly (e.g. relying on side-effects in these modules to be applied first), you can pass { eager: true } as the second argument:\n\njs\nconst modules = import.meta.glob('./dir/*.js', { eager: true })\n\nThe above will be transformed into the following:\n\njs\n// code produced by vite\nimport * as __glob__0_0 from './dir/foo.js'\nimport * as __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\nGlob Import As\n​\n\nimport.meta.glob also supports importing files as strings (similar to Importing Asset as String) with the Import Reflection syntax:\n\njs\nconst modules = import.meta.glob('./dir/*.js', { as: 'raw', eager: true })\n\nThe above will be transformed into the following:\n\njs\n// code produced by vite\nconst modules = {\n  './dir/foo.js': 'export default \"foo\"\\n',\n  './dir/bar.js': 'export default \"bar\"\\n',\n}\n\n{ as: 'url' } is also supported for loading assets as URLs.\n\nMultiple Patterns\n​\n\nThe first argument can be an array of globs, for example\n\njs\nconst modules = import.meta.glob(['./dir/*.js', './another/*.js'])\nNegative Patterns\n​\n\nNegative glob patterns are also supported (prefixed with !). To ignore some files from the result, you can add exclude glob patterns to the first argument:\n\njs\nconst modules = import.meta.glob(['./dir/*.js', '!**/bar.js'])\njs\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js'),\n}\nNamed Imports\n​\n\nIt's possible to only import parts of the modules with the import options.\n\nts\nconst modules = import.meta.glob('./dir/*.js', { import: 'setup' })\nts\n// code produced by vite\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js').then((m) => m.setup),\n  './dir/bar.js': () => import('./dir/bar.js').then((m) => m.setup),\n}\n\nWhen combined with eager it's even possible to have tree-shaking enabled for those modules.\n\nts\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'setup',\n  eager: true,\n})\nts\n// code produced by vite:\nimport { setup as __glob__0_0 } from './dir/foo.js'\nimport { setup as __glob__0_1 } from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\n\nSet import to default to import the default export.\n\nts\nconst modules = import.meta.glob('./dir/*.js', {\n  import: 'default',\n  eager: true,\n})\nts\n// code produced by vite:\nimport __glob__0_0 from './dir/foo.js'\nimport __glob__0_1 from './dir/bar.js'\nconst modules = {\n  './dir/foo.js': __glob__0_0,\n  './dir/bar.js': __glob__0_1,\n}\nCustom Queries\n​\n\nYou can also use the query option to provide custom queries to imports for other plugins to consume.\n\nts\nconst modules = import.meta.glob('./dir/*.js', {\n  query: { foo: 'bar', bar: true },\n})\nts\n// code produced by vite:\nconst modules = {\n  './dir/foo.js': () => import('./dir/foo.js?foo=bar&bar=true'),\n  './dir/bar.js': () => import('./dir/bar.js?foo=bar&bar=true'),\n}\nGlob Import Caveats\n​\n\nNote that:\n\nThis is a Vite-only feature and is not a web or ES standard.\nThe glob patterns are treated like import specifiers: they must be either relative (start with ./) or absolute (start with /, resolved relative to project root) or an alias path (see resolve.alias option).\nThe glob matching is done via fast-glob - check out its documentation for supported glob patterns.\nYou should also be aware that all the arguments in the import.meta.glob must be passed as literals. You can NOT use variables or expressions in them.\nDynamic Import\n​\n\nSimilar to glob import, Vite also supports dynamic import with variables.\n\nts\nconst module = await import(`./dir/${file}.js`)\n\nNote that variables only represent file names one level deep. If file is 'foo/bar', the import would fail. For more advanced usage, you can use the glob import feature.\n\nWebAssembly\n​\n\nPre-compiled .wasm files can be imported with ?init. The default export will be an initialization function that returns a Promise of the WebAssembly.Instance:\n\njs\nimport init from './example.wasm?init'\n\ninit().then((instance) => {\n  instance.exports.test()\n})\n\nThe init function can also take an importObject which is passed along to WebAssembly.instantiate as its second argument:\n\njs\ninit({\n  imports: {\n    someFunc: () => {\n      /* ... */\n    },\n  },\n}).then(() => {\n  /* ... */\n})\n\nIn the production build, .wasm files smaller than assetInlineLimit will be inlined as base64 strings. Otherwise, they will be treated as a static asset and fetched on-demand.\n\nNOTE\n\nES Module Integration Proposal for WebAssembly is not currently supported. Use vite-plugin-wasm or other community plugins to handle this.\n\nAccessing the WebAssembly Module\n​\n\nIf you need access to the Module object, e.g. to instantiate it multiple times, use an explicit URL import to resolve the asset, and then perform the instantiation:\n\njs\nimport wasmUrl from 'foo.wasm?url'\n\nconst main = async () => {\n  const responsePromise = fetch(wasmUrl)\n  const { module, instance } =\n    await WebAssembly.instantiateStreaming(responsePromise)\n  /* ... */\n}\n\nmain()\nFetching the module in Node.js\n​\n\nIn SSR, the fetch() happening as part of the ?init import, may fail with TypeError: Invalid URL. See the issue Support wasm in SSR.\n\nHere is an alternative, assuming the project base is the current directory:\n\njs\nimport wasmUrl from 'foo.wasm?url'\nimport { readFile } from 'node:fs/promises'\n\nconst main = async () => {\n  const resolvedUrl = (await import('./test/boot.test.wasm?url')).default\n  const buffer = await readFile('.' + resolvedUrl)\n  const { instance } = await WebAssembly.instantiate(buffer, {\n    /* ... */\n  })\n  /* ... */\n}\n\nmain()\nWeb Workers\n​\nImport with Constructors\n​\n\nA web worker script can be imported using new Worker() and new SharedWorker(). Compared to the worker suffixes, this syntax leans closer to the standards and is the recommended way to create workers.\n\nts\nconst worker = new Worker(new URL('./worker.js', import.meta.url))\n\nThe worker constructor also accepts options, which can be used to create \"module\" workers:\n\nts\nconst worker = new Worker(new URL('./worker.js', import.meta.url), {\n  type: 'module',\n})\nImport with Query Suffixes\n​\n\nA web worker script can be directly imported by appending ?worker or ?sharedworker to the import request. The default export will be a custom worker constructor:\n\njs\nimport MyWorker from './worker?worker'\n\nconst worker = new MyWorker()\n\nThe worker script can also use ESM import statements instead of importScripts(). Note: During dev this relies on browser native support, but for the production build it is compiled away.\n\nBy default, the worker script will be emitted as a separate chunk in the production build. If you wish to inline the worker as base64 strings, add the inline query:\n\njs\nimport MyWorker from './worker?worker&inline'\n\nIf you wish to retrieve the worker as a URL, add the url query:\n\njs\nimport MyWorker from './worker?worker&url'\n\nSee Worker Options for details on configuring the bundling of all workers.\n\nBuild Optimizations\n​\n\nFeatures listed below are automatically applied as part of the build process and there is no need for explicit configuration unless you want to disable them.\n\nCSS Code Splitting\n​\n\nVite automatically extracts the CSS used by modules in an async chunk and generates a separate file for it. The CSS file is automatically loaded via a <link> tag when the associated async chunk is loaded, and the async chunk is guaranteed to only be evaluated after the CSS is loaded to avoid FOUC.\n\nIf you'd rather have all the CSS extracted into a single file, you can disable CSS code splitting by setting build.cssCodeSplit to false.\n\nPreload Directives Generation\n​\n\nVite automatically generates <link rel=\"modulepreload\"> directives for entry chunks and their direct imports in the built HTML.\n\nAsync Chunk Loading Optimization\n​\n\nIn real world applications, Rollup often generates \"common\" chunks - code that is shared between two or more other chunks. Combined with dynamic imports, it is quite common to have the following scenario:\n\nEntry\nasync chunk A\ncommon chunk C\nasync chunk B\ndynamic import\ndirect import\n\nIn the non-optimized scenarios, when async chunk A is imported, the browser will have to request and parse A before it can figure out that it also needs the common chunk C. This results in an extra network roundtrip:\n\nEntry ---> A ---> C\n\nVite automatically rewrites code-split dynamic import calls with a preload step so that when A is requested, C is fetched in parallel:\n\nEntry ---> (A + C)\n\nIt is possible for C to have further imports, which will result in even more roundtrips in the un-optimized scenario. Vite's optimization will trace all the direct imports to completely eliminate the roundtrips regardless of import depth."
  },
  {
    "title": "Getting Started | Vite",
    "url": "https://vitejs.dev/guide/",
    "html": "Getting Started\n​\nOverview\n​\n\nVite (French word for \"quick\", pronounced /vit/\n, like \"veet\") is a build tool that aims to provide a faster and leaner development experience for modern web projects. It consists of two major parts:\n\nA dev server that provides rich feature enhancements over native ES modules, for example extremely fast Hot Module Replacement (HMR).\n\nA build command that bundles your code with Rollup, pre-configured to output highly optimized static assets for production.\n\nVite is opinionated and comes with sensible defaults out of the box. Read about what's possible in the Features Guide. Support for frameworks or integration with other tools is possible through Plugins. The Config Section explains how to adapt Vite to your project if needed.\n\nVite is also highly extensible via its Plugin API and JavaScript API with full typing support.\n\nYou can learn more about the rationale behind the project in the Why Vite section.\n\nBrowser Support\n​\n\nDuring development, Vite sets esnext as the transform target, because we assume a modern browser is used and it supports all of the latest JavaScript and CSS features. This prevents syntax lowering, letting Vite serve modules as close as possible to the original source code.\n\nFor the production build, by default Vite targets browsers that support native ES Modules, native ESM dynamic import, and import.meta. Legacy browsers can be supported via the official @vitejs/plugin-legacy. See the Building for Production section for more details.\n\nTrying Vite Online\n​\n\nYou can try Vite online on StackBlitz. It runs the Vite-based build setup directly in the browser, so it is almost identical to the local setup but doesn't require installing anything on your machine. You can navigate to vite.new/{template} to select which framework to use.\n\nThe supported template presets are:\n\nJavaScript\tTypeScript\nvanilla\tvanilla-ts\nvue\tvue-ts\nreact\treact-ts\npreact\tpreact-ts\nlit\tlit-ts\nsvelte\tsvelte-ts\nsolid\tsolid-ts\nqwik\tqwik-ts\nScaffolding Your First Vite Project\n​\n\nCompatibility Note\n\nVite requires Node.js version 18+. 20+. However, some templates require a higher Node.js version to work, please upgrade if your package manager warns about it.\n\nNPM\nYarn\nPNPM\nBun\nbash\n$ npm create vite@latest\n\nThen follow the prompts!\n\nYou can also directly specify the project name and the template you want to use via additional command line options. For example, to scaffold a Vite + Vue project, run:\n\nbash\n# npm 7+, extra double-dash is needed:\nnpm create vite@latest my-vue-app -- --template vue\n\n# yarn\nyarn create vite my-vue-app --template vue\n\n# pnpm\npnpm create vite my-vue-app --template vue\n\n# bun\nbunx create-vite my-vue-app --template vue\n\nSee create-vite for more details on each supported template: vanilla, vanilla-ts, vue, vue-ts, react, react-ts, react-swc, react-swc-ts, preact, preact-ts, lit, lit-ts, svelte, svelte-ts, solid, solid-ts, qwik, qwik-ts.\n\nCommunity Templates\n​\n\ncreate-vite is a tool to quickly start a project from a basic template for popular frameworks. Check out Awesome Vite for community maintained templates that include other tools or target different frameworks. You can use a tool like degit to scaffold your project with one of the templates.\n\nbash\nnpx degit user/project my-project\ncd my-project\n\nnpm install\nnpm run dev\n\nIf the project uses main as the default branch, suffix the project repo with #main\n\nbash\nnpx degit user/project#main my-project\nindex.html and Project Root\n​\n\nOne thing you may have noticed is that in a Vite project, index.html is front-and-central instead of being tucked away inside public. This is intentional: during development Vite is a server, and index.html is the entry point to your application.\n\nVite treats index.html as source code and part of the module graph. It resolves <script type=\"module\" src=\"...\"> that references your JavaScript source code. Even inline <script type=\"module\"> and CSS referenced via <link href> also enjoy Vite-specific features. In addition, URLs inside index.html are automatically rebased so there's no need for special %PUBLIC_URL% placeholders.\n\nSimilar to static http servers, Vite has the concept of a \"root directory\" which your files are served from. You will see it referenced as <root> throughout the rest of the docs. Absolute URLs in your source code will be resolved using the project root as base, so you can write code as if you are working with a normal static file server (except way more powerful!). Vite is also capable of handling dependencies that resolve to out-of-root file system locations, which makes it usable even in a monorepo-based setup.\n\nVite also supports multi-page apps with multiple .html entry points.\n\nSpecifying Alternative Root\n​\n\nRunning vite starts the dev server using the current working directory as root. You can specify an alternative root with vite serve some/sub/dir. Note that Vite will also resolve its config file (i.e. vite.config.js) inside the project root, so you'll need to move it if the root is changed.\n\nCommand Line Interface\n​\n\nIn a project where Vite is installed, you can use the vite binary in your npm scripts, or run it directly with npx vite. Here are the default npm scripts in a scaffolded Vite project:\n\njson\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // start dev server, aliases: `vite dev`, `vite serve`\n    \"build\": \"vite build\", // build for production\n    \"preview\": \"vite preview\" // locally preview production build\n  }\n}\n\nYou can specify additional CLI options like --port or --open. For a full list of CLI options, run npx vite --help in your project.\n\nLearn more about the Command Line Interface\n\nUsing Unreleased Commits\n​\n\nIf you can't wait for a new release to test the latest features, you will need to clone the vite repo to your local machine and then build and link it yourself (pnpm is required):\n\nbash\ngit clone https://github.com/vitejs/vite.git\ncd vite\npnpm install\ncd packages/vite\npnpm run build\npnpm link --global # use your preferred package manager for this step\n\nThen go to your Vite based project and run pnpm link --global vite (or the package manager that you used to link vite globally). Now restart the development server to ride on the bleeding edge!\n\nCommunity\n​\n\nIf you have questions or need help, reach out to the community at Discord and GitHub Discussions."
  },
  {
    "title": "Why Vite | Vite",
    "url": "https://vitejs.dev/guide/why",
    "html": "Why Vite\n​\nThe Problems\n​\n\nBefore ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of \"bundling\": using tools that crawl, process and concatenate our source modules into files that can run in the browser.\n\nOver time we have seen tools like webpack, Rollup and Parcel, which greatly improved the development experience for frontend developers.\n\nHowever, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.\n\nVite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.\n\nSlow Server Start\n​\n\nWhen cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.\n\nVite improves the dev server start time by first dividing the modules in an application into two categories: dependencies and source code.\n\nDependencies are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).\n\nVite pre-bundles dependencies using esbuild. esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.\n\nSource code often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).\n\nVite serves source code over native ESM. This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.\n\nBundle based dev server\nentry\n···\nroute\nroute\nmodule\nmodule\nmodule\nmodule\n···\nBundle\nServer ready\nNative ESM based dev server\nentry\n···\nroute\nroute\nmodule\nmodule\nmodule\nmodule\n···\nServer ready\nDynamic import (code split point)\nHTTP request\nSlow Updates\n​\n\nWhen a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.\n\nIn some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to \"hot replace\" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.\n\nIn Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.\n\nVite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via 304 Not Modified, and dependency module requests are strongly cached via Cache-Control: max-age=31536000,immutable so they don't hit the server again once cached.\n\nOnce you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.\n\nWhy Bundle for Production\n​\n\nEven though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).\n\nEnsuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured build command that bakes in many performance optimizations out of the box.\n\nWhy Not Bundle with esbuild?\n​\n\nVite's current plugin API isn't compatible with using esbuild as a bundler. In spite of esbuild being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.\n\nRollup has also been working on performance improvements, switching its parser to SWC in v4. And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch Evan You's ViteConf 2023 keynote for more details.\n\nHow is Vite Different from X?\n​\n\nYou can check out the Comparisons section for more details on how Vite differs from other similar tools."
  },
  {
    "title": "Why Vite | Vite",
    "url": "https://vitejs.dev/guide/why.html",
    "html": "Why Vite\n​\nThe Problems\n​\n\nBefore ES modules were available in browsers, developers had no native mechanism for authoring JavaScript in a modularized fashion. This is why we are all familiar with the concept of \"bundling\": using tools that crawl, process and concatenate our source modules into files that can run in the browser.\n\nOver time we have seen tools like webpack, Rollup and Parcel, which greatly improved the development experience for frontend developers.\n\nHowever, as we build more and more ambitious applications, the amount of JavaScript we are dealing with is also increasing dramatically. It is not uncommon for large scale projects to contain thousands of modules. We are starting to hit a performance bottleneck for JavaScript based tooling: it can often take an unreasonably long wait (sometimes up to minutes!) to spin up a dev server, and even with Hot Module Replacement (HMR), file edits can take a couple of seconds to be reflected in the browser. The slow feedback loop can greatly affect developers' productivity and happiness.\n\nVite aims to address these issues by leveraging new advancements in the ecosystem: the availability of native ES modules in the browser, and the rise of JavaScript tools written in compile-to-native languages.\n\nSlow Server Start\n​\n\nWhen cold-starting the dev server, a bundler-based build setup has to eagerly crawl and build your entire application before it can be served.\n\nVite improves the dev server start time by first dividing the modules in an application into two categories: dependencies and source code.\n\nDependencies are mostly plain JavaScript that do not change often during development. Some large dependencies (e.g. component libraries with hundreds of modules) are also quite expensive to process. Dependencies may also be shipped in various module formats (e.g. ESM or CommonJS).\n\nVite pre-bundles dependencies using esbuild. esbuild is written in Go and pre-bundles dependencies 10-100x faster than JavaScript-based bundlers.\n\nSource code often contains non-plain JavaScript that needs transforming (e.g. JSX, CSS or Vue/Svelte components), and will be edited very often. Also, not all source code needs to be loaded at the same time (e.g. with route-based code-splitting).\n\nVite serves source code over native ESM. This is essentially letting the browser take over part of the job of a bundler: Vite only needs to transform and serve source code on demand, as the browser requests it. Code behind conditional dynamic imports is only processed if actually used on the current screen.\n\nBundle based dev server\nentry\n···\nroute\nroute\nmodule\nmodule\nmodule\nmodule\n···\nBundle\nServer ready\nNative ESM based dev server\nentry\n···\nroute\nroute\nmodule\nmodule\nmodule\nmodule\n···\nServer ready\nDynamic import (code split point)\nHTTP request\nSlow Updates\n​\n\nWhen a file is edited in a bundler-based build setup, it is inefficient to rebuild the whole bundle for an obvious reason: the update speed will degrade linearly with the size of the app.\n\nIn some bundlers, the dev server runs the bundling in memory so that it only needs to invalidate part of its module graph when a file changes, but it still needs to re-construct the entire bundle and reload the web page. Reconstructing the bundle can be expensive, and reloading the page blows away the current state of the application. This is why some bundlers support Hot Module Replacement (HMR): allowing a module to \"hot replace\" itself without affecting the rest of the page. This greatly improves DX - however, in practice we've found that even HMR update speed deteriorates significantly as the size of the application grows.\n\nIn Vite, HMR is performed over native ESM. When a file is edited, Vite only needs to precisely invalidate the chain between the edited module and its closest HMR boundary (most of the time only the module itself), making HMR updates consistently fast regardless of the size of your application.\n\nVite also leverages HTTP headers to speed up full page reloads (again, let the browser do more work for us): source code module requests are made conditional via 304 Not Modified, and dependency module requests are strongly cached via Cache-Control: max-age=31536000,immutable so they don't hit the server again once cached.\n\nOnce you experience how fast Vite is, we highly doubt you'd be willing to put up with bundled development again.\n\nWhy Bundle for Production\n​\n\nEven though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).\n\nEnsuring optimal output and behavioral consistency between the dev server and the production build isn't easy. This is why Vite ships with a pre-configured build command that bakes in many performance optimizations out of the box.\n\nWhy Not Bundle with esbuild?\n​\n\nVite's current plugin API isn't compatible with using esbuild as a bundler. In spite of esbuild being faster, Vite's adoption of Rollup's flexible plugin API and infrastructure heavily contributed to its success in the ecosystem. For the time being, we believe that Rollup offers a better performance-vs-flexibility tradeoff.\n\nRollup has also been working on performance improvements, switching its parser to SWC in v4. And there is an ongoing effort to build a Rust-port of Rollup called Rolldown. Once Rolldown is ready, it could replace both Rollup and esbuild in Vite, improving build performance significantly and removing inconsistencies between development and build. You can watch Evan You's ViteConf 2023 keynote for more details.\n\nHow is Vite Different from X?\n​\n\nYou can check out the Comparisons section for more details on how Vite differs from other similar tools."
  },
  {
    "title": "Worker Options | Vite",
    "url": "https://vitejs.dev/config/worker-options",
    "html": "Worker Options\n​\n\nOptions related to Web Workers.\n\nworker.format\n​\nType: 'es' | 'iife'\nDefault: 'iife'\n\nOutput format for worker bundle.\n\nworker.plugins\n​\nType: () => (Plugin | Plugin[])[]\n\nVite plugins that apply to the worker bundles. Note that config.plugins only applies to workers in dev, it should be configured here instead for build. The function should return new plugin instances as they are used in parallel rollup worker builds. As such, modifying config.worker options in the config hook will be ignored.\n\nworker.rollupOptions\n​\nType: RollupOptions\n\nRollup options to build worker bundle."
  },
  {
    "title": "SSR Options | Vite",
    "url": "https://vitejs.dev/config/ssr-options",
    "html": "SSR Options\n​\nssr.external\n​\nType: string[]\nRelated: SSR Externals\n\nForce externalize dependencies for SSR.\n\nssr.noExternal\n​\nType: string | RegExp | (string | RegExp)[] | true\nRelated: SSR Externals\n\nPrevent listed dependencies from being externalized for SSR. If true, no dependencies are externalized.\n\nssr.target\n​\nType: 'node' | 'webworker'\nDefault: node\n\nBuild target for the SSR server.\n\nssr.resolve.conditions\n​\nType: string[]\nRelated: Resolve Conditions\n\nDefaults to the the root resolve.conditions.\n\nThese conditions are used in the plugin pipeline, and only affect non-externalized dependencies during the SSR build. Use ssr.resolve.externalConditions to affect externalized imports.\n\nssr.resolve.externalConditions\n​\nType: string[]\nDefault: []\n\nConditions that are used during ssr import (including ssrLoadModule) of externalized dependencies."
  },
  {
    "title": "Dep Optimization Options | Vite",
    "url": "https://vitejs.dev/config/dep-optimization-options",
    "html": "Dep Optimization Options\n​\nRelated: Dependency Pre-Bundling\noptimizeDeps.entries\n​\nType: string | string[]\n\nBy default, Vite will crawl all your .html files to detect dependencies that need to be pre-bundled (ignoring node_modules, build.outDir, __tests__ and coverage). If build.rollupOptions.input is specified, Vite will crawl those entry points instead.\n\nIf neither of these fit your needs, you can specify custom entries using this option - the value should be a fast-glob pattern or array of patterns that are relative from Vite project root. This will overwrite default entries inference. Only node_modules and build.outDir folders will be ignored by default when optimizeDeps.entries is explicitly defined. If other folders need to be ignored, you can use an ignore pattern as part of the entries list, marked with an initial !.\n\noptimizeDeps.exclude\n​\nType: string[]\n\nDependencies to exclude from pre-bundling.\n\nCommonJS\n\nCommonJS dependencies should not be excluded from optimization. If an ESM dependency is excluded from optimization, but has a nested CommonJS dependency, the CommonJS dependency should be added to optimizeDeps.include. Example:\n\njs\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['esm-dep > cjs-dep'],\n  },\n})\noptimizeDeps.include\n​\nType: string[]\n\nBy default, linked packages not inside node_modules are not pre-bundled. Use this option to force a linked package to be pre-bundled.\n\nExperimental: If you're using a library with many deep imports, you can also specify a trailing glob pattern to pre-bundle all deep imports at once. This will avoid constantly pre-bundling whenever a new deep import is used. For example:\n\njs\nexport default defineConfig({\n  optimizeDeps: {\n    include: ['my-lib/components/**/*.vue'],\n  },\n})\noptimizeDeps.esbuildOptions\n​\nType: EsbuildBuildOptions\n\nOptions to pass to esbuild during the dep scanning and optimization.\n\nCertain options are omitted since changing them would not be compatible with Vite's dep optimization.\n\nexternal is also omitted, use Vite's optimizeDeps.exclude option\nplugins are merged with Vite's dep plugin\noptimizeDeps.force\n​\nType: boolean\n\nSet to true to force dependency pre-bundling, ignoring previously cached optimized dependencies.\n\noptimizeDeps.disabled\n​\nExperimental: Give Feedback\nType: boolean | 'build' | 'dev'\nDefault: 'build'\n\nDisables dependencies optimizations, true disables the optimizer during build and dev. Pass 'build' or 'dev' to only disable the optimizer in one of the modes. Dependency optimization is enabled by default in dev only.\n\nWARNING\n\nOptimizing dependencies in build mode is experimental. If enabled, it removes one of the most significant differences between dev and prod. @rollup/plugin-commonjs is no longer needed in this case since esbuild converts CJS-only dependencies to ESM.\n\nIf you want to try this build strategy, you can use optimizeDeps.disabled: false. @rollup/plugin-commonjs can be removed by passing build.commonjsOptions: { include: [] }.\n\noptimizeDeps.needsInterop\n​\nExperimental\nType: string[]\n\nForces ESM interop when importing these dependencies. Vite is able to properly detect when a dependency needs interop, so this option isn't generally needed. However, different combinations of dependencies could cause some of them to be prebundled differently. Adding these packages to needsInterop can speed up cold start by avoiding full-page reloads. You'll receive a warning if this is the case for one of your dependencies, suggesting to add the package name to this array in your config."
  },
  {
    "title": "Preview Options | Vite",
    "url": "https://vitejs.dev/config/preview-options",
    "html": "Preview Options\n​\npreview.host\n​\nType: string | boolean\nDefault: server.host\n\nSpecify which IP addresses the server should listen on. Set this to 0.0.0.0 or true to listen on all addresses, including LAN and public addresses.\n\nThis can be set via the CLI using --host 0.0.0.0 or --host.\n\nNOTE\n\nThere are cases when other servers might respond instead of Vite. See server.host for more details.\n\npreview.port\n​\nType: number\nDefault: 4173\n\nSpecify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.\n\nExample:\n\njs\nexport default defineConfig({\n  server: {\n    port: 3030,\n  },\n  preview: {\n    port: 8080,\n  },\n})\npreview.strictPort\n​\nType: boolean\nDefault: server.strictPort\n\nSet to true to exit if port is already in use, instead of automatically trying the next available port.\n\npreview.https\n​\nType: boolean | https.ServerOptions\nDefault: server.https\n\nEnable TLS + HTTP/2. Note this downgrades to TLS only when the server.proxy option is also used.\n\nThe value can also be an options object passed to https.createServer().\n\npreview.open\n​\nType: boolean | string\nDefault: server.open\n\nAutomatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env process.env.BROWSER (e.g. firefox). You can also set process.env.BROWSER_ARGS to pass additional arguments (e.g. --incognito).\n\nBROWSER and BROWSER_ARGS are also special environment variables you can set in the .env file to configure it. See the open package for more details.\n\npreview.proxy\n​\nType: Record<string, string | ProxyOptions>\nDefault: server.proxy\n\nConfigure custom proxy rules for the preview server. Expects an object of { key: options } pairs. If the key starts with ^, it will be interpreted as a RegExp. The configure option can be used to access the proxy instance.\n\nUses http-proxy. Full options here.\n\npreview.cors\n​\nType: boolean | CorsOptions\nDefault: server.cors\n\nConfigure CORS for the preview server. This is enabled by default and allows any origin. Pass an options object to fine tune the behavior or false to disable.\n\npreview.headers\n​\nType: OutgoingHttpHeaders\n\nSpecify server response headers."
  },
  {
    "title": "Build Options | Vite",
    "url": "https://vitejs.dev/config/build-options",
    "html": "Build Options\n​\nbuild.target\n​\nType: string | string[]\nDefault: 'modules'\nRelated: Browser Compatibility\n\nBrowser compatibility target for the final bundle. The default value is a Vite special value, 'modules', which targets browsers with native ES Modules, native ESM dynamic import, and import.meta support. Vite will replace 'modules' to ['es2020', 'edge88', 'firefox78', 'chrome87', 'safari14']\n\nAnother special value is 'esnext' - which assumes native dynamic imports support and will transpile as little as possible:\n\nIf the build.minify option is 'terser' and the installed Terser version is below 5.16.0, 'esnext' will be forced down to 'es2021'.\nIn other cases, it will perform no transpilation at all.\n\nThe transform is performed with esbuild and the value should be a valid esbuild target option. Custom targets can either be an ES version (e.g. es2015), a browser with version (e.g. chrome58), or an array of multiple target strings.\n\nNote the build will fail if the code contains features that cannot be safely transpiled by esbuild. See esbuild docs for more details.\n\nbuild.modulePreload\n​\nType: boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }\nDefault: { polyfill: true }\n\nBy default, a module preload polyfill is automatically injected. The polyfill is auto injected into the proxy module of each index.html entry. If the build is configured to use a non-HTML custom entry via build.rollupOptions.input, then it is necessary to manually import the polyfill in your custom entry:\n\njs\nimport 'vite/modulepreload-polyfill'\n\nNote: the polyfill does not apply to Library Mode. If you need to support browsers without native dynamic import, you should probably avoid using it in your library.\n\nThe polyfill can be disabled using { polyfill: false }.\n\nThe list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the base will be used when loading these dependencies. If the base is relative ('' or './'), import.meta.url is used at runtime to avoid absolute paths that depend on the final deployed base.\n\nThere is experimental support for fine grained control over the dependencies list and their paths using the resolveDependencies function. Give Feedback. It expects a function of type ResolveModulePreloadDependenciesFn:\n\nts\ntype ResolveModulePreloadDependenciesFn = (\n  url: string,\n  deps: string[],\n  context: {\n    importer: string\n  },\n) => string[]\n\nThe resolveDependencies function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The deps paths are relative to the build.outDir. Returning a relative path to the hostId for hostType === 'js' is allowed, in which case new URL(dep, import.meta.url) is used to get an absolute path when injecting this module preload in the HTML head.\n\njs\nmodulePreload: {\n  resolveDependencies: (filename, deps, { hostId, hostType }) => {\n    return deps.filter(condition)\n  }\n}\n\nThe resolved dependency paths can be further modified using experimental.renderBuiltUrl.\n\nbuild.polyfillModulePreload\n​\nType: boolean\nDefault: true\nDeprecated use build.modulePreload.polyfill instead\n\nWhether to automatically inject a module preload polyfill.\n\nbuild.outDir\n​\nType: string\nDefault: dist\n\nSpecify the output directory (relative to project root).\n\nbuild.assetsDir\n​\nType: string\nDefault: assets\n\nSpecify the directory to nest generated assets under (relative to build.outDir. This is not used in Library Mode).\n\nbuild.assetsInlineLimit\n​\nType: number\nDefault: 4096 (4 KiB)\n\nImported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to 0 to disable inlining altogether.\n\nGit LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.\n\nNote\n\nIf you specify build.lib, build.assetsInlineLimit will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.\n\nbuild.cssCodeSplit\n​\nType: boolean\nDefault: true\n\nEnable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.\n\nIf disabled, all CSS in the entire project will be extracted into a single CSS file.\n\nNote\n\nIf you specify build.lib, build.cssCodeSplit will be false as default.\n\nbuild.cssTarget\n​\nType: string | string[]\nDefault: the same as build.target\n\nThis option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.\n\nIt should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the #RGBA hexadecimal color notation in CSS. In this case, you need to set build.cssTarget to chrome61 to prevent vite from transform rgba() colors into #RGBA hexadecimal notations.\n\nbuild.cssMinify\n​\nType: boolean | 'esbuild' | 'lightningcss'\nDefault: the same as build.minify\n\nThis option allows users to override CSS minification specifically instead of defaulting to build.minify, so you can configure minification for JS and CSS separately. Vite uses esbuild by default to minify CSS. Set the option to 'lightningcss' to use Lightning CSS instead. If selected, it can be configured using css.lightningcss.\n\nbuild.sourcemap\n​\nType: boolean | 'inline' | 'hidden'\nDefault: false\n\nGenerate production source maps. If true, a separate sourcemap file will be created. If 'inline', the sourcemap will be appended to the resulting output file as a data URI. 'hidden' works like true except that the corresponding sourcemap comments in the bundled files are suppressed.\n\nbuild.rollupOptions\n​\nType: RollupOptions\n\nDirectly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite's internal Rollup options. See Rollup options docs for more details.\n\nbuild.commonjsOptions\n​\nType: RollupCommonJSOptions\n\nOptions to pass on to @rollup/plugin-commonjs.\n\nbuild.dynamicImportVarsOptions\n​\nType: RollupDynamicImportVarsOptions\nRelated: Dynamic Import\n\nOptions to pass on to @rollup/plugin-dynamic-import-vars.\n\nbuild.lib\n​\nType: { entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: ('es' | 'cjs' | 'umd' | 'iife')[], fileName?: string | ((format: ModuleFormat, entryName: string) => string) }\nRelated: Library Mode\n\nBuild as a library. entry is required since the library cannot use HTML as entry. name is the exposed global variable and is required when formats includes 'umd' or 'iife'. Default formats are ['es', 'umd'], or ['es', 'cjs'], if multiple entries are used. fileName is the name of the package file output, default fileName is the name option of package.json, it can also be defined as function taking the format and entryAlias as arguments.\n\nbuild.manifest\n​\nType: boolean | string\nDefault: false\nRelated: Backend Integration\n\nWhen set to true, the build will also generate a .vite/manifest.json file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links. When the value is a string, it will be used as the manifest file name.\n\nbuild.ssrManifest\n​\nType: boolean | string\nDefault: false\nRelated: Server-Side Rendering\n\nWhen set to true, the build will also generate an SSR manifest for determining style links and asset preload directives in production. When the value is a string, it will be used as the manifest file name.\n\nbuild.ssr\n​\nType: boolean | string\nDefault: false\nRelated: Server-Side Rendering\n\nProduce SSR-oriented build. The value can be a string to directly specify the SSR entry, or true, which requires specifying the SSR entry via rollupOptions.input.\n\nbuild.ssrEmitAssets\n​\nType: boolean\nDefault: false\n\nDuring the SSR build, static assets aren't emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step.\n\nbuild.minify\n​\nType: boolean | 'terser' | 'esbuild'\nDefault: 'esbuild'\n\nSet to false to disable minification, or specify the minifier to use. The default is esbuild which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. Benchmarks\n\nNote the build.minify option does not minify whitespaces when using the 'es' format in lib mode, as it removes pure annotations and breaks tree-shaking.\n\nTerser must be installed when it is set to 'terser'.\n\nsh\nnpm add -D terser\nbuild.terserOptions\n​\nType: TerserOptions\n\nAdditional minify options to pass on to Terser.\n\nIn addition, you can also pass a maxWorkers: number option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.\n\nbuild.write\n​\nType: boolean\nDefault: true\n\nSet to false to disable writing the bundle to disk. This is mostly used in programmatic build() calls where further post processing of the bundle is needed before writing to disk.\n\nbuild.emptyOutDir\n​\nType: boolean\nDefault: true if outDir is inside root\n\nBy default, Vite will empty the outDir on build if it is inside project root. It will emit a warning if outDir is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as --emptyOutDir.\n\nbuild.copyPublicDir\n​\nType: boolean\nDefault: true\n\nBy default, Vite will copy files from the publicDir into the outDir on build. Set to false to disable this.\n\nbuild.reportCompressedSize\n​\nType: boolean\nDefault: true\n\nEnable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.\n\nbuild.chunkSizeWarningLimit\n​\nType: number\nDefault: 500\n\nLimit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the JavaScript size itself is related to the execution time.\n\nbuild.watch\n​\nType: WatcherOptions| null\nDefault: null\n\nSet to {} to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.\n\nUsing Vite on Windows Subsystem for Linux (WSL) 2\n\nThere are cases that file system watching does not work with WSL2. See server.watch for more details."
  },
  {
    "title": "Server Options | Vite",
    "url": "https://vitejs.dev/config/server-options",
    "html": "Server Options\n​\nserver.host\n​\nType: string | boolean\nDefault: 'localhost'\n\nSpecify which IP addresses the server should listen on. Set this to 0.0.0.0 or true to listen on all addresses, including LAN and public addresses.\n\nThis can be set via the CLI using --host 0.0.0.0 or --host.\n\nNOTE\n\nThere are cases when other servers might respond instead of Vite.\n\nThe first case is when localhost is used. Node.js under v17 reorders the result of DNS-resolved addresses by default. When accessing localhost, browsers use DNS to resolve the address and that address might differ from the address which Vite is listening to. Vite prints the resolved address when it differs.\n\nYou can set dns.setDefaultResultOrder('verbatim') to disable the reordering behavior. Vite will then print the address as localhost.\n\njs\n// vite.config.js\nimport { defineConfig } from 'vite'\nimport dns from 'dns'\n\ndns.setDefaultResultOrder('verbatim')\n\nexport default defineConfig({\n  // omit\n})\n\nThe second case is when wildcard hosts (e.g. 0.0.0.0) are used. This is because servers listening on non-wildcard hosts take priority over those listening on wildcard hosts.\n\nAccessing the server on WSL2 from your LAN\n\nWhen running Vite on WSL2, it is not sufficient to set host: true to access the server from your LAN. See the WSL document for more details.\n\nserver.port\n​\nType: number\nDefault: 5173\n\nSpecify server port. Note if the port is already being used, Vite will automatically try the next available port so this may not be the actual port the server ends up listening on.\n\nserver.strictPort\n​\nType: boolean\n\nSet to true to exit if port is already in use, instead of automatically trying the next available port.\n\nserver.https\n​\nType: https.ServerOptions\n\nEnable TLS + HTTP/2. Note this downgrades to TLS only when the server.proxy option is also used.\n\nThe value can also be an options object passed to https.createServer().\n\nA valid certificate is needed. For a basic setup, you can add @vitejs/plugin-basic-ssl to the project plugins, which will automatically create and cache a self-signed certificate. But we recommend creating your own certificates.\n\nserver.open\n​\nType: boolean | string\n\nAutomatically open the app in the browser on server start. When the value is a string, it will be used as the URL's pathname. If you want to open the server in a specific browser you like, you can set the env process.env.BROWSER (e.g. firefox). You can also set process.env.BROWSER_ARGS to pass additional arguments (e.g. --incognito).\n\nBROWSER and BROWSER_ARGS are also special environment variables you can set in the .env file to configure it. See the open package for more details.\n\nExample:\n\njs\nexport default defineConfig({\n  server: {\n    open: '/docs/index.html',\n  },\n})\nserver.proxy\n​\nType: Record<string, string | ProxyOptions>\n\nConfigure custom proxy rules for the dev server. Expects an object of { key: options } pairs. Any requests that request path starts with that key will be proxied to that specified target. If the key starts with ^, it will be interpreted as a RegExp. The configure option can be used to access the proxy instance.\n\nNote that if you are using non-relative base, you must prefix each key with that base.\n\nExtends http-proxy. Additional options are here.\n\nIn some cases, you might also want to configure the underlying dev server (e.g. to add custom middlewares to the internal connect app). In order to do that, you need to write your own plugin and use configureServer function.\n\nExample:\n\njs\nexport default defineConfig({\n  server: {\n    proxy: {\n      // string shorthand: http://localhost:5173/foo -> http://localhost:4567/foo\n      '/foo': 'http://localhost:4567',\n      // with options: http://localhost:5173/api/bar-> http://jsonplaceholder.typicode.com/bar\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/api/, ''),\n      },\n      // with RegEx: http://localhost:5173/fallback/ -> http://jsonplaceholder.typicode.com/\n      '^/fallback/.*': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        rewrite: (path) => path.replace(/^\\/fallback/, ''),\n      },\n      // Using the proxy instance\n      '/api': {\n        target: 'http://jsonplaceholder.typicode.com',\n        changeOrigin: true,\n        configure: (proxy, options) => {\n          // proxy will be an instance of 'http-proxy'\n        },\n      },\n      // Proxying websockets or socket.io: ws://localhost:5173/socket.io -> ws://localhost:5174/socket.io\n      '/socket.io': {\n        target: 'ws://localhost:5174',\n        ws: true,\n      },\n    },\n  },\n})\nserver.cors\n​\nType: boolean | CorsOptions\n\nConfigure CORS for the dev server. This is enabled by default and allows any origin. Pass an options object to fine tune the behavior or false to disable.\n\nserver.headers\n​\nType: OutgoingHttpHeaders\n\nSpecify server response headers.\n\nserver.hmr\n​\nType: boolean | { protocol?: string, host?: string, port?: number, path?: string, timeout?: number, overlay?: boolean, clientPort?: number, server?: Server }\n\nDisable or configure HMR connection (in cases where the HMR websocket must use a different address from the http server).\n\nSet server.hmr.overlay to false to disable the server error overlay.\n\nclientPort is an advanced option that overrides the port only on the client side, allowing you to serve the websocket on a different port than the client code looks for it on.\n\nWhen server.hmr.server is defined, Vite will process the HMR connection requests through the provided server. If not in middleware mode, Vite will attempt to process HMR connection requests through the existing server. This can be helpful when using self-signed certificates or when you want to expose Vite over a network on a single port.\n\nCheck out vite-setup-catalogue for some examples.\n\nNOTE\n\nWith the default configuration, reverse proxies in front of Vite are expected to support proxying WebSocket. If the Vite HMR client fails to connect WebSocket, the client will fall back to connecting the WebSocket directly to the Vite HMR server bypassing the reverse proxies:\n\nDirect websocket connection fallback. Check out https://vitejs.dev/config/server-options.html#server-hmr to remove the previous connection error.\n\nThe error that appears in the Browser when the fallback happens can be ignored. To avoid the error by directly bypassing reverse proxies, you could either:\n\nconfigure the reverse proxy to proxy WebSocket too\nset server.strictPort = true and set server.hmr.clientPort to the same value with server.port\nset server.hmr.port to a different value from server.port\nserver.warmup\n​\nType: { clientFiles?: string[], ssrFiles?: string[] }\nRelated: Warm Up Frequently Used Files\n\nWarm up files to transform and cache the results in advance. This improves the initial page load during server starts and prevents transform waterfalls.\n\nclientFiles are files that are used in the client only, while ssrFiles are files that are used in SSR only. They accept an array of file paths or fast-glob patterns relative to the root.\n\nMake sure to only add files that are frequently used to not overload the Vite dev server on startup.\n\njs\nexport default defineConfig({\n  server: {\n    warmup: {\n      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],\n      ssrFiles: ['./src/server/modules/*.js'],\n    },\n  },\n})\nserver.watch\n​\nType: object | null\n\nFile system watcher options to pass on to chokidar.\n\nThe Vite server watcher watches the root and skips the .git/ and node_modules/ directories by default. When updating a watched file, Vite will apply HMR and update the page only if needed.\n\nIf set to null, no files will be watched. server.watcher will provide a compatible event emitter, but calling add or unwatch will have no effect.\n\nWatching files in node_modules\n\nIt's currently not possible to watch files and packages in node_modules. For further progress and workarounds, you can follow issue #8619.\n\nUsing Vite on Windows Subsystem for Linux (WSL) 2\n\nWhen running Vite on WSL2, file system watching does not work when a file is edited by Windows applications (non-WSL2 process). This is due to a WSL2 limitation. This also applies to running on Docker with a WSL2 backend.\n\nTo fix it, you could either:\n\nRecommended: Use WSL2 applications to edit your files.\nIt is also recommended to move the project folder outside of a Windows filesystem. Accessing Windows filesystem from WSL2 is slow. Removing that overhead will improve performance.\nSet { usePolling: true }.\nNote that usePolling leads to high CPU utilization.\nserver.middlewareMode\n​\nType: boolean\nDefault: false\n\nCreate Vite server in middleware mode.\n\nRelated: appType, SSR - Setting Up the Dev Server\n\nExample:\n\njs\nimport express from 'express'\nimport { createServer as createViteServer } from 'vite'\n\nasync function createServer() {\n  const app = express()\n\n  // Create Vite server in middleware mode\n  const vite = await createViteServer({\n    server: { middlewareMode: true },\n    appType: 'custom', // don't include Vite's default HTML handling middlewares\n  })\n  // Use vite's connect instance as middleware\n  app.use((req, res, next) => {\n    vite.middlewares.handle(req, res, next)\n  })\n\n  app.use('*', async (req, res) => {\n    // Since `appType` is `'custom'`, should serve response here.\n    // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares to handle\n    // HTML requests and 404s so user middlewares should be added\n    // before Vite's middlewares to take effect instead\n  })\n}\n\ncreateServer()\nserver.fs.strict\n​\nType: boolean\nDefault: true (enabled by default since Vite 2.7)\n\nRestrict serving files outside of workspace root.\n\nserver.fs.allow\n​\nType: string[]\n\nRestrict files that could be served via /@fs/. When server.fs.strict is set to true, accessing files outside this directory list that aren't imported from an allowed file will result in a 403.\n\nBoth directories and files can be provided.\n\nVite will search for the root of the potential workspace and use it as default. A valid workspace met the following conditions, otherwise will fall back to the project root.\n\ncontains workspaces field in package.json\ncontains one of the following file\nlerna.json\npnpm-workspace.yaml\n\nAccepts a path to specify the custom workspace root. Could be a absolute path or a path relative to project root. For example:\n\njs\nexport default defineConfig({\n  server: {\n    fs: {\n      // Allow serving files from one level up to the project root\n      allow: ['..'],\n    },\n  },\n})\n\nWhen server.fs.allow is specified, the auto workspace root detection will be disabled. To extend the original behavior, a utility searchForWorkspaceRoot is exposed:\n\njs\nimport { defineConfig, searchForWorkspaceRoot } from 'vite'\n\nexport default defineConfig({\n  server: {\n    fs: {\n      allow: [\n        // search up for workspace root\n        searchForWorkspaceRoot(process.cwd()),\n        // your custom rules\n        '/path/to/custom/allow_directory',\n        '/path/to/custom/allow_file.demo',\n      ],\n    },\n  },\n})\nserver.fs.deny\n​\nType: string[]\nDefault: ['.env', '.env.*', '*.{crt,pem}']\n\nBlocklist for sensitive files being restricted to be served by Vite dev server. This will have higher priority than server.fs.allow. picomatch patterns are supported.\n\nserver.origin\n​\nType: string\n\nDefines the origin of the generated asset URLs during development.\n\njs\nexport default defineConfig({\n  server: {\n    origin: 'http://127.0.0.1:8080',\n  },\n})\nserver.sourcemapIgnoreList\n​\nType: false | (sourcePath: string, sourcemapPath: string) => boolean\nDefault: (sourcePath) => sourcePath.includes('node_modules')\n\nWhether or not to ignore source files in the server sourcemap, used to populate the x_google_ignoreList source map extension.\n\nserver.sourcemapIgnoreList is the equivalent of build.rollupOptions.output.sourcemapIgnoreList for the dev server. A difference between the two config options is that the rollup function is called with a relative path for sourcePath while server.sourcemapIgnoreList is called with an absolute path. During dev, most modules have the map and the source in the same folder, so the relative path for sourcePath is the file name itself. In these cases, absolute paths makes it convenient to be used instead.\n\nBy default, it excludes all paths containing node_modules. You can pass false to disable this behavior, or, for full control, a function that takes the source path and sourcemap path and returns whether to ignore the source path.\n\njs\nexport default defineConfig({\n  server: {\n    // This is the default value, and will add all files with node_modules\n    // in their paths to the ignore list.\n    sourcemapIgnoreList(sourcePath, sourcemapPath) {\n      return sourcePath.includes('node_modules')\n    }\n  }\n};\n\nNote\n\nserver.sourcemapIgnoreList and build.rollupOptions.output.sourcemapIgnoreList need to be set independently. server.sourcemapIgnoreList is a server only config and doesn't get its default value from the defined rollup options."
  },
  {
    "title": "Shared Options | Vite",
    "url": "https://vitejs.dev/config/shared-options",
    "html": "Shared Options\n​\nroot\n​\nType: string\nDefault: process.cwd()\n\nProject root directory (where index.html is located). Can be an absolute path, or a path relative to the current working directory.\n\nSee Project Root for more details.\n\nbase\n​\nType: string\nDefault: /\nRelated: server.origin\n\nBase public path when served in development or production. Valid values include:\n\nAbsolute URL pathname, e.g. /foo/\nFull URL, e.g. https://foo.com/ (The origin part won't be used in development)\nEmpty string or ./ (for embedded deployment)\n\nSee Public Base Path for more details.\n\nmode\n​\nType: string\nDefault: 'development' for serve, 'production' for build\n\nSpecifying this in config will override the default mode for both serve and build. This value can also be overridden via the command line --mode option.\n\nSee Env Variables and Modes for more details.\n\ndefine\n​\nType: Record<string, any>\n\nDefine global constant replacements. Entries will be defined as globals during dev and statically replaced during build.\n\nVite uses esbuild defines to perform replacements, so value expressions must be a string that contains a JSON-serializable value (null, boolean, number, string, array, or object) or a single identifier. For non-string values, Vite will automatically convert it to a string with JSON.stringify.\n\nExample:\n\njs\nexport default defineConfig({\n  define: {\n    __APP_VERSION__: JSON.stringify('v1.0.0'),\n    __API_URL__: 'window.__backend_api_url',\n  },\n})\n\nNOTE\n\nFor TypeScript users, make sure to add the type declarations in the env.d.ts or vite-env.d.ts file to get type checks and Intellisense.\n\nExample:\n\nts\n// vite-env.d.ts\ndeclare const __APP_VERSION__: string\nplugins\n​\nType: (Plugin | Plugin[] | Promise<Plugin | Plugin[]>)[]\n\nArray of plugins to use. Falsy plugins are ignored and arrays of plugins are flattened. If a promise is returned, it would be resolved before running. See Plugin API for more details on Vite plugins.\n\npublicDir\n​\nType: string | false\nDefault: \"public\"\n\nDirectory to serve as plain static assets. Files in this directory are served at / during dev and copied to the root of outDir during build, and are always served or copied as-is without transform. The value can be either an absolute file system path or a path relative to project root.\n\nDefining publicDir as false disables this feature.\n\nSee The public Directory for more details.\n\ncacheDir\n​\nType: string\nDefault: \"node_modules/.vite\"\n\nDirectory to save cache files. Files in this directory are pre-bundled deps or some other cache files generated by vite, which can improve the performance. You can use --force flag or manually delete the directory to regenerate the cache files. The value can be either an absolute file system path or a path relative to project root. Default to .vite when no package.json is detected.\n\nresolve.alias\n​\nType:Record<string, string> | Array<{ find: string | RegExp, replacement: string, customResolver?: ResolverFunction | ResolverObject }>\n\nWill be passed to @rollup/plugin-alias as its entries option. Can either be an object, or an array of { find, replacement, customResolver } pairs.\n\nWhen aliasing to file system paths, always use absolute paths. Relative alias values will be used as-is and will not be resolved into file system paths.\n\nMore advanced custom resolution can be achieved through plugins.\n\nUsing with SSR\n\nIf you have configured aliases for SSR externalized dependencies, you may want to alias the actual node_modules packages. Both Yarn and pnpm support aliasing via the npm: prefix.\n\nresolve.dedupe\n​\nType: string[]\n\nIf you have duplicated copies of the same dependency in your app (likely due to hoisting or linked packages in monorepos), use this option to force Vite to always resolve listed dependencies to the same copy (from project root).\n\nSSR + ESM\n\nFor SSR builds, deduplication does not work for ESM build outputs configured from build.rollupOptions.output. A workaround is to use CJS build outputs until ESM has better plugin support for module loading.\n\nresolve.conditions\n​\nType: string[]\n\nAdditional allowed conditions when resolving Conditional Exports from a package.\n\nA package with conditional exports may have the following exports field in its package.json:\n\njson\n{\n  \"exports\": {\n    \".\": {\n      \"import\": \"./index.mjs\",\n      \"require\": \"./index.js\"\n    }\n  }\n}\n\nHere, import and require are \"conditions\". Conditions can be nested and should be specified from most specific to least specific.\n\nVite has a list of \"allowed conditions\" and will match the first condition that is in the allowed list. The default allowed conditions are: import, module, browser, default, and production/development based on current mode. The resolve.conditions config option allows specifying additional allowed conditions.\n\nResolving subpath exports\n\nExport keys ending with \"/\" is deprecated by Node and may not work well. Please contact the package author to use * subpath patterns instead.\n\nresolve.mainFields\n​\nType: string[]\nDefault: ['browser', 'module', 'jsnext:main', 'jsnext']\n\nList of fields in package.json to try when resolving a package's entry point. Note this takes lower precedence than conditional exports resolved from the exports field: if an entry point is successfully resolved from exports, the main field will be ignored.\n\nresolve.extensions\n​\nType: string[]\nDefault: ['.mjs', '.js', '.mts', '.ts', '.jsx', '.tsx', '.json']\n\nList of file extensions to try for imports that omit extensions. Note it is NOT recommended to omit extensions for custom import types (e.g. .vue) since it can interfere with IDE and type support.\n\nresolve.preserveSymlinks\n​\nType: boolean\nDefault: false\n\nEnabling this setting causes vite to determine file identity by the original file path (i.e. the path without following symlinks) instead of the real file path (i.e. the path after following symlinks).\n\nRelated: esbuild#preserve-symlinks, webpack#resolve.symlinks\ncss.modules\n​\nType:\nts\ninterface CSSModulesOptions {\n  getJSON?: (\n    cssFileName: string,\n    json: Record<string, string>,\n    outputFileName: string,\n  ) => void\n  scopeBehaviour?: 'global' | 'local'\n  globalModulePaths?: RegExp[]\n  exportGlobals?: boolean\n  generateScopedName?:\n    | string\n    | ((name: string, filename: string, css: string) => string)\n  hashPrefix?: string\n  /**\n   * default: undefined\n   */\n  localsConvention?:\n    | 'camelCase'\n    | 'camelCaseOnly'\n    | 'dashes'\n    | 'dashesOnly'\n    | ((\n        originalClassName: string,\n        generatedClassName: string,\n        inputFile: string,\n      ) => string)\n}\n\nConfigure CSS modules behavior. The options are passed on to postcss-modules.\n\nThis option doesn't have any effect when using Lightning CSS. If enabled, css.lightningcss.cssModules should be used instead.\n\ncss.postcss\n​\nType: string | (postcss.ProcessOptions & { plugins?: postcss.AcceptedPlugin[] })\n\nInline PostCSS config or a custom directory to search PostCSS config from (default is project root).\n\nFor inline PostCSS config, it expects the same format as postcss.config.js. But for plugins property, only array format can be used.\n\nThe search is done using postcss-load-config and only the supported config file names are loaded.\n\nNote if an inline config is provided, Vite will not search for other PostCSS config sources.\n\ncss.preprocessorOptions\n​\nType: Record<string, object>\n\nSpecify options to pass to CSS pre-processors. The file extensions are used as keys for the options. The supported options for each preprocessors can be found in their respective documentation:\n\nsass/scss - Options.\nless - Options.\nstyl/stylus - Only define is supported, which can be passed as an object.\n\nAll preprocessor options also support the additionalData option, which can be used to inject extra code for each style content. Note that if you include actual styles and not just variables, those styles will be duplicated in the final bundle.\n\nExample:\n\njs\nexport default defineConfig({\n  css: {\n    preprocessorOptions: {\n      scss: {\n        additionalData: `$injectedColor: orange;`,\n      },\n      less: {\n        math: 'parens-division',\n      },\n      styl: {\n        define: {\n          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),\n        },\n      },\n    },\n  },\n})\ncss.devSourcemap\n​\nExperimental: Give Feedback\nType: boolean\nDefault: false\n\nWhether to enable sourcemaps during dev.\n\ncss.transformer\n​\nExperimental: Give Feedback\nType: 'postcss' | 'lightningcss'\nDefault: 'postcss'\n\nSelects the engine used for CSS processing. Check out Lightning CSS for more information.\n\ncss.lightningcss\n​\nExperimental: Give Feedback\nType:\njs\nimport type {\n  CSSModulesConfig,\n  Drafts,\n  Features,\n  NonStandard,\n  PseudoClasses,\n  Targets,\n} from 'lightningcss'\njs\n{\n  targets?: Targets\n  include?: Features\n  exclude?: Features\n  drafts?: Drafts\n  nonStandard?: NonStandard\n  pseudoClasses?: PseudoClasses\n  unusedSymbols?: string[]\n  cssModules?: CSSModulesConfig,\n  // ...\n}\n\nConfigures Lightning CSS. Full transform options can be found in the Lightning CSS repo.\n\njson.namedExports\n​\nType: boolean\nDefault: true\n\nWhether to support named imports from .json files.\n\njson.stringify\n​\nType: boolean\nDefault: false\n\nIf set to true, imported JSON will be transformed into export default JSON.parse(\"...\") which is significantly more performant than Object literals, especially when the JSON file is large.\n\nEnabling this disables named imports.\n\nesbuild\n​\nType: ESBuildOptions | false\n\nESBuildOptions extends esbuild's own transform options. The most common use case is customizing JSX:\n\njs\nexport default defineConfig({\n  esbuild: {\n    jsxFactory: 'h',\n    jsxFragment: 'Fragment',\n  },\n})\n\nBy default, esbuild is applied to ts, jsx and tsx files. You can customize this with esbuild.include and esbuild.exclude, which can be a regex, a picomatch pattern, or an array of either.\n\nIn addition, you can also use esbuild.jsxInject to automatically inject JSX helper imports for every file transformed by esbuild:\n\njs\nexport default defineConfig({\n  esbuild: {\n    jsxInject: `import React from 'react'`,\n  },\n})\n\nWhen build.minify is true, all minify optimizations are applied by default. To disable certain aspects of it, set any of esbuild.minifyIdentifiers, esbuild.minifySyntax, or esbuild.minifyWhitespace options to false. Note the esbuild.minify option can't be used to override build.minify.\n\nSet to false to disable esbuild transforms.\n\nassetsInclude\n​\nType: string | RegExp | (string | RegExp)[]\nRelated: Static Asset Handling\n\nSpecify additional picomatch patterns to be treated as static assets so that:\n\nThey will be excluded from the plugin transform pipeline when referenced from HTML or directly requested over fetch or XHR.\n\nImporting them from JS will return their resolved URL string (this can be overwritten if you have a enforce: 'pre' plugin to handle the asset type differently).\n\nThe built-in asset type list can be found here.\n\nExample:\n\njs\nexport default defineConfig({\n  assetsInclude: ['**/*.gltf'],\n})\nlogLevel\n​\nType: 'info' | 'warn' | 'error' | 'silent'\n\nAdjust console output verbosity. Default is 'info'.\n\ncustomLogger\n​\nType:\nts\ninterface Logger {\n  info(msg: string, options?: LogOptions): void\n  warn(msg: string, options?: LogOptions): void\n  warnOnce(msg: string, options?: LogOptions): void\n  error(msg: string, options?: LogErrorOptions): void\n  clearScreen(type: LogType): void\n  hasErrorLogged(error: Error | RollupError): boolean\n  hasWarned: boolean\n}\n\nUse a custom logger to log messages. You can use Vite's createLogger API to get the default logger and customize it to, for example, change the message or filter out certain warnings.\n\njs\nimport { createLogger, defineConfig } from 'vite'\n\nconst logger = createLogger()\nconst loggerWarn = logger.warn\n\nlogger.warn = (msg, options) => {\n  // Ignore empty CSS files warning\n  if (msg.includes('vite:css') && msg.includes(' is empty')) return\n  loggerWarn(msg, options)\n}\n\nexport default defineConfig({\n  customLogger: logger,\n})\nclearScreen\n​\nType: boolean\nDefault: true\n\nSet to false to prevent Vite from clearing the terminal screen when logging certain messages. Via command line, use --clearScreen false.\n\nenvDir\n​\nType: string\nDefault: root\n\nThe directory from which .env files are loaded. Can be an absolute path, or a path relative to the project root.\n\nSee here for more about environment files.\n\nenvPrefix\n​\nType: string | string[]\nDefault: VITE_\n\nEnv variables starting with envPrefix will be exposed to your client source code via import.meta.env.\n\nSECURITY NOTES\n\nenvPrefix should not be set as '', which will expose all your env variables and cause unexpected leaking of sensitive information. Vite will throw an error when detecting ''.\n\nIf you would like to expose an unprefixed variable, you can use define to expose it:\n\njs\ndefine: {\n  'import.meta.env.ENV_VARIABLE': JSON.stringify(process.env.ENV_VARIABLE)\n}\nappType\n​\nType: 'spa' | 'mpa' | 'custom'\nDefault: 'spa'\n\nWhether your application is a Single Page Application (SPA), a Multi Page Application (MPA), or Custom Application (SSR and frameworks with custom HTML handling):\n\n'spa': include HTML middlewares and use SPA fallback. Configure sirv with single: true in preview\n'mpa': include HTML middlewares\n'custom': don't include HTML middlewares\n\nLearn more in Vite's SSR guide. Related: server.middlewareMode."
  },
  {
    "title": "Configuring Vite | Vite",
    "url": "https://vitejs.dev/config/",
    "html": "Configuring Vite\n​\n\nWhen running vite from the command line, Vite will automatically try to resolve a config file named vite.config.js inside project root (other JS and TS extensions are also supported).\n\nThe most basic config file looks like this:\n\njs\n// vite.config.js\nexport default {\n  // config options\n}\n\nNote Vite supports using ES modules syntax in the config file even if the project is not using native Node ESM, e.g. type: \"module\" in package.json. In this case, the config file is auto pre-processed before load.\n\nYou can also explicitly specify a config file to use with the --config CLI option (resolved relative to cwd):\n\nbash\nvite --config my-config.js\nConfig Intellisense\n​\n\nSince Vite ships with TypeScript typings, you can leverage your IDE's intellisense with jsdoc type hints:\n\njs\n/** @type {import('vite').UserConfig} */\nexport default {\n  // ...\n}\n\nAlternatively, you can use the defineConfig helper which should provide intellisense without the need for jsdoc annotations:\n\njs\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  // ...\n})\n\nVite also directly supports TS config files. You can use vite.config.ts with the defineConfig helper as well.\n\nConditional Config\n​\n\nIf the config needs to conditionally determine options based on the command (serve or build), the mode being used, if it's an SSR build (isSsrBuild), or is previewing the build (isPreview), it can export a function instead:\n\njs\nexport default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {\n  if (command === 'serve') {\n    return {\n      // dev specific config\n    }\n  } else {\n    // command === 'build'\n    return {\n      // build specific config\n    }\n  }\n})\n\nIt is important to note that in Vite's API the command value is serve during dev (in the cli vite, vite dev, and vite serve are aliases), and build when building for production (vite build).\n\nisSsrBuild and isPreview are additional optional flags to differentiate the kind of build and serve commands respectively. Some tools that load the Vite config may not support these flags and will pass undefined instead. Hence, it's recommended to use explicit comparison against true and false.\n\nAsync Config\n​\n\nIf the config needs to call async functions, it can export an async function instead. And this async function can also be passed through defineConfig for improved intellisense support:\n\njs\nexport default defineConfig(async ({ command, mode }) => {\n  const data = await asyncFunction()\n  return {\n    // vite config\n  }\n})\nUsing Environment Variables in Config\n​\n\nEnvironmental Variables can be obtained from process.env as usual.\n\nNote that Vite doesn't load .env files by default as the files to load can only be determined after evaluating the Vite config, for example, the root and envDir options affect the loading behaviour. However, you can use the exported loadEnv helper to load the specific .env file if needed.\n\njs\nimport { defineConfig, loadEnv } from 'vite'\n\nexport default defineConfig(({ command, mode }) => {\n  // Load env file based on `mode` in the current working directory.\n  // Set the third parameter to '' to load all env regardless of the `VITE_` prefix.\n  const env = loadEnv(mode, process.cwd(), '')\n  return {\n    // vite config\n    define: {\n      __APP_ENV__: JSON.stringify(env.APP_ENV),\n    },\n  }\n})"
  }
]
