[
  {
    "title": "Contributing Â· Nitro",
    "url": "https://nitro.unjs.io/guide/community/contributing/",
    "html": "Contributing\n\nThank you for wanting to contribute to Nitro ðŸ’›\n\nBefore everything, please make sure to check the open issues or the discussions.\n\nTo contribute locally:\n\nFork and clone unjs/nitro\nEnable corepack using corepack enable (use npm i -g corepack for Node.js < 16.10)\nInstall dependencies using pnpm install\nActivate passive watcher using pnpm stub\nStart playground with pnpm dev and open http://localhost:3000\nYou can also try examples/ using pnpm nitro dev examples/<name> and pnpm nitro build examples/<name>\nMake changes\nEnsure all tests pass using the pnpm test command\nOpen a Pull-Request\n\nYou can also run pnpm vitest test/presets/node.test.ts to run a single test.\n\nEdit this page on GitHub\nGuide\nTypeScript\nOverview"
  },
  {
    "title": "TypeScript Â· Nitro",
    "url": "https://nitro.unjs.io/guide/typescript/",
    "html": "TypeScript Support\n\nNitro supports TypeScript by default. If you are using the starter template, you have nothing to do âœ¨.\n\nTo add type hints within your project, create a tsconfig.json file:\n\ntsconfig.json\n{\n\n  \"extends\": \"./.nitro/types/tsconfig.json\"\n\n}\n\nCopy to clipboard\n\nRun npx nitropack prepare to generate the types for global auto-imports. This can be useful in a CI environment or as a postinstall command in your package.json.\n\nIf you are using Nuxt, your tsconfig.json can stay:\n\ntsconfig.json\n{\n\n  \"extends\": \"./.nuxt/tsconfig.json\"\n\n}\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nPlugins\nCommunity\nContributing"
  },
  {
    "title": "Plugins Â· Nitro",
    "url": "https://nitro.unjs.io/guide/plugins/",
    "html": "Plugins\n\nUse plugins to extend Nitro's runtime behavior.\n\nPlugins are auto-registered (filename ordering) and run synchronously on the first nitro initialization. They receive nitroApp context, which can be used to hook into lifecycle events.\n\nScanning pattern: plugins/**/*.{ts,mjs,js,cjs}\n\nYou can order the plugins by prefixing them with a number:\n\nplugins/\n\n  1.first.ts\n\n  2.second.ts\n\nCopy to clipboard\n\nExample: Simple plugin\n\n// plugins/test.ts\n\nexport default defineNitroPlugin((nitroApp) => {\n\n  console.log('Nitro plugin', nitroApp)\n\n})\n\nCopy to clipboard\n\nIf you have plugins in another directory, you can use the plugins option:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  plugins: ['my-plugins/hello.ts']\n\n})\n\nCopy to clipboard\nNitro Runtime Hooks\n\nHooks allow extending the default runtime behaviour of Nitro by registering custom functions to the lifecycle events within plugins. (Read unjs/hookable to see how it works.)\n\nExample:\n\nexport default defineNitroPlugin((nitro) => {\n\n  nitro.hooks.hook(\"close\", async () => {\n\n    // Will run when nitro is being closed\n\n  });\n\n})\n\nCopy to clipboard\nAvailable Hooks\n\nSee the source code for list of all available runtime hooks.\n\n\"close\", () => {}\n\"error\", (error, { event? }) => {}\n\"render:response\", (response, { event }) => {}\n\"request\", (event) => {}\n\"beforeResponse\", (event, { body }) => {}\n\"afterResponse\", (event, { body }) => {}\nExamples\nCapturing Errors\n\nYou can use plugins to capture all application errors.\n\nexport default defineNitroPlugin((nitro) => {\n\n  nitro.hooks.hook(\"error\", async (error, { event }) => {\n\n    console.error(`${event.path} Application error:`, error)\n\n  });\n\n})\n\nCopy to clipboard\nGraceful Shutdown\n\nYou can use plugins to register a hook that resolves when Nitro is closed.\n\nexport default defineNitroPlugin((nitro) => {\n\n  nitro.hooks.hookOnce(\"close\", async () => {\n\n    // Will run when nitro is closed\n\n    console.log(\"Closing nitro server...\")\n\n    await new Promise((resolve) => setTimeout(resolve, 500));\n\n    console.log(\"Task is done!\");\n\n  });\n\n})\n\nCopy to clipboard\nRequest and Response lifecycle\n\nYou can use plugins to register a hook that can run on request lifecycle:\n\nexport default defineNitroPlugin((nitroApp) => {\n\n  nitroApp.hooks.hook(\"request\", (event) => {\n\n    console.log(\"on request\", event.path);\n\n  });\n\n\n\n  nitroApp.hooks.hook(\"beforeResponse\", (event, { body }) => {\n\n    console.log(\"on response\", event.path, { body });\n\n  });\n\n\n\n  nitroApp.hooks.hook(\"afterResponse\", (event, { body }) => {\n\n    console.log(\"on after response\", event.path, { body });\n\n  });\n\n});\n\nCopy to clipboard\nRenderer Response\n\nYou can use plugins to register a hook that modifies the renderer response.\n\nThis only works for render handler defined with renderer and won't be called for other api/server routes. In Nuxt this hook will be called for Server Side Rendered pages\nexport default defineNitroPlugin((nitro) => {\n\n\n\n  nitro.hooks.hook('render:response', (response, { event }) => {\n\n    // Inspect or Modify the renderer response here\n\n    console.log(response)\n\n  })\n\n})\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nUtils\nGuide\nTypeScript"
  },
  {
    "title": "Utils Â· Nitro",
    "url": "https://nitro.unjs.io/guide/utils/",
    "html": "Utils\n\nNitro helps you to stay organized allowing you to take advantage of the auto-imports feature.\n\nEvery export in the utils directory and its subdirectories will become available globally in your application.\n\nExample: Create a utils/sum.ts file where a function useSum is exported:\n\nutils/sum.ts\nexport function useSum(a: number, b: number) { return a + b }\n\nCopy to clipboard\n\nUse it in your routes/index.ts file without importing it:\n\nroutes/index.ts\nexport default defineEventHandler(() => {\n\n  const sum = useSum(1, 2) // auto-imported\n\n  return { sum }\n\n})\n\nCopy to clipboard\nExperimental Composition API\n\nNitro (2.6+) enables a new server development experience in order to split application logic into smaller \"composable\" utilities that are fully decoupled from each other and can directly assess to a shared context (request event) without needing it to be passed along. This pattern is inspired from Vue Composition API and powered by unjs/unctx.\n\nThis feature is currently supported for Node.js and Bun runtimes and also coming soon to other presets that support AsyncLocalStorage interface.\n\nIn order to enable composition API, you have to enable asyncContext flag:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  experimental: {\n\n    asyncContext: true\n\n  }\n\n});\n\nCopy to clipboard\n\nAfter enabling this flag, you can use useEvent() (auto imported) in any utility or composable to access the request event without manually passing it along:\n\nwith async context\nwithout async context\n// routes/index.ts\n\nexport default defineEventHandler(async () => {\n\n  const user = await useAuth()\n\n})\n\n\n\n// utils/auth.ts\n\nexport function useAuth() {\n\n  return useSession(useEvent())\n\n}\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nAssets\nGuide\nPlugins"
  },
  {
    "title": "Assets Â· Nitro",
    "url": "https://nitro.unjs.io/guide/assets/",
    "html": "Assets Handling\n\nNitro handles assets via the public/ directory.\n\nPublic Assets\n\nAll assets in public/ directory will be automatically served.\n\npublic/\n\n  image.png     <-- /image.png\n\n  video.mp4     <-- /video.mp4\n\n  robots.txt    <-- /robots.txt\n\npackage.json\n\nnitro.config.ts\n\nCopy to clipboard\n\nWhen building with Nitro, it will copy the public/ directory to .output/public/ and create a manifest with metadata:\n\n{\n\n  \"/image.png\": {\n\n    \"type\": \"image/png\",\n\n    \"etag\": \"\\\"4a0c-6utWq0Kbk5OqDmksYCa9XV8irnM\\\"\",\n\n    \"mtime\": \"2023-03-04T21:39:45.086Z\",\n\n    \"size\": 18956\n\n  },\n\n  \"/robots.txt\": {\n\n    \"type\": \"text/plain; charset=utf-8\",\n\n    \"etag\": \"\\\"8-hMqyDrA8fJ0R904zgEPs3L55Jls\\\"\",\n\n    \"mtime\": \"2023-03-04T21:39:45.086Z\",\n\n    \"size\": 8\n\n  },\n\n  \"/video.mp4\": {\n\n    \"type\": \"video/mp4\",\n\n    \"etag\": \"\\\"9b943-4UwfQXKUjPCesGPr6J5j7GzNYGU\\\"\",\n\n    \"mtime\": \"2023-03-04T21:39:45.085Z\",\n\n    \"size\": 637251\n\n  }\n\n}\n\nCopy to clipboard\n\nThis allows Nitro to know the public assets without scanning the directory, giving high performance with caching headers.\n\nServer Assets\n\nAll assets in assets/ directory will be added to the server bundle.\n\nThey can be addressed by the assets:server mount point using useStorage('assets:server')\n\nKeys can be written assets/server/my_file_path or assets:server:my_file_path.\nCustom Server Assets\n\nIn order to add assets from a custom directory, path will need to be defined in the nitro config:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  serverAssets: [{\n\n    baseName: 'my_directory',\n\n    dir: './server/my_directory'\n\n  }]\n\n})\n\nCopy to clipboard\n\nThey can be addressed by the key assets/my_directory/.\n\nExamples\n\nExample: Retrieving a json data from default assets directory:\n\nexport default defineEventHandler(async () => {\n\n  const data = await useStorage().getItem(`assets/server/data.json`)\n\n  return data\n\n})\n\nCopy to clipboard\n\nExample: Retrieving a html file from a custom assets directory:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  serverAssets: [{\n\n    baseName: 'templates',\n\n    dir: './templates' // Relative to `srcDir` (`server/` for nuxt)\n\n  }]\n\n})\n\nCopy to clipboard\n// routes/success.ts\n\nexport default defineEventHandler(async (event) => {\n\n  return await useStorage().getItem(`assets/templates/success.html`)\n\n  // or\n\n  return await useStorage('assets:templates').getItem(`success.html`)\n\n})\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nCache API\nGuide\nUtils"
  },
  {
    "title": "Cache API Â· Nitro",
    "url": "https://nitro.unjs.io/guide/cache/",
    "html": "Cache API\n\nNitro provides a powerful caching system built on top of the storage layer.\n\nIt stores the data in the cache mountpoint.\n\nIn development, it will use the FS driver writting to .nitro/cache or .nuxt/cache if using Nuxt.\nIn production, it will use the memory driver by default.\n\nTo overwrite the production storage, set the cache mountpoint using the storage option:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  storage: {\n\n    cache: {\n\n      driver: 'redis',\n\n      /* redis connector options */\n\n    }\n\n  }\n\n})\n\nCopy to clipboard\n\nTo overwrite the cache mountpoint in development, use the devStorage option to add the cache mountpoint.\n\nUsage\nRouter Handler\nFunction\n// Cache an API handler\n\nexport default cachedEventHandler((event) => {\n\n  // My event handler\n\n}, options);\n\nCopy to clipboard\nExamples\n\nIf you come from Nuxt, all the examples below should be placed inside the server/ directory.\n\nRoute Handler\n\nCache a route with stale-while-revalidate behavior for 10 second:\n\nroutes/cached.ts\nexport default cachedEventHandler(async () => {\n\n  return `Response generated at ${new Date().toISOString()}`;\n\n}, {\n\n  maxAge: 10\n\n});\n\nCopy to clipboard\n\nThe response will be cached for 10 seconds and a stale value will be sent to the client while the cache is being updated in the background. If you want to immediately return the updated response set swr: false.\n\nThe cached answer will be store in development inside .nitro/cache/handlers/_/*.json.\n\nBy default, all incoming request headers are dropped when handling cached responses. If you define the varies option, only the specified headers will be considered when caching and serving the responses.\nFunction\n\nCache for 1 hour the result of a function fetching the GitHub stars for a repository:\n\nutils/github.ts\napi/stars/[...repo\nexport const cachedGHStars = cachedFunction(async (repo: string) => {\n\n  const data: any = await $fetch(`https://api.github.com/repos/${repo}`)\n\n\n\n  return data.stargazers_count\n\n}, {\n\n  maxAge: 60 * 60,\n\n  name: 'ghStars',\n\n  getKey: (repo: string) => repo\n\n})\n\nCopy to clipboard\n\nThe stars will be cached in development inside .nitro/cache/functions/ghStars/<owner>/<repo>.json with value being the number of stars.\n\n{\"expires\":1677851092249,\"value\":43991,\"mtime\":1677847492540,\"integrity\":\"ZUHcsxCWEH\"}\n\nCopy to clipboard\nRoute Rules\n\nThis feature enables you to add caching routes based on a glob pattern directly in the main configuration file.\n\nThis feature is still experimental and may evolve in the future.\n\nCache all the blog routes for 1 hour with stale-while-revalidate behavior:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  routeRules: {\n\n    \"/blog/**\": {\n\n      swr: 60 * 60,\n\n      // or\n\n      cache: {\n\n        maxAge: 60 * 60\n\n      }\n\n    },\n\n  },\n\n});\n\nCopy to clipboard\n\nIf we want to use a custom storage mountpoint, we can use the base option. Let's store our cache result for the blog routes in a Redis storage for production:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  storage: {\n\n    redis: {\n\n      driver: \"redis\",\n\n      url: \"redis://localhost:6379\",\n\n    },\n\n  },\n\n  routeRules: {\n\n    \"/blog/**\": {\n\n      swr: 60 * 60,\n\n      cache: {\n\n        base: \"redis\",\n\n      },\n\n    },\n\n  },\n\n});\n\nCopy to clipboard\nOptions\n\nThe cachedEventHandler and cachedFunction functions accept the following options:\n\nname: Handler name.\nType: String\nDefault: Guessed from function name if not provided and fallback to _ otherwise.\ngroup: Part of cache name. Useful to organize cache storage.\nType: String\nDefault: 'nitro/handlers' for handlers and 'nitro/functions' for functions.\ngetKey: A function that accepts the same arguments of the function and returns a cache key (String).\nType: Function\nDefault: If not provided, a built-in hash function will be used.\nintegrity: A value that invalidates the cache when changed.\nType: String\nDefault: Computed from function code, used in development to invalidate the cache when the function code changes.\nmaxAge: Maximum age that cache is valid in seconds.\nType: Number\nDefault: 1 (second).\nstaleMaxAge: Maximum age that a stale cache is valid in seconds. If set to -1 a stale value will still be sent to the client, while updating the cache in the background.\nType: Number\nDefault: 0 (disabled).\nswr: Enable stale-while-revalidate behavior.\nDefault: true\nbase: Name of the storage mountpoint to use for caching.\nDefault: cache.\nshouldInvalidateCache: A function that returns a Boolean to invalidate the current cache and create a new one.\nType: Function\nshouldBypassCache: A function that returns a boolean to bypass the current cache without invalidating the existing entry.\nType: Function\nvaries: An array of request headers to be considered for the cache\nType: string[]\nEdit this page on GitHub\nGuide\nStorage Layer\nGuide\nAssets"
  },
  {
    "title": "Storage Layer Â· Nitro",
    "url": "https://nitro.unjs.io/guide/storage/",
    "html": "Storage Layer\n\nNitro provides a built-in storage layer that can abstract filesystem or database or any other data source.\n\nuseStorage() is an instance of createStorage using the memory driver.\n\nExample: Simple (in memory) operations\n\nawait useStorage().setItem('test:foo', { hello: 'world' })\n\nawait useStorage().getItem('test:foo')\n\n\n\n// You can also specify the base in useStorage(base)\n\nawait useStorage('test').setItem('foo', { hello: 'world' })\n\nawait useStorage('test').getItem('foo')\n\nCopy to clipboard\n\nSee Unstorage for detailed usage.\n\nMountpoints\n\nYou can mount storage drivers using the storage option:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  storage: {\n\n    'redis': {\n\n      driver: 'redis',\n\n      /* redis connector options */\n\n    },\n\n    'db': {\n\n      driver: 'fs',\n\n      base: './data/db'\n\n    }\n\n  }\n\n})\n\nCopy to clipboard\nRuntime configuration\n\nIn scenarios where the mount point configuration is not known until runtime, Nitro can dynamically add mount points during startup using plugins:\n\nThis is a temporary workaround, with a better solution coming in the future! Keep a lookout on the GitHub issue here.\nplugins/storage.ts\nnitro.config.ts\nnuxt.config.ts\nimport redisDriver from 'unstorage/drivers/redis'\n\n\n\nexport default defineNitroPlugin(() => {\n\n  const storage = useStorage()\n\n\n\n  // Dynamically pass in credentials from runtime configuration, or other sources\n\n  const driver = redisDriver({\n\n      base: 'redis',\n\n      host: useRuntimeConfig().redis.host,\n\n      port: useRuntimeConfig().redis.port,\n\n      /* other redis connector options */\n\n    })\n\n\n\n  // Mount driver\n\n  storage.mount('redis', driver)\n\n})\n\nCopy to clipboard\n\nUsage:\n\nawait useStorage('redis').setItem('foo', { hello: 'world' })\n\nawait useStorage('redis').getItem('foo')\n\n// or\n\nawait useStorage().setItem('redis:foo', { hello: 'world' })\n\nawait useStorage().getItem('redis:foo')\n\nCopy to clipboard\n\nUsage with generics:\n\nawait useStorage().getItem<string>('foo')\n\n// => string\n\nawait useStorage<string>().getItem('foo')\n\n// => string\n\n\n\nawait useStorage<string>().setItem('foo', 123) // ts error\n\n\n\ntype Foo = { data: number }\n\n\n\nawait useStorage().getItem<Foo>('foo')\n\n// => Foo\n\nCopy to clipboard\n\nYou can find the list of drivers on unstorage documentation.\n\nIn development, Nitro adds the cache mountpoint using the FS driver writting to .nitro/cache or .nuxt/cache if using Nuxt.\n\nawait useStorage('cache').setItem('foo', { hello: 'world' })\n\nawait useStorage('cache').getItem('foo')\n\nCopy to clipboard\nDevelopment storage\n\nYou can use the devStorage key to overwrite the storage configuration during development, very useful when you use a database in production and want to use the filesystem in development.\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  // Production\n\n  storage: {\n\n    db: {\n\n      driver: 'redis',\n\n      /* redis connector options */\n\n    }\n\n  },\n\n  // Development\n\n  devStorage: {\n\n    db: {\n\n      driver: 'fs',\n\n      base: './data/db'\n\n    }\n\n  }\n\n})\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nRouting\nGuide\nCache API"
  },
  {
    "title": "Routing Â· Nitro",
    "url": "https://nitro.unjs.io/guide/routing/",
    "html": "Routing\n\nNitro support filesystem routing as well as defining route rules for maximum flexibility and performance.\n\nFilesystem Routing\n\nNitro supports file-based routing for your API routes.\n\nHandler files inside api/ and routes/ directory will be automatically mapped to unjs/h3 routes.\n\napi/\n\n  test.ts      <-- /api/test\n\nroutes/\n\n  hello.ts     <-- /hello\n\nnitro.config.ts\n\nCopy to clipboard\nSome providers like Vercel use a top-level api/ directory as a feature, therefore routes placed in /api wont work. You will have to use routes/api/.\nIf you are using Nuxt, move the api/ and routes/ inside the server/ directory.\nSimple route\n// api/hello.ts\n\nexport default defineEventHandler(() => {\n\n  return { hello: 'world' }\n\n})\n\nCopy to clipboard\n\nYou can now universally call this API using await $fetch('/api/hello').\n\nRoute with params\n// routes/hello/[name].ts\n\nexport default defineEventHandler(event => `Hello ${event.context.params.name}!`)\n\nCopy to clipboard\n/hello/nitro\nHello nitro!\n\nCopy to clipboard\n\nTo include the /, use [...name].ts:\n\n// routes/hello/[...name].ts\n\nexport default defineEventHandler(event => `Hello ${event.context.params.name}!`)\n\nCopy to clipboard\n/hello/nitro/is/hot\nHello nitro/is/hot!\n\nCopy to clipboard\nSpecific request method\n\nAPI route with a specific HTTP request method (get, post, put, delete, options and so on).\n\nGET\nPOST\n// routes/users/[id].get.ts\n\nexport default defineEventHandler(async (event) => {\n\n  const { id } = event.context.params\n\n  // TODO: fetch user by id\n\n  return `User profile!`\n\n})\n\nCopy to clipboard\n\nCheck out h3 JSDocs for all available utilities like readBody.\n\nCatch all route\n// routes/[...].ts\n\nexport default defineEventHandler(event => `Default page`)\n\nCopy to clipboard\nRoute Rules\n\nNitro allows you to add logic at the top-level of your configuration, useful for redirecting, proxying, caching and adding headers to routes.\n\nIt is a map from route pattern (following unjs/radix3) to route options.\n\nWhen cache option is set, handlers matching pattern will be automatically wrapped with defineCachedEventHandler.\n\nSee the Cache API for all available cache options.\n\nswr: true|number is shortcut for cache: { swr: true, maxAge: number }\n\nExample:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  routeRules: {\n\n    '/blog/**': { swr: true },\n\n    '/blog/**': { swr: 600 },\n\n    '/blog/**': { static: true },\n\n    '/blog/**': { cache: { /* cache options*/ } },\n\n    '/assets/**': { headers: { 'cache-control': 's-maxage=0' } },\n\n    '/api/v1/**': { cors: true, headers: { 'access-control-allow-methods': 'GET' } },\n\n    '/old-page': { redirect: '/new-page' },\n\n    '/proxy/example': { proxy: 'https://example.com' },\n\n    '/proxy/**': { proxy: '/api/**' },\n\n  }\n\n})\n\nCopy to clipboard\nRoute Middleware\n\nNitro route middleware can hook into the request lifecycle.\n\nA middleware can modify the request before it is processed, not after.\n\nMiddleware are auto-registered within the middleware/ directory.\n\nroutes/\n\n  hello.ts\n\nmiddleware/\n\n  auth.ts\n\n  logger.ts\n\n  ...\n\nnitro.config.ts\n\nCopy to clipboard\nSimple Middleware\n\nMiddleware are defined exactly like route handlers with the only exception that they should not return anything. Returning from middleware behaves like returning from a request - the value will be returned as a response and further code will not be ran.\n\nmiddleware/auth.ts\nexport default defineEventHandler((event) => {\n\n  // Extends or modify the event\n\n  event.context.user = { name: 'Nitro' }\n\n})\n\nCopy to clipboard\nReturning anything from a middleware will close the request and should be avoided! Any returned value from middleware will be the response and further code will not be executed however this is not recommended to do!\nExecution Order\n\nMiddleware are executed in directory listing order.\n\nmiddleware/\n\n  auth.ts <-- First\n\n  logger.ts <-- Second\n\n  ... <-- Third\n\nCopy to clipboard\n\nPrefix middleware with a number to control their execution order.\n\nmiddleware/\n\n  1.logger.ts <-- First\n\n  2.auth.ts <-- Second\n\n  3.... <-- Third\n\nCopy to clipboard\nRequest Filtering\n\nMiddleware are executed on every request.\n\nApply custom logic to scope them to specific conditions.\n\nFor example, you can use the URL to apply a middleware to a specific route:\n\nmiddleware/auth.ts\nexport default defineEventHandler((event) => {\n\n  // Will only execute for /auth route\n\n  if (getRequestURL(event).startsWith('/auth')) {\n\n    event.context.user = { name: 'Nitro' }\n\n  }\n\n})\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nAuto Imports\nGuide\nStorage Layer"
  },
  {
    "title": "Configuration Â· Nitro",
    "url": "https://nitro.unjs.io/guide/configuration/",
    "html": "Configuration\n\nYou can customize your Nitro server with single configuration file: nitro.config.ts.\n\nAll deployment providers are built on the same options API.\n\nIf you are using Nuxt, use the nitro option in your Nuxt config.\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  // Nitro options\n\n})\n\nCopy to clipboard\n\nRead all the available options to configure Nitro.\n\nNitro loads the configuration using unjs/c12, giving more possibilities such as using .nitrorc.\n\n.nitrorc\n.nuxtrc\ntiming=true\n\nCopy to clipboard\nRuntime Configuration\n\nNitro provides a runtime config API to expose configuration within your application, with the ability to update it at runtime by setting environment variables.\n\nTo expose config and environment variables to the rest of your app, you will need to define runtime configuration in your configuration file.\n\nExample:\n\nnitro.config.ts\nnuxt.config.ts\nexport default defineNitroConfig({\n\n  runtimeConfig: {\n\n    helloThere: \"foobar\",\n\n  }\n\n})\n\nCopy to clipboard\n\nYou can now access the runtime config using useRuntimeConfig(event).\n\nExample:\n\napi/example.get.ts (nitro)\nserver/api/example.get.ts (nuxt)\nexport default defineEventHandler((event) => {\n\n  return useRuntimeConfig(event).helloThere // foobar\n\n});\n\nCopy to clipboard\nNote: Consider using useRuntimeConfig(event) within event handlers and utilities and avoid calling it in ambient global contexts.\nEnvironment Variables\n\nNitro supports defining environment variables using .env file in development (use platform variables for production).\n\nCreate an .env file in your project root:\n\n.env\nTEST=\"123\"\n\nCopy to clipboard\n\nYou can universally access environment variables using import.meta.env.TEST or process.env.TEST.\n\nNote: Consider writing any logic that depends on environment variables within event handlers and utilities and avoid accessing and caching them in ambient global contexts.\nUpdate runtime config using environment variables\n\nThe variables prefixed with NITRO_ will be applied to runtime config, and they will override the variables defined within your nitro.config.ts file. (matching \"camelCase\" version).\n\nExample:\n\n.env (nitro)\n.env (nuxt)\nNITRO_HELLO_THERE=\"123\"\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nGetting Started\nGuide\nAuto Imports"
  },
  {
    "title": "Auto Imports Â· Nitro",
    "url": "https://nitro.unjs.io/guide/auto-imports/",
    "html": "Auto Imports\n\nNitro is using unjs/unimport to auto import utilities when used with full tree-shaking support.\n\nAvailable Auto Imports\ndefineCachedFunction(fn, options) / cachedFunction(fn, options)\ndefineCachedEventHandler(handler, options) / cachedEventHandler(handler, options)\ndefineRenderHandler(handler)\nuseRuntimeConfig(event?)\nuseAppConfig(event?)\nuseStorage(base?)\nuseNitroApp()\ndefineNitroPlugin(plugin)\nnitroPlugin(plugin)\ngetRouteRules(event)\n\nCheck the source code for list of available auto imports.\n\nWith TypeScript enabled, you can easily see them as global utilities in your IDE.\n\nThe types are auto generated for global auto-imports when running the prepare or dev command.\nManual Imports\n\nFor some edge cases (IDE support and libraries in node_modules) it is impossible to rely on auto imports.\n\nYou can import them from virtual #imports file. It will be still tree-shaken:\n\nplugins/test.ts\nimport { useStorage } from '#imports'\n\nCopy to clipboard\nEdit this page on GitHub\nGuide\nConfiguration\nGuide\nRouting"
  },
  {
    "title": "Getting Started Â· Nitro",
    "url": "https://nitro.unjs.io/guide/getting-started/",
    "html": "Getting Started\n\nLet's create a new Nitro app in few steps.\n\nPlay Online\nOpen on Stackblitz\nOpen on CodeSandbox\nStarter Template\n\nMake sure you have installed the recommended setup:\n\nCreate a new project using starter template:\n\nnpx\npnpm\nbun\nnpx giget@latest nitro nitro-app\n\nCopy to clipboard\ncd nitro-app\n\nCopy to clipboard\n\nInstall the dependencies:\n\nnpm\nyarn\npnpm\nbun\nnpm install\n\nCopy to clipboard\n\nStart the development server:\n\nnpm run dev\n\nCopy to clipboard\n\nðŸª„ Your API is ready at http://localhost:3000/\n\nCheck .nitro/dev/index.mjs if want to know what is happening\n\nBuild your production-ready server:\n\nnpm run build\n\nCopy to clipboard\n\nOutput is in the .output directory and ready to be deployed on almost any provider with no dependencies.\n\nYou can try it locally with:\n\nnpm run preview\n\nCopy to clipboard\nNightly Release Channel\n\nNitro offers a nightly release channel that automatically releases for every commit to main branch.\n\nYou can opt-in to the nightly release channel by updating your package.json:\n\nNitro\nNuxt\n{\n\n  \"devDependencies\": {\n\n--    \"nitropack\": \"^2.0.0\"\n\n++    \"nitropack\": \"npm:nitropack-nightly@latest\"\n\n  }\n\n}\n\nCopy to clipboard\nIf you are using Nuxt, use the Nuxt nightly channel as it already includes nitropack-nightly.\n\nRemove the lockfile (package-lock.json, yarn.lock, pnpm-lock.yaml, or bun.lockb) and reinstall the dependencies.\n\nEdit this page on GitHub\nGuide\nConfiguration"
  }
]