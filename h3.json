[
  {
    "title": "h3@1.9.0 - jsDocs.io",
    "url": "https://www.jsdocs.io/package/h3#package-functions",
    "html": "Minimal H(TTP) framework built for high performance and portability.\n\nIndex\nVariables\nappendHeader\nappendHeaders\neventHandler\ngetHeader\ngetHeaders\nH3Headers\nH3Response\nlazyEventHandler\nMIMES\nsetHeader\nsetHeaders\nFunctions\nappendCorsHeaders()\nappendCorsPreflightHeaders()\nappendResponseHeader()\nappendResponseHeaders()\nassertMethod()\ncallNodeListener()\nclearResponseHeaders()\nclearSession()\ncreateApp()\ncreateAppEventHandler()\ncreateError()\ncreateEvent()\ncreateRouter()\ndefaultContentType()\ndefineEventHandler()\ndefineLazyEventHandler()\ndefineNodeListener()\ndefineNodeMiddleware()\ndefineRequestMiddleware()\ndefineResponseMiddleware()\ndeleteCookie()\ndynamicEventHandler()\nfetchWithEvent()\nfromNodeMiddleware()\nfromPlainHandler()\nfromWebHandler()\ngetCookie()\ngetMethod()\ngetProxyRequestHeaders()\ngetQuery()\ngetRequestFingerprint()\ngetRequestHeader()\ngetRequestHeaders()\ngetRequestHost()\ngetRequestIP()\ngetRequestPath()\ngetRequestProtocol()\ngetRequestURL()\ngetRequestWebStream()\ngetResponseHeader()\ngetResponseHeaders()\ngetResponseStatus()\ngetResponseStatusText()\ngetRouterParam()\ngetRouterParams()\ngetSession()\ngetValidatedQuery()\ngetValidatedRouterParams()\nhandleCacheHeaders()\nhandleCors()\nisCorsOriginAllowed()\nisError()\nisEvent()\nisEventHandler()\nisMethod()\nisPreflightRequest()\nisStream()\nisWebResponse()\nparseCookies()\npromisifyNodeListener()\nproxyRequest()\nreadBody()\nreadFormData()\nreadMultipartFormData()\nreadRawBody()\nreadValidatedBody()\nremoveResponseHeader()\nsanitizeStatusCode()\nsanitizeStatusMessage()\nsealSession()\nsend()\nsendError()\nsendNoContent()\nsendProxy()\nsendRedirect()\nsendStream()\nsendWebResponse()\nserveStatic()\nsetCookie()\nsetResponseHeader()\nsetResponseHeaders()\nsetResponseStatus()\nsplitCookiesString()\ntoEventHandler()\ntoNodeListener()\ntoPlainHandler()\ntoWebHandler()\ntoWebRequest()\nunsealSession()\nupdateSession()\nuse()\nuseBase()\nuseSession()\nwriteEarlyHints()\nClasses\nH3Error\nH3Event\nInterfaces\nApp\nAppOptions\nAppUse\nCacheConditions\nCreateRouterOptions\nDynamicEventHandler\nEventHandler\nEventHandlerRequest\nH3CorsOptions\nH3EventContext\nInputLayer\nLayer\nMultiPartData\nNodeEventContext\nPlainRequest\nPlainResponse\nProxyOptions\nRequestFingerprintOptions\nRouteNode\nRouter\nServeStaticOptions\nSession\nSessionConfig\nStaticAssetMeta\nWebEventContext\nType Aliases\nAddRouteShortcuts\nDuplex\nEncoding\nEventHandlerObject\nEventHandlerResponse\nHTTPHeaderName\nHTTPMethod\nInferEventInput\nInputStack\nLazyEventHandler\nMatcher\nNodeListener\nNodeMiddleware\nNodePromisifiedHandler\nPlainHandler\nRequestHeaders\nRouterMethod\nRouterUse\nSessionData\nStack\nValidateFunction\nValidateResult\nWebHandler\nVariables\nvariable appendHeader\nconst appendHeader: (\n    event: H3Event<EventHandlerRequest>,\n    name: HTTPHeaderName,\n    value: string\n) => void;\nvariable appendHeaders\nconst appendHeaders: (\n    event: H3Event<EventHandlerRequest>,\n    headers: Record<string, string>\n) => void;\nvariable eventHandler\nconst eventHandler: {\n    <Request extends EventHandlerRequest = EventHandlerRequest, Response = any>(\n        handler:\n            | EventHandler<Request, Response>\n            | EventHandlerObject<Request, Response>\n    ): EventHandler<Request, Response>;\n    <Request = EventHandlerRequest, Response = any>(\n        handler: EventHandler<\n            Request extends EventHandlerRequest ? Request : EventHandlerRequest,\n            Request extends EventHandlerRequest ? Response : Request\n        >\n    ): EventHandler<\n        Request extends EventHandlerRequest ? Request : EventHandlerRequest,\n        Request extends EventHandlerRequest ? Response : Request\n    >;\n};\nvariable getHeader\nconst getHeader: (\n    event: H3Event<EventHandlerRequest>,\n    name: HTTPHeaderName\n) => string;\nvariable getHeaders\nconst getHeaders: (\n    event: H3Event<EventHandlerRequest>\n) => Partial<Record<HTTPHeaderName, string>>;\nvariable H3Headers\nconst H3Headers: {\n    new (init?: HeadersInit | undefined): Headers;\n    prototype: Headers;\n};\nDeprecated\n\nPlease use native web Headers https://developer.mozilla.org/en-US/docs/Web/API/Headers\n\nvariable H3Response\nconst H3Response: {\n    new (\n        body?: BodyInit | null | undefined,\n        init?: ResponseInit | undefined\n    ): Response;\n    prototype: Response;\n    error(): Response;\n    json(data: any, init?: ResponseInit | undefined): Response;\n    redirect(url: string | URL, status?: number | undefined): Response;\n};\nDeprecated\n\nPlease use native web Response https://developer.mozilla.org/en-US/docs/Web/API/Response\n\nvariable lazyEventHandler\nconst lazyEventHandler: <T extends LazyEventHandler>(\n    factory: T\n) => Awaited<ReturnType<T>>;\nvariable MIMES\nconst MIMES: { html: string; json: string };\nvariable setHeader\nconst setHeader: (\n    event: H3Event<EventHandlerRequest>,\n    name: HTTPHeaderName,\n    value: unknown\n) => void;\nvariable setHeaders\nconst setHeaders: (\n    event: H3Event<EventHandlerRequest>,\n    headers: Record<string, unknown>\n) => void;\nFunctions\nfunction appendCorsHeaders\nappendCorsHeaders: (event: H3Event, options: H3CorsOptions) => void;\nfunction appendCorsPreflightHeaders\nappendCorsPreflightHeaders: (event: H3Event, options: H3CorsOptions) => void;\nfunction appendResponseHeader\nappendResponseHeader: (\n    event: H3Event,\n    name: HTTPHeaderName,\n    value: string\n) => void;\nfunction appendResponseHeaders\nappendResponseHeaders: (event: H3Event, headers: Record<string, string>) => void;\nfunction assertMethod\nassertMethod: (\n    event: H3Event,\n    expected: HTTPMethod | HTTPMethod[],\n    allowHead?: boolean\n) => void;\nfunction callNodeListener\ncallNodeListener: (\n    handler: NodeMiddleware,\n    req: IncomingMessage,\n    res: ServerResponse\n) => Promise<unknown>;\nfunction clearResponseHeaders\nclearResponseHeaders: (event: H3Event, headerNames?: string[]) => void;\n\nRemove all response headers, or only those specified in the headerNames array.\n\nParameter event\n\nH3 event\n\nParameter headerNames\n\nArray of header names to remove\n\nfunction clearSession\nclearSession: (event: H3Event, config: Partial<SessionConfig>) => Promise<void>;\nfunction createApp\ncreateApp: (options?: AppOptions) => App;\nfunction createAppEventHandler\ncreateAppEventHandler: (\n    stack: Stack,\n    options: AppOptions\n) => EventHandler<EventHandlerRequest, Promise<void>>;\nfunction createError\ncreateError: <DataT = any>(\n    input:\n        | string\n        | (Partial<H3Error<DataT>> & { status?: number; statusText?: string })\n) => H3Error;\n\nCreates a new Error that can be used to handle both internal and runtime errors.\n\nParameter input\n\nThe error message or an object containing error properties. {H3Error} - An instance of H3Error.\n\nfunction createEvent\ncreateEvent: (req: IncomingMessage, res: ServerResponse) => H3Event;\n\nCreates a new H3Event instance from the given Node.js request and response objects.\n\nParameter req\n\nThe NodeIncomingMessage object.\n\nParameter res\n\nThe NodeServerResponse object.\n\nReturns\n\nA new H3Event instance.\n\nSee Also\n\nH3Event\n\nfunction createRouter\ncreateRouter: (opts?: CreateRouterOptions) => Router;\nfunction defaultContentType\ndefaultContentType: (event: H3Event, type?: string) => void;\nfunction defineEventHandler\ndefineEventHandler: {\n    <Request extends EventHandlerRequest = EventHandlerRequest, Response = any>(\n        handler:\n            | EventHandler<Request, Response>\n            | EventHandlerObject<Request, Response>\n    ): EventHandler<Request, Response>;\n    <Request = EventHandlerRequest, Response = any>(\n        handler: EventHandler<\n            Request extends EventHandlerRequest ? Request : EventHandlerRequest,\n            Request extends EventHandlerRequest ? Response : Request\n        >\n    ): EventHandler<\n        Request extends EventHandlerRequest ? Request : EventHandlerRequest,\n        Request extends EventHandlerRequest ? Response : Request\n    >;\n};\nfunction defineLazyEventHandler\ndefineLazyEventHandler: <T extends LazyEventHandler>(\n    factory: T\n) => Awaited<ReturnType<T>>;\nfunction defineNodeListener\ndefineNodeListener: (handler: NodeListener) => NodeListener;\nfunction defineNodeMiddleware\ndefineNodeMiddleware: (middleware: NodeMiddleware) => NodeMiddleware;\nfunction defineRequestMiddleware\ndefineRequestMiddleware: <\n    Request extends EventHandlerRequest = EventHandlerRequest\n>(\n    fn: _RequestMiddleware<Request>\n) => _RequestMiddleware<Request>;\nfunction defineResponseMiddleware\ndefineResponseMiddleware: <\n    Request extends EventHandlerRequest = EventHandlerRequest\n>(\n    fn: _ResponseMiddleware<Request>\n) => _ResponseMiddleware<Request>;\nfunction deleteCookie\ndeleteCookie: (\n    event: H3Event,\n    name: string,\n    serializeOptions?: CookieSerializeOptions\n) => void;\n\nRemove a cookie by name.\n\nParameter event\n\nH3 event or res passed by h3 handler\n\nParameter name\n\nName of the cookie to delete\n\nParameter serializeOptions\n\nCookie options\n\ndeleteCookie(res, 'SessionId')\nfunction dynamicEventHandler\ndynamicEventHandler: (initial?: EventHandler) => DynamicEventHandler;\nfunction fetchWithEvent\nfetchWithEvent: <\n    T = unknown,\n    _R = any,\n    F extends (req: RequestInfo | URL, opts?: any) => any = (\n        input: URL | RequestInfo,\n        init?: RequestInit\n    ) => Promise<Response>\n>(\n    event: H3Event,\n    req: RequestInfo | URL,\n    init?: RequestInit & { context?: H3EventContext },\n    options?: { fetch: F }\n) => unknown extends T ? ReturnType<F> : T;\nfunction fromNodeMiddleware\nfromNodeMiddleware: (handler: NodeListener | NodeMiddleware) => EventHandler;\nfunction fromPlainHandler\nfromPlainHandler: (\n    handler: PlainHandler\n) => EventHandler<EventHandlerRequest, Promise<unknown>>;\n\nModifiers\n@experimental\nfunction fromWebHandler\nfromWebHandler: (\n    handler: WebHandler\n) => EventHandler<EventHandlerRequest, Promise<Response>>;\n\nModifiers\n@experimental\nfunction getCookie\ngetCookie: (event: H3Event, name: string) => string | undefined;\n\nGet a cookie value by name.\n\nParameter event\n\nH3 event or req passed by h3 handler\n\nParameter name\n\nName of the cookie to get\n\nReturns\n\n{*} Value of the cookie (String or undefined)\n\nconst authorization = getCookie(request, 'Authorization')\nfunction getMethod\ngetMethod: (event: H3Event, defaultMethod?: HTTPMethod) => HTTPMethod;\nDeprecated\n\nDirectly use event.method instead.\n\nfunction getProxyRequestHeaders\ngetProxyRequestHeaders: (event: H3Event) => any;\nfunction getQuery\ngetQuery: <\n    T,\n    Event extends H3Event<EventHandlerRequest> = H3Event<EventHandlerRequest>,\n    _T = Exclude<InferEventInput<'query', Event, T>, undefined>\n>(\n    event: Event\n) => _T;\nfunction getRequestFingerprint\ngetRequestFingerprint: (\n    event: H3Event,\n    opts?: RequestFingerprintOptions\n) => Promise<string | null>;\n\nBehavior of this utility might change in the future versions\n\nModifiers\n@experimental\nfunction getRequestHeader\ngetRequestHeader: (\n    event: H3Event,\n    name: HTTPHeaderName\n) => RequestHeaders[string];\nfunction getRequestHeaders\ngetRequestHeaders: (event: H3Event) => RequestHeaders;\nfunction getRequestHost\ngetRequestHost: (event: H3Event, opts?: { xForwardedHost?: boolean }) => string;\nfunction getRequestIP\ngetRequestIP: (\n    event: H3Event,\n    opts?: { xForwardedFor?: boolean }\n) => string | undefined;\nfunction getRequestPath\ngetRequestPath: (event: H3Event) => string;\nDeprecated\n\nUse event.path instead\n\nfunction getRequestProtocol\ngetRequestProtocol: (\n    event: H3Event,\n    opts?: { xForwardedProto?: boolean }\n) => 'https' | 'http';\nfunction getRequestURL\ngetRequestURL: (\n    event: H3Event,\n    opts?: { xForwardedHost?: boolean; xForwardedProto?: boolean }\n) => URL;\nfunction getRequestWebStream\ngetRequestWebStream: (event: H3Event) => undefined | ReadableStream;\n\nCaptures a stream from a request.\n\nParameter event\n\nThe H3Event object containing the request information.\n\nReturns\n\nUndefined if the request can't transport a payload, otherwise a ReadableStream of the request body.\n\nfunction getResponseHeader\ngetResponseHeader: (\n    event: H3Event,\n    name: HTTPHeaderName\n) => ReturnType<H3Event['res']['getHeader']>;\nfunction getResponseHeaders\ngetResponseHeaders: (event: H3Event) => ReturnType<H3Event['res']['getHeaders']>;\nfunction getResponseStatus\ngetResponseStatus: (event: H3Event) => number;\nfunction getResponseStatusText\ngetResponseStatusText: (event: H3Event) => string;\nfunction getRouterParam\ngetRouterParam: (\n    event: H3Event,\n    name: string,\n    opts?: { decode?: boolean }\n) => string | undefined;\nfunction getRouterParams\ngetRouterParams: (\n    event: H3Event,\n    opts?: { decode?: boolean }\n) => NonNullable<H3Event['context']['params']>;\nfunction getSession\ngetSession: <T extends SessionDataT = SessionDataT>(\n    event: H3Event,\n    config: SessionConfig\n) => Promise<Session<T>>;\nfunction getValidatedQuery\ngetValidatedQuery: <\n    T,\n    Event extends H3Event<EventHandlerRequest> = H3Event<EventHandlerRequest>,\n    _T = InferEventInput<'query', Event, T>\n>(\n    event: Event,\n    validate: ValidateFunction<_T>\n) => Promise<_T>;\nfunction getValidatedRouterParams\ngetValidatedRouterParams: <\n    T,\n    Event extends H3Event<EventHandlerRequest> = H3Event<EventHandlerRequest>,\n    _T = InferEventInput<'routerParams', Event, T>\n>(\n    event: Event,\n    validate: ValidateFunction<_T>,\n    opts?: { decode?: boolean }\n) => Promise<_T>;\nfunction handleCacheHeaders\nhandleCacheHeaders: (event: H3Event, opts: CacheConditions) => boolean;\n\nCheck request caching headers (If-Modified-Since) and add caching headers (Last-Modified, Cache-Control) Note: public cache control will be added by default\n\nReturns\n\ntrue when cache headers are matching. When true is returned, no reponse should be sent anymore\n\nfunction handleCors\nhandleCors: (event: H3Event, options: H3CorsOptions) => boolean;\nfunction isCorsOriginAllowed\nisCorsOriginAllowed: (\n    origin: ReturnType<typeof getRequestHeaders>['origin'],\n    options: H3CorsOptions\n) => boolean;\nfunction isError\nisError: (input: any) => input is H3Error<any>;\n\nChecks if the given input is an instance of H3Error.\n\nParameter input\n\nThe input to check. {boolean} - Returns true if the input is an instance of H3Error, false otherwise.\n\nfunction isEvent\nisEvent: (input: any) => input is H3Event<EventHandlerRequest>;\n\nChecks if the input is an H3Event object.\n\nParameter input\n\nThe input to check.\n\nReturns\n\nTrue if the input is an H3Event object, false otherwise.\n\nSee Also\n\nH3Event\n\nfunction isEventHandler\nisEventHandler: (input: any) => input is EventHandler<EventHandlerRequest, any>;\n\nChecks if any kind of input is an event handler.\n\nParameter input\n\nThe input to check.\n\nReturns\n\nTrue if the input is an event handler, false otherwise.\n\nfunction isMethod\nisMethod: (\n    event: H3Event,\n    expected: HTTPMethod | HTTPMethod[],\n    allowHead?: boolean\n) => boolean;\nfunction isPreflightRequest\nisPreflightRequest: (event: H3Event) => boolean;\nfunction isStream\nisStream: (data: any) => data is any;\nfunction isWebResponse\nisWebResponse: (data: any) => data is Response;\nfunction parseCookies\nparseCookies: (event: H3Event) => Record<string, string>;\n\nParse the request to get HTTP Cookie header string and returning an object of all cookie name-value pairs.\n\nParameter event\n\nH3 event or req passed by h3 handler\n\nReturns\n\nObject of cookie name-value pairs\n\nconst cookies = parseCookies(event)\nfunction promisifyNodeListener\npromisifyNodeListener: (\n    handler: NodeListener | NodeMiddleware\n) => NodePromisifiedHandler;\nfunction proxyRequest\nproxyRequest: (\n    event: H3Event,\n    target: string,\n    opts?: ProxyOptions\n) => Promise<any>;\nfunction readBody\nreadBody: <\n    T,\n    Event extends H3Event<EventHandlerRequest> = H3Event<EventHandlerRequest>,\n    _T = InferEventInput<'body', Event, T>\n>(\n    event: Event,\n    options?: { strict?: boolean }\n) => Promise<_T>;\n\nReads request body and tries to safely parse using [destr](https://github.com/unjs/destr).\n\nParameter event\n\nH3 event passed by h3 handler\n\nParameter encoding\n\nThe character encoding to use, defaults to 'utf-8'.\n\n{*} The Object, Array, String, Number, Boolean, or null value corresponding to the request JSON body\n\nconst body = await readBody(event)\nfunction readFormData\nreadFormData: (event: H3Event) => Promise<FormData>;\n\nConstructs a FormData object from an event, after converting it to a a web request.\n\nParameter event\n\nThe H3Event object to read the form data from.\n\nconst eventHandler = event => {\n  const formData = await readFormData(event)\n  const email = formData.get(\"email\")\n  const password = formData.get(\"password\")\n }\nfunction readMultipartFormData\nreadMultipartFormData: (event: H3Event) => Promise<MultiPartData[] | undefined>;\n\nTries to read and parse the body of a an H3Event as multipart form.\n\nParameter event\n\nThe H3Event object to read multipart form from.\n\nThe parsed form data. If no form could be detected because the content type is not multipart/form-data or no boundary could be found.\n\nconst formData = await readMultipartFormData(event)\n// The result could look like:\n// [\n//   {\n//     \"data\": \"other\",\n//     \"name\": \"baz\",\n//   },\n//   {\n//     \"data\": \"something\",\n//     \"name\": \"some-other-data\",\n//   },\n// ]\nfunction readRawBody\nreadRawBody: <E extends Encoding = 'utf8'>(\n    event: H3Event,\n    encoding?: E\n) => E extends false ? Promise<Buffer | undefined> : Promise<string | undefined>;\n\nReads body of the request and returns encoded raw string (default), or Buffer if encoding is falsy.\n\nParameter event\n\nH3 event or req passed by h3 handler\n\nParameter encoding\n\nencoding=\"utf-8\" - The character encoding to use.\n\n{String|Buffer} Encoded raw string or raw Buffer of the body\n\nfunction readValidatedBody\nreadValidatedBody: <\n    T,\n    Event extends H3Event<EventHandlerRequest> = H3Event<EventHandlerRequest>,\n    _T = InferEventInput<'body', Event, T>\n>(\n    event: Event,\n    validate: ValidateFunction<_T>\n) => Promise<_T>;\n\nTries to read the request body via readBody, then uses the provided validation function and either throws a validation error or returns the result.\n\nParameter event\n\nThe H3Event passed by the handler.\n\nParameter validate\n\nThe function to use for body validation. It will be called passing the read request body. If the result is not false, the parsed body will be returned.\n\nThrows\n\nIf the validation function returns false or throws, a validation error will be thrown. {*} The Object, Array, String, Number, Boolean, or null value corresponding to the request JSON body.\n\nSee Also\n\n{readBody}\n\n// With a custom validation function\nconst body = await readValidatedBody(event, (body) => {\n  return typeof body === \"object\" && body !== null\n})\n\n\n// With a zod schema\nimport { z } from 'zod'\nconst objectSchema = z.object()\nconst body = await readValidatedBody(event, objectSchema.safeParse)\nfunction removeResponseHeader\nremoveResponseHeader: (event: H3Event, name: HTTPHeaderName) => void;\nfunction sanitizeStatusCode\nsanitizeStatusCode: (\n    statusCode?: string | number,\n    defaultStatusCode?: number\n) => number;\nfunction sanitizeStatusMessage\nsanitizeStatusMessage: (statusMessage?: string) => string;\nfunction sealSession\nsealSession: <T extends SessionDataT = SessionDataT>(\n    event: H3Event,\n    config: SessionConfig\n) => Promise<string>;\nfunction send\nsend: (event: H3Event, data?: any, type?: string) => Promise<void>;\nfunction sendError\nsendError: (event: H3Event, error: Error | H3Error, debug?: boolean) => void;\n\nReceives an error and returns the corresponding response. H3 internally uses this function to handle unhandled errors. Note that calling this function will close the connection and no other data will be sent to the client afterwards.\n\nParameter event\n\nH3 event or req passed by h3 handler.\n\nParameter error\n\nThe raised error.\n\nParameter debug\n\nWhether the application is in debug mode. In the debug mode, the stack trace of errors will be returned in the response.\n\nfunction sendNoContent\nsendNoContent: (event: H3Event, code?: number) => void;\n\nRespond with an empty payload. Note that calling this function will close the connection and no other data can be sent to the client afterwards.\n\nParameter event\n\nH3 event\n\nParameter code\n\nstatus code to be send. By default, it is 204 No Content.\n\nfunction sendProxy\nsendProxy: (event: H3Event, target: string, opts?: ProxyOptions) => Promise<any>;\nfunction sendRedirect\nsendRedirect: (event: H3Event, location: string, code?: number) => Promise<void>;\nfunction sendStream\nsendStream: (event: H3Event, stream: Readable | ReadableStream) => Promise<void>;\nfunction sendWebResponse\nsendWebResponse: (event: H3Event, response: Response) => void | Promise<void>;\nfunction serveStatic\nserveStatic: (\n    event: H3Event,\n    options: ServeStaticOptions\n) => Promise<void | false>;\nfunction setCookie\nsetCookie: (\n    event: H3Event,\n    name: string,\n    value: string,\n    serializeOptions?: CookieSerializeOptions\n) => void;\n\nSet a cookie value by name.\n\nParameter event\n\nH3 event or res passed by h3 handler\n\nParameter name\n\nName of the cookie to set\n\nParameter value\n\nValue of the cookie to set\n\nParameter serializeOptions\n\nOptions for serializing the cookie\n\nsetCookie(res, 'Authorization', '1234567')\nfunction setResponseHeader\nsetResponseHeader: (\n    event: H3Event,\n    name: HTTPHeaderName,\n    value: Parameters<OutgoingMessage['setHeader']>[1]\n) => void;\nfunction setResponseHeaders\nsetResponseHeaders: (\n    event: H3Event,\n    headers: Record<string, Parameters<OutgoingMessage['setHeader']>[1]>\n) => void;\nfunction setResponseStatus\nsetResponseStatus: (event: H3Event, code?: number, text?: string) => void;\nfunction splitCookiesString\nsplitCookiesString: (cookiesString: string | string[]) => string[];\n\nSet-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas that are within a single set-cookie field-value, such as in the Expires portion. This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2 Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128 Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25 Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation https://github.com/nfriedly/set-cookie-parser/blob/3eab8b7d5d12c8ed87832532861c1a35520cf5b3/lib/set-cookie.js#L144\n\nfunction toEventHandler\ntoEventHandler: (input: any, _?: any, _route?: string) => EventHandler;\nfunction toNodeListener\ntoNodeListener: (app: App) => NodeListener;\nfunction toPlainHandler\ntoPlainHandler: (app: App) => PlainHandler;\n\nModifiers\n@experimental\nfunction toWebHandler\ntoWebHandler: (app: App) => WebHandler;\n\nModifiers\n@experimental\nfunction toWebRequest\ntoWebRequest: (event: H3Event) => Request;\nfunction unsealSession\nunsealSession: (\n    _event: H3Event,\n    config: SessionConfig,\n    sealed: string\n) => Promise<Partial<Session<SessionDataT>>>;\nfunction updateSession\nupdateSession: <T extends SessionDataT = SessionDataT>(\n    event: H3Event,\n    config: SessionConfig,\n    update?: SessionUpdate<T>\n) => Promise<Session<T>>;\nfunction use\nuse: (\n    app: App,\n    arg1: string | EventHandler | InputLayer | InputLayer[],\n    arg2?: Partial<InputLayer> | EventHandler | EventHandler[],\n    arg3?: Partial<InputLayer>\n) => App;\nfunction useBase\nuseBase: (base: string, handler: EventHandler) => EventHandler;\n\nPrefixes and executes a handler with a base path.\n\nParameter base\n\nThe base path to prefix. When set to an empty string, the handler will be run as is.\n\nParameter handler\n\nThe event handler to use with the adapted path.\n\nfunction useSession\nuseSession: <T extends SessionDataT = SessionDataT>(\n    event: H3Event,\n    config: SessionConfig\n) => Promise<{\n    readonly id: string | undefined;\n    readonly data: T;\n    update: (update: SessionUpdate<T>) => Promise<any>;\n    clear: () => Promise<any>;\n}>;\nfunction writeEarlyHints\nwriteEarlyHints: (\n    event: H3Event,\n    hints: string | string[] | Record<string, string | string[]>,\n    cb?: () => void\n) => void;\nClasses\nclass H3Error\nclass H3Error<DataT = any> extends Error {}\n\nH3 Runtime Error Error {number} statusCode - An integer indicating the HTTP response status code. {string} statusMessage - A string representing the HTTP status message. {boolean} fatal - Indicates if the error is a fatal error. {boolean} unhandled - Indicates if the error was unhandled and auto captured. {DataT} data - An extra data that will be included in the response. This can be used to pass additional information about the error. {boolean} internal - Setting this property to true will mark the error as an internal error.\n\nconstructor\nconstructor(message: string, opts?: { cause?: unknown });\nproperty cause\ncause?: {};\nproperty data\ndata?: {};\nproperty fatal\nfatal: boolean;\nproperty statusCode\nstatusCode: number;\nproperty statusMessage\nstatusMessage?: string;\nproperty unhandled\nunhandled: boolean;\nmethod toJSON\ntoJSON: () => Pick<\n    H3Error<DataT>,\n    'data' | 'statusCode' | 'statusMessage' | 'message'\n>;\nclass H3Event\nclass H3Event<_RequestT extends EventHandlerRequest = EventHandlerRequest>\n    implements Pick<FetchEvent, 'respondWith'> {}\nconstructor\nconstructor(req: IncomingMessage, res: ServerResponse);\nproperty \"__is_event__\"\n'__is_event__': boolean;\nproperty context\ncontext: H3EventContext;\nproperty handled\nreadonly handled: boolean;\nproperty headers\nreadonly headers: Headers;\nproperty method\nreadonly method: HTTPMethod;\nproperty node\nnode: NodeEventContext;\nproperty path\nreadonly path: string;\nproperty req\nreadonly req: any;\nDeprecated\n\nPlease use event.node.req instead. *\n\nproperty res\nreadonly res: ServerResponse<IncomingMessage>;\nDeprecated\n\nPlease use event.node.res instead. *\n\nproperty web\nweb?: WebEventContext;\nmethod respondWith\nrespondWith: (response: Response | PromiseLike<Response>) => Promise<void>;\nmethod toJSON\ntoJSON: () => string;\nmethod toString\ntoString: () => string;\nInterfaces\ninterface App\ninterface App {}\nproperty handler\nhandler: EventHandler;\nproperty options\noptions: AppOptions;\nproperty stack\nstack: Stack;\nproperty use\nuse: AppUse;\ninterface AppOptions\ninterface AppOptions {}\nproperty debug\ndebug?: boolean;\nproperty onAfterResponse\nonAfterResponse?: (\n    event: H3Event,\n    response?: {\n        body?: unknown;\n    }\n) => void | Promise<void>;\nproperty onBeforeResponse\nonBeforeResponse?: (\n    event: H3Event,\n    response: {\n        body?: unknown;\n    }\n) => void | Promise<void>;\nproperty onError\nonError?: (error: H3Error, event: H3Event) => any;\nproperty onRequest\nonRequest?: (event: H3Event) => void | Promise<void>;\ninterface AppUse\ninterface AppUse {}\ncall signature\n(\n    route: string | string[],\n    handler: EventHandler | EventHandler[],\n    options?: Partial<InputLayer>\n): App;\ncall signature\n(handler: EventHandler | EventHandler[], options?: Partial<InputLayer>): App;\ncall signature\n(options: InputLayer): App;\ninterface CacheConditions\ninterface CacheConditions {}\nproperty cacheControls\ncacheControls?: string[];\nproperty etag\netag?: string;\nproperty maxAge\nmaxAge?: number;\nproperty modifiedTime\nmodifiedTime?: string | Date;\ninterface CreateRouterOptions\ninterface CreateRouterOptions {}\nproperty preemptive\npreemptive?: boolean;\nproperty preemtive\npreemtive?: boolean;\nDeprecated\n\nPlease use preemptive instead. *\n\ninterface DynamicEventHandler\ninterface DynamicEventHandler extends EventHandler {}\nproperty set\nset: (handler: EventHandler) => void;\ninterface EventHandler\ninterface EventHandler<\n    Request extends EventHandlerRequest = EventHandlerRequest,\n    Response extends EventHandlerResponse = EventHandlerResponse\n> {}\ncall signature\n(event: H3Event<Request>): Response;\ninterface EventHandlerRequest\ninterface EventHandlerRequest {}\nproperty body\nbody?: any;\nproperty query\nquery?: QueryObject;\nproperty routerParams\nrouterParams?: Record<string, string>;\ninterface H3CorsOptions\ninterface H3CorsOptions {}\nproperty allowHeaders\nallowHeaders?: '*' | string[];\nproperty credentials\ncredentials?: boolean;\nproperty exposeHeaders\nexposeHeaders?: '*' | string[];\nproperty maxAge\nmaxAge?: string | false;\nproperty methods\nmethods?: '*' | HTTPMethod[];\nproperty origin\norigin?: '*' | 'null' | (string | RegExp)[] | ((origin: string) => boolean);\nproperty preflight\npreflight?: {\n    statusCode?: number;\n};\ninterface H3EventContext\ninterface H3EventContext extends Record<string, any> {}\nproperty clientAddress\nclientAddress?: string;\nproperty matchedRoute\nmatchedRoute?: RouteNode;\n\nMatched router Node\n\nThe object structure may change in non-major version.\n\nModifiers\n@experimental\nproperty params\nparams?: Record<string, string>;\nproperty sessions\nsessions?: Record<string, Session>;\ninterface InputLayer\ninterface InputLayer {}\nproperty handler\nhandler: EventHandler;\nproperty lazy\nlazy?: boolean;\nproperty match\nmatch?: Matcher;\nproperty route\nroute?: string;\ninterface Layer\ninterface Layer {}\nproperty handler\nhandler: EventHandler;\nproperty match\nmatch?: Matcher;\nproperty route\nroute: string;\ninterface MultiPartData\ninterface MultiPartData {}\nproperty data\ndata: Buffer;\nproperty filename\nfilename?: string;\nproperty name\nname?: string;\nproperty type\ntype?: string;\ninterface NodeEventContext\ninterface NodeEventContext {}\nproperty req\nreq: IncomingMessage & {\n    originalUrl?: string;\n};\nproperty res\nres: ServerResponse;\ninterface PlainRequest\ninterface PlainRequest {}\nproperty body\nbody?: null | BodyInit;\nproperty context\ncontext?: Record<string, unknown>;\nproperty headers\nheaders: HeadersInit;\nproperty method\nmethod: string;\nproperty path\npath: string;\ninterface PlainResponse\ninterface PlainResponse {}\nproperty body\nbody?: unknown;\nproperty headers\nheaders: [string, string][];\nproperty status\nstatus: number;\nproperty statusText\nstatusText: string;\ninterface ProxyOptions\ninterface ProxyOptions {}\nproperty cookieDomainRewrite\ncookieDomainRewrite?: string | Record<string, string>;\nproperty cookiePathRewrite\ncookiePathRewrite?: string | Record<string, string>;\nproperty fetch\nfetch?: typeof fetch;\nproperty fetchOptions\nfetchOptions?: RequestInit & {\n    duplex?: Duplex;\n} & {\n    ignoreResponseError?: boolean;\n};\nproperty headers\nheaders?: RequestHeaders | HeadersInit;\nproperty onResponse\nonResponse?: (event: H3Event, response: Response) => void;\nproperty sendStream\nsendStream?: boolean;\nproperty streamRequest\nstreamRequest?: boolean;\ninterface RequestFingerprintOptions\ninterface RequestFingerprintOptions {}\nproperty hash\nhash?: false | 'SHA-1';\n\nSHA-1\n\nproperty ip\nip?: boolean;\n\ntrue\n\nproperty method\nmethod?: boolean;\n\nfalse\n\nproperty path\npath?: boolean;\n\nfalse\n\nproperty userAgent\nuserAgent?: boolean;\n\nfalse\n\nproperty xForwardedFor\nxForwardedFor?: boolean;\n\nfalse\n\ninterface RouteNode\ninterface RouteNode {}\nproperty handlers\nhandlers: Partial<Record<RouterMethod | 'all', EventHandler>>;\nproperty path\npath: string;\ninterface Router\ninterface Router extends AddRouteShortcuts {}\nproperty add\nadd: RouterUse;\nproperty handler\nhandler: EventHandler;\nproperty use\nuse: RouterUse;\ninterface ServeStaticOptions\ninterface ServeStaticOptions {}\nproperty encodings\nencodings?: Record<string, string>;\n\nMap of supported encodings (compressions) and their file extensions.\n\nEach extension will be appended to the asset path to find the compressed version of the asset.\n\nExample 1\n\n{ gzip: \".gz\", br: \".br\" }\n\nproperty fallthrough\nfallthrough?: boolean;\n\nWhen set to true, the function will not throw 404 error when the asset meta is not found or meta validation failed\n\nproperty getContents\ngetContents: (id: string) => unknown | Promise<unknown>;\n\nThis function should resolve asset content\n\nproperty getMeta\ngetMeta: (\n    id: string\n) => StaticAssetMeta | undefined | Promise<StaticAssetMeta | undefined>;\n\nThis function should resolve asset meta\n\nproperty indexNames\nindexNames?: string[];\n\nDefault index file to serve when the path is a directory\n\n[\"/index.html\"]\n\ninterface Session\ninterface Session<T extends SessionDataT = SessionDataT> {}\nproperty createdAt\ncreatedAt: number;\nproperty data\ndata: SessionData<T>;\nproperty id\nid: string;\ninterface SessionConfig\ninterface SessionConfig {}\nproperty cookie\ncookie?: false | CookieSerializeOptions;\n\nDefault is secure, httpOnly, /\n\nproperty crypto\ncrypto?: Crypto;\nproperty generateId\ngenerateId?: () => string;\n\nDefault is Crypto.randomUUID\n\nproperty maxAge\nmaxAge?: number;\n\nSession expiration time in seconds\n\nproperty name\nname?: string;\n\ndefault is h3\n\nproperty password\npassword: string;\n\nPrivate key used to encrypt session tokens\n\nproperty seal\nseal?: SealOptions;\nproperty sessionHeader\nsessionHeader?: false | string;\n\nDefault is x-h3-session / x-{name}-session\n\ninterface StaticAssetMeta\ninterface StaticAssetMeta {}\nproperty encoding\nencoding?: string;\nproperty etag\netag?: string;\nproperty mtime\nmtime?: number | string | Date;\nproperty path\npath?: string;\nproperty size\nsize?: number;\nproperty type\ntype?: string;\ninterface WebEventContext\ninterface WebEventContext {}\nproperty request\nrequest?: Request;\nproperty url\nurl?: URL;\nType Aliases\ntype AddRouteShortcuts\ntype AddRouteShortcuts = Record<RouterMethod, RouterUse>;\ntype Duplex\ntype Duplex = 'half' | 'full';\ntype Encoding\ntype Encoding =\n    | false\n    | 'ascii'\n    | 'utf8'\n    | 'utf-8'\n    | 'utf16le'\n    | 'ucs2'\n    | 'ucs-2'\n    | 'base64'\n    | 'latin1'\n    | 'binary'\n    | 'hex';\ntype EventHandlerObject\ntype EventHandlerObject<\n    Request extends EventHandlerRequest = EventHandlerRequest,\n    Response extends EventHandlerResponse = EventHandlerResponse\n> = {\n    onRequest?: _RequestMiddleware<Request> | _RequestMiddleware<Request>[];\n    onBeforeResponse?:\n        | _ResponseMiddleware<Request, Response>\n        | _ResponseMiddleware<Request, Response>[];\n    handler: EventHandler<Request, Response>;\n};\ntype EventHandlerResponse\ntype EventHandlerResponse<T = any> = T | Promise<T>;\ntype HTTPHeaderName\ntype HTTPHeaderName = _HTTPHeaderName | Lowercase<_HTTPHeaderName> | (string & {});\ntype HTTPMethod\ntype HTTPMethod =\n    | 'GET'\n    | 'HEAD'\n    | 'PATCH'\n    | 'POST'\n    | 'PUT'\n    | 'DELETE'\n    | 'CONNECT'\n    | 'OPTIONS'\n    | 'TRACE';\ntype InferEventInput\ntype InferEventInput<\n    Key extends keyof EventHandlerRequest,\n    Event extends H3Event,\n    T\n> = void extends T ? (Event extends H3Event<infer E> ? E[Key] : never) : T;\ntype InputStack\ntype InputStack = InputLayer[];\ntype LazyEventHandler\ntype LazyEventHandler = () => EventHandler | Promise<EventHandler>;\ntype Matcher\ntype Matcher = (url: string, event?: H3Event) => boolean;\ntype NodeListener\ntype NodeListener = (req: IncomingMessage, res: ServerResponse) => void;\ntype NodeMiddleware\ntype NodeMiddleware = (\n    req: IncomingMessage,\n    res: ServerResponse,\n    next: (err?: Error) => any\n) => any;\ntype NodePromisifiedHandler\ntype NodePromisifiedHandler = (\n    req: IncomingMessage,\n    res: ServerResponse\n) => Promise<any>;\ntype PlainHandler\ntype PlainHandler = (request: PlainRequest) => Promise<PlainResponse>;\ntype RequestHeaders\ntype RequestHeaders = Partial<Record<HTTPHeaderName, string | undefined>>;\ntype RouterMethod\ntype RouterMethod = Lowercase<HTTPMethod>;\ntype RouterUse\ntype RouterUse = (\n    path: string,\n    handler: EventHandler,\n    method?: RouterMethod | RouterMethod[]\n) => Router;\ntype SessionData\ntype SessionData<T extends SessionDataT = SessionDataT> = T;\ntype Stack\ntype Stack = Layer[];\ntype ValidateFunction\ntype ValidateFunction<T> = (\n    data: unknown\n) => ValidateResult<T> | Promise<ValidateResult<T>>;\ntype ValidateResult\ntype ValidateResult<T> = T | true | false | void;\ntype WebHandler\ntype WebHandler = (\n    request: Request,\n    context?: Record<string, unknown>\n) => Promise<Response>;\n\nModifiers\n@experimental\nPackage Files (1)\ndist/index.d.ts\nDependencies (8)\ncookie-es\ndefu\ndestr\niron-webcrypto\nradix3\nufo\nuncrypto\nunenv\nDev Dependencies (23)\n@types/express\n@types/node\n@types/supertest\n@vitest/coverage-v8\n0x\nautocannon\nchangelogen\nconnect\neslint\neslint-config-unjs\nexpress\nget-port\njiti\nlisthen\nnode-fetch-native\nprettier\nreact\nreact-dom\nsupertest\ntypescript\nunbuild\nvitest\nzod\nPeer Dependencies (0)\n\nNo peer dependencies."
  }
]
